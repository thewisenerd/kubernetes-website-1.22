<!doctype html><html lang=en class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/configuration/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/configuration/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/configuration/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/configuration/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/configuration/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/configuration/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/configuration/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/configuration/>
<link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/configuration/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/docs/concepts/configuration/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>Configuration | Kubernetes</title><meta property="og:title" content="Configuration">
<meta property="og:description" content="Resources that Kubernetes provides for configuring Pods.
">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/docs/concepts/configuration/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="Configuration">
<meta itemprop=description content="Resources that Kubernetes provides for configuring Pods.
"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Configuration">
<meta name=twitter:description content="Resources that Kubernetes provides for configuring Pods.
">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="Resources that Kubernetes provides for configuring Pods.
">
<meta property="og:description" content="Resources that Kubernetes provides for configuring Pods.
">
<meta name=twitter:description content="Resources that Kubernetes provides for configuring Pods.
">
<meta property="og:url" content="https://kubernetes.io/docs/concepts/configuration/">
<meta property="og:title" content="Configuration">
<meta name=twitter:title content="Configuration">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/docs/>Documentation</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/blog/>Kubernetes Blog</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/training/>Training</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/partners/>Partners</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/community/>Community</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/case-studies/>Case Studies</span></a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Versions
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/docs/concepts/configuration/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/docs/concepts/configuration/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/docs/concepts/configuration/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/docs/concepts/configuration/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/docs/concepts/configuration/>v1.22</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
English
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/zh/docs/concepts/configuration/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/concepts/configuration/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/concepts/configuration/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/configuration/>Français</a>
<a class=dropdown-item href=/de/docs/concepts/configuration/>Deutsch</a>
<a class=dropdown-item href=/es/docs/concepts/configuration/>Español</a>
<a class=dropdown-item href=/pt-br/docs/concepts/configuration/>Português</a>
<a class=dropdown-item href=/id/docs/concepts/configuration/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/configuration/>Українська</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
This the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.
</p><p>
<a href=/docs/concepts/configuration/>Return to the regular view of this page</a>.
</p>
</div>
<h1 class=title>Configuration</h1>
<div class=lead>Resources that Kubernetes provides for configuring Pods.</div>
<ul>
<li>1: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>Configuration Best Practices</a></li>
<li>2: <a href=#pg-6b5ccadd699df0904e8e9917c5450c4b>ConfigMaps</a></li>
<li>3: <a href=#pg-e511ed821ada65d0053341dbd8ad2bb5>Secrets</a></li>
<li>4: <a href=#pg-436057b96151ecb8a4a9a9f456b5d0fc>Managing Resources for Containers</a></li>
<li>5: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>Organizing Cluster Access Using kubeconfig Files</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>1 - Configuration Best Practices</h1>
<p>This document highlights and consolidates configuration best practices that are introduced throughout the user guide, Getting Started documentation, and examples.</p>
<p>This is a living document. If you think of something that is not on this list but might be useful to others, please don't hesitate to file an issue or submit a PR.</p>
<h2 id=general-configuration-tips>General Configuration Tips</h2>
<ul>
<li>
<p>When defining configurations, specify the latest stable API version.</p>
</li>
<li>
<p>Configuration files should be stored in version control before being pushed to the cluster. This allows you to quickly roll back a configuration change if necessary. It also aids cluster re-creation and restoration.</p>
</li>
<li>
<p>Write your configuration files using YAML rather than JSON. Though these formats can be used interchangeably in almost all scenarios, YAML tends to be more user-friendly.</p>
</li>
<li>
<p>Group related objects into a single file whenever it makes sense. One file is often easier to manage than several. See the <a href=https://github.com/kubernetes/examples/tree/master/guestbook/all-in-one/guestbook-all-in-one.yaml>guestbook-all-in-one.yaml</a> file as an example of this syntax.</p>
</li>
<li>
<p>Note also that many <code>kubectl</code> commands can be called on a directory. For example, you can call <code>kubectl apply</code> on a directory of config files.</p>
</li>
<li>
<p>Don't specify default values unnecessarily: simple, minimal configuration will make errors less likely.</p>
</li>
<li>
<p>Put object descriptions in annotations, to allow better introspection.</p>
</li>
</ul>
<h2 id=naked-pods-vs-replicasets-deployments-and-jobs>"Naked" Pods versus ReplicaSets, Deployments, and Jobs</h2>
<ul>
<li>
<p>Don't use naked Pods (that is, Pods not bound to a <a href=/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> or <a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a>) if you can avoid it. Naked Pods will not be rescheduled in the event of a node failure.</p>
<p>A Deployment, which both creates a ReplicaSet to ensure that the desired number of Pods is always available, and specifies a strategy to replace Pods (such as <a href=/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment>RollingUpdate</a>), is almost always preferable to creating Pods directly, except for some explicit <a href=/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>restartPolicy: Never</code></a> scenarios. A <a href=/docs/concepts/workloads/controllers/job/>Job</a> may also be appropriate.</p>
</li>
</ul>
<h2 id=services>Services</h2>
<ul>
<li>
<p>Create a <a href=/docs/concepts/services-networking/service/>Service</a> before its corresponding backend workloads (Deployments or ReplicaSets), and before any workloads that need to access it. When Kubernetes starts a container, it provides environment variables pointing to all the Services which were running when the container was started. For example, if a Service named <code>foo</code> exists, all containers will get the following variables in their initial environment:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;the host the Service is running on&gt;
<span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;the port the Service is running on&gt;
</code></pre></div><p><em>This does imply an ordering requirement</em> - any <code>Service</code> that a <code>Pod</code> wants to access must be created before the <code>Pod</code> itself, or else the environment variables will not be populated. DNS does not have this restriction.</p>
</li>
<li>
<p>An optional (though strongly recommended) <a href=/docs/concepts/cluster-administration/addons/>cluster add-on</a> is a DNS server. The
DNS server watches the Kubernetes API for new <code>Services</code> and creates a set of DNS records for each. If DNS has been enabled throughout the cluster then all <code>Pods</code> should be able to do name resolution of <code>Services</code> automatically.</p>
</li>
<li>
<p>Don't specify a <code>hostPort</code> for a Pod unless it is absolutely necessary. When you bind a Pod to a <code>hostPort</code>, it limits the number of places the Pod can be scheduled, because each &lt;<code>hostIP</code>, <code>hostPort</code>, <code>protocol</code>> combination must be unique. If you don't specify the <code>hostIP</code> and <code>protocol</code> explicitly, Kubernetes will use <code>0.0.0.0</code> as the default <code>hostIP</code> and <code>TCP</code> as the default <code>protocol</code>.</p>
<p>If you only need access to the port for debugging purposes, you can use the <a href=/docs/tasks/access-application-cluster/access-cluster/#manually-constructing-apiserver-proxy-urls>apiserver proxy</a> or <a href=/docs/tasks/access-application-cluster/port-forward-access-application-cluster/><code>kubectl port-forward</code></a>.</p>
<p>If you explicitly need to expose a Pod's port on the node, consider using a <a href=/docs/concepts/services-networking/service/#type-nodeport>NodePort</a> Service before resorting to <code>hostPort</code>.</p>
</li>
<li>
<p>Avoid using <code>hostNetwork</code>, for the same reasons as <code>hostPort</code>.</p>
</li>
<li>
<p>Use <a href=/docs/concepts/services-networking/service/#headless-services>headless Services</a> (which have a <code>ClusterIP</code> of <code>None</code>) for service discovery when you don't need <code>kube-proxy</code> load balancing.</p>
</li>
</ul>
<h2 id=using-labels>Using Labels</h2>
<ul>
<li>Define and use <a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> that identify <strong>semantic attributes</strong> of your application or Deployment, such as <code>{ app: myapp, tier: frontend, phase: test, deployment: v3 }</code>. You can use these labels to select the appropriate Pods for other resources; for example, a Service that selects all <code>tier: frontend</code> Pods, or all <code>phase: test</code> components of <code>app: myapp</code>. See the <a href=https://github.com/kubernetes/examples/tree/master/guestbook/>guestbook</a> app for examples of this approach.</li>
</ul>
<p>A Service can be made to span multiple Deployments by omitting release-specific labels from its selector. When you need to update a running service without downtime, use a <a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a>.</p>
<p>A desired state of an object is described by a Deployment, and if changes to that spec are <em>applied</em>, the deployment controller changes the actual state to the desired state at a controlled rate.</p>
<ul>
<li>
<p>Use the <a href=/docs/concepts/overview/working-with-objects/common-labels/>Kubernetes common labels</a> for common use cases. These standardized labels enrich the metadata in a way that allows tools, including <code>kubectl</code> and <a href=/docs/tasks/access-application-cluster/web-ui-dashboard>dashboard</a>, to work in an interoperable way.</p>
</li>
<li>
<p>You can manipulate labels for debugging. Because Kubernetes controllers (such as ReplicaSet) and Services match to Pods using selector labels, removing the relevant labels from a Pod will stop it from being considered by a controller or from being served traffic by a Service. If you remove the labels of an existing Pod, its controller will create a new Pod to take its place. This is a useful way to debug a previously "live" Pod in a "quarantine" environment. To interactively remove or add labels, use <a href=/docs/reference/generated/kubectl/kubectl-commands#label><code>kubectl label</code></a>.</p>
</li>
</ul>
<h2 id=using-kubectl>Using kubectl</h2>
<ul>
<li>
<p>Use <code>kubectl apply -f &lt;directory></code>. This looks for Kubernetes configuration in all <code>.yaml</code>, <code>.yml</code>, and <code>.json</code> files in <code>&lt;directory></code> and passes it to <code>apply</code>.</p>
</li>
<li>
<p>Use label selectors for <code>get</code> and <code>delete</code> operations instead of specific object names. See the sections on <a href=/docs/concepts/overview/working-with-objects/labels/#label-selectors>label selectors</a> and <a href=/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively>using labels effectively</a>.</p>
</li>
<li>
<p>Use <code>kubectl create deployment</code> and <code>kubectl expose</code> to quickly create single-container Deployments and Services. See <a href=/docs/tasks/access-application-cluster/service-access-application-cluster/>Use a Service to Access an Application in a Cluster</a> for an example.</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6b5ccadd699df0904e8e9917c5450c4b>2 - ConfigMaps</h1>
<p><p>A ConfigMap is an API object used to store non-confidential data in key-value pairs.
<a class=glossary-tooltip title="A Pod represents a set of running containers in your cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> can consume ConfigMaps as
environment variables, command-line arguments, or as configuration files in a
<a class=glossary-tooltip title="A directory containing data, accessible to the containers in a pod." data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a>.</p></p>
<p>A ConfigMap allows you to decouple environment-specific configuration from your <a class=glossary-tooltip title="Stored instance of a container that holds a set of software needed to run an application." data-toggle=tooltip data-placement=top href="/docs/reference/glossary/?all=true#term-image" target=_blank aria-label="container images">container images</a>, so that your applications are easily portable.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> ConfigMap does not provide secrecy or encryption.
If the data you want to store are confidential, use a
<a class=glossary-tooltip title="Stores sensitive information, such as passwords, OAuth tokens, and ssh keys." data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> rather than a ConfigMap,
or use additional (third party) tools to keep your data private.
</div>
<h2 id=motivation>Motivation</h2>
<p>Use a ConfigMap for setting configuration data separately from application code.</p>
<p>For example, imagine that you are developing an application that you can run on your
own computer (for development) and in the cloud (to handle real traffic).
You write the code to look in an environment variable named <code>DATABASE_HOST</code>.
Locally, you set that variable to <code>localhost</code>. In the cloud, you set it to
refer to a Kubernetes <a class=glossary-tooltip title="A way to expose an application running on a set of Pods as a network service." data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>
that exposes the database component to your cluster.
This lets you fetch a container image running in the cloud and
debug the exact same code locally if needed.</p>
<p>A ConfigMap is not designed to hold large chunks of data. The data stored in a
ConfigMap cannot exceed 1 MiB. If you need to store settings that are
larger than this limit, you may want to consider mounting a volume or use a
separate database or file service.</p>
<h2 id=configmap-object>ConfigMap object</h2>
<p>A ConfigMap is an API <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/>object</a>
that lets you store configuration for other objects to use. Unlike most
Kubernetes objects that have a <code>spec</code>, a ConfigMap has <code>data</code> and <code>binaryData</code>
fields. These fields accept key-value pairs as their values. Both the <code>data</code>
field and the <code>binaryData</code> are optional. The <code>data</code> field is designed to
contain UTF-8 byte sequences while the <code>binaryData</code> field is designed to
contain binary data as base64-encoded strings.</p>
<p>The name of a ConfigMap must be a valid
<a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS subdomain name</a>.</p>
<p>Each key under the <code>data</code> or the <code>binaryData</code> field must consist of
alphanumeric characters, <code>-</code>, <code>_</code> or <code>.</code>. The keys stored in <code>data</code> must not
overlap with the keys in the <code>binaryData</code> field.</p>
<p>Starting from v1.19, you can add an <code>immutable</code> field to a ConfigMap
definition to create an <a href=#configmap-immutable>immutable ConfigMap</a>.</p>
<h2 id=configmaps-and-pods>ConfigMaps and Pods</h2>
<p>You can write a Pod <code>spec</code> that refers to a ConfigMap and configures the container(s)
in that Pod based on the data in the ConfigMap. The Pod and the ConfigMap must be in
the same <a class=glossary-tooltip title="An abstraction used by Kubernetes to support multiple virtual clusters on the same physical cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> The <code>spec</code> of a <a class=glossary-tooltip title="A pod managed directly by the kubelet daemon on a specific node." data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label="static Pod">static Pod</a> cannot refer to a ConfigMap
or any other API objects.
</div>
<p>Here's an example ConfigMap that has some keys with single values,
and other keys where the value looks like a fragment of a configuration
format.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># property-like keys; each key maps to a simple value</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>player_initial_lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui_properties_file_name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># file-like keys</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    enemy.types=aliens,monsters
</span><span style=color:#b44;font-style:italic>    player.maximum-lives=5</span><span style=color:#bbb>    
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user-interface.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    color.good=purple
</span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span><span style=color:#b44;font-style:italic>    allow.textmode=true</span><span style=color:#bbb>    
</span></code></pre></div><p>There are four different ways that you can use a ConfigMap to configure
a container inside a Pod:</p>
<ol>
<li>Inside a container command and args</li>
<li>Environment variables for a container</li>
<li>Add a file in read-only volume, for the application to read</li>
<li>Write code to run inside the Pod that uses the Kubernetes API to read a ConfigMap</li>
</ol>
<p>These different methods lend themselves to different ways of modeling
the data being consumed.
For the first three methods, the
<a class=glossary-tooltip title="An agent that runs on each node in the cluster. It makes sure that containers are running in a pod." data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> uses the data from
the ConfigMap when it launches container(s) for a Pod.</p>
<p>The fourth method means you have to write code to read the ConfigMap and its data.
However, because you're using the Kubernetes API directly, your application can
subscribe to get updates whenever the ConfigMap changes, and react
when that happens. By accessing the Kubernetes API directly, this
technique also lets you access a ConfigMap in a different namespace.</p>
<p>Here's an example Pod that uses values from <code>game-demo</code> to configure a Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-demo-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>alpine<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;3600&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Define the environment variable</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PLAYER_INITIAL_LIVES<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Notice that the case is different here</span><span style=color:#bbb>
</span><span style=color:#bbb>                                     </span><span style=color:#080;font-style:italic># from the key name in the ConfigMap.</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo          <span style=color:#bbb> </span><span style=color:#080;font-style:italic># The ConfigMap this value comes from.</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>player_initial_lives<span style=color:#bbb> </span><span style=color:#080;font-style:italic># The key to fetch.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>UI_PROPERTIES_FILE_NAME<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ui_properties_file_name<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/config&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># You set volumes at the Pod level, then mount them into containers inside that Pod</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Provide the name of the ConfigMap you want to mount.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># An array of keys from the ConfigMap to create as files</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>A ConfigMap doesn't differentiate between single line property values and
multi-line file-like values.
What matters is how Pods and other objects consume those values.</p>
<p>For this example, defining a volume and mounting it inside the <code>demo</code>
container as <code>/config</code> creates two files,
<code>/config/game.properties</code> and <code>/config/user-interface.properties</code>,
even though there are four keys in the ConfigMap. This is because the Pod
definition specifies an <code>items</code> array in the <code>volumes</code> section.
If you omit the <code>items</code> array entirely, every key in the ConfigMap becomes
a file with the same name as the key, and you get 4 files.</p>
<h2 id=using-configmaps>Using ConfigMaps</h2>
<p>ConfigMaps can be mounted as data volumes. ConfigMaps can also be used by other
parts of the system, without being directly exposed to the Pod. For example,
ConfigMaps can hold data that other parts of the system should use for configuration.</p>
<p>The most common way to use ConfigMaps is to configure settings for
containers running in a Pod in the same namespace. You can also use a
ConfigMap separately.</p>
<p>For example, you
might encounter <a class=glossary-tooltip title="Resources that extend the functionality of Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=addons>addons</a>
or <a class=glossary-tooltip title="A specialized controller used to manage a custom resource" data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operators>operators</a> that
adjust their behavior based on a ConfigMap.</p>
<h3 id=using-configmaps-as-files-from-a-pod>Using ConfigMaps as files from a Pod</h3>
<p>To consume a ConfigMap in a volume in a Pod:</p>
<ol>
<li>Create a ConfigMap or use an existing one. Multiple Pods can reference the
same ConfigMap.</li>
<li>Modify your Pod definition to add a volume under <code>.spec.volumes[]</code>. Name
the volume anything, and have a <code>.spec.volumes[].configMap.name</code> field set
to reference your ConfigMap object.</li>
<li>Add a <code>.spec.containers[].volumeMounts[]</code> to each container that needs the
ConfigMap. Specify <code>.spec.containers[].volumeMounts[].readOnly = true</code> and
<code>.spec.containers[].volumeMounts[].mountPath</code> to an unused directory name
where you would like the ConfigMap to appear.</li>
<li>Modify your image or command line so that the program looks for files in
that directory. Each key in the ConfigMap <code>data</code> map becomes the filename
under <code>mountPath</code>.</li>
</ol>
<p>This is an example of a Pod that mounts a ConfigMap in a volume:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></code></pre></div><p>Each ConfigMap you want to use needs to be referred to in <code>.spec.volumes</code>.</p>
<p>If there are multiple containers in the Pod, then each container needs its
own <code>volumeMounts</code> block, but only one <code>.spec.volumes</code> is needed per ConfigMap.</p>
<h4 id=mounted-configmaps-are-updated-automatically>Mounted ConfigMaps are updated automatically</h4>
<p>When a ConfigMap currently consumed in a volume is updated, projected keys are eventually updated as well.
The kubelet checks whether the mounted ConfigMap is fresh on every periodic sync.
However, the kubelet uses its local cache for getting the current value of the ConfigMap.
The type of the cache is configurable using the <code>ConfigMapAndSecretChangeDetectionStrategy</code> field in
the <a href=/docs/reference/config-api/kubelet-config.v1beta1/>KubeletConfiguration struct</a>.
A ConfigMap can be either propagated by watch (default), ttl-based, or by redirecting
all requests directly to the API server.
As a result, the total delay from the moment when the ConfigMap is updated to the moment
when new keys are projected to the Pod can be as long as the kubelet sync period + cache
propagation delay, where the cache propagation delay depends on the chosen cache type
(it equals to watch propagation delay, ttl of cache, or zero correspondingly).</p>
<p>ConfigMaps consumed as environment variables are not updated automatically and require a pod restart.</p>
<h2 id=configmap-immutable>Immutable ConfigMaps</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p>The Kubernetes feature <em>Immutable Secrets and ConfigMaps</em> provides an option to set
individual Secrets and ConfigMaps as immutable. For clusters that extensively use ConfigMaps
(at least tens of thousands of unique ConfigMap to Pod mounts), preventing changes to their
data has the following advantages:</p>
<ul>
<li>protects you from accidental (or unwanted) updates that could cause applications outages</li>
<li>improves performance of your cluster by significantly reducing load on kube-apiserver, by
closing watches for ConfigMaps marked as immutable.</li>
</ul>
<p>This feature is controlled by the <code>ImmutableEphemeralVolumes</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>.
You can create an immutable ConfigMap by setting the <code>immutable</code> field to <code>true</code>.
For example:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><p>Once a ConfigMap is marked as immutable, it is <em>not</em> possible to revert this change
nor to mutate the contents of the <code>data</code> or the <code>binaryData</code> field. You can
only delete and recreate the ConfigMap. Because existing Pods maintain a mount point
to the deleted ConfigMap, it is recommended to recreate these pods.</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>Read about <a href=/docs/concepts/configuration/secret/>Secrets</a>.</li>
<li>Read <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>Configure a Pod to Use a ConfigMap</a>.</li>
<li>Read <a href=https://12factor.net/>The Twelve-Factor App</a> to understand the motivation for
separating code from configuration.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e511ed821ada65d0053341dbd8ad2bb5>3 - Secrets</h1>
<p>A Secret is an object that contains a small amount of sensitive data such as
a password, a token, or a key. Such information might otherwise be put in a
<a class=glossary-tooltip title="A Pod represents a set of running containers in your cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a> specification or in a
<a class=glossary-tooltip title="Stored instance of a container that holds a set of software needed to run an application." data-toggle=tooltip data-placement=top href="/docs/reference/glossary/?all=true#term-image" target=_blank aria-label="container image">container image</a>. Using a
Secret means that you don't need to include confidential data in your
application code.</p>
<p>Because Secrets can be created independently of the Pods that use them, there
is less risk of the Secret (and its data) being exposed during the workflow of
creating, viewing, and editing Pods. Kubernetes, and applications that run in
your cluster, can also take additional precautions with Secrets, such as
avoiding writing confidential data to nonvolatile storage.</p>
<p>Secrets are similar to <a class=glossary-tooltip title="An API object used to store non-confidential data in key-value pairs. Can be consumed as environment variables, command-line arguments, or configuration files in a volume." data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/configmap/ target=_blank aria-label=ConfigMaps>ConfigMaps</a>
but are specifically intended to hold confidential data.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> <p>Kubernetes Secrets are, by default, stored unencrypted in the API server's underlying data store (etcd). Anyone with API access can retrieve or modify a Secret, and so can anyone with access to etcd.
Additionally, anyone who is authorized to create a Pod in a namespace can use that access to read any Secret in that namespace; this includes indirect access such as the ability to create a Deployment.</p>
<p>In order to safely use Secrets, take at least the following steps:</p>
<ol>
<li><a href=/docs/tasks/administer-cluster/encrypt-data/>Enable Encryption at Rest</a> for Secrets.</li>
<li>Enable or configure <a href=/docs/reference/access-authn-authz/authorization/>RBAC rules</a> that
restrict reading data in Secrets (including via indirect means).</li>
<li>Where appropriate, also use mechanisms such as RBAC to limit which principals are allowed to create new Secrets or replace existing ones.</li>
</ol>
</div>
<h2 id=overview-of-secrets>Overview of Secrets</h2>
<p>To use a Secret, a Pod needs to reference the Secret.
A Secret can be used with a Pod in three ways:</p>
<ul>
<li>As <a href=#using-secrets-as-files-from-a-pod>files</a> in a
<a class=glossary-tooltip title="A directory containing data, accessible to the containers in a pod." data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a> mounted on one or more of
its containers.</li>
<li>As <a href=#using-secrets-as-environment-variables>container environment variable</a>.</li>
<li>By the <a href=#using-imagepullsecrets>kubelet when pulling images</a> for the Pod.</li>
</ul>
<p>The Kubernetes control plane also uses Secrets; for example,
<a href=#bootstrap-token-secrets>bootstrap token Secrets</a> are a mechanism to
help automate node registration.</p>
<p>The name of a Secret object must be a valid
<a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS subdomain name</a>.
You can specify the <code>data</code> and/or the <code>stringData</code> field when creating a
configuration file for a Secret. The <code>data</code> and the <code>stringData</code> fields are optional.
The values for all keys in the <code>data</code> field have to be base64-encoded strings.
If the conversion to base64 string is not desirable, you can choose to specify
the <code>stringData</code> field instead, which accepts arbitrary strings as values.</p>
<p>The keys of <code>data</code> and <code>stringData</code> must consist of alphanumeric characters,
<code>-</code>, <code>_</code> or <code>.</code>. All key-value pairs in the <code>stringData</code> field are internally
merged into the <code>data</code> field. If a key appears in both the <code>data</code> and the
<code>stringData</code> field, the value specified in the <code>stringData</code> field takes
precedence.</p>
<h2 id=secret-types>Types of Secret</h2>
<p>When creating a Secret, you can specify its type using the <code>type</code> field of
a Secret resource, or certain equivalent <code>kubectl</code> command line flags (if available).
The <code>type</code> of a Secret is used to facilitate programmatic handling of different
kinds of confidential data.</p>
<p>Kubernetes provides several builtin types for some common usage scenarios.
These types vary in terms of the validations performed and the constraints
Kubernetes imposes on them.</p>
<table>
<thead>
<tr>
<th>Builtin Type</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Opaque</code></td>
<td>arbitrary user-defined data</td>
</tr>
<tr>
<td><code>kubernetes.io/service-account-token</code></td>
<td>service account token</td>
</tr>
<tr>
<td><code>kubernetes.io/dockercfg</code></td>
<td>serialized <code>~/.dockercfg</code> file</td>
</tr>
<tr>
<td><code>kubernetes.io/dockerconfigjson</code></td>
<td>serialized <code>~/.docker/config.json</code> file</td>
</tr>
<tr>
<td><code>kubernetes.io/basic-auth</code></td>
<td>credentials for basic authentication</td>
</tr>
<tr>
<td><code>kubernetes.io/ssh-auth</code></td>
<td>credentials for SSH authentication</td>
</tr>
<tr>
<td><code>kubernetes.io/tls</code></td>
<td>data for a TLS client or server</td>
</tr>
<tr>
<td><code>bootstrap.kubernetes.io/token</code></td>
<td>bootstrap token data</td>
</tr>
</tbody>
</table>
<p>You can define and use your own Secret type by assigning a non-empty string as the
<code>type</code> value for a Secret object. An empty string is treated as an <code>Opaque</code> type.
Kubernetes doesn't impose any constraints on the type name. However, if you
are using one of the builtin types, you must meet all the requirements defined
for that type.</p>
<h3 id=opaque-secrets>Opaque secrets</h3>
<p><code>Opaque</code> is the default Secret type if omitted from a Secret configuration file.
When you create a Secret using <code>kubectl</code>, you will use the <code>generic</code>
subcommand to indicate an <code>Opaque</code> Secret type. For example, the following
command creates an empty Secret of type <code>Opaque</code>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic empty-secret
kubectl get secret empty-secret
</code></pre></div><p>The output looks like:</p>
<pre><code>NAME           TYPE     DATA   AGE
empty-secret   Opaque   0      2m6s
</code></pre><p>The <code>DATA</code> column shows the number of data items stored in the Secret.
In this case, <code>0</code> means we have created an empty Secret.</p>
<h3 id=service-account-token-secrets>Service account token Secrets</h3>
<p>A <code>kubernetes.io/service-account-token</code> type of Secret is used to store a
token that identifies a service account. When using this Secret type, you need
to ensure that the <code>kubernetes.io/service-account.name</code> annotation is set to an
existing service account name. A Kubernetes controller fills in some other
fields such as the <code>kubernetes.io/service-account.uid</code> annotation and the
<code>token</code> key in the <code>data</code> field set to actual token content.</p>
<p>The following example configuration declares a service account token Secret:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-sa-sample<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-account.name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sa-name&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># You can include additional key value pairs as you do with Opaque Secrets</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb> </span>YmFyCg==<span style=color:#bbb>
</span></code></pre></div><p>When creating a <code>Pod</code>, Kubernetes automatically creates a service account Secret
and automatically modifies your Pod to use this Secret. The service account token
Secret contains credentials for accessing the API.</p>
<p>The automatic creation and use of API credentials can be disabled or
overridden if desired. However, if all you need to do is securely access the
API server, this is the recommended workflow.</p>
<p>See the <a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>
documentation for more information on how service accounts work.
You can also check the <code>automountServiceAccountToken</code> field and the
<code>serviceAccountName</code> field of the
<a href=/docs/reference/generated/kubernetes-api/v1.22/#pod-v1-core><code>Pod</code></a>
for information on referencing service account from Pods.</p>
<h3 id=docker-config-secrets>Docker config Secrets</h3>
<p>You can use one of the following <code>type</code> values to create a Secret to
store the credentials for accessing a Docker registry for images.</p>
<ul>
<li><code>kubernetes.io/dockercfg</code></li>
<li><code>kubernetes.io/dockerconfigjson</code></li>
</ul>
<p>The <code>kubernetes.io/dockercfg</code> type is reserved to store a serialized
<code>~/.dockercfg</code> which is the legacy format for configuring Docker command line.
When using this Secret type, you have to ensure the Secret <code>data</code> field
contains a <code>.dockercfg</code> key whose value is content of a <code>~/.dockercfg</code> file
encoded in the base64 format.</p>
<p>The <code>kubernetes.io/dockerconfigjson</code> type is designed for storing a serialized
JSON that follows the same format rules as the <code>~/.docker/config.json</code> file
which is a new format for <code>~/.dockercfg</code>.
When using this Secret type, the <code>data</code> field of the Secret object must
contain a <code>.dockerconfigjson</code> key, in which the content for the
<code>~/.docker/config.json</code> file is provided as a base64 encoded string.</p>
<p>Below is an example for a <code>kubernetes.io/dockercfg</code> type of Secret:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dockercfg<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockercfg<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockercfg</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span><span style=color:#b44>&#34;&lt;base64 encoded ~/.dockercfg file&gt;&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> If you do not want to perform the base64 encoding, you can choose to use the
<code>stringData</code> field instead.
</div>
<p>When you create these types of Secrets using a manifest, the API
server checks whether the expected key does exists in the <code>data</code> field, and
it verifies if the value provided can be parsed as a valid JSON. The API
server doesn't validate if the JSON actually is a Docker config file.</p>
<p>When you do not have a Docker config file, or you want to use <code>kubectl</code>
to create a Docker registry Secret, you can do:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret docker-registry secret-tiger-docker <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-username<span style=color:#666>=</span>tiger <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-password<span style=color:#666>=</span>pass113 <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-email<span style=color:#666>=</span>tiger@acme.com <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-server<span style=color:#666>=</span>my-registry.example:5000
</code></pre></div><p>This command creates a Secret of type <code>kubernetes.io/dockerconfigjson</code>.
If you dump the <code>.dockerconfigjson</code> content from the <code>data</code> field, you will
get the following JSON content which is a valid Docker configuration created
on the fly:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;data&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;.dockerconfigjson&#34;</span>: <span style=color:#b44>&#34;eyJhdXRocyI6eyJteS1yZWdpc3RyeTo1MDAwIjp7InVzZXJuYW1lIjoidGlnZXIiLCJwYXNzd29yZCI6InBhc3MxMTMiLCJlbWFpbCI6InRpZ2VyQGFjbWUuY29tIiwiYXV0aCI6ImRHbG5aWEk2Y0dGemN6RXhNdz09In19fQ==&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Secret&#34;</span>,
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>: <span style=color:#b44>&#34;2021-07-01T07:30:59Z&#34;</span>,
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;secret-tiger-docker&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
        <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>: <span style=color:#b44>&#34;566718&#34;</span>,
        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;e15c1d7b-9071-4100-8681-f3a7a2ce89ca&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;kubernetes.io/dockerconfigjson&#34;</span>
}

</code></pre></div><h3 id=basic-authentication-secret>Basic authentication Secret</h3>
<p>The <code>kubernetes.io/basic-auth</code> type is provided for storing credentials needed
for basic authentication. When using this Secret type, the <code>data</code> field of the
Secret must contain one of the following two keys:</p>
<ul>
<li><code>username</code>: the user name for authentication;</li>
<li><code>password</code>: the password or token for authentication.</li>
</ul>
<p>Both values for the above two keys are base64 encoded strings. You can, of
course, provide the clear text content using the <code>stringData</code> for Secret
creation.</p>
<p>The following YAML is an example config for a basic authentication Secret:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-basic-auth<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/basic-auth<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>admin<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>t0p-Secret<span style=color:#bbb>
</span></code></pre></div><p>The basic authentication Secret type is provided only for user's convenience.
You can create an <code>Opaque</code> for credentials used for basic authentication.
However, using the builtin Secret type helps unify the formats of your credentials
and the API server does verify if the required keys are provided in a Secret
configuration.</p>
<h3 id=ssh-authentication-secrets>SSH authentication secrets</h3>
<p>The builtin type <code>kubernetes.io/ssh-auth</code> is provided for storing data used in
SSH authentication. When using this Secret type, you will have to specify a
<code>ssh-privatekey</code> key-value pair in the <code>data</code> (or <code>stringData</code>) field
as the SSH credential to use.</p>
<p>The following YAML is an example config for a SSH authentication Secret:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-ssh-auth<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/ssh-auth<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># the data is abbreviated in this example</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ssh-privatekey</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>     </span><span style=color:#bbb>     </span>MIIEpQIBAAKCAQEAulqb/Y ...<span style=color:#bbb>
</span></code></pre></div><p>The SSH authentication Secret type is provided only for user's convenience.
You can create an <code>Opaque</code> for credentials used for SSH authentication.
However, using the builtin Secret type helps unify the formats of your credentials
and the API server does verify if the required keys are provided in a Secret
configuration.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> SSH private keys do not establish trusted communication between an SSH client and
host server on their own. A secondary means of establishing trust is needed to
mitigate "man in the middle" attacks, such as a <code>known_hosts</code> file added to a
ConfigMap.
</div>
<h3 id=tls-secrets>TLS secrets</h3>
<p>Kubernetes provides a builtin Secret type <code>kubernetes.io/tls</code> for storing
a certificate and its associated key that are typically used for TLS . This
data is primarily used with TLS termination of the Ingress resource, but may
be used with other resources or directly by a workload.
When using this type of Secret, the <code>tls.key</code> and the <code>tls.crt</code> key must be provided
in the <code>data</code> (or <code>stringData</code>) field of the Secret configuration, although the API
server doesn't actually validate the values for each key.</p>
<p>The following YAML contains an example config for a TLS Secret:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-tls<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># the data is abbreviated in this example</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIC2DCCAcCgAwIBAgIBATANBgkqh ...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...<span style=color:#bbb>
</span></code></pre></div><p>The TLS Secret type is provided for user's convenience. You can create an <code>Opaque</code>
for credentials used for TLS server and/or client. However, using the builtin Secret
type helps ensure the consistency of Secret format in your project; the API server
does verify if the required keys are provided in a Secret configuration.</p>
<p>When creating a TLS Secret using <code>kubectl</code>, you can use the <code>tls</code> subcommand
as shown in the following example:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret tls my-tls-secret <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --cert<span style=color:#666>=</span>path/to/cert/file <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --key<span style=color:#666>=</span>path/to/key/file
</code></pre></div><p>The public/private key pair must exist beforehand. The public key certificate
for <code>--cert</code> must be .PEM encoded (Base64-encoded DER format), and match the
given private key for <code>--key</code>.
The private key must be in what is commonly called PEM private key format,
unencrypted. In both cases, the initial and the last lines from PEM (for
example, <code>--------BEGIN CERTIFICATE-----</code> and <code>-------END CERTIFICATE----</code> for
a certificate) are <em>not</em> included.</p>
<h3 id=bootstrap-token-secrets>Bootstrap token Secrets</h3>
<p>A bootstrap token Secret can be created by explicitly specifying the Secret
<code>type</code> to <code>bootstrap.kubernetes.io/token</code>. This type of Secret is designed for
tokens used during the node bootstrap process. It stores tokens used to sign
well known ConfigMaps.</p>
<p>A bootstrap token Secret is usually created in the <code>kube-system</code> namespace and
named in the form <code>bootstrap-token-&lt;token-id></code> where <code>&lt;token-id></code> is a 6 character
string of the token ID.</p>
<p>As a Kubernetes manifest, a bootstrap token Secret might look like the
following:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>c3lzdGVtOmJvb3RzdHJhcHBlcnM6a3ViZWFkbTpkZWZhdWx0LW5vZGUtdG9rZW4=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span>MjAyMC0wOS0xM1QwNDozOToxMFo=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>NWVtaXRq<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>a3E0Z2lodnN6emduMXAwcg==<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></code></pre></div><p>A bootstrap type Secret has the following keys specified under <code>data</code>:</p>
<ul>
<li><code>token-id</code>: A random 6 character string as the token identifier. Required.</li>
<li><code>token-secret</code>: A random 16 character string as the actual token secret. Required.</li>
<li><code>description</code>: A human-readable string that describes what the token is
used for. Optional.</li>
<li><code>expiration</code>: An absolute UTC time using RFC3339 specifying when the token
should be expired. Optional.</li>
<li><code>usage-bootstrap-&lt;usage></code>: A boolean flag indicating additional usage for
the bootstrap token.</li>
<li><code>auth-extra-groups</code>: A comma-separated list of group names that will be
authenticated as in addition to the <code>system:bootstrappers</code> group.</li>
</ul>
<p>The above YAML may look confusing because the values are all in base64 encoded
strings. In fact, you can create an identical Secret using the following YAML:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Note how the Secret is named</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># A bootstrap token Secret usually resides in the kube-system namespace</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;system:bootstrappers:kubeadm:default-node-token&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-09-13T04:39:10Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># This token ID is used in the name</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5emitj&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kq4gihvszzgn1p0r&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># This token can be used for authentication</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># and it can be used for signing</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=creating-a-secret>Creating a Secret</h2>
<p>There are several options to create a Secret:</p>
<ul>
<li><a href=/docs/tasks/configmap-secret/managing-secret-using-kubectl/>create Secret using <code>kubectl</code> command</a></li>
<li><a href=/docs/tasks/configmap-secret/managing-secret-using-config-file/>create Secret from config file</a></li>
<li><a href=/docs/tasks/configmap-secret/managing-secret-using-kustomize/>create Secret using kustomize</a></li>
</ul>
<h2 id=editing-a-secret>Editing a Secret</h2>
<p>An existing Secret may be edited with the following command:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit secrets mysecret
</code></pre></div><p>This will open the default configured editor and allow for updating the base64 encoded Secret values in the <code>data</code> field:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># Please edit the object below. Lines beginning with a &#39;#&#39; will be ignored,</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># and an empty file will abort the edit. If an error occurs while saving this file will be</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># reopened with the relevant failures.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>{<span style=color:#bbb> </span>... }<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-01-22T18:41:56Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;164619&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>cfee02d6-c137-11e5-8d73-42010af00002<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></code></pre></div><h2 id=using-secrets>Using Secrets</h2>
<p>Secrets can be mounted as data volumes or exposed as
<a class=glossary-tooltip title="Container environment variables are name=value pairs that provide useful information into containers running in a Pod." data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment/ target=_blank aria-label="environment variables">environment variables</a>
to be used by a container in a Pod. Secrets can also be used by other parts of the
system, without being directly exposed to the Pod. For example, Secrets can hold
credentials that other parts of the system should use to interact with external
systems on your behalf.</p>
<h3 id=using-secrets-as-files-from-a-pod>Using Secrets as files from a Pod</h3>
<p>To consume a Secret in a volume in a Pod:</p>
<ol>
<li>Create a secret or use an existing one. Multiple Pods can reference the same secret.</li>
<li>Modify your Pod definition to add a volume under <code>.spec.volumes[]</code>. Name the volume anything, and have a <code>.spec.volumes[].secret.secretName</code> field equal to the name of the Secret object.</li>
<li>Add a <code>.spec.containers[].volumeMounts[]</code> to each container that needs the secret. Specify <code>.spec.containers[].volumeMounts[].readOnly = true</code> and <code>.spec.containers[].volumeMounts[].mountPath</code> to an unused directory name where you would like the secrets to appear.</li>
<li>Modify your image or command line so that the program looks for files in that directory. Each key in the secret <code>data</code> map becomes the filename under <code>mountPath</code>.</li>
</ol>
<p>This is an example of a Pod that mounts a Secret in a volume:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></code></pre></div><p>Each Secret you want to use needs to be referred to in <code>.spec.volumes</code>.</p>
<p>If there are multiple containers in the Pod, then each container needs its
own <code>volumeMounts</code> block, but only one <code>.spec.volumes</code> is needed per Secret.</p>
<p>You can package many files into one secret, or use many secrets, whichever is convenient.</p>
<h4 id=projection-of-secret-keys-to-specific-paths>Projection of Secret keys to specific paths</h4>
<p>You can also control the paths within the volume where Secret keys are projected.
You can use the <code>.spec.volumes[].secret.items</code> field to change the target path of each key:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></code></pre></div><p>What will happen:</p>
<ul>
<li><code>username</code> secret is stored under <code>/etc/foo/my-group/my-username</code> file instead of <code>/etc/foo/username</code>.</li>
<li><code>password</code> secret is not projected.</li>
</ul>
<p>If <code>.spec.volumes[].secret.items</code> is used, only keys specified in <code>items</code> are projected.
To consume all keys from the secret, all of them must be listed in the <code>items</code> field.
All listed keys must exist in the corresponding secret. Otherwise, the volume is not created.</p>
<h4 id=secret-files-permissions>Secret files permissions</h4>
<p>You can set the file access permission bits for a single Secret key.
If you don't specify any permissions, <code>0644</code> is used by default.
You can also set a default mode for the entire Secret volume and override per key if needed.</p>
<p>For example, you can specify a default mode like this:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>0400</span><span style=color:#bbb>
</span></code></pre></div><p>Then, the secret will be mounted on <code>/etc/foo</code> and all the files created by the
secret volume mount will have permission <code>0400</code>.</p>
<p>Note that the JSON spec doesn't support octal notation, so use the value 256 for
0400 permissions. If you use YAML instead of JSON for the Pod, you can use octal
notation to specify permissions in a more natural way.</p>
<p>Note if you <code>kubectl exec</code> into the Pod, you need to follow the symlink to find
the expected file mode. For example,</p>
<p>Check the secrets file mode on the pod.</p>
<pre><code>kubectl exec mypod -it sh

cd /etc/foo
ls -l
</code></pre><p>The output is similar to this:</p>
<pre><code>total 0
lrwxrwxrwx 1 root root 15 May 18 00:18 password -&gt; ..data/password
lrwxrwxrwx 1 root root 15 May 18 00:18 username -&gt; ..data/username
</code></pre><p>Follow the symlink to find the correct file mode.</p>
<pre><code>cd /etc/foo/..data
ls -l
</code></pre><p>The output is similar to this:</p>
<pre><code>total 8
-r-------- 1 root root 12 May 18 00:18 password
-r-------- 1 root root  5 May 18 00:18 username
</code></pre><p>You can also use mapping, as in the previous example, and specify different
permissions for different files like this:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>0777</span><span style=color:#bbb>
</span></code></pre></div><p>In this case, the file resulting in <code>/etc/foo/my-group/my-username</code> will have
permission value of <code>0777</code>. If you use JSON, owing to JSON limitations, you
must specify the mode in decimal notation, <code>511</code>.</p>
<p>Note that this permission value might be displayed in decimal notation if you
read it later.</p>
<h4 id=consuming-secret-values-from-volumes>Consuming Secret values from volumes</h4>
<p>Inside the container that mounts a secret volume, the secret keys appear as
files and the secret values are base64 decoded and stored inside these files.
This is the result of commands executed inside the container from the example above:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls /etc/foo/
</code></pre></div><p>The output is similar to:</p>
<pre><code>username
password
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /etc/foo/username
</code></pre></div><p>The output is similar to:</p>
<pre><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /etc/foo/password
</code></pre></div><p>The output is similar to:</p>
<pre><code>1f2d1e2e67df
</code></pre><p>The program in a container is responsible for reading the secrets from the
files.</p>
<h4 id=mounted-secrets-are-updated-automatically>Mounted Secrets are updated automatically</h4>
<p>When a secret currently consumed in a volume is updated, projected keys are eventually updated as well.
The kubelet checks whether the mounted secret is fresh on every periodic sync.
However, the kubelet uses its local cache for getting the current value of the Secret.
The type of the cache is configurable using the <code>ConfigMapAndSecretChangeDetectionStrategy</code> field in
the <a href=/docs/reference/config-api/kubelet-config.v1beta1/>KubeletConfiguration struct</a>.
A Secret can be either propagated by watch (default), ttl-based, or by redirecting
all requests directly to the API server.
As a result, the total delay from the moment when the Secret is updated to the moment
when new keys are projected to the Pod can be as long as the kubelet sync period + cache
propagation delay, where the cache propagation delay depends on the chosen cache type
(it equals to watch propagation delay, ttl of cache, or zero correspondingly).</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> A container using a Secret as a
<a href=/docs/concepts/storage/volumes#using-subpath>subPath</a> volume mount will not receive
Secret updates.
</div>
<h3 id=using-secrets-as-environment-variables>Using Secrets as environment variables</h3>
<p>To use a secret in an <a class=glossary-tooltip title="Container environment variables are name=value pairs that provide useful information into containers running in a Pod." data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment/ target=_blank aria-label="environment variable">environment variable</a>
in a Pod:</p>
<ol>
<li>Create a secret or use an existing one. Multiple Pods can reference the same secret.</li>
<li>Modify your Pod definition in each container that you wish to consume the value of a secret key to add an environment variable for each secret key you wish to consume. The environment variable that consumes the secret key should populate the secret's name and key in <code>env[].valueFrom.secretKeyRef</code>.</li>
<li>Modify your image and/or command line so that the program looks for values in the specified environment variables.</li>
</ol>
<p>This is an example of a Pod that uses secrets from environment variables:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-env-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mycontainer<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div><h4 id=consuming-secret-values-from-environment-variables>Consuming Secret Values from environment variables</h4>
<p>Inside a container that consumes a secret in the environment variables, the secret keys appear as
normal environment variables containing the base64 decoded values of the secret data.
This is the result of commands executed inside the container from the example above:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_USERNAME</span>
</code></pre></div><p>The output is similar to:</p>
<pre><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_PASSWORD</span>
</code></pre></div><p>The output is similar to:</p>
<pre><code>1f2d1e2e67df
</code></pre><h4 id=environment-variables-are-not-updated-after-a-secret-update>Environment variables are not updated after a secret update</h4>
<p>If a container already consumes a Secret in an environment variable, a Secret update will not be seen by the container unless it is restarted.
There are third party solutions for triggering restarts when secrets change.</p>
<h2 id=secret-immutable>Immutable Secrets</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p>The Kubernetes feature <em>Immutable Secrets and ConfigMaps</em> provides an option to set
individual Secrets and ConfigMaps as immutable. For clusters that extensively use Secrets
(at least tens of thousands of unique Secret to Pod mounts), preventing changes to their
data has the following advantages:</p>
<ul>
<li>protects you from accidental (or unwanted) updates that could cause applications outages</li>
<li>improves performance of your cluster by significantly reducing load on kube-apiserver, by
closing watches for secrets marked as immutable.</li>
</ul>
<p>This feature is controlled by the <code>ImmutableEphemeralVolumes</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>,
which is enabled by default since v1.19. You can create an immutable
Secret by setting the <code>immutable</code> field to <code>true</code>. For example,</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Once a Secret or ConfigMap is marked as immutable, it is <em>not</em> possible to revert this change
nor to mutate the contents of the <code>data</code> field. You can only delete and recreate the Secret.
Existing Pods maintain a mount point to the deleted Secret - it is recommended to recreate
these pods.
</div>
<h3 id=using-imagepullsecrets>Using imagePullSecrets</h3>
<p>The <code>imagePullSecrets</code> field is a list of references to secrets in the same namespace.
You can use an <code>imagePullSecrets</code> to pass a secret that contains a Docker (or other) image registry
password to the kubelet. The kubelet uses this information to pull a private image on behalf of your Pod.
See the <a href=/docs/reference/generated/kubernetes-api/v1.22/#podspec-v1-core>PodSpec API</a> for more information about the <code>imagePullSecrets</code> field.</p>
<h4 id=manually-specifying-an-imagepullsecret>Manually specifying an imagePullSecret</h4>
<p>You can learn how to specify <code>ImagePullSecrets</code> from the <a href=/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>container images documentation</a>.</p>
<h3 id=arranging-for-imagepullsecrets-to-be-automatically-attached>Arranging for imagePullSecrets to be automatically attached</h3>
<p>You can manually create <code>imagePullSecrets</code>, and reference it from
a ServiceAccount. Any Pods created with that ServiceAccount
or created with that ServiceAccount by default, will get their <code>imagePullSecrets</code>
field set to that of the service account.
See <a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Add ImagePullSecrets to a service account</a>
for a detailed explanation of that process.</p>
<h2 id=details>Details</h2>
<h3 id=restrictions>Restrictions</h3>
<p>Secret volume sources are validated to ensure that the specified object
reference actually points to an object of type Secret. Therefore, a secret
needs to be created before any Pods that depend on it.</p>
<p>Secret resources reside in a <a class=glossary-tooltip title="An abstraction used by Kubernetes to support multiple virtual clusters on the same physical cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.
Secrets can only be referenced by Pods in that same namespace.</p>
<p>Individual secrets are limited to 1MiB in size. This is to discourage creation
of very large secrets which would exhaust the API server and kubelet memory.
However, creation of many smaller secrets could also exhaust memory. More
comprehensive limits on memory usage due to secrets is a planned feature.</p>
<p>The kubelet only supports the use of secrets for Pods where the secrets
are obtained from the API server.
This includes any Pods created using <code>kubectl</code>, or indirectly via a replication
controller. It does not include Pods created as a result of the kubelet
<code>--manifest-url</code> flag, its <code>--config</code> flag, or its REST API (these are
not common ways to create Pods).
The <code>spec</code> of a <a class=glossary-tooltip title="A pod managed directly by the kubelet daemon on a specific node." data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label="static Pod">static Pod</a> cannot refer to a Secret
or any other API objects.</p>
<p>Secrets must be created before they are consumed in Pods as environment
variables unless they are marked as optional. References to secrets that do
not exist will prevent the Pod from starting.</p>
<p>References (<code>secretKeyRef</code> field) to keys that do not exist in a named Secret
will prevent the Pod from starting.</p>
<p>Secrets used to populate environment variables by the <code>envFrom</code> field that have keys
that are considered invalid environment variable names will have those keys
skipped. The Pod will be allowed to start. There will be an event whose
reason is <code>InvalidVariableNames</code> and the message will contain the list of
invalid keys that were skipped. The example shows a pod which refers to the
default/mysecret that contains 2 invalid keys: <code>1badkey</code> and <code>2alsobad</code>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events
</code></pre></div><p>The output is similar to:</p>
<pre><code>LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentVariableNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variable names.
</code></pre><h3 id=secret-and-pod-lifetime-interaction>Secret and Pod lifetime interaction</h3>
<p>When a Pod is created by calling the Kubernetes API, there is no check if a referenced
secret exists. Once a Pod is scheduled, the kubelet will try to fetch the
secret value. If the secret cannot be fetched because it does not exist or
because of a temporary lack of connection to the API server, the kubelet will
periodically retry. It will report an event about the Pod explaining the
reason it is not started yet. Once the secret is fetched, the kubelet will
create and mount a volume containing it. None of the Pod's containers will
start until all the Pod's volumes are mounted.</p>
<h2 id=use-cases>Use cases</h2>
<h3 id=use-case-as-container-environment-variables>Use-Case: As container environment variables</h3>
<p>Create a secret</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>USER_NAME</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>PASSWORD</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></code></pre></div><p>Create the Secret:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f mysecret.yaml
</code></pre></div><p>Use <code>envFrom</code> to define all of the Secret's data as container environment variables. The key from the Secret becomes the environment variable name in the Pod.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div><h3 id=use-case-pod-with-ssh-keys>Use-Case: Pod with ssh keys</h3>
<p>Create a secret containing some ssh keys:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic ssh-key-secret --from-file<span style=color:#666>=</span>ssh-privatekey<span style=color:#666>=</span>/path/to/.ssh/id_rsa --from-file<span style=color:#666>=</span>ssh-publickey<span style=color:#666>=</span>/path/to/.ssh/id_rsa.pub
</code></pre></div><p>The output is similar to:</p>
<pre><code>secret &quot;ssh-key-secret&quot; created
</code></pre><p>You can also create a <code>kustomization.yaml</code> with a <code>secretGenerator</code> field containing ssh keys.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> Think carefully before sending your own ssh keys: other users of the cluster may have access to the secret. Use a service account which you want to be accessible to all the users with whom you share the Kubernetes cluster, and can revoke this account if the users are compromised.
</div>
<p>Now you can create a Pod which references the secret with the ssh key and
consumes it in a volume:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>ssh-key-secret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ssh-test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mySshImage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>When the container's command runs, the pieces of the key will be available in:</p>
<pre><code>/etc/secret-volume/ssh-publickey
/etc/secret-volume/ssh-privatekey
</code></pre><p>The container is then free to use the secret data to establish an ssh connection.</p>
<h3 id=use-case-pods-with-prod-test-credentials>Use-Case: Pods with prod / test credentials</h3>
<p>This example illustrates a Pod which consumes a secret containing production
credentials and another Pod which consumes a secret with test environment
credentials.</p>
<p>You can create a <code>kustomization.yaml</code> with a <code>secretGenerator</code> field or run
<code>kubectl create secret</code>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic prod-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>produser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>Y4nys7f11
</code></pre></div><p>The output is similar to:</p>
<pre><code>secret &quot;prod-db-secret&quot; created
</code></pre><p>You can also create a secret for test environment credentials.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic test-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>testuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>iluvtests
</code></pre></div><p>The output is similar to:</p>
<pre><code>secret &quot;test-db-secret&quot; created
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>Special characters such as <code>$</code>, <code>\</code>, <code>*</code>, <code>=</code>, and <code>!</code> will be interpreted by your <a href=https://en.wikipedia.org/wiki/Shell_(computing)>shell</a> and require escaping.
In most shells, the easiest way to escape the password is to surround it with single quotes (<code>'</code>).
For example, if your actual password is <code>S!B\*d$zDsb=</code>, you should execute the command this way:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic dev-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;S!B\*d$zDsb=&#39;</span>
</code></pre></div><p>You do not need to escape special characters in passwords from files (<code>--from-file</code>).</p>
</div>
<p>Now make the Pods:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: List
</span><span style=color:#b44>items:
</span><span style=color:#b44>- kind: Pod
</span><span style=color:#b44>  apiVersion: v1
</span><span style=color:#b44>  metadata:
</span><span style=color:#b44>    name: prod-db-client-pod
</span><span style=color:#b44>    labels:
</span><span style=color:#b44>      name: prod-db-client
</span><span style=color:#b44>  spec:
</span><span style=color:#b44>    volumes:
</span><span style=color:#b44>    - name: secret-volume
</span><span style=color:#b44>      secret:
</span><span style=color:#b44>        secretName: prod-db-secret
</span><span style=color:#b44>    containers:
</span><span style=color:#b44>    - name: db-client-container
</span><span style=color:#b44>      image: myClientImage
</span><span style=color:#b44>      volumeMounts:
</span><span style=color:#b44>      - name: secret-volume
</span><span style=color:#b44>        readOnly: true
</span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span><span style=color:#b44>- kind: Pod
</span><span style=color:#b44>  apiVersion: v1
</span><span style=color:#b44>  metadata:
</span><span style=color:#b44>    name: test-db-client-pod
</span><span style=color:#b44>    labels:
</span><span style=color:#b44>      name: test-db-client
</span><span style=color:#b44>  spec:
</span><span style=color:#b44>    volumes:
</span><span style=color:#b44>    - name: secret-volume
</span><span style=color:#b44>      secret:
</span><span style=color:#b44>        secretName: test-db-secret
</span><span style=color:#b44>    containers:
</span><span style=color:#b44>    - name: db-client-container
</span><span style=color:#b44>      image: myClientImage
</span><span style=color:#b44>      volumeMounts:
</span><span style=color:#b44>      - name: secret-volume
</span><span style=color:#b44>        readOnly: true
</span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>Add the pods to the same kustomization.yaml:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- pod.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>Apply all those objects on the API server by running:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
</code></pre></div><p>Both containers will have the following files present on their filesystems with the values for each container's environment:</p>
<pre><code>/etc/secret-volume/username
/etc/secret-volume/password
</code></pre><p>Note how the specs for the two Pods differ only in one field; this facilitates
creating Pods with different capabilities from a common Pod template.</p>
<p>You could further simplify the base Pod specification by using two service accounts:</p>
<ol>
<li><code>prod-user</code> with the <code>prod-db-secret</code></li>
<li><code>test-user</code> with the <code>test-db-secret</code></li>
</ol>
<p>The Pod specification is shortened to:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client-pod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-client-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myClientImage<span style=color:#bbb>
</span></code></pre></div><h3 id=use-case-dotfiles-in-a-secret-volume>Use-case: dotfiles in a secret volume</h3>
<p>You can make your data "hidden" by defining a key that begins with a dot.
This key represents a dotfile or "hidden" file. For example, when the following secret
is mounted into a volume, <code>secret-volume</code>:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.secret-file</span>:<span style=color:#bbb> </span>dmFsdWUtMg0KDQo=<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dotfiles-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ls<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-l&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>The volume will contain a single file, called <code>.secret-file</code>, and
the <code>dotfile-test-container</code> will have this file present at the path
<code>/etc/secret-volume/.secret-file</code>.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Files beginning with dot characters are hidden from the output of <code>ls -l</code>;
you must use <code>ls -la</code> to see them when listing directory contents.
</div>
<h3 id=use-case-secret-visible-to-one-container-in-a-pod>Use-case: Secret visible to one container in a Pod</h3>
<p>Consider a program that needs to handle HTTP requests, do some complex business
logic, and then sign some messages with an HMAC. Because it has complex
application logic, there might be an unnoticed remote file reading exploit in
the server, which could expose the private key to an attacker.</p>
<p>This could be divided into two processes in two containers: a frontend container
which handles user interaction and business logic, but which cannot see the
private key; and a signer container that can see the private key, and responds
to simple signing requests from the frontend (for example, over localhost networking).</p>
<p>With this partitioned approach, an attacker now has to trick the application
server into doing something rather arbitrary, which may be harder than getting
it to read a file.</p>
<h2 id=best-practices>Best practices</h2>
<h3 id=clients-that-use-the-secret-api>Clients that use the Secret API</h3>
<p>When deploying applications that interact with the Secret API, you should
limit access using <a href=/docs/reference/access-authn-authz/authorization/>authorization policies</a> such as <a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>.</p>
<p>Secrets often hold values that span a spectrum of importance, many of which can
cause escalations within Kubernetes (e.g. service account tokens) and to
external systems. Even if an individual app can reason about the power of the
Secrets it expects to interact with, other apps within the same namespace can
render those assumptions invalid.</p>
<p>For these reasons <code>watch</code> and <code>list</code> requests for secrets within a namespace are
extremely powerful capabilities and should be avoided, since listing secrets allows
the clients to inspect the values of all secrets that are in that namespace. The ability to
<code>watch</code> and <code>list</code> all secrets in a cluster should be reserved for only the most
privileged, system-level components.</p>
<p>Applications that need to access the Secret API should perform <code>get</code> requests on
the secrets they need. This lets administrators restrict access to all secrets
while <a href=/docs/reference/access-authn-authz/rbac/#referring-to-resources>white-listing access to individual instances</a> that
the app needs.</p>
<p>For improved performance over a looping <code>get</code>, clients can design resources that
reference a secret then <code>watch</code> the resource, re-requesting the secret when the
reference changes. Additionally, a <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/bulk_watch.md>"bulk watch" API</a>
to let clients <code>watch</code> individual resources has also been proposed, and will likely
be available in future releases of Kubernetes.</p>
<h2 id=security-properties>Security properties</h2>
<h3 id=protections>Protections</h3>
<p>Because secrets can be created independently of the Pods that use
them, there is less risk of the secret being exposed during the workflow of
creating, viewing, and editing Pods. The system can also take additional
precautions with Secrets, such as avoiding writing them to disk where
possible.</p>
<p>A secret is only sent to a node if a Pod on that node requires it.
The kubelet stores the secret into a <code>tmpfs</code> so that the secret is not written
to disk storage. Once the Pod that depends on the secret is deleted, the kubelet
will delete its local copy of the secret data as well.</p>
<p>There may be secrets for several Pods on the same node. However, only the
secrets that a Pod requests are potentially visible within its containers.
Therefore, one Pod does not have access to the secrets of another Pod.</p>
<p>There may be several containers in a Pod. However, each container in a Pod has
to request the secret volume in its <code>volumeMounts</code> for it to be visible within
the container. This can be used to construct useful <a href=#use-case-secret-visible-to-one-container-in-a-pod>security partitions at the
Pod level</a>.</p>
<p>On most Kubernetes distributions, communication between users
and the API server, and from the API server to the kubelets, is protected by SSL/TLS.
Secrets are protected when transmitted over these channels.</p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [beta]</code>
</div>
<p>You can enable <a href=/docs/tasks/administer-cluster/encrypt-data/>encryption at rest</a>
for secret data, so that the secrets are not stored in the clear into <a class=glossary-tooltip title="Consistent and highly-available key value store used as Kubernetes' backing store for all cluster data." data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>.</p>
<h3 id=risks>Risks</h3>
<ul>
<li>In the API server, secret data is stored in <a class=glossary-tooltip title="Consistent and highly-available key value store used as Kubernetes' backing store for all cluster data." data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>;
therefore:
<ul>
<li>Administrators should enable encryption at rest for cluster data (requires v1.13 or later).</li>
<li>Administrators should limit access to etcd to admin users.</li>
<li>Administrators may want to wipe/shred disks used by etcd when no longer in use.</li>
<li>If running etcd in a cluster, administrators should make sure to use SSL/TLS
for etcd peer-to-peer communication.</li>
</ul>
</li>
<li>If you configure the secret through a manifest (JSON or YAML) file which has
the secret data encoded as base64, sharing this file or checking it in to a
source repository means the secret is compromised. Base64 encoding is <em>not</em> an
encryption method and is considered the same as plain text.</li>
<li>Applications still need to protect the value of secret after reading it from the volume,
such as not accidentally logging it or transmitting it to an untrusted party.</li>
<li>A user who can create a Pod that uses a secret can also see the value of that secret. Even
if the API server policy does not allow that user to read the Secret, the user could
run a Pod which exposes the secret.</li>
</ul>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>Learn how to <a href=/docs/tasks/configmap-secret/managing-secret-using-kubectl/>manage Secret using <code>kubectl</code></a></li>
<li>Learn how to <a href=/docs/tasks/configmap-secret/managing-secret-using-config-file/>manage Secret using config file</a></li>
<li>Learn how to <a href=/docs/tasks/configmap-secret/managing-secret-using-kustomize/>manage Secret using kustomize</a></li>
<li>Read the <a href=/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/>API reference</a> for <code>Secret</code></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-436057b96151ecb8a4a9a9f456b5d0fc>4 - Managing Resources for Containers</h1>
<p>When you specify a <a class=glossary-tooltip title="A Pod represents a set of running containers in your cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a>, you can optionally specify how
much of each resource a <a class=glossary-tooltip title="A lightweight and portable executable image that contains software and all of its dependencies." data-toggle=tooltip data-placement=top href=/docs/concepts/containers/ target=_blank aria-label=Container>Container</a> needs.
The most common resources to specify are CPU and memory (RAM); there are others.</p>
<p>When you specify the resource <em>request</em> for Containers in a Pod, the scheduler uses this
information to decide which node to place the Pod on. When you specify a resource <em>limit</em>
for a Container, the kubelet enforces those limits so that the running container is not
allowed to use more of that resource than the limit you set. The kubelet also reserves
at least the <em>request</em> amount of that system resource specifically for that container
to use.</p>
<h2 id=requests-and-limits>Requests and limits</h2>
<p>If the node where a Pod is running has enough of a resource available, it's possible (and
allowed) for a container to use more resource than its <code>request</code> for that resource specifies.
However, a container is not allowed to use more than its resource <code>limit</code>.</p>
<p>For example, if you set a <code>memory</code> request of 256 MiB for a container, and that container is in
a Pod scheduled to a Node with 8GiB of memory and no other Pods, then the container can try to use
more RAM.</p>
<p>If you set a <code>memory</code> limit of 4GiB for that Container, the kubelet (and
<a class=glossary-tooltip title="The container runtime is the software that is responsible for running containers." data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label="container runtime">container runtime</a>) enforce the limit.
The runtime prevents the container from using more than the configured resource limit. For example:
when a process in the container tries to consume more than the allowed amount of memory,
the system kernel terminates the process that attempted the allocation, with an out of memory
(OOM) error.</p>
<p>Limits can be implemented either reactively (the system intervenes once it sees a violation)
or by enforcement (the system prevents the container from ever exceeding the limit). Different
runtimes can have different ways to implement the same restrictions.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> If a Container specifies its own memory limit, but does not specify a memory request, Kubernetes
automatically assigns a memory request that matches the limit. Similarly, if a Container specifies its own
CPU limit, but does not specify a CPU request, Kubernetes automatically assigns a CPU request that matches
the limit.
</div>
<h2 id=resource-types>Resource types</h2>
<p><em>CPU</em> and <em>memory</em> are each a <em>resource type</em>. A resource type has a base unit.
CPU represents compute processing and is specified in units of <a href=#meaning-of-cpu>Kubernetes CPUs</a>.
Memory is specified in units of bytes.
If you're using Kubernetes v1.14 or newer, you can specify <em>huge page</em> resources.
Huge pages are a Linux-specific feature where the node kernel allocates blocks of memory
that are much larger than the default page size.</p>
<p>For example, on a system where the default page size is 4KiB, you could specify a limit,
<code>hugepages-2Mi: 80Mi</code>. If the container tries allocating over 40 2MiB huge pages (a
total of 80 MiB), that allocation fails.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> You cannot overcommit <code>hugepages-*</code> resources.
This is different from the <code>memory</code> and <code>cpu</code> resources.
</div>
<p>CPU and memory are collectively referred to as <em>compute resources</em>, or <em>resources</em>. Compute
resources are measurable quantities that can be requested, allocated, and
consumed. They are distinct from
<a href=/docs/concepts/overview/kubernetes-api/>API resources</a>. API resources, such as Pods and
<a href=/docs/concepts/services-networking/service/>Services</a> are objects that can be read and modified
through the Kubernetes API server.</p>
<h2 id=resource-requests-and-limits-of-pod-and-container>Resource requests and limits of Pod and Container</h2>
<p>Each Container of a Pod can specify one or more of the following:</p>
<ul>
<li><code>spec.containers[].resources.limits.cpu</code></li>
<li><code>spec.containers[].resources.limits.memory</code></li>
<li><code>spec.containers[].resources.limits.hugepages-&lt;size></code></li>
<li><code>spec.containers[].resources.requests.cpu</code></li>
<li><code>spec.containers[].resources.requests.memory</code></li>
<li><code>spec.containers[].resources.requests.hugepages-&lt;size></code></li>
</ul>
<p>Although requests and limits can only be specified on individual Containers, it
is convenient to talk about Pod resource requests and limits. A
<em>Pod resource request/limit</em> for a particular resource type is the sum of the
resource requests/limits of that type for each Container in the Pod.</p>
<h2 id=resource-units-in-kubernetes>Resource units in Kubernetes</h2>
<h3 id=meaning-of-cpu>Meaning of CPU</h3>
<p>Limits and requests for CPU resources are measured in <em>cpu</em> units.
One cpu, in Kubernetes, is equivalent to <strong>1 vCPU/Core</strong> for cloud providers and <strong>1 hyperthread</strong> on bare-metal Intel processors.</p>
<p>Fractional requests are allowed. When you define a container with
<code>spec.containers[].resources.requests.cpu</code> set to <code>0.5</code>, you are requesting half
as much CPU time compared to if you asked for <code>1.0</code> CPU.
For CPU resource units, the expression <code>0.1</code> is equivalent to the
expression <code>100m</code>, which can be read as "one hundred millicpu". Some people say
"one hundred millicores", and this is understood to mean the same thing. A
request with a decimal point, like <code>0.1</code>, is converted to <code>100m</code> by the API, and
precision finer than <code>1m</code> is not allowed. For this reason, the form <code>100m</code> might
be preferred.</p>
<p>CPU is always requested as an absolute quantity, never as a relative quantity;
0.1 is the same amount of CPU on a single-core, dual-core, or 48-core machine.</p>
<h3 id=meaning-of-memory>Meaning of memory</h3>
<p>Limits and requests for <code>memory</code> are measured in bytes. You can express memory as
a plain integer or as a fixed-point number using one of these suffixes:
E, P, T, G, M, k, m (millis). You can also use the power-of-two equivalents: Ei, Pi, Ti, Gi,
Mi, Ki. For example, the following represent roughly the same value:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>128974848, 129e6, 129M,  128974848000m, 123Mi
</code></pre></div><p>Here's an example.
The following Pod has two Containers. Each Container has a request of 0.25 cpu
and 64MiB (2<sup>26</sup> bytes) of memory. Each Container has a limit of 0.5
cpu and 128MiB of memory. You can say the Pod has a request of 0.5 cpu and 128
MiB of memory, and a limit of 1 cpu and 256MiB of memory.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=how-pods-with-resource-requests-are-scheduled>How Pods with resource requests are scheduled</h2>
<p>When you create a Pod, the Kubernetes scheduler selects a node for the Pod to
run on. Each node has a maximum capacity for each of the resource types: the
amount of CPU and memory it can provide for Pods. The scheduler ensures that,
for each resource type, the sum of the resource requests of the scheduled
Containers is less than the capacity of the node. Note that although actual memory
or CPU resource usage on nodes is very low, the scheduler still refuses to place
a Pod on a node if the capacity check fails. This protects against a resource
shortage on a node when resource usage later increases, for example, during a
daily peak in request rate.</p>
<h2 id=how-pods-with-resource-limits-are-run>How Pods with resource limits are run</h2>
<p>When the kubelet starts a Container of a Pod, it passes the CPU and memory limits
to the container runtime.</p>
<p>When using Docker:</p>
<ul>
<li>
<p>The <code>spec.containers[].resources.requests.cpu</code> is converted to its core value,
which is potentially fractional, and multiplied by 1024. The greater of this number
or 2 is used as the value of the
<a href=https://docs.docker.com/engine/reference/run/#cpu-share-constraint><code>--cpu-shares</code></a>
flag in the <code>docker run</code> command.</p>
</li>
<li>
<p>The <code>spec.containers[].resources.limits.cpu</code> is converted to its millicore value and
multiplied by 100. The resulting value is the total amount of CPU time in microseconds
that a container can use every 100ms. A container cannot use more than its share of
CPU time during this interval.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> The default quota period is 100ms. The minimum resolution of CPU quota is 1ms.
</div>
</li>
<li>
<p>The <code>spec.containers[].resources.limits.memory</code> is converted to an integer, and
used as the value of the
<a href=https://docs.docker.com/engine/reference/run/#/user-memory-constraints><code>--memory</code></a>
flag in the <code>docker run</code> command.</p>
</li>
</ul>
<p>If a Container exceeds its memory limit, it might be terminated. If it is
restartable, the kubelet will restart it, as with any other type of runtime
failure.</p>
<p>If a Container exceeds its memory request, it is likely that its Pod will
be evicted whenever the node runs out of memory.</p>
<p>A Container might or might not be allowed to exceed its CPU limit for extended
periods of time. However, it will not be killed for excessive CPU usage.</p>
<p>To determine whether a Container cannot be scheduled or is being killed due to
resource limits, see the
<a href=#troubleshooting>Troubleshooting</a> section.</p>
<h3 id=monitoring-compute-memory-resource-usage>Monitoring compute & memory resource usage</h3>
<p>The resource usage of a Pod is reported as part of the Pod status.</p>
<p>If optional <a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>tools for monitoring</a>
are available in your cluster, then Pod resource usage can be retrieved either
from the <a href=/docs/tasks/debug-application-cluster/resource-metrics-pipeline/#the-metrics-api>Metrics API</a>
directly or from your monitoring tools.</p>
<h2 id=local-ephemeral-storage>Local ephemeral storage</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code>
</div>
<p>Nodes have local ephemeral storage, backed by
locally-attached writeable devices or, sometimes, by RAM.
"Ephemeral" means that there is no long-term guarantee about durability.</p>
<p>Pods use ephemeral local storage for scratch space, caching, and for logs.
The kubelet can provide scratch space to Pods using local ephemeral storage to
mount <a href=/docs/concepts/storage/volumes/#emptydir><code>emptyDir</code></a>
<a class=glossary-tooltip title="A directory containing data, accessible to the containers in a pod." data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volumes>volumes</a> into containers.</p>
<p>The kubelet also uses this kind of storage to hold
<a href=/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>node-level container logs</a>,
container images, and the writable layers of running containers.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> If a node fails, the data in its ephemeral storage can be lost.
Your applications cannot expect any performance SLAs (disk IOPS for example)
from local ephemeral storage.
</div>
<p>As a beta feature, Kubernetes lets you track, reserve and limit the amount
of ephemeral local storage a Pod can consume.</p>
<h3 id=configurations-for-local-ephemeral-storage>Configurations for local ephemeral storage</h3>
<p>Kubernetes supports two ways to configure local ephemeral storage on a node:
<ul class="nav nav-tabs" id=local-storage-configurations role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#local-storage-configurations-0 role=tab aria-controls=local-storage-configurations-0 aria-selected=true>Single filesystem</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#local-storage-configurations-1 role=tab aria-controls=local-storage-configurations-1>Two filesystems</a></li></ul>
<div class=tab-content id=local-storage-configurations><div id=local-storage-configurations-0 class="tab-pane show active" role=tabpanel aria-labelledby=local-storage-configurations-0>
<p><p>In this configuration, you place all different kinds of ephemeral local data
(<code>emptyDir</code> volumes, writeable layers, container images, logs) into one filesystem.
The most effective way to configure the kubelet means dedicating this filesystem
to Kubernetes (kubelet) data.</p>
<p>The kubelet also writes
<a href=/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>node-level container logs</a>
and treats these similarly to ephemeral local storage.</p>
<p>The kubelet writes logs to files inside its configured log directory (<code>/var/log</code>
by default); and has a base directory for other locally stored data
(<code>/var/lib/kubelet</code> by default).</p>
<p>Typically, both <code>/var/lib/kubelet</code> and <code>/var/log</code> are on the system root filesystem,
and the kubelet is designed with that layout in mind.</p>
<p>Your node can have as many other filesystems, not used for Kubernetes,
as you like.</p>
</div>
<div id=local-storage-configurations-1 class=tab-pane role=tabpanel aria-labelledby=local-storage-configurations-1>
<p><p>You have a filesystem on the node that you're using for ephemeral data that
comes from running Pods: logs, and <code>emptyDir</code> volumes. You can use this filesystem
for other data (for example: system logs not related to Kubernetes); it can even
be the root filesystem.</p>
<p>The kubelet also writes
<a href=/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>node-level container logs</a>
into the first filesystem, and treats these similarly to ephemeral local storage.</p>
<p>You also use a separate filesystem, backed by a different logical storage device.
In this configuration, the directory where you tell the kubelet to place
container image layers and writeable layers is on this second filesystem.</p>
<p>The first filesystem does not hold any image layers or writeable layers.</p>
<p>Your node can have as many other filesystems, not used for Kubernetes,
as you like.</p>
</div></div>
</p>
<p>The kubelet can measure how much local storage it is using. It does this provided
that:</p>
<ul>
<li>the <code>LocalStorageCapacityIsolation</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
is enabled (the feature is on by default), and</li>
<li>you have set up the node using one of the supported configurations
for local ephemeral storage.</li>
</ul>
<p>If you have a different configuration, then the kubelet does not apply resource
limits for ephemeral local storage.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> The kubelet tracks <code>tmpfs</code> emptyDir volumes as container memory use, rather
than as local ephemeral storage.
</div>
<h3 id=setting-requests-and-limits-for-local-ephemeral-storage>Setting requests and limits for local ephemeral storage</h3>
<p>You can use <em>ephemeral-storage</em> for managing local ephemeral storage. Each Container of a Pod can specify one or more of the following:</p>
<ul>
<li><code>spec.containers[].resources.limits.ephemeral-storage</code></li>
<li><code>spec.containers[].resources.requests.ephemeral-storage</code></li>
</ul>
<p>Limits and requests for <code>ephemeral-storage</code> are measured in bytes. You can express storage as
a plain integer or as a fixed-point number using one of these suffixes:
E, P, T, G, M, K. You can also use the power-of-two equivalents: Ei, Pi, Ti, Gi,
Mi, Ki. For example, the following represent roughly the same value:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>128974848, 129e6, 129M, 123Mi
</code></pre></div><p>In the following example, the Pod has two Containers. Each Container has a request of 2GiB of local ephemeral storage. Each Container has a limit of 4GiB of local ephemeral storage. Therefore, the Pod has a request of 4GiB of local ephemeral storage, and a limit of 8GiB of local ephemeral storage.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div><h3 id=how-pods-with-ephemeral-storage-requests-are-scheduled>How Pods with ephemeral-storage requests are scheduled</h3>
<p>When you create a Pod, the Kubernetes scheduler selects a node for the Pod to
run on. Each node has a maximum amount of local ephemeral storage it can provide for Pods. For more information, see <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>Node Allocatable</a>.</p>
<p>The scheduler ensures that the sum of the resource requests of the scheduled Containers is less than the capacity of the node.</p>
<h3 id=resource-emphemeralstorage-consumption>Ephemeral storage consumption management</h3>
<p>If the kubelet is managing local ephemeral storage as a resource, then the
kubelet measures storage use in:</p>
<ul>
<li><code>emptyDir</code> volumes, except <em>tmpfs</em> <code>emptyDir</code> volumes</li>
<li>directories holding node-level logs</li>
<li>writeable container layers</li>
</ul>
<p>If a Pod is using more ephemeral storage than you allow it to, the kubelet
sets an eviction signal that triggers Pod eviction.</p>
<p>For container-level isolation, if a Container's writable layer and log
usage exceeds its storage limit, the kubelet marks the Pod for eviction.</p>
<p>For pod-level isolation the kubelet works out an overall Pod storage limit by
summing the limits for the containers in that Pod. In this case, if the sum of
the local ephemeral storage usage from all containers and also the Pod's <code>emptyDir</code>
volumes exceeds the overall Pod storage limit, then the kubelet also marks the Pod
for eviction.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Caution:</strong> <p>If the kubelet is not measuring local ephemeral storage, then a Pod
that exceeds its local storage limit will not be evicted for breaching
local storage resource limits.</p>
<p>However, if the filesystem space for writeable container layers, node-level logs,
or <code>emptyDir</code> volumes falls low, the node
<a class=glossary-tooltip title="A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups." data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taints>taints</a> itself as short on local storage
and this taint triggers eviction for any Pods that don't specifically tolerate the taint.</p>
<p>See the supported <a href=#configurations-for-local-ephemeral-storage>configurations</a>
for ephemeral local storage.</p>
</div>
<p>The kubelet supports different ways to measure Pod storage use:</p>
<ul class="nav nav-tabs" id=resource-emphemeralstorage-measurement role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#resource-emphemeralstorage-measurement-0 role=tab aria-controls=resource-emphemeralstorage-measurement-0 aria-selected=true>Periodic scanning</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#resource-emphemeralstorage-measurement-1 role=tab aria-controls=resource-emphemeralstorage-measurement-1>Filesystem project quota</a></li></ul>
<div class=tab-content id=resource-emphemeralstorage-measurement><div id=resource-emphemeralstorage-measurement-0 class="tab-pane show active" role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-0>
<p><p>The kubelet performs regular, scheduled checks that scan each
<code>emptyDir</code> volume, container log directory, and writeable container layer.</p>
<p>The scan measures how much space is used.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> <p>In this mode, the kubelet does not track open file descriptors
for deleted files.</p>
<p>If you (or a container) create a file inside an <code>emptyDir</code> volume,
something then opens that file, and you delete the file while it is
still open, then the inode for the deleted file stays until you close
that file but the kubelet does not categorize the space as in use.</p>
</div>
</div>
<div id=resource-emphemeralstorage-measurement-1 class=tab-pane role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-1>
<p><div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.15 [alpha]</code>
</div>
<p>Project quotas are an operating-system level feature for managing
storage use on filesystems. With Kubernetes, you can enable project
quotas for monitoring storage use. Make sure that the filesystem
backing the <code>emptyDir</code> volumes, on the node, provides project quota support.
For example, XFS and ext4fs offer project quotas.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Project quotas let you monitor storage use; they do not enforce limits.
</div>
<p>Kubernetes uses project IDs starting from <code>1048576</code>. The IDs in use are
registered in <code>/etc/projects</code> and <code>/etc/projid</code>. If project IDs in
this range are used for other purposes on the system, those project
IDs must be registered in <code>/etc/projects</code> and <code>/etc/projid</code> so that
Kubernetes does not use them.</p>
<p>Quotas are faster and more accurate than directory scanning. When a
directory is assigned to a project, all files created under a
directory are created in that project, and the kernel merely has to
keep track of how many blocks are in use by files in that project.
If a file is created and deleted, but has an open file descriptor,
it continues to consume space. Quota tracking records that space accurately
whereas directory scans overlook the storage used by deleted files.</p>
<p>If you want to use project quotas, you should:</p>
<ul>
<li>
<p>Enable the <code>LocalStorageCapacityIsolationFSQuotaMonitoring=true</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
using the <code>featureGates</code> field in the
<a href=/docs/reference/config-api/kubelet-config.v1beta1/>kubelet configuration</a>
or the <code>--feature-gates</code> command line flag.</p>
</li>
<li>
<p>Ensure that the root filesystem (or optional runtime filesystem)
has project quotas enabled. All XFS filesystems support project quotas.
For ext4 filesystems, you need to enable the project quota tracking feature
while the filesystem is not mounted.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># For ext4, with /dev/block-device not mounted</span>
sudo tune2fs -O project -Q prjquota /dev/block-device
</code></pre></div></li>
<li>
<p>Ensure that the root filesystem (or optional runtime filesystem) is
mounted with project quotas enabled. For both XFS and ext4fs, the
mount option is named <code>prjquota</code>.</p>
</li>
</ul>
</div></div>
<h2 id=extended-resources>Extended resources</h2>
<p>Extended resources are fully-qualified resource names outside the
<code>kubernetes.io</code> domain. They allow cluster operators to advertise and users to
consume the non-Kubernetes-built-in resources.</p>
<p>There are two steps required to use Extended Resources. First, the cluster
operator must advertise an Extended Resource. Second, users must request the
Extended Resource in Pods.</p>
<h3 id=managing-extended-resources>Managing extended resources</h3>
<h4 id=node-level-extended-resources>Node-level extended resources</h4>
<p>Node-level extended resources are tied to nodes.</p>
<h5 id=device-plugin-managed-resources>Device plugin managed resources</h5>
<p>See <a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>Device
Plugin</a>
for how to advertise device plugin managed resources on each node.</p>
<h5 id=other-resources>Other resources</h5>
<p>To advertise a new node-level extended resource, the cluster operator can
submit a <code>PATCH</code> HTTP request to the API server to specify the available
quantity in the <code>status.capacity</code> for a node in the cluster. After this
operation, the node's <code>status.capacity</code> will include a new resource. The
<code>status.allocatable</code> field is updated automatically with the new resource
asynchronously by the kubelet. Note that because the scheduler uses the node
<code>status.allocatable</code> value when evaluating Pod fitness, there may be a short
delay between patching the node capacity with a new resource and the first Pod
that requests the resource to be scheduled on that node.</p>
<p><strong>Example:</strong></p>
<p>Here is an example showing how to use <code>curl</code> to form an HTTP request that
advertises five "example.com/foo" resources on node <code>k8s-node-1</code> whose master
is <code>k8s-master</code>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1foo&#34;, &#34;value&#34;: &#34;5&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>http://k8s-master:8080/api/v1/nodes/k8s-node-1/status
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> In the preceding request, <code>~1</code> is the encoding for the character <code>/</code>
in the patch path. The operation path value in JSON-Patch is interpreted as a
JSON-Pointer. For more details, see
<a href=https://tools.ietf.org/html/rfc6901#section-3>IETF RFC 6901, section 3</a>.
</div>
<h4 id=cluster-level-extended-resources>Cluster-level extended resources</h4>
<p>Cluster-level extended resources are not tied to nodes. They are usually managed
by scheduler extenders, which handle the resource consumption and resource quota.</p>
<p>You can specify the extended resources that are handled by scheduler extenders
in <a href=/docs/reference/config-api/kube-scheduler-policy-config.v1/>scheduler policy configuration</a></p>
<p><strong>Example:</strong></p>
<p>The following configuration for a scheduler policy indicates that the
cluster-level extended resource "example.com/foo" is handled by the scheduler
extender.</p>
<ul>
<li>The scheduler sends a Pod to the scheduler extender only if the Pod requests
"example.com/foo".</li>
<li>The <code>ignoredByScheduler</code> field specifies that the scheduler does not check
the "example.com/foo" resource in its <code>PodFitsResources</code> predicate.</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;extenders&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;urlPrefix&#34;</span>:<span style=color:#b44>&#34;&lt;extender-endpoint&gt;&#34;</span>,
      <span style=color:green;font-weight:700>&#34;bindVerb&#34;</span>: <span style=color:#b44>&#34;bind&#34;</span>,
      <span style=color:green;font-weight:700>&#34;managedResources&#34;</span>: [
        {
          <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example.com/foo&#34;</span>,
          <span style=color:green;font-weight:700>&#34;ignoredByScheduler&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
        }
      ]
    }
  ]
}
</code></pre></div><h3 id=consuming-extended-resources>Consuming extended resources</h3>
<p>Users can consume extended resources in Pod specs like CPU and memory.
The scheduler takes care of the resource accounting so that no more than the
available amount is simultaneously allocated to Pods.</p>
<p>The API server restricts quantities of extended resources to whole numbers.
Examples of <em>valid</em> quantities are <code>3</code>, <code>3000m</code> and <code>3Ki</code>. Examples of
<em>invalid</em> quantities are <code>0.5</code> and <code>1500m</code>.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Extended resources replace Opaque Integer Resources.
Users can use any domain name prefix other than <code>kubernetes.io</code> which is reserved.
</div>
<p>To consume an extended resource in a Pod, include the resource name as a key
in the <code>spec.containers[].resources.limits</code> map in the container spec.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> Extended resources cannot be overcommitted, so request and limit
must be equal if both are present in a container spec.
</div>
<p>A Pod is scheduled only if all of the resource requests are satisfied, including
CPU, memory and any extended resources. The Pod remains in the <code>PENDING</code> state
as long as the resource request cannot be satisfied.</p>
<p><strong>Example:</strong></p>
<p>The Pod below requests 2 CPUs and 1 "example.com/foo" (an extended resource).</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myimage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></code></pre></div><h2 id=pid-limiting>PID limiting</h2>
<p>Process ID (PID) limits allow for the configuration of a kubelet to limit the number of PIDs that a given Pod can consume. See <a href=/docs/concepts/policy/pid-limiting/>Pid Limiting</a> for information.</p>
<h2 id=troubleshooting>Troubleshooting</h2>
<h3 id=my-pods-are-pending-with-event-message-failedscheduling>My Pods are pending with event message failedScheduling</h3>
<p>If the scheduler cannot find any node where a Pod can fit, the Pod remains
unscheduled until a place can be found. An event is produced each time the
scheduler fails to find a place for the Pod, like this:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod frontend | grep -A <span style=color:#666>3</span> Events
</code></pre></div><pre><code>Events:
  FirstSeen LastSeen   Count  From          Subobject   PathReason      Message
  36s   5s     6      {scheduler }              FailedScheduling  Failed for reason PodExceedsFreeCPU and possibly others
</code></pre><p>In the preceding example, the Pod named "frontend" fails to be scheduled due to
insufficient CPU resource on the node. Similar error messages can also suggest
failure due to insufficient memory (PodExceedsFreeMemory). In general, if a Pod
is pending with a message of this type, there are several things to try:</p>
<ul>
<li>Add more nodes to the cluster.</li>
<li>Terminate unneeded Pods to make room for pending Pods.</li>
<li>Check that the Pod is not larger than all the nodes. For example, if all the
nodes have a capacity of <code>cpu: 1</code>, then a Pod with a request of <code>cpu: 1.1</code> will
never be scheduled.</li>
</ul>
<p>You can check node capacities and amounts allocated with the
<code>kubectl describe nodes</code> command. For example:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe nodes e2e-test-node-pool-4lw4
</code></pre></div><pre><code>Name:            e2e-test-node-pool-4lw4
[ ... lines removed for clarity ...]
Capacity:
 cpu:                               2
 memory:                            7679792Ki
 pods:                              110
Allocatable:
 cpu:                               1800m
 memory:                            7474992Ki
 pods:                              110
[ ... lines removed for clarity ...]
Non-terminated Pods:        (5 in total)
  Namespace    Name                                  CPU Requests  CPU Limits  Memory Requests  Memory Limits
  ---------    ----                                  ------------  ----------  ---------------  -------------
  kube-system  fluentd-gcp-v1.38-28bv1               100m (5%)     0 (0%)      200Mi (2%)       200Mi (2%)
  kube-system  kube-dns-3297075139-61lj3             260m (13%)    0 (0%)      100Mi (1%)       170Mi (2%)
  kube-system  kube-proxy-e2e-test-...               100m (5%)     0 (0%)      0 (0%)           0 (0%)
  kube-system  monitoring-influxdb-grafana-v4-z1m12  200m (10%)    200m (10%)  600Mi (8%)       600Mi (8%)
  kube-system  node-problem-detector-v0.1-fj7m3      20m (1%)      200m (10%)  20Mi (0%)        100Mi (1%)
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests    CPU Limits    Memory Requests    Memory Limits
  ------------    ----------    ---------------    -------------
  680m (34%)      400m (20%)    920Mi (11%)        1070Mi (13%)
</code></pre><p>In the preceding output, you can see that if a Pod requests more than 1120m
CPUs or 6.23Gi of memory, it will not fit on the node.</p>
<p>By looking at the <code>Pods</code> section, you can see which Pods are taking up space on
the node.</p>
<p>The amount of resources available to Pods is less than the node capacity, because
system daemons use a portion of the available resources. The <code>allocatable</code> field
<a href=/docs/reference/generated/kubernetes-api/v1.22/#nodestatus-v1-core>NodeStatus</a>
gives the amount of resources that are available to Pods. For more information, see
<a href=https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md>Node Allocatable Resources</a>.</p>
<p>The <a href=/docs/concepts/policy/resource-quotas/>resource quota</a> feature can be configured
to limit the total amount of resources that can be consumed. If used in conjunction
with namespaces, it can prevent one team from hogging all the resources.</p>
<h3 id=my-container-is-terminated>My Container is terminated</h3>
<p>Your Container might get terminated because it is resource-starved. To check
whether a Container is being killed because it is hitting a resource limit, call
<code>kubectl describe pod</code> on the Pod of interest:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod simmemleak-hra99
</code></pre></div><pre><code>Name:                           simmemleak-hra99
Namespace:                      default
Image(s):                       saadali/simmemleak
Node:                           kubernetes-node-tf0f/10.240.216.66
Labels:                         name=simmemleak
Status:                         Running
Reason:
Message:
IP:                             10.244.2.75
Replication Controllers:        simmemleak (1/1 replicas created)
Containers:
  simmemleak:
    Image:  saadali/simmemleak
    Limits:
      cpu:                      100m
      memory:                   50Mi
    State:                      Running
      Started:                  Tue, 07 Jul 2015 12:54:41 -0700
    Last Termination State:     Terminated
      Exit Code:                1
      Started:                  Fri, 07 Jul 2015 12:54:30 -0700
      Finished:                 Fri, 07 Jul 2015 12:54:33 -0700
    Ready:                      False
    Restart Count:              5
Conditions:
  Type      Status
  Ready     False
Events:
  FirstSeen                         LastSeen                         Count  From                              SubobjectPath                       Reason      Message
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {scheduler }                                                          scheduled   Successfully assigned simmemleak-hra99 to kubernetes-node-tf0f
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   pulled      Pod container image &quot;k8s.gcr.io/pause:0.8.0&quot; already present on machine
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   created     Created with docker id 6a41280f516d
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   started     Started with docker id 6a41280f516d
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    spec.containers{simmemleak}         created     Created with docker id 87348f12526a
</code></pre><p>In the preceding example, the <code>Restart Count: 5</code> indicates that the <code>simmemleak</code>
Container in the Pod was terminated and restarted five times.</p>
<p>You can call <code>kubectl get pod</code> with the <code>-o go-template=...</code> option to fetch the status
of previously terminated Containers:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range.status.containerStatuses}}{{&#34;Container Name: &#34;}}{{.name}}{{&#34;\r\nLastState: &#34;}}{{.lastState}}{{end}}&#39;</span>  simmemleak-hra99
</code></pre></div><pre><code>Container Name: simmemleak
LastState: map[terminated:map[exitCode:137 reason:OOM Killed startedAt:2015-07-07T20:58:43Z finishedAt:2015-07-07T20:58:43Z containerID:docker://0e4095bba1feccdfe7ef9fb6ebffe972b4b14285d5acdec6f0d3ae8a22fad8b2]]
</code></pre><p>You can see that the Container was terminated because of <code>reason:OOM Killed</code>, where <code>OOM</code> stands for Out Of Memory.</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li>Get hands-on experience <a href=/docs/tasks/configure-pod-container/assign-memory-resource/>assigning Memory resources to Containers and Pods</a>.</li>
<li>Get hands-on experience <a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>assigning CPU resources to Containers and Pods</a>.</li>
<li>For more details about the difference between requests and limits, see
<a href=https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md>Resource QoS</a>.</li>
<li>Read the <a href=/docs/reference/generated/kubernetes-api/v1.22/#container-v1-core>Container</a> API reference</li>
<li>Read the <a href=/docs/reference/generated/kubernetes-api/v1.22/#resourcerequirements-v1-core>ResourceRequirements</a> API reference</li>
<li>Read about <a href=https://xfs.org/docs/xfsdocs-xml-dev/XFS_User_Guide/tmp/en-US/html/xfs-quotas.html>project quotas</a> in XFS</li>
<li>Read more about the <a href=/docs/reference/config-api/kube-scheduler-policy-config.v1/>kube-scheduler Policy reference (v1)</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>5 - Organizing Cluster Access Using kubeconfig Files</h1>
<p>Use kubeconfig files to organize information about clusters, users, namespaces, and
authentication mechanisms. The <code>kubectl</code> command-line tool uses kubeconfig files to
find the information it needs to choose a cluster and communicate with the API server
of a cluster.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Note:</strong> A file that is used to configure access to clusters is called
a <em>kubeconfig file</em>. This is a generic way of referring to configuration files.
It does not mean that there is a file named <code>kubeconfig</code>.
</div>
<div class="alert alert-danger warning callout" role=alert>
<strong>Warning:</strong> Only use kubeconfig files from trusted sources. Using a specially-crafted kubeconfig file could result in malicious code execution or file exposure.
If you must use an untrusted kubeconfig file, inspect it carefully first, much as you would a shell script.
</div>
<p>By default, <code>kubectl</code> looks for a file named <code>config</code> in the <code>$HOME/.kube</code> directory.
You can specify other kubeconfig files by setting the <code>KUBECONFIG</code> environment
variable or by setting the
<a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a> flag.</p>
<p>For step-by-step instructions on creating and specifying kubeconfig files, see
<a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters>Configure Access to Multiple Clusters</a>.</p>
<h2 id=supporting-multiple-clusters-users-and-authentication-mechanisms>Supporting multiple clusters, users, and authentication mechanisms</h2>
<p>Suppose you have several clusters, and your users and components authenticate
in a variety of ways. For example:</p>
<ul>
<li>A running kubelet might authenticate using certificates.</li>
<li>A user might authenticate using tokens.</li>
<li>Administrators might have sets of certificates that they provide to individual users.</li>
</ul>
<p>With kubeconfig files, you can organize your clusters, users, and namespaces.
You can also define contexts to quickly and easily switch between
clusters and namespaces.</p>
<h2 id=context>Context</h2>
<p>A <em>context</em> element in a kubeconfig file is used to group access parameters
under a convenient name. Each context has three parameters: cluster, namespace, and user.
By default, the <code>kubectl</code> command-line tool uses parameters from
the <em>current context</em> to communicate with the cluster.</p>
<p>To choose the current context:</p>
<pre><code>kubectl config use-context
</code></pre><h2 id=the-kubeconfig-environment-variable>The KUBECONFIG environment variable</h2>
<p>The <code>KUBECONFIG</code> environment variable holds a list of kubeconfig files.
For Linux and Mac, the list is colon-delimited. For Windows, the list
is semicolon-delimited. The <code>KUBECONFIG</code> environment variable is not
required. If the <code>KUBECONFIG</code> environment variable doesn't exist,
<code>kubectl</code> uses the default kubeconfig file, <code>$HOME/.kube/config</code>.</p>
<p>If the <code>KUBECONFIG</code> environment variable does exist, <code>kubectl</code> uses
an effective configuration that is the result of merging the files
listed in the <code>KUBECONFIG</code> environment variable.</p>
<h2 id=merging-kubeconfig-files>Merging kubeconfig files</h2>
<p>To see your configuration, enter this command:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div><p>As described previously, the output might be from a single kubeconfig file,
or it might be the result of merging several kubeconfig files.</p>
<p>Here are the rules that <code>kubectl</code> uses when it merges kubeconfig files:</p>
<ol>
<li>
<p>If the <code>--kubeconfig</code> flag is set, use only the specified file. Do not merge.
Only one instance of this flag is allowed.</p>
<p>Otherwise, if the <code>KUBECONFIG</code> environment variable is set, use it as a
list of files that should be merged.
Merge the files listed in the <code>KUBECONFIG</code> environment variable
according to these rules:</p>
<ul>
<li>Ignore empty filenames.</li>
<li>Produce errors for files with content that cannot be deserialized.</li>
<li>The first file to set a particular value or map key wins.</li>
<li>Never change the value or map key.
Example: Preserve the context of the first file to set <code>current-context</code>.
Example: If two files specify a <code>red-user</code>, use only values from the first file's <code>red-user</code>.
Even if the second file has non-conflicting entries under <code>red-user</code>, discard them.</li>
</ul>
<p>For an example of setting the <code>KUBECONFIG</code> environment variable, see
<a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable>Setting the KUBECONFIG environment variable</a>.</p>
<p>Otherwise, use the default kubeconfig file, <code>$HOME/.kube/config</code>, with no merging.</p>
</li>
<li>
<p>Determine the context to use based on the first hit in this chain:</p>
<ol>
<li>Use the <code>--context</code> command-line flag if it exists.</li>
<li>Use the <code>current-context</code> from the merged kubeconfig files.</li>
</ol>
<p>An empty context is allowed at this point.</p>
</li>
<li>
<p>Determine the cluster and user. At this point, there might or might not be a context.
Determine the cluster and user based on the first hit in this chain,
which is run twice: once for user and once for cluster:</p>
<ol>
<li>Use a command-line flag if it exists: <code>--user</code> or <code>--cluster</code>.</li>
<li>If the context is non-empty, take the user or cluster from the context.</li>
</ol>
<p>The user and cluster can be empty at this point.</p>
</li>
<li>
<p>Determine the actual cluster information to use. At this point, there might or
might not be cluster information.
Build each piece of the cluster information based on this chain; the first hit wins:</p>
<ol>
<li>Use command line flags if they exist: <code>--server</code>, <code>--certificate-authority</code>, <code>--insecure-skip-tls-verify</code>.</li>
<li>If any cluster information attributes exist from the merged kubeconfig files, use them.</li>
<li>If there is no server location, fail.</li>
</ol>
</li>
<li>
<p>Determine the actual user information to use. Build user information using the same
rules as cluster information, except allow only one authentication
technique per user:</p>
<ol>
<li>Use command line flags if they exist: <code>--client-certificate</code>, <code>--client-key</code>, <code>--username</code>, <code>--password</code>, <code>--token</code>.</li>
<li>Use the <code>user</code> fields from the merged kubeconfig files.</li>
<li>If there are two conflicting techniques, fail.</li>
</ol>
</li>
<li>
<p>For any information still missing, use default values and potentially
prompt for authentication information.</p>
</li>
</ol>
<h2 id=file-references>File references</h2>
<p>File and path references in a kubeconfig file are relative to the location of the kubeconfig file.
File references on the command line are relative to the current working directory.
In <code>$HOME/.kube/config</code>, relative paths are stored relatively, and absolute paths
are stored absolutely.</p>
<h2 id=what-s-next>What's next</h2>
<ul>
<li><a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Configure Access to Multiple Clusters</a></li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/docs/home/>Home</a>
<a class=text-white href=/blog/>Blog</a>
<a class=text-white href=/training/>Training</a>
<a class=text-white href=/partners/>Partners</a>
<a class=text-white href=/community/>Community</a>
<a class=text-white href=/case-studies/>Case Studies</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>