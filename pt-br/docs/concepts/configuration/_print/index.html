<!doctype html><html lang=pt-br class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/configuration/>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/configuration/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/configuration/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/configuration/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/configuration/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/configuration/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/configuration/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/configuration/>
<link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/configuration/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/pt-br/docs/concepts/configuration/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>Configuração | Kubernetes</title><meta property="og:title" content="Configuração">
<meta property="og:description" content="Orquestração de contêineres em nível de produção">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/pt-br/docs/concepts/configuration/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="Configuração">
<meta itemprop=description content="Orquestração de contêineres em nível de produção"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Configuração">
<meta name=twitter:description content="Orquestração de contêineres em nível de produção">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content>
<meta property="og:description" content>
<meta name=twitter:description content>
<meta property="og:url" content="https://kubernetes.io/pt-br/docs/concepts/configuration/">
<meta property="og:title" content="Configuração">
<meta name=twitter:title content="Configuração">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/pt-br/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/pt-br/docs/>Documentação</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/pt-br/blog/>Kubernetes Blog</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/pt-br/partners/>Parceiros</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/pt-br/community/>Comunidade</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/pt-br/case-studies/>Casos de estudo</span></a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Versões
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/pt-br/docs/concepts/configuration/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/pt-br/docs/concepts/configuration/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/pt-br/docs/concepts/configuration/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/pt-br/docs/concepts/configuration/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/pt-br/docs/concepts/configuration/>v1.22</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
Português
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/concepts/configuration/>English</a>
<a class=dropdown-item href=/zh/docs/concepts/configuration/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/concepts/configuration/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/concepts/configuration/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/configuration/>Français</a>
<a class=dropdown-item href=/de/docs/concepts/configuration/>Deutsch</a>
<a class=dropdown-item href=/es/docs/concepts/configuration/>Español</a>
<a class=dropdown-item href=/id/docs/concepts/configuration/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/configuration/>Українська</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
Essa é a versão completa de impressão dessa seção
<a href=# onclick="return print(),!1">Clique aqui para imprimir</a>.
</p><p>
<a href=/pt-br/docs/concepts/configuration/>Retornar à visualização normal</a>.
</p>
</div>
<h1 class=title>Configuração</h1>
<ul>
<li>1: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>Melhores Práticas de Configuração</a></li>
<li>2: <a href=#pg-6b5ccadd699df0904e8e9917c5450c4b>ConfigMaps</a></li>
<li>3: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>Organizando o acesso ao cluster usando arquivos kubeconfig</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>1 - Melhores Práticas de Configuração</h1>
<p>Esse documento destaca e consolida as melhores práticas de configuração apresentadas em todo o guia de usuário,
na documentação de introdução e nos exemplos.</p>
<p>Este é um documento vivo. Se você pensar em algo que não está nesta lista, mas pode ser útil para outras pessoas,
não hesite em criar uma <em>issue</em> ou submeter um PR.</p>
<h2 id=dicas-gerais-de-configuração>Dicas Gerais de Configuração</h2>
<ul>
<li>
<p>Ao definir configurações, especifique a versão mais recente estável da API.</p>
</li>
<li>
<p>Os arquivos de configuração devem ser armazenados em um sistema de controle antes de serem enviados ao cluster.
Isso permite que você reverta rapidamente uma alteração de configuração, caso necessário. Isso também auxilia na recriação e restauração do cluster.</p>
</li>
<li>
<p>Escreva seus arquivos de configuração usando YAML ao invés de JSON. Embora esses formatos possam ser usados alternadamente em quase todos os cenários, YAML tende a ser mais amigável.</p>
</li>
<li>
<p>Agrupe objetos relacionados em um único arquivo sempre que fizer sentido. Geralmente, um arquivo é mais fácil de
gerenciar do que vários. Veja o <a href=https://github.com/kubernetes/examples/tree/v1.22.16/guestbook/all-in-one/guestbook-all-in-one.yaml>guestbook-all-in-one.yaml</a> como exemplo dessa sintaxe.</p>
</li>
<li>
<p>Observe também que vários comandos <code>kubectl</code> podem ser chamados em um diretório. Por exemplo, você pode chamar
<code>kubectl apply</code> em um diretório de arquivos de configuração.</p>
</li>
<li>
<p>Não especifique valores padrões desnecessariamente: configurações simples e mínimas diminuem a possibilidade de erros.</p>
</li>
<li>
<p>Coloque descrições de objetos nas anotações para permitir uma melhor análise.</p>
</li>
</ul>
<h2 id=naked-pods-vs-replicasets-deployments-and-jobs>"Naked" Pods comparados a ReplicaSets, Deployments, e Jobs</h2>
<ul>
<li>
<p>Se você puder evitar, não use "naked" Pods (ou seja, se você puder evitar, pods não vinculados a um <a href=/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> ou <a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a>).
Os "naked" pods não serão reconfigurados em caso de falha de um nó.</p>
<p>Criar um Deployment, que cria um ReplicaSet para garantir que o número desejado de Pods esteja disponível e especifica uma estratégia para substituir os Pods (como <a href=/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment>RollingUpdate</a>), é quase sempre preferível do que criar Pods diretamente, exceto para alguns cenários explícitos de restartPolicy:Never. Um Job também pode ser apropriado.</p>
</li>
</ul>
<h2 id=services>Services</h2>
<ul>
<li>
<p>Crie o <a href=/docs/concepts/services-networking/service/>Service</a> antes de suas cargas de trabalho de backend correspondentes (Deployments ou ReplicaSets) e antes de quaisquer cargas de trabalho que precisem acessá-lo. Quando o
Kubernetes inicia um contêiner, ele fornece variáveis de ambiente apontando para todos os Services que estavam em execução quando o contêiner foi iniciado. Por exemplo, se um Service chamado <code>foo</code> existe, todos os contêineres vão
receber as seguintes variáveis em seu ambiente inicial:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;o host em que o Service está executando&gt;
<span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;a porta em que o Service está executando&gt;
</code></pre></div></li>
</ul>
<p><em>Isso implica em um requisito de pedido</em> - qualquer <code>Service</code> que um <code>Pod</code> quer acessar precisa ser criado antes do <code>Pod</code> em si, ou então as variáveis de ambiente não serão populadas. O DNS não possui essa restrição.</p>
<ul>
<li>
<p>Um <a href=/docs/concepts/cluster-administration/addons/>cluster add-on</a> opcional (embora fortemente recomendado) é um servidor DNS. O
servidor DNS monitora a API do Kubernetes buscando novos <code>Services</code> e cria um conjunto de DNS para cada um. Se o DNS foi habilitado em todo o cluster, então todos os <code>Pods</code> devem ser capazes de fazer a resolução de <code>Services</code> automaticamente.</p>
</li>
<li>
<p>Não especifique um <code>hostPort</code> para um Pod a menos que isso seja absolutamente necessário. Quando você vincula um Pod a um <code>hostPort</code>, isso limita o número de lugares em que o Pod pode ser agendado, porque cada
combinação de &lt;<code>hostIP</code>, <code>hostPort</code>, <code>protocol</code>> deve ser única. Se você não especificar o <code>hostIP</code> e <code>protocol</code> explicitamente, o Kubernetes vai usar <code>0.0.0.0</code> como o <code>hostIP</code> padrão e <code>TCP</code> como <code>protocol</code> padrão.</p>
<p>Se você precisa de acesso a porta apenas para fins de depuração, pode usar o <a href=/docs/tasks/access-application-cluster/access-cluster/#manually-constructing-apiserver-proxy-urls>apiserver proxy</a> ou o <a href=/docs/tasks/access-application-cluster/port-forward-access-application-cluster/><code>kubectl port-forward</code></a>.</p>
<p>Se você precisa expor explicitamente a porta de um Pod no nó, considere usar um Service do tipo <a href=/docs/concepts/services-networking/service/#nodeport>NodePort</a> antes de recorrer a <code>hostPort</code>.</p>
</li>
<li>
<p>Evite usar <code>hostNetwork</code> pelos mesmos motivos do <code>hostPort</code>.</p>
</li>
<li>
<p>Use <a href=/docs/concepts/services-networking/service/#headless-services>headless Services</a> (que tem um <code>ClusterIP</code> ou <code>None</code>) para descoberta de serviço quando você não precisar de um balanceador de carga <code>kube-proxy</code>.</p>
</li>
</ul>
<h2 id=usando-labels>Usando Labels</h2>
<ul>
<li>Defina e use <a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> que identifiquem <em>atributos semânticos</em> da sua aplicação ou Deployment, como <code>{ app: myapp, tier: frontend, phase: test, deployment: v3 }</code>. Você pode usar essas labels para selecionar os Pods apropriados para outros recursos; por exemplo, um Service que seleciona todos os Pods <code>tier: frontend</code>, ou todos
os componentes de <code>app: myapp</code>. Veja o app <a href=https://github.com/kubernetes/examples/tree/v1.22.16/guestbook/>guestbook</a> para exemplos dessa abordagem.</li>
</ul>
<p>Um Service pode ser feito para abranger vários Deployments, omitindo labels específicas de lançamento de seu seletor. Quando você
precisar atualizar um serviço em execução sem <em>downtime</em>, use um <a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a>.</p>
<p>Um estado desejado de um objeto é descrito por um Deployment, e se as alterações nesse <em>spec</em> forem <em>aplicadas</em> o controlador
do Deployment altera o estado real para o estado desejado em uma taxa controlada.</p>
<ul>
<li>
<p>Use as <a href=/docs/concepts/overview/working-with-objects/common-labels/>labels comuns do Kubernetes</a> para casos de uso comuns.
Essas labels padronizadas enriquecem os metadados de uma forma que permite que ferramentas, incluindo <code>kubectl</code> e a <a href=/docs/tasks/access-application-cluster/web-ui-dashboard>dashboard</a>, funcionem de uma forma interoperável.</p>
</li>
<li>
<p>Você pode manipular labels para depuração. Como os controladores do Kubernetes (como ReplicaSet) e Services se relacionam com os Pods usando seletor de labels, remover as labels relevantes de um Pod impedirá que ele seja considerado por um controlador ou que
seja atendido pelo tráfego de um Service. Se você remover as labels de um Pod existente, seu controlador criará um novo Pod para
substituí-lo. Essa é uma maneira útil de depurar um Pod anteriormente "ativo" em um ambiente de "quarentena". Para remover ou
alterar labels interativamente, use <a href=/docs/reference/generated/kubectl/kubectl-commands#label><code>kubectl label</code></a>.</p>
</li>
</ul>
<h2 id=imagens-de-contêiner>Imagens de Contêiner</h2>
<p>A <a href=/docs/concepts/containers/images/#updating-images>imagePullPolicy</a> e tag da imagem afetam quando o <a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> tenta puxar a imagem especificada.</p>
<ul>
<li>
<p><code>imagePullPolicy: IfNotPresent</code>: a imagem é puxada apenas se ainda não estiver presente localmente.</p>
</li>
<li>
<p><code>imagePullPolicy: Always</code>: sempre que o kubelet inicia um contêiner, ele consulta o <em>registry</em> da imagem do contêiner para verificar o resumo de assinatura da imagem. Se o kubelet tiver uma imagem do contêiner com o mesmo resumo de assinatura
armazenado em cache localmente, o kubelet usará a imagem em cache, caso contrário, o kubelet baixa(<em>pulls</em>) a imagem com o resumo de assinatura resolvido, e usa essa imagem para iniciar o contêiner.</p>
</li>
<li>
<p><code>imagePullPolicy</code> é omitido se a tag da imagem é <code>:latest</code> ou se <code>imagePullPolicy</code> é omitido é automaticamente definido como <code>Always</code>. Observe que <em>não</em> será utilizado para <code>ifNotPresent</code>se o valor da tag mudar.</p>
</li>
<li>
<p><code>imagePullPolicy</code> é omitido se uma tag da imagem existe mas não <code>:latest</code>: <code>imagePullPolicy</code> é automaticamente definido como <code>ifNotPresent</code>. Observe que isto <em>não</em> será atualizado para <code>Always</code> se a tag for removida ou alterada para <code>:latest</code>.</p>
</li>
<li>
<p><code>imagePullPolicy: Never</code>: presume-se que a imagem exista localmente. Não é feita nenhuma tentativa de puxar a imagem.</p>
</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>Nota:</strong> Para garantir que seu contêiner sempre use a mesma versão de uma imagem, você pode especificar seu <a href=https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier>resumo de assinatura</a>;
substitua <code>&lt;nome-da-imagem>:&lt;tag></code> por <code>&lt;nome-da-imagem>@&lt;hash></code> (por exemplo, <code>image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>). Esse resumo de assinatura identifica exclusivamente uma versão
específica de uma imagem, então isso nunca vai ser atualizado pelo Kubernetes a menos que você mude o valor do resumo de assinatura da imagem.
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Nota:</strong> Você deve evitar o uso da tag <code>:latest</code> em produção, pois é mais difícil rastrear qual versão da imagem está sendo executada e mais difícil reverter adequadamente.
</div>
<div class="alert alert-info note callout" role=alert>
<strong>Nota:</strong> A semântica de cache do provedor de imagem subjacente torna até mesmo <code>imagePullPolicy: Always</code> eficiente, contanto que o registro esteja acessível de forma confiável. Com o Docker, por exemplo, se a imagem já existe, a tentativa de baixar(pull) é rápida porque todas as camadas da imagem são armazenadas em cache e nenhum download de imagem é necessário.
</div>
<h2 id=usando-kubectl>Usando kubectl</h2>
<ul>
<li>
<p>Use <code>kubectl apply -f &lt;directory></code>. Isso procura por configurações do Kubernetes em todos os arquivos <code>.yaml</code>, <code>.yml</code> em <code>&lt;directory></code> e passa isso para <code>apply</code>.</p>
</li>
<li>
<p>Use <em>labels selectors</em> para operações <code>get</code> e <code>delete</code> em vez de nomes de objetos específicos. Consulte as seções sobre <a href=/docs/concepts/overview/working-with-objects/labels/#label-selectors>label selectors</a>
e <a href=/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively>usando Labels efetivamente</a>.</p>
</li>
<li>
<p>Use <code>kubectl create deployment</code> e <code>kubectl expose</code> para criar rapidamente Deployments e Services de um único contêiner. Consulte <a href=/docs/tasks/access-application-cluster/service-access-application-cluster/>Use um Service para acessar uma aplicação em um cluster</a> para obter um exemplo.</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6b5ccadd699df0904e8e9917c5450c4b>2 - ConfigMaps</h1>
<p><p>Um ConfigMap é um objeto da API usado para armazenar dados não-confidenciais em pares chave-valor.
<a class=glossary-tooltip title="O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> podem consumir ConfigMaps como variáveis de ambiente, argumentos de linha de comando ou como arquivos de configuração em um <a class=glossary-tooltip title="Um diretório contendo dados, accessível aos contêineres em um pod." data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a>.</p></p>
<p>Um ConfigMap ajuda a desacoplar configurações vinculadas ao ambiente das <a class=glossary-tooltip title="Instância armazenada de um contêiner que contém o conjunto de softwares necessários para rodar uma aplicação." data-toggle=tooltip data-placement=top href="/pt-br/docs/reference/glossary/?all=true#term-image" target=_blank aria-label="imagens de contêiner">imagens de contêiner</a>, de modo a tornar aplicações mais facilmente portáveis.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>Cuidado:</strong> O ConfigMap não oferece confidencialidade ou encriptação.
Se os dados que você deseja armazenar são confidenciais, utilize
<a class=glossary-tooltip title="Armazena dados sensíveis, como senhas, tokens OAuth e chaves SSH." data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> ao invés de um ConfigMap,
ou utilize ferramentas adicionais (de terceiros) para manter seus dados privados.
</div>
<h2 id=motivação>Motivação</h2>
<p>Utilize um ConfigMap para manter a configuração separada do código da aplicação.</p>
<p>Por exemplo, imagine que você esteja desenvolvendo uma aplicação que pode ser executada
no seu computador local (para desenvolvimento) e na nuvem (para manipular tráfego real).
Você escreve código para ler a variável de ambiente chamada <code>DATABASE_HOST</code>.
No seu ambiente local, você configura essa variável com o valor <code>localhost</code>. Na nuvem, você
configura essa variável para referenciar um <a class=glossary-tooltip title="Uma forma abstrata de expor uma aplicação que está executando em um conjunto de Pods como um serviço de rede." data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=serviço>serviço</a>
do Kubernetes que expõe o componente do banco de dados ao seu cluster.
Isto permite que você baixe uma imagem de contêiner que roda na nuvem e depure exatamente
o mesmo código localmente se necessário.</p>
<p>Um ConfigMap não foi planejado para conter grandes quantidades de dados. Os dados armazenados
em um ConfigMap não podem exceder 1 MiB. Se você precisa armazenar configurações que são maiores
que este limite, considere montar um volume ou utilizar um serviço separado de banco de dados
ou de arquivamento de dados.</p>
<h2 id=objeto-configmap>Objeto ConfigMap</h2>
<p>Um ConfigMap é um <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/>objeto</a>
da API que permite o armazenamento de configurações para consumo por outros objetos. Diferentemente
de outros objetos do Kubernetes que contém um campo <code>spec</code>, o ConfigMap contém os campos <code>data</code> e
<code>binaryData</code>. Estes campos aceitam pares chave-valor como valores. Ambos os campos <code>data</code> e <code>binaryData</code>
são opcionais. O campo <code>data</code> foi pensado para conter sequências de bytes UTF-8, enquanto o campo <code>binaryData</code>
foi planejado para conter dados binários em forma de strings codificadas em base64.</p>
<p>É obrigatório que o nome de um ConfigMap seja um
<a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>subdomínio DNS válido</a>.</p>
<p>Cada chave sob as seções <code>data</code> ou <code>binaryData</code> pode conter quaisquer caracteres alfanuméricos,
<code>-</code>, <code>_</code> e <code>.</code>. As chaves armazenadas na seção <code>data</code> não podem colidir com as chaves armazenadas
na seção <code>binaryData</code>.</p>
<p>A partir da versão v1.19 do Kubernetes, é possível adicionar o campo <code>immutable</code> a uma definição de ConfigMap
para criar um <a href=#configmap-immutable>ConfigMap imutável</a>.</p>
<h2 id=configmaps-e-pods>ConfigMaps e Pods</h2>
<p>Você pode escrever uma <code>spec</code> para um Pod que se refere a um ConfigMap e configurar o(s) contêiner(es)
neste Pod baseados em dados do ConfigMap. O Pod e o ConfigMap devem estar no mesmo
<a class=glossary-tooltip title="Uma abstração utilizada pelo Kubernetes para suportar múltiplos clusters virtuais no mesmo cluster físico." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Nota:</strong> A <code>spec</code> de um <a class=glossary-tooltip title="Um pod gerenciado diretamente pelo daemon do kubelet em um nó específico." data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label="Pod estático">Pod estático</a> não pode se referir a um
ConfigMap ou a quaisquer outros objetos da API.
</div>
<p>Exemplo de um ConfigMap que contém algumas chaves com valores avulsos e outras chaves com valores semelhantes
a fragmentos de arquivos de configuração:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># chaves com valores de propriedades; cada chave mapeia para um valor avulso</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>player_initial_lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui_properties_file_name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># chaves semelhantes a fragmentos de arquivos</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    enemy.types=aliens,monsters
</span><span style=color:#b44;font-style:italic>    player.maximum-lives=5</span><span style=color:#bbb>    
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user-interface.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    color.good=purple
</span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span><span style=color:#b44;font-style:italic>    allow.textmode=true</span><span style=color:#bbb>    
</span></code></pre></div><p>Existem quatro formas diferentes para consumo de um ConfigMap na configuração de um
contêiner dentro de um Pod:</p>
<ol>
<li>Dentro de um comando de contêiner e seus argumentos.</li>
<li>Variáveis de ambiente para um contêiner.</li>
<li>Criando um arquivo em um volume somente leitura, para consumo pela aplicação.</li>
<li>Escrevendo código para execução dentro do Pod que utilize a API do Kubernetes para ler um ConfigMap.</li>
</ol>
<p>Os diferentes métodos de consumo oferecem diferentes formas de modelar os dados sendo consumidos.
Para os três primeiros métodos, o <a class=glossary-tooltip title="Um agente que é executado em cada node no cluster. Ele garante que os contêineres estejam sendo executados em um pod." data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kubelet target=_blank aria-label=kubelet>kubelet</a> utiliza
os dados de um ConfigMap quando o(s) contêiner(es) do Pod são inicializados.</p>
<p>O quarto método envolve escrita de código para leitura do ConfigMap e dos seus dados. No entanto,
como a API do Kubernetes está sendo utilizada diretamente, a aplicação pode solicitar atualizações
sempre que o ConfigMap for alterado e reagir quando isso ocorre. Acessar a API do Kubernetes
diretamente também permite ler ConfigMaps em outros namespaces.</p>
<p>Exemplo de um Pod que utiliza valores do ConfigMap <code>game-demo</code> para configurar um Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-demo-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>alpine<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;3600&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Define as variáveis de ambiente</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PLAYER_INITIAL_LIVES<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Note que aqui a variável está definida em caixa alta,</span><span style=color:#bbb>
</span><span style=color:#bbb>                                     </span><span style=color:#080;font-style:italic># diferente da chave no ConfigMap.</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo          <span style=color:#bbb> </span><span style=color:#080;font-style:italic># O ConfigMap de onde esse valor vem.</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>player_initial_lives<span style=color:#bbb> </span><span style=color:#080;font-style:italic># A chave que deve ser buscada.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>UI_PROPERTIES_FILE_NAME<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ui_properties_file_name<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/config&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Volumes são definidos no escopo do Pod, e os pontos de montagem são definidos</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># nos contêineres dentro dos pods.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Informe o nome do ConfigMap que deseja montar.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Uma lista de chaves do ConfigMap para serem criadas como arquivos.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>ConfigMaps não diferenciam entre propriedades com valores simples ou valores complexos,
que ocupam várias linhas. O importante é a forma que Pods e outros objetos consomem tais valores.</p>
<p>Neste exemplo, definir um volume e montar ele dentro do contêiner <code>demo</code> no caminho <code>/config</code>
cria dois arquivos: <code>/config/game.properties</code> e <code>/config/user-interface.properties</code>, embora existam
quatro chaves distintas no ConfigMap. Isso se deve ao fato de que a definição do Pod contém uma lista
<code>items</code> na seção <code>volumes</code>.
Se a lista <code>items</code> for omitida, cada chave do ConfigMap torna-se um arquivo cujo nome é a sua chave
correspondente, e quatro arquivos serão criados.</p>
<h2 id=usando-configmaps>Usando ConfigMaps</h2>
<p>ConfigMaps podem ser montados como volumes de dados. ConfigMaps também podem ser utilizados
por outras partes do sistema sem serem diretamente expostos ao Pod. Por exemplo, ConfigMaps
podem conter dados que outras partes do sistema devem usar para configuração.</p>
<p>A forma mais comum de utilização de ConfigMaps é a configuração de contêineres executando em
Pods no mesmo namespace. Você também pode utilizar um ConfigMap separadamente.</p>
<p>Por exemplo, existem <a class=glossary-tooltip title="Recursos que estendem a funcionalidade do Kubernetes." data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/cluster-administration/addons/ target=_blank aria-label=complementos>complementos</a> ou
<a class=glossary-tooltip title="Um controlador especializado que gerencia um recurso personalizado." data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operadores>operadores</a> que adaptam seus comportamentos
de acordo com dados de um ConfigMap.</p>
<h3 id=utilizando-configmaps-como-arquivos-em-um-pod>Utilizando ConfigMaps como arquivos em um Pod</h3>
<p>Para consumir um ConfigMap em um volume em um Pod:</p>
<ol>
<li>Crie um ConfigMap ou utilize um ConfigMap existente. Múltiplos Pods
podem referenciar o mesmo ConfigMap.</li>
<li>Modifique sua definição de Pod para adicionar um volume em
<code>.spec.volumes[]</code>. Escolha um nome qualquer para o seu volume, e
referencie o seu objeto ConfigMap no campo
<code>.spec.volumes[].configMap.name</code>.</li>
<li>Adicione um campo <code>.spec.containers[].volumeMounts[]</code> a cada um dos
contêineres que precisam do ConfigMap. Especifique
<code>.spec.containers[].volumeMounts[].readOnly = true</code> e informe no campo
<code>.spec.containers[].volumeMounts[].mountPath</code> um caminho de um diretório
não utilizado onde você deseja que este ConfigMap apareça.</li>
<li>Modifique sua imagem ou linha de comando de modo que o programa procure
por arquivos no diretório especificado no passo anterior. Cada chave no
campo <code>data</code> do ConfigMap será transformado em um nome de arquivo no
diretório especificado por <code>mountPath</code>.</li>
</ol>
<p>Exemplo de um Pod que monta um ConfigMap em um volume:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></code></pre></div><p>Cada ConfigMap que você deseja utilizar precisa ser referenciado em
<code>.spec.volumes</code>.</p>
<p>Se houver múltiplos contêineres no Pod, cada contêiner deve ter seu
próprio bloco <code>volumeMounts</code>, mas somente uma instância de <code>.spec.volumes</code>
é necessária por ConfigMap.</p>
<h3 id=configmaps-montados-são-atualizados-automaticamente>ConfigMaps montados são atualizados automaticamente</h3>
<p>Quando um ConfigMap que está sendo consumido em um volume é atualizado, as chaves projetadas são
eventualmente atualizadas também. O Kubelet checa se o ConfigMap montado está atualizado em cada
sincronização periódica.
No entanto, o kubelet utiliza o cache local para buscar o valor atual do ConfigMap.
O tipo de cache é configurável utilizando o campo <code>ConfigMapAndSecretChangeDetectionStrategy</code> na
<a href=/docs/reference/config-api/kubelet-config.v1beta1/>configuração do Kubelet (KubeletConfiguration)</a>.
Um ConfigMap pode ter sua propagação baseada em um <em>watch</em> (comportamento padrão), que é o sistema
de propagação de mudanças incrementais em objetos do Kubernetes; baseado em TTL (<em>time to live</em>,
ou tempo de expiração); ou redirecionando todas as requisições diretamente para o servidor da API.
Como resultado, o tempo decorrido total entre o momento em que o ConfigMap foi atualizado até o momento
quando as novas chaves são projetadas nos Pods pode ser tão longo quanto o tempo de sincronização
do kubelet somado ao tempo de propagação do cache, onde o tempo de propagação do cache depende do
tipo de cache escolhido: o tempo de propagação pode ser igual ao tempo de propagação do <em>watch</em>,
TTL do cache, ou zero, de acordo com cada um dos tipos de cache.</p>
<p>ConfigMaps que são consumidos como variáveis de ambiente não atualizam automaticamente e requerem uma
reinicialização do pod.</p>
<h2 id=configmap-immutable>ConfigMaps imutáveis</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p>A funcionalidade <em>Secrets e ConfigMaps imutáveis</em> do Kubernetes fornece uma opção
para marcar Secrets e ConfigMaps individuais como imutáveis. Para clusters que utilizam
ConfigMaps extensivamente (ao menos centenas de milhares de mapeamentos únicos de
ConfigMaps para Pods), prevenir alterações dos seus dados traz as seguintes vantagens:</p>
<ul>
<li>protege de atualizações acidentais ou indesejadas que podem causar disrupção na execução
de aplicações</li>
<li>melhora o desempenho do cluster através do fechamento de <em>watches</em> de ConfigMaps marcados
como imutáveis, diminuindo significativamente a carga no kube-apiserver</li>
</ul>
<p>Essa funcionalidade é controlada pelo <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
<code>ImmutableEphemeralVolumes</code>. É possível criar um ConfigMap imutável adicionando o campo
<code>immutable</code> e marcando seu valor com <code>true</code>.
Por exemplo:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><p>Após um ConfigMap ser marcado como imutável, <em>não</em> é possível reverter a alteração, nem
alterar o conteúdo dos campos <code>data</code> ou <code>binaryData</code>. É possível apenas apagar e recriar
o ConfigMap. Como Pods existentes que consomem o ConfigMap em questão mantém um ponto de
montagem que continuará referenciando este objeto após a remoção, é recomendado recriar
estes pods.</p>
<h2 id=próximos-passos>Próximos passos</h2>
<ul>
<li>Leia sobre <a href=/docs/concepts/configuration/secret/>Secrets</a> (em inglês).</li>
<li>Leia <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>Configure a Pod to Use a ConfigMap</a> (em inglês).</li>
<li>Leia <a href=https://12factor.net/>The Twelve-Factor App</a> (em inglês) para entender a motivação da separação de código
e configuração.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>3 - Organizando o acesso ao cluster usando arquivos kubeconfig</h1>
<p>Utilize arquivos kubeconfig para organizar informações sobre clusters, usuários, namespaces e mecanismos de autenticação. A ferramenta de linha de comando <code>kubectl</code> faz uso dos arquivos kubeconfig para encontrar as informações necessárias para escolher e se comunicar com o serviço de API de um cluster.</p>
<div class="alert alert-info note callout" role=alert>
<strong>Nota:</strong> Um arquivo que é utilizado para configurar o acesso aos clusters é chamado de <em>kubeconfig</em>. Esta á uma forma genérica de referenciamento para um arquivo de configuração desta natureza. Isso não significa que existe um arquivo com o nome <code>kubeconfig</code>.
</div>
<p>Por padrão, o <code>kubectl</code> procura por um arquivo de nome <code>config</code> no diretório <code>$HOME/.kube</code></p>
<p>Você pode especificar outros arquivos kubeconfig através da variável de ambiente <code>KUBECONFIG</code> ou adicionando a opção <a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a>.</p>
<p>Para maiores detalhes na criação e especificação de um kubeconfig, veja o passo a passo em <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters>Configurar Acesso para Múltiplos Clusters</a>.</p>
<h2 id=suportando-múltiplos-clusters-usuários-e-mecanismos-de-autenticação>Suportando múltiplos clusters, usuários e mecanismos de autenticação</h2>
<p>Imagine que você possua inúmeros clusters, e seus usuários e componentes se autenticam de várias formas. Por exemplo:</p>
<ul>
<li>Um kubelet ativo pode se autenticar utilizando certificados</li>
<li>Um usuário pode se autenticar através de tokens</li>
<li>Administradores podem possuir conjuntos de certificados os quais provém acesso aos usuários de forma individual.</li>
</ul>
<p>Através de arquivos kubeconfig, você pode organizar os seus clusters, usuários, e namespaces. Você também pode definir contextos para uma fácil troca entre clusters e namespaces.</p>
<h2 id=contexto>Contexto</h2>
<p>Um elemento de <em>contexto</em> em um kubeconfig é utilizado para agrupar parâmetros de acesso em um nome conveniente. Cada contexto possui três parâmetros: cluster, namespace, e usuário.</p>
<p>Por padrão, a ferramenta de linha de comando <code>kubectl</code> utiliza os parâmetros do <em>contexto atual</em> para se comunicar com o cluster.</p>
<p>Para escolher o contexto atual:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config use-context
</code></pre></div><h2 id=a-variável-de-ambiente-kubeconfig>A variável de ambiente KUBECONFIG</h2>
<p>A variável de ambiente <code>KUBECONFIG</code> possui uma lista dos arquivos kubeconfig. Para Linux e Mac, esta lista é delimitada por vírgula. No Windows, a lista é delimitada por ponto e vírgula. A variável de ambiente <code>KUBECONFIG</code> não é um requisito obrigatório - caso ela não exista o <code>kubectl</code> utilizará o arquivo kubeconfig padrão localizado no caminho <code>$HOME/.kube/config</code>.</p>
<p>Se a variável de ambiente <code>KUBECONFIG</code> existir, o <code>kubectl</code> utilizará uma configuração que é o resultado da combinação dos arquivos listados na variável de ambiente <code>KUBECONFIG</code>.</p>
<h2 id=combinando-arquivos-kubeconfig>Combinando arquivos kubeconfig</h2>
<p>Para inspecionar a sua configuração atual, execute o seguinte comando:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div><p>Como descrito anteriormente, a saída poderá ser resultado de um único arquivo kubeconfig, ou poderá ser o resultado da junção de vários arquivos kubeconfig.</p>
<p>Aqui estão as regras que o <code>kubectl</code> utiliza quando realiza a combinação de arquivos kubeconfig:</p>
<ol>
<li>
<p>Se o argumento <code>--kubeconfig</code> está definido, apenas o arquivo especificado será utilizado. Apenas uma instância desta flag é permitida.</p>
<p>Caso contrário, se a variável de ambiente <code>KUBECONFIG</code> estiver definida, esta deverá ser utilizada como uma lista de arquivos a serem combinados, seguindo o fluxo a seguir:</p>
<ul>
<li>Ignorar arquivos vazios.</li>
<li>Produzir erros para aquivos cujo conteúdo não for possível desserializar.</li>
<li>O primeiro arquivo que definir um valor ou mapear uma chave determinada, será o escolhido.</li>
<li>Nunca modificar um valor ou mapear uma chave.
Exemplo: Preservar o contexto do primeiro arquivo que definir <code>current-context</code>.
Exemplo: Se dois arquivos especificarem um <code>red-user</code>, use apenas os valores do primeiro <code>red-user</code>. Mesmo se um segundo arquivo possuir entradas não conflitantes sobre a mesma entrada <code>red-user</code>, estas deverão ser descartadas.</li>
</ul>
<p>Para um exemplo de definição da variável de ambiente <code>KUBECONFIG</code> veja <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable>Definido a variável de ambiente KUBECONFIG</a>.</p>
<p>Caso contrário, utilize o arquivo kubeconfig padrão encontrado no diretório <code>$HOME/.kube/config</code>, sem qualquer tipo de combinação.</p>
</li>
<li>
<p>Determine o contexto a ser utilizado baseado no primeiro padrão encontrado, nesta ordem:</p>
<ol>
<li>Usar o conteúdo da flag <code>--context</code> caso ela existir.</li>
<li>Usar o <code>current-context</code> a partir da combinação dos arquivos kubeconfig.</li>
</ol>
<p>Um contexto vazio é permitido neste momento.</p>
</li>
<li>
<p>Determinar o cluster e o usuário. Neste ponto, poderá ou não existir um contexto.
Determinar o cluster e o usuário no primeiro padrão encontrado de acordo com a ordem à seguir. Este procedimento deverá executado duas vezes: uma para definir o usuário a outra para definir o cluster.</p>
<ol>
<li>Utilizar a flag caso ela existir: <code>--user</code> ou <code>--cluster</code>.</li>
<li>Se o contexto não estiver vazio, utilizar o cluster ou usuário deste contexto.</li>
</ol>
<p>O usuário e o cluster poderão estar vazios neste ponto.</p>
</li>
<li>
<p>Determinar as informações do cluster atual a serem utilizadas. Neste ponto, poderá ou não existir informações de um cluster.</p>
<p>Construir cada peça de informação do cluster baseado nas opções à seguir; a primeira ocorrência encontrada será a opção vencedora:</p>
<ol>
<li>Usar as flags de linha de comando caso existirem: <code>--server</code>, <code>--certificate-authority</code>, <code>--insecure-skip-tls-verify</code>.</li>
<li>Se algum atributo do cluster existir a partir da combinação de kubeconfigs, estes deverão ser utilizados.</li>
<li>Se não existir informação de localização do servidor falhar.</li>
</ol>
</li>
<li>
<p>Determinar a informação atual de usuário a ser utilizada. Construir a informação de usuário utilizando as mesmas regras utilizadas para o caso de informações de cluster, exceto para a regra de técnica de autenticação que deverá ser única por usuário:</p>
<ol>
<li>Usar as flags, caso existirem: <code>--client-certificate</code>, <code>--client-key</code>, <code>--username</code>, <code>--password</code>, <code>--token</code>.</li>
<li>Usar os campos <code>user</code> resultado da combinação de arquivos kubeconfig.</li>
<li>Se existirem duas técnicas conflitantes, falhar.</li>
</ol>
</li>
<li>
<p>Para qualquer informação que ainda estiver ausente, utilizar os valores padrão e potencialmente solicitar informações de autenticação a partir do prompt de comando.</p>
</li>
</ol>
<h2 id=referências-de-arquivos>Referências de arquivos</h2>
<p>Arquivos e caminhos referenciados em um arquivo kubeconfig são relativos à localização do arquivo kubeconfig.</p>
<p>Referências de arquivos na linha de comando são relativas ao diretório de trabalho vigente.</p>
<p>No arquivo <code>$HOME/.kube/config</code>, caminhos relativos são armazenados de forma relativa, e caminhos absolutos são armazenados de forma absoluta.</p>
<h2 id=próximos-passos>Próximos passos</h2>
<ul>
<li><a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Configurar Accesso para Multiplos Clusters</a></li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/pt-br/docs/home/>Home</a>
<a class=text-white href=/pt-br/blog/>Blog</a>
<a class=text-white href=/pt-br/partners/>Parceiros</a>
<a class=text-white href=/pt-br/community/>Comunidade</a>
<a class=text-white href=/pt-br/case-studies/>Casos de estudo</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 Os autores do Kubernetes | Documentação Distribuída sob <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 A Fundação Linux &reg;. Todos os direitos reservados. A Linux Foundation tem marcas registradas e usa marcas registradas. Para uma lista de marcas registradas da The Linux Foundation, por favor, veja nossa <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Página de uso de marca registrada</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>