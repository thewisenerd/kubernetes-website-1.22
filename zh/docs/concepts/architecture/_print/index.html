<!doctype html><html lang=zh class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/architecture/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/architecture/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/architecture/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/architecture/>
<link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/architecture/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/architecture/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/architecture/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/architecture/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/architecture/>
<link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/architecture/>
<link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/architecture/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/zh/docs/concepts/architecture/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>Kubernetes 架构 | Kubernetes</title><meta property="og:title" content="Kubernetes 架构">
<meta property="og:description" content="Kubernetes 背后的架构概念。
">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/zh/docs/concepts/architecture/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="Kubernetes 架构">
<meta itemprop=description content="Kubernetes 背后的架构概念。
"><meta name=twitter:card content="summary">
<meta name=twitter:title content="Kubernetes 架构">
<meta name=twitter:description content="Kubernetes 背后的架构概念。
">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="Kubernetes 背后的架构概念。
">
<meta property="og:description" content="Kubernetes 背后的架构概念。
">
<meta name=twitter:description content="Kubernetes 背后的架构概念。
">
<meta property="og:url" content="https://kubernetes.io/zh/docs/concepts/architecture/">
<meta property="og:title" content="Kubernetes 架构">
<meta name=twitter:title content="Kubernetes 架构">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/zh/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/zh/docs/>文档</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/blog/>Kubernetes 博客</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/training/>培训</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/partners/>合作伙伴</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/community/>社区</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/case-studies/>案例分析</span></a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
版本列表
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh/docs/concepts/architecture/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/zh/docs/concepts/architecture/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh/docs/concepts/architecture/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh/docs/concepts/architecture/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh/docs/concepts/architecture/>v1.22</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/concepts/architecture/>English</a>
<a class=dropdown-item href=/ko/docs/concepts/architecture/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/concepts/architecture/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/architecture/>Français</a>
<a class=dropdown-item href=/it/docs/concepts/architecture/>Italiano</a>
<a class=dropdown-item href=/de/docs/concepts/architecture/>Deutsch</a>
<a class=dropdown-item href=/es/docs/concepts/architecture/>Español</a>
<a class=dropdown-item href=/pt-br/docs/concepts/architecture/>Português</a>
<a class=dropdown-item href=/id/docs/concepts/architecture/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/architecture/>Tiếng Việt</a>
<a class=dropdown-item href=/ru/docs/concepts/architecture/>Русский</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/zh/docs/concepts/architecture/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>Kubernetes 架构</h1>
<div class=lead>Kubernetes 背后的架构概念。</div>
<ul>
<li>1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>节点</a></li>
<li>2: <a href=#pg-c0251def6da29b30afebfb04549f1703>控制面到节点通信</a></li>
<li>3: <a href=#pg-ca8819042a505291540e831283da66df>控制器</a></li>
<li>4: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>云控制器管理器</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>1 - 节点</h1>
<p>Kubernetes 通过将容器放入在节点（Node）上运行的 Pod 中来执行你的工作负载。
节点可以是一个虚拟机或者物理机器，取决于所在的集群配置。
每个节点包含运行 <a class=glossary-tooltip title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a> 所需的服务；
这些节点由 <a class=glossary-tooltip title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=控制面>控制面</a> 负责管理。</p>
<p>通常集群中会有若干个节点；而在一个学习用或者资源受限的环境中，你的集群中也可能
只有一个节点。</p>
<p>节点上的<a href=/zh/docs/concepts/overview/components/#node-components>组件</a>包括
<a class=glossary-tooltip title="一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。" data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>、
<a class=glossary-tooltip title=容器运行时是负责运行容器的软件。 data-toggle=tooltip data-placement=top href=/zh/docs/setup/production-environment/container-runtimes target=_blank aria-label=容器运行时>容器运行时</a>以及
<a class=glossary-tooltip title="kube-proxy 是集群中每个节点上运行的网络代理。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>。</p>
<h2 id=management>管理 </h2>
<p>向 <a class=glossary-tooltip title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank aria-label="API 服务器">API 服务器</a>添加节点的方式主要有两种：</p>
<ol>
<li>节点上的 <code>kubelet</code> 向控制面执行自注册；</li>
<li>你，或者别的什么人，手动添加一个 Node 对象。</li>
</ol>
<p>在你创建了 Node 对象或者节点上的 <code>kubelet</code> 执行了自注册操作之后，
控制面会检查新的 Node 对象是否合法。例如，如果你使用下面的 JSON
对象来创建 Node 对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
    }
  }
}
</code></pre></div>
<p>Kubernetes 会在内部创建一个 Node 对象作为节点的表示。Kubernetes 检查 <code>kubelet</code>
向 API 服务器注册节点时使用的 <code>metadata.name</code> 字段是否匹配。
如果节点是健康的（即所有必要的服务都在运行中），则该节点可以用来运行 Pod。
否则，直到该节点变为健康之前，所有的集群活动都会忽略该节点。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> Kubernetes 会一直保存着非法节点对应的对象，并持续检查该节点是否已经
变得健康。
你，或者某个<a class=glossary-tooltip title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>必需显式地
删除该 Node 对象以停止健康检查操作。
</div>
<p>Node 对象的名称必须是合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>。</p>
<h3 id=self-registration-of-nodes>节点自注册</h3>
<p>当 kubelet 标志 <code>--register-node</code> 为 true（默认）时，它会尝试向 API 服务注册自己。
这是首选模式，被绝大多数发行版选用。</p>
<p>对于自注册模式，kubelet 使用下列参数启动：</p>
<ul>
<li><code>--kubeconfig</code> - 用于向 API 服务器表明身份的凭据路径。</li>
<li><code>--cloud-provider</code> - 与某<a class=glossary-tooltip title=一个提供云计算平台的组织。 data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-cloud-provider" target=_blank aria-label=云驱动>云驱动</a>
进行通信以读取与自身相关的元数据的方式。</li>
<li><code>--register-node</code> - 自动向 API 服务注册。</li>
<li><code>--register-with-taints</code> - 使用所给的污点列表（逗号分隔的 <code>&lt;key>=&lt;value>:&lt;effect></code>）注册节点。
当 <code>register-node</code> 为 false 时无效。</li>
<li><code>--node-ip</code> - 节点 IP 地址。</li>
<li><code>--node-labels</code> - 在集群中注册节点时要添加的
<a class=glossary-tooltip title=用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=标签>标签</a>。
（参见 <a href=/zh/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction 准入控制插件</a>所实施的标签限制）。</li>
<li><code>--node-status-update-frequency</code> - 指定 kubelet 向控制面发送状态的频率。</li>
</ul>
<p>启用<a href=/zh/docs/reference/access-authn-authz/node/>节点授权模式</a>和
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction 准入插件</a>
时，仅授权 <code>kubelet</code> 创建或修改其自己的节点资源。</p>
<h3 id=manual-node-administration>手动节点管理</h3>
<p>你可以使用 <a class=glossary-tooltip title="kubectl 是用来和 Kubernetes API 服务器进行通信的命令行工具。" data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>
来创建和修改 Node 对象。</p>
<p>如果你希望手动创建节点对象时，请设置 kubelet 标志 <code>--register-node=false</code>。</p>
<p>你可以修改 Node 对象（忽略 <code>--register-node</code> 设置）。
例如，修改节点上的标签或标记其为不可调度。</p>
<p>你可以结合使用节点上的标签和 Pod 上的选择算符来控制调度。
例如，你可以限制某 Pod 只能在符合要求的节点子集上运行。</p>
<p>如果标记节点为不可调度（unschedulable），将阻止新 Pod 调度到该节点之上，但不会
影响任何已经在其上的 Pod。
这是重启节点或者执行其他维护操作之前的一个有用的准备步骤。</p>
<p>要标记一个节点为不可调度，执行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</code></pre></div>
<p>更多细节参考<a href=/zh/docs/tasks/administer-cluster/safely-drain-node/>安全腾空节点</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 被 <a class=glossary-tooltip title="确保 Pod 的副本在集群中的一组节点上运行。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/daemonset/ target=_blank aria-label=DaemonSet>DaemonSet</a> 控制器创建的 Pod
能够容忍节点的不可调度属性。
DaemonSet 通常提供节点本地的服务，即使节点上的负载应用已经被腾空，这些服务也仍需
运行在节点之上。
</div>
<h2 id=node-status>节点状态 </h2>
<p>一个节点的状态包含以下信息:</p>
<ul>
<li><a href=#addresses>地址</a></li>
<li><a href=#condition>状况</a></li>
<li><a href=#capacity>容量与可分配</a></li>
<li><a href=#info>信息</a></li>
</ul>
<p>你可以使用 <code>kubectl</code> 来查看节点状态和其他细节信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe node &lt;节点名称&gt;
</code></pre></div>
<p>下面对每个部分进行详细描述。</p>
<h3 id=addresses>地址 </h3>
<p>这些字段的用法取决于你的云服务商或者物理机配置。</p>
<ul>
<li>HostName：由节点的内核设置。可以通过 kubelet 的 <code>--hostname-override</code> 参数覆盖。</li>
<li>ExternalIP：通常是节点的可外部路由（从集群外可访问）的 IP 地址。</li>
<li>InternalIP：通常是节点的仅可在集群内部路由的 IP 地址。</li>
</ul>
<h3 id=condition>状况</h3>
<p><code>conditions</code> 字段描述了所有 <code>Running</code> 节点的状态。状况的示例包括：</p>
<table><caption style=display:none>节点状况及每种状况适用场景的描述</caption>
<thead>
<tr>
<th>节点状况</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ready</code></td>
<td>如节点是健康的并已经准备好接收 Pod 则为 <code>True</code>；<code>False</code> 表示节点不健康而且不能接收 Pod；<code>Unknown</code> 表示节点控制器在最近 <code>node-monitor-grace-period</code> 期间（默认 40 秒）没有收到节点的消息</td>
</tr>
<tr>
<td><code>DiskPressure</code></td>
<td><code>True</code> 表示节点存在磁盘空间压力，即磁盘可用量低, 否则为 <code>False</code></td>
</tr>
<tr>
<td><code>MemoryPressure</code></td>
<td><code>True</code> 表示节点存在内存压力，即节点内存可用量低，否则为 <code>False</code></td>
</tr>
<tr>
<td><code>PIDPressure</code></td>
<td><code>True</code> 表示节点存在进程压力，即节点上进程过多；否则为 <code>False</code></td>
</tr>
<tr>
<td><code>NetworkUnavailable</code></td>
<td><code>True</code> 表示节点网络配置不正确；否则为 <code>False</code></td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 如果使用命令行工具来打印已保护（Cordoned）节点的细节，其中的 Condition 字段可能
包括 <code>SchedulingDisabled</code>。<code>SchedulingDisabled</code> 不是 Kubernetes API 中定义的
Condition，被保护起来的节点在其规约中被标记为不可调度（Unschedulable）。
</div>
<p>在 Kubernetes API 中，节点的状况表示节点资源中<code>.status</code> 的一部分。
例如，以下 JSON 结构描述了一个健康节点：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
  {
    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
  }
]
</code></pre></div>
<p>如果 Ready 条件的 <code>status</code> 处于 <code>Unknown</code> 或者 <code>False</code> 状态的时间超过了 <code>pod-eviction-timeout</code> 值，
（一个传递给 <a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 的参数），
<a href=#node-controller>节点控制器</a> 会对节点上的所有 Pod 触发
<a class=glossary-tooltip title="API 发起的驱逐是一个先调用 Eviction API 创建驱逐对象，再由该对象体面地中止 Pod 的过程。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/scheduling-eviction/pod-eviction/#api-eviction target=_blank aria-label=API-发起的驱逐>API-发起的驱逐</a>。
默认的逐出超时时长为 <strong>5 分钟</strong>。
某些情况下，当节点不可达时，API 服务器不能和其上的 kubelet 通信。
删除 Pod 的决定不能传达给 kubelet，直到它重新建立和 API 服务器的连接为止。
与此同时，被计划删除的 Pod 可能会继续在游离的节点上运行。</p>
<p>节点控制器在确认 Pod 在集群中已经停止运行前，不会强制删除它们。
你可以看到这些可能在无法访问的节点上运行的 Pod 处于 <code>Terminating</code> 或者 <code>Unknown</code> 状态。
如果 kubernetes 不能基于下层基础设施推断出某节点是否已经永久离开了集群，
集群管理员可能需要手动删除该节点对象。
从 Kubernetes 删除节点对象将导致 API 服务器删除节点上所有运行的 Pod 对象并释放它们的名字。</p>
<p>节点生命周期控制器会自动创建代表状况的
<a href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/>污点</a>。
当调度器将 Pod 指派给某节点时，会考虑节点上的污点。
Pod 则可以通过容忍度（Toleration）表达所能容忍的污点。</p>
<h3 id=capacity>容量与可分配</h3>
<p>描述节点上的可用资源：CPU、内存和可以调度到节点上的 Pod 的个数上限。</p>
<p><code>capacity</code> 块中的字段标示节点拥有的资源总量。
<code>allocatable</code> 块指示节点上可供普通 Pod 消耗的资源量。</p>
<p>可以在学习如何在节点上<a href=/zh/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>预留计算资源</a>
的时候了解有关容量和可分配资源的更多信息。</p>
<h3 id=info>信息</h3>
<p>描述节点的一般信息，如内核版本、Kubernetes 版本（<code>kubelet</code> 和 <code>kube-proxy</code> 版本）、
容器运行时详细信息，以及 节点使用的操作系统。
<code>kubelet</code> 从节点收集这些信息并将其发布到 Kubernetes API。</p>
<h2 id=heartbeats>心跳 </h2>
<p>Kubernetes 节点发送的心跳帮助你的集群确定每个节点的可用性，并在检测到故障时采取行动。</p>
<p>对于节点，有两种形式的心跳:</p>
<ul>
<li>更新节点的 <code>.status</code></li>
<li><a href=/docs/reference/kubernetes-api/cluster-resources/lease-v1/>Lease</a> 对象
在 <code>kube-node-lease</code> <a class=glossary-tooltip title="名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=命名空间>命名空间</a>中。
每个节点都有一个关联的 Lease 对象。</li>
</ul>
<p>与 Node 的 <code>.status</code> 更新相比，<code>Lease</code> 是一种轻量级资源。
使用 <code>Leases</code> 心跳在大型集群中可以减少这些更新对性能的影响。</p>
<p>kubelet 负责创建和更新节点的 <code>.status</code>，以及更新它们对应的 <code>Lease</code>。</p>
<ul>
<li>当状态发生变化时，或者在配置的时间间隔内没有更新事件时，kubelet 会更新 <code>.status</code>。
<code>.status</code> 更新的默认间隔为 5 分钟（比不可达节点的 40 秒默认超时时间长很多）。</li>
<li><code>kubelet</code> 会每 10 秒（默认更新间隔时间）创建并更新其 <code>Lease</code> 对象。
<code>Lease</code> 更新独立于 <code>NodeStatus</code> 更新而发生。
如果 <code>Lease</code> 的更新操作失败，<code>kubelet</code> 会采用指数回退机制，从 200 毫秒开始
重试，最长重试间隔为 7 秒钟。</li>
</ul>
<h2 id=node-controller>节点控制器 </h2>
<p>节点<a class=glossary-tooltip title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>是
Kubernetes 控制面组件，管理节点的方方面面。</p>
<p>节点控制器在节点的生命周期中扮演多个角色。
第一个是当节点注册时为它分配一个 CIDR 区段（如果启用了 CIDR 分配）。</p>
<p>第二个是保持节点控制器内的节点列表与云服务商所提供的可用机器列表同步。
如果在云环境下运行，只要某节点不健康，节点控制器就会询问云服务是否节点的虚拟机仍可用。
如果不可用，节点控制器会将该节点从它的节点列表删除。</p>
<p>第三个是监控节点的健康状况。 节点控制器是负责：</p>
<ul>
<li>在节点节点不可达的情况下，在 Node 的 <code>.status</code> 中更新 <code>NodeReady</code> 状况。
在这种情况下，节点控制器将 <code>NodeReady</code> 状况更新为 <code>ConditionUnknown</code> 。</li>
<li>如果节点仍然无法访问：对于不可达节点上的所有 Pod触发
<a href=/zh/docs/concepts/scheduling-eviction/api-eviction/>API-发起的逐出</a>。
默认情况下，节点控制器 在将节点标记为 <code>ConditionUnknown</code> 后等待 5 分钟 提交第一个驱逐请求。</li>
</ul>
<p>节点控制器每隔 <code>--node-monitor-period</code> 秒检查每个节点的状态。</p>
<h3 id=rate-limits-on-eviction>逐出速率限制 </h3>
<p>大部分情况下，节点控制器把逐出速率限制在每秒 <code>--node-eviction-rate</code> 个（默认为 0.1）。
这表示它每 10 秒钟内至多从一个节点驱逐 Pod。</p>
<p>当一个可用区域（Availability Zone）中的节点变为不健康时，节点的驱逐行为将发生改变。
节点控制器会同时检查可用区域中不健康（NodeReady 状况为 <code>ConditionUnknown</code> 或 <code>ConditionFalse</code>）
的节点的百分比：</p>
<ul>
<li>如果不健康节点的比例超过 <code>--unhealthy-zone-threshold</code> （默认为 0.55），
驱逐速率将会降低。</li>
<li>如果集群较小（意即小于等于 <code>--large-cluster-size-threshold</code>
个节点 - 默认为 50），驱逐操作将会停止。</li>
<li>否则驱逐速率将降为每秒 <code>--secondary-node-eviction-rate</code> 个（默认为 0.01）。</li>
</ul>
<p>在单个可用区域实施这些策略的原因是当一个可用区域可能从控制面脱离时其它可用区域
可能仍然保持连接。
如果你的集群没有跨越云服务商的多个可用区域，那（整个集群）就只有一个可用区域。</p>
<p>跨多个可用区域部署你的节点的一个关键原因是当某个可用区域整体出现故障时，
工作负载可以转移到健康的可用区域。
因此，如果一个可用区域中的所有节点都不健康时，节点控制器会以正常的速率
<code>--node-eviction-rate</code> 进行驱逐操作。
在所有的可用区域都不健康（也即集群中没有健康节点）的极端情况下，
节点控制器将假设控制面与节点间的连接出了某些问题，它将停止所有驱逐动作（如果故障后部分节点重新连接，
节点控制器会从剩下不健康或者不可达节点中驱逐 <code>pods</code>）。</p>
<p>节点控制器还负责驱逐运行在拥有 <code>NoExecute</code> 污点的节点上的 Pod，
除非这些 Pod 能够容忍此污点。
节点控制器还负责根据节点故障（例如节点不可访问或没有就绪）为其添加
<a class=glossary-tooltip title="污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=污点>污点</a>。
这意味着调度器不会将 Pod 调度到不健康的节点上。</p>
<h3 id=node-capacity>资源容量跟踪 </h3>
<p>Node 对象会跟踪节点上资源的容量（例如可用内存和 CPU 数量）。
通过<a href=#self-registration-of-nodes>自注册</a>机制生成的 Node 对象会在注册期间报告自身容量。
如果你<a href=#manual-node-administration>手动</a>添加了 Node，你就需要在添加节点时
手动设置节点容量。</p>
<p>Kubernetes <a class=glossary-tooltip title="控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。" data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=调度器>调度器</a>保证节点上
有足够的资源供其上的所有 Pod 使用。它会检查节点上所有容器的请求的总和不会超过节点的容量。
总的请求包括由 kubelet 启动的所有容器，但不包括由容器运行时直接启动的容器，
也不包括不受 <code>kubelet</code> 控制的其他进程。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 如果要为非 Pod 进程显式保留资源。请参考
<a href=/zh/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>为系统守护进程预留资源</a>。
</div>
<h2 id=node-topology>节点拓扑 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code>
</div>
<p>如果启用了 <code>TopologyManager</code> <a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>，
<code>kubelet</code> 可以在作出资源分配决策时使用拓扑提示。
参考<a href=/zh/docs/tasks/administer-cluster/topology-manager/>控制节点上拓扑管理策略</a>
了解详细信息。</p>
<h2 id=graceful-node-shutdown>节点体面关闭</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code>
</div>
<p>kubelet 会尝试检测节点系统关闭事件并终止在节点上运行的 Pods。</p>
<p>在节点终止期间，kubelet 保证 Pod 遵从常规的 <a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>Pod 终止流程</a>。</p>
<p>体面节点关闭特性依赖于 systemd，因为它要利用
<a href=https://www.freedesktop.org/wiki/Software/systemd/inhibit/>systemd 抑制器锁</a>
在给定的期限内延迟节点关闭。</p>
<p>体面节点关闭特性受 <code>GracefulNodeShutdown</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
控制，在 1.21 版本中是默认启用的。</p>
<p>注意，默认情况下，下面描述的两个配置选项，<code>ShutdownGracePeriod</code> 和
<code>ShutdownGracePeriodCriticalPods</code> 都是被设置为 0 的，因此不会激活
体面节点关闭功能。
要激活此功能特性，这两个 kubelet 配置选项要适当配置，并设置为非零值。</p>
<p>在体面关闭节点过程中，kubelet 分两个阶段来终止 Pods：</p>
<ol>
<li>终止在节点上运行的常规 Pod。</li>
<li>终止在节点上运行的<a href=/zh/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>关键 Pod</a>。</li>
</ol>
<p>节点体面关闭的特性对应两个
<a href=/zh/docs/tasks/administer-cluster/kubelet-config-file/><code>KubeletConfiguration</code></a> 选项：</p>
<ul>
<li><code>ShutdownGracePeriod</code>：
<ul>
<li>指定节点应延迟关闭的总持续时间。此时间是 Pod 体面终止的时间总和，不区分常规 Pod 还是
<a href=/zh/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>关键 Pod</a>。</li>
</ul>
</li>
<li><code>ShutdownGracePeriodCriticalPods</code>：
<ul>
<li>在节点关闭期间指定用于终止
<a href=/zh/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>关键 Pod</a>
的持续时间。该值应小于 <code>ShutdownGracePeriod</code>。</li>
</ul>
</li>
</ul>
<p>例如，如果设置了 <code>ShutdownGracePeriod=30s</code> 和 <code>ShutdownGracePeriodCriticalPods=10s</code>，
则 kubelet 将延迟 30 秒关闭节点。
在关闭期间，将保留前 20（30 - 10）秒用于体面终止常规 Pod，
而保留最后 10 秒用于终止
<a href=/zh/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>关键 Pod</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> <p>当 Pod 在正常节点关闭期间被驱逐时，它们会被标记为 <code>failed</code>。
运行 <code>kubectl get pods</code> 将被驱逐的 pod 的状态显示为 <code>Shutdown</code>。
并且 <code>kubectl describe pod</code> 表示 pod 因节点关闭而被驱逐：</p>
<pre><code>Status:         Failed
Reason:         Shutdown
Message:        Node is shutting, evicting pods
</code></pre><p><code>Failed</code> 的 pod 对象将被保留，直到被明确删除或
<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>由 GC 清理</a>。
与突然的节点终止相比这是一种行为变化。</p>
</div>
<h2 id=swap-memory>交换内存管理</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code>
</div>
<p>在 Kubernetes 1.22 之前，节点不支持使用交换内存，并且
默认情况下，如果在节点上检测到交换内存配置，kubelet 将无法启动。 在 1.22
以后，可以在每个节点的基础上启用交换内存支持。</p>
<p>要在节点上启用交换内存，必须启用kubelet 的 <code>NodeSwap</code> 特性门控，
同时使用 <code>--fail-swap-on</code> 命令行参数或者将 <code>failSwapOn</code>
<a href=/zh/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>配置</a>
设置为false。</p>
<p>用户还可以选择配置 <code>memorySwap.swapBehavior</code> 以指定节点使用交换内存的方式。 例如:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>memorySwap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>swapBehavior</span>:<span style=color:#bbb> </span>LimitedSwap<span style=color:#bbb>
</span></code></pre></div>
<p>已有的 <code>swapBehavior</code> 的配置选项有：</p>
<ul>
<li><code>LimitedSwap</code>：Kubernetes 工作负载的交换内存会受限制。
不受 Kubernetes 管理的节点上的工作负载仍然可以交换。</li>
<li><code>UnlimitedSwap</code>：Kubernetes 工作负载可以使用尽可能多的交换内存
请求，一直到系统限制。</li>
</ul>
<p>如果启用了特性门控但是未指定 <code>memorySwap</code> 的配置，默认情况下 kubelet 将使用
<code>LimitedSwap</code> 设置。</p>
<p><code>LimitedSwap</code> 设置的行为还取决于节点运行的是 v1 还是 v2 的控制组（也就是 <code>cgroups</code>）：</p>
<ul>
<li><strong>cgroupsv1:</strong> Kubernetes 工作负载可以使用内存和
交换，达到 pod 的内存限制（如果设置）。</li>
<li><strong>cgroupsv2:</strong> Kubernetes 工作负载不能使用交换内存。</li>
</ul>
<p>如需更多信息以及协助测试和提供反馈，请
参见 <a href=https://github.com/kubernetes/enhancements/issues/2400>KEP-2400</a> 及其
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2400-node-swap/README.md>设计方案</a>。</p>
<h2 id=接下来>接下来</h2>
<ul>
<li>了解有关节点<a href=/zh/docs/concepts/overview/components/#node-components>组件</a>。</li>
<li>阅读 <a href=/docs/reference/generated/kubernetes-api/v1.22/#node-v1-core>Node 的 API 定义</a>。</li>
<li>阅读架构设计文档中有关
<a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>节点</a>
的章节。</li>
<li>了解<a href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/>污点和容忍度</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c0251def6da29b30afebfb04549f1703>2 - 控制面到节点通信</h1>
<p>本文列举控制面节点（确切说是 API 服务器）和 Kubernetes 集群之间的通信路径。
目的是为了让用户能够自定义他们的安装，以实现对网络配置的加固，使得集群能够在不可信的网络上
（或者在一个云服务商完全公开的 IP 上）运行。</p>
<h2 id=节点到控制面>节点到控制面</h2>
<p>Kubernetes 采用的是中心辐射型（Hub-and-Spoke）API 模式。
所有从集群（或所运行的 Pods）发出的 API 调用都终止于 apiserver。
其它控制面组件都没有被设计为可暴露远程服务。
apiserver 被配置为在一个安全的 HTTPS 端口（通常为 443）上监听远程连接请求，
并启用一种或多种形式的客户端<a href=/zh/docs/reference/access-authn-authz/authentication/>身份认证</a>机制。
一种或多种客户端<a href=/zh/docs/reference/access-authn-authz/authorization/>鉴权机制</a>应该被启用，
特别是在允许使用<a href=/zh/docs/reference/access-authn-authz/authentication/#anonymous-requests>匿名请求</a>
或<a href=/zh/docs/reference/access-authn-authz/authentication/#service-account-tokens>服务账号令牌</a>的时候。</p>
<p>应该使用集群的公共根证书开通节点，这样它们就能够基于有效的客户端凭据安全地连接 apiserver。
一种好的方法是以客户端证书的形式将客户端凭据提供给 kubelet。
请查看 <a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLS 启动引导</a>
以了解如何自动提供 kubelet 客户端证书。</p>
<p>想要连接到 apiserver 的 Pod 可以使用服务账号安全地进行连接。
当 Pod 被实例化时，Kubernetes 自动把公共根证书和一个有效的持有者令牌注入到 Pod 里。
<code>kubernetes</code> 服务（位于 <code>default</code> 名字空间中）配置了一个虚拟 IP 地址，用于（通过 kube-proxy）转发
请求到 apiserver 的 HTTPS 末端。</p>
<p>控制面组件也通过安全端口与集群的 apiserver 通信。</p>
<p>这样，从集群节点和节点上运行的 Pod 到控制面的连接的缺省操作模式即是安全的，
能够在不可信的网络或公网上运行。</p>
<h2 id=控制面到节点>控制面到节点</h2>
<p>从控制面（apiserver）到节点有两种主要的通信路径。
第一种是从 apiserver 到集群中每个节点上运行的 kubelet 进程。
第二种是从 apiserver 通过它的代理功能连接到任何节点、Pod 或者服务。</p>
<h3 id=api-服务器到-kubelet>API 服务器到 kubelet</h3>
<p>从 apiserver 到 kubelet 的连接用于：</p>
<ul>
<li>获取 Pod 日志</li>
<li>挂接（通过 kubectl）到运行中的 Pod</li>
<li>提供 kubelet 的端口转发功能。</li>
</ul>
<p>这些连接终止于 kubelet 的 HTTPS 末端。
默认情况下，apiserver 不检查 kubelet 的服务证书。这使得此类连接容易受到中间人攻击，
在非受信网络或公开网络上运行也是 <strong>不安全的</strong>。</p>
<p>为了对这个连接进行认证，使用 <code>--kubelet-certificate-authority</code> 标志给 apiserver
提供一个根证书包，用于 kubelet 的服务证书。</p>
<p>如果无法实现这点，又要求避免在非受信网络或公共网络上进行连接，可在 apiserver 和
kubelet 之间使用 <a href=#ssh-tunnels>SSH 隧道</a>。</p>
<p>最后，应该启用
<a href=/zh/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/>kubelet 用户认证和/或鉴权</a>
来保护 kubelet API。</p>
<h3 id=apiserver-到节点-pod-和服务>apiserver 到节点、Pod 和服务</h3>
<p>从 apiserver 到节点、Pod 或服务的连接默认为纯 HTTP 方式，因此既没有认证，也没有加密。
这些连接可通过给 API URL 中的节点、Pod 或服务名称添加前缀 <code>https:</code> 来运行在安全的 HTTPS 连接上。
不过这些连接既不会验证 HTTPS 末端提供的证书，也不会提供客户端证书。
因此，虽然连接是加密的，仍无法提供任何完整性保证。
这些连接 <strong>目前还不能安全地</strong> 在非受信网络或公共网络上运行。</p>
<h3 id=ssh-tunnels>SSH 隧道</h3>
<p>Kubernetes 支持使用 SSH 隧道来保护从控制面到节点的通信路径。在这种配置下，apiserver
建立一个到集群中各节点的 SSH 隧道（连接到在 22 端口监听的 SSH 服务）
并通过这个隧道传输所有到 kubelet、节点、Pod 或服务的请求。
这一隧道保证通信不会被暴露到集群节点所运行的网络之外。</p>
<p>SSH 隧道目前已被废弃。除非你了解个中细节，否则不应使用。
Konnectivity 服务是对此通信通道的替代品。</p>
<h3 id=konnectivity-服务>Konnectivity 服务</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>作为 SSH 隧道的替代方案，Konnectivity 服务提供 TCP 层的代理，以便支持从控制面到集群的通信。
Konnectivity 服务包含两个部分：Konnectivity 服务器和 Konnectivity 代理，分别运行在
控制面网络和节点网络中。Konnectivity 代理建立并维持到 Konnectivity 服务器的网络连接。
启用 Konnectivity 服务之后，所有控制面到节点的通信都通过这些连接传输。</p>
<p>请浏览 <a href=/zh/docs/tasks/extend-kubernetes/setup-konnectivity/>Konnectivity 服务任务</a>
在你的集群中配置 Konnectivity 服务。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ca8819042a505291540e831283da66df>3 - 控制器</h1>
<p>在机器人技术和自动化领域，控制回路（Control Loop）是一个非终止回路，用于调节系统状态。</p>
<p>这是一个控制环的例子：房间里的温度自动调节器。</p>
<p>当你设置了温度，告诉了温度自动调节器你的<em>期望状态（Desired State）</em>。
房间的实际温度是<em>当前状态（Current State）</em>。
通过对设备的开关控制，温度自动调节器让其当前状态接近期望状态。</p>
在 Kubernetes 中，控制器通过监控<a class=glossary-tooltip title="集群由一组被称作节点的机器组成。这些节点上运行 Kubernetes 所管理的容器化应用。集群具有至少一个工作节点。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-cluster" target=_blank aria-label=集群>集群</a>
的公共状态，并致力于将当前状态转变为期望的状态。
<h2 id=controller-pattern>控制器模式</h2>
<p>一个控制器至少追踪一种类型的 Kubernetes 资源。这些
<a href=/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/>对象</a>
有一个代表期望状态的 <code>spec</code> 字段。
该资源的控制器负责确保其当前状态接近期望状态。</p>
<p>控制器可能会自行执行操作；在 Kubernetes 中更常见的是一个控制器会发送信息给
<a class=glossary-tooltip title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank aria-label="API 服务器">API 服务器</a>，这会有副作用。
具体可参看后文的例子。</p>
<h3 id=control-via-API-server>通过 API 服务器来控制</h3>
<p><a class=glossary-tooltip title="Job 是需要运行完成的确定性的或批量的任务。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> 控制器是一个 Kubernetes 内置控制器的例子。
内置控制器通过和集群 API 服务器交互来管理状态。</p>
<p>Job 是一种 Kubernetes 资源，它运行一个或者多个 <a class=glossary-tooltip title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>，
来执行一个任务然后停止。
（一旦<a href=/zh/docs/concepts/scheduling-eviction/>被调度了</a>，对 <code>kubelet</code> 来说 Pod
对象就会变成了期望状态的一部分）。</p>
<p>在集群中，当 Job 控制器拿到新任务时，它会保证一组 Node 节点上的 <code>kubelet</code>
可以运行正确数量的 Pod 来完成工作。
Job 控制器不会自己运行任何的 Pod 或者容器。Job 控制器是通知 API 服务器来创建或者移除 Pod。
<a class=glossary-tooltip title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=控制面>控制面</a>中的其它组件
根据新的消息作出反应（调度并运行新 Pod）并且最终完成工作。</p>
<p>创建新 Job 后，所期望的状态就是完成这个 Job。Job 控制器会让 Job 的当前状态不断接近期望状态：创建为 Job 要完成工作所需要的 Pod，使 Job 的状态接近完成。</p>
<p>控制器也会更新配置对象。例如：一旦 Job 的工作完成了，Job 控制器会更新 Job 对象的状态为 <code>Finished</code>。</p>
<p>（这有点像温度自动调节器关闭了一个灯，以此来告诉你房间的温度现在到你设定的值了）。</p>
<h3 id=direct-control>直接控制</h3>
<p>相比 Job 控制器，有些控制器需要对集群外的一些东西进行修改。</p>
<p>例如，如果你使用一个控制回路来保证集群中有足够的
<a class=glossary-tooltip title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/nodes/ target=_blank aria-label=节点>节点</a>，那么控制器就需要当前集群外的
一些服务在需要时创建新节点。</p>
<p>和外部状态交互的控制器从 API 服务器获取到它想要的状态，然后直接和外部系统进行通信
并使当前状态更接近期望状态。</p>
<p>（实际上有一个<a href=https://github.com/kubernetes/autoscaler/>控制器</a>
可以水平地扩展集群中的节点。）</p>
<p>这里，很重要的一点是，控制器做出了一些变更以使得事物更接近你的期望状态，
之后将当前状态报告给集群的 API 服务器。
其他控制回路可以观测到所汇报的数据的这种变化并采取其各自的行动。</p>
<p>在温度计的例子中，如果房间很冷，那么某个控制器可能还会启动一个防冻加热器。
就 Kubernetes 集群而言，控制面间接地与 IP 地址管理工具、存储服务、云驱动
APIs 以及其他服务协作，通过<a href=/zh/docs/concepts/extend-kubernetes/>扩展 Kubernetes</a>
来实现这点。</p>
<h2 id=desired-vs-current>期望状态与当前状态</h2>
<p>Kubernetes 采用了系统的云原生视图，并且可以处理持续的变化。</p>
<p>在任务执行时，集群随时都可能被修改，并且控制回路会自动修复故障。
这意味着很可能集群永远不会达到稳定状态。</p>
<p>只要集群中的控制器在运行并且进行有效的修改，整体状态的稳定与否是无关紧要的。</p>
<h2 id=design>设计</h2>
<p>作为设计原则之一，Kubernetes 使用了很多控制器，每个控制器管理集群状态的一个特定方面。
最常见的一个特定的控制器使用一种类型的资源作为它的期望状态，
控制器管理控制另外一种类型的资源向它的期望状态演化。</p>
<p>使用简单的控制器而不是一组相互连接的单体控制回路是很有用的。
控制器会失败，所以 Kubernetes 的设计正是考虑到了这一点。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> <p>可以有多个控制器来创建或者更新相同类型的对象。
在后台，Kubernetes 控制器确保它们只关心与其控制资源相关联的资源。</p>
<p>例如，你可以创建 Deployment 和 Job；它们都可以创建 Pod。
Job 控制器不会删除 Deployment 所创建的 Pod，因为有信息
（<a class=glossary-tooltip title=用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=标签>标签</a>）让控制器可以区分这些 Pod。</p>
</div>
<h2 id=running-controllers>运行控制器的方式</h2>
<p>Kubernetes 内置一组控制器，运行在 <a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 内。
这些内置的控制器提供了重要的核心功能。</p>
<p>Deployment 控制器和 Job 控制器是 Kubernetes 内置控制器的典型例子。
Kubernetes 允许你运行一个稳定的控制平面，这样即使某些内置控制器失败了，
控制平面的其他部分会接替它们的工作。</p>
<p>你会遇到某些控制器运行在控制面之外，用以扩展 Kubernetes。
或者，如果你愿意，你也可以自己编写新控制器。
你可以以一组 Pod 来运行你的控制器，或者运行在 Kubernetes 之外。
最合适的方案取决于控制器所要执行的功能是什么。</p>
<h2 id=接下来>接下来</h2>
<ul>
<li>阅读 <a href=/zh/docs/concepts/overview/components/#control-plane-components>Kubernetes 控制平面组件</a></li>
<li>了解 <a href=/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/>Kubernetes 对象</a>
的一些基本知识</li>
<li>进一步学习 <a href=/zh/docs/concepts/overview/kubernetes-api/>Kubernetes API</a></li>
<li>如果你想编写自己的控制器，请看 Kubernetes 的
<a href=/zh/docs/concepts/extend-kubernetes/#extension-patterns>扩展模式</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>4 - 云控制器管理器</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p>使用云基础设施技术，你可以在公有云、私有云或者混合云环境中运行 Kubernetes。
Kubernetes 的信条是基于自动化的、API 驱动的基础设施，同时避免组件间紧密耦合。</p>
<p><p>组件 cloud-controller-manager 是指云控制器管理器， 云控制器管理器是指嵌入特定云的控制逻辑的
<a class=glossary-tooltip title="控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=控制平面>控制平面</a>组件。
云控制器管理器使得你可以将你的集群连接到云提供商的 API 之上，
并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p></p>
<p>通过分离 Kubernetes 和底层云基础设置之间的互操作性逻辑，
云控制器管理器组件使云提供商能够以不同于 Kubernetes 主项目的
步调发布新特征。</p>
<p><code>cloud-controller-manager</code> 组件是基于一种插件机制来构造的，
这种机制使得不同的云厂商都能将其平台与 Kubernetes 集成。</p>
<h2 id=design>设计 </h2>
<p><img src=/images/docs/components-of-kubernetes.svg alt="Kubernetes 组件"></p>
<p>云控制器管理器以一组多副本的进程集合的形式运行在控制面中，通常表现为 Pod
中的容器。每个 <code>cloud-controller-manager</code> 在同一进程中实现多个
<a class=glossary-tooltip title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 你也可以用 Kubernetes <a class=glossary-tooltip title="扩展 Kubernetes 功能的资源。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/cluster-administration/addons/ target=_blank aria-label=插件>插件</a>
的形式而不是控制面中的一部分来运行云控制器管理器。
</div>
<h2 id=functions-of-the-ccm>云控制器管理器的功能</h2>
<p>云控制器管理器中的控制器包括：</p>
<h3 id=node-controller>节点控制器 </h3>
<p>节点控制器负责在云基础设施中创建了新服务器时为之 创建
<a class=glossary-tooltip title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/nodes/ target=_blank aria-label=节点（Node）>节点（Node）</a>对象。
节点控制器从云提供商获取当前租户中主机的信息。节点控制器执行以下功能：</p>
<ol>
<li>针对控制器通过云平台驱动的 API 所发现的每个服务器初始化一个 Node 对象；</li>
<li>利用特定云平台的信息为 Node 对象添加注解和标签，例如节点所在的
区域（Region）和所具有的资源（CPU、内存等等）；</li>
<li>获取节点的网络地址和主机名；</li>
<li>检查节点的健康状况。如果节点无响应，控制器通过云平台 API 查看该节点是否
已从云中禁用、删除或终止。如果节点已从云中删除，则控制器从 Kubernetes 集群
中删除 Node 对象。</li>
</ol>
<p>某些云驱动实现中，这些任务被划分到一个节点控制器和一个节点生命周期控制器中。</p>
<h3 id=route-controller>路由控制器 </h3>
<p>Route 控制器负责适当地配置云平台中的路由，以便 Kubernetes 集群中不同节点上的
容器之间可以相互通信。</p>
<p>取决于云驱动本身，路由控制器可能也会为 Pod 网络分配 IP 地址块。</p>
<h3 id=service-controller>服务控制器 </h3>
<p><a class=glossary-tooltip title="将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/services-networking/service/ target=_blank aria-label=服务（Service）>服务（Service）</a>与受控的负载均衡器、
IP 地址、网络包过滤、目标健康检查等云基础设施组件集成。
服务控制器与云驱动的 API 交互，以配置负载均衡器和其他基础设施组件。
你所创建的 Service 资源会需要这些组件服务。</p>
<h2 id=authorization>鉴权 </h2>
<p>本节分别讲述云控制器管理器为了完成自身工作而产生的对各类 API 对象的访问需求。</p>
<h3 id=authorization-node-controller>节点控制器 </h3>
<p>节点控制器只操作 Node 对象。它需要读取和修改 Node 对象的完全访问权限。</p>
<p><code>v1/Node</code>:</p>
<ul>
<li>Get</li>
<li>List</li>
<li>Create</li>
<li>Update</li>
<li>Patch</li>
<li>Watch</li>
<li>Delete</li>
</ul>
<h3 id=authorization-route-controller>路由控制器</h3>
<p>路由控制器会监听 Node 对象的创建事件，并据此配置路由设施。
它需要读取 Node 对象的 Get 权限。</p>
<p><code>v1/Node</code>:</p>
<ul>
<li>Get</li>
</ul>
<h3 id=authorization-service-controller>服务控制器</h3>
<p>服务控制器监测 Service 对象的 Create、Update 和 Delete 事件，并配置
对应服务的 Endpoints 对象。
为了访问 Service 对象，它需要 List、Watch 访问权限；为了更新 Service 对象
它需要 Patch 和 Update 访问权限。
为了能够配置 Service 对应的 Endpoints 资源，它需要 Create、List、Get、Watch
和 Update 等访问权限。</p>
<p><code>v1/Service</code>:</p>
<ul>
<li>List</li>
<li>Get</li>
<li>Watch</li>
<li>Patch</li>
<li>Update</li>
</ul>
<h3 id=authorization-miscellaneous>其他 </h3>
<p>云控制器管理器的实现中，其核心部分需要创建 Event 对象的访问权限以及
创建 ServiceAccount 资源以保证操作安全性的权限。</p>
<p><code>v1/Event</code>:</p>
<ul>
<li>Create</li>
<li>Patch</li>
<li>Update</li>
</ul>
<p><code>v1/ServiceAccount</code>:</p>
<ul>
<li>Create</li>
</ul>
<p>用于云控制器管理器 <a class=glossary-tooltip title="管理授权决策，允许管理员通过 Kubernetes API 动态配置访问策略。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a>
的 ClusterRole 如下例所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></code></pre></div><h2 id=接下来>接下来</h2>
<p><a href=/zh/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>云控制器管理器的管理</a>
给出了运行和管理云控制器管理器的指南。</p>
<p>要升级 HA 控制平面以使用云控制器管理器，请参见 <a href=/zh/docs/tasks/administer-cluster/controller-manager-leader-migration/>将复制的控制平面迁移以使用云控制器管理器</a></p>
<p>想要了解如何实现自己的云控制器管理器，或者对现有项目进行扩展么？</p>
<p>云控制器管理器使用 Go 语言的接口，从而使得针对各种云平台的具体实现都可以接入。
其中使用了在 <a href=https://github.com/kubernetes/cloud-provider>kubernetes/cloud-provider</a>
项目中 <a href=https://github.com/kubernetes/cloud-provider/blob/release-1.21/cloud.go#L42-L69><code>cloud.go</code></a>
文件所定义的 <code>CloudProvider</code> 接口。</p>
<p>本文中列举的共享控制器（节点控制器、路由控制器和服务控制器等）的实现以及
其他一些生成具有 CloudProvider 接口的框架的代码，都是 Kubernetes 的核心代码。
特定于云驱动的实现虽不是 Kubernetes 核心成分，仍要实现 <code>CloudProvider</code> 接口。</p>
<p>关于如何开发插件的详细信息，可参考
<a href=/zh/docs/tasks/administer-cluster/developing-cloud-controller-manager/>开发云控制器管理器</a>
文档。</p>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/zh/docs/home/>主页</a>
<a class=text-white href=/zh/blog/>博客</a>
<a class=text-white href=/zh/training/>培训</a>
<a class=text-white href=/zh/partners/>合作伙伴</a>
<a class=text-white href=/zh/community/>社区</a>
<a class=text-white href=/zh/case-studies/>案例分析</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small>
<br>
<small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>