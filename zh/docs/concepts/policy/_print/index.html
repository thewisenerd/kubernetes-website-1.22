<!doctype html><html lang=zh class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/policy/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/policy/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/policy/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/policy/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/policy/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/policy/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/policy/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/zh/docs/concepts/policy/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>策略 | Kubernetes</title><meta property="og:title" content="策略">
<meta property="og:description" content="可配置的、可应用到一组资源的策略。">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/zh/docs/concepts/policy/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="策略">
<meta itemprop=description content="可配置的、可应用到一组资源的策略。"><meta name=twitter:card content="summary">
<meta name=twitter:title content="策略">
<meta name=twitter:description content="可配置的、可应用到一组资源的策略。">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="可配置的、可应用到一组资源的策略。">
<meta property="og:description" content="可配置的、可应用到一组资源的策略。">
<meta name=twitter:description content="可配置的、可应用到一组资源的策略。">
<meta property="og:url" content="https://kubernetes.io/zh/docs/concepts/policy/">
<meta property="og:title" content="策略">
<meta name=twitter:title content="策略">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/zh/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/zh/docs/>文档</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/blog/>Kubernetes 博客</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/training/>培训</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/partners/>合作伙伴</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/community/>社区</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/case-studies/>案例分析</span></a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
版本列表
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh/docs/concepts/policy/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/zh/docs/concepts/policy/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh/docs/concepts/policy/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh/docs/concepts/policy/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh/docs/concepts/policy/>v1.22</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/concepts/policy/>English</a>
<a class=dropdown-item href=/ko/docs/concepts/policy/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/concepts/policy/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/concepts/policy/>Français</a>
<a class=dropdown-item href=/de/docs/concepts/policy/>Deutsch</a>
<a class=dropdown-item href=/es/docs/concepts/policy/>Español</a>
<a class=dropdown-item href=/id/docs/concepts/policy/>Bahasa Indonesia</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/zh/docs/concepts/policy/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>策略</h1>
<div class=lead>可配置的、可应用到一组资源的策略。</div>
<ul>
<li>1: <a href=#pg-a935ff8c59eb116b43494255cc67f69a>限制范围</a></li>
<li>2: <a href=#pg-94ddc6e901c30f256138db11d09f05a3>资源配额</a></li>
<li>3: <a href=#pg-59977cbac423e20437db079757cb03df>Pod 安全策略</a></li>
<li>4: <a href=#pg-7352434db5f5954d2f7656b46fe5a324>进程 ID 约束与预留</a></li>
<li>5: <a href=#pg-b528c4464c030f3f044124b38d778f04>节点资源管理器</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-a935ff8c59eb116b43494255cc67f69a>1 - 限制范围</h1>
<p>默认情况下， Kubernetes 集群上的容器运行使用的<a href=/zh/docs/concepts/configuration/manage-resources-containers/>计算资源</a>没有限制。
使用资源配额，集群管理员可以以<a class=glossary-tooltip title="名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a>为单位，限制其资源的使用与创建。
在命名空间中，一个 Pod 或 Container 最多能够使用命名空间的资源配额所定义的 CPU 和内存用量。
有人担心，一个 Pod 或 Container 会垄断所有可用的资源。
LimitRange 是在命名空间内限制资源分配（给多个 Pod 或 Container）的策略对象。</p>
<p>一个 <em>LimitRange（限制范围）</em> 对象提供的限制能够做到：</p>
<ul>
<li>在一个命名空间中实施对每个 Pod 或 Container 最小和最大的资源使用量的限制。</li>
<li>在一个命名空间中实施对每个 PersistentVolumeClaim 能申请的最小和最大的存储空间大小的限制。</li>
<li>在一个命名空间中实施对一种资源的申请值和限制值的比值的控制。</li>
<li>设置一个命名空间中对计算资源的默认申请/限制值，并且自动的在运行时注入到多个 Container 中。</li>
</ul>
<h2 id=启用-limitrange>启用 LimitRange</h2>
<p>对 LimitRange 的支持自 Kubernetes 1.10 版本默认启用。</p>
<p>LimitRange 支持在很多 Kubernetes 发行版本中也是默认启用的。</p>
<p>LimitRange 的名称必须是合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>。</p>
<h3 id=限制范围总览>限制范围总览</h3>
<ul>
<li>管理员在一个命名空间内创建一个 <code>LimitRange</code> 对象。</li>
<li>用户在命名空间内创建 Pod ，Container 和 PersistentVolumeClaim 等资源。</li>
<li><code>LimitRanger</code> 准入控制器对所有没有设置计算资源需求的 Pod 和 Container 设置默认值与限制值，
并跟踪其使用量以保证没有超出命名空间中存在的任意 LimitRange 对象中的最小、最大资源使用量以及使用量比值。</li>
<li>若创建或更新资源（Pod、 Container、PersistentVolumeClaim）违反了 LimitRange 的约束，
向 API 服务器的请求会失败，并返回 HTTP 状态码 <code>403 FORBIDDEN</code> 与描述哪一项约束被违反的消息。</li>
<li>若命名空间中的 LimitRange 启用了对 <code>cpu</code> 和 <code>memory</code> 的限制，
用户必须指定这些值的需求使用量与限制使用量。否则，系统将会拒绝创建 Pod。</li>
<li>LimitRange 的验证仅在 Pod 准入阶段进行，不对正在运行的 Pod 进行验证。</li>
</ul>
<p>能够使用限制范围创建的策略示例有：</p>
<ul>
<li>在一个有两个节点，8 GiB 内存与16个核的集群中，限制一个命名空间的 Pod 申请
100m 单位，最大 500m 单位的 CPU，以及申请 200Mi，最大 600Mi 的内存。</li>
<li>为 spec 中没有 cpu 和内存需求值的 Container 定义默认 CPU 限制值与需求值
150m，内存默认需求值 300Mi。</li>
</ul>
<p>在命名空间的总限制值小于 Pod 或 Container 的限制值的总和的情况下，可能会产生资源竞争。
在这种情况下，将不会创建 Container 或 Pod。</p>
<p>竞争和对 LimitRange 的改变都不会影响任何已经创建了的资源。</p>
<h2 id=接下来>接下来</h2>
<p>参阅 <a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md>LimitRanger 设计文档</a>获取更多信息。</p>
<p>关于使用限值的例子，可参看</p>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>如何配置每个命名空间最小和最大的 CPU 约束</a>。</li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>如何配置每个命名空间最小和最大的内存约束</a>。</li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>如何配置每个命名空间默认的 CPU 申请值和限制值</a>。</li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>如何配置每个命名空间默认的内存申请值和限制值</a>。</li>
<li><a href=/zh/docs/tasks/administer-cluster/limit-storage-consumption/#limitrange-to-limit-requests-for-storage>如何配置每个命名空间最小和最大存储使用量</a>。</li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>配置每个命名空间的配额的详细例子</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-94ddc6e901c30f256138db11d09f05a3>2 - 资源配额</h1>
<p>当多个用户或团队共享具有固定节点数目的集群时，人们会担心有人使用超过其基于公平原则所分配到的资源量。</p>
<p>资源配额是帮助管理员解决这一问题的工具。</p>
<p>资源配额，通过 <code>ResourceQuota</code> 对象来定义，对每个命名空间的资源消耗总量提供限制。
它可以限制命名空间中某种类型的对象的总数目上限，也可以限制命令空间中的 Pod 可以使用的计算资源的总上限。</p>
<p>资源配额的工作方式如下：</p>
<ul>
<li>
<p>不同的团队可以在不同的命名空间下工作，目前这是非约束性的，在未来的版本中可能会通过
ACL (Access Control List 访问控制列表) 来实现强制性约束。</p>
</li>
<li>
<p>集群管理员可以为每个命名空间创建一个或多个 ResourceQuota 对象。</p>
</li>
<li>
<p>当用户在命名空间下创建资源（如 Pod、Service 等）时，Kubernetes 的配额系统会
跟踪集群的资源使用情况，以确保使用的资源用量不超过 ResourceQuota 中定义的硬性资源限额。</p>
</li>
<li>
<p>如果资源创建或者更新请求违反了配额约束，那么该请求会报错（HTTP 403 FORBIDDEN），
并在消息中给出有可能违反的约束。</p>
</li>
<li>
<p>如果命名空间下的计算资源 （如 <code>cpu</code> 和 <code>memory</code>）的配额被启用，则用户必须为
这些资源设定请求值（request）和约束值（limit），否则配额系统将拒绝 Pod 的创建。
提示: 可使用 <code>LimitRanger</code> 准入控制器来为没有设置计算资源需求的 Pod 设置默认值。</p>
<p>若想避免这类问题，请参考
<a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>演练</a>示例。</p>
</li>
</ul>
<p>ResourceQuota 对象的名称必须是合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>。</p>
<p>下面是使用命名空间和配额构建策略的示例：</p>
<ul>
<li>在具有 32 GiB 内存和 16 核 CPU 资源的集群中，允许 A 团队使用 20 GiB 内存 和 10 核的 CPU 资源，
允许 B 团队使用 10 GiB 内存和 4 核的 CPU 资源，并且预留 2 GiB 内存和 2 核的 CPU 资源供将来分配。</li>
<li>限制 "testing" 命名空间使用 1 核 CPU 资源和 1GiB 内存。允许 "production" 命名空间使用任意数量。</li>
</ul>
<p>在集群容量小于各命名空间配额总和的情况下，可能存在资源竞争。资源竞争时，Kubernetes 系统会遵循先到先得的原则。</p>
<p>不管是资源竞争还是配额的修改，都不会影响已经创建的资源使用对象。</p>
<h2 id=启用资源配额>启用资源配额</h2>
<p>资源配额的支持在很多 Kubernetes 版本中是默认启用的。
当 <a class=glossary-tooltip title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank aria-label="API 服务器">API 服务器</a>
的命令行标志 <code>--enable-admission-plugins=</code> 中包含 <code>ResourceQuota</code> 时，
资源配额会被启用。</p>
<p>当命名空间中存在一个 ResourceQuota 对象时，对于该命名空间而言，资源配额就是开启的。</p>
<h2 id=计算资源配额>计算资源配额</h2>
<p>用户可以对给定命名空间下的可被请求的
<a href=/zh/docs/concepts/configuration/manage-resources-containers/>计算资源</a>
总量进行限制。</p>
<p>配额机制所支持的资源类型：</p>
<table>
<thead>
<tr>
<th>资源名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>limits.cpu</code></td>
<td>所有非终止状态的 Pod，其 CPU 限额总量不能超过该值。</td>
</tr>
<tr>
<td><code>limits.memory</code></td>
<td>所有非终止状态的 Pod，其内存限额总量不能超过该值。</td>
</tr>
<tr>
<td><code>requests.cpu</code></td>
<td>所有非终止状态的 Pod，其 CPU 需求总量不能超过该值。</td>
</tr>
<tr>
<td><code>requests.memory</code></td>
<td>所有非终止状态的 Pod，其内存需求总量不能超过该值。</td>
</tr>
<tr>
<td><code>hugepages-&lt;size></code></td>
<td>对于所有非终止状态的 Pod，针对指定尺寸的巨页请求总数不能超过此值。</td>
</tr>
<tr>
<td><code>cpu</code></td>
<td>与 <code>requests.cpu</code> 相同。</td>
</tr>
<tr>
<td><code>memory</code></td>
<td>与 <code>requests.memory</code> 相同。</td>
</tr>
</tbody>
</table>
<h3 id=扩展资源的资源配额>扩展资源的资源配额</h3>
<p>除上述资源外，在 Kubernetes 1.10 版本中，还添加了对
<a href=/zh/docs/concepts/configuration/manage-resources-containers/#extended-resources>扩展资源</a>
的支持。</p>
<p>由于扩展资源不可超量分配，因此没有必要在配额中为同一扩展资源同时指定 <code>requests</code> 和 <code>limits</code>。
对于扩展资源而言，目前仅允许使用前缀为 <code>requests.</code> 的配额项。</p>
<p>以 GPU 拓展资源为例，如果资源名称为 <code>nvidia.com/gpu</code>，并且要将命名空间中请求的 GPU
资源总数限制为 4，则可以如下定义配额：</p>
<ul>
<li><code>requests.nvidia.com/gpu: 4</code></li>
</ul>
<p>有关更多详细信息，请参阅<a href=#viewing-and-setting-quotas>查看和设置配额</a>。</p>
<h2 id=存储资源配额>存储资源配额</h2>
<p>用户可以对给定命名空间下的<a href=/zh/docs/concepts/storage/persistent-volumes/>存储资源</a>
总量进行限制。</p>
<p>此外，还可以根据相关的存储类（Storage Class）来限制存储资源的消耗。</p>
<table>
<thead>
<tr>
<th>资源名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>requests.storage</code></td>
<td>所有 PVC，存储资源的需求总量不能超过该值。</td>
</tr>
<tr>
<td><code>persistentvolumeclaims</code></td>
<td>在该命名空间中所允许的 <a href=/zh/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PVC</a> 总量。</td>
</tr>
<tr>
<td><code>&lt;storage-class-name>.storageclass.storage.k8s.io/requests.storage</code></td>
<td>在所有与 <code>&lt;storage-class-name></code> 相关的持久卷申领中，存储请求的总和不能超过该值。</td>
</tr>
<tr>
<td><code>&lt;storage-class-name>.storageclass.storage.k8s.io/persistentvolumeclaims</code></td>
<td>在与 storage-class-name 相关的所有持久卷申领中，命名空间中可以存在的<a href=/zh/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>持久卷申领</a>总数。</td>
</tr>
</tbody>
</table>
<p>例如，如果一个操作人员针对 <code>gold</code> 存储类型与 <code>bronze</code> 存储类型设置配额，
操作人员可以定义如下配额：</p>
<ul>
<li><code>gold.storageclass.storage.k8s.io/requests.storage: 500Gi</code></li>
<li><code>bronze.storageclass.storage.k8s.io/requests.storage: 100Gi</code></li>
</ul>
<p>在 Kubernetes 1.8 版本中，本地临时存储的配额支持已经是 Alpha 功能：</p>
<table>
<thead>
<tr>
<th>资源名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>requests.ephemeral-storage</code></td>
<td>在命名空间的所有 Pod 中，本地临时存储请求的总和不能超过此值。</td>
</tr>
<tr>
<td><code>limits.ephemeral-storage</code></td>
<td>在命名空间的所有 Pod 中，本地临时存储限制值的总和不能超过此值。</td>
</tr>
<tr>
<td><code>ephemeral-storage</code></td>
<td>与 <code>requests.ephemeral-storage</code> 相同。</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>如果所使用的是 CRI 容器运行时，容器日志会被计入临时存储配额。
这可能会导致存储配额耗尽的 Pods 被意外地驱逐出节点。
参考<a href=/zh/docs/concepts/cluster-administration/logging/>日志架构</a>
了解详细信息。
</div>
<h2 id=对象数量配额>对象数量配额</h2>
<p>你可以使用以下语法对所有标准的、命名空间域的资源类型进行配额设置：</p>
<ul>
<li><code>count/&lt;resource>.&lt;group></code>：用于非核心（core）组的资源</li>
<li><code>count/&lt;resource></code>：用于核心组的资源</li>
</ul>
<p>这是用户可能希望利用对象计数配额来管理的一组资源示例。</p>
<ul>
<li><code>count/persistentvolumeclaims</code></li>
<li><code>count/services</code></li>
<li><code>count/secrets</code></li>
<li><code>count/configmaps</code></li>
<li><code>count/replicationcontrollers</code></li>
<li><code>count/deployments.apps</code></li>
<li><code>count/replicasets.apps</code></li>
<li><code>count/statefulsets.apps</code></li>
<li><code>count/jobs.batch</code></li>
<li><code>count/cronjobs.batch</code></li>
</ul>
<p>相同语法也可用于自定义资源。
例如，要对 <code>example.com</code> API 组中的自定义资源 <code>widgets</code> 设置配额，请使用
<code>count/widgets.example.com</code>。</p>
<p>当使用 <code>count/*</code> 资源配额时，如果对象存在于服务器存储中，则会根据配额管理资源。
这些类型的配额有助于防止存储资源耗尽。例如，用户可能想根据服务器的存储能力来对服务器中
Secret 的数量进行配额限制。
集群中存在过多的 Secret 实际上会导致服务器和控制器无法启动。
用户可以选择对 Job 进行配额管理，以防止配置不当的 CronJob 在某命名空间中创建太多
Job 而导致集群拒绝服务。</p>
<p>对有限的一组资源上实施一般性的对象数量配额也是可能的。
此外，还可以进一步按资源的类型设置其配额。</p>
<p>支持以下类型：</p>
<table>
<thead>
<tr>
<th>资源名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>configmaps</code></td>
<td>在该命名空间中允许存在的 ConfigMap 总数上限。</td>
</tr>
<tr>
<td><code>persistentvolumeclaims</code></td>
<td>在该命名空间中允许存在的 <a href=/zh/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PVC</a> 的总数上限。</td>
</tr>
<tr>
<td><code>pods</code></td>
<td>在该命名空间中允许存在的非终止状态的 Pod 总数上限。Pod 终止状态等价于 Pod 的 <code>.status.phase in (Failed, Succeeded)</code> 为真。</td>
</tr>
<tr>
<td><code>replicationcontrollers</code></td>
<td>在该命名空间中允许存在的 ReplicationController 总数上限。</td>
</tr>
<tr>
<td><code>resourcequotas</code></td>
<td>在该命名空间中允许存在的 ResourceQuota 总数上限。</td>
</tr>
<tr>
<td><code>services</code></td>
<td>在该命名空间中允许存在的 Service 总数上限。</td>
</tr>
<tr>
<td><code>services.loadbalancers</code></td>
<td>在该命名空间中允许存在的 LoadBalancer 类型的 Service 总数上限。</td>
</tr>
<tr>
<td><code>services.nodeports</code></td>
<td>在该命名空间中允许存在的 NodePort 类型的 Service 总数上限。</td>
</tr>
<tr>
<td><code>secrets</code></td>
<td>在该命名空间中允许存在的 Secret 总数上限。</td>
</tr>
</tbody>
</table>
<p>例如，<code>pods</code> 配额统计某个命名空间中所创建的、非终止状态的 <code>Pod</code> 个数并确保其不超过某上限值。
用户可能希望在某命名空间中设置 <code>pods</code> 配额，以避免有用户创建很多小的 Pod，
从而耗尽集群所能提供的 Pod IP 地址。</p>
<h2 id=quota-scopes>配额作用域 </h2>
<p>每个配额都有一组相关的 <code>scope</code>（作用域），配额只会对作用域内的资源生效。
配额机制仅统计所列举的作用域的交集中的资源用量。</p>
<p>当一个作用域被添加到配额中后，它会对作用域相关的资源数量作限制。
如配额中指定了允许（作用域）集合之外的资源，会导致验证错误。</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Terminating</code></td>
<td>匹配所有 <code>spec.activeDeadlineSeconds</code> 不小于 0 的 Pod。</td>
</tr>
<tr>
<td><code>NotTerminating</code></td>
<td>匹配所有 <code>spec.activeDeadlineSeconds</code> 是 nil 的 Pod。</td>
</tr>
<tr>
<td><code>BestEffort</code></td>
<td>匹配所有 Qos 是 BestEffort 的 Pod。</td>
</tr>
<tr>
<td><code>NotBestEffort</code></td>
<td>匹配所有 Qos 不是 BestEffort 的 Pod。</td>
</tr>
<tr>
<td><code>PriorityClass</code></td>
<td>匹配所有引用了所指定的<a href=/zh/docs/concepts/scheduling-eviction/pod-priority-preemption>优先级类</a>的 Pods。</td>
</tr>
<tr>
<td><code>CrossNamespacePodAffinity</code></td>
<td>匹配那些设置了跨名字空间 <a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node>（反）亲和性条件</a>的 Pod。</td>
</tr>
</tbody>
</table>
<p><code>BestEffort</code> 作用域限制配额跟踪以下资源：</p>
<ul>
<li><code>pods</code></li>
</ul>
<p><code>Terminating</code>、<code>NotTerminating</code>、<code>NotBestEffort</code> 和 <code>PriorityClass</code> 这些作用域限制配额跟踪以下资源：</p>
<ul>
<li><code>pods</code></li>
<li><code>cpu</code></li>
<li><code>memory</code></li>
<li><code>requests.cpu</code></li>
<li><code>requests.memory</code></li>
<li><code>limits.cpu</code></li>
<li><code>limits.memory</code></li>
</ul>
<p>需要注意的是，你不可以在同一个配额对象中同时设置 <code>Terminating</code> 和 <code>NotTerminating</code>
作用域，你也不可以在同一个配额中同时设置 <code>BestEffort</code> 和 <code>NotBestEffort</code>
作用域。</p>
<p><code>scopeSelector</code> 支持在 <code>operator</code> 字段中使用以下值：</p>
<ul>
<li><code>In</code></li>
<li><code>NotIn</code></li>
<li><code>Exists</code></li>
<li><code>DoesNotExist</code></li>
</ul>
<p>定义 <code>scopeSelector</code> 时，如果使用以下值之一作为 <code>scopeName</code> 的值，则对应的
<code>operator</code> 只能是 <code>Exists</code>。</p>
<ul>
<li><code>Terminating</code></li>
<li><code>NotTerminating</code></li>
<li><code>BestEffort</code></li>
<li><code>NotBestEffort</code></li>
</ul>
<p>如果 <code>operator</code> 是 <code>In</code> 或 <code>NotIn</code> 之一，则 <code>values</code> 字段必须至少包含一个值。
例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- middle<span style=color:#bbb>
</span></code></pre></div>
<p>如果 <code>operator</code> 为 <code>Exists</code> 或 <code>DoesNotExist</code>，则<em>不</em>可以设置 <code>values</code> 字段。</p>
<h3 id=基于优先级类-priorityclass-来设置资源配额>基于优先级类（PriorityClass）来设置资源配额</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>
<p>Pod 可以创建为特定的<a href=/zh/docs/concepts/scheduling-eviction/pod-priority-preemption/#pod-priority>优先级</a>。
通过使用配额规约中的 <code>scopeSelector</code> 字段，用户可以根据 Pod 的优先级控制其系统资源消耗。</p>
<p>仅当配额规范中的 <code>scopeSelector</code> 字段选择到某 Pod 时，配额机制才会匹配和计量 Pod 的资源消耗。</p>
<p>如果配额对象通过 <code>scopeSelector</code> 字段设置其作用域为优先级类，则配额对象只能
跟踪以下资源：</p>
<ul>
<li><code>pods</code></li>
<li><code>cpu</code></li>
<li><code>memory</code></li>
<li><code>ephemeral-storage</code></li>
<li><code>limits.cpu</code></li>
<li><code>limits.memory</code></li>
<li><code>limits.ephemeral-storage</code></li>
<li><code>requests.cpu</code></li>
<li><code>requests.memory</code></li>
<li><code>requests.ephemeral-storage</code></li>
</ul>
<p>本示例创建一个配额对象，并将其与具有特定优先级的 Pod 进行匹配。
该示例的工作方式如下：</p>
<ul>
<li>集群中的 Pod 可取三个优先级类之一，即 "low"、"medium"、"high"。</li>
<li>为每个优先级创建一个配额对象。</li>
</ul>
<p>将以下 YAML 保存到文件 <code>quota.yml</code> 中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>List<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-high<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Gi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;high&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-medium<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;medium&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-low<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;low&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>kubectl create</code> 命令运行以下操作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./quota.yml
</code></pre></div><pre><code>resourcequota/pods-high created
resourcequota/pods-medium created
resourcequota/pods-low created
</code></pre>
<p>使用 <code>kubectl describe quota</code> 操作验证配额的 <code>Used</code> 值为 <code>0</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota
</code></pre></div><pre><code>Name:       pods-high
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     1k
memory      0     200Gi
pods        0     10


Name:       pods-low
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     5
memory      0     10Gi
pods        0     10


Name:       pods-medium
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     10
memory      0     20Gi
pods        0     10
</code></pre>
<p>创建优先级为 "high" 的 Pod。
将以下 YAML 保存到文件 <code>high-priority-pod.yml</code> 中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>ubuntu<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;while true; do echo hello; sleep 10;done&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>high<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>kubectl create</code> 运行以下操作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./high-priority-pod.yml
</code></pre></div>
<p>确认 "high" 优先级配额 <code>pods-high</code> 的 "Used" 统计信息已更改，并且其他两个配额未更改。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota
</code></pre></div><pre><code>Name:       pods-high
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         500m  1k
memory      10Gi  200Gi
pods        1     10


Name:       pods-low
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     5
memory      0     10Gi
pods        0     10


Name:       pods-medium
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     10
memory      0     20Gi
pods        0     10
</code></pre>
<h3 id=cross-namespace-pod-affinity-quota>跨名字空间的 Pod 亲和性配额 </h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>集群运维人员可以使用 <code>CrossNamespacePodAffinity</code> 配额作用域来
限制哪个名字空间中可以存在包含跨名字空间亲和性规则的 Pod。
更为具体一点，此作用域用来配置哪些 Pod 可以在其 Pod 亲和性规则
中设置 <code>namespaces</code> 或 <code>namespaceSelector</code> 字段。</p>
<p>禁止用户使用跨名字空间的亲和性规则可能是一种被需要的能力，因为带有
反亲和性约束的 Pod 可能会阻止所有其他名字空间的 Pod 被调度到某失效域中。</p>
<p>使用此作用域操作符可以避免某些名字空间（例如下面例子中的 <code>foo-ns</code>）运行
特别的 Pod，这类 Pod 使用跨名字空间的 Pod 亲和性约束，在该名字空间中创建
了作用域为 <code>CrossNamespaceAffinity</code> 的、硬性约束为 0 的资源配额对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>disable-cross-namespace-affinity<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo-ns<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>CrossNamespaceAffinity<span style=color:#bbb>
</span></code></pre></div>
<p>如果集群运维人员希望默认禁止使用 <code>namespaces</code> 和 <code>namespaceSelector</code>，而
仅仅允许在特定名字空间中这样做，他们可以将 <code>CrossNamespaceAffinity</code> 作为一个
被约束的资源。方法是为 <code>kube-apiserver</code> 设置标志
<code>--admission-control-config-file</code>，使之指向如下的配置文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ResourceQuota&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuotaConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limitedResources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>pods<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchScopes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>CrossNamespaceAffinity<span style=color:#bbb>
</span></code></pre></div>
<p>基于上面的配置，只有名字空间中包含作用域为 <code>CrossNamespaceAffinity</code> 且
硬性约束大于或等于使用 <code>namespaces</code> 和 <code>namespaceSelector</code> 字段的 Pods
个数时，才可以在该名字空间中继续创建在其 Pod 亲和性规则中设置 <code>namespaces</code>
或 <code>namespaceSelector</code> 的新 Pod。</p>
<p>此功能特性处于 Beta 阶段，默认被禁用。你可以通过为 kube-apiserver 和
kube-scheduler 设置
<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
<code>PodAffinityNamespaceSelector</code> 来启用此特性。</p>
<h2 id=requests-vs-limits>请求与限制的比较 </h2>
<p>分配计算资源时，每个容器可以为 CPU 或内存指定请求和约束。
配额可以针对二者之一进行设置。</p>
<p>如果配额中指定了 <code>requests.cpu</code> 或 <code>requests.memory</code> 的值，则它要求每个容器都显式给出对这些资源的请求。
同理，如果配额中指定了 <code>limits.cpu</code> 或 <code>limits.memory</code> 的值，那么它要求每个容器都显式设定对应资源的限制。</p>
<h2 id=viewing-and-setting-quotas>查看和设置配额</h2>
<p>Kubectl 支持创建、更新和查看配额：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt; compute-resources.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: ResourceQuota
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: compute-resources
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  hard:
</span><span style=color:#b44>    requests.cpu: &#34;1&#34;
</span><span style=color:#b44>    requests.memory: 1Gi
</span><span style=color:#b44>    limits.cpu: &#34;2&#34;
</span><span style=color:#b44>    limits.memory: 2Gi
</span><span style=color:#b44>    requests.nvidia.com/gpu: 4
</span><span style=color:#b44>EOF</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./compute-resources.yaml --namespace<span style=color:#666>=</span>myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt; object-counts.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: ResourceQuota
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: object-counts
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  hard:
</span><span style=color:#b44>    configmaps: &#34;10&#34;
</span><span style=color:#b44>    persistentvolumeclaims: &#34;4&#34;
</span><span style=color:#b44>    pods: &#34;4&#34;
</span><span style=color:#b44>    replicationcontrollers: &#34;20&#34;
</span><span style=color:#b44>    secrets: &#34;10&#34;
</span><span style=color:#b44>    services: &#34;10&#34;
</span><span style=color:#b44>    services.loadbalancers: &#34;2&#34;
</span><span style=color:#b44>EOF</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./object-counts.yaml --namespace<span style=color:#666>=</span>myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get quota --namespace<span style=color:#666>=</span>myspace
</code></pre></div><pre><code class=language-none data-lang=none>NAME                    AGE
compute-resources       30s
object-counts           32s
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota compute-resources --namespace<span style=color:#666>=</span>myspace
</code></pre></div><pre><code class=language-none data-lang=none>Name:                    compute-resources
Namespace:               myspace
Resource                 Used  Hard
--------                 ----  ----
limits.cpu               0     2
limits.memory            0     2Gi
requests.cpu             0     1
requests.memory          0     1Gi
requests.nvidia.com/gpu  0     4
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota object-counts --namespace<span style=color:#666>=</span>myspace
</code></pre></div><pre><code class=language-none data-lang=none>Name:                   object-counts
Namespace:              myspace
Resource                Used    Hard
--------                ----    ----
configmaps              0       10
persistentvolumeclaims  0       4
pods                    0       4
replicationcontrollers  0       20
secrets                 1       10
services                0       10
services.loadbalancers  0       2
</code></pre>
<p>kubectl 还使用语法 <code>count/&lt;resource>.&lt;group></code> 支持所有标准的、命名空间域的资源的对象计数配额：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create quota <span style=color:#a2f>test</span> --hard<span style=color:#666>=</span>count/deployments.apps<span style=color:#666>=</span>2,count/replicasets.apps<span style=color:#666>=</span>4,count/pods<span style=color:#666>=</span>3,count/secrets<span style=color:#666>=</span><span style=color:#666>4</span> --namespace<span style=color:#666>=</span>myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>myspace --replicas<span style=color:#666>=</span><span style=color:#666>2</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota --namespace<span style=color:#666>=</span>myspace
</code></pre></div><pre><code>Name:                         test
Namespace:                    myspace
Resource                      Used  Hard
--------                      ----  ----
count/deployments.apps        1     2
count/pods                    2     3
count/replicasets.apps        1     4
count/secrets                 1     4
</code></pre>
<h2 id=quota-and-cluster-capacity>配额和集群容量 </h2>
<p>ResourceQuota 与集群资源总量是完全独立的。它们通过绝对的单位来配置。
所以，为集群添加节点时，资源配额<em>不会</em>自动赋予每个命名空间消耗更多资源的能力。</p>
<p>有时可能需要资源配额支持更复杂的策略，比如：</p>
<ul>
<li>在几个团队中按比例划分总的集群资源。</li>
<li>允许每个租户根据需要增加资源使用量，但要有足够的限制以防止资源意外耗尽。</li>
<li>探测某个命名空间的需求，添加物理节点并扩大资源配额值。</li>
</ul>
<p>这些策略可以通过将资源配额作为一个组成模块、手动编写一个控制器来监控资源使用情况，
并结合其他信号调整命名空间上的硬性资源配额来实现。</p>
<p>注意：资源配额对集群资源总体进行划分，但它对节点没有限制：来自不同命名空间的 Pod 可能在同一节点上运行。</p>
<h2 id=默认情况下限制特定优先级的资源消耗>默认情况下限制特定优先级的资源消耗</h2>
<p>有时候可能希望当且仅当某名字空间中存在匹配的配额对象时，才可以创建特定优先级
（例如 "cluster-services"）的 Pod。</p>
<p>通过这种机制，操作人员能够将限制某些高优先级类仅出现在有限数量的命名空间中，
而并非每个命名空间默认情况下都能够使用这些优先级类。</p>
<p>要实现此目的，应设置 kube-apiserver 的标志 <code>--admission-control-config-file</code>
指向如下配置文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ResourceQuota&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuotaConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limitedResources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>pods<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchScopes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;cluster-services&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>现在在 <code>kube-system</code> 名字空间中创建一个资源配额对象：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/policy/priority-class-resourcequota.yaml download=policy/priority-class-resourcequota.yaml><code>policy/priority-class-resourcequota.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('policy-priority-class-resourcequota-yaml')" title="Copy policy/priority-class-resourcequota.yaml to clipboard">
</img>
</div>
<div class=includecode id=policy-priority-class-resourcequota-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-cluster-services<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;cluster-services&#34;</span>]</code></pre></div>
</div>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/policy/priority-class-resourcequota.yaml -n kube-system
</code></pre></div><pre><code class=language-none data-lang=none>resourcequota/pods-cluster-services created
</code></pre>
<p>在这里，当以下条件满足时可以创建 Pod：</p>
<ol>
<li>Pod 未设置 <code>priorityClassName</code></li>
<li>Pod 的 <code>priorityClassName</code> 设置值不是 <code>cluster-services</code></li>
<li>Pod 的 <code>priorityClassName</code> 设置值为 <code>cluster-services</code>，它将被创建于
<code>kube-system</code> 名字空间中，并且它已经通过了资源配额检查。</li>
</ol>
<p>如果 Pod 的 <code>priorityClassName</code> 设置为 <code>cluster-services</code>，但要被创建到
<code>kube-system</code> 之外的别的名字空间，则 Pod 创建请求也被拒绝。</p>
<h2 id=接下来>接下来</h2>
<ul>
<li>查看<a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_resource_quota.md>资源配额设计文档</a></li>
<li>查看<a href=/zh/docs/tasks/administer-cluster/quota-api-object/>如何使用资源配额的详细示例</a>。</li>
<li>阅读<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/pod-priority-resourcequota.md>优先级类配额支持的设计文档</a>。
了解更多信息。</li>
<li>参阅 <a href=https://github.com/kubernetes/kubernetes/pull/36765>LimitedResources</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-59977cbac423e20437db079757cb03df>3 - Pod 安全策略</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [deprecated]</code>
</div>
<p>PodSecurityPolicy 在 Kubernetes v1.21 版本中被弃用，将在 v1.25 中删除。
关于弃用的更多信息，请查阅 <a href=/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/>PodSecurityPolicy Deprecation: Past, Present, and Future</a>。</p>
<p>Pod 安全策略使得对 Pod 创建和更新进行细粒度的权限控制成为可能。</p>
<h2 id=什么是-pod-安全策略>什么是 Pod 安全策略？</h2>
<p><em>Pod 安全策略（Pod Security Policy）</em> 是集群级别的资源，它能够控制 Pod 规约
中与安全性相关的各个方面。
<a href=/docs/reference/generated/kubernetes-api/v1.22/#podsecuritypolicy-v1beta1-policy>PodSecurityPolicy</a>
对象定义了一组 Pod 运行时必须遵循的条件及相关字段的默认值，只有 Pod 满足这些条件
才会被系统接受。
Pod 安全策略允许管理员控制如下方面：</p>
<table>
<thead>
<tr>
<th>控制的角度</th>
<th>字段名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>运行特权容器</td>
<td><a href=#privileged><code>privileged</code></a></td>
</tr>
<tr>
<td>使用宿主名字空间</td>
<td><a href=#host-namespaces><code>hostPID</code>、<code>hostIPC</code></a></td>
</tr>
<tr>
<td>使用宿主的网络和端口</td>
<td><a href=#host-namespaces><code>hostNetwork</code>, <code>hostPorts</code></a></td>
</tr>
<tr>
<td>控制卷类型的使用</td>
<td><a href=#volumes-and-file-systems><code>volumes</code></a></td>
</tr>
<tr>
<td>使用宿主文件系统</td>
<td><a href=#volumes-and-file-systems><code>allowedHostPaths</code></a></td>
</tr>
<tr>
<td>允许使用特定的 FlexVolume 驱动</td>
<td><a href=#flexvolume-drivers><code>allowedFlexVolumes</code></a></td>
</tr>
<tr>
<td>分配拥有 Pod 卷的 FSGroup 账号</td>
<td><a href=#volumes-and-file-systems><code>fsGroup</code></a></td>
</tr>
<tr>
<td>以只读方式访问根文件系统</td>
<td><a href=#volumes-and-file-systems><code>readOnlyRootFilesystem</code></a></td>
</tr>
<tr>
<td>设置容器的用户和组 ID</td>
<td><a href=#users-and-groups><code>runAsUser</code>, <code>runAsGroup</code>, <code>supplementalGroups</code></a></td>
</tr>
<tr>
<td>限制 root 账号特权级提升</td>
<td><a href=#privilege-escalation><code>allowPrivilegeEscalation</code>, <code>defaultAllowPrivilegeEscalation</code></a></td>
</tr>
<tr>
<td>Linux 权能字（Capabilities）</td>
<td><a href=#capabilities><code>defaultAddCapabilities</code>, <code>requiredDropCapabilities</code>, <code>allowedCapabilities</code></a></td>
</tr>
<tr>
<td>设置容器的 SELinux 上下文</td>
<td><a href=#selinux><code>seLinux</code></a></td>
</tr>
<tr>
<td>指定容器可以挂载的 proc 类型</td>
<td><a href=#allowedprocmounttypes><code>allowedProcMountTypes</code></a></td>
</tr>
<tr>
<td>指定容器使用的 AppArmor 模版</td>
<td><a href=#apparmor>annotations</a></td>
</tr>
<tr>
<td>指定容器使用的 seccomp 模版</td>
<td><a href=#seccomp>annotations</a></td>
</tr>
<tr>
<td>指定容器使用的 sysctl 模版</td>
<td><a href=#sysctl><code>forbiddenSysctls</code>,<code>allowedUnsafeSysctls</code></a></td>
</tr>
</tbody>
</table>
<p><em>Pod 安全策略</em> 由设置和策略组成，它们能够控制 Pod 访问的安全特征。这些设置分为如下三类：</p>
<ul>
<li><em>基于布尔值控制</em> ：这种类型的字段默认为最严格限制的值。</li>
<li><em>基于被允许的值集合控制</em> ：这种类型的字段会与这组值进行对比，以确认值被允许。</li>
<li><em>基于策略控制</em> ：设置项通过一种策略提供的机制来生成该值，这种机制能够确保指定的值落在被允许的这组值中。</li>
</ul>
<h2 id=启用-pod-安全策略>启用 Pod 安全策略</h2>
<p>Pod 安全策略实现为一种可选的
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#podsecuritypolicy>准入控制器</a>。
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#how-do-i-turn-on-an-admission-control-plug-in>启用了准入控制器</a>
即可强制实施 Pod 安全策略，不过如果没有授权认可策略之前即启用
准入控制器 <strong>将导致集群中无法创建任何 Pod</strong>。</p>
<p>由于 Pod 安全策略 API（<code>policy/v1beta1/podsecuritypolicy</code>）是独立于准入控制器
来启用的，对于现有集群而言，建议在启用准入控制器之前先添加策略并对其授权。</p>
<h2 id=authorizing-policies>授权策略 </h2>
<p>PodSecurityPolicy 资源被创建时，并不执行任何操作。为了使用该资源，需要对
发出请求的用户或者目标 Pod 的
<a href=/zh/docs/tasks/configure-pod-container/configure-service-account/>服务账号</a>
授权，通过允许其对策略执行 <code>use</code> 动词允许其使用该策略。</p>
<p>大多数 Kubernetes Pod 不是由用户直接创建的。相反，这些 Pod 是由
<a href=/zh/docs/concepts/workloads/controllers/deployment/>Deployment</a>、
<a href=/zh/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>
或者经由控制器管理器模版化的控制器创建。
赋予控制器访问策略的权限意味着对应控制器所创建的 <em>所有</em> Pod 都可访问策略。
因此，对策略进行授权的优先方案是为 Pod 的服务账号授予访问权限
（参见<a href=#run-another-pod>示例</a>）。</p>
<h3 id=via-rbac>通过 RBAC 授权 </h3>
<p><a href=/zh/docs/reference/access-authn-authz/rbac/>RBAC</a> 是一种标准的 Kubernetes
鉴权模式，可以很容易地用来授权策略访问。</p>
<p>首先，某 <code>Role</code> 或 <code>ClusterRole</code> 需要获得使用 <code>use</code> 访问目标策略的权限。
访问授权的规则看起来像这样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;Role 名称&gt;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;policy&#39;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;podsecuritypolicies&#39;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>     </span>[<span style=color:#b44>&#39;use&#39;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- &lt;要授权的策略列表&gt;<span style=color:#bbb>
</span></code></pre></div>
<p>接下来将该 <code>Role</code>（或 <code>ClusterRole</code>）绑定到授权的用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;binding name&gt;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;role name&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 授权命名空间下的所有服务账号（推荐）：</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts:&lt;authorized namespace&gt;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 授权特定的服务账号（不建议这样操作）：</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;authorized service account name&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>&lt;authorized pod namespace&gt;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 授权特定的用户（不建议这样操作）：</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;authorized user name&gt;<span style=color:#bbb>
</span></code></pre></div>
<p>如果使用的是 <code>RoleBinding</code>（而不是 <code>ClusterRoleBinding</code>），授权仅限于
与该 <code>RoleBinding</code> 处于同一名字空间中的 Pods。
可以考虑将这种授权模式和系统组结合，对名字空间中的所有 Pod 授予访问权限。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 授权某名字空间中所有服务账号</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 或者与之等价，授权给某名字空间中所有被认证过的用户</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span></code></pre></div>
<p>参阅<a href=/zh/docs/reference/access-authn-authz/rbac#role-binding-examples>角色绑定示例</a>
查看 RBAC 绑定的更多实例。
参阅<a href=#example>下文</a>，查看对 PodSecurityPolicy 进行授权的完整示例。</p>
<h2 id=recommended-practice>推荐实践 </h2>
<p>PodSecurityPolicy 正在被一个新的、简化的 <code>PodSecurity</code> <a class=glossary-tooltip title="在对象持久化之前拦截 Kubernetes Api 服务器请求的一段代码" data-toggle=tooltip data-placement=top href=/zh/docs/reference/access-authn-authz/admission-controllers/ target=_blank aria-label=准入控制器>准入控制器</a>替代。
有关此变更的更多详细信息，请参阅 <a href=/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/>PodSecurityPolicy Deprecation: Past, Present, and
Future</a>。
参照下述指导，简化从 PodSecurityPolicy 迁移到新的准入控制器步骤：</p>
<ol>
<li>
<p>将 PodSecurityPolicies 限制为 <a href=/zh/docs/concepts/security/pod-security-standards>Pod 安全性标准</a>所定义的策略：</p>
<ul>
<li>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/policy/privileged-psp.yaml download=policy/privileged-psp.yaml>Privileged</a>
</li>
<li>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/policy/baseline-psp.yaml download=policy/baseline-psp.yaml>Baseline</a>
</li>
<li>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/policy/restricted-psp.yaml download=policy/restricted-psp.yaml>Restricted</a>
</li>
</ul>
</li>
<li>
<p>通过配置 <code>system:serviceaccounts:&lt;namespace></code> 组（<code>&lt;namespace></code> 是目标命名空间），仅将 PSP 绑定到整个命名空间。示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># This cluster role binding allows all pods in the &#34;development&#34; namespace to use the baseline PSP.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>psp-baseline-namespaces<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>psp-baseline<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts:development<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts:canary<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<h3 id=troubleshooting>故障排查 </h3>
<ul>
<li><a href=/zh/docs/reference/command-line-tools-reference/kube-controller-manager/>控制器管理器组件</a>
必须运行在
<a href=/zh/docs/concepts/security/controlling-access/>安全的 API 端口</a>，
并且一定不能具有超级用户权限。
否则其请求会绕过身份认证和鉴权模块控制，从而导致所有 PodSecurityPolicy 对象
都被启用，用户亦能创建特权容器。
关于配置控制器管理器鉴权相关的详细信息，可参阅
<a href=/zh/docs/reference/access-authn-authz/rbac/#controller-roles>控制器角色</a>。</li>
</ul>
<h2 id=policy-order>策略顺序 </h2>
<p>除了限制 Pod 创建与更新，Pod 安全策略也可用来为其所控制的很多字段
设置默认值。当存在多个策略对象时，Pod 安全策略控制器依据以下条件选择
策略：</p>
<ol>
<li>优先考虑允许 Pod 保持原样，不会更改 Pod 字段默认值或其他配置的 PodSecurityPolicy。
这类非更改性质的 PodSecurityPolicy 对象之间的顺序无关紧要。</li>
<li>如果必须要为 Pod 设置默认值或者其他配置，（按名称顺序）选择第一个允许
Pod 操作的 PodSecurityPolicy 对象。</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 在更新操作期间（这时不允许更改 Pod 规约），仅使用非更改性质的
PodSecurityPolicy 来对 Pod 执行验证操作。
</div>
<h2 id=example>示例 </h2>
<p><em>本示例假定你已经有一个启动了 PodSecurityPolicy 准入控制器的集群并且
你拥有集群管理员特权。</em></p>
<h3 id=set-up>配置 </h3>
<p>为运行此示例，配置一个名字空间和一个服务账号。我们将用这个服务账号来
模拟一个非管理员账号的用户。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace psp-example
kubectl create serviceaccount -n psp-example fake-user
kubectl create rolebinding -n psp-example fake-editor --clusterrole<span style=color:#666>=</span>edit --serviceaccount<span style=color:#666>=</span>psp-example:fake-user
</code></pre></div>
<p>创建两个别名，以更清晰地展示我们所使用的用户账号，同时减少一些键盘输入：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>alias</span> kubectl-admin<span style=color:#666>=</span><span style=color:#b44>&#39;kubectl -n psp-example&#39;</span>
<span style=color:#a2f>alias</span> kubectl-user<span style=color:#666>=</span><span style=color:#b44>&#39;kubectl --as=system:serviceaccount:psp-example:fake-user -n psp-example&#39;</span>
</code></pre></div>
<h3 id=创建一个策略和一个-pod>创建一个策略和一个 Pod</h3>
<p>在一个文件中定义一个示例的 PodSecurityPolicy 对象。
这里的策略只是用来禁止创建有特权要求的 Pods。
PodSecurityPolicy 对象的名称必须是合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/policy/example-psp.yaml download=policy/example-psp.yaml><code>policy/example-psp.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('policy-example-psp-yaml')" title="Copy policy/example-psp.yaml to clipboard">
</img>
</div>
<div class=includecode id=policy-example-psp-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Don&#39;t allow privileged pods!</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># The rest fills in some required fields.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seLinux</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span>RunAsAny<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>supplementalGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span>RunAsAny<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span>RunAsAny<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span>RunAsAny<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>使用 kubectl 执行创建操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-admin create -f example-psp.yaml
</code></pre></div>
<p>现在，作为一个非特权用户，尝试创建一个简单的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user create -f- <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: pause
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: pause
</span><span style=color:#b44>      image: k8s.gcr.io/pause
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>输出类似于：</p>
<pre><code>Error from server (Forbidden): error when creating &quot;STDIN&quot;: pods &quot;pause&quot; is forbidden: unable to validate against any pod security policy: []
</code></pre>
<p><strong>发生了什么？</strong> 尽管 PodSecurityPolicy 被创建，Pod 的服务账号或者
<code>fake-user</code> 用户都没有使用该策略的权限。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user auth can-i use podsecuritypolicy/example
</code></pre></div><pre><code>no
</code></pre>
<p>创建角色绑定，赋予 <code>fake-user</code> 使用 <code>use</code> 访问示例策略的权限：</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 不建议使用这种方法！
欲了解优先考虑的方法，请参见<a href=#run-another-pod>下节</a>。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-admin create role psp:unprivileged <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --verb<span style=color:#666>=</span>use <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --resource<span style=color:#666>=</span>podsecuritypolicy <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --resource-name<span style=color:#666>=</span>example
</code></pre></div><p>输出：</p>
<pre><code>role &quot;psp:unprivileged&quot; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-admin create rolebinding fake-user:psp:unprivileged <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --role<span style=color:#666>=</span>psp:unprivileged <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --serviceaccount<span style=color:#666>=</span>psp-example:fake-user
</code></pre></div><p>输出：</p>
<pre><code>rolebinding &quot;fake-user:psp:unprivileged&quot; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user auth can-i use podsecuritypolicy/example
</code></pre></div><p>输出：</p>
<pre><code>yes
</code></pre>
<p>现在重试创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user create -f- <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: pause
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: pause
</span><span style=color:#b44>      image: k8s.gcr.io/pause
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>输出类似于：</p>
<pre><code>pod &quot;pause&quot; created
</code></pre>
<p>此次尝试不出所料地成功了！
不过任何创建特权 Pod 的尝试还是会被拒绝：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user create -f- <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: privileged
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: pause
</span><span style=color:#b44>      image: k8s.gcr.io/pause
</span><span style=color:#b44>      securityContext:
</span><span style=color:#b44>        privileged: true
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>输出类似于：</p>
<pre><code>Error from server (Forbidden): error when creating &quot;STDIN&quot;: pods &quot;privileged&quot; is forbidden: unable to validate against any pod security policy: [spec.containers[0].securityContext.privileged: Invalid value: true: Privileged containers are not allowed]
</code></pre>
<p>继续此例之前先删除该 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user delete pod pause
</code></pre></div>
<h3 id=run-another-pod>运行另一个 Pod </h3>
<p>我们再试一次，稍微有些不同：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user create deployment pause --image<span style=color:#666>=</span>k8s.gcr.io/pause
</code></pre></div><p>输出为：</p>
<pre><code>deployment &quot;pause&quot; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user get pods
</code></pre></div><p>输出为：</p>
<pre><code>No resources found.
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user get events | head -n <span style=color:#666>2</span>
</code></pre></div><p>输出为：</p>
<pre><code>LASTSEEN   FIRSTSEEN   COUNT     NAME              KIND         SUBOBJECT                TYPE      REASON                  SOURCE                                  MESSAGE
1m         2m          15        pause-7774d79b5   ReplicaSet                            Warning   FailedCreate            replicaset-controller                   Error creating: pods &quot;pause-7774d79b5-&quot; is forbidden: no providers available to validate pod request
</code></pre>
<p><strong>发生了什么？</strong> 我们已经为用户 <code>fake-user</code> 绑定了 <code>psp:unprivileged</code> 角色，
为什么还会收到错误 <code>Error creating: pods "pause-7774d79b5-" is forbidden: no providers available to validate pod request （创建错误：pods "pause-7774d79b5" 被禁止：没有可用来验证 pod 请求的驱动）</code>？
答案在于源文件 - <code>replicaset-controller</code>。
<code>fake-user</code> 用户成功地创建了 Deployment，而后者也成功地创建了 ReplicaSet，
不过当 ReplicaSet 创建 Pod 时，发现未被授权使用示例 PodSecurityPolicy 资源。</p>
<p>为了修复这一问题，将 <code>psp:unprivileged</code> 角色绑定到 Pod 的服务账号。
在这里，因为我们没有给出服务账号名称，默认的服务账号是 <code>default</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-admin create rolebinding default:psp:unprivileged <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --role<span style=color:#666>=</span>psp:unprivileged <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --serviceaccount<span style=color:#666>=</span>psp-example:default
</code></pre></div><p>输出为：</p>
<pre><code>rolebinding &quot;default:psp:unprivileged&quot; created
</code></pre>
<p>现在如果你给 ReplicaSet 控制器一分钟的时间来重试，该控制器最终将能够
成功地创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-user get pods --watch
</code></pre></div><p>输出类似于：</p>
<pre><code>NAME                    READY     STATUS    RESTARTS   AGE
pause-7774d79b5-qrgcb   0/1       Pending   0         1s
pause-7774d79b5-qrgcb   0/1       Pending   0         1s
pause-7774d79b5-qrgcb   0/1       ContainerCreating   0         1s
pause-7774d79b5-qrgcb   1/1       Running   0         2s
</code></pre>
<h3 id=clean-up>清理 </h3>
<p>删除名字空间即可清理大部分示例资源：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-admin delete ns psp-example
</code></pre></div><p>输出类似于：</p>
<pre><code>namespace &quot;psp-example&quot; deleted
</code></pre>
<p>注意 <code>PodSecurityPolicy</code> 资源不是名字空间域的资源，必须单独清理：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl-admin delete psp example
</code></pre></div><p>输出类似于：</p>
<pre><code>podsecuritypolicy &quot;example&quot; deleted
</code></pre>
<h3 id=example-policies>示例策略 </h3>
<p>下面是一个你可以创建的约束性非常弱的策略，其效果等价于没有使用 Pod 安全
策略准入控制器：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/policy/privileged-psp.yaml download=policy/privileged-psp.yaml><code>policy/privileged-psp.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('policy-privileged-psp-yaml')" title="Copy policy/privileged-psp.yaml to clipboard">
</img>
</div>
<div class=includecode id=policy-privileged-psp-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>privileged<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>seccomp.security.alpha.kubernetes.io/allowedProfileNames</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowPrivilegeEscalation</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowedCapabilities</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPorts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>min</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb> </span><span style=color:#666>65535</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostIPC</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPID</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seLinux</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>supplementalGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>下面是一个具有约束性的策略，要求用户以非特权账号运行，禁止可能的向 root 权限
的升级，同时要求使用若干安全机制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/policy/restricted-psp.yaml download=policy/restricted-psp.yaml><code>policy/restricted-psp.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('policy-restricted-psp-yaml')" title="Copy policy/restricted-psp.yaml to clipboard">
</img>
</div>
<div class=includecode id=policy-restricted-psp-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>restricted<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>seccomp.security.alpha.kubernetes.io/allowedProfileNames</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker/default,runtime/default&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apparmor.security.beta.kubernetes.io/allowedProfileNames</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;runtime/default&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>seccomp.security.alpha.kubernetes.io/defaultProfileName</span>:<span style=color:#bbb>  </span><span style=color:#b44>&#39;runtime/default&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apparmor.security.beta.kubernetes.io/defaultProfileName</span>:<span style=color:#bbb>  </span><span style=color:#b44>&#39;runtime/default&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Required to prevent escalations to root.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowPrivilegeEscalation</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># This is redundant with non-root + disallow privilege escalation,</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># but we can provide it for defense in depth.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requiredDropCapabilities</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ALL<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Allow core volume types.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;configMap&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;emptyDir&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;projected&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;secret&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;downwardAPI&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Assume that persistentVolumes set up by the cluster admin are safe to use.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;persistentVolumeClaim&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostIPC</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPID</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Require the container to run without root privileges.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;MustRunAsNonRoot&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seLinux</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This policy assumes the nodes are using AppArmor rather than SELinux.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>supplementalGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;MustRunAs&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ranges</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Forbid adding the root group.</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>min</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb> </span><span style=color:#666>65535</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;MustRunAs&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ranges</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Forbid adding the root group.</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>min</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb> </span><span style=color:#666>65535</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readOnlyRootFilesystem</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>更多的示例可参考
<a href=/zh/docs/concepts/security/pod-security-standards/#policy-instantiation>Pod 安全标准</a>。</p>
<h2 id=policy-reference>策略参考 </h2>
<h3 id=privileged>Privileged</h3>
<p><strong>Privileged</strong> - 决定是否 Pod 中的某容器可以启用特权模式。
默认情况下，容器是不可以访问宿主上的任何设备的，不过一个“privileged（特权的）”
容器则被授权访问宿主上所有设备。
这种容器几乎享有宿主上运行的进程的所有访问权限。
对于需要使用 Linux 权能字（如操控网络堆栈和访问设备）的容器而言是有用的。</p>
<h3 id=host-namespaces>宿主名字空间 </h3>
<p><strong>HostPID</strong> - 控制 Pod 中容器是否可以共享宿主上的进程 ID 空间。
注意，如果与 <code>ptrace</code> 相结合，这种授权可能被利用，导致向容器外的特权逃逸
（默认情况下 <code>ptrace</code> 是被禁止的）。</p>
<p><strong>HostIPC</strong> - 控制 Pod 容器是否可共享宿主上的 IPC 名字空间。</p>
<p><strong>HostNetwork</strong> - 控制是否 Pod 可以使用节点的网络名字空间。
此类授权将允许 Pod 访问本地回路（loopback）设备、在本地主机（localhost）
上监听的服务、还可能用来监听同一节点上其他 Pod 的网络活动。</p>
<p><strong>HostPorts</strong> -提供可以在宿主网络名字空间中可使用的端口范围列表。
该属性定义为一组 <code>HostPortRange</code> 对象的列表，每个对象中包含
<code>min</code>（含）与 <code>max</code>（含）值的设置。
默认不允许访问宿主端口。</p>
<h3 id=volumes-and-file-systems>卷和文件系统 </h3>
<p><strong>Volumes</strong> - 提供一组被允许的卷类型列表。可被允许的值对应于创建卷时可以
设置的卷来源。卷类型的完整列表可参见
<a href=/zh/docs/concepts/storage/volumes/#types-of-volumes>卷类型</a>。
此外， <code>*</code> 可以用来允许所有卷类型。</p>
<p>对于新的 Pod 安全策略设置而言，建议设置的卷类型的<em>最小列表</em>包含：</p>
<ul>
<li>configMap</li>
<li>downwardAPI</li>
<li>emptyDir</li>
<li>persistentVolumeClaim</li>
<li>secret</li>
<li>projected</li>
</ul>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告：</strong> PodSecurityPolicy 并不限制可以被 <code>PersistentVolumeClaim</code> 所引用的
<code>PersistentVolume</code> 对象的类型。
此外 <code>hostPath</code> 类型的 <code>PersistentVolume</code> 不支持只读访问模式。
应该仅赋予受信用户创建 <code>PersistentVolume</code> 对象的访问权限。
</div>
<p><strong>FSGroup</strong> - 控制应用到某些卷上的附加用户组。</p>
<ul>
<li><em>MustRunAs</em> - 要求至少指定一个 <code>range</code>。
使用范围中的最小值作为默认值。所有 range 值都会被用来执行验证。</li>
<li><em>MayRunAs</em> - 要求至少指定一个 <code>range</code>。
允许不设置 <code>FSGroups</code>，且无默认值。
如果 <code>FSGroup</code> 被设置，则所有 range 值都会被用来执行验证检查。</li>
<li><em>RunAsAny</em> - 不提供默认值。允许设置任意 <code>fsGroup</code> ID 值。</li>
</ul>
<p><strong>AllowedHostPaths</strong> - 设置一组宿主文件目录，这些目录项可以在 <code>hostPath</code> 卷中
使用。列表为空意味着对所使用的宿主目录没有限制。
此选项定义包含一个对象列表，表中对象包含 <code>pathPrefix</code> 字段，用来表示允许
<code>hostPath</code> 卷挂载以所指定前缀开头的路径。
对象中还包含一个 <code>readOnly</code> 字段，用来表示对应的卷必须以只读方式挂载。
例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>allowedHostPaths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 下面的设置允许 &#34;/foo&#34;、&#34;/foo/&#34;、&#34;/foo/bar&#34; 等路径，但禁止</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># &#34;/fool&#34;、&#34;/etc/foo&#34; 这些路径。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># &#34;/foo/../&#34; 总会被当作非法路径。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>pathPrefix</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 仅允许只读模式挂载</span><span style=color:#bbb>
</span></code></pre></div>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告：</strong> <p>容器如果对宿主文件系统拥有不受限制的访问权限，就可以有很多种方式提升自己的特权，
包括读取其他容器中的数据、滥用系统服务（如 <code>kubelet</code>）的凭据信息等。</p>
<p>由可写入的目录所构造的 <code>hostPath</code> 卷能够允许容器写入数据到宿主文件系统，
并且在写入时避开 <code>pathPrefix</code> 所设置的目录限制。
<code>readOnly: true</code> 这一设置在 Kubernetes 1.11 版本之后可用。
必须针对 <code>allowedHostPaths</code> 中的 <em>所有</em> 条目设置此属性才能有效地限制容器
只能访问 <code>pathPrefix</code> 所指定的目录。</p>
</div>
<p><strong>ReadOnlyRootFilesystem</strong> - 要求容器必须以只读方式挂载根文件系统来运行
（即不允许存在可写入层）。</p>
<h3 id=flexvolume-drivers>FlexVolume 驱动 </h3>
<p>此配置指定一个可以被 FlexVolume 卷使用的驱动程序的列表。
空的列表或者 nil 值意味着对驱动没有任何限制。
请确保<a href=#volumes-and-file-systems><code>volumes</code></a> 字段包含了 <code>flexVolume</code> 卷类型，
否则所有 FlexVolume 驱动都被禁止。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-flex-volumes<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># spec d的其他字段</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- flexVolume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowedFlexVolumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>example/lvm<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>example/cifs<span style=color:#bbb>
</span></code></pre></div>
<h3 id=users-and-groups>用户和组 </h3>
<p><strong>RunAsUser</strong> - 控制使用哪个用户 ID 来运行容器。</p>
<ul>
<li><em>MustRunAs</em> - 必须配置一个 <code>range</code>。使用该范围内的第一个值作为默认值。
所有 range 值都被用于验证检查。</li>
<li><em>MustRunAsNonRoot</em> - 要求提交的 Pod 具有非零 <code>runAsUser</code> 值，或在镜像中
（使用 UID 数值）定义了 <code>USER</code> 环境变量。
如果 Pod 既没有设置 <code>runAsNonRoot</code>，也没有设置 <code>runAsUser</code>，则该 Pod 会被
修改以设置 <code>runAsNonRoot=true</code>，从而要求容器通过 <code>USER</code> 指令给出非零的数值形式
的用户 ID。此配置没有默认值。采用此配置时，强烈建议设置
<code>allowPrivilegeEscalation=false</code>。</li>
<li><em>RunAsAny</em> - 没有提供默认值。允许指定任何 <code>runAsUser</code> 配置。</li>
</ul>
<p><strong>RunAsGroup</strong> - 控制运行容器时使用的主用户组 ID。</p>
<ul>
<li><em>MustRunAs</em> - 要求至少指定一个 <code>range</code> 值。第一个 range
中的最小值作为默认值。所有 range 值都被用来执行验证检查。</li>
<li><em>MayRunAs</em> - 不要求设置 <code>RunAsGroup</code>。
不过，如果指定了 <code>RunAsGroup</code> 被设置，所设置值必须处于所定义的范围内。</li>
<li><em>RunAsAny</em> - 未指定默认值。允许 <code>runAsGroup</code> 设置任何值。</li>
</ul>
<p><strong>SupplementalGroups</strong> - 控制容器可以添加的组 ID。</p>
<ul>
<li><em>MustRunAs</em> - 要求至少指定一个 <code>range</code> 值。
第一个 range 中的最小值用作默认值。
所有 range 值都被用来执行验证检查。</li>
<li><em>MayRunAs</em> - 要求至少指定一个 <code>range</code> 值。
允许不指定 <code>supplementalGroups</code> 且不设置默认值。
如果 <code>supplementalGroups</code> 被设置，则所有 range 值都被用来执行验证检查。</li>
<li><em>RunAsAny</em> - 未指定默认值。允许为 <code>supplementalGroups</code> 设置任何值。</li>
</ul>
<h3 id=privilege-escalation>特权提升 </h3>
<p>这一组选项控制容器的<code>allowPrivilegeEscalation</code> 属性。该属性直接决定是否为
容器进程设置
<a href=https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt><code>no_new_privs</code></a>
参数。此参数会禁止 <code>setuid</code> 属性的可执行文件更改有效用户 ID（EUID），并且
禁止启用额外权能的文件。例如，<code>no_new_privs</code> 会禁止使用 <code>ping</code> 工具。
如果想有效地实施 <code>MustRunAsNonRoot</code> 控制，需要配置这一选项。</p>
<p><strong>AllowPrivilegeEscalation</strong> - 决定是否用户可以将容器的安全上下文设置为
<code>allowPrivilegeEscalation=true</code>。默认设置下，这样做是允许的，目的是避免
造成现有的 <code>setuid</code> 应用无法运行。将此选项设置为 <code>false</code> 可以确保容器的所有
子进程都无法获得比父进程更多的特权。</p>
<p><strong>DefaultAllowPrivilegeEscalation</strong> - 为 <code>allowPrivilegeEscalation</code> 选项设置
默认值。不设置此选项时的默认行为是允许特权提升，以便运行 setuid 程序。
如果不希望运行 setuid 程序，可以使用此字段将选项的默认值设置为禁止，同时
仍然允许 Pod 显式地请求 <code>allowPrivilegeEscalation</code>。</p>
<h3 id=capabilities>权能字 </h3>
<p>Linux 权能字（Capabilities）将传统上与超级用户相关联的特权作了细粒度的分解。
其中某些权能字可以用来提升特权，打破容器边界，可以通过 PodSecurityPolicy
来限制。关于 Linux 权能字的更多细节，可参阅
<a href=http://man7.org/linux/man-pages/man7/capabilities.7.html>capabilities(7)</a>。</p>
<p>下列字段都可以配置为权能字的列表。表中的每一项都是 <code>ALL_CAPS</code> 中的一个权能字
名称，只是需要去掉 <code>CAP_</code> 前缀。</p>
<p><strong>AllowedCapabilities</strong> - 给出可以被添加到容器的权能字列表。
默认的权能字集合是被隐式允许的那些。空集合意味着只能使用默认权能字集合，
不允许添加额外的权能字。<code>*</code> 可以用来设置允许所有权能字。</p>
<p><strong>RequiredDropCapabilities</strong> - 必须从容器中去除的权能字。
所给的权能字会从默认权能字集合中去除，并且一定不可以添加。
<code>RequiredDropCapabilities</code> 中列举的权能字不能出现在
<code>AllowedCapabilities</code> 或 <code>DefaultAddCapabilities</code> 所给的列表中。</p>
<p><strong>DefaultAddCapabilities</strong> - 默认添加到容器的权能字集合。
这一集合是作为容器运行时所设值的补充。
关于使用 Docker 容器运行引擎时默认的权能字列表，可参阅
<a href=https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities>Docker 文档</a>。</p>
<h3 id=selinux>SELinux</h3>
<ul>
<li><em>MustRunAs</em> - 要求必须配置 <code>seLinuxOptions</code>。默认使用 <code>seLinuxOptions</code>。
针对 <code>seLinuxOptions</code> 所给值执行验证检查。</li>
<li><em>RunAsAny</em> - 没有提供默认值。允许任意指定的 <code>seLinuxOptions</code> 选项。</li>
</ul>
<h3 id=allowedprocmounttypes>AllowedProcMountTypes</h3>
<p><code>allowedProcMountTypes</code> 是一组可以允许的 proc 挂载类型列表。
空表或者 nil 值表示只能使用 <code>DefaultProcMountType</code>。</p>
<p><code>DefaultProcMount</code> 使用容器运行时的默认值设置来决定 <code>/proc</code> 的只读挂载模式
和路径屏蔽。大多数容器运行时都会屏蔽 <code>/proc</code> 下面的某些路径以避免特殊设备或
信息被不小心暴露给容器。这一配置使所有 <code>Default</code> 字符串值来表示。</p>
<p>此外唯一的ProcMountType 是 <code>UnmaskedProcMount</code>，意味着即将绕过容器运行时的
路径屏蔽行为，确保新创建的 <code>/proc</code> 不会被容器修改。此配置用字符串
<code>Unmasked</code> 来表示。</p>
<h3 id=apparmor>AppArmor</h3>
<p>通过 PodSecurityPolicy 上的注解来控制。
详情请参阅
<a href=/zh/docs/tutorials/clusters/apparmor/#podsecuritypolicy-annotations>AppArmor 文档</a>。</p>
<h3 id=seccomp>Seccomp</h3>
<p>Pod 对 seccomp 模版的使用可以通过在 PodSecurityPolicy 上设置注解来控制。
Seccomp 是 Kubernetes 的一项 alpha 阶段特性。</p>
<p><strong>seccomp.security.alpha.kubernetes.io/defaultProfileName</strong> - 注解用来
指定为容器配置默认的 seccomp 模版。可选值为：</p>
<ul>
<li><code>unconfined</code> - 如果没有指定其他替代方案，Seccomp 不会被应用到容器进程上
（Kubernets 中的默认设置）。</li>
<li><code>runtime/default</code> - 使用默认的容器运行时模版。</li>
<li><code>docker/default</code> - 使用 Docker 的默认 seccomp 模版。自 1.11 版本废弃。
应改为使用 <code>runtime/default</code>。</li>
<li><code>localhost/&lt;路径名></code> - 指定节点上路径 <code>&lt;seccomp_root>/&lt;路径名></code> 下的一个
文件作为其模版。其中 <code>&lt;seccomp_root></code> 是通过 <code>kubelet</code> 的标志
<code>--seccomp-profile-root</code> 来指定的。</li>
</ul>
<p><strong>seccomp.security.alpha.kubernetes.io/allowedProfileNames</strong> - 指定可以为
Pod seccomp 注解配置的值的注解。取值为一个可用值的列表。
表中每项可以是上述各值之一，还可以是 <code>*</code>，用来表示允许所有的模版。
如果没有设置此注解，意味着默认的 seccomp 模版是不可更改的。</p>
<h3 id=sysctl>Sysctl</h3>
<p>默认情况下，所有的安全的 sysctl 都是被允许的。</p>
<ul>
<li><code>forbiddenSysctls</code> - 用来排除某些特定的 sysctl。
你可以在此列表中禁止一些安全的或者不安全的 sysctl。
此选项设置为 <code>*</code> 意味着禁止设置所有 sysctl。</li>
<li><code>allowedUnsafeSysctls</code> - 用来启用那些被默认列表所禁用的 sysctl，
前提是所启用的 sysctl 没有被列在 <code>forbiddenSysctls</code> 中。</li>
</ul>
<p>参阅 <a href=/zh/docs/tasks/administer-cluster/sysctl-cluster/#podsecuritypolicy>Sysctl 文档</a>。</p>
<h2 id=接下来>接下来</h2>
<ul>
<li>
<p>参阅 <a href=/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/>PodSecurityPolicy Deprecation: Past, Present, and
Future</a>，了解 Pod 安全策略的未来。</p>
</li>
<li>
<p>参阅<a href=/zh/docs/concepts/security/pod-security-standards/>Pod 安全标准</a>
了解策略建议。</p>
</li>
<li>
<p>阅读 <a href=/docs/reference/generated/kubernetes-api/v1.22/#podsecuritypolicy-v1beta1-policy>Pod 安全策略参考</a>了解 API 细节。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7352434db5f5954d2f7656b46fe5a324>4 - 进程 ID 约束与预留</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<p>Kubernetes 允许你限制一个 <a class=glossary-tooltip title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> 中可以使用的
进程 ID（PID）数目。你也可以为每个 <a class=glossary-tooltip title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/nodes/ target=_blank aria-label=节点>节点</a>
预留一定数量的可分配的 PID，供操作系统和守护进程（而非 Pod）使用。</p>
<p>进程 ID（PID）是节点上的一种基础资源。很容易就会在尚未超出其它资源约束的时候就
已经触及任务个数上限，进而导致宿主机器不稳定。</p>
<p>集群管理员需要一定的机制来确保集群中运行的 Pod 不会导致 PID 资源枯竭，甚而
造成宿主机上的守护进程（例如
<a class=glossary-tooltip title="一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。" data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> 或者
<a class=glossary-tooltip title="kube-proxy 是集群中每个节点上运行的网络代理。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>
乃至包括容器运行时本身）无法正常运行。
此外，确保 Pod 中 PID 的个数受限对于保证其不会影响到同一节点上其它负载也很重要。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>在某些 Linux 安装环境中，操作系统会将 PID 约束设置为一个较低的默认值，例如
<code>32768</code>。这时可以考虑提升 <code>/proc/sys/kernel/pid_max</code> 的设置值。
</div>
<p>你可以配置 kubelet 限制给定 Pod 能够使用的 PID 个数。
例如，如果你的节点上的宿主操作系统被设置为最多可使用 <code>262144</code> 个 PID，同时预期
节点上会运行的 Pod 个数不会超过 <code>250</code>，那么你可以为每个 Pod 设置 <code>1000</code> 个 PID
的预算，避免耗尽该节点上可用 PID 的总量。
如果管理员系统像 CPU 或内存那样允许对 PID 进行过量分配（Overcommit），他们也可以
这样做，只是会有一些额外的风险。不管怎样，任何一个 Pod 都不可以将整个机器的运行
状态破坏。这类资源限制有助于避免简单的派生炸弹（Fork
Bomb）影响到整个集群的运行。</p>
<p>在 Pod 级别设置 PID 限制使得管理员能够保护 Pod 之间不会互相伤害，不过无法
确保所有调度到该宿主机器上的所有 Pod 都不会影响到节点整体。
Pod 级别的限制也无法保护节点代理任务自身不会受到 PID 耗尽的影响。</p>
<p>你也可以预留一定量的 PID，作为节点的额外开销，与分配给 Pod 的 PID 集合独立。
这有点类似于在给操作系统和其它设施预留 CPU、内存或其它资源时所做的操作，
这些任务都在 Pod 及其所包含的容器之外运行。</p>
<p>PID 限制是与<a href=/zh/docs/concepts/configuration/manage-resources-containers/>计算资源</a>
请求和限制相辅相成的一种机制。不过，你需要用一种不同的方式来设置这一限制：
你需要将其设置到 kubelet 上而不是在 Pod 的 <code>.spec</code> 中为 Pod 设置资源限制。
目前还不支持在 Pod 级别设置 PID 限制。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong>
<p>这意味着，施加在 Pod 之上的限制值可能因为 Pod 运行所在的节点不同而有差别。
为了简化系统，最简单的方法是为所有节点设置相同的 PID 资源限制和预留值。
</div>
<h2 id=node-pid-limits>节点级别 PID 限制 </h2>
<p>Kubernetes 允许你为系统预留一定量的进程 ID。为了配置预留数量，你可以使用
kubelet 的 <code>--system-reserved</code> 和 <code>--kube-reserved</code> 命令行选项中的参数
<code>pid=&lt;number></code>。你所设置的参数值分别用来声明为整个系统和 Kubernetes 系统
守护进程所保留的进程 ID 数目。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>在 Kubernetes 1.20 版本之前，在节点级别通过 PID 资源限制预留 PID 的能力
需要启用<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
<code>SupportNodePidsLimit</code> 才行。
</div>
<h2 id=pod-pid-limits>Pod 级别 PID 限制 </h2>
<p>Kubernetes 允许你限制 Pod 中运行的进程个数。你可以在节点级别设置这一限制，
而不是为特定的 Pod 来将其设置为资源限制。
每个节点都可以有不同的 PID 限制设置。
要设置限制值，你可以设置 kubelet 的命令行参数 <code>--pod-max-pids</code>，或者
在 kubelet 的<a href=/zh/docs/tasks/administer-cluster/kubelet-config-file/>配置文件</a>
中设置 <code>PodPidsLimit</code>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>在 Kubernetes 1.20 版本之前，为 Pod 设置 PID 资源限制的能力需要启用
<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
<code>SupportNodePidsLimit</code> 才行。
</div>
<h2 id=pid-based-eviction>基于 PID 的驱逐 </h2>
<p>你可以配置 kubelet 使之在 Pod 行为不正常或者消耗不正常数量资源的时候将其终止。
这一特性称作驱逐。你可以针对不同的驱逐信号
<a href=/zh/docs/tasks/administer-cluster/out-of-resource>配置资源不足的处理</a>。
使用 <code>pid.available</code> 驱逐信号来配置 Pod 使用的 PID 个数的阈值。
你可以设置硬性的和软性的驱逐策略。不过，即使使用硬性的驱逐策略，
如果 PID 个数增长过快，节点仍然可能因为触及节点 PID 限制而进入一种不稳定状态。
驱逐信号的取值是周期性计算的，而不是一直能够强制实施约束。</p>
<p>Pod 级别和节点级别的 PID 限制会设置硬性限制。
一旦触及限制值，工作负载会在尝试获得新的 PID 时开始遇到问题。
这可能会也可能不会导致 Pod 被重新调度，取决于工作负载如何应对这类失败
以及 Pod 的存活性和就绪态探测是如何配置的。
可是，如果限制值被正确设置，你可以确保其它 Pod 负载和系统进程不会因为某个
Pod 行为不正常而没有 PID 可用。</p>
<h2 id=接下来>接下来</h2>
<ul>
<li>参阅 <a href=https://github.com/kubernetes/enhancements/blob/097b4d8276bc9564e56adf72505d43ce9bc5e9e8/keps/sig-node/20190129-pid-limiting.md>PID 约束改进文档</a>
以了解更多信息。</li>
<li>关于历史背景，请阅读
<a href=/blog/2019/04/15/process-id-limiting-for-stability-improvements-in-kubernetes-1.14/>Kubernetes 1.14 中限制进程 ID 以提升稳定性</a>
的博文。</li>
<li>请阅读<a href=/zh/docs/concepts/configuration/manage-resources-containers/>为容器管理资源</a>。</li>
<li>学习如何<a href=/zh/docs/concepts/scheduling-eviction/node-pressure-eviction/>配置资源不足情况的处理</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b528c4464c030f3f044124b38d778f04>5 - 节点资源管理器</h1>
<p>Kubernetes 提供了一组资源管理器，用于支持延迟敏感的、高吞吐量的工作负载。
资源管理器的目标是协调和优化节点资源，以支持对 CPU、设备和内存（巨页）等资源有特殊需求的 Pod。</p>
<p>主管理器，也叫拓扑管理器（Topology Manager），是一个 Kubelet 组件，
它通过<a href=/zh/docs/tasks/administer-cluster/topology-manager/>策略</a>，
协调全局的资源管理过程。</p>
<p>各个管理器的配置方式会在专项文档中详细阐述：</p>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/cpu-management-policies/>CPU 管理器策略</a></li>
<li><a href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#device-plugin-integration-with-the-topology-manager>设备管理器</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/memory-manager/>内存管理器策略</a></li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/zh/docs/home/>主页</a>
<a class=text-white href=/zh/blog/>博客</a>
<a class=text-white href=/zh/training/>培训</a>
<a class=text-white href=/zh/partners/>合作伙伴</a>
<a class=text-white href=/zh/community/>社区</a>
<a class=text-white href=/zh/case-studies/>案例分析</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small>
<br>
<small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>