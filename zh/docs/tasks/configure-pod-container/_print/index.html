<!doctype html><html lang=zh class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/configure-pod-container/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tasks/configure-pod-container/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/configure-pod-container/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/configure-pod-container/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/configure-pod-container/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/configure-pod-container/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/configure-pod-container/>
<link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/tasks/configure-pod-container/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/zh/docs/tasks/configure-pod-container/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>配置 Pods 和容器 | Kubernetes</title><meta property="og:title" content="配置 Pods 和容器">
<meta property="og:description" content="对 Pod 和容器执行常见的配置任务。">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/zh/docs/tasks/configure-pod-container/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="配置 Pods 和容器">
<meta itemprop=description content="对 Pod 和容器执行常见的配置任务。"><meta name=twitter:card content="summary">
<meta name=twitter:title content="配置 Pods 和容器">
<meta name=twitter:description content="对 Pod 和容器执行常见的配置任务。">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="对 Pod 和容器执行常见的配置任务。">
<meta property="og:description" content="对 Pod 和容器执行常见的配置任务。">
<meta name=twitter:description content="对 Pod 和容器执行常见的配置任务。">
<meta property="og:url" content="https://kubernetes.io/zh/docs/tasks/configure-pod-container/">
<meta property="og:title" content="配置 Pods 和容器">
<meta name=twitter:title content="配置 Pods 和容器">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/zh/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/zh/docs/>文档</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/blog/>Kubernetes 博客</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/training/>培训</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/partners/>合作伙伴</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/community/>社区</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/case-studies/>案例分析</span></a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
版本列表
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh/docs/tasks/configure-pod-container/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/zh/docs/tasks/configure-pod-container/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh/docs/tasks/configure-pod-container/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh/docs/tasks/configure-pod-container/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh/docs/tasks/configure-pod-container/>v1.22</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/tasks/configure-pod-container/>English</a>
<a class=dropdown-item href=/ko/docs/tasks/configure-pod-container/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/tasks/configure-pod-container/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/tasks/configure-pod-container/>Français</a>
<a class=dropdown-item href=/de/docs/tasks/configure-pod-container/>Deutsch</a>
<a class=dropdown-item href=/es/docs/tasks/configure-pod-container/>Español</a>
<a class=dropdown-item href=/id/docs/tasks/configure-pod-container/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/tasks/configure-pod-container/>Русский</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/zh/docs/tasks/configure-pod-container/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>配置 Pods 和容器</h1>
<div class=lead>对 Pod 和容器执行常见的配置任务。</div>
<ul>
<li>1: <a href=#pg-e6dd9300cf3a955f7cdfe77fb5d15292>为容器和 Pod 分配内存资源</a></li>
<li>2: <a href=#pg-aa522472483f900008124a2809f2114b>为 Windows Pod 和容器配置 GMSA</a></li>
<li>3: <a href=#pg-f5da7517bee8a8807431d9fc65263b39>为 Windows 的 Pod 和容器配置 RunAsUserName</a></li>
<li>4: <a href=#pg-8555af270ae7122cc0464bab3f5d1609>为容器和 Pods 分配 CPU 资源</a></li>
<li>5: <a href=#pg-904cea8c8efd5c0d33adbfe579ec2dd2>配置 Pod 的服务质量</a></li>
<li>6: <a href=#pg-4219ac6ab56a3b88d20305083d57d03c>为容器分派扩展资源</a></li>
<li>7: <a href=#pg-484833fb880d1e179cc2965d15f84da5>配置 Pod 以使用卷进行存储</a></li>
<li>8: <a href=#pg-528d2422215cb9632b7b45e886b023b5>配置 Pod 以使用 PersistentVolume 作为存储</a></li>
<li>9: <a href=#pg-4621938ba53c04a77f51b5938a583439>配置 Pod 使用投射卷作存储</a></li>
<li>10: <a href=#pg-abd895c0803315e9717e6ff9ec4e3d30>为 Pod 或容器配置安全性上下文</a></li>
<li>11: <a href=#pg-2c0d882359718c4c69c67099bed2156c>为 Pod 配置服务账户</a></li>
<li>12: <a href=#pg-d385b86a7cb496d3b1c3b2a47280ca70>从私有仓库拉取镜像</a></li>
<li>13: <a href=#pg-eb54daf87df373096b5e830680194dfc>配置存活、就绪和启动探测器</a></li>
<li>14: <a href=#pg-bbc17480da6d051c696489654c64064a>将 Pod 分配给节点</a></li>
<li>15: <a href=#pg-fc3f4777ae8ea685d2b54e175277ac01>用节点亲和性把 Pods 分配到节点</a></li>
<li>16: <a href=#pg-1e7baac1825631a5af5d2aebcf059249>配置 Pod 初始化</a></li>
<li>17: <a href=#pg-efbc43486296f0439d1a89c12d944d94>为容器的生命周期事件设置处理函数</a></li>
<li>18: <a href=#pg-ed34e761c3dbd00fa79577fa78e30020>配置 Pod 使用 ConfigMap</a></li>
<li>19: <a href=#pg-3d7b9cb24a647c36ba63f7a02ec49010>在 Pod 中的容器之间共享进程命名空间</a></li>
<li>20: <a href=#pg-42a59b878d4c58e5c6f4bb87483dda93>创建静态 Pod</a></li>
<li>21: <a href=#pg-1bb997c61a85de753d9994e7a312a291>将 Docker Compose 文件转换为 Kubernetes 资源</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-e6dd9300cf3a955f7cdfe77fb5d15292>1 - 为容器和 Pod 分配内存资源</h1>
<p>此页面展示如何将内存 <em>请求</em> （request）和内存 <em>限制</em> （limit）分配给一个容器。
我们保障容器拥有它请求数量的内存，但不允许使用超过限制数量的内存。</p>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<p>你集群中的每个节点必须拥有至少 300 MiB 的内存。</p>
<p>该页面上的一些步骤要求你在集群中运行
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a> 服务。
如果你已经有在运行中的 metrics-server，则可以跳过这些步骤。</p>
<p>如果你运行的是 Minikube，可以运行下面的命令启用 metrics-server：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube addons <span style=color:#a2f>enable</span> metrics-server
</code></pre></div>
<p>要查看 metrics-server 或资源指标 API (<code>metrics.k8s.io</code>) 是否已经运行，请运行以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get apiservices
</code></pre></div>
<p>如果资源指标 API 可用，则输出结果将包含对 <code>metrics.k8s.io</code> 的引用信息。</p>
<pre><code>NAME
v1beta1.metrics.k8s.io
</code></pre>
<h2 id=创建命名空间>创建命名空间</h2>
<p>创建一个命名空间，以便将本练习中创建的资源与集群的其余部分隔离。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace mem-example
</code></pre></div>
<h2 id=指定内存请求和限制>指定内存请求和限制</h2>
<p>要为容器指定内存请求，请在容器资源清单中包含 <code>resources：requests</code> 字段。
同理，要指定内存限制，请包含 <code>resources：limits</code>。</p>
<p>在本练习中，你将创建一个拥有一个容器的 Pod。
容器将会请求 100 MiB 内存，并且内存会被限制在 200 MiB 以内。
这是 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/resource/memory-request-limit.yaml download=pods/resource/memory-request-limit.yaml><code>pods/resource/memory-request-limit.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-memory-request-limit-yaml')" title="Copy pods/resource/memory-request-limit.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-memory-request-limit-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>配置文件的 <code>args</code> 部分提供了容器启动时的参数。
<code>"--vm-bytes", "150M"</code> 参数告知容器尝试分配 150 MiB 内存。</p>
<p>开始创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit.yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>验证 Pod 中的容器是否已运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>查看 Pod 相关的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>输出结果显示：该 Pod 中容器的内存请求为 100 MiB，内存限制为 200 MiB。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div>
<p>运行 <code>kubectl top</code> 命令，获取该 Pod 的指标数据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl top pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>输出结果显示：Pod 正在使用的内存大约为 162,900,000 字节，约为 150 MiB。
这大于 Pod 请求的 100 MiB，但在 Pod 限制的 200 MiB之内。</p>
<pre><code>NAME                        CPU(cores)   MEMORY(bytes)
memory-demo                 &lt;something&gt;  162856960
</code></pre>
<p>删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<h2 id=超过容器限制的内存>超过容器限制的内存</h2>
<p>当节点拥有足够的可用内存时，容器可以使用其请求的内存。
但是，容器不允许使用超过其限制的内存。
如果容器分配的内存超过其限制，该容器会成为被终止的候选容器。
如果容器继续消耗超出其限制的内存，则终止容器。
如果终止的容器可以被重启，则 kubelet 会重新启动它，就像其他任何类型的运行时失败一样。</p>
<p>在本练习中，你将创建一个 Pod，尝试分配超出其限制的内存。
这是一个 Pod 的配置文件，其拥有一个容器，该容器的内存请求为 50 MiB，内存限制为 100 MiB：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/resource/memory-request-limit-2.yaml download=pods/resource/memory-request-limit-2.yaml><code>pods/resource/memory-request-limit-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-memory-request-limit-2-yaml')" title="Copy pods/resource/memory-request-limit-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-memory-request-limit-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;250M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在配置文件的 <code>args</code> 部分中，你可以看到容器会尝试分配 250 MiB 内存，这远高于 100 MiB 的限制。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-2.yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>查看 Pod 相关的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>此时，容器可能正在运行或被杀死。重复前面的命令，直到容器被杀掉：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME            READY     STATUS      RESTARTS   AGE
memory-demo-2   0/1       OOMKilled   <span style=color:#666>1</span>          24s
</code></pre></div>
<p>获取容器更详细的状态信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-2 --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>输出结果显示：由于内存溢出（OOM），容器已被杀掉：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>lastState:
   terminated:
     containerID: docker://65183c1877aaec2e8427bc95609cc52677a454b56fcb24340dbd22917c23b10f
     exitCode: <span style=color:#666>137</span>
     finishedAt: 2017-06-20T20:52:19Z
     reason: OOMKilled
     startedAt: null
</code></pre></div>
<p>本练习中的容器可以被重启，所以 kubelet 会重启它。
多次运行下面的命令，可以看到容器在反复的被杀死和重启：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>输出结果显示：容器被杀掉、重启、再杀掉、再重启……：</p>
<pre><code>kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS      RESTARTS   AGE
memory-demo-2   0/1       OOMKilled   1          37s
</code></pre><pre><code>
kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-2   1/1       Running   2          40s
</code></pre>
<p>查看关于该 Pod 历史的详细信息：</p>
<pre><code>kubectl describe pod memory-demo-2 --namespace=mem-example
</code></pre>
<p>输出结果显示：该容器反复的在启动和失败：</p>
<pre><code>... Normal  Created   Created container with id 66a3a20aa7980e61be4922780bf9d24d1a1d8b7395c09861225b0eba1b1f8511
... Warning BackOff   Back-off restarting failed container
</code></pre>
<p>查看关于集群节点的详细信息：</p>
<pre><code>kubectl describe nodes
</code></pre>
<p>输出结果包含了一条练习中的容器由于内存溢出而被杀掉的记录：</p>
<pre><code>Warning OOMKilling Memory cgroup out of memory: Kill process 4481 (stress) score 1994 or sacrifice child
</code></pre>
<p>删除 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<h2 id=超过整个节点容量的内存>超过整个节点容量的内存</h2>
<p>内存请求和限制是与容器关联的，但将 Pod 视为具有内存请求和限制，也是很有用的。
Pod 的内存请求是 Pod 中所有容器的内存请求之和。
同理，Pod 的内存限制是 Pod 中所有容器的内存限制之和。</p>
<p>Pod 的调度基于请求。只有当节点拥有足够满足 Pod 内存请求的内存时，才会将 Pod 调度至节点上运行。</p>
<p>在本练习中，你将创建一个 Pod，其内存请求超过了你集群中的任意一个节点所拥有的内存。
这是该 Pod 的配置文件，其拥有一个请求 1000 GiB 内存的容器，这应该超过了你集群中任何节点的容量。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/resource/memory-request-limit-3.yaml download=pods/resource/memory-request-limit-3.yaml><code>pods/resource/memory-request-limit-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-memory-request-limit-3-yaml')" title="Copy pods/resource/memory-request-limit-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-memory-request-limit-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-3.yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>查看 Pod 状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>输出结果显示：Pod 处于 PENDING 状态。
这意味着，该 Pod 没有被调度至任何节点上运行，并且它会无限期的保持该状态：</p>
<pre><code>kubectl get pod memory-demo-3 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-3   0/1       Pending   0          25s
</code></pre>
<p>查看关于 Pod 的详细信息，包括事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<p>输出结果显示：由于节点内存不足，该容器无法被调度：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Events:
  ...  Reason            Message
       ------            -------
  ...  FailedScheduling  No nodes are available that match all of the following predicates:: Insufficient memory <span style=color:#666>(</span>3<span style=color:#666>)</span>.
</code></pre></div>
<h2 id=内存单位>内存单位</h2>
<p>内存资源的基本单位是字节（byte）。你可以使用这些后缀之一，将内存表示为
纯整数或定点整数：E、P、T、G、M、K、Ei、Pi、Ti、Gi、Mi、Ki。
例如，下面是一些近似相同的值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>128974848, 129e6, 129M , 123Mi
</code></pre></div>
<p>删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div>
<h2 id=如果你没有指定内存限制>如果你没有指定内存限制</h2>
<p>如果你没有为一个容器指定内存限制，则自动遵循以下情况之一：</p>
<ul>
<li>
<p>容器可无限制地使用内存。容器可以使用其所在节点所有的可用内存，
进而可能导致该节点调用 OOM Killer。
此外，如果发生 OOM Kill，没有资源限制的容器将被杀掉的可行性更大。</p>
</li>
<li>
<p>运行的容器所在命名空间有默认的内存限制，那么该容器会被自动分配默认限制。
集群管理员可用使用 <a href=/docs/reference/generated/kubernetes-api/v1.22/#limitrange-v1-core>LimitRange</a>
来指定默认的内存限制。</p>
</li>
</ul>
<h2 id=内存请求和限制的目的>内存请求和限制的目的</h2>
<p>通过为集群中运行的容器配置内存请求和限制，你可以有效利用集群节点上可用的内存资源。
通过将 Pod 的内存请求保持在较低水平，你可以更好地安排 Pod 调度。
通过让内存限制大于内存请求，你可以完成两件事：</p>
<ul>
<li>Pod 可以进行一些突发活动，从而更好的利用可用内存。</li>
<li>Pod 在突发活动期间，可使用的内存被限制为合理的数量。</li>
</ul>
<h2 id=清理>清理</h2>
<p>删除命名空间。下面的命令会删除你根据这个任务创建的所有 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace mem-example
</code></pre></div><h2 id=接下来>接下来</h2>
<h3 id=应用开发者扩展阅读>应用开发者扩展阅读</h3>
<ul>
<li>
<p><a href=/zh/docs/tasks/configure-pod-container/assign-cpu-resource/>为容器和 Pod 分配 CPU 资源</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/configure-pod-container/quality-service-pod/>配置 Pod 的服务质量</a></p>
</li>
</ul>
<h3 id=集群管理员扩展阅读>集群管理员扩展阅读</h3>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>为命名空间配置默认的内存请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>为命名空间配置默认的 CPU 请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>配置命名空间的最小和最大内存约束</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>配置命名空间的最小和最大 CPU 约束</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为命名空间配置内存和 CPU 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>配置命名空间下 Pod 总数</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/quota-api-object/>配置 API 对象配额</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-aa522472483f900008124a2809f2114b>2 - 为 Windows Pod 和容器配置 GMSA</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>本页展示如何为将运行在 Windows 节点上的 Pod 和容器配置
<a href=https://docs.microsoft.com/en-us/windows-server/security/group-managed-service-accounts/group-managed-service-accounts-overview>组管理的服务账号（Group Managed Service Accounts，GMSA）</a>。
组管理的服务账号是活动目录（Active Directory）的一种特殊类型，提供自动化的
密码管理、简化的服务主体名称（Service Principal Name，SPN）管理以及跨多个
服务器将管理操作委派给其他管理员等能力。</p>
<p>在 Kubernetes 环境中，GMSA 凭据规约配置为 Kubernetes 集群范围的自定义资源
（Custom Resources）形式。Windows Pod 以及各 Pod 中的每个容器可以配置为
使用 GMSA 来完成基于域（Domain）的操作（例如，Kerberos 身份认证），以便
与其他 Windows 服务相交互。自 Kubernetes 1.16 版本起，Docker 运行时为
Windows 负载支持 GMSA。</p>
<h2 id=准备开始>准备开始</h2>
<p>你需要一个 Kubernetes 集群，以及 <code>kubectl</code> 命令行工具，且工具必须已配置
为能够与你的集群通信。集群预期包含 Windows 工作节点。
本节讨论需要为每个集群执行一次的初始操作。</p>
<h3 id=安装-gmsacredentialspec-crd>安装 GMSACredentialSpec CRD</h3>
<p>你需要在集群上配置一个用于 GMSA 凭据规约资源的
<a href=/zh/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>(CRD)，
以便定义类型为 <code>GMSACredentialSpec</code> 的自定义资源。
首先下载 GMSA CRD <a href=https://github.com/kubernetes-sigs/windows-gmsa/blob/master/admission-webhook/deploy/gmsa-crd.yml>YAML</a>
并将其保存为 <code>gmsa-crd.yaml</code>。接下来执行 <code>kubectl apply -f gmsa-crd.yaml</code>
安装 CRD。</p>
<h3 id=安装-webhook-来验证-gmsa-用户>安装 Webhook 来验证 GMSA 用户</h3>
<p>你需要为 Kubernetes 集群配置两个 Webhook，在 Pod 或容器级别填充和检查
GMSA 凭据规约引用。</p>
<ol>
<li>
<p>一个修改模式（Mutating）的 Webhook，将对 GMSA 的引用（在 Pod 规约中体现为名字）
展开为完整凭据规约的 JSON 形式，并保存回 Pod 规约中。</p>
</li>
<li>
<p>一个验证模式（Validating）的 Webhook，确保对 GMSA 的所有引用都是已经授权
给 Pod 的服务账号使用的。</p>
</li>
</ol>
<p>安装以上 Webhook 及其相关联的对象需要执行以下步骤：</p>
<ol>
<li>
<p>创建一个证书密钥对（用于允许 Webhook 容器与集群通信）</p>
</li>
<li>
<p>安装一个包含如上证书的 Secret</p>
</li>
<li>
<p>创建一个包含核心 Webhook 逻辑的 Deployment</p>
</li>
<li>
<p>创建引用该 Deployment 的 Validating Webhook 和 Mutating Webhook 配置</p>
</li>
</ol>
<p>你可以使用<a href=https://github.com/kubernetes-sigs/windows-gmsa/blob/master/admission-webhook/deploy/deploy-gmsa-webhook.sh>这个脚本</a>
来部署和配置上述 GMSA Webhook 及相关联的对象。你还可以在运行脚本时设置 <code>--dry-run=server</code>
选项以便审查脚本将会对集群做出的变更。</p>
<p>脚本所使用的<a href=https://github.com/kubernetes-sigs/windows-gmsa/blob/master/admission-webhook/deploy/gmsa-webhook.yml.tpl>YAML 模板</a>
也可用于手动部署 Webhook 及相关联的对象，不过需要对其中的参数作适当替换。</p>
<h2 id=在活动目录中配置-gmsa-和-windows-节点>在活动目录中配置 GMSA 和 Windows 节点</h2>
<p>在配置 Kubernetes 中的 Pod 以使用 GMSA 之前，需要按
<a href=https://docs.microsoft.com/en-us/windows-server/security/group-managed-service-accounts/getting-started-with-group-managed-service-accounts#BKMK_Step1>Windows GMSA 文档</a>
中描述的那样先在活动目录中准备好期望的 GMSA。
Windows 工作节点（作为 Kubernetes 集群的一部分）需要被配置到活动目录中，以便
访问与期望的 GSMA 相关联的秘密凭据数据。这一操作的描述位于
<a href=https://docs.microsoft.com/en-us/windows-server/security/group-managed-service-accounts/getting-started-with-group-managed-service-accounts#to-add-member-hosts-using-the-set-adserviceaccount-cmdlet>Windows GMSA 文档</a>
中。</p>
<h2 id=创建-gmsa-凭据规约资源>创建 GMSA 凭据规约资源</h2>
<p>当（如前所述）安装了 GMSACredentialSpec CRD 之后，你就可以配置包含 GMSA 凭据
规约的自定义资源了。GMSA 凭据规约中并不包含秘密或敏感数据。
其中包含的信息主要用于容器运行时，便于后者向 Windows 描述容器所期望的 GMSA。
GMSA 凭据规约可以使用
<a href=https://github.com/kubernetes-sigs/windows-gmsa/tree/master/scripts/GenerateCredentialSpecResource.ps1>PowerShell 脚本</a>
以 YAML 格式生成。</p>
<p>下面是手动以 JSON 格式生成 GMSA 凭据规约并对其进行 YAML 转换的步骤：</p>
<ol>
<li>
<p>导入 CredentialSpec <a href=https://github.com/MicrosoftDocs/Virtualization-Documentation/blob/live/windows-server-container-tools/ServiceAccounts/CredentialSpec.psm1>模块</a>: <code>ipmo CredentialSpec.psm1</code></p>
</li>
<li>
<p>使用 <code>New-CredentialSpec</code> 来创建一个 JSON 格式的凭据规约。
要创建名为 <code>WebApp1</code> 的 GMSA 凭据规约，调用
<code>New-CredentialSpec -Name WebApp1 -AccountName WebApp1 -Domain $(Get-ADDomain -Current LocalComputer)</code>。</p>
</li>
<li>
<p>使用 <code>Get-CredentialSpec</code> 来显示 JSON 文件的路径。</p>
</li>
<li>
<p>将凭据规约从 JSON 格式转换为 YAML 格式，并添加必要的头部字段
<code>apiVersion</code>、<code>kind</code>、<code>metadata</code> 和 <code>credspec</code>，使其成为一个可以在
Kubernetes 中配置的 GMSACredentialSpec 自定义资源。</p>
</li>
</ol>
<p>下面的 YAML 配置描述的是一个名为 <code>gmsa-WebApp1</code> 的 GMSA 凭据规约：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>windows.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>GMSACredentialSpec<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gmsa-WebApp1 <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 这是随意起的一个名字，将用作引用</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>credspec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ActiveDirectoryConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>GroupManagedServiceAccounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>Name</span>:<span style=color:#bbb> </span>WebApp1  <span style=color:#bbb> </span><span style=color:#080;font-style:italic># GMSA 账号的用户名</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>Scope</span>:<span style=color:#bbb> </span>CONTOSO <span style=color:#bbb> </span><span style=color:#080;font-style:italic># NETBIOS 域名</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>Name</span>:<span style=color:#bbb> </span>WebApp1  <span style=color:#bbb> </span><span style=color:#080;font-style:italic># GMSA 账号的用户名</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>Scope</span>:<span style=color:#bbb> </span>contoso.com<span style=color:#bbb> </span><span style=color:#080;font-style:italic># DNS 域名</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>CmsPlugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- ActiveDirectory<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>DomainJoinConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>DnsName</span>:<span style=color:#bbb> </span>contoso.com <span style=color:#bbb> </span><span style=color:#080;font-style:italic># DNS 域名</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>DnsTreeName</span>:<span style=color:#bbb> </span>contoso.com<span style=color:#bbb> </span><span style=color:#080;font-style:italic># DNS 域名根</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>Guid</span>:<span style=color:#bbb> </span>244818ae-87ac-4fcd-92ec-e79e5252348a <span style=color:#bbb> </span><span style=color:#080;font-style:italic># GUID</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>MachineAccountName</span>:<span style=color:#bbb> </span>WebApp1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># GMSA 账号的用户名</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>NetBiosName</span>:<span style=color:#bbb> </span>CONTOSO <span style=color:#bbb> </span><span style=color:#080;font-style:italic># NETBIOS 域名</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>Sid</span>:<span style=color:#bbb> </span>S-1-5-21-2126449477-2524075714-3094792973<span style=color:#bbb> </span><span style=color:#080;font-style:italic># GMSA 的 SID</span><span style=color:#bbb>
</span></code></pre></div>
<p>上面的凭据规约资源可以保存为 <code>gmsa-Webapp1-credspec.yaml</code>，之后使用
<code>kubectl apply -f gmsa-Webapp1-credspec.yml</code> 应用到集群上。</p>
<h2 id=配置集群角色以启用对特定-gmsa-凭据规约的-rbac>配置集群角色以启用对特定 GMSA 凭据规约的 RBAC</h2>
<p>你需要为每个 GMSA 凭据规约资源定义集群角色。
该集群角色授权某主体（通常是一个服务账号）对特定的 GMSA 资源执行 <code>use</code> 动作。
下面的示例显示的是一个集群角色，对前文创建的凭据规约 <code>gmsa-WebApp1</code> 执行鉴权。
将此文件保存为 <code>gmsa-webapp1-role.yaml</code> 并执行 <code>kubectl apply -f gmsa-webapp1-role.yaml</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 创建集群角色读取凭据规约</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webapp1-role<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;windows.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;gmsacredentialspecs&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;use&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;gmsa-WebApp1&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<h2 id=将角色指派给要使用特定-gmsa-凭据规约的服务账号>将角色指派给要使用特定 GMSA 凭据规约的服务账号</h2>
<p>你需要将某个服务账号（Pod 配置所对应的那个）绑定到前文创建的集群角色上。
这一绑定操作实际上授予该服务账号使用所指定的 GMSA 凭据规约资源的访问权限。
下面显示的是一个绑定到集群角色 <code>webapp1-role</code> 上的 default 服务账号，使之
能够使用前面所创建的 <code>gmsa-WebApp1</code> 凭据规约资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-default-svc-account-read-on-gmsa-WebApp1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webapp1-role<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<h2 id=在-pod-规约中配置-gmsa-凭据规约引用>在 Pod 规约中配置 GMSA 凭据规约引用</h2>
<p>Pod 规约字段 <code>securityContext.windowsOptions.gmsaCredentialSpecName</code> 可用来
设置对指定 GMSA 凭据规约自定义资源的引用。
设置此引用将会配置 Pod 中的所有容器使用所给的 GMSA。
下面是一个 Pod 规约示例，其中包含了对 <code>gmsa-WebApp1</code> 凭据规约的引用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>gmsaCredentialSpecName</span>:<span style=color:#bbb> </span>gmsa-webapp1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></code></pre></div>
<p>Pod 中的各个容器也可以使用对应容器的 <code>securityContext.windowsOptions.gmsaCredentialSpecName</code>
字段来设置期望使用的 GMSA 凭据规约。
例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>gmsaCredentialSpecName</span>:<span style=color:#bbb> </span>gmsa-Webapp1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></code></pre></div>
<p>当 Pod 规约中填充了 GMSA 相关字段（如上所述），在集群中应用 Pod 规约时会依次
发生以下事件：</p>
<ol>
<li>
<p>Mutating Webhook 解析对 GMSA 凭据规约资源的引用，并将其全部展开，
得到 GMSA 凭据规约的实际内容。</p>
</li>
<li>
<p>Validating Webhook 确保与 Pod 相关联的服务账号有权在所给的 GMSA 凭据规约
上执行 <code>use</code> 动作。</p>
</li>
<li>
<p>容器运行时为每个 Windows 容器配置所指定的 GMSA 凭据规约，这样容器就可以以
活动目录中该 GMSA 所代表的身份来执行操作，使用该身份来访问域中的服务。</p>
</li>
</ol>
<h2 id=containerd>Containerd</h2>
<p>在 Windows Server 2019 上对 containerd 使用 GMSA，需要使用 Build 17763.1817（或更新的版本），
你可以安装补丁 <a href=https://support.microsoft.com/en-us/topic/march-9-2021-kb5000822-os-build-17763-1817-2eb6197f-e3b1-4f42-ab51-84345e063564>KB5000822</a>。</p>
<p>containerd 场景从 Pod 连接 SMB 共享的时候有一个已知问题：
配置了 GMSA 以后，无法通过主机名或者 FQDN 访问 SMB共享，但是通过 IP 地址访问没有问题。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell>ping adserver.ad.local
</code></pre></div>
<p>主机名可以被解析为 IPv4 地址，输出类似如下所示：</p>
<pre><code>Pinging adserver.ad.local [192.168.111.18] with 32 bytes of data:
Reply from 192.168.111.18: bytes=32 time=6ms TTL=124
Reply from 192.168.111.18: bytes=32 time=5ms TTL=124
Reply from 192.168.111.18: bytes=32 time=5ms TTL=124
Reply from 192.168.111.18: bytes=32 time=5ms TTL=124
</code></pre>
<p>但是，当尝试使用主机名浏览目录时:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=color:#a2f>cd </span>\\adserver.ad.local\test
</code></pre></div>
<p>你会看到一个错误，提示目标共享不存在:</p>
<pre><code>cd : Cannot find path '\\adserver.ad.local\test' because it does not exist.
At line:1 char:1
+ cd \\adserver.ad.local\test
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : ObjectNotFound: (\\adserver.ad.local\test:String) [Set-Location], ItemNotFoundException
    + FullyQualifiedErrorId : PathNotFound,Microsoft.PowerShell.Commands.SetLocationCommand
</code></pre>
<p>但是你会注意到，如果你改为使用其 IPv4 地址浏览共享，错误就会消失；例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=color:#a2f>cd </span>\\192.168.111.18\test
</code></pre></div>
<p>切换到共享中的目录后，你会看到类似于以下内容的提示：</p>
<pre><code>Microsoft.PowerShell.Core\FileSystem::\\192.168.111.18\test&gt;
</code></pre>
<p>要解决问题，你需要在节点上运行以下命令以添加所需的注册表项
<code>reg add "HKLM\SYSTEM\CurrentControlSet\Services\hns\State" /v EnableCompartmentNamespace /t REG_DWORD /d 1</code>。
此更改只会在新创建的 Pod 中生效，这意味着你必须重新创建任何需要访问 SMB 共享的正在运行的 Pod。</p>
<h2 id=故障排查>故障排查</h2>
<p>如果在你的环境中配置 GMSA 时遇到了困难，你可以采取若干步骤来排查可能的故障。</p>
<p>首先，确保 credspec 已传递给 Pod。为此，你需要先运行 <code>exec</code> 进入到你的一个 Pod 中并检查 <code>nltest.exe /parentdomain</code> 命令的输出。
在下面的例子中，Pod 未能正确地获得凭据规约：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell>kubectl exec -it <span style=color:#a2f>iis-auth</span>-7776966999-n5nzr powershell.exe
</code></pre></div>
<p><code>nltest.exe /parentdomain</code> 导致以下错误：</p>
<pre><code>Getting parent domain failed: Status = 1722 0x6ba RPC_S_SERVER_UNAVAILABLE
</code></pre>
<p>如果 Pod 未能正确获得凭据规约，则下一步就要检查与域之间的通信。
首先，从 Pod 内部快速执行一个 nslookup 操作，找到域根。</p>
<p>这一操作会告诉我们三件事情：</p>
<ol>
<li>Pod 能否访问域控制器（DC）</li>
<li>DC 能否访问 Pod</li>
<li>DNS 是否正常工作</li>
</ol>
<p>如果 DNS 和通信测试通过，接下来你需要检查是否 Pod 已经与域之间建立了
安全通信通道。要执行这一检查，你需要再次通过 <code>exec</code> 进入到你的 Pod 中
并执行 <code>nltest.exe /query</code> 命令。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell>nltest.exe /query
</code></pre></div>
<p>这告诉我们，由于某种原因，Pod 无法使用 credspec 中指定的帐户登录到域。
你可以尝试通过运行以下命令来修复安全通道：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell>nltest /sc_reset<span>:</span>domain.example
</code></pre></div>
<p>如果命令成功，你将看到类似以下内容的输出：</p>
<pre><code>Flags: 30 HAS_IP  HAS_TIMESERV
Trusted DC Name \\dc10.domain.example
Trusted DC Connection Status Status = 0 0x0 NERR_Success
The command completed successfully
</code></pre>
<p>如果以上命令修复了错误，你可以通过将以下生命周期回调添加到你的 Pod 规约中来自动执行该步骤。
如果这些操作没有修复错误，你将需要再次检查你的 credspec 并确认它是正确和完整的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.domain.example/iis-auth:1809v1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>postStart</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;powershell.exe&#34;</span>,<span style=color:#b44>&#34;-command&#34;</span>,<span style=color:#b44>&#34;do { Restart-Service -Name netlogon } while ( $($Result = (nltest.exe /query); if ($Result -like &#39;*0x0 NERR_Success*&#39;) {return $true} else {return $false}) -eq $false)&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></code></pre></div>
<p>如果你向你的 Pod 规约中添加如上所示的 <code>lifecycle</code> 节，则 Pod 会自动执行所
列举的命令来重启 <code>netlogon</code> 服务，直到 <code>nltest.exe /query</code>
命令返回时没有错误信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5da7517bee8a8807431d9fc65263b39>3 - 为 Windows 的 Pod 和容器配置 RunAsUserName</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>本页展示如何为运行为在 Windows 节点上运行的 Pod 和容器配置 <code>RunAsUserName</code> 。
大致相当于 Linux 上的 <code>runAsUser</code>，允许在容器中以与默认值不同的用户名运行应用。</p>
<h2 id=准备开始>准备开始</h2>
<p>你必须有一个 Kubernetes 集群，并且 kubectl 必须能和集群通信。
集群应该要有 Windows 工作节点，将在其中调度运行 Windows 工作负载的 pod 和容器。</p>
<h2 id=为-pod-设置-username>为 Pod 设置 Username</h2>
<p>要指定运行 Pod 容器时所使用的用户名，请在 Pod 声明中包含 <code>securityContext</code>
(<a href=/docs/reference/generated/kubernetes-api/v1.22/#podsecuritycontext-v1-core>PodSecurityContext</a>) 字段，
并在其内部包含 <code>windowsOptions</code>
(<a href=/docs/reference/generated/kubernetes-api/v1.22/#windowssecuritycontextoptions-v1-core>WindowsSecurityContextOptions</a>)
字段的 <code>runAsUserName</code> 字段。</p>
<p>你为 Pod 指定的 Windows SecurityContext 选项适用于该 Pod 中（包括 init 容器）的所有容器。</p>
<p>这儿有一个已经设置了 <code>runAsUserName</code> 字段的 Windows Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/windows/run-as-username-pod.yaml download=windows/run-as-username-pod.yaml><code>windows/run-as-username-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('windows-run-as-username-pod-yaml')" title="Copy windows/run-as-username-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=windows-run-as-username-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-pod-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runAsUserName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ContainerUser&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-demo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore:ltsc2019<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;ping&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-t&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;localhost&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/windows/run-as-username-pod.yaml
</code></pre></div>
<p>验证 Pod 容器是否在运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod run-as-username-pod-demo
</code></pre></div>
<p>获取该容器的 shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it run-as-username-pod-demo -- powershell
</code></pre></div>
<p>检查运行 shell 的用户的用户名是否正确：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>echo </span><span style=color:#b8860b>$env:USERNAME</span>
</code></pre></div>
<p>输出结果应该是这样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ContainerUser
</code></pre></div>
<h2 id=为容器设置-username>为容器设置 Username</h2>
<p>要指定运行容器时所使用的用户名，请在容器清单中包含 <code>securityContext</code>
(<a href=/zh/docs/reference/generated/kubernetes-api/v1.22/#securitycontext-v1-core>SecurityContext</a>)
字段，并在其内部包含 <code>windowsOptions</code>
（<a href=/zh/docs/reference/generated/kubernetes-api/v1.22/#windowssecuritycontextoptions-v1-core>WindowsSecurityContextOptions</a>）
字段的 <code>runAsUserName</code> 字段。</p>
<p>你为容器指定的 Windows SecurityContext 选项仅适用于该容器，并且它会覆盖 Pod 级别设置。</p>
<p>这里有一个 Pod 的配置文件，其中只有一个容器，并且在 Pod 级别和容器级别都设置了 <code>runAsUserName</code>：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/windows/run-as-username-container.yaml download=windows/run-as-username-container.yaml><code>windows/run-as-username-container.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('windows-run-as-username-container-yaml')" title="Copy windows/run-as-username-container.yaml to clipboard">
</img>
</div>
<div class=includecode id=windows-run-as-username-container-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-container-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runAsUserName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ContainerUser&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-demo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore:ltsc2019<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;ping&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-t&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;localhost&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>runAsUserName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ContainerAdministrator&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/windows/run-as-username-container.yaml
</code></pre></div>
<p>验证 Pod 容器是否在运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod run-as-username-container-demo
</code></pre></div>
<p>获取该容器的 shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it run-as-username-container-demo -- powershell
</code></pre></div>
<p>检查运行 shell 的用户的用户名是否正确（应该是容器级别设置的那个）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>echo </span><span style=color:#b8860b>$env:USERNAME</span>
</code></pre></div>
<p>输出结果应该是这样：</p>
<pre><code>ContainerAdministrator
</code></pre>
<h2 id=windows-username-的局限性>Windows Username 的局限性</h2>
<p>想要使用此功能，在 <code>runAsUserName</code> 字段中设置的值必须是有效的用户名。
它必须是 <code>DOMAIN\USER</code> 这种格式，其中 <code>DOMAIN\</code> 是可选的。
Windows 用户名不区分大小写。此外，关于 <code>DOMAIN</code> 和 <code>USER</code> 还有一些限制：</p>
<ul>
<li><code>runAsUserName</code> 字段不能为空，并且不能包含控制字符（ASCII 值：<code>0x00-0x1F</code>、<code>0x7F</code>）</li>
<li><code>DOMAIN</code> 必须是 NetBios 名称或 DNS 名称，每种名称都有各自的局限性：
<ul>
<li>NetBios 名称：最多 15 个字符，不能以 <code>.</code>（点）开头，并且不能包含以下字符：<code>\ / : * ? " &lt; > |</code></li>
<li>DNS 名称：最多 255 个字符，只能包含字母、数字、点和中划线，并且不能以 <code>.</code>（点）或 <code>-</code>（中划线）开头和结尾。</li>
</ul>
</li>
<li><code>USER</code> 最多不超过 20 个字符，不能 <strong>只</strong> 包含点或空格，并且不能包含以下字符：<code>" / \ [ ] : ; | = , + * ? &lt; > @</code></li>
</ul>
<p><code>runAsUserName</code> 字段接受的值的一些示例：<code>ContainerAdministrator</code>、<code>ContainerUser</code>、
<code>NT AUTHORITY\NETWORK SERVICE</code>、<code>NT AUTHORITY\LOCAL SERVICE</code>。</p>
<p>关于这些限制的更多信息，可以查看<a href=https://support.microsoft.com/en-us/help/909264/naming-conventions-in-active-directory-for-computers-domains-sites-and>这里</a>和<a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.localaccounts/new-localuser?view=powershell-5.1">这里</a>。</p>
<h2 id=接下来>接下来</h2>
<ul>
<li><a href=/zh/docs/setup/production-environment/windows/user-guide-windows-containers/>Kubernetes 中调度 Windows 容器的指南</a></li>
<li><a href=/zh/docs/setup/production-environment/windows/user-guide-windows-containers/#managing-workload-identity-with-group-managed-service-accounts>使用组托管服务帐户（GMSA）管理工作负载身份</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/configure-gmsa/>Windows 下 pod 和容器的 GMSA 配置</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8555af270ae7122cc0464bab3f5d1609>4 - 为容器和 Pods 分配 CPU 资源</h1>
<p>本页面展示如何为容器设置 CPU <em>request（请求）</em> 和 CPU <em>limit（限制）</em>。
容器使用的 CPU 不能超过所配置的限制。
如果系统有空闲的 CPU 时间，则可以保证给容器分配其所请求数量的 CPU 资源。</p>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<p>集群中的每个节点必须至少有 1 个 CPU 可用才能运行本任务中的示例。</p>
<p>本页的一些步骤要求你在集群中运行
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a>
服务。如果你的集群中已经有正在运行的 metrics-server 服务，可以跳过这些步骤。</p>
<p>如果你正在运行<a class=glossary-tooltip title="Minikube 是用来在本地运行 Kubernetes 的一种工具。" data-toggle=tooltip data-placement=top href=/docs/getting-started-guides/minikube/ target=_blank aria-label=Minikube>Minikube</a>，请运行以下命令启用 metrics-server：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube addons <span style=color:#a2f>enable</span> metrics-server
</code></pre></div>
<p>查看 metrics-server（或者其他资源度量 API <code>metrics.k8s.io</code> 服务提供者）是否正在运行，
请键入以下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get apiservices
</code></pre></div>
<p>如果资源指标 API 可用，则会输出将包含一个对 <code>metrics.k8s.io</code> 的引用。</p>
<pre><code>NAME
v1beta1.metrics.k8s.io
</code></pre>
<h2 id=创建一个名字空间>创建一个名字空间</h2>
<p>创建一个<a class=glossary-tooltip title="名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a>，以便将
本练习中创建的资源与集群的其余部分资源隔离。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace cpu-example
</code></pre></div>
<h2 id=指定-cpu-请求和-cpu-限制>指定 CPU 请求和 CPU 限制</h2>
<p>要为容器指定 CPU 请求，请在容器资源清单中包含 <code>resources: requests</code> 字段。
要指定 CPU 限制，请包含 <code>resources:limits</code>。</p>
<p>在本练习中，你将创建一个具有一个容器的 Pod。容器将会请求 0.5 个 CPU，而且最多限制使用 1 个 CPU。
这是 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/resource/cpu-request-limit.yaml download=pods/resource/cpu-request-limit.yaml><code>pods/resource/cpu-request-limit.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-cpu-request-limit-yaml')" title="Copy pods/resource/cpu-request-limit.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-cpu-request-limit-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cpu-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0.5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -cpus<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>配置文件的 <code>args</code> 部分提供了容器启动时的参数。
<code>-cpus "2"</code> 参数告诉容器尝试使用 2 个 CPU。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/cpu-request-limit.yaml --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<p>验证所创建的 Pod 处于 Running 状态</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<p>查看显示关于 Pod 的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod cpu-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<p>输出显示 Pod 中的一个容器的 CPU 请求为 500 milli CPU，并且 CPU 限制为 1 个 CPU。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>kubectl top</code> 命令来获取该 Pod 的度量值数据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl top pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<p>此示例输出显示 Pod 使用的是 974 milliCPU，即略低于 Pod 配置中指定的 1 个 CPU 的限制。</p>
<pre><code>NAME                        CPU(cores)   MEMORY(bytes)
cpu-demo                    974m         &lt;something&gt;
</code></pre>
<p>回想一下，通过设置 <code>-cpu "2"</code>，你将容器配置为尝试使用 2 个 CPU，
但是容器只被允许使用大约 1 个 CPU。
容器的 CPU 用量受到限制，因为该容器正尝试使用超出其限制的 CPU 资源。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> CPU 使用率低于 1.0 的另一种可能的解释是，节点可能没有足够的 CPU 资源可用。
回想一下，此练习的先决条件需要你的节点至少具有 1 个 CPU 可用。
如果你的容器在只有 1 个 CPU 的节点上运行，则容器无论为容器指定的 CPU 限制如何，
都不能使用超过 1 个 CPU。
</div>
<h2 id=cpu-units>CPU 单位 </h2>
<p>CPU 资源以 <em>CPU</em> 单位度量。Kubernetes 中的一个 CPU 等同于：</p>
<ul>
<li>1 个 AWS vCPU</li>
<li>1 个 GCP核心</li>
<li>1 个 Azure vCore</li>
<li>裸机上具有超线程能力的英特尔处理器上的 1 个超线程</li>
</ul>
<p>小数值是可以使用的。一个请求 0.5 CPU 的容器保证会获得请求 1 个 CPU 的容器的 CPU 的一半。
你可以使用后缀 <code>m</code> 表示毫。例如 <code>100m</code> CPU、100 milliCPU 和 0.1 CPU 都相同。
精度不能超过 1m。</p>
<p>CPU 请求只能使用绝对数量，而不是相对数量。0.1 在单核、双核或 48 核计算机上的 CPU 数量值是一样的。</p>
<p>删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<h2 id=设置超过节点能力的-cpu-请求>设置超过节点能力的 CPU 请求</h2>
<p>CPU 请求和限制与都与容器相关，但是我们可以考虑一下 Pod 具有对应的 CPU 请求和限制这样的场景。
Pod 对 CPU 用量的请求等于 Pod 中所有容器的请求数量之和。
同样，Pod 的 CPU 资源限制等于 Pod 中所有容器 CPU 资源限制数之和。</p>
<p>Pod 调度是基于资源请求值来进行的。
仅在某节点具有足够的 CPU 资源来满足 Pod CPU 请求时，Pod 将会在对应节点上运行：</p>
<p>在本练习中，你将创建一个 Pod，该 Pod 的 CPU 请求对于集群中任何节点的容量而言都会过大。
下面是 Pod 的配置文件，其中有一个容器。容器请求 100 个 CPU，这可能会超出集群中任何节点的容量。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/resource/cpu-request-limit-2.yaml download=pods/resource/cpu-request-limit-2.yaml><code>pods/resource/cpu-request-limit-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-cpu-request-limit-2-yaml')" title="Copy pods/resource/cpu-request-limit-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-cpu-request-limit-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cpu-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-ctr-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -cpus<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/cpu-request-limit-2.yaml --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<p>查看该 Pod 的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<p>输出显示 Pod 状态为 Pending。也就是说，Pod 未被调度到任何节点上运行，
并且 Pod 将无限期地处于 Pending 状态：</p>
<pre><code>NAME         READY     STATUS    RESTARTS   AGE
cpu-demo-2   0/1       Pending   0          7m
</code></pre>
<p>查看有关 Pod 的详细信息，包含事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<p>输出显示由于节点上的 CPU 资源不足，无法调度容器：</p>
<pre><code>Events:
  Reason                        Message
  ------                        -------
  FailedScheduling      No nodes are available that match all of the following predicates:: Insufficient cpu (3).
</code></pre>
<p>删除你的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div>
<h2 id=如果不指定-cpu-限制>如果不指定 CPU 限制</h2>
<p>如果你没有为容器指定 CPU 限制，则会发生以下情况之一：</p>
<ul>
<li>
<p>容器在可以使用的 CPU 资源上没有上限。因而可以使用所在节点上所有的可用 CPU 资源。</p>
</li>
<li>
<p>容器在具有默认 CPU 限制的名字空间中运行，系统会自动为容器设置默认限制。
集群管理员可以使用
<a href=/docs/reference/generated/kubernetes-api/v1.22/#limitrange-v1-core/>LimitRange</a>
指定 CPU 限制的默认值。</p>
</li>
</ul>
<h2 id=如果你设置了-cpu-限制但未设置-cpu-请求>如果你设置了 CPU 限制但未设置 CPU 请求</h2>
<p>如果你为容器指定了 CPU 限制值但未为其设置 CPU 请求，Kubernetes 会自动为其
设置与 CPU 限制相同的 CPU 请求值。类似的，如果容器设置了内存限制值但未设置
内存请求值，Kubernetes 也会为其设置与内存限制值相同的内存请求。</p>
<h2 id=cpu-请求和限制的初衷>CPU 请求和限制的初衷</h2>
<p>通过配置你的集群中运行的容器的 CPU 请求和限制，你可以有效利用集群上可用的 CPU 资源。
通过将 Pod CPU 请求保持在较低水平，可以使 Pod 更有机会被调度。
通过使 CPU 限制大于 CPU 请求，你可以完成两件事：</p>
<ul>
<li>Pod 可能会有突发性的活动，它可以利用碰巧可用的 CPU 资源。</li>
<li>Pod 在突发负载期间可以使用的 CPU 资源数量仍被限制为合理的数量。</li>
</ul>
<h2 id=清理>清理</h2>
<p>删除名称空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace cpu-example
</code></pre></div><h2 id=接下来>接下来</h2>
<h3 id=针对应用开发者>针对应用开发者</h3>
<ul>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-memory-resource/>将内存资源分配给容器和 Pod</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/quality-service-pod/>配置 Pod 服务质量</a></li>
</ul>
<h3 id=针对集群管理员>针对集群管理员</h3>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>配置名称空间的默认内存请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>为名字空间配置默认 CPU 请求和限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster//manage-resources/memory-constraint-namespace/>为名字空间配置最小和最大内存限制</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>为名字空间配置最小和最大 CPU 约束</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为名字空间配置内存和 CPU 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>为名字空间配置 Pod 配额</a></li>
<li><a href=/zh/docs/tasks/administer-cluster/quota-api-object/>配置 API 对象的配额</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-904cea8c8efd5c0d33adbfe579ec2dd2>5 - 配置 Pod 的服务质量</h1>
<p>本页介绍怎样配置 Pod 让其获得特定的服务质量（QoS）类。Kubernetes 使用 QoS 类来决定 Pod 的调度和驱逐策略。</p>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<h2 id=qos-classes>QoS 类 </h2>
<p>Kubernetes 创建 Pod 时就给它指定了下列一种 QoS 类：</p>
<ul>
<li>Guaranteed</li>
<li>Burstable</li>
<li>BestEffort</li>
</ul>
<h2 id=创建命名空间>创建命名空间</h2>
<p>创建一个命名空间，以便将本练习所创建的资源与集群的其余资源相隔离。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace qos-example
</code></pre></div>
<h2 id=创建一个-qos-类为-guaranteed-的-pod>创建一个 QoS 类为 Guaranteed 的 Pod</h2>
<p>对于 QoS 类为 Guaranteed 的 Pod：</p>
<ul>
<li>Pod 中的每个容器都必须指定内存限制和内存请求。</li>
<li>对于 Pod 中的每个容器，内存限制必须等于内存请求。</li>
<li>Pod 中的每个容器都必须指定 CPU 限制和 CPU 请求。</li>
<li>对于 Pod 中的每个容器，CPU 限制必须等于 CPU 请求。</li>
</ul>
<p>这些限制同样适用于初始化容器和应用程序容器。</p>
<p>下面是包含一个容器的 Pod 配置文件。
容器设置了内存请求和内存限制，值都是 200 MiB。
容器设置了 CPU 请求和 CPU 限制，值都是 700 milliCPU：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/qos/qos-pod.yaml download=pods/qos/qos-pod.yaml><code>pods/qos/qos-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-yaml')" title="Copy pods/qos/qos-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/qos/qos-pod.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<p>查看 Pod 详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>结果表明 Kubernetes 为 Pod 配置的 QoS 类为 Guaranteed。
结果也确认了 Pod 容器设置了与内存限制匹配的内存请求，设置了与 CPU 限制匹配的 CPU 请求。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Guaranteed<span style=color:#bbb>
</span></code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 如果容器指定了自己的内存限制，但没有指定内存请求，Kubernetes 会自动为它指定与内存限制匹配的内存请求。
同样，如果容器指定了自己的 CPU 限制，但没有指定 CPU 请求，Kubernetes 会自动为它指定与 CPU 限制匹配的 CPU 请求。
</div>
<p>删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<h2 id=创建一个-qos-类为-burstable-的-pod>创建一个 QoS 类为 Burstable 的 Pod</h2>
<p>如果满足下面条件，将会指定 Pod 的 QoS 类为 Burstable：</p>
<ul>
<li>Pod 不符合 Guaranteed QoS 类的标准。</li>
<li>Pod 中至少一个容器具有内存或 CPU 请求。</li>
</ul>
<p>下面是包含一个容器的 Pod 配置文件。
容器设置了内存限制 200 MiB 和内存请求 100 MiB。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/qos/qos-pod-2.yaml download=pods/qos/qos-pod-2.yaml><code>pods/qos/qos-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-2-yaml')" title="Copy pods/qos/qos-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/qos/qos-pod-2.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<p>查看 Pod 详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>结果表明 Kubernetes 为 Pod 配置的 QoS 类为 Burstable。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></code></pre></div>
<p>删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<h2 id=创建一个-qos-类为-besteffort-的-pod>创建一个 QoS 类为 BestEffort 的 Pod</h2>
<p>对于 QoS 类为 BestEffort 的 Pod，Pod 中的容器必须没有设置内存和 CPU 限制或请求。</p>
<p>下面是包含一个容器的 Pod 配置文件。
容器没有设置内存和 CPU 限制或请求。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/qos/qos-pod-3.yaml download=pods/qos/qos-pod-3.yaml><code>pods/qos/qos-pod-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-3-yaml')" title="Copy pods/qos/qos-pod-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/qos/qos-pod-3.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<p>查看 Pod 详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>结果表明 Kubernetes 为 Pod 配置的 QoS 类为 BestEffort。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>BestEffort<span style=color:#bbb>
</span></code></pre></div>
<p>删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<h2 id=创建包含两个容器的-pod>创建包含两个容器的 Pod</h2>
<p>下面是包含两个容器的 Pod 配置文件。
一个容器指定了内存请求 200 MiB。
另外一个容器没有指定任何请求和限制。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/qos/qos-pod-4.yaml download=pods/qos/qos-pod-4.yaml><code>pods/qos/qos-pod-4.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-4-yaml')" title="Copy pods/qos/qos-pod-4.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-4-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>注意此 Pod 满足 Burstable QoS 类的标准。
也就是说它不满足 Guaranteed QoS 类标准，因为它的一个容器设有内存请求。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/qos/qos-pod-4.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<p>查看 Pod 详情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>结果表明 Kubernetes 为 Pod 配置的 QoS 类为 Burstable：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></code></pre></div>
<p>删除 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example
</code></pre></div>
<h2 id=环境清理>环境清理</h2>
<p>删除命名空间：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace qos-example
</code></pre></div><h2 id=接下来>接下来</h2>
<h3 id=应用开发者参考>应用开发者参考</h3>
<ul>
<li>
<p><a href=/zh/docs/tasks/configure-pod-container/assign-memory-resource/>为 Pod 和容器分配内存资源</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/configure-pod-container/assign-cpu-resource/>为 Pod 和容器分配 CPU 资源</a></p>
</li>
</ul>
<h3 id=集群管理员参考>集群管理员参考</h3>
<ul>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>为命名空间配置默认的内存请求和限制</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace>为命名空间配置默认的 CPU 请求和限制</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>为命名空间配置最小和最大内存限制</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>为命名空间配置最小和最大 CPU 限制</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为命名空间配置内存和 CPU 配额</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>为命名空间配置 Pod 配额</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/quota-api-object/>为 API 对象配置配额</a></p>
</li>
<li>
<p><a href=/zh/docs/tasks/administer-cluster/topology-manager/>控制节点上的拓扑管理策略</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4219ac6ab56a3b88d20305083d57d03c>6 - 为容器分派扩展资源</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<p>本文介绍如何为容器指定扩展资源。</p>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<p>在你开始此练习前，请先练习
<a href=/zh/docs/tasks/administer-cluster/extended-resource-node/>为节点广播扩展资源</a>。
在那个练习中将配置你的一个节点来广播 dongle 资源。</p>
<h2 id=给-pod-分派扩展资源>给 Pod 分派扩展资源</h2>
<p>要请求扩展资源，需要在你的容器清单中包括 <code>resources:requests</code> 字段。
扩展资源可以使用任何完全限定名称，只是不能使用 <code>*.kubernetes.io/</code>。
有效的扩展资源名的格式为 <code>example.com/foo</code>，其中 <code>example.com</code> 应被替换为
你的组织的域名，而 <code>foo</code> 则是描述性的资源名称。</p>
<p>下面是包含一个容器的 Pod 配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/resource/extended-resource-pod.yaml download=pods/resource/extended-resource-pod.yaml><code>pods/resource/extended-resource-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-extended-resource-pod-yaml')" title="Copy pods/resource/extended-resource-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-extended-resource-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在配置文件中，你可以看到容器请求了 3 个 dongles。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/extended-resource-pod.yaml
</code></pre></div>
<p>检查 Pod 是否运行正常：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod extended-resource-demo
</code></pre></div>
<p>描述 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod extended-resource-demo
</code></pre></div>
<p>输出结果显示 dongle 请求如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>Requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
<h2 id=尝试创建第二个-pod>尝试创建第二个 Pod</h2>
<p>下面是包含一个容器的 Pod 配置文件，容器请求了 2 个 dongles。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/resource/extended-resource-pod-2.yaml download=pods/resource/extended-resource-pod-2.yaml><code>pods/resource/extended-resource-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-extended-resource-pod-2-yaml')" title="Copy pods/resource/extended-resource-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-extended-resource-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Kubernetes 将不能满足 2 个 dongles 的请求，因为第一个 Pod 已经使用了 4 个可用 dongles 中的 3 个。</p>
<p>尝试创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/extended-resource-pod-2.yaml
</code></pre></div>
<p>描述 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod extended-resource-demo-2
</code></pre></div>
<p>输出结果表明 Pod 不能被调度，因为没有一个节点上存在两个可用的 dongles。</p>
<pre><code>Conditions:
  Type    Status
  PodScheduled  False
...
Events:
  ...
  ... Warning   FailedScheduling  pod (extended-resource-demo-2) failed to fit in any node
fit failure summary on nodes : Insufficient example.com/dongle (1)
</code></pre>
<p>查看 Pod 的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod extended-resource-demo-2
</code></pre></div>
<p>输出结果表明 Pod 虽然被创建了，但没有被调度到节点上正常运行。Pod 的状态为 Pending：</p>
<pre><code>NAME                       READY     STATUS    RESTARTS   AGE
extended-resource-demo-2   0/1       Pending   0          6m
</code></pre>
<h2 id=清理>清理</h2>
<p>删除本练习中创建的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod extended-resource-demo
kubectl delete pod extended-resource-demo-2
</code></pre></div><h2 id=接下来>接下来</h2>
<h2 id=应用开发者参考>应用开发者参考</h2>
<ul>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-memory-resource/>为容器和 Pod 分配内存资源</a></li>
<li><a href=/zh/docs/tasks/configure-pod-container/assign-cpu-resource/>为容器和 Pod 分配 CPU 资源</a></li>
</ul>
<h3 id=集群管理员参考>集群管理员参考</h3>
<ul>
<li><a href=/zh/docs/tasks/administer-cluster/extended-resource-node/>为节点广播扩展资源</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-484833fb880d1e179cc2965d15f84da5>7 - 配置 Pod 以使用卷进行存储</h1>
<p>此页面展示了如何配置 Pod 以使用卷进行存储。</p>
<p>只要容器存在，容器的文件系统就会存在，因此当一个容器终止并重新启动，对该容器的文件系统改动将丢失。
对于独立于容器的持久化存储，你可以使用<a href=/zh/docs/concepts/storage/volumes/>卷</a>。
这对于有状态应用程序尤为重要，例如键值存储（如 Redis）和数据库。</p>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<h2 id=configure-a-volume-for-a-pod>为 Pod 配置卷 </h2>
<p>在本练习中，你将创建一个运行 Pod，该 Pod 仅运行一个容器并拥有一个类型为
<a href=/zh/docs/concepts/storage/volumes/#emptydir>emptyDir</a> 的卷，
在整个 Pod 生命周期中一直存在，即使 Pod 中的容器被终止和重启。以下是 Pod 的配置：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/storage/redis.yaml download=pods/storage/redis.yaml><code>pods/storage/redis.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-redis-yaml')" title="Copy pods/storage/redis.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-redis-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/data/redis<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>创建 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/storage/redis.yaml
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>验证 Pod 中的容器是否正在运行，然后留意 Pod 的更改：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod redis --watch
</code></pre></div><p>输出如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      READY     STATUS    RESTARTS   AGE
redis     1/1       Running   <span style=color:#666>0</span>          13s
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>在另一个终端，用 shell 连接正在运行的容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>在你的 Shell中，切换到 <code>/data/redis</code> 目录下，然后创建一个文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data# <span style=color:#a2f>cd</span> /data/redis/
root@redis:/data/redis# <span style=color:#a2f>echo</span> Hello &gt; test-file
</code></pre></div></li>
</ol>
<ol start=5>
<li>
<p>在你的 Shell 中，列出正在运行的进程：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data/redis# apt-get update
root@redis:/data/redis# apt-get install procps
root@redis:/data/redis# ps aux
</code></pre></div><p>输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
redis        <span style=color:#666>1</span>  0.1  0.1  <span style=color:#666>33308</span>  <span style=color:#666>3828</span> ?        Ssl  00:46   0:00 redis-server *:6379
root        <span style=color:#666>12</span>  0.0  0.0  <span style=color:#666>20228</span>  <span style=color:#666>3020</span> ?        Ss   00:47   0:00 /bin/bash
root        <span style=color:#666>15</span>  0.0  0.0  <span style=color:#666>17500</span>  <span style=color:#666>2072</span> ?        R+   00:48   0:00 ps aux
</code></pre></div></li>
</ol>
<ol start=6>
<li>
<p>在你的 Shell 中，结束 Redis 进程：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data/redis# <span style=color:#a2f>kill</span> &lt;pid&gt;
</code></pre></div><p>其中 <code>&lt;pid></code> 是 Redis 进程的 ID (PID)。</p>
</li>
</ol>
<ol start=7>
<li>
<p>在你原先终端中，留意 Redis Pod 的更改。最终你将会看到和下面类似的输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      READY     STATUS     RESTARTS   AGE
redis     1/1       Running    <span style=color:#666>0</span>          13s
redis     0/1       Completed  <span style=color:#666>0</span>         6m
redis     1/1       Running    <span style=color:#666>1</span>         6m
</code></pre></div></li>
</ol>
<p>此时，容器已经终止并重新启动。这是因为 Redis Pod 的
<a href=/docs/reference/generated/kubernetes-api/v1.22/#podspec-v1-core>restartPolicy</a>
为 <code>Always</code>。</p>
<ol>
<li>
<p>用 Shell 进入重新启动的容器中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>在你的 Shell 中，进入到 <code>/data/redis</code> 目录下，并确认 <code>test-file</code> 文件是否仍然存在。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data/redis# <span style=color:#a2f>cd</span> /data/redis/
root@redis:/data/redis# ls
test-file
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>删除为此练习所创建的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod redis
</code></pre></div></li>
</ol>
<h2 id=接下来>接下来</h2>
<ul>
<li>参阅 <a href=/docs/reference/generated/kubernetes-api/v1.22/#volume-v1-core>Volume</a>。</li>
<li>参阅 <a href=/docs/reference/generated/kubernetes-api/v1.22/#pod-v1-core>Pod</a>。</li>
<li>除了 <code>emptyDir</code> 提供的本地磁盘存储外，Kubernetes 还支持许多不同的网络附加存储解决方案，
包括 GCE 上的 PD 和 EC2 上的 EBS，它们是关键数据的首选，并将处理节点上的一些细节，
例如安装和卸载设备。了解更多详情请参阅<a href=/zh/docs/concepts/storage/volumes/>卷</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-528d2422215cb9632b7b45e886b023b5>8 - 配置 Pod 以使用 PersistentVolume 作为存储</h1>
<p>本文介绍如何配置 Pod 使用
<a class=glossary-tooltip title=声明在持久卷中定义的存储资源，以便可以将其挂载为容器中的卷。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PersistentVolumeClaim>PersistentVolumeClaim</a>
作为存储。
以下是该过程的总结：</p>
<ol>
<li>
<p>你作为集群管理员创建由物理存储支持的 PersistentVolume。你不会将卷与任何 Pod 关联。</p>
</li>
<li>
<p>你现在以开发人员或者集群用户的角色创建一个 PersistentVolumeClaim，
它将自动绑定到合适的 PersistentVolume。</p>
</li>
<li>
<p>你创建一个使用 PersistentVolumeClaim 作为存储的 Pod。</p>
</li>
</ol>
<h2 id=准备开始>准备开始</h2>
<ul>
<li>你需要一个包含单个节点的 Kubernetes 集群，并且必须配置 kubectl 命令行工具以便与集群交互。
如果还没有单节点集群，可以使用
<a href=https://minikube.sigs.k8s.io/docs/>Minikube</a> 创建一个。
.</li>
<li>熟悉<a href=/zh/docs/concepts/storage/persistent-volumes/>持久卷</a>中的材料。</li>
</ul>
<h2 id=在你的节点上创建一个-index-html-文件>在你的节点上创建一个 index.html 文件</h2>
<p>打开集群中节点的一个 Shell。
如何打开 Shell 取决于集群的设置。
例如，如果你正在使用 Minikube，那么可以通过输入 <code>minikube ssh</code> 来打开节点的 Shell。</p>
<p>在 Shell 中，创建一个 <code>/mnt/data</code> 目录：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 这里假定你的节点使用 &#34;sudo&#34; 来以超级用户角色执行命令</span>
sudo mkdir /mnt/data
</code></pre></div>
<p>在 <code>/mnt/data</code> 目录中创建一个 index.html 文件：</p>
<pre><code># 这里再次假定你的节点使用 &quot;sudo&quot; 来以超级用户角色执行命令
sudo sh -c &quot;echo 'Hello from Kubernetes storage' &gt; /mnt/data/index.html&quot;
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 如果你的节点使用某工具而不是 <code>sudo</code> 来完成超级用户访问，你可以将上述命令
中的 <code>sudo</code> 替换为该工具的名称。
</div>
<p>测试 <code>index.html</code> 文件确实存在：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /mnt/data/index.html
</code></pre></div>
<p>输出应该是：</p>
<pre><code>Hello from Kubernetes storage
</code></pre>
<p>现在你可以关闭节点的 Shell 了。</p>
<h2 id=创建-persistentvolume>创建 PersistentVolume</h2>
<p>在本练习中，你将创建一个 <em>hostPath</em> 类型的 PersistentVolume。
Kubernetes 支持用于在单节点集群上开发和测试的 hostPath 类型的 PersistentVolume。
hostPath 类型的 PersistentVolume 使用节点上的文件或目录来模拟网络附加存储。</p>
<p>在生产集群中，你不会使用 hostPath。
集群管理员会提供网络存储资源，比如 Google Compute Engine 持久盘卷、NFS 共享卷或 Amazon Elastic Block Store 卷。
集群管理员还可以使用 <a href=/docs/reference/generated/kubernetes-api/v1.22/#storageclass-v1-storage>StorageClasses</a> 来设置<a href=https://kubernetes.io/blog/2016/10/dynamic-provisioning-and-storage-in-kubernetes>动态提供存储</a>。</p>
<p>下面是 hostPath PersistentVolume 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/storage/pv-volume.yaml download=pods/storage/pv-volume.yaml><code>pods/storage/pv-volume.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-pv-volume-yaml')" title="Copy pods/storage/pv-volume.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-pv-volume-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>local<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/mnt/data&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 PersistentVolume：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/storage/pv-volume.yaml
</code></pre></div>
<p>查看 PersistentVolume 的信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pv task-pv-volume
</code></pre></div>
<p>输出结果显示该 PersistentVolume 的<code>状态（STATUS）</code> 为 <code>Available</code>。
这意味着它还没有被绑定给 PersistentVolumeClaim。</p>
<pre><code>NAME             CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE
task-pv-volume   10Gi       RWO           Retain          Available             manual                   4s
</code></pre>
<h2 id=创建-persistentvolumeclaim>创建 PersistentVolumeClaim</h2>
<p>下一步是创建一个 PersistentVolumeClaim。
Pod 使用 PersistentVolumeClaim 来请求物理存储。
在本练习中，你将创建一个 PersistentVolumeClaim，它请求至少 3 GB 容量的卷，
该卷至少可以为一个节点提供读写访问。</p>
<p>下面是 PersistentVolumeClaim 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/storage/pv-claim.yaml download=pods/storage/pv-claim.yaml><code>pods/storage/pv-claim.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-pv-claim-yaml')" title="Copy pods/storage/pv-claim.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-pv-claim-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-claim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>3Gi<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 PersistentVolumeClaim：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/storage/pv-claim.yaml
</code></pre></div>
<p>创建 PersistentVolumeClaim 之后，Kubernetes 控制平面将查找满足申领要求的 PersistentVolume。
如果控制平面找到具有相同 StorageClass 的适当的 PersistentVolume，
则将 PersistentVolumeClaim 绑定到该 PersistentVolume 上。</p>
<p>再次查看 PersistentVolume 信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pv task-pv-volume
</code></pre></div>
<p>现在输出的 <code>STATUS</code> 为 <code>Bound</code>。</p>
<pre><code>NAME             CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM                   STORAGECLASS   REASON    AGE
task-pv-volume   10Gi       RWO           Retain          Bound     default/task-pv-claim   manual                   2m
</code></pre>
<p>查看 PersistentVolumeClaim：</p>
<pre><code>kubectl get pvc task-pv-claim
</code></pre>
<p>输出结果表明该 PersistentVolumeClaim 绑定了你的 PersistentVolume <code>task-pv-volume</code>。</p>
<pre><code>NAME            STATUS    VOLUME           CAPACITY   ACCESSMODES   STORAGECLASS   AGE
task-pv-claim   Bound     task-pv-volume   10Gi       RWO           manual         30s
</code></pre>
<h2 id=创建-pod>创建 Pod</h2>
<p>下一步是创建一个 Pod， 该 Pod 使用你的 PersistentVolumeClaim 作为存储卷。</p>
<p>下面是 Pod 的 配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/storage/pv-pod.yaml download=pods/storage/pv-pod.yaml><code>pods/storage/pv-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-pv-pod-yaml')" title="Copy pods/storage/pv-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-pv-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>task-pv-claim<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http-server&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/usr/share/nginx/html&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>注意 Pod 的配置文件指定了 PersistentVolumeClaim，但没有指定 PersistentVolume。
对 Pod 而言，PersistentVolumeClaim 就是一个存储卷。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/storage/pv-pod.yaml
</code></pre></div>
<p>检查 Pod 中的容器是否运行正常：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod task-pv-pod
</code></pre></div>
<p>打开一个 Shell 访问 Pod 中的容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it task-pv-pod -- /bin/bash
</code></pre></div>
<p>在 Shell 中，验证 nginx 是否正在从 hostPath 卷提供 <code>index.html</code> 文件：</p>
<pre><code># 一定要在上一步 &quot;kubectl exec&quot; 所返回的 Shell 中执行下面三个命令
root@task-pv-pod:/# apt-get update
root@task-pv-pod:/# apt-get install curl
root@task-pv-pod:/# curl localhost
</code></pre>
<p>输出结果是你之前写到 hostPath 卷中的 <code>index.html</code> 文件中的内容：</p>
<pre><code>Hello from Kubernetes storage
</code></pre>
<p>如果你看到此消息，则证明你已经成功地配置了 Pod 使用 PersistentVolumeClaim
的存储。</p>
<h2 id=clean-up>清理 </h2>
<p>删除 Pod、PersistentVolumeClaim 和 PersistentVolume 对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod task-pv-pod
kubectl delete pvc task-pv-claim
kubectl delete pv task-pv-volume
</code></pre></div>
<p>如果你还没有连接到集群中节点的 Shell，可以按之前所做操作，打开一个新的 Shell。</p>
<p>在节点的 Shell 上，删除你所创建的目录和文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 这里假定你使用 &#34;sudo&#34; 来以超级用户的角色执行命令</span>
sudo rm /mnt/data/index.html
sudo rmdir /mnt/data
</code></pre></div>
<p>你现在可以关闭连接到节点的 Shell。</p>
<h2 id=access-control>访问控制 </h2>
<p>使用组 ID（GID）配置的存储仅允许 Pod 使用相同的 GID 进行写入。
GID 不匹配或缺失将会导致无权访问错误。
为了减少与用户的协调，管理员可以对 PersistentVolume 添加 GID 注解。
这样 GID 就能自动添加到使用 PersistentVolume 的任何 Pod 中。</p>
<p>使用 <code>pv.beta.kubernetes.io/gid</code> 注解的方法如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pv.beta.kubernetes.io/gid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1234&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<p>当 Pod 使用带有 GID 注解的 PersistentVolume 时，注解的 GID 会被应用于 Pod 中的所有容器，
应用的方法与 Pod 的安全上下文中指定的 GID 相同。
每个 GID，无论是来自 PersistentVolume 注解还是来自 Pod 规约，都会被应用于每个容器中
运行的第一个进程。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 当 Pod 使用 PersistentVolume 时，与 PersistentVolume 关联的 GID 不会在 Pod
资源本身的对象上出现。
</div>
<h2 id=接下来>接下来</h2>
<ul>
<li>进一步了解 <a href=/zh/docs/concepts/storage/persistent-volumes/>PersistentVolumes</a></li>
<li>阅读<a href=https://git.k8s.io/community/contributors/design-proposals/storage/persistent-storage.md>持久存储设计文档</a></li>
</ul>
<h3 id=参考>参考</h3>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#persistentvolume-v1-core>PersistentVolume</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#persistentvolumespec-v1-core>PersistentVolumeSpec</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#persistentvolumeclaim-v1-core>PersistentVolumeClaim</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#persistentvolumeclaimspec-v1-core>PersistentVolumeClaimSpec</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4621938ba53c04a77f51b5938a583439>9 - 配置 Pod 使用投射卷作存储</h1>
<p>本文介绍怎样通过<a href=/zh/docs/concepts/storage/volumes/#projected><code>projected</code></a> 卷将现有的多个卷资源挂载到相同的目录。
当前，<code>secret</code>、<code>configMap</code>、<code>downwardAPI</code> 和 <code>serviceAccountToken</code> 卷可以被投射。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> <code>serviceAccountToken</code> 不是一种卷类型
</div>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<h2 id=为-pod-配置-projected-卷>为 Pod 配置 projected 卷</h2>
<p>本练习中，您将从本地文件来创建包含有用户名和密码的 Secret。然后创建运行一个容器的 Pod，
该 Pod 使用<a href=/zh/docs/concepts/storage/volumes/#projected><code>projected</code></a> 卷将 Secret 挂载到相同的路径下。</p>
<p>下面是 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/storage/projected.yaml download=pods/storage/projected.yaml><code>pods/storage/projected.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-projected-yaml')" title="Copy pods/storage/projected.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-projected-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-projected-volume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-projected-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;86400&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>user<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pass<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>创建 Secret:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建包含用户名和密码的文件:</span>
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#34;admin&#34;</span> &gt; ./username.txt
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#34;1f2d1e2e67df&#34;</span> &gt; ./password.txt--&gt;

<span style=color:#080;font-style:italic># 将上述文件引用到 Secret：</span>
kubectl create secret generic user --from-file<span style=color:#666>=</span>./username.txt
kubectl create secret generic pass --from-file<span style=color:#666>=</span>./password.txt
</code></pre></div></li>
<li>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/storage/projected.yaml
</code></pre></div></li>
<li>
<p>确认 Pod 中的容器运行正常，然后监视 Pod 的变化：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get --watch pod test-projected-volume
</code></pre></div>
<p>输出结果和下面类似：</p>
<pre><code>NAME                    READY     STATUS    RESTARTS   AGE
test-projected-volume   1/1       Running   0          14s
</code></pre></li>
<li>
<p>在另外一个终端中，打开容器的 shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it test-projected-volume -- /bin/sh
</code></pre></div></li>
<li>
<p>在 shell 中，确认 <code>projected-volume</code> 目录包含你的投射源：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls /projected-volume/
</code></pre></div></li>
</ol>
<h2 id=清理>清理</h2>
<p>删除 Pod 和 Secret:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod test-projected-volume
kubectl delete secret user pass
</code></pre></div><h2 id=接下来>接下来</h2>
<ul>
<li>进一步了解<a href=/zh/docs/concepts/storage/volumes/#projected><code>projected</code></a> 卷。</li>
<li>阅读<a href=https://github.com/kubernetes/community/blob/v1.22.16/contributors/design-proposals/node/all-in-one-volume.md>一体卷</a>设计文档。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-abd895c0803315e9717e6ff9ec4e3d30>10 - 为 Pod 或容器配置安全性上下文</h1>
<p>安全上下文（Security Context）定义 Pod 或 Container 的特权与访问控制设置。
安全上下文包括但不限于：</p>
<ul>
<li>自主访问控制（Discretionary Access Control）：基于
<a href=https://wiki.archlinux.org/index.php/users_and_groups>用户 ID（UID）和组 ID（GID）</a>.
来判定对对象（例如文件）的访问权限。</li>
<li><a href=https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA%E5%BC%8FLinux>安全性增强的 Linux（SELinux）</a>：
为对象赋予安全性标签。</li>
<li>以特权模式或者非特权模式运行。</li>
<li><a href=https://linux-audit.com/linux-capabilities-hardening-linux-binaries-by-removing-setuid/>Linux 权能</a>:
为进程赋予 root 用户的部分特权而非全部特权。</li>
</ul>
<ul>
<li><a href=/zh/docs/tutorials/clusters/apparmor/>AppArmor</a>：使用程序框架来限制个别程序的权能。</li>
<li><a href=/zh/docs/tutorials/clusters/seccomp/>Seccomp</a>：过滤进程的系统调用。</li>
<li>AllowPrivilegeEscalation：控制进程是否可以获得超出其父进程的特权。
此布尔值直接控制是否为容器进程设置
<a href=https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt><code>no_new_privs</code></a>标志。
当容器以特权模式运行或者具有 <code>CAP_SYS_ADMIN</code> 权能时，AllowPrivilegeEscalation 总是为 true。</li>
<li>readOnlyRootFilesystem：以只读方式加载容器的根文件系统。</li>
</ul>
<p>以上条目不是安全上下文设置的完整列表 -- 请参阅
<a href=/docs/reference/generated/kubernetes-api/v1.22/#securitycontext-v1-core>SecurityContext</a>
了解其完整列表。</p>
<p>关于在 Linux 系统中的安全机制的更多信息，可参阅
<a href=https://www.linux.com/learn/overview-linux-kernel-security-features>Linux 内核安全性能力概述</a>。</p>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<h2 id=set-the-security-context-for-a-pod>为 Pod 设置安全性上下文 </h2>
<p>要为 Pod 设置安全性设置，可在 Pod 规约中包含 <code>securityContext</code> 字段。<code>securityContext</code> 字段值是一个
<a href=/docs/reference/generated/kubernetes-api/v1.22/#podsecuritycontext-v1-core>PodSecurityContext</a>
对象。你为 Pod 所设置的安全性配置会应用到 Pod 中所有 Container 上。
下面是一个 Pod 的配置文件，该 Pod 定义了 <code>securityContext</code> 和一个 <code>emptyDir</code> 卷：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/security/security-context.yaml download=pods/security/security-context.yaml><code>pods/security/security-context.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-security-security-context-yaml')" title="Copy pods/security/security-context.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-security-security-context-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>runAsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>3000</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-vol<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-demo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep 1h&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-vol<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/data/demo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>allowPrivilegeEscalation</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在配置文件中，<code>runAsUser</code> 字段指定 Pod 中的所有容器内的进程都使用用户 ID 1000
来运行。<code>runAsGroup</code> 字段指定所有容器中的进程都以主组 ID 3000 来运行。
如果忽略此字段，则容器的主组 ID 将是 root（0）。
当 <code>runAsGroup</code> 被设置时，所有创建的文件也会划归用户 1000 和组 3000。
由于 <code>fsGroup</code> 被设置，容器中所有进程也会是附组 ID 2000 的一部分。
卷 <code>/data/demo</code> 及在该卷中创建的任何文件的属主都会是组 ID 2000。</p>
<p>创建该 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/security/security-context.yaml
</code></pre></div>
<p>检查 Pod 的容器处于运行状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod security-context-demo
</code></pre></div>
<p>开启一个 Shell 进入到运行中的容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it security-context-demo -- sh
</code></pre></div>
<p>在你的 Shell 中，列举运行中的进程：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps
</code></pre></div>
<p>输出显示进程以用户 1000 运行，即 <code>runAsUser</code> 所设置的值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>PID   USER     TIME  COMMAND
    <span style=color:#666>1</span> <span style=color:#666>1000</span>      0:00 sleep 1h
    <span style=color:#666>6</span> <span style=color:#666>1000</span>      0:00 sh
...
</code></pre></div>
<p>在你的 Shell 中，进入 <code>/data</code> 目录列举其内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>cd</span> /data
ls -l
</code></pre></div>
<p>输出显示 <code>/data/demo</code> 目录的组 ID 为 2000，即 <code>fsGroup</code> 的设置值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>drwxrwsrwx <span style=color:#666>2</span> root <span style=color:#666>2000</span> <span style=color:#666>4096</span> Jun  <span style=color:#666>6</span> 20:08 demo
</code></pre></div>
<p>在你的 Shell 中，进入到 <code>/data/demo</code> 目录下创建一个文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>cd</span> demo
<span style=color:#a2f>echo</span> hello &gt; testfile
</code></pre></div>
<p>列举 <code>/data/demo</code> 目录下的文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls -l
</code></pre></div>
<p>输出显示 <code>testfile</code> 的组 ID 为 2000，也就是 <code>fsGroup</code> 所设置的值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>-rw-r--r-- <span style=color:#666>1</span> <span style=color:#666>1000</span> <span style=color:#666>2000</span> <span style=color:#666>6</span> Jun  <span style=color:#666>6</span> 20:08 testfile
</code></pre></div>
<p>运行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>id
</code></pre></div><p>输出为：</p>
<pre><code>uid=1000 gid=3000 groups=2000
</code></pre>
<p>你会看到 <code>gid</code> 值为 3000，也就是 <code>runAsGroup</code> 字段的值。
如果 <code>runAsGroup</code> 被忽略，则 <code>gid</code> 会取值 0（root），而进程就能够与 root
用户组所拥有以及要求 root 用户组访问权限的文件交互。</p>
<p>退出你的 Shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>exit</span>
</code></pre></div>
<h2 id=为-pod-配置卷访问权限和属主变更策略>为 Pod 配置卷访问权限和属主变更策略</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [beta]</code>
</div>
<p>默认情况下，Kubernetes 在挂载一个卷时，会递归地更改每个卷中的内容的属主和访问权限，使之与 Pod
的 <code>securityContext</code> 中指定的 <code>fsGroup</code> 匹配。
对于较大的数据卷，检查和变更属主与访问权限可能会花费很长时间，降低 Pod 启动速度。
你可以在 <code>securityContext</code> 中使用 <code>fsGroupChangePolicy</code> 字段来控制 Kubernetes
检查和管理卷属主和访问权限的方式。</p>
<p><strong>fsGroupChangePolicy</strong> - <code>fsGroupChangePolicy</code> 定义在卷被暴露给 Pod 内部之前对其
内容的属主和访问许可进行变更的行为。此字段仅适用于那些支持使用 <code>fsGroup</code> 来
控制属主与访问权限的卷类型。此字段的取值可以是：</p>
<ul>
<li><code>OnRootMismatch</code>：只有根目录的属主与访问权限与卷所期望的权限不一致时，
才改变其中内容的属主和访问权限。这一设置有助于缩短更改卷的属主与访问
权限所需要的时间。</li>
<li><code>Always</code>：在挂载卷时总是更改卷中内容的属主和访问权限。</li>
</ul>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>3000</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroupChangePolicy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;OnRootMismatch&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 此字段对于<a href=/zh/docs/concepts/storage/volumes/#secret><code>secret</code></a>、
<a href=/zh/docs/concepts/storage/volumes/#configmap><code>configMap</code></a>
和 <a href=/zh/docs/concepts/storage/volumes/#emptydir><code>emptydir</code></a>
这类临时性存储无效。
</div>
<h2 id=将卷权限和所有权更改委派给-csi-驱动程序>将卷权限和所有权更改委派给 CSI 驱动程序</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code>
</div>
<p>如果你部署了一个<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>容器存储接口 (CSI)</a>
驱动支持 <code>VOLUME_MOUNT_GROUP</code> <code>NodeServiceCapability</code>，
在 <code>securityContext</code> 中指定 <code>fsGroup</code> 来设置文件所有权和权限的过程将由 CSI 驱动
而不是 Kubernetes 来执行，前提是 Kubernetes 的 <code>DelegateFSGroupToCSIDriver</code>
特性门控已启用。在这种情况下，由于 Kubernetes 不执行任何
所有权和权限更改，<code>fsGroupChangePolicy</code> 不会生效，并且
按照 CSI 的规定，CSI 驱动应该使用所指定的 <code>fsGroup</code> 来挂载卷，从而生成了一个对 <code>fsGroup</code> 可读/可写的卷.</p>
<p>更多的信息请参考 <a href=https://github.com/gnufied/enhancements/blob/master/keps/sig-storage/2317-fsgroup-on-mount/README.md>KEP</a>
和 <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>CSI 规范</a> 中的字
段 <code>VolumeCapability.MountVolume.volume_mount_group</code> 的描述 。</p>
<h2 id=set-the-security-context-for-a-container>为 Container 设置安全性上下文 </h2>
<p>若要为 Container 设置安全性配置，可以在 Container 清单中包含 <code>securityContext</code>
字段。<code>securityContext</code> 字段的取值是一个
<a href=/docs/reference/generated/kubernetes-api/v1.22/#securitycontext-v1-core>SecurityContext</a>
对象。你为 Container 设置的安全性配置仅适用于该容器本身，并且所指定的设置
在与 Pod 层面设置的内容发生重叠时，会重载后者。Container 层面的设置不会影响
到 Pod 的卷。</p>
<p>下面是一个 Pod 的配置文件，其中包含一个 Container。Pod 和 Container 都有
<code>securityContext</code> 字段：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/security/security-context-2.yaml download=pods/security/security-context-2.yaml><code>pods/security/security-context-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-security-security-context-2-yaml')" title="Copy pods/security/security-context-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-security-security-context-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-demo-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>allowPrivilegeEscalation</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建该 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/security/security-context-2.yaml
</code></pre></div>
<p>验证 Pod 中的容器处于运行状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod security-context-demo-2
</code></pre></div>
<p>启动一个 Shell 进入到运行中的容器内：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it security-context-demo-2 -- sh
</code></pre></div>
<p>在你的 Shell 中，列举运行中的进程：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps aux
</code></pre></div>
<p>输出显示进程以用户 2000 账号运行。该值是在 Container 的 <code>runAsUser</code> 中设置的。
该设置值重载了 Pod 层面所设置的值 1000。</p>
<pre><code>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
2000         1  0.0  0.0   4336   764 ?        Ss   20:36   0:00 /bin/sh -c node server.js
2000         8  0.1  0.5 772124 22604 ?        Sl   20:36   0:00 node server.js
...
</code></pre>
<p>退出你的 Shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>exit</span>
</code></pre></div>
<h2 id=set-capabilities-for-a-container>为 Container 设置权能 </h2>
<p>使用 <a href=https://man7.org/linux/man-pages/man7/capabilities.7.html>Linux 权能</a>，你可以
赋予进程 root 用户所拥有的某些特权，但不必赋予其全部特权。
要为 Container 添加或移除 Linux 权能，可以在 Container 清单的 <code>securityContext</code> 节
包含 <code>capabilities</code> 字段。</p>
<p>首先，查看不包含 <code>capabilities</code> 字段时候会发生什么。
下面是一个配置文件，其中没有添加或移除容器的权能：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/security/security-context-3.yaml download=pods/security/security-context-3.yaml><code>pods/security/security-context-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-security-security-context-3-yaml')" title="Copy pods/security/security-context-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-security-security-context-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo-3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-3<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建该 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/security/security-context-3.yaml
</code></pre></div>
<p>验证 Pod 的容器处于运行状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod security-context-demo-3
</code></pre></div>
<p>启动一个 Shell 进入到运行中的容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it security-context-demo-3 -- sh
</code></pre></div>
<p>在你的 Shell 中，列举运行中的进程：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps aux
</code></pre></div>
<p>输出显示容器中进程 ID（PIDs）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>USER  PID %CPU %MEM    VSZ   RSS TTY   STAT START   TIME COMMAND
root    <span style=color:#666>1</span>  0.0  0.0   <span style=color:#666>4336</span>   <span style=color:#666>796</span> ?     Ss   18:17   0:00 /bin/sh -c node server.js
root    <span style=color:#666>5</span>  0.1  0.5 <span style=color:#666>772124</span> <span style=color:#666>22700</span> ?     Sl   18:17   0:00 node server.js
</code></pre></div>
<p>在你的 Shell 中，查看进程 1 的状态：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>cd</span> /proc/1
cat status
</code></pre></div>
<p>输出显示进程的权能位图：</p>
<pre><code>...
CapPrm:	00000000a80425fb
CapEff:	00000000a80425fb
...
</code></pre>
<p>记下进程权能位图，之后退出你的 Shell：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>exit</span>
</code></pre></div>
<p>接下来运行一个与前例中容器相同的容器，只是这个容器有一些额外的权能设置。</p>
<p>下面是一个 Pod 的配置，其中运行一个容器。配置为容器添加 <code>CAP_NET_ADMIN</code> 和
<code>CAP_SYS_TIME</code> 权能：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/security/security-context-4.yaml download=pods/security/security-context-4.yaml><code>pods/security/security-context-4.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-security-security-context-4-yaml')" title="Copy pods/security/security-context-4.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-security-security-context-4-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo-4<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-4<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>capabilities</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>add</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;NET_ADMIN&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;SYS_TIME&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/security/security-context-4.yaml
</code></pre></div>
<p>启动一个 Shell，进入到运行中的容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it security-context-demo-4 -- sh
</code></pre></div>
<p>在你的 Shell 中，查看进程 1 的权能：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>cd</span> /proc/1
cat status
</code></pre></div>
<p>输出显示的是进程的权能位图：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>...
CapPrm:	00000000aa0435fb
CapEff:	00000000aa0435fb
...
</code></pre></div>
<p>比较两个容器的权能位图：</p>
<pre><code>00000000a80425fb
00000000aa0435fb
</code></pre>
<p>在第一个容器的权能位图中，位 12 和 25 是没有设置的。在第二个容器中，位 12
和 25 是设置了的。位 12 是 <code>CAP_NET_ADMIN</code> 而位 25 则是 <code>CAP_SYS_TIME</code>。
参见 <a href=https://github.com/torvalds/linux/blob/master/include/uapi/linux/capability.h>capability.h</a>
了解权能常数的定义。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> Linux 权能常数定义的形式为 <code>CAP_XXX</code>。但是你在 Container 清单中列举权能时，
要将权能名称中的 <code>CAP_</code> 部分去掉。例如，要添加 <code>CAP_SYS_TIME</code>，可在权能
列表中添加 <code>SYS_TIME</code>。
</div>
<h2 id=为容器设置-seccomp-样板>为容器设置 Seccomp 样板</h2>
<p>若要为容器设置 Seccomp 样板（Profile），可在你的 Pod 或 Container 清单的
<code>securityContext</code> 节中包含 <code>seccompProfile</code> 字段。该字段是一个
<a href=/docs/reference/generated/kubernetes-api/v1.22/#seccompprofile-v1-core>SeccompProfile</a>
对象，包含 <code>type</code> 和 <code>localhostProfile</code> 属性。
<code>type</code> 的合法选项包括 <code>RuntimeDefault</code>、<code>Unconfined</code> 和 <code>Localhost</code>。
<code>localhostProfile</code> 只能在 <code>type: Localhost</code> 配置下才需要设置。
该字段标明节点上预先配置的样板的路径，路径是相对于 kubelet 所配置的
Seccomp 样板路径（使用 <code>--root-dir</code> 配置）而言的。</p>
<p>下面是一个例子，设置容器使用节点上容器运行时的默认样板作为 Seccomp 样板：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seccompProfile</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>RuntimeDefault<span style=color:#bbb>
</span></code></pre></div>
<p>下面是另一个例子，将 Seccomp 的样板设置为位于
<code>&lt;kubelet-根目录>/seccomp/my-profiles/profile-allow.json</code>
的一个预先配置的文件。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seccompProfile</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Localhost<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>localhostProfile</span>:<span style=color:#bbb> </span>my-profiles/profile-allow.json<span style=color:#bbb>
</span></code></pre></div>
<h2 id=为-container-赋予-selinux-标签>为 Container 赋予 SELinux 标签</h2>
<p>若要给 Container 设置 SELinux 标签，可以在 Pod 或 Container 清单的
<code>securityContext</code> 节包含 <code>seLinuxOptions</code> 字段。
<code>seLinuxOptions</code> 字段的取值是一个
<a href=/docs/reference/generated/kubernetes-api/v1.22/#selinuxoptions-v1-core>SELinuxOptions</a>
对象。下面是一个应用 SELinux 标签的例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seLinuxOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;s0:c123,c456&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 要指定 SELinux，需要在宿主操作系统中装载 SELinux 安全性模块。
</div>
<h2 id=discussion>讨论 </h2>
<p>Pod 的安全上下文适用于 Pod 中的容器，也适用于 Pod 所挂载的卷（如果有的话）。
尤其是，<code>fsGroup</code> 和 <code>seLinuxOptions</code> 按下面的方式应用到挂载卷上：</p>
<ul>
<li>
<p><code>fsGroup</code>：支持属主管理的卷会被修改，将其属主变更为 <code>fsGroup</code> 所指定的 GID，
并且对该 GID 可写。进一步的细节可参阅
<a href=https://git.k8s.io/community/contributors/design-proposals/storage/volume-ownership-management.md>属主变更设计文档</a>。</p>
</li>
<li>
<p><code>seLinuxOptions</code>：支持 SELinux 标签的卷会被重新打标签，以便可被 <code>seLinuxOptions</code>
下所设置的标签访问。通常你只需要设置 <code>level</code> 部分。
该部分设置的是赋予 Pod 中所有容器及卷的
<a href=https://selinuxproject.org/page/NB_MLS>多类别安全性（Multi-Category Security，MCS)</a>标签。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告：</strong> 在为 Pod 设置 MCS 标签之后，所有带有相同标签的 Pod 可以访问该卷。
如果你需要跨 Pod 的保护，你必须为每个 Pod 赋予独特的 MCS 标签。
</div>
</li>
</ul>
<h2 id=清理>清理</h2>
<p>删除之前创建的所有 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod security-context-demo
kubectl delete pod security-context-demo-2
kubectl delete pod security-context-demo-3
kubectl delete pod security-context-demo-4
</code></pre></div><h2 id=接下来>接下来</h2>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#podsecuritycontext-v1-core>PodSecurityContext</a> API 定义</li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#securitycontext-v1-core>SecurityContext</a> API 定义</li>
<li><a href=https://opensource.com/business/15/3/docker-security-tuning>使用最新的安全性增强来调优 Docker</a></li>
<li><a href=https://git.k8s.io/community/contributors/design-proposals/auth/security_context.md>安全性上下文的设计文档</a></li>
<li><a href=https://git.k8s.io/community/contributors/design-proposals/storage/volume-ownership-management.md>属主管理的设计文档</a></li>
<li><a href=/zh/docs/concepts/policy/pod-security-policy/>Pod 安全策略</a></li>
<li><a href=https://git.k8s.io/community/contributors/design-proposals/auth/no-new-privs.md>AllowPrivilegeEscalation 的设计文档</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2c0d882359718c4c69c67099bed2156c>11 - 为 Pod 配置服务账户</h1>
<p>服务账户为 Pod 中运行的进程提供了一个标识。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 本文是服务账户的用户使用介绍，描述服务账号在集群中如何起作用。
你的集群管理员可能已经对你的集群做了定制，因此导致本文中所讲述的内容并不适用。
</div>
<p>当你（自然人）访问集群时（例如，使用 <code>kubectl</code>），API 服务器将你的身份验证为
特定的用户帐户（当前这通常是 <code>admin</code>，除非你的集群管理员已经定制了你的集群配置）。
Pod 内的容器中的进程也可以与 api 服务器接触。
当它们进行身份验证时，它们被验证为特定的服务帐户（例如，<code>default</code>）。</p>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<h2 id=使用默认的服务账户访问-api-服务器>使用默认的服务账户访问 API 服务器</h2>
<p>当你创建 Pod 时，如果没有指定服务账户，Pod 会被指定给命名空间中的 <code>default</code> 服务账户。
如果你查看 Pod 的原始 JSON 或 YAML（例如：<code>kubectl get pods/podname -o yaml</code>），
你可以看到 <code>spec.serviceAccountName</code> 字段已经被自动设置了。</p>
<p>你可以使用自动挂载给 Pod 的服务账户凭据访问 API，
<a href=/zh/docs/tasks/access-application-cluster/access-cluster/#accessing-the-api-from-a-pod>访问集群</a>
中有相关描述。
服务账户的 API 许可取决于你所使用的
<a href=/zh/docs/reference/access-authn-authz/authorization/#authorization-modules>鉴权插件和策略</a>。</p>
<p>在 1.6 以上版本中，你可以通过在服务账户上设置 <code>automountServiceAccountToken: false</code>
来实现不给服务账号自动挂载 API 凭据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>automountServiceAccountToken</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div>
<p>在 1.6 以上版本中，你也可以选择不给特定 Pod 自动挂载 API 凭据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>automountServiceAccountToken</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>如果 Pod 和服务账户都指定了 <code>automountServiceAccountToken</code> 值，则 Pod 的 spec 优先于服务帐户。</p>
<h2 id=use-multiple-service-accounts>使用多个服务账户 </h2>
<p>每个命名空间都有一个名为 <code>default</code> 的服务账户资源。
你可以用下面的命令查询这个服务账户以及命名空间中的其他 ServiceAccount 资源：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get serviceAccounts
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME      SECRETS    AGE
default   1          1d
</code></pre>
<p>你可以像这样来创建额外的 ServiceAccount 对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f - <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: ServiceAccount
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: build-robot
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>ServiceAccount 对象的名字必须是一个有效的
<a href=/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>.</p>
<p>如果你查询服务帐户对象的完整信息，如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get serviceaccounts/build-robot -o yaml
</code></pre></div>
<p>输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2015-06-16T00:12:59Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;272500&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>721ab723-13bc-11e5-aec2-42010af0021e<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>secrets</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>build-robot-token-bvbk5<span style=color:#bbb>
</span></code></pre></div>
<p>那么你就能看到系统已经自动创建了一个令牌并且被服务账户所引用。</p>
<p>你可以使用授权插件来
<a href=/zh/docs/reference/access-authn-authz/rbac/#service-account-permissions>设置服务账户的访问许可</a>。</p>
<p>要使用非默认的服务账户，将 Pod 的 <code>spec.serviceAccountName</code> 字段设置为你想用的服务账户名称。</p>
<p>Pod 被创建时服务账户必须存在，否则会被拒绝。</p>
<p>你不能更新已经创建好的 Pod 的服务账户。</p>
<p>你可以清除服务账户，如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete serviceaccount/build-robot
</code></pre></div>
<h2 id=手动创建服务账户-api-令牌>手动创建服务账户 API 令牌</h2>
<p>假设我们有一个上面提到的名为 "build-robot" 的服务账户，然后我们手动创建一个新的 Secret。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f - <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Secret
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: build-robot-secret
</span><span style=color:#b44>  annotations:
</span><span style=color:#b44>    kubernetes.io/service-account.name: build-robot
</span><span style=color:#b44>type: kubernetes.io/service-account-token
</span><span style=color:#b44>EOF</span>
secret/build-robot-secret created
</code></pre></div>
<p>现在，你可以确认新构建的 Secret 中填充了 "build-robot" 服务帐户的 API 令牌。</p>
<p>令牌控制器将清理不存在的服务帐户的所有令牌。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe secrets/build-robot-secret
</code></pre></div>
<p>输出类似于：</p>
<pre><code>Name:           build-robot-secret
Namespace:      default
Labels:         &lt;none&gt;
Annotations:    kubernetes.io/service-account.name: build-robot
                kubernetes.io/service-account.uid: da68f9c6-9d26-11e7-b84e-002dc52800da

Type:   kubernetes.io/service-account-token

Data
====
ca.crt:         1338 bytes
namespace:      7 bytes
token:          ...
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 这里省略了 <code>token</code> 的内容。
</div>
<h2 id=add-imagepullsecrets-to-a-service-account>为服务账户添加 ImagePullSecrets </h2>
<h3 id=创建-imagepullsecret>创建 ImagePullSecret</h3>
<ul>
<li>
<p>创建一个 ImagePullSecret，如同<a href=/zh/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>为 Pod 设置 ImagePullSecret</a>所述。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret docker-registry myregistrykey --docker-server<span style=color:#666>=</span>DUMMY_SERVER <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>          --docker-username<span style=color:#666>=</span>DUMMY_USERNAME --docker-password<span style=color:#666>=</span>DUMMY_DOCKER_PASSWORD <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>          --docker-email<span style=color:#666>=</span>DUMMY_DOCKER_EMAIL
</code></pre></div></li>
</ul>
<ul>
<li>
<p>确认创建成功：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secrets myregistrykey
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME             TYPE                              DATA    AGE
myregistrykey    kubernetes.io/.dockerconfigjson   1       1d
</code></pre></li>
</ul>
<h3 id=将镜像拉取-secret-添加到服务账号>将镜像拉取 Secret 添加到服务账号</h3>
<p>接着修改命名空间的 <code>default</code> 服务帐户，以将该 Secret 用作 imagePullSecret。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch serviceaccount default -p <span style=color:#b44>&#39;{&#34;imagePullSecrets&#34;: [{&#34;name&#34;: &#34;myregistrykey&#34;}]}&#39;</span>
</code></pre></div>
<p>你也可以使用 <code>kubectl edit</code>，或者如下所示手动编辑 YAML 清单：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get serviceaccounts default -o yaml &gt; ./sa.yaml
</code></pre></div><p><code>sa.yaml</code> 文件的内容类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2015-08-07T22:02:39Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;243024&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>052fb0f4-3d50-11e5-b066-42010af0d7b6<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>secrets</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-token-uudge<span style=color:#bbb>
</span></code></pre></div>
<p>使用你常用的编辑器（例如 <code>vi</code>），打开 <code>sa.yaml</code> 文件，删除带有键名
<code>resourceVersion</code> 的行，添加带有 <code>imagePullSecrets:</code> 的行，最后保存文件。</p>
<p>所得到的 <code>sa.yaml</code> 文件类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2015-08-07T22:02:39Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>052fb0f4-3d50-11e5-b066-42010af0d7b6<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>secrets</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-token-uudge<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>imagePullSecrets</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myregistrykey<span style=color:#bbb>
</span></code></pre></div>
<p>最后，用新的更新的 <code>sa.yaml</code> 文件替换服务账号。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl replace serviceaccount default -f ./sa.yaml
</code></pre></div>
<h3 id=验证镜像拉取-secret-已经被添加到-pod-规约>验证镜像拉取 Secret 已经被添加到 Pod 规约</h3>
<p>现在，在当前命名空间中创建的每个使用默认服务账号的新 Pod，新 Pod 都会自动
设置其 <code>.spec.imagePullSecrets</code> 字段：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run nginx --image<span style=color:#666>=</span>nginx --restart<span style=color:#666>=</span>Never
kubectl get pod nginx -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.imagePullSecrets[0].name}{&#34;\n&#34;}&#39;</span>
</code></pre></div>
<p>输出为：</p>
<pre><code>myregistrykey
</code></pre>
<h2 id=service-account-token-volume-projection>服务帐户令牌卷投射 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> <p>为了启用令牌请求投射，你必须为 <code>kube-apiserver</code> 设置以下命令行参数：</p>
<ul>
<li><code>--service-account-issuer</code></li>
<li><code>--service-account-key-file</code></li>
<li><code>--service-account-signing-key-file</code></li>
<li><code>--api-audiences</code></li>
</ul>
</div>
<p>kubelet 还可以将服务帐户令牌投影到 Pod 中。
你可以指定令牌的所需属性，例如受众和有效持续时间。
这些属性在默认服务帐户令牌上无法配置。
当删除 Pod 或 ServiceAccount 时，服务帐户令牌也将对 API 无效。</p>
<p>使用名为 <a href=/zh/docs/concepts/storage/volumes/#projected>ServiceAccountToken</a> 的
ProjectedVolume 类型在 PodSpec 上配置此功能。
要向 Pod 提供具有 "vault" 用户以及两个小时有效期的令牌，可以在 PodSpec 中配置以下内容：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/pod-projected-svc-token.yaml download=pods/pod-projected-svc-token.yaml><code>pods/pod-projected-svc-token.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-projected-svc-token-yaml')" title="Copy pods/pod-projected-svc-token.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-projected-svc-token-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/run/secrets/tokens<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>7200</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>audience</span>:<span style=color:#bbb> </span>vault<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/pod-projected-svc-token.yaml
</code></pre></div>
<p><code>kubelet</code> 组件会替 Pod 请求令牌并将其保存起来，通过将令牌存储到一个可配置的
路径使之在 Pod 内可用，并在令牌快要到期的时候刷新它。
<code>kubelet</code> 会在令牌存在期达到其 TTL 的 80% 的时候或者令牌生命期超过 24 小时
的时候主动轮换它。</p>
<p>应用程序负责在令牌被轮换时重新加载其内容。对于大多数使用场景而言，周期性地
（例如，每隔 5 分钟）重新加载就足够了。</p>
<h2 id=发现服务账号分发者>发现服务账号分发者</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code>
</div>
<p>当启用服务账号令牌投射时启用发现服务账号分发者（Service Account Issuer Discovery）这一功能特性，
如<a href=#service-account-token-volume-projection>上文所述</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> <p>分发者的 URL 必须遵从
<a href=https://openid.net/specs/openid-connect-discovery-1_0.html>OIDC 发现规范</a>。
这意味着 URL 必须使用 <code>https</code> 模式，并且必须在
<code>{service-account-issuer}/.well-known/openid-configuration</code>
路径提供 OpenID 提供者（Provider）配置。</p>
<p>如果 URL 没有遵从这一规范，<code>ServiceAccountIssuerDiscovery</code> 末端就不会被注册，
即使该特性已经被启用。</p>
</div>
<p>发现服务账号分发者这一功能使得用户能够用联邦的方式结合使用 Kubernetes
集群（<em>Identity Provider</em>，标识提供者）与外部系统（<em>relying parties</em>，
依赖方）所分发的服务账号令牌。</p>
<p>当此功能被启用时，Kubernetes API 服务器会在 <code>/.well-known/openid-configuration</code>
提供一个 OpenID 提供者配置文档，并在 <code>/openid/v1/jwks</code> 处提供与之关联的
JSON Web Key Set（JWKS）。
这里的 OpenID 提供者配置有时候也被称作 <em>发现文档（Discovery Document）</em>。</p>
<p>集群包括一个的默认 RBAC ClusterRole, 名为 <code>system:service-account-issuer-discovery</code>。
默认的 RBAC ClusterRoleBinding 将此角色分配给 <code>system:serviceaccounts</code> 组，
所有服务帐户隐式属于该组。这使得集群上运行的 Pod 能够通过它们所挂载的服务帐户令牌访问服务帐户发现文档。
此外，管理员可以根据其安全性需要以及期望集成的外部系统选择是否将该角色绑定到
<code>system:authenticated</code> 或 <code>system:unauthenticated</code>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 对 <code>/.well-known/openid-configuration</code> 和 <code>/openid/v1/jwks</code> 路径请求的响应
被设计为与 OIDC 兼容，但不是完全与其一致。
返回的文档仅包含对 Kubernetes 服务账号令牌进行验证所必须的参数。
</div>
<p>JWKS 响应包含依赖方可以用来验证 Kubernetes 服务账号令牌的公钥数据。
依赖方先会查询 OpenID 提供者配置，之后使用返回响应中的 <code>jwks_uri</code> 来查找
JWKS。</p>
<p>在很多场合，Kubernetes API 服务器都不会暴露在公网上，不过对于缓存并向外提供 API
服务器响应数据的公开末端而言，用户或者服务提供商可以选择将其暴露在公网上。
在这种环境中，可能会重载 OpenID 提供者配置中的
<code>jwks_uri</code>，使之指向公网上可用的末端地址，而不是 API 服务器的地址。
这时需要向 API 服务器传递 <code>--service-account-jwks-uri</code> 参数。
与分发者 URL 类似，此 JWKS URI 也需要使用 <code>https</code> 模式。</p>
<h2 id=接下来>接下来</h2>
<p>另请参见：</p>
<ul>
<li><a href=/zh/docs/reference/access-authn-authz/service-accounts-admin/>服务账号的集群管理员指南</a></li>
<li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-auth/1393-oidc-discovery>服务账号签署密钥检索 KEP</a></li>
<li><a href=https://openid.net/specs/openid-connect-discovery-1_0.html>OIDC 发现规范</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d385b86a7cb496d3b1c3b2a47280ca70>12 - 从私有仓库拉取镜像</h1>
<p>本文介绍如何使用 Secret 从私有的 Docker 镜像仓库或代码仓库拉取镜像来创建 Pod。</p>
<h2 id=准备开始>准备开始</h2>
<ul>
<li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</li>
</ul>
<p>你需要 <a href=https://docs.docker.com/docker-id/>Docker ID</a> 和密码来进行本练习。</p>
<h2 id=登录-docker-镜像仓库>登录 Docker 镜像仓库</h2>
<p>在个人电脑上，要想拉取私有镜像必须在镜像仓库上进行身份验证。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker login
</code></pre></div>
<p>当出现提示时，输入 Docker 用户名和密码。</p>
<p>登录过程会创建或更新保存有授权令牌的 <code>config.json</code> 文件。</p>
<p>查看 <code>config.json</code> 文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat ~/.docker/config.json
</code></pre></div>
<p>输出结果包含类似于以下内容的部分：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;https://index.docker.io/v1/&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;c3R...zE2&#34;</span>
        }
    }
}
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 如果使用 Docker 凭证仓库，则不会看到 <code>auth</code> 条目，看到的将是以仓库名称作为值的 <code>credsStore</code> 条目。
</div>
<h2 id=在集群中创建保存授权令牌的-secret>在集群中创建保存授权令牌的 Secret</h2>
<p>Kubernetes 集群使用 <code>docker-registry</code> 类型的 Secret 来通过容器仓库的身份验证，进而提取私有映像。</p>
<p>创建 Secret，命名为 <code>regcred</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret docker-registry regcred <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-server<span style=color:#666>=</span>&lt;你的镜像仓库服务器&gt; <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-username<span style=color:#666>=</span>&lt;你的用户名&gt; <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-password<span style=color:#666>=</span>&lt;你的密码&gt; <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-email<span style=color:#666>=</span>&lt;你的邮箱地址&gt;
</code></pre></div>
<p>在这里：</p>
<ul>
<li><code>&lt;your-registry-server></code> 是你的私有 Docker 仓库全限定域名（FQDN）。
DockerHub 使用 <code>https://index.docker.io/v1/</code>。</li>
<li><code>&lt;your-name></code> 是你的 Docker 用户名。</li>
<li><code>&lt;your-pword></code> 是你的 Docker 密码。</li>
<li><code>&lt;your-email></code> 是你的 Docker 邮箱。</li>
</ul>
<p>这样你就成功地将集群中的 Docker 凭据设置为名为 <code>regcred</code> 的 Secret。</p>
<h2 id=检查-secret-regcred>检查 Secret <code>regcred</code></h2>
<p>要了解你创建的 <code>regcred</code> Secret 的内容，可以用 YAML 格式进行查看：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secret regcred --output<span style=color:#666>=</span>yaml
</code></pre></div>
<p>输出和下面类似：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockerconfigjson</span>:<span style=color:#bbb> </span>eyJodHRwczovL2luZGV4L ... J0QUl6RTIifX0=<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>regcred<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockerconfigjson<span style=color:#bbb>
</span></code></pre></div>
<p><code>.dockerconfigjson</code> 字段的值是 Docker 凭据的 base64 表示。</p>
<p>要了解 <code>dockerconfigjson</code> 字段中的内容，请将 Secret 数据转换为可读格式：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secret regcred --output<span style=color:#666>=</span><span style=color:#b44>&#34;jsonpath={.data.\.dockerconfigjson}&#34;</span> | base64 --decode
</code></pre></div>
<p>输出和下面类似：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;auths&#34;</span>:{<span style=color:green;font-weight:700>&#34;yourprivateregistry.com&#34;</span>:{<span style=color:green;font-weight:700>&#34;username&#34;</span>:<span style=color:#b44>&#34;janedoe&#34;</span>,<span style=color:green;font-weight:700>&#34;password&#34;</span>:<span style=color:#b44>&#34;xxxxxxxxxxx&#34;</span>,<span style=color:green;font-weight:700>&#34;email&#34;</span>:<span style=color:#b44>&#34;jdoe@example.com&#34;</span>,<span style=color:green;font-weight:700>&#34;auth&#34;</span>:<span style=color:#b44>&#34;c3R...zE2&#34;</span>}}}
</code></pre></div>
<p>要了解 <code>auth</code> 字段中的内容，请将 base64 编码过的数据转换为可读格式：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;c3R...zE2&#34;</span> | base64 --decode
</code></pre></div>
<p>输出结果中，用户名和密码用 <code>:</code> 链接，类似下面这样：</p>
<pre><code class=language-none data-lang=none>janedoe:xxxxxxxxxxx
</code></pre>
<p>注意，Secret 数据包含与本地 <code>~/.docker/config.json</code> 文件类似的授权令牌。</p>
<p>这样你就已经成功地将 Docker 凭据设置为集群中的名为 <code>regcred</code> 的 Secret。</p>
<h2 id=创建一个使用你的-secret-的-pod>创建一个使用你的 Secret 的 Pod</h2>
<p>下面是一个 Pod 配置文件，它需要访问 <code>regcred</code> 中的 Docker 凭据：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/private-reg-pod.yaml download=pods/private-reg-pod.yaml><code>pods/private-reg-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-private-reg-pod-yaml')" title="Copy pods/private-reg-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-private-reg-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>private-reg<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>private-reg-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>&lt;your-private-image&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imagePullSecrets</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>regcred<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>下载上述文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget -O my-private-reg-pod.yaml https://k8s.io/examples/pods/private-reg-pod.yaml
</code></pre></div>
<p>在<code>my-private-reg-pod.yaml</code> 文件中，使用私有仓库的镜像路径替换 <code>&lt;your-private-image></code>，例如：</p>
<pre><code class=language-none data-lang=none>janedoe/jdoe-private:v1
</code></pre>
<p>要从私有仓库拉取镜像，Kubernetes 需要凭证。
配置文件中的 <code>imagePullSecrets</code> 字段表明 Kubernetes 应该通过名为 <code>regcred</code> 的 Secret 获取凭证。</p>
<p>创建使用了你的 Secret 的 Pod，并检查它是否正常运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f my-private-reg-pod.yaml
kubectl get pod private-reg
</code></pre></div><h2 id=接下来>接下来</h2>
<ul>
<li>进一步了解 <a href=/zh/docs/concepts/configuration/secret/>Secret</a></li>
<li>进一步了解 <a href=/zh/docs/concepts/containers/images/#using-a-private-registry>使用私有仓库</a></li>
<li>参考 <a href=/docs/reference/generated/kubectl/kubectl-commands/#-em-secret-docker-registry-em->kubectl create secret docker-registry</a></li>
<li>参考 <a href=/docs/reference/generated/kubernetes-api/v1.22/#secret-v1-core>Secret</a></li>
<li>参考 <a href=/docs/reference/generated/kubernetes-api/v1.22/#podspec-v1-core>PodSpec</a> 中的 <code>imagePullSecrets</code> 字段</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eb54daf87df373096b5e830680194dfc>13 - 配置存活、就绪和启动探测器</h1>
<p>这篇文章介绍如何给容器配置存活、就绪和启动探测器。</p>
<p><a href=/zh/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>
使用存活探测器来知道什么时候要重启容器。
例如，存活探测器可以捕捉到死锁（应用程序在运行，但是无法继续执行后面的步骤）。
这样的情况下重启容器有助于让应用程序在有问题的情况下更可用。</p>
<p>kubelet 使用就绪探测器可以知道容器什么时候准备好了并可以开始接受请求流量， 当一个 Pod
内的所有容器都准备好了，才能把这个 Pod 看作就绪了。
这种信号的一个用途就是控制哪个 Pod 作为 Service 的后端。
在 Pod 还没有准备好的时候，会从 Service 的负载均衡器中被剔除的。</p>
<p>kubelet 使用启动探测器可以知道应用程序容器什么时候启动了。
如果配置了这类探测器，就可以控制容器在启动成功后再进行存活性和就绪检查，
确保这些存活、就绪探测器不会影响应用程序的启动。
这可以用于对慢启动容器进行存活性检测，避免它们在启动运行之前就被杀掉。</p>
<h2 id=准备开始>准备开始</h2>
<p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
<h2 id=define-a-liveness-command>定义存活命令</h2>
<p>许多长时间运行的应用程序最终会过渡到断开的状态，除非重新启动，否则无法恢复。
Kubernetes 提供了存活探测器来发现并补救这种情况。</p>
<p>在这篇练习中，你会创建一个 Pod，其中运行一个基于 <code>k8s.gcr.io/busybox</code> 镜像的容器。
下面是这个 Pod 的配置文件。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/probe/exec-liveness.yaml download=pods/probe/exec-liveness.yaml><code>pods/probe/exec-liveness.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-probe-exec-liveness-yaml')" title="Copy pods/probe/exec-liveness.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-probe-exec-liveness-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-exec<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- cat<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- /tmp/healthy<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在这个配置文件中，可以看到 Pod 中只有一个容器。
<code>periodSeconds</code> 字段指定了 kubelet 应该每 5 秒执行一次存活探测。
<code>initialDelaySeconds</code> 字段告诉 kubelet 在执行第一次探测前应该等待 5 秒。
kubelet 在容器内执行命令 <code>cat /tmp/healthy</code> 来进行探测。
如果命令执行成功并且返回值为 0，kubelet 就会认为这个容器是健康存活的。
如果这个命令返回非 0 值，kubelet 会杀死这个容器并重新启动它。</p>
<p>当容器启动时，执行如下的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/bin/sh -c <span style=color:#b44>&#34;touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600&#34;</span>
</code></pre></div>
<p>这个容器生命的前 30 秒， <code>/tmp/healthy</code> 文件是存在的。
所以在这最开始的 30 秒内，执行命令 <code>cat /tmp/healthy</code> 会返回成功代码。
30 秒之后，执行命令 <code>cat /tmp/healthy</code> 就会返回失败代码。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/probe/exec-liveness.yaml
</code></pre></div>
<p>在 30 秒内，查看 Pod 的事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod liveness-exec
</code></pre></div>
<p>输出结果表明还没有存活探测器失败：</p>
<pre><code>FirstSeen    LastSeen    Count   From            SubobjectPath           Type        Reason      Message
--------- --------    -----   ----            -------------           --------    ------      -------
24s       24s     1   {default-scheduler }                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulling     pulling image &quot;k8s.gcr.io/busybox&quot;
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulled      Successfully pulled image &quot;k8s.gcr.io/busybox&quot;
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Created     Created container with docker id 86849c15382e; Security:[seccomp=unconfined]
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Started     Started container with docker id 86849c15382e
</code></pre>
<p>35 秒之后，再来看 Pod 的事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod liveness-exec
</code></pre></div>
<p>在输出结果的最下面，有信息显示存活探测器失败了，这个容器被杀死并且被重建了。</p>
<pre><code>FirstSeen LastSeen    Count   From            SubobjectPath           Type        Reason      Message
--------- --------    -----   ----            -------------           --------    ------      -------
37s       37s     1   {default-scheduler }                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulling     pulling image &quot;k8s.gcr.io/busybox&quot;
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulled      Successfully pulled image &quot;k8s.gcr.io/busybox&quot;
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Created     Created container with docker id 86849c15382e; Security:[seccomp=unconfined]
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Started     Started container with docker id 86849c15382e
2s        2s      1   {kubelet worker0}   spec.containers{liveness}   Warning     Unhealthy   Liveness probe failed: cat: can't open '/tmp/healthy': No such file or directory
</code></pre>
<p>再等另外 30 秒，检查看这个容器被重启了：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod liveness-exec
</code></pre></div>
<p>输出结果显示 <code>RESTARTS</code> 的值增加了 1。</p>
<pre><code>NAME            READY     STATUS    RESTARTS   AGE
liveness-exec   1/1       Running   1          1m
</code></pre>
<h2 id=define-a-liveness-HTTP-request>定义一个存活态 HTTP 请求接口</h2>
<p>另外一种类型的存活探测方式是使用 HTTP GET 请求。
下面是一个 Pod 的配置文件，其中运行一个基于 <code>k8s.gcr.io/liveness</code> 镜像的容器。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/probe/http-liveness.yaml download=pods/probe/http-liveness.yaml><code>pods/probe/http-liveness.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-probe-http-liveness-yaml')" title="Copy pods/probe/http-liveness.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-probe-http-liveness-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-http<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/liveness<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /server<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>Custom-Header<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>Awesome<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在这个配置文件中，可以看到 Pod 也只有一个容器。
<code>periodSeconds</code> 字段指定了 kubelet 每隔 3 秒执行一次存活探测。
<code>initialDelaySeconds</code> 字段告诉 kubelet 在执行第一次探测前应该等待 3 秒。
kubelet 会向容器内运行的服务（服务会监听 8080 端口）发送一个 HTTP GET 请求来执行探测。
如果服务器上 <code>/healthz</code> 路径下的处理程序返回成功代码，则 kubelet 认为容器是健康存活的。
如果处理程序返回失败代码，则 kubelet 会杀死这个容器并且重新启动它。</p>
<p>任何大于或等于 200 并且小于 400 的返回代码标示成功，其它返回代码都标示失败。</p>
<p>可以在这里看服务的源码 <a href=https://github.com/kubernetes/kubernetes/blob/master/test/images/agnhost/liveness/server.go>server.go</a>。</p>
<p>容器存活的最开始 10 秒中，<code>/healthz</code> 处理程序返回一个 200 的状态码。之后处理程序返回 500 的状态码。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>http.<span style=color:#00a000>HandleFunc</span>(<span style=color:#b44>&#34;/healthz&#34;</span>, <span style=color:#a2f;font-weight:700>func</span>(w http.ResponseWriter, r <span style=color:#666>*</span>http.Request) {
    duration <span style=color:#666>:=</span> time.<span style=color:#00a000>Now</span>().<span style=color:#00a000>Sub</span>(started)
    <span style=color:#a2f;font-weight:700>if</span> duration.<span style=color:#00a000>Seconds</span>() &gt; <span style=color:#666>10</span> {
        w.<span style=color:#00a000>WriteHeader</span>(<span style=color:#666>500</span>)
        w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;error: %v&#34;</span>, duration.<span style=color:#00a000>Seconds</span>())))
    } <span style=color:#a2f;font-weight:700>else</span> {
        w.<span style=color:#00a000>WriteHeader</span>(<span style=color:#666>200</span>)
        w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(<span style=color:#b44>&#34;ok&#34;</span>))
    }
})
</code></pre></div>
<p>kubelet 在容器启动之后 3 秒开始执行健康检测。所以前几次健康检查都是成功的。
但是 10 秒之后，健康检查会失败，并且 kubelet 会杀死容器再重新启动容器。</p>
<p>创建一个 Pod 来测试 HTTP 的存活检测：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/probe/http-liveness.yaml
</code></pre></div>
<p>10 秒之后，通过看 Pod 事件来检测存活探测器已经失败了并且容器被重新启动了。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod liveness-http
</code></pre></div>
<p>在 1.13（包括 1.13版本）之前的版本中，如果在 Pod 运行的节点上设置了环境变量
<code>http_proxy</code>（或者 <code>HTTP_PROXY</code>），HTTP 的存活探测会使用这个代理。
在 1.13 之后的版本中，设置本地的 HTTP 代理环境变量不会影响 HTTP 的存活探测。</p>
<h2 id=define-a-TCP-liveness-probe>定义 TCP 的存活探测</h2>
<p>第三种类型的存活探测是使用 TCP 套接字。
通过配置，kubelet 会尝试在指定端口和容器建立套接字链接。
如果能建立连接，这个容器就被看作是健康的，如果不能则这个容器就被看作是有问题的。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/probe/tcp-liveness-readiness.yaml download=pods/probe/tcp-liveness-readiness.yaml><code>pods/probe/tcp-liveness-readiness.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-probe-tcp-liveness-readiness-yaml')" title="Copy pods/probe/tcp-liveness-readiness.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-probe-tcp-liveness-readiness-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/goproxy:0.1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tcpSocket</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tcpSocket</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>20</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>如你所见，TCP 检测的配置和 HTTP 检测非常相似。
下面这个例子同时使用就绪和存活探测器。kubelet 会在容器启动 5 秒后发送第一个就绪探测。
这会尝试连接 <code>goproxy</code> 容器的 8080 端口。
如果探测成功，这个 Pod 会被标记为就绪状态，kubelet 将继续每隔 10 秒运行一次检测。</p>
<p>除了就绪探测，这个配置包括了一个存活探测。
kubelet 会在容器启动 15 秒后进行第一次存活探测。
与就绪探测类似，会尝试连接 <code>goproxy</code> 容器的 8080 端口。
如果存活探测失败，这个容器会被重新启动。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/probe/tcp-liveness-readiness.yaml
</code></pre></div>
<p>15 秒之后，通过看 Pod 事件来检测存活探测器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod goproxy
</code></pre></div>
<h2 id=use-a-named-port>使用命名端口</h2>
<p>对于 HTTP 或者 TCP 存活检测可以使用命名的
<a href=/docs/reference/generated/kubernetes-api/v1.22/#containerport-v1-core>ContainerPort</a>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></code></pre></div>
<h2 id=define-startup-probes>使用启动探测器保护慢启动容器</h2>
<p>有时候，会有一些现有的应用程序在启动时需要较多的初始化时间。
要不影响对引起探测死锁的快速响应，这种情况下，设置存活探测参数是要技巧的。
技巧就是使用一个命令来设置启动探测，针对HTTP 或者 TCP 检测，可以通过设置
<code>failureThreshold * periodSeconds</code> 参数来保证有足够长的时间应对糟糕情况下的启动时间。</p>
<p>所以，前面的例子就变成了：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>startupProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></code></pre></div>
<p>幸亏有启动探测，应用程序将会有最多 5 分钟(30 * 10 = 300s) 的时间来完成它的启动。
一旦启动探测成功一次，存活探测任务就会接管对容器的探测，对容器死锁可以快速响应。
如果启动探测一直没有成功，容器会在 300 秒后被杀死，并且根据 <code>restartPolicy</code> 来设置 Pod 状态。</p>
<h2 id=define-readiness-probes>定义就绪探测器</h2>
<p>有时候，应用程序会暂时性的不能提供通信服务。
例如，应用程序在启动时可能需要加载很大的数据或配置文件，或是启动后要依赖等待外部服务。
在这种情况下，既不想杀死应用程序，也不想给它发送请求。
Kubernetes 提供了就绪探测器来发现并缓解这些情况。
容器所在 Pod 上报还未就绪的信息，并且不接受通过 Kubernetes Service 的流量。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 就绪探测器在容器的整个生命周期中保持运行状态。
</div>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong> 活跃性探测器 <em>不等待</em> 就绪性探测器成功。
如果要在执行活跃性探测器之前等待，应该使用 initialDelaySeconds 或 startupProbe。
</div>
<p>就绪探测器的配置和存活探测器的配置相似。
唯一区别就是要使用 <code>readinessProbe</code> 字段，而不是 <code>livenessProbe</code> 字段。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- cat<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /tmp/healthy<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div>
<p>HTTP 和 TCP 的就绪探测器配置也和存活探测器的配置一样的。</p>
<p>就绪和存活探测可以在同一个容器上并行使用。
两者都用可以确保流量不会发给还没有准备好的容器，并且容器会在它们失败的时候被重新启动。</p>
<h2 id=configure-probes>配置探测器</h2>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#probe-v1-core>Probe</a>
有很多配置字段，可以使用这些字段精确的控制存活和就绪检测的行为：</p>
<ul>
<li><code>initialDelaySeconds</code>：容器启动后要等待多少秒后存活和就绪探测器才被初始化，默认是 0 秒，最小值是 0。</li>
<li><code>periodSeconds</code>：执行探测的时间间隔（单位是秒）。默认是 10 秒。最小值是 1。</li>
<li><code>timeoutSeconds</code>：探测的超时后等待多少秒。默认值是 1 秒。最小值是 1。</li>
<li><code>successThreshold</code>：探测器在失败后，被视为成功的最小连续成功数。默认值是 1。
存活和启动探测的这个值必须是 1。最小值是 1。</li>
<li><code>failureThreshold</code>：当探测失败时，Kubernetes 的重试次数。
存活探测情况下的放弃就意味着重新启动容器。
就绪探测情况下的放弃 Pod 会被打上未就绪的标签。默认值是 3。最小值是 1。</li>
</ul>
<p><div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>在 Kubernetes 1.20 版本之前，exec 探针会忽略 <code>timeoutSeconds</code>：探针会无限期地
持续运行，甚至可能超过所配置的限期，直到返回结果为止。</p>
<p>这一缺陷在 Kubernetes v1.20 版本中得到修复。你可能一直依赖于之前错误的探测行为，
甚至你都没有觉察到这一问题的存在，因为默认的超时值是 1 秒钟。
作为集群管理员，你可以在所有的 kubelet 上禁用 <code>ExecProbeTimeout</code>
<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
（将其设置为 <code>false</code>），从而恢复之前版本中的运行行为，之后当集群中所有的
exec 探针都设置了 <code>timeoutSeconds</code> 参数后，移除此标志重载。
如果你有 Pods 受到此默认 1 秒钟超时值的影响，你应该更新 Pod 对应的探针的
超时值，这样才能为最终去除该特性门控做好准备。</p>
<p>当此缺陷被修复之后，在使用 <code>dockershim</code> 容器运行时的 Kubernetes <code>1.20+</code>
版本中，对于 exec 探针而言，容器中的进程可能会因为超时值的设置保持持续运行，
即使探针返回了失败状态。</p>
</div>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong>
<p>如果就绪态探针的实现不正确，可能会导致容器中进程的数量不断上升。
如果不对其采取措施，很可能导致资源枯竭的状况。
</div>
</p>
<h3 id=http-probes>HTTP 探测 </h3>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#httpgetaction-v1-core>HTTP Probes</a>
可以在 <code>httpGet</code> 上配置额外的字段：</p>
<ul>
<li><code>host</code>：连接使用的主机名，默认是 Pod 的 IP。也可以在 HTTP 头中设置 “Host” 来代替。</li>
<li><code>scheme</code> ：用于设置连接主机的方式（HTTP 还是 HTTPS）。默认是 HTTP。</li>
<li><code>path</code>：访问 HTTP 服务的路径。默认值为 "/"。</li>
<li><code>httpHeaders</code>：请求中自定义的 HTTP 头。HTTP 头字段允许重复。</li>
<li><code>port</code>：访问容器的端口号或者端口名。如果数字必须在 1 ～ 65535 之间。</li>
</ul>
<p>对于 HTTP 探测，kubelet 发送一个 HTTP 请求到指定的路径和端口来执行检测。
除非 <code>httpGet</code> 中的 <code>host</code> 字段设置了，否则 kubelet 默认是给 Pod 的 IP 地址发送探测。
如果 <code>scheme</code> 字段设置为了 <code>HTTPS</code>，kubelet 会跳过证书验证发送 HTTPS 请求。
大多数情况下，不需要设置<code>host</code> 字段。
这里有个需要设置 <code>host</code> 字段的场景，假设容器监听 127.0.0.1，并且 Pod 的 <code>hostNetwork</code>
字段设置为了 <code>true</code>。那么 <code>httpGet</code> 中的 <code>host</code> 字段应该设置为 127.0.0.1。
可能更常见的情况是如果 Pod 依赖虚拟主机，你不应该设置 <code>host</code> 字段，而是应该在
<code>httpHeaders</code> 中设置 <code>Host</code>。</p>
<p>针对 HTTP 探针，kubelet 除了必需的 <code>Host</code> 头部之外还发送两个请求头部字段：
<code>User-Agent</code> 和 <code>Accept</code>。这些头部的默认值分别是 <code>kube-probe/{{ skew latestVersion >}}</code>
（其中 <code>1.26</code> 是 kubelet 的版本号）和 <code>*/*</code>。</p>
<p>你可以通过为探测设置 <code>.httpHeaders</code> 来重载默认的头部字段值；例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>Accept<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>application/json<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>startupProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>User-Agent<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>MyUserAgent<span style=color:#bbb>
</span></code></pre></div>
<p>你也可以通过将这些头部字段定义为空值，从请求中去掉这些头部字段。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>Accept<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>startupProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>User-Agent<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<h3 id=tcp-probes>TCP 探测 </h3>
<p>对于一次 TCP 探测，kubelet 在节点上（不是在 Pod 里面）建立探测连接，
这意味着你不能在 <code>host</code> 参数上配置服务名称，因为 kubelet 不能解析服务名称。</p>
<h3 id=探测器级别-terminationgraceperiodseconds>探测器级别 <code>terminationGracePeriodSeconds</code></h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code>
</div>
<p>在 1.21 及更高版本中，当特性门控 <code>ProbeTerminationGracePeriod</code> 为
启用状态时，用户可以指定一个探测级别的 <code>terminationGracePeriodSeconds</code> 作为
探针规格的一部分。当特性门控被启用时，并且
Pod 级和探针级的 <code>terminationGracePeriodSeconds</code> 都已设置，kubelet 将
使用探针级设置的值。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>从 Kubernetes 1.22 开始，<code>ProbeTerminationGracePeriod</code> 特性门控只
在 API 服务器上可用。 kubelet 始终遵守探针级别
<code>terminationGracePeriodSeconds</code> 字段（如果它存在于 Pod 上）。</p>
<p>如果你已经为现有 Pod 设置了 “terminationGracePeriodSeconds” 字段并且
不再希望使用针对每个探针的终止宽限期，则必须删除那些现有的 Pod。</p>
<p>当你（或控制平面或某些其他组件）创建替换
Pods，并且特性门控 “ProbeTerminationGracePeriod” 被禁用，那么
API 服务器会忽略 Pod 级别的 <code>terminationGracePeriodSeconds</code> 字段，即使
Pod 或 Pod 模板指定了它。</p>
</div>
<p>例如:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># pod-level</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Override pod-level terminationGracePeriodSeconds #</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></code></pre></div>
<p>探测器级别的 <code>terminationGracePeriodSeconds</code> 不能用于设置就绪态探针。
它将被 API 服务器拒绝。</p>
<h2 id=接下来>接下来</h2>
<ul>
<li>进一步了解<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>容器探针</a>。</li>
</ul>
<p>你也可以阅读以下的 API 参考资料：</p>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#pod-v1-core>Pod</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#container-v1-core>Container</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#probe-v1-core>Probe</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bbc17480da6d051c696489654c64064a>14 - 将 Pod 分配给节点</h1>
<p>此页面显示如何将 Kubernetes Pod 分配给 Kubernetes 集群中的特定节点。</p>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<h2 id=给节点添加标签>给节点添加标签</h2>
<ol>
<li>
<p>列出集群中的节点</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes
</code></pre></div>
<p>输出类似如下：</p>
<pre><code>NAME      STATUS    AGE     VERSION
worker0   Ready     1d      v1.6.0+fff5156
worker1   Ready     1d      v1.6.0+fff5156
worker2   Ready     1d      v1.6.0+fff5156
</code></pre></li>
</ol>
<ol start=2>
<li>
<p>选择其中一个节点，为它添加标签：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl label nodes &lt;your-node-name&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</code></pre></div>
<p><code>&lt;your-node-name></code> 是你选择的节点的名称。</p>
</li>
</ol>
<ol start=3>
<li>
<p>验证你选择的节点是否有 <code>disktype=ssd</code> 标签：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div>
<p>输出类似如下：</p>
<pre><code>NAME      STATUS    AGE     VERSION            LABELS
worker0   Ready     1d      v1.6.0+fff5156     ...,disktype=ssd,kubernetes.io/hostname=worker0
worker1   Ready     1d      v1.6.0+fff5156     ...,kubernetes.io/hostname=worker1
worker2   Ready     1d      v1.6.0+fff5156     ...,kubernetes.io/hostname=worker2
</code></pre>
<p>在前面的输出中，你可以看到 <code>worker0</code> 节点有 <code>disktype=ssd</code> 标签。</p>
</li>
</ol>
<h2 id=创建一个调度到你选择的节点的-pod>创建一个调度到你选择的节点的 pod</h2>
<p>此 Pod 配置文件描述了一个拥有节点选择器 <code>disktype: ssd</code> 的 Pod。这表明该 Pod 将被调度到
有 <code>disktype=ssd</code> 标签的节点。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/pod-nginx.yaml download=pods/pod-nginx.yaml><code>pods/pod-nginx.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-yaml')" title="Copy pods/pod-nginx.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>disktype</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>使用该配置文件去创建一个 pod，该 pod 将被调度到你选择的节点上：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/pod-nginx.yaml
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>验证 pod 是不是运行在你选择的节点上：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div>
<p>输出类似如下：</p>
<pre><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li>
</ol>
<h2 id=接下来>接下来</h2>
<p>进一步了解<a href=/zh/docs/concepts/overview/working-with-objects/labels/>标签和选择器</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fc3f4777ae8ea685d2b54e175277ac01>15 - 用节点亲和性把 Pods 分配到节点</h1>
<p>本页展示在 Kubernetes 集群中，如何使用节点亲和性把 Kubernetes Pod 分配到特定节点。</p>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
您的 Kubernetes 服务器版本必须不低于版本 v1.10.
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<h2 id=给节点添加标签>给节点添加标签</h2>
<ol>
<li>
<p>列出集群中的节点及其标签：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div>
<p>输出类似于此：</p>
<pre><code>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker2
</code></pre>
</li>
<li>
<p>选择一个节点，给它添加一个标签：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl label nodes &lt;your-node-name&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</code></pre></div>
<p>其中 <code>&lt;your-node-name></code> 是你所选节点的名称。</p>
</li>
<li>
<p>验证你所选节点具有 <code>disktype=ssd</code> 标签：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div>
<p>输出类似于此：</p>
<pre><code>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,disktype=ssd,kubernetes.io/hostname=worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker2
</code></pre>
<p>在前面的输出中，可以看到 <code>worker0</code> 节点有一个 <code>disktype=ssd</code> 标签。</p>
</li>
</ol>
<h2 id=schedule-a-Pod-using-required-node-affinity>依据强制的节点亲和性调度 Pod </h2>
<p>下面清单描述了一个 Pod，它有一个节点亲和性配置 <code>requiredDuringSchedulingIgnoredDuringExecution</code>，<code>disktype=ssd</code>。
这意味着 pod 只会被调度到具有 <code>disktype=ssd</code> 标签的节点上。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/pod-nginx-required-affinity.yaml download=pods/pod-nginx-required-affinity.yaml><code>pods/pod-nginx-required-affinity.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-required-affinity-yaml')" title="Copy pods/pod-nginx-required-affinity.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-required-affinity-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- ssd            <span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>执行（Apply）此清单来创建一个调度到所选节点上的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/pod-nginx-required-affinity.yaml
</code></pre></div>
</li>
<li>
<p>验证 pod 已经在所选节点上运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div>
<p>输出类似于此：</p>
<pre><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li>
</ol>
<h2 id=schedule-a-Pod-using-preferred-node-affinity>使用首选的节点亲和性调度 Pod</h2>
<p>本清单描述了一个Pod，它有一个节点亲和性设置 <code>preferredDuringSchedulingIgnoredDuringExecution</code>，<code>disktype: ssd</code>。
这意味着 pod 将首选具有 <code>disktype=ssd</code> 标签的节点。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/pod-nginx-preferred-affinity.yaml download=pods/pod-nginx-preferred-affinity.yaml><code>pods/pod-nginx-preferred-affinity.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-preferred-affinity-yaml')" title="Copy pods/pod-nginx-preferred-affinity.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-preferred-affinity-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>preference</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- ssd          <span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>执行此清单创建一个会调度到所选节点上的 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/pod-nginx-preferred-affinity.yaml
</code></pre></div>
</li>
<li>
<p>验证 pod 是否在所选节点上运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div>
<p>输出类似于此：</p>
<pre><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li>
</ol>
<h2 id=接下来>接下来</h2>
<p>进一步了解
<a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity>节点亲和性</a>.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1e7baac1825631a5af5d2aebcf059249>16 - 配置 Pod 初始化</h1>
<p>本文介绍在应用容器运行前，怎样利用 Init 容器初始化 Pod。</p>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<h2 id=creating-a-pod-that-has-an-init-container>创建一个包含 Init 容器的 Pod </h2>
<p>本例中你将创建一个包含一个应用容器和一个 Init 容器的 Pod。Init 容器在应用容器启动前运行完成。</p>
<p>下面是 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/init-containers.yaml download=pods/init-containers.yaml><code>pods/init-containers.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-init-containers-yaml')" title="Copy pods/init-containers.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-init-containers-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># These containers are run during pod initialization</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>install<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- wget<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-O&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/work-dir/index.html&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- http://info.cern.ch<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/work-dir&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>Default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>配置文件中，你可以看到应用容器和 Init 容器共享了一个卷。</p>
<p>Init 容器将共享卷挂载到了 <code>/work-dir</code> 目录，应用容器将共享卷挂载到了 <code>/usr/share/nginx/html</code> 目录。
Init 容器执行完下面的命令就终止：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget -O /work-dir/index.html http://info.cern.ch
</code></pre></div>
<p>请注意 Init 容器在 nginx 服务器的根目录写入 <code>index.html</code>。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/pods/init-containers.yaml
</code></pre></div>
<p>检查 nginx 容器运行正常：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod init-demo
</code></pre></div>
<p>结果表明 nginx 容器运行正常：</p>
<pre><code>NAME        READY     STATUS    RESTARTS   AGE
init-demo   1/1       Running   0          1m
</code></pre>
<p>通过 shell 进入 init-demo Pod 中的 nginx 容器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it init-demo -- /bin/bash
</code></pre></div>
<p>在 shell 中，发送个 GET 请求到 nginx 服务器：</p>
<pre><code>root@nginx:~# apt-get update
root@nginx:~# apt-get install curl
root@nginx:~# curl localhost
</code></pre>
<p>结果表明 nginx 正在为 Init 容器编写的 web 页面服务：</p>
<pre><code>&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt;
&lt;title&gt;http://info.cern.ch&lt;/title&gt;
&lt;/header&gt;

&lt;h1&gt;http://info.cern.ch - home of the first website&lt;/h1&gt;
  ...
&lt;li&gt;&lt;a href=&quot;http://info.cern.ch/hypertext/WWW/TheProject.html&quot;&gt;Browse the first website&lt;/a&gt;&lt;/li&gt;
  ...
</code></pre><h2 id=接下来>接下来</h2>
<ul>
<li>进一步了解<a href=/zh/docs/tasks/access-application-cluster/communicate-containers-same-pod-shared-volume/>同一 Pod 中的容器间的通信</a>。</li>
<li>进一步了解 <a href=/zh/docs/concepts/workloads/pods/init-containers/>Init 容器</a>。</li>
<li>进一步了解<a href=/zh/docs/concepts/storage/volumes/>卷</a>。</li>
<li>进一步了解 <a href=/zh/docs/tasks/debug-application-cluster/debug-init-containers/>Init 容器排错</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-efbc43486296f0439d1a89c12d944d94>17 - 为容器的生命周期事件设置处理函数</h1>
<p>这个页面将演示如何为容器的生命周期事件挂接处理函数。Kubernetes 支持 postStart 和 preStop 事件。
当一个容器启动后，Kubernetes 将立即发送 postStart 事件；在容器被终结之前，
Kubernetes 将发送一个 preStop 事件。容器可以为每个事件指定一个处理程序。</p>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<h2 id=定义-poststart-和-prestop-处理函数>定义 postStart 和 preStop 处理函数</h2>
<p>在本练习中，你将创建一个包含一个容器的 Pod，该容器为 postStart 和 preStop 事件提供对应的处理函数。</p>
<p>下面是对应 Pod 的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/lifecycle-events.yaml download=pods/lifecycle-events.yaml><code>pods/lifecycle-events.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-lifecycle-events-yaml')" title="Copy pods/lifecycle-events.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-lifecycle-events-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lifecycle-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lifecycle-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>postStart</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo Hello from the postStart handler &gt; /usr/share/message&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preStop</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#b44>&#34;nginx -s quit; while killall -0 nginx; do sleep 1; done&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>在上述配置文件中，你可以看到 postStart 命令在容器的 <code>/usr/share</code> 目录下写入文件 <code>message</code>。
命令 preStop 负责优雅地终止 nginx 服务。当因为失效而导致容器终止时，这一处理方式很有用。</p>
<p>创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/lifecycle-events.yaml
</code></pre></div>
<p>验证 Pod 中的容器已经运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod lifecycle-demo
</code></pre></div>
<p>使用 shell 连接到你的 Pod 里的容器：</p>
<pre><code>kubectl exec -it lifecycle-demo -- /bin/bash
</code></pre>
<p>在 shell 中，验证 <code>postStart</code> 处理函数创建了 <code>message</code> 文件：</p>
<pre><code>root@lifecycle-demo:/# cat /usr/share/message
</code></pre>
<p>命令行输出的是 <code>postStart</code> 处理函数所写入的文本</p>
<pre><code>Hello from the postStart handler
</code></pre>
<h2 id=讨论>讨论</h2>
<p>Kubernetes 在容器创建后立即发送 postStart 事件。
然而，postStart 处理函数的调用不保证早于容器的入口点（entrypoint）
的执行。postStart 处理函数与容器的代码是异步执行的，但 Kubernetes
的容器管理逻辑会一直阻塞等待 postStart 处理函数执行完毕。
只有 postStart 处理函数执行完毕，容器的状态才会变成
RUNNING。</p>
<p>Kubernetes 在容器结束前立即发送 preStop 事件。除非 Pod 宽限期限超时，Kubernetes 的容器管理逻辑
会一直阻塞等待 preStop 处理函数执行完毕。更多的相关细节，可以参阅
<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>Pods 的结束</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> Kubernetes 只有在 Pod <em>结束（Terminated）</em> 的时候才会发送 preStop 事件，
这意味着在 Pod <em>完成（Completed）</em> 时
preStop 的事件处理逻辑不会被触发。这个限制在
<a href=https://github.com/kubernetes/kubernetes/issues/55807>issue #55087</a> 中被追踪。
</div>
<h2 id=接下来>接下来</h2>
<ul>
<li>进一步了解<a href=/zh/docs/concepts/containers/container-lifecycle-hooks/>容器生命周期回调</a>。</li>
<li>进一步了解<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/>Pod 的生命周期</a>。</li>
</ul>
<h3 id=参考>参考</h3>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#lifecycle-v1-core>Lifecycle</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#container-v1-core>Container</a></li>
<li>参阅 <a href=/docs/reference/generated/kubernetes-api/v1.22/#podspec-v1-core>PodSpec</a> 中关于<code>terminationGracePeriodSeconds</code> 的部分</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ed34e761c3dbd00fa79577fa78e30020>18 - 配置 Pod 使用 ConfigMap</h1>
<p>ConfigMap 允许你将配置文件与镜像文件分离，以使容器化的应用程序具有可移植性。
本页提供了一系列使用示例，这些示例演示了如何创建 ConfigMap 以及配置 Pod
使用存储在 ConfigMap 中的数据。</p>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<h2 id=创建-configmap>创建 ConfigMap</h2>
<p>你可以使用 <code>kubectl create configmap</code> 或者在 <code>kustomization.yaml</code> 中的 ConfigMap 生成器
来创建 ConfigMap。注意，<code>kubectl</code> 从 1.14 版本开始支持 <code>kustomization.yaml</code>。</p>
<h3 id=使用-kubectl-create-configmap-创建-configmap>使用 kubectl create configmap 创建 ConfigMap</h3>
<p>你可以使用 <code>kubectl create configmap</code> 命令基于
<a href=#create-configmaps-from-directories>目录</a>、<a href=#create-configmaps-from-files>文件</a>
或者<a href=#create-configmaps-from-literal-values>字面值</a>来创建 ConfigMap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap &lt;map-name&gt; &lt;data-source&gt;
</code></pre></div>
<p>其中，&lt;map-name> 是要设置的 ConfigMap 名称，&lt;data-source> 是要从中提取数据的目录、
文件或者字面值。
ConfigMap 对象的名称必须是合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>.</p>
<p>在你基于文件来创建 ConfigMap 时，&lt;data-source> 中的键名默认取自
文件的基本名，而对应的值则默认为文件的内容。</p>
<p>你可以使用<a href=/docs/reference/generated/kubectl/kubectl-commands/#describe><code>kubectl describe</code></a> 或者
<a href=/docs/reference/generated/kubectl/kubectl-commands/#get><code>kubectl get</code></a> 获取有关 ConfigMap 的信息。</p>
<h4 id=create-configmaps-from-directories>基于目录创建 ConfigMap </h4>
<p>你可以使用 <code>kubectl create configmap</code> 基于同一目录中的多个文件创建 ConfigMap。
当你基于目录来创建 ConfigMap 时，kubectl 识别目录下基本名可以作为合法键名的
文件，并将这些文件打包到新的 ConfigMap 中。普通文件之外的所有目录项都会被
忽略（例如，子目录、符号链接、设备、管道等等）。</p>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建本地目录</span>
mkdir -p configure-pod-container/configmap/

<span style=color:#080;font-style:italic># 将实例文件下载到 `configure-pod-container/configmap/` 目录</span>
wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.properties
wget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.properties

<span style=color:#080;font-style:italic># 创建 configmap</span>
kubectl create configmap game-config --from-file<span style=color:#666>=</span>configure-pod-container/configmap/
</code></pre></div>
<p>以上命令将 <code>configure-pod-container/configmap</code> 目录下的所有文件，也就是
<code>game.properties</code> 和 <code>ui.properties</code> 打包到 game-config ConfigMap
中。你可以使用下面的命令显示 ConfigMap 的详细信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe configmaps game-config
</code></pre></div>
<p>输出类似以下内容：</p>
<pre><code>Name:         game-config
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
ui.properties:
----
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
</code></pre>
<p><code>configure-pod-container/configmap/</code> 目录中的 <code>game.properties</code> 和 <code>ui.properties</code>
文件出现在 ConfigMap 的 <code>data</code> 部分。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmaps game-config -o yaml
</code></pre></div>
<p>输出类似以下内容:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T18:52:05Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;516&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/configmaps/game-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>b4952dc3-d670-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    enemies=aliens
</span><span style=color:#b44;font-style:italic>    lives=3
</span><span style=color:#b44;font-style:italic>    enemies.cheat=true
</span><span style=color:#b44;font-style:italic>    enemies.cheat.level=noGoodRotten
</span><span style=color:#b44;font-style:italic>    secret.code.passphrase=UUDDLRLRBABAS
</span><span style=color:#b44;font-style:italic>    secret.code.allowed=true
</span><span style=color:#b44;font-style:italic>    secret.code.lives=30</span><span style=color:#bbb>    
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    color.good=purple
</span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span><span style=color:#b44;font-style:italic>    allow.textmode=true
</span><span style=color:#b44;font-style:italic>    how.nice.to.look=fairlyNice</span><span style=color:#bbb>    
</span></code></pre></div>
<h4 id=create-configmaps-from-files>基于文件创建 ConfigMap </h4>
<p>你可以使用 <code>kubectl create configmap</code> 基于单个文件或多个文件创建 ConfigMap。</p>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-2 --from-file<span style=color:#666>=</span>configure-pod-container/configmap/game.properties
</code></pre></div>
<p>将产生以下 ConfigMap:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe configmaps game-config-2
</code></pre></div>
<p>输出类似以下内容:</p>
<pre><code>Name:         game-config-2
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
</code></pre>
<p>你可以多次使用 <code>--from-file</code> 参数，从多个数据源创建 ConfigMap。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-2 --from-file<span style=color:#666>=</span>configure-pod-container/configmap/game.properties --from-file<span style=color:#666>=</span>configure-pod-container/configmap/ui.properties
</code></pre></div>
<p>描述上面创建的 <code>game-config-2</code> configmap</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe configmaps game-config-2
</code></pre></div>
<p>输出类似以下内容:</p>
<pre><code>Name:         game-config-2
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
ui.properties:
----
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
</code></pre>
<p>当 <code>kubectl</code> 基于非 ASCII 或 UTF-8 的输入创建 ConfigMap 时，
该工具将这些输入放入 ConfigMap 的 <code>binaryData</code> 字段，而不是 <code>data</code> 中。
同一个 ConfigMap 中可同时包含文本数据和二进制数据源。
如果你想查看 ConfigMap 中的 <code>binaryData</code> 键（及其值），
你可以运行 <code>kubectl get configmap -o jsonpath='{.binaryData}' &lt;name></code>。</p>
<p>使用 <code>--from-env-file</code> 选项从环境文件创建 ConfigMap，例如：</p>
<p>Env 文件包含环境变量列表。
其中适用以下语法规则:</p>
<ul>
<li>Env 文件中的每一行必须为 VAR=VAL 格式。</li>
<li>以＃开头的行（即注释）将被忽略。</li>
<li>空行将被忽略。</li>
<li>引号不会被特殊处理（即它们将成为 ConfigMap 值的一部分）。</li>
</ul>
<p>将示例文件下载到 <code>configure-pod-container/configmap/</code> 目录</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget https://kubernetes.io/examples/configmap/game-env-file.properties -O configure-pod-container/configmap/game-env-file.properties
</code></pre></div><p>env 文件 <code>game-env-file.properties</code> 如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat configure-pod-container/configmap/game-env-file.properties
</code></pre></div><pre><code>enemies=aliens
lives=3
allowed=&quot;true&quot;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-env-file <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>       --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/game-env-file.properties
</code></pre></div>
<p>将产生以下 ConfigMap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmap game-config-env-file -o yaml
</code></pre></div>
<p>输出类似以下内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-12-27T18:36:28Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config-env-file<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;809965&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/configmaps/game-config-env-file<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>d9d1ca5b-eb34-11e7-887b-42010a8002b8<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;&#34;true&#34;&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>enemies</span>:<span style=color:#bbb> </span>aliens<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong> 当多次使用 <code>--from-env-file</code> 来从多个数据源创建 ConfigMap 时，仅仅最后一个 env 文件有效。
</div>
<p>下面是一个多次使用 <code>--from-env-file</code> 参数的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 将样本文件下载到 `configure-pod-container/configmap/` 目录</span>
wget https://k8s.io/examples/configmap/ui-env-file.properties -O configure-pod-container/configmap/ui-env-file.properties

<span style=color:#080;font-style:italic># 创建 configmap</span>
kubectl create configmap config-multi-env-files <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/game-env-file.properties <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/ui-env-file.properties
</code></pre></div>
<p>将产生以下 ConfigMap:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmap config-multi-env-files -o yaml
</code></pre></div>
<p>输出类似以下内容:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-12-27T18:38:34Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-multi-env-files<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;810136&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/configmaps/config-multi-env-files<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>252c4572-eb35-11e7-887b-42010a8002b8<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>color</span>:<span style=color:#bbb> </span>purple<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>how</span>:<span style=color:#bbb> </span>fairlyNice<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>textmode</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<h4 id=定义从文件创建-configmap-时要使用的键>定义从文件创建 ConfigMap 时要使用的键</h4>
<p>在使用 <code>--from-file</code> 参数时，你可以定义在 ConfigMap 的 <code>data</code> 部分出现键名，
而不是按默认行为使用文件名：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-3 --from-file<span style=color:#666>=</span>&lt;my-key-name&gt;<span style=color:#666>=</span>&lt;path-to-file&gt;
</code></pre></div>
<p><code>&lt;my-key-name></code> 是你要在 ConfigMap 中使用的键名，<code>&lt;path-to-file></code> 是你想要键表示数据源文件的位置。</p>
<p>例如:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-3 --from-file<span style=color:#666>=</span>game-special-key<span style=color:#666>=</span>configure-pod-container/configmap/game.properties
</code></pre></div>
<p>将产生以下 ConfigMap:</p>
<pre><code>kubectl get configmaps game-config-3 -o yaml
</code></pre>
<p>输出类似以下内容：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T18:54:22Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config-3<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;530&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/configmaps/game-config-3<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>05f8da22-d671-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game-special-key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    enemies=aliens
</span><span style=color:#b44;font-style:italic>    lives=3
</span><span style=color:#b44;font-style:italic>    enemies.cheat=true
</span><span style=color:#b44;font-style:italic>    enemies.cheat.level=noGoodRotten
</span><span style=color:#b44;font-style:italic>    secret.code.passphrase=UUDDLRLRBABAS
</span><span style=color:#b44;font-style:italic>    secret.code.allowed=true
</span><span style=color:#b44;font-style:italic>    secret.code.lives=30</span><span style=color:#bbb>    
</span></code></pre></div>
<h4 id=create-configmaps-from-literal-values>根据字面值创建 ConfigMap </h4>
<p>你可以将 <code>kubectl create configmap</code> 与 <code>--from-literal</code> 参数一起使用，从命令行定义文字值:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap special-config --from-literal<span style=color:#666>=</span>special.how<span style=color:#666>=</span>very --from-literal<span style=color:#666>=</span>special.type<span style=color:#666>=</span>charm
</code></pre></div>
<p>你可以传入多个键值对。命令行中提供的每对键值在 ConfigMap 的 <code>data</code> 部分中均表示为单独的条目。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmaps special-config -o yaml
</code></pre></div>
<p>输出类似以下内容:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T19:14:38Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;651&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/configmaps/special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>dadce046-d673-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.how</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.type</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></code></pre></div>
<h3 id=基于生成器创建-configmap>基于生成器创建 ConfigMap</h3>
<p>自 1.14 开始，<code>kubectl</code> 开始支持 <code>kustomization.yaml</code>。
你还可以基于生成器创建 ConfigMap，然后将其应用于 API 服务器上创建对象。
生成器应在目录内的 <code>kustomization.yaml</code> 中指定。</p>
<h4 id=基于文件生成-configmap>基于文件生成 ConfigMap</h4>
<p>例如，要从 <code>configure-pod-container/configmap/kubectl/game.properties</code> 文件生成一个 ConfigMap：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建包含 ConfigMapGenerator 的 kustomization.yaml 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: game-config-4
</span><span style=color:#b44>  files:
</span><span style=color:#b44>  - configure-pod-container/configmap/kubectl/game.properties
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>使用 kustomization 目录创建 ConfigMap 对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
</code></pre></div><pre><code>configmap/game-config-4-m9dm2f92bt created
</code></pre>
<p>你可以检查 ConfigMap 是这样创建的:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmap
</code></pre></div><pre><code>NAME                       DATA   AGE
game-config-4-m9dm2f92bt   1      37s


kubectl describe configmaps/game-config-4-m9dm2f92bt
Name:         game-config-4-m9dm2f92bt
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                {&quot;apiVersion&quot;:&quot;v1&quot;,&quot;data&quot;:{&quot;game.properties&quot;:&quot;enemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.p...

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
Events:  &lt;none&gt;
</code></pre>
<p>请注意，生成的 ConfigMap 名称具有通过对内容进行散列而附加的后缀，
这样可以确保每次修改内容时都会生成新的 ConfigMap。</p>
<h4 id=定义从文件生成-configmap-时要使用的键>定义从文件生成 ConfigMap 时要使用的键</h4>
<p>在 ConfigMap 生成器，你可以定义一个非文件名的键名。
例如，从 <code>configure-pod-container/configmap/game.properties</code> 文件生成 ConfigMap，
但使用 <code>game-special-key</code> 作为键名：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建包含 ConfigMapGenerator 的 kustomization.yaml 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: game-config-5
</span><span style=color:#b44>  files:
</span><span style=color:#b44>  - game-special-key=configure-pod-container/configmap/kubectl/game.properties
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>使用 Kustomization 目录创建 ConfigMap 对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
</code></pre></div><pre><code>configmap/game-config-5-m67dt67794 created
</code></pre>
<h4 id=从字面值生成-configmap>从字面值生成 ConfigMap</h4>
<p>要基于字符串 <code>special.type=charm</code> 和 <code>special.how=very</code> 生成 ConfigMap，
可以在 <code>kusotmization.yaml</code> 中配置 ConfigMap 生成器：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 创建带有 ConfigMapGenerator 的 kustomization.yaml 文件</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: special-config-2
</span><span style=color:#b44>  literals:
</span><span style=color:#b44>  - special.how=very
</span><span style=color:#b44>  - special.type=charm
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>应用 Kustomization 目录创建 ConfigMap 对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
</code></pre></div><pre><code>configmap/special-config-2-c92b5mmcf2 created
</code></pre>
<h2 id=使用-configmap-数据定义容器环境变量>使用 ConfigMap 数据定义容器环境变量</h2>
<h3 id=使用单个-configmap-中的数据定义容器环境变量>使用单个 ConfigMap 中的数据定义容器环境变量</h3>
<ol>
<li>
<p>在 ConfigMap 中将环境变量定义为键值对:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap special-config --from-literal<span style=color:#666>=</span>special.how<span style=color:#666>=</span>very
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>将 ConfigMap 中定义的 <code>special.how</code> 值分配给 Pod 规范中的 <code>SPECIAL_LEVEL_KEY</code> 环境变量。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/pod-single-configmap-env-variable.yaml download=pods/pod-single-configmap-env-variable.yaml><code>pods/pod-single-configmap-env-variable.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-single-configmap-env-variable-yaml')" title="Copy pods/pod-single-configmap-env-variable.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-single-configmap-env-variable-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Define the environment variable</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:#080;font-style:italic># The ConfigMap containing the value you want to assign to SPECIAL_LEVEL_KEY</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:#080;font-style:italic># Specify the key associated with the value</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>special.how<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-single-configmap-env-variable.yaml
</code></pre></div>
<p>现在，Pod 的输出包含环境变量 <code>SPECIAL_LEVEL_KEY=very</code>。</p>
</li>
</ol>
<h3 id=使用来自多个-configmap-的数据定义容器环境变量>使用来自多个 ConfigMap 的数据定义容器环境变量</h3>
<ul>
<li>
<p>与前面的示例一样，首先创建 ConfigMap。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/configmap/configmaps.yaml download=configmap/configmaps.yaml><code>configmap/configmaps.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('configmap-configmaps-yaml')" title="Copy configmap/configmaps.yaml to clipboard">
</img>
</div>
<div class=includecode id=configmap-configmaps-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.how</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>log_level</span>:<span style=color:#bbb> </span>INFO<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 ConfigMap:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/configmap/configmaps.yaml
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在 Pod 规范中定义环境变量。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/pod-multiple-configmap-env-variable.yaml download=pods/pod-multiple-configmap-env-variable.yaml><code>pods/pod-multiple-configmap-env-variable.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-multiple-configmap-env-variable-yaml')" title="Copy pods/pod-multiple-configmap-env-variable.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-multiple-configmap-env-variable-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>special.how<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>LOG_LEVEL<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-multiple-configmap-env-variable.yaml
</code></pre></div>
<p>现在，Pod 的输出包含环境变量 <code>SPECIAL_LEVEL_KEY=very</code> 和 <code>LOG_LEVEL=INFO</code>。</p>
</li>
</ul>
<h2 id=将-configmap-中的所有键值对配置为容器环境变量>将 ConfigMap 中的所有键值对配置为容器环境变量</h2>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> Kubernetes v1.6 和更高版本支持此功能。
</div>
<ul>
<li>
<p>创建一个包含多个键值对的 ConfigMap。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/configmap/configmap-multikeys.yaml download=configmap/configmap-multikeys.yaml><code>configmap/configmap-multikeys.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('configmap-configmap-multikeys-yaml')" title="Copy configmap/configmap-multikeys.yaml to clipboard">
</img>
</div>
<div class=includecode id=configmap-configmap-multikeys-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_LEVEL</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_TYPE</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 ConfigMap:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml
</code></pre></div></li>
</ul>
<ul>
<li>
<p>使用 <code>envFrom</code> 将所有 ConfigMap 的数据定义为容器环境变量，ConfigMap 中的键成为 Pod 中的环境变量名称。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/pod-configmap-envFrom.yaml download=pods/pod-configmap-envFrom.yaml><code>pods/pod-configmap-envFrom.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-envfrom-yaml')" title="Copy pods/pod-configmap-envFrom.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-envfrom-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMapRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-envFrom.yaml
</code></pre></div>
<p>现在，Pod 的输出包含环境变量 <code>SPECIAL_LEVEL=very</code> 和 <code>SPECIAL_TYPE=charm</code>。</p>
</li>
</ul>
<h2 id=在-pod-命令中使用-configmap-定义的环境变量>在 Pod 命令中使用 ConfigMap 定义的环境变量</h2>
<p>你可以使用 <code>$(VAR_NAME)</code> Kubernetes 替换语法在容器的 <code>command</code> 和 <code>args</code> 部分中使用 ConfigMap 定义的环境变量。</p>
<p>例如，以下 Pod 规范</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/pod-configmap-env-var-valueFrom.yaml download=pods/pod-configmap-env-var-valueFrom.yaml><code>pods/pod-configmap-env-var-valueFrom.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-env-var-valuefrom-yaml')" title="Copy pods/pod-configmap-env-var-valueFrom.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-env-var-valuefrom-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_TYPE_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_TYPE<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>通过运行下面命令创建 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-env-var-valueFrom.yaml
</code></pre></div>
<p>在 <code>test-container</code> 容器中产生以下输出:</p>
<pre><code>very charm
</code></pre>
<h2 id=将-configmap-数据添加到一个卷中>将 ConfigMap 数据添加到一个卷中</h2>
<p>如基于文件创建 <a href=#create-configmaps-from-files>ConfigMap</a> 中所述，当你使用
<code>--from-file</code> 创建 ConfigMap 时，文件名成为存储在 ConfigMap 的 <code>data</code> 部分中的键，
文件内容成为键对应的值。</p>
<p>本节中的示例引用了一个名为 special-config 的 ConfigMap，如下所示：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/configmap/configmap-multikeys.yaml download=configmap/configmap-multikeys.yaml><code>configmap/configmap-multikeys.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('configmap-configmap-multikeys-yaml')" title="Copy configmap/configmap-multikeys.yaml to clipboard">
</img>
</div>
<div class=includecode id=configmap-configmap-multikeys-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_LEVEL</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_TYPE</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 ConfigMap:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml
</code></pre></div>
<h3 id=使用存储在-configmap-中的数据填充数据卷>使用存储在 ConfigMap 中的数据填充数据卷</h3>
<p>在 Pod 规约的 <code>volumes</code> 部分下添加 ConfigMap 名称。
这会将 ConfigMap 数据添加到指定为 <code>volumeMounts.mountPath</code> 的目录（在本例中为 <code>/etc/config</code>）。
<code>command</code> 部分引用存储在 ConfigMap 中的 <code>special.level</code>。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/pod-configmap-volume.yaml download=pods/pod-configmap-volume.yaml><code>pods/pod-configmap-volume.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-volume-yaml')" title="Copy pods/pod-configmap-volume.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-volume-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;ls /etc/config/&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Provide the name of the ConfigMap containing the files you want</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># to add to the container</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume.yaml
</code></pre></div>
<p>Pod 运行时，命令 <code>ls /etc/config/</code> 产生下面的输出：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>SPECIAL_LEVEL
SPECIAL_TYPE
</code></pre></div>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong> 如果在 <code>/etc/config/</code> 目录中有一些文件，它们将被删除。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 文本数据会使用 UTF-8 字符编码的形式展现为文件。如果使用其他字符编码，
可以使用 <code>binaryData</code>。
</div>
<h3 id=将-configmap-数据添加到数据卷中的特定路径>将 ConfigMap 数据添加到数据卷中的特定路径</h3>
<p>使用 <code>path</code> 字段为特定的 ConfigMap 项目指定预期的文件路径。
在这里，ConfigMap中，键值 <code>SPECIAL_LEVEL</code> 的内容将挂载在 <code>config-volume</code> 数据卷中 <code>/etc/config/keys</code> 文件下。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/pod-configmap-volume-specific-key.yaml download=pods/pod-configmap-volume-specific-key.yaml><code>pods/pod-configmap-volume-specific-key.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-volume-specific-key-yaml')" title="Copy pods/pod-configmap-volume-specific-key.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-volume-specific-key-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#b44>&#34;cat /etc/config/keys&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>keys<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>创建Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume-specific-key.yaml
</code></pre></div>
<p>当 pod 运行时，命令 <code>cat /etc/config/keys</code> 产生以下输出：</p>
<pre><code>very
</code></pre>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong> 如前，<code>/etc/config/</code> 目录中所有先前的文件都将被删除。
</div>
<h3 id=映射键以指定路径和文件权限>映射键以指定路径和文件权限</h3>
<p>你可以通过指定键名到特定目录的投射关系，也可以逐个文件地设定访问权限。
<a href=/zh/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod>Secret 用户指南</a>
中对这一语法提供了解释。</p>
<h3 id=挂载的-configmap-将自动更新>挂载的 ConfigMap 将自动更新</h3>
<p>更新已经在数据卷中使用的 ConfigMap 时，已映射的键最终也会被更新。
<code>kubelet</code> 在每次定期同步时都会检查已挂载的 ConfigMap 是否是最新的。
但是，它使用其本地的基于 TTL 的缓存来获取 ConfigMap 的当前值。
因此，从更新 ConfigMap 到将新键映射到 Pod 的总延迟可能与
kubelet 同步周期 + ConfigMap 在 kubelet 中缓存的 TTL 一样长。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 使用 ConfigMap 作为 <a href=/zh/docs/concepts/storage/volumes/#using-subpath>subPath</a>
的数据卷将不会收到 ConfigMap 更新。
</div>
<h2 id=了解-configmap-和-pod>了解 ConfigMap 和 Pod</h2>
<p>ConfigMap API 资源将配置数据存储为键值对。
数据可以在 Pod 中使用，也可以提供系统组件（如控制器）的配置。
ConfigMap 与 <a href=/zh/docs/concepts/configuration/secret/>Secret</a> 类似，
但是提供了一种使用不包含敏感信息的字符串的方法。
用户和系统组件都可以在 ConfigMap 中存储配置数据。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> ConfigMap 应该引用属性文件，而不是替换它们。可以将 ConfigMap 理解为类似于 Linux
<code>/etc</code> 目录及其内容的东西。例如，如果你从 ConfigMap 创建
<a href=/zh/docs/concepts/storage/volumes/>Kubernetes 卷</a>，则 ConfigMap
中的每个数据项都由该数据卷中的单个文件表示。
</div>
<p>ConfigMap 的 <code>data</code> 字段包含配置数据。如下例所示，它可以简单
（如用 <code>--from-literal</code> 的单个属性定义）或复杂
（如用 <code>--from-file</code> 的配置文件或 JSON blob定义）。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T19:14:38Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 使用 --from-literal 定义的简单属性</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.1</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.2</span>:<span style=color:#bbb> </span>world<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 使用 --from-file 定义复杂属性的例子</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.file</span>:<span style=color:#bbb> </span>|-<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    property.1=value-1
</span><span style=color:#b44;font-style:italic>    property.2=value-2
</span><span style=color:#b44;font-style:italic>    property.3=value-3</span><span style=color:#bbb>    
</span></code></pre></div>
<h3 id=限制>限制</h3>
<ul>
<li>在 Pod 规范中引用之前，必须先创建一个 ConfigMap（除非将 ConfigMap 标记为"可选"）。
如果引用的 ConfigMap 不存在，则 Pod 将不会启动。同样，引用 ConfigMap 中不存在的键也会阻止 Pod 启动。</li>
</ul>
<ul>
<li>
<p>如果你使用 <code>envFrom</code> 基于 ConfigMap 定义环境变量，那么无效的键将被忽略。
可以启动 Pod，但无效名称将记录在事件日志中（<code>InvalidVariableNames</code>）。
日志消息列出了每个跳过的键。例如:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events
</code></pre></div>
<p>输出与此类似:</p>
<pre><code>LASTSEEN FIRSTSEEN COUNT NAME          KIND  SUBOBJECT  TYPE      REASON                            SOURCE                MESSAGE
0s       0s        1     dapi-test-pod Pod              Warning   InvalidEnvironmentVariableNames   {kubelet, 127.0.0.1}  Keys [1badkey, 2alsobad] from the EnvFrom configMap default/myconfig were skipped since they are considered invalid environment variable names.
</code></pre></li>
</ul>
<ul>
<li>ConfigMap 位于特定的<a class=glossary-tooltip title="名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a>
中。每个 ConfigMap 只能被同一名字空间中的 Pod 引用.</li>
</ul>
<ul>
<li>你不能将 ConfigMap 用于 <a class=glossary-tooltip title="静态Pod（Static Pod）是指由特定节点上的 kubelet 守护进程直接管理的 Pod。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label="静态 Pod">静态 Pod</a>，
因为 Kubernetes 不支持这种用法。</li>
</ul>
<h2 id=接下来>接下来</h2>
<ul>
<li>浏览<a href=/zh/docs/tutorials/configuration/configure-redis-using-configmap/>使用 ConfigMap 配置 Redis</a>
真实实例</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3d7b9cb24a647c36ba63f7a02ec49010>19 - 在 Pod 中的容器之间共享进程命名空间</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>
<p>此页面展示如何为 pod 配置进程命名空间共享。
当启用进程命名空间共享时，容器中的进程对该 pod 中的所有其他容器都是可见的。</p>
<p>您可以使用此功能来配置协作容器，比如日志处理 sidecar 容器，或者对那些不包含诸如 shell 等调试实用工具的镜像进行故障排查。</p>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
您的 Kubernetes 服务器版本必须不低于版本 v1.10.
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<h2 id=配置-pod>配置 Pod</h2>
<p>进程命名空间共享使用 <code>v1.PodSpec</code> 中的 <code>ShareProcessNamespace</code> 字段启用。例如：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/pods/share-process-namespace.yaml download=pods/share-process-namespace.yaml><code>pods/share-process-namespace.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-share-process-namespace-yaml')" title="Copy pods/share-process-namespace.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-share-process-namespace-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>shareProcessNamespace</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>capabilities</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>add</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- SYS_PTRACE<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stdin</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tty</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>在集群中创建 <code>nginx</code> pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/share-process-namespace.yaml
</code></pre></div></li>
<li>
<p>获取容器 <code>shell</code>，执行 <code>ps</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl attach -it nginx -c shell
</code></pre></div><p>如果没有看到命令提示符，请按 enter 回车键。</p>
<pre><code>/ # ps ax
PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    8 root      0:00 nginx: master process nginx -g daemon off;
   14 101       0:00 nginx: worker process
   15 root      0:00 sh
   21 root      0:00 ps ax
</code></pre></li>
</ol>
<p>您可以在其他容器中对进程发出信号。例如，发送 <code>SIGHUP</code> 到 nginx 以重启工作进程。这需要 <code>SYS_PTRACE</code> 功能。</p>
<pre><code>/ # kill -HUP 8
/ # ps ax
PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    8 root      0:00 nginx: master process nginx -g daemon off;
   15 root      0:00 sh
   22 101       0:00 nginx: worker process
   23 root      0:00 ps ax
</code></pre>
<p>甚至可以使用 <code>/proc/$pid/root</code> 链接访问另一个容器镜像。</p>
<pre><code>/ # head /proc/8/root/etc/nginx/nginx.conf

user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
</code></pre>
<h2 id=理解进程命名空间共享>理解进程命名空间共享</h2>
<p>Pod 共享许多资源，因此它们共享进程命名空间是很有意义的。
不过，有些容器镜像可能希望与其他容器隔离，因此了解这些差异很重要:</p>
<ol>
<li>
<p><strong>容器进程不再具有 PID 1。</strong> 在没有 PID 1 的情况下，一些容器镜像拒绝启动（例如，使用 <code>systemd</code> 的容器)，或者拒绝执行 <code>kill -HUP 1</code> 之类的命令来通知容器进程。在具有共享进程命名空间的 pod 中，<code>kill -HUP 1</code> 将通知 pod 沙箱（在上面的例子中是 <code>/pause</code>）。</p>
</li>
<li>
<p><strong>进程对 pod 中的其他容器可见。</strong> 这包括 <code>/proc</code> 中可见的所有信息，例如作为参数或环境变量传递的密码。这些仅受常规 Unix 权限的保护。</p>
</li>
<li>
<p><strong>容器文件系统通过 <code>/proc/$pid/root</code> 链接对 pod 中的其他容器可见。</strong> 这使调试更加容易，但也意味着文件系统安全性只受文件系统权限的保护。</p>
</li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-42a59b878d4c58e5c6f4bb87483dda93>20 - 创建静态 Pod</h1>
<p><em>静态 Pod</em> 在指定的节点上由 kubelet 守护进程直接管理，不需要
<a class=glossary-tooltip title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank aria-label="API 服务器">API 服务器</a> 监管。
与由控制面管理的 Pod（例如，<a class=glossary-tooltip title="Deployment 是管理应用副本的 API 对象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>）
不同；kubelet 监视每个静态 Pod（在它崩溃之后重新启动）。</p>
<p>静态 Pod 永远都会绑定到一个指定节点上的 <a class=glossary-tooltip title="一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。" data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>。</p>
<p>kubelet 会尝试通过 Kubernetes API 服务器为每个静态 Pod 自动创建一个
<a class=glossary-tooltip title="API 服务器中的一个对象，用于跟踪 kubelet 上的静态 pod。" data-toggle=tooltip data-placement=top href="/zh/docs/reference/glossary/?all=true#term-mirror-pod" target=_blank aria-label="镜像 Pod">镜像 Pod</a>。
这意味着节点上运行的静态 Pod 对 API 服务来说是可见的，但是不能通过 API 服务器来控制。
Pod 名称将把以连字符开头的节点主机名作为后缀。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 如果你在运行一个 Kubernetes 集群，并且在每个节点上都运行一个静态 Pod，
就可能需要考虑使用 <a class=glossary-tooltip title="确保 Pod 的副本在集群中的一组节点上运行。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/daemonset/ target=_blank aria-label=DaemonSet>DaemonSet</a> 替代这种方式。
</div>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<p>本文假定你在使用 <a class=glossary-tooltip title="Docker 是一种可以提供操作系统级别虚拟化（也称作容器）的软件技术。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/kubectl/docker-cli-to-kubectl/ target=_blank aria-label=Docker>Docker</a> 来运行 Pod，
并且你的节点是运行着 Fedora 操作系统。
其它发行版或者 Kubernetes 部署版本上操作方式可能不一样。</p>
<h2 id=static-pod-creation>创建静态 Pod</h2>
<p>可以通过<a href=/zh/docs/tasks/configure-pod-container/static-pod/#configuration-files>文件系统上的配置文件</a>
或者 <a href=/zh/docs/tasks/configure-pod-container/static-pod/#pods-created-via-http>web 网络上的配置文件</a>
来配置静态 Pod。</p>
<h3 id=configuration-files>文件系统上的静态 Pod 声明文件</h3>
<p>声明文件是标准的 Pod 定义文件，以 JSON 或者 YAML 格式存储在指定目录。路径设置在
<a href=/zh/docs/reference/config-api/kubelet-config.v1beta1/>Kubelet 配置文件</a>
的 <code>staticPodPath: &lt;目录></code> 字段，kubelet 会定期的扫描这个文件夹下的 YAML/JSON
文件来创建/删除静态 Pod。
注意 kubelet 扫描目录的时候会忽略以点开头的文件。</p>
<p>例如：下面是如何以静态 Pod 的方式启动一个简单 web 服务：</p>
<ol>
<li>
<p>选择一个要运行静态 Pod 的节点。在这个例子中选择 <code>my-node1</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ssh my-node1
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>选择一个目录，比如在 <code>/etc/kubelet.d</code> 目录来保存 web 服务 Pod 的定义文件，
<code>/etc/kubelet.d/static-web.yaml</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
mkdir /etc/kubelet.d/
cat <span style=color:#b44>&lt;&lt;EOF &gt;/etc/kubelet.d/static-web.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: static-web
</span><span style=color:#b44>  labels:
</span><span style=color:#b44>    role: myrole
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: web
</span><span style=color:#b44>      image: nginx
</span><span style=color:#b44>      ports:
</span><span style=color:#b44>        - name: web
</span><span style=color:#b44>          containerPort: 80
</span><span style=color:#b44>          protocol: TCP
</span><span style=color:#b44>EOF</span>
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>配置这个节点上的 kubelet，使用这个参数执行 <code>--pod-manifest-path=/etc/kubelet.d/</code>。
在 Fedora 上编辑 <code>/etc/kubernetes/kubelet</code> 以包含下行：</p>
<pre><code>KUBELET_ARGS=&quot;--cluster-dns=10.254.0.10 --cluster-domain=kube.local --pod-manifest-path=/etc/kubelet.d/&quot;
</code></pre><p>或者在 <a href=/zh/docs/reference/config-api/kubelet-config.v1beta1/>Kubelet 配置文件</a>
中添加 <code>staticPodPath: &lt;目录></code>字段。</p>
</li>
</ol>
<ol start=4>
<li>
<p>重启 kubelet。Fedora 上使用下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
systemctl restart kubelet
</code></pre></div></li>
</ol>
<h3 id=pods-created-via-http>Web 网上的静态 Pod 声明文件</h3>
<p>Kubelet 根据 <code>--manifest-url=&lt;URL></code> 参数的配置定期的下载指定文件，并且转换成
JSON/YAML 格式的 Pod 定义文件。
与<a href=#configuration-files>文件系统上的清单文件</a>使用方式类似，kubelet 调度获取清单文件。
如果静态 Pod 的清单文件有改变，kubelet 会应用这些改变。</p>
<p>按照下面的方式来：</p>
<ol>
<li>
<p>创建一个 YAML 文件，并保存在 web 服务上，为 kubelet 生成一个 URL。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>static-web<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>myrole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>通过在选择的节点上使用 <code>--manifest-url=&lt;manifest-url></code> 配置运行 kubelet。
在 Fedora 添加下面这行到 <code>/etc/kubernetes/kubelet</code> ：</p>
<pre><code>KUBELET_ARGS=&quot;--cluster-dns=10.254.0.10 --cluster-domain=kube.local --manifest-url=&lt;manifest-url&gt;&quot;
</code></pre></li>
</ol>
<ol start=3>
<li>
<p>重启 kubelet。在 Fedora 上运行如下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
systemctl restart kubelet
</code></pre></div></li>
</ol>
<h2 id=behavior-of-static-pods>观察静态 pod 的行为</h2>
<p>当 kubelet 启动时，会自动启动所有定义的静态 Pod。
当定义了一个静态 Pod 并重新启动 kubelet 时，新的静态 Pod 就应该已经在运行了。</p>
<p>可以在节点上运行下面的命令来查看正在运行的容器（包括静态 Pod）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
docker ps
</code></pre></div>
<p>输出可能会像这样：</p>
<pre><code>CONTAINER ID IMAGE         COMMAND  CREATED        STATUS         PORTS     NAMES
f6d05272b57e nginx:latest  &quot;nginx&quot;  8 minutes ago  Up 8 minutes             k8s_web.6f802af4_static-web-fk-node1_default_67e24ed9466ba55986d120c867395f3c_378e5f3c
</code></pre>
<p>可以在 API 服务上看到镜像 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME                       READY     STATUS    RESTARTS   AGE
static-web-my-node1        1/1       Running   0          2m
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 要确保 kubelet 在 API 服务上有创建镜像 Pod 的权限。如果没有，创建请求会被 API 服务拒绝。
可以看<a href=/zh/docs/concepts/policy/pod-security-policy/>Pod安全策略</a>。
</div>
<p>静态 Pod 上的<a class=glossary-tooltip title=用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=标签>标签</a> 被传到镜像 Pod。
你可以通过 <a class=glossary-tooltip title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=选择算符>选择算符</a> 使用这些标签。</p>
<p>如果你用 <code>kubectl</code> 从 API 服务上删除镜像 Pod，kubelet <em>不会</em> 移除静态 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod static-web-my-node1
</code></pre></div><pre><code>pod &quot;static-web-my-node1&quot; deleted
</code></pre>
<p>可以看到 Pod 还在运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME                       READY     STATUS    RESTARTS   AGE
static-web-my-node1        1/1       Running   0          12s
</code></pre>
<p>回到 kubelet 运行的节点上，可以手工停止 Docker 容器。
可以看到过了一段时间后 kubelet 会发现容器停止了并且会自动重启 Pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
<span style=color:#080;font-style:italic># 把 ID 换为你的容器的 ID</span>
docker stop f6d05272b57e
sleep <span style=color:#666>20</span>
docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE         COMMAND                CREATED       ...
5b920cbaf8b1        nginx:latest  &quot;nginx -g 'daemon of   2 seconds ago ...
</code></pre>
<h2 id=动态增加和删除静态-pod>动态增加和删除静态 pod</h2>
<p>运行中的 kubelet 会定期扫描配置的目录(比如例子中的 <code>/etc/kubelet.d</code> 目录)中的变化，
并且根据文件中出现/消失的 Pod 来添加/删除 Pod。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 前提是你在用主机文件系统上的静态 Pod 配置文件</span>
<span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
mv /etc/kubelet.d/static-web.yaml /tmp
sleep <span style=color:#666>20</span>
docker ps
<span style=color:#080;font-style:italic># 可以看到没有 nginx 容器在运行</span>
mv /tmp/static-web.yaml  /etc/kubelet.d/
sleep <span style=color:#666>20</span>
docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE         COMMAND                CREATED           ...
e7a62e3427f1        nginx:latest  &quot;nginx -g 'daemon of   27 seconds ago
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1bb997c61a85de753d9994e7a312a291>21 - 将 Docker Compose 文件转换为 Kubernetes 资源</h1>
<p>Kompose 是什么？它是个转换工具，可将 compose（即 Docker Compose）所组装的所有内容
转换成容器编排器（Kubernetes 或 OpenShift）可识别的形式。</p>
<p>更多信息请参考 Kompose 官网 <a href=http://kompose.io>http://kompose.io</a>。</p>
<h2 id=准备开始>准备开始</h2>
<p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
如果你还没有集群，你可以通过 <a href=/zh/docs/tasks/tools/#minikube>Minikube</a> 构建一
个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li>
</ul>
要获知版本信息，请输入 <code>kubectl version</code>.
</p>
<h2 id=安装-kompose>安装 Kompose</h2>
<p>我们有很多种方式安装 Kompose。首选方式是从最新的 GitHub 发布页面下载二进制文件。</p>
<ul class="nav nav-tabs" id=install-ways role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#install-ways-0 role=tab aria-controls=install-ways-0 aria-selected=true>GitHub 下载</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-1 role=tab aria-controls=install-ways-1>基于源代码构建</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-2 role=tab aria-controls=install-ways-2>CentOS 包</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-3 role=tab aria-controls=install-ways-3>Fedora package</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-4 role=tab aria-controls=install-ways-4>Homebrew (macOS)</a></li></ul>
<div class=tab-content id=install-ways><div id=install-ways-0 class="tab-pane show active" role=tabpanel aria-labelledby=install-ways-0>
<p>
<p>Kompose 通过 GitHub 发布，发布周期为三星期。
你可以在 <a href=https://github.com/kubernetes/kompose/releases>GitHub 发布页面</a>
上看到所有当前版本。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Linux</span>
curl -L https://github.com/kubernetes/kompose/releases/download/v1.24.0/kompose-linux-amd64 -o kompose

<span style=color:#080;font-style:italic># macOS</span>
curl -L https://github.com/kubernetes/kompose/releases/download/v1.24.0/kompose-darwin-amd64 -o kompose

<span style=color:#080;font-style:italic># Windows</span>
curl -L https://github.com/kubernetes/kompose/releases/download/v1.24.0/kompose-windows-amd64.exe -o kompose.exe

chmod +x kompose
sudo mv ./kompose /usr/local/bin/kompose
</code></pre></div>
<p>或者，你可以下载 <a href=https://github.com/kubernetes/kompose/releases>tar 包</a>。</p>
</div>
<div id=install-ways-1 class=tab-pane role=tabpanel aria-labelledby=install-ways-1>
<p>
<p>用 <code>go get</code> 命令从主分支拉取最新的开发变更的方法安装 Kompose。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>go get -u github.com/kubernetes/kompose
</code></pre></div></div>
<div id=install-ways-2 class=tab-pane role=tabpanel aria-labelledby=install-ways-2>
<p>
<p>Kompose 位于 <a href=https://fedoraproject.org/wiki/EPEL>EPEL</a> CentOS 代码仓库。
如果你还没有安装启用 <a href=https://fedoraproject.org/wiki/EPEL>EPEL</a> 代码仓库，
请运行命令 <code>sudo yum install epel-release</code>。</p>
<p>如果你的系统中已经启用了 <a href=https://fedoraproject.org/wiki/EPEL>EPEL</a>，
你就可以像安装其他软件包一样安装 Kompose。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo yum -y install kompose
</code></pre></div></div>
<div id=install-ways-3 class=tab-pane role=tabpanel aria-labelledby=install-ways-3>
<p>
<p>Kompose 位于 Fedora 24、25 和 26 的代码仓库。你可以像安装其他软件包一样安装 Kompose。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo dnf -y install kompose
</code></pre></div></div>
<div id=install-ways-4 class=tab-pane role=tabpanel aria-labelledby=install-ways-4>
<p>
<p>在 macOS 上你可以通过 <a href=https://brew.sh>Homebrew</a> 安装 Kompose 的最新版本：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>brew install kompose
</code></pre></div></div></div>
<h2 id=使用-kompose>使用 Kompose</h2>
<p>再需几步，我们就把你从 Docker Compose 带到 Kubernetes。
你只需要一个现有的 <code>docker-compose.yml</code> 文件。</p>
<ol>
<li>
<p>进入 <code>docker-compose.yml</code> 文件所在的目录。如果没有，请使用下面这个进行测试。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>redis-master</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/redis:e2e<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;6379&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>redis-slave</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_samples/gb-redisslave:v3<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;6379&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- GET_HOSTS_FROM=dns<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>frontend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/gb-frontend:v4<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;80:80&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- GET_HOSTS_FROM=dns<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kompose.service.type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>要将 <code>docker-compose.yml</code> 转换为 <code>kubectl</code> 可用的文件，请运行 <code>kompose convert</code>
命令进行转换，然后运行 <code>kubectl create -f &lt;output file></code> 进行创建。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose convert                           
</code></pre></div><pre><code class=language-none data-lang=none>INFO Kubernetes file &quot;frontend-service.yaml&quot; created
   INFO Kubernetes file &quot;frontend-service.yaml&quot; created
INFO Kubernetes file &quot;frontend-service.yaml&quot; created
INFO Kubernetes file &quot;redis-master-service.yaml&quot; created
   INFO Kubernetes file &quot;redis-master-service.yaml&quot; created
INFO Kubernetes file &quot;redis-master-service.yaml&quot; created
INFO Kubernetes file &quot;redis-slave-service.yaml&quot; created
   INFO Kubernetes file &quot;redis-slave-service.yaml&quot; created
INFO Kubernetes file &quot;redis-slave-service.yaml&quot; created
INFO Kubernetes file &quot;frontend-deployment.yaml&quot; created
   INFO Kubernetes file &quot;frontend-deployment.yaml&quot; created
INFO Kubernetes file &quot;frontend-deployment.yaml&quot; created
INFO Kubernetes file &quot;redis-master-deployment.yaml&quot; created
   INFO Kubernetes file &quot;redis-master-deployment.yaml&quot; created
INFO Kubernetes file &quot;redis-master-deployment.yaml&quot; created
INFO Kubernetes file &quot;redis-slave-deployment.yaml&quot; created
   INFO Kubernetes file &quot;redis-slave-deployment.yaml&quot; created
INFO Kubernetes file &quot;redis-slave-deployment.yaml&quot; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f frontend-service.yaml,redis-master-service.yaml,redis-slave-service.yaml,frontend-deployment.yaml,
</code></pre></div>
<p>输出类似于：</p>
<pre><code class=language-none data-lang=none>service/frontend created
service/redis-master created
service/redis-slave created
deployment.apps/frontend created
deployment.apps/redis-master created
deployment.apps/redis-slave created
</code></pre>
<p>你部署的应用在 Kubernetes 中运行起来了。</p>
</li>
</ol>
<ol start=3>
<li>
<p>访问你的应用</p>
<p>如果你在开发过程中使用 <code>minikube</code>，请执行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube service frontend
</code></pre></div>
<p>否则，我们要查看一下你的服务使用了什么 IP！</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe svc frontend
</code></pre></div><pre><code class=language-none data-lang=none>Name:                   frontend
Namespace:              default
Labels:                 service=frontend
Selector:               service=frontend
Type:                   LoadBalancer
IP:                     10.0.0.183
LoadBalancer Ingress:   192.0.2.89
Port:                   80      80/TCP
NodePort:               80      31144/TCP
Endpoints:              172.17.0.4:80
Session Affinity:       None
No events.
</code></pre>
<p>如果你使用的是云提供商，你的 IP 将在 <code>LoadBalancer Ingress</code> 字段给出。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl http://192.0.2.89
</code></pre></div></li>
</ol>
<h2 id=user-guide>用户指南 </h2>
<ul>
<li>
<p>CLI</p>
<ul>
<li><a href=#kompose-convert><code>kompose convert</code></a></li>
<li><a href=#kompose-up><code>kompose up</code></a></li>
<li><a href=#kompose-down><code>kompose down</code></a></li>
</ul>
</li>
<li>
<p>文档</p>
<ul>
<li><a href=#build-and-push-docker-images>构建和推送 Docker 镜像</a></li>
<li><a href=#%E5%85%B6%E4%BB%96%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F>其他转换方式</a></li>
<li><a href=#labels>标签</a></li>
<li><a href=#restart>重启</a></li>
<li><a href=#docker-compose-versions>Docker Compose 版本</a></li>
</ul>
</li>
</ul>
<p>Kompose 支持两种驱动：OpenShift 和 Kubernetes。
你可以通过全局选项 <code>--provider</code> 选择驱动。如果没有指定，
会将 Kubernetes 作为默认驱动。</p>
<h2 id=kompose-convert><code>kompose convert</code></h2>
<p>Kompose 支持将 V1、V2 和 V3 版本的 Docker Compose 文件转换为 Kubernetes 和 OpenShift 资源对象。</p>
<h3 id=kubernetes-kompose-convert-示例>Kubernetes <code>kompose convert</code> 示例</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose --file docker-voting.yml convert
</code></pre></div><pre><code class=language-none data-lang=none>WARN Unsupported key networks - ignoring
WARN Unsupported key build - ignoring
INFO Kubernetes file &quot;worker-svc.yaml&quot; created
INFO Kubernetes file &quot;db-svc.yaml&quot; created
INFO Kubernetes file &quot;redis-svc.yaml&quot; created
INFO Kubernetes file &quot;result-svc.yaml&quot; created
INFO Kubernetes file &quot;vote-svc.yaml&quot; created
INFO Kubernetes file &quot;redis-deployment.yaml&quot; created
INFO Kubernetes file &quot;result-deployment.yaml&quot; created
INFO Kubernetes file &quot;vote-deployment.yaml&quot; created
INFO Kubernetes file &quot;worker-deployment.yaml&quot; created
INFO Kubernetes file &quot;db-deployment.yaml&quot; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls
</code></pre></div><pre><code class=language-none data-lang=none>db-deployment.yaml  docker-compose.yml         docker-gitlab.yml  redis-deployment.yaml  result-deployment.yaml  vote-deployment.yaml  worker-deployment.yaml
db-svc.yaml         docker-voting.yml          redis-svc.yaml     result-svc.yaml        vote-svc.yaml           worker-svc.yaml
</code></pre>
<p>你也可以同时提供多个 docker-compose 文件进行转换：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose -f docker-compose.yml -f docker-guestbook.yml convert
</code></pre></div><pre><code class=language-none data-lang=none>INFO Kubernetes file &quot;frontend-service.yaml&quot; created         
INFO Kubernetes file &quot;mlbparks-service.yaml&quot; created         
INFO Kubernetes file &quot;mongodb-service.yaml&quot; created          
INFO Kubernetes file &quot;redis-master-service.yaml&quot; created     
INFO Kubernetes file &quot;redis-slave-service.yaml&quot; created      
INFO Kubernetes file &quot;frontend-deployment.yaml&quot; created      
INFO Kubernetes file &quot;mlbparks-deployment.yaml&quot; created      
INFO Kubernetes file &quot;mongodb-deployment.yaml&quot; created       
INFO Kubernetes file &quot;mongodb-claim0-persistentvolumeclaim.yaml&quot; created
INFO Kubernetes file &quot;redis-master-deployment.yaml&quot; created  
INFO Kubernetes file &quot;redis-slave-deployment.yaml&quot; created   
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls
</code></pre></div><pre><code>mlbparks-deployment.yaml  mongodb-service.yaml                       redis-slave-service.jsonmlbparks-service.yaml  
frontend-deployment.yaml  mongodb-claim0-persistentvolumeclaim.yaml  redis-master-service.yaml
frontend-service.yaml     mongodb-deployment.yaml                    redis-slave-deployment.yaml
redis-master-deployment.yaml
</code></pre>
<p>当提供多个 docker-compose 文件时，配置将会合并。任何通用的配置都将被后续文件覆盖。</p>
<h3 id=openshift-kompose-convert-示例>OpenShift <code>kompose convert</code> 示例</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose --provider openshift --file docker-voting.yml convert
</code></pre></div><pre><code>WARN [worker] Service cannot be created because of missing port.
INFO OpenShift file &quot;vote-service.yaml&quot; created             
INFO OpenShift file &quot;db-service.yaml&quot; created               
INFO OpenShift file &quot;redis-service.yaml&quot; created            
INFO OpenShift file &quot;result-service.yaml&quot; created           
INFO OpenShift file &quot;vote-deploymentconfig.yaml&quot; created    
INFO OpenShift file &quot;vote-imagestream.yaml&quot; created         
INFO OpenShift file &quot;worker-deploymentconfig.yaml&quot; created  
INFO OpenShift file &quot;worker-imagestream.yaml&quot; created       
INFO OpenShift file &quot;db-deploymentconfig.yaml&quot; created      
INFO OpenShift file &quot;db-imagestream.yaml&quot; created           
INFO OpenShift file &quot;redis-deploymentconfig.yaml&quot; created   
INFO OpenShift file &quot;redis-imagestream.yaml&quot; created        
INFO OpenShift file &quot;result-deploymentconfig.yaml&quot; created  
INFO OpenShift file &quot;result-imagestream.yaml&quot; created  
</code></pre>
<p>kompose 还支持为服务中的构建指令创建 buildconfig。
默认情况下，它使用当前 git 分支的 remote 仓库作为源仓库，使用当前分支作为构建的源分支。
你可以分别使用 <code>--build-repo</code> 和 <code>--build-branch</code> 选项指定不同的源仓库和分支。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose --provider openshift --file buildconfig/docker-compose.yml convert
</code></pre></div><pre><code class=language-none data-lang=none>WARN [foo] Service cannot be created because of missing port.
INFO OpenShift Buildconfig using git@github.com:rtnpro/kompose.git::master as source.
INFO OpenShift file &quot;foo-deploymentconfig.yaml&quot; created     
INFO OpenShift file &quot;foo-imagestream.yaml&quot; created          
INFO OpenShift file &quot;foo-buildconfig.yaml&quot; created
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 如果使用 <code>oc create -f</code> 手动推送 Openshift 工件，则需要确保在构建配置工件之前推送
imagestream 工件，以解决 Openshift 的这个问题：https://github.com/openshift/origin/issues/4518 。
</div>
<h2 id=kompose-up><code>kompose up</code></h2>
<p>Kompose 支持通过 <code>kompose up</code> 直接将你的"复合的（composed）" 应用程序
部署到 Kubernetes 或 OpenShift。</p>
<h3 id=kubernetes-kompose-up-示例>Kubernetes <code>kompose up</code> 示例</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose --file ./examples/docker-guestbook.yml up
</code></pre></div><pre><code class=language-none data-lang=none>We are going to create Kubernetes deployments and services for your Dockerized application.
If you need different kind of resources, use the 'kompose convert' and 'kubectl create -f' commands instead.

INFO Successfully created service: redis-master   
INFO Successfully created service: redis-slave    
INFO Successfully created service: frontend       
INFO Successfully created deployment: redis-master
INFO Successfully created deployment: redis-slave
INFO Successfully created deployment: frontend    

Your application has been deployed to Kubernetes. You can run 'kubectl get deployment,svc,pods' for details.
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment,svc,pods
</code></pre></div><pre><code>NAME                                              DESIRED       CURRENT       UP-TO-DATE   AVAILABLE   AGE
deployment.extensions/frontend                    1             1             1            1           4m
deployment.extensions/redis-master                1             1             1            1           4m
deployment.extensions/redis-slave                 1             1             1            1           4m

NAME                         TYPE               CLUSTER-IP    EXTERNAL-IP   PORT(S)      AGE
service/frontend             ClusterIP          10.0.174.12   &lt;none&gt;        80/TCP       4m
service/kubernetes           ClusterIP          10.0.0.1      &lt;none&gt;        443/TCP      13d
service/redis-master         ClusterIP          10.0.202.43   &lt;none&gt;        6379/TCP     4m
service/redis-slave          ClusterIP          10.0.1.85     &lt;none&gt;        6379/TCP     4m

NAME                                READY         STATUS        RESTARTS     AGE
pod/frontend-2768218532-cs5t5       1/1           Running       0            4m
pod/redis-master-1432129712-63jn8   1/1           Running       0            4m
pod/redis-slave-2504961300-nve7b    1/1           Running       0            4m
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<ul>
<li>你必须有一个运行正常的 Kubernetes 集群，该集群具有预先配置的 kubectl 上下文。</li>
<li>此操作仅生成 Deployment 和 Service 对象并将其部署到 Kubernetes。
如果需要部署其他不同类型的资源，请使用 <code>kompose convert</code> 和 <code>kubectl create -f</code> 命令。</li>
</ul>
</div>
<h3 id=openshift-kompose-up-示例>OpenShift <code>kompose up</code> 示例</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose --file ./examples/docker-guestbook.yml --provider openshift up
</code></pre></div><pre><code class=language-none data-lang=none>We are going to create OpenShift DeploymentConfigs and Services for your Dockerized application.
If you need different kind of resources, use the 'kompose convert' and 'oc create -f' commands instead.

INFO Successfully created service: redis-slave    
INFO Successfully created service: frontend       
INFO Successfully created service: redis-master   
INFO Successfully created deployment: redis-slave
INFO Successfully created ImageStream: redis-slave
INFO Successfully created deployment: frontend    
INFO Successfully created ImageStream: frontend   
INFO Successfully created deployment: redis-master
INFO Successfully created ImageStream: redis-master

Your application has been deployed to OpenShift. You can run 'oc get dc,svc,is' for details.
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>oc get dc,svc,is
</code></pre></div><pre><code class=language-none data-lang=none>NAME               REVISION                              DESIRED       CURRENT    TRIGGERED BY
dc/frontend        0                                     1             0          config,image(frontend:v4)
dc/redis-master    0                                     1             0          config,image(redis-master:e2e)
dc/redis-slave     0                                     1             0          config,image(redis-slave:v1)
NAME               CLUSTER-IP                            EXTERNAL-IP   PORT(S)    AGE
svc/frontend       172.30.46.64                          &lt;none&gt;        80/TCP     8s
svc/redis-master   172.30.144.56                         &lt;none&gt;        6379/TCP   8s
svc/redis-slave    172.30.75.245                         &lt;none&gt;        6379/TCP   8s
NAME               DOCKER REPO                           TAGS          UPDATED
is/frontend        172.30.12.200:5000/fff/frontend                     
is/redis-master    172.30.12.200:5000/fff/redis-master                 
is/redis-slave     172.30.12.200:5000/fff/redis-slave    v1  
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>你必须有一个运行正常的 OpenShift 集群，该集群具有预先配置的 <code>oc</code> 上下文 (<code>oc login</code>)。
</div>
<h2 id=kompose-down><code>kompose down</code></h2>
<p>你一旦将"复合(composed)" 应用部署到 Kubernetes，<code>kompose down</code>
命令将能帮你通过删除 Deployment 和 Service 对象来删除应用。
如果需要删除其他资源，请使用 'kubectl' 命令。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose --file docker-guestbook.yml down
</code></pre></div><pre><code>INFO Successfully deleted service: redis-master   
INFO Successfully deleted deployment: redis-master
INFO Successfully deleted service: redis-slave    
INFO Successfully deleted deployment: redis-slave
INFO Successfully deleted service: frontend       
INFO Successfully deleted deployment: frontend
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<ul>
<li>你必须有一个运行正常的 Kubernetes 集群，该集群具有预先配置的 kubectl 上下文。</li>
</ul>
</div>
<h2 id=build-and-push-docker-images>构建和推送 Docker 镜像 </h2>
<p>Kompose 支持构建和推送 Docker 镜像。如果 Docker Compose 文件中使用了 <code>build</code>
关键字，你的镜像将会：</p>
<ul>
<li>使用文档中指定的 <code>image</code> 键自动构建 Docker 镜像</li>
<li>使用本地凭据推送到正确的 Docker 仓库</li>
</ul>
<p>使用 <a href=https://raw.githubusercontent.com/kubernetes/kompose/master/examples/buildconfig/docker-compose.yml>Docker Compose 文件示例</a></p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>build</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;./build&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>docker.io/foo/bar<span style=color:#bbb>
</span></code></pre></div>
<p>使用带有 <code>build</code> 键的 <code>kompose up</code> 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose up
</code></pre></div><pre><code class=language-none data-lang=none>INFO Build key detected. Attempting to build and push image 'docker.io/foo/bar'
INFO Building image 'docker.io/foo/bar' from directory 'build'
INFO Image 'docker.io/foo/bar' from directory 'build' built successfully
INFO Pushing image 'foo/bar:latest' to registry 'docker.io'
INFO Attempting authentication credentials 'https://index.docker.io/v1/
INFO Successfully pushed image 'foo/bar:latest' to registry 'docker.io'
INFO We are going to create Kubernetes Deployments, Services and PersistentVolumeClaims for your Dockerized application. If you need different kind of resources, use the 'kompose convert' and 'kubectl create -f' commands instead.

INFO Deploying application in &quot;default&quot; namespace
INFO Successfully created Service: foo            
INFO Successfully created Deployment: foo         

Your application has been deployed to Kubernetes. You can run 'kubectl get deployment,svc,pods,pvc' for details.
</code></pre>
<p>要想禁用该功能，或者使用 BuildConfig 中的版本（在 OpenShift 中），
可以通过传递 <code>--build (local|build-config|none)</code> 参数来实现。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 禁止构造和推送 Docker 镜像</span>
kompose up --build none

<span style=color:#080;font-style:italic># 为 OpenShift 生成 Build Config 工件</span>
kompose up --provider openshift --build build-config
</code></pre></div>
<h2 id=alternative-conversions>其他转换方式 </h2>
<p>默认的 <code>kompose</code> 转换会生成 yaml 格式的 Kubernetes
<a href=/zh/docs/concepts/workloads/controllers/deployment/>Deployment</a> 和
<a href=/zh/docs/concepts/services-networking/service/>Service</a> 对象。
你可以选择通过 <code>-j</code> 参数生成 json 格式的对象。
你也可以替换生成 <a href=/zh/docs/concepts/workloads/controllers/replicationcontroller/>Replication Controllers</a> 对象、
<a href=/zh/docs/concepts/workloads/controllers/daemonset/>Daemon Sets</a> 或
<a href=https://github.com/helm/helm>Helm</a> charts。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose convert -j
</code></pre></div><pre><code class=language-none data-lang=none>INFO Kubernetes file &quot;redis-svc.json&quot; created
INFO Kubernetes file &quot;web-svc.json&quot; created
INFO Kubernetes file &quot;redis-deployment.json&quot; created
INFO Kubernetes file &quot;web-deployment.json&quot; created
</code></pre>
<p><code>*-deployment.json</code> 文件中包含 Deployment 对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose convert --replication-controller
</code></pre></div><pre><code class=language-none data-lang=none>INFO Kubernetes file &quot;redis-svc.yaml&quot; created
INFO Kubernetes file &quot;web-svc.yaml&quot; created
INFO Kubernetes file &quot;redis-replicationcontroller.yaml&quot; created
INFO Kubernetes file &quot;web-replicationcontroller.yaml&quot; created
</code></pre>
<p><code>*-replicationcontroller.yaml</code> 文件包含 Replication Controller 对象。
如果你想指定副本数（默认为 1），可以使用 <code>--replicas</code> 参数：
<code>kompose convert --replication-controller --replicas 3</code></p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose convert --daemon-set
</code></pre></div><pre><code class=language-none data-lang=none>INFO Kubernetes file &quot;redis-svc.yaml&quot; created
INFO Kubernetes file &quot;web-svc.yaml&quot; created
INFO Kubernetes file &quot;redis-daemonset.yaml&quot; created
INFO Kubernetes file &quot;web-daemonset.yaml&quot; created
</code></pre>
<p><code>*-daemonset.yaml</code> 文件包含 DaemonSet 对象。</p>
<p>如果你想生成 <a href=https://github.com/kubernetes/helm>Helm</a> 可用的 Chart，
只需简单的执行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kompose convert -c
</code></pre></div><pre><code class=language-none data-lang=none>INFO Kubernetes file &quot;web-svc.yaml&quot; created
INFO Kubernetes file &quot;redis-svc.yaml&quot; created
INFO Kubernetes file &quot;web-deployment.yaml&quot; created
INFO Kubernetes file &quot;redis-deployment.yaml&quot; created
chart created in &quot;./docker-compose/&quot;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>tree docker-compose/
</code></pre></div><pre><code>docker-compose
├── Chart.yaml
├── README.md
└── templates
    ├── redis-deployment.yaml
    ├── redis-svc.yaml
    ├── web-deployment.yaml
    └── web-svc.yaml
</code></pre>
<p>这个 Chart 结构旨在为构建 Helm Chart 提供框架。</p>
<h2 id=labels>标签 </h2>
<p><code>kompose</code> 支持 <code>docker-compose.yml</code> 文件中用于 Kompose 的标签，以便
在转换时明确定义 Service 的行为。</p>
<ul>
<li>
<p><code>kompose.service.type</code> 定义要创建的 Service 类型。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nginx</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>dockerfile</span>:<span style=color:#bbb> </span>foobar<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>build</span>:<span style=color:#bbb> </span>./foobar<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cap_add</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- ALL<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>container_name</span>:<span style=color:#bbb> </span>foobar<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kompose.service.type</span>:<span style=color:#bbb> </span>nodeport<span style=color:#bbb>
</span></code></pre></div></li>
</ul>
<ul>
<li>
<p><code>kompose.service.expose</code> 定义是否允许从集群外部访问 Service。
如果该值被设置为 "true"，提供程序将自动设置端点，
对于任何其他值，该值将被设置为主机名。
如果在 Service 中定义了多个端口，则选择第一个端口作为公开端口。</p>
<ul>
<li>如果使用 Kubernetes 驱动，会有一个 Ingress 资源被创建，并且假定
已经配置了相应的 Ingress 控制器。</li>
<li>如果使用 OpenShift 驱动, 则会有一个 route 被创建。</li>
</ul>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>web</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>tuna/docker-counter23<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span>- <span style=color:#b44>&#34;5000:5000&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>links</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span>- redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kompose.service.expose</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;counter.example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>redis</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis:3.0<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span>- <span style=color:#b44>&#34;6379&#34;</span><span style=color:#bbb>
</span></code></pre></div></li>
</ul>
<p>当前支持的选项有:</p>
<table>
<thead>
<tr>
<th>键</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>kompose.service.type</td>
<td>nodeport / clusterip / loadbalancer</td>
</tr>
<tr>
<td>kompose.service.expose</td>
<td>true / hostname</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p><code>kompose.service.type</code> 标签应该只用 <code>ports</code> 来定义，否则 <code>kompose</code> 会失败。
</div>
<h2 id=restart>重启 </h2>
<p>如果你想创建没有控制器的普通 Pod，可以使用 docker-compose 的 <code>restart</code>
结构来指定这一行为。请参考下表了解 <code>restart</code> 的不同参数。</p>
<table>
<thead>
<tr>
<th><code>docker-compose</code> <code>restart</code></th>
<th>创建的对象</th>
<th>Pod <code>restartPolicy</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>""</code></td>
<td>控制器对象</td>
<td><code>Always</code></td>
</tr>
<tr>
<td><code>always</code></td>
<td>控制器对象</td>
<td><code>Always</code></td>
</tr>
<tr>
<td><code>on-failure</code></td>
<td>Pod</td>
<td><code>OnFailure</code></td>
</tr>
<tr>
<td><code>no</code></td>
<td>Pod</td>
<td><code>Never</code></td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 控制器对象可以是 <code>deployment</code> 或 <code>replicationcontroller</code> 等。
</div>
<p>例如，<code>pival</code> Service 将在这里变成 Pod。这个容器计算 <code>pi</code> 的取值。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;2&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>pival</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>restart</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;on-failure&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<h3 id=关于-deployment-config-的提醒>关于 Deployment Config 的提醒</h3>
<p>如果 Docker Compose 文件中为服务声明了卷，Deployment (Kubernetes) 或
DeploymentConfig (OpenShift) 策略会从 "RollingUpdate" (默认) 变为 "Recreate"。
这样做的目的是为了避免服务的多个实例同时访问卷。</p>
<p>如果 Docker Compose 文件中的服务名包含 <code>_</code>（例如 <code>web_service</code>），
那么将会被替换为 <code>-</code>，服务也相应的会重命名（例如 <code>web-service</code>）。
Kompose 这样做的原因是 "Kubernetes" 不允许对象名称中包含 <code>_</code>。</p>
<p>请注意，更改服务名称可能会破坏一些 <code>docker-compose</code> 文件。</p>
<h2 id=docker-compose-versions>Docker Compose 版本 </h2>
<p>Kompose 支持的 Docker Compose 版本包括：1、2 和 3。
对 2.1 和 3.2 版本的支持还有限，因为它们还在实验阶段。</p>
<p>所有三个版本的兼容性列表请查看我们的
<a href=https://github.com/kubernetes/kompose/blob/master/docs/conversion.md>转换文档</a>，
文档中列出了所有不兼容的 Docker Compose 关键字。</p>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/zh/docs/home/>主页</a>
<a class=text-white href=/zh/blog/>博客</a>
<a class=text-white href=/zh/training/>培训</a>
<a class=text-white href=/zh/partners/>合作伙伴</a>
<a class=text-white href=/zh/community/>社区</a>
<a class=text-white href=/zh/case-studies/>案例分析</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small>
<br>
<small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>