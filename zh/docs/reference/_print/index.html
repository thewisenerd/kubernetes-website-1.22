<!doctype html><html lang=zh class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/reference/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/reference/>
<link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/reference/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/reference/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/reference/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/reference/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/reference/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/reference/>
<link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/reference/>
<link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/reference/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/zh/docs/reference/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>参考 | Kubernetes</title><meta property="og:title" content="参考">
<meta property="og:description" content="生产级别的容器编排系统">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/zh/docs/reference/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="参考">
<meta itemprop=description content="生产级别的容器编排系统"><meta name=twitter:card content="summary">
<meta name=twitter:title content="参考">
<meta name=twitter:description content="生产级别的容器编排系统">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="这是 Kubernetes 文档的参考部分。
API 参考   术语表 - 一个全面的标准化的 Kubernetes 术语表
  Kubernetes API 单页参考
  Kubernetes API 参考 v1.22。
  使用 Kubernetes API  - Kubernetes 的 API 概述
  API 的访问控制 - 关于 Kubernetes 如何控制 API 访问的详细信息
  常见的标签、注解和污点
  官方支持的客户端库 如果您需要通过编程语言调用 Kubernetes API，您可以使用 客户端库。以下是官方支持的客户端库：
 Kubernetes Go 语言客户端库 Kubernetes Python 语言客户端库 Kubernetes Java 语言客户端库 Kubernetes JavaScript 语言客户端库 Kubernetes Dotnet 语言客户端库 Kubernetes Haskell 语言客户端库  CLI  kubectl - 主要的 CLI 工具，用于运行命令和管理 Kubernetes 集群。  JSONPath - 通过 kubectl 使用 JSONPath 表达式 的语法指南。   kubeadm - 此 CLI 工具可轻松配置安全的 Kubernetes 集群。  组件   kubelet - 在每个节点上运行的主代理。kubelet 接收一组 PodSpecs 并确保其所描述的容器健康地运行。">
<meta property="og:description" content="这是 Kubernetes 文档的参考部分。
API 参考   术语表 - 一个全面的标准化的 Kubernetes 术语表
  Kubernetes API 单页参考
  Kubernetes API 参考 v1.22。
  使用 Kubernetes API  - Kubernetes 的 API 概述
  API 的访问控制 - 关于 Kubernetes 如何控制 API 访问的详细信息
  常见的标签、注解和污点
  官方支持的客户端库 如果您需要通过编程语言调用 Kubernetes API，您可以使用 客户端库。以下是官方支持的客户端库：
 Kubernetes Go 语言客户端库 Kubernetes Python 语言客户端库 Kubernetes Java 语言客户端库 Kubernetes JavaScript 语言客户端库 Kubernetes Dotnet 语言客户端库 Kubernetes Haskell 语言客户端库  CLI  kubectl - 主要的 CLI 工具，用于运行命令和管理 Kubernetes 集群。  JSONPath - 通过 kubectl 使用 JSONPath 表达式 的语法指南。   kubeadm - 此 CLI 工具可轻松配置安全的 Kubernetes 集群。  组件   kubelet - 在每个节点上运行的主代理。kubelet 接收一组 PodSpecs 并确保其所描述的容器健康地运行。">
<meta name=twitter:description content="这是 Kubernetes 文档的参考部分。
API 参考   术语表 - 一个全面的标准化的 Kubernetes 术语表
  Kubernetes API 单页参考
  Kubernetes API 参考 v1.22。
  使用 Kubernetes API  - Kubernetes 的 API 概述
  API 的访问控制 - 关于 Kubernetes 如何控制 API 访问的详细信息
  常见的标签、注解和污点
  官方支持的客户端库 如果您需要通过编程语言调用 Kubernetes API，您可以使用 客户端库。以下是官方支持的客户端库：
 Kubernetes Go 语言客户端库 Kubernetes Python 语言客户端库 Kubernetes Java 语言客户端库 Kubernetes JavaScript 语言客户端库 Kubernetes Dotnet 语言客户端库 Kubernetes Haskell 语言客户端库  CLI  kubectl - 主要的 CLI 工具，用于运行命令和管理 Kubernetes 集群。  JSONPath - 通过 kubectl 使用 JSONPath 表达式 的语法指南。   kubeadm - 此 CLI 工具可轻松配置安全的 Kubernetes 集群。  组件   kubelet - 在每个节点上运行的主代理。kubelet 接收一组 PodSpecs 并确保其所描述的容器健康地运行。">
<meta property="og:url" content="https://kubernetes.io/zh/docs/reference/">
<meta property="og:title" content="参考">
<meta name=twitter:title content="参考">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/zh/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/zh/docs/>文档</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/blog/>Kubernetes 博客</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/training/>培训</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/partners/>合作伙伴</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/community/>社区</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/zh/case-studies/>案例分析</span></a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
版本列表
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh/docs/reference/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/zh/docs/reference/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh/docs/reference/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh/docs/reference/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh/docs/reference/>v1.22</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
中文 Chinese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/reference/>English</a>
<a class=dropdown-item href=/ko/docs/reference/>한국어 Korean</a>
<a class=dropdown-item href=/ja/docs/reference/>日本語 Japanese</a>
<a class=dropdown-item href=/fr/docs/reference/>Français</a>
<a class=dropdown-item href=/de/docs/reference/>Deutsch</a>
<a class=dropdown-item href=/es/docs/reference/>Español</a>
<a class=dropdown-item href=/pt-br/docs/reference/>Português</a>
<a class=dropdown-item href=/id/docs/reference/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/reference/>Русский</a>
<a class=dropdown-item href=/pl/docs/reference/>Polski</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.
</p><p>
<a href=/zh/docs/reference/>返回本页常规视图</a>.
</p>
</div>
<h1 class=title>参考</h1>
<ul>
<li>1: <a href=#pg-2b03679960950df772fb4fe7d78427b9>词汇表</a></li>
<li>2: <a href=#pg-882c82a32bfb4d7946585a93a966b442>API 概述</a></li>
<ul>
<li>2.1: <a href=#pg-2b5428a2ff6f4831fd972ef50e12b3eb>Kubernetes API 概念</a></li>
<li>2.2: <a href=#pg-040d9484db673074f1b8ba3465be9d91>服务器端应用（Server-Side Apply）</a></li>
<li>2.3: <a href=#pg-79880efc25dc8cb3b6962ad78a964319>客户端库</a></li>
<li>2.4: <a href=#pg-8d2ce3e7b2223cda0ccd428f4d5ea24b>Kubernetes 弃用策略</a></li>
<li>2.5: <a href=#pg-e4dbb59f8f23854d7b7d574e169923c4>Kubernetes API 健康端点</a></li>
</ul>
<li>3: <a href=#pg-99b26586d8a33ec06996dcf7892a9683>访问 API</a></li>
<ul>
<li>3.1: <a href=#pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b>用户认证</a></li>
<li>3.2: <a href=#pg-de45b6ca7419a0e308044425b2ac52bb>使用启动引导令牌（Bootstrap Tokens）认证</a></li>
<li>3.3: <a href=#pg-3d0c14d1e3cfade38febc343cd044c73>证书签名请求</a></li>
<li>3.4: <a href=#pg-518807b9b00bda46d7c7e6e0b17c18f8>使用准入控制器</a></li>
<li>3.5: <a href=#pg-d04751f776f1faa6a82bbb7f0a200950>动态准入控制</a></li>
<li>3.6: <a href=#pg-bea207258f3576b8ec7444a20d498e1d>管理服务账号</a></li>
<li>3.7: <a href=#pg-342be69d36f174f762c36f4fe11fcb20>鉴权概述</a></li>
<li>3.8: <a href=#pg-954776b47f2d90515f375623a0ce98e1>使用 RBAC 鉴权</a></li>
<li>3.9: <a href=#pg-9cbb97d4d9f08d67931a1baae4e6519c>使用 Node 鉴权</a></li>
<li>3.10: <a href=#pg-215c25173044b8f97e9b0494b0c7e53f>Webhook 模式</a></li>
<li>3.11: <a href=#pg-a5bdc757c01991e5e6ab1a82b90639ea>使用 ABAC 鉴权</a></li>
</ul>
<li>4: <a href=#pg-232c8c895125744f56a31038ab6fa4e9>常见的标签、注解和污点</a></li>
<li>5: <a href=#pg-60a16da3955f1de774f1f8dd756f2251>Kubernetes API</a></li>
<ul>
</ul>
<li>6: <a href=#pg-af7c1f9168ec67f957edc504f43faf9a>Kubernetes 问题和安全</a></li>
<ul>
<li>6.1: <a href=#pg-980c0542a3b195a20cfd4358792e2a38>Kubernetes 问题追踪</a></li>
<li>6.2: <a href=#pg-1f7dc06f1cc1ea2cdde4480e54d5fb34>Kubernetes 安全和信息披露</a></li>
</ul>
<li>7: <a href=#pg-5bbbc5163b35431b3bff029ab9ec57d3>安装工具</a></li>
<ul>
<li>7.1: <a href=#pg-f351ced098abbb076bc8c4be1053672b>Kubeadm</a></li>
<ul>
<li>7.1.1: <a href=#pg-36c22b52e8447eb3d2452d4f56fbea9b>创建 Kubeadm</a></li>
<ul>
<li>7.1.1.1: <a href=#pg-fd3ad295c1f10bfa333f841bbdffba81></a></li>
<li>7.1.1.2: <a href=#pg-185ec44b69a851237e5cbde8b34d60b8></a></li>
<li>7.1.1.3: <a href=#pg-5106075da35b6c976e6f8d7d225df0ff></a></li>
<li>7.1.1.4: <a href=#pg-d7af99919faca6010658b893fa2a6890></a></li>
<li>7.1.1.5: <a href=#pg-8df9aba508b2736a6712ef46227eea7d></a></li>
<li>7.1.1.6: <a href=#pg-018648dfc6f28bc9b969f45af0563cae></a></li>
<li>7.1.1.7: <a href=#pg-4a1ff27cdf01c1c47d034278048e776b></a></li>
<li>7.1.1.8: <a href=#pg-5d6b2999153cd86f56329534249fc4ec></a></li>
<li>7.1.1.9: <a href=#pg-adb5eecdc351074cc2e0cc2b1b4f04a8></a></li>
<li>7.1.1.10: <a href=#pg-df4c2dc6cba0be90d8d7de2fca9b87f7></a></li>
<li>7.1.1.11: <a href=#pg-6d6746e8ac1f1602f7dab1056b27e5c2></a></li>
<li>7.1.1.12: <a href=#pg-7449c7fa06f25b967cf531e937b0f4b2></a></li>
<li>7.1.1.13: <a href=#pg-b5c6ae77d3be9bd358c68667006cfc18></a></li>
<li>7.1.1.14: <a href=#pg-4f804e59ec1739e733807d2b591d771f></a></li>
<li>7.1.1.15: <a href=#pg-f5cf8caa95834803b133d53c321ab4a9></a></li>
<li>7.1.1.16: <a href=#pg-ee770858e2bb767b79d572b4882af656></a></li>
<li>7.1.1.17: <a href=#pg-7484bf11b6183f4c329b1f66734cc886></a></li>
<li>7.1.1.18: <a href=#pg-bf444d915ab856dba693c36294c5427b></a></li>
<li>7.1.1.19: <a href=#pg-f5c087e087714c5290b4967dd7924b3b></a></li>
<li>7.1.1.20: <a href=#pg-20703ce1c236264ad78cb1ad7244723e></a></li>
<li>7.1.1.21: <a href=#pg-49aaa494ef75de67609987a43e5ee520></a></li>
<li>7.1.1.22: <a href=#pg-d63311c16e6468f5a5940aadd902faa7></a></li>
<li>7.1.1.23: <a href=#pg-6678a79b85306310066616185153377d></a></li>
<li>7.1.1.24: <a href=#pg-8f73e208cc67d221165f6294393881a7></a></li>
<li>7.1.1.25: <a href=#pg-9aec3477159c105a46f4479de1c21418></a></li>
<li>7.1.1.26: <a href=#pg-045e41c28798930e21f77a90c3a90263></a></li>
<li>7.1.1.27: <a href=#pg-e7d83478123771ad14f475ee44440303></a></li>
<li>7.1.1.28: <a href=#pg-57a6b20d9571220989a7a445d4459468></a></li>
<li>7.1.1.29: <a href=#pg-92a2c11eef37937af846b55d9b87a544></a></li>
<li>7.1.1.30: <a href=#pg-dcfffcaafb438cd650475945ddc129ee></a></li>
<li>7.1.1.31: <a href=#pg-6eaa2624c512051ff2a9cdbc6ee54949></a></li>
<li>7.1.1.32: <a href=#pg-4b7ada30e3923594b2907dcb8b431080></a></li>
<li>7.1.1.33: <a href=#pg-6d1154da2e554de858cf4e7b37c054fa></a></li>
<li>7.1.1.34: <a href=#pg-d3a16914ddc849435ed864163978ddbf></a></li>
<li>7.1.1.35: <a href=#pg-8a257337ea78e5d9a0c54aa971eaf991></a></li>
<li>7.1.1.36: <a href=#pg-77759011117e7974cbfee9694b6f8801></a></li>
<li>7.1.1.37: <a href=#pg-8e1920b2caaa8de839cd3997edca80e9></a></li>
<li>7.1.1.38: <a href=#pg-00aa8c2e4b3b2fd3a4b7986976b7bfda></a></li>
<li>7.1.1.39: <a href=#pg-316aa97ee5719be5a723ac1b77c44f5a></a></li>
<li>7.1.1.40: <a href=#pg-759e85e62b32c0697ab37c214e99a864></a></li>
<li>7.1.1.41: <a href=#pg-2e7091074560abc2a8e7b897cdd8a7b6></a></li>
<li>7.1.1.42: <a href=#pg-eedb8f5a6ed4cff1dfb1a5d14176b5b3></a></li>
<li>7.1.1.43: <a href=#pg-c55f2fa6bdaa124b37da090a3ef90902></a></li>
<li>7.1.1.44: <a href=#pg-10f416336efdcee22d691869e7585b9f></a></li>
<li>7.1.1.45: <a href=#pg-c4b6d149cda7cac896f4374c821b7fc6></a></li>
<li>7.1.1.46: <a href=#pg-1db087626f4f368e932df6f12993a5ab></a></li>
<li>7.1.1.47: <a href=#pg-e85da83e18a50e472eb56320af55768a></a></li>
<li>7.1.1.48: <a href=#pg-eb911bdcb8bb53ceb8b253089ab0d814></a></li>
<li>7.1.1.49: <a href=#pg-62c5dc89c39f3ecd6aee57545d12891a></a></li>
<li>7.1.1.50: <a href=#pg-2a79e12b9455f0ca1a6d5b00a9841249></a></li>
<li>7.1.1.51: <a href=#pg-a2c8efac328fcf416e558bf167ef417d></a></li>
<li>7.1.1.52: <a href=#pg-d93bd37094201bdefdb3908c9a6c86b3></a></li>
<li>7.1.1.53: <a href=#pg-efa9ae4c92ed1c26dc04bb049db38cec></a></li>
<li>7.1.1.54: <a href=#pg-576c00359074987304b3b418cec9a5b1></a></li>
<li>7.1.1.55: <a href=#pg-e6097fe5dd013abd9f356c2566ef7b63></a></li>
<li>7.1.1.56: <a href=#pg-5ab65eab2498cc1893af5b3bf8fe08fc></a></li>
<li>7.1.1.57: <a href=#pg-fcb78718510a9d3027d1bb9d379c0c17></a></li>
<li>7.1.1.58: <a href=#pg-a0e1457f667eb757f82f8c42901aa6c5></a></li>
<li>7.1.1.59: <a href=#pg-59e362bf565041872395d165e99eafc1></a></li>
<li>7.1.1.60: <a href=#pg-2a5040747a02ae2b2326c9901f1725d3></a></li>
<li>7.1.1.61: <a href=#pg-043bd19497eefb77a6ed30a4d704fe7c></a></li>
<li>7.1.1.62: <a href=#pg-bffb0d67824e75ade7232d09754b9718></a></li>
<li>7.1.1.63: <a href=#pg-a37b5872c572c71775e389df50fca215></a></li>
<li>7.1.1.64: <a href=#pg-3f49598c499c3356d89d98fdc8c8ad79></a></li>
<li>7.1.1.65: <a href=#pg-7d68ac74e5301f789ddd2e25dd36218e></a></li>
<li>7.1.1.66: <a href=#pg-e7c1ae3d905d9b6854216e26651955cd></a></li>
<li>7.1.1.67: <a href=#pg-967a98823c19c8338bfc0e1338a20fb1></a></li>
<li>7.1.1.68: <a href=#pg-b5838cc93a3fdb37b61afd201a71edd9></a></li>
<li>7.1.1.69: <a href=#pg-f54c84a0fdada369a87b2ced6ccfc38f></a></li>
<li>7.1.1.70: <a href=#pg-0d96e214c09a8f014e984a6b980522b3></a></li>
<li>7.1.1.71: <a href=#pg-48afa88840a20edf1ad613c18480d4fc></a></li>
<li>7.1.1.72: <a href=#pg-14da359f76a0f36af507d289dd4a5050></a></li>
<li>7.1.1.73: <a href=#pg-3fda282409b804a14879b9c65c035797></a></li>
<li>7.1.1.74: <a href=#pg-e044e6c69c2b1512c8d89430e0400771></a></li>
<li>7.1.1.75: <a href=#pg-9f968809f867b76728697577492429e8></a></li>
<li>7.1.1.76: <a href=#pg-c3c506c1683aed34398a34ab66d609da></a></li>
<li>7.1.1.77: <a href=#pg-2c1a5a4405dca745ef50b4e86f5977c7></a></li>
<li>7.1.1.78: <a href=#pg-003aaef561d065ecdaeb2c325b6b9253></a></li>
<li>7.1.1.79: <a href=#pg-535f050663a6d8db3a61df2b19a0714b></a></li>
<li>7.1.1.80: <a href=#pg-2f0a684baffe3cdf830c16693412f8e0></a></li>
<li>7.1.1.81: <a href=#pg-aba528e06c437710b269f4e41f854fdd></a></li>
<li>7.1.1.82: <a href=#pg-1d7987a759cd1519def4d433710cdff1></a></li>
<li>7.1.1.83: <a href=#pg-33216a69b333c330cb8b305a119abc7c></a></li>
<li>7.1.1.84: <a href=#pg-53abd743076fc859067264f3e8e676e0></a></li>
<li>7.1.1.85: <a href=#pg-3a08eb202d572e417768a942ad24c59f></a></li>
<li>7.1.1.86: <a href=#pg-11ed4820a6c3b411d9c4b87163cf0ae7></a></li>
<li>7.1.1.87: <a href=#pg-e81c9d9320242b5ed4b063beea6696f8></a></li>
<li>7.1.1.88: <a href=#pg-47f2d404188d6eb1fbf6fffd7fba4e48></a></li>
<li>7.1.1.89: <a href=#pg-a46a193f2322aa88cb3b2de2447b0461></a></li>
<li>7.1.1.90: <a href=#pg-f5b27d7bd0eeed918f8635c68d220dc5></a></li>
<li>7.1.1.91: <a href=#pg-370e9ffda66b4c48dfa54ea37c3aad21></a></li>
<li>7.1.1.92: <a href=#pg-6bd27042c883aa5c498647d37762392c></a></li>
<li>7.1.1.93: <a href=#pg-3a000435e1cca0be398b44b487f530c8></a></li>
<li>7.1.1.94: <a href=#pg-97fbe97ca22de377e7fbf2517e0451b6></a></li>
<li>7.1.1.95: <a href=#pg-bee6749065a369c2ab5b311eb43c40ba></a></li>
<li>7.1.1.96: <a href=#pg-bdd9680ec894593d17f782d5e5665fd4></a></li>
<li>7.1.1.97: <a href=#pg-1d005baad1a1e217d7ae0210fec96c3f></a></li>
<li>7.1.1.98: <a href=#pg-c79d11d27bed54caac743c93e0b2fb24></a></li>
<li>7.1.1.99: <a href=#pg-ba78e64c325e4131dd741235e2a1b2c0></a></li>
<li>7.1.1.100: <a href=#pg-872d33f1fbc83cb2f0bf89b4bd545174></a></li>
<li>7.1.1.101: <a href=#pg-7d8c1710684742ca940f580674225d9d></a></li>
<li>7.1.1.102: <a href=#pg-28dcf20d89c7bb1c8e7a3873d7703d5d></a></li>
<li>7.1.1.103: <a href=#pg-f869b6331e40c6f9eb01314f96d3113e></a></li>
<li>7.1.1.104: <a href=#pg-19a94d2f7649959b218952cef00729f4></a></li>
<li>7.1.1.105: <a href=#pg-b22d3ed181fb7f926ae2081f8fc8c14d></a></li>
<li>7.1.1.106: <a href=#pg-ae1ea74c2c21b25a3c1eacdaf549274b></a></li>
<li>7.1.1.107: <a href=#pg-633020ef232bc34f60c82153578a6c9b></a></li>
<li>7.1.1.108: <a href=#pg-e938edeb3d824f9b364de617a1f10a93></a></li>
<li>7.1.1.109: <a href=#pg-aa9f718186487df2ab6885cae45f5d37></a></li>
<li>7.1.1.110: <a href=#pg-60d816e74ec8e0301cc484b19d7694e6></a></li>
</ul>
<li>7.1.2: <a href=#pg-82b2fcf985bae77dcb754387a9fcc64f>kubeadm init</a></li>
<li>7.1.3: <a href=#pg-2a2b5f34806b4b1bd2c12682ac170d68>kubeadm join</a></li>
<li>7.1.4: <a href=#pg-2c20539d9fabf5982e2dd931742714bd>kubeadm upgrade</a></li>
<li>7.1.5: <a href=#pg-5042dc49c5348b3674d3878f37f7670b>kubeadm config</a></li>
<li>7.1.6: <a href=#pg-6eb5bc1e7114609930a76c683cc27c2b>kubeadm reset</a></li>
<li>7.1.7: <a href=#pg-516f4705fb2f5f62c76c7742772726a3>kubeadm token</a></li>
<li>7.1.8: <a href=#pg-34c4af6f36d969ed08ba840e7fb64c6d>kubeadm version</a></li>
<li>7.1.9: <a href=#pg-92a39c69c3689119dd5fa12886cb73a3>kubeadm alpha</a></li>
<li>7.1.10: <a href=#pg-6a1fed09235bbf3644c804339928f10e>kubeadm certs</a></li>
<li>7.1.11: <a href=#pg-fbe8dcd222ce5795a5c325670a26b067>kubeadm init phase</a></li>
<li>7.1.12: <a href=#pg-62a742c564b0b5b7ac12a95e67cc425a>kubeadm join phase</a></li>
<li>7.1.13: <a href=#pg-b969d0033ce5d9036463521fb1f150b3>kubeadm reset phase</a></li>
<li>7.1.14: <a href=#pg-dfd085b5ab706bd84dda15847dd27f1b>kubeadm upgrade phase</a></li>
<li>7.1.15: <a href=#pg-455b6412a275b743ee8ad90f35808393>实现细节</a></li>
</ul>
</ul>
<li>8: <a href=#pg-df8ff2190764e70c3de2015e2cb46b14>端口和协议</a></li>
<li>9: <a href=#pg-03460a7254c6c73eb2a1bb3dd7d25910>kubectl</a></li>
<ul>
<li>9.1: <a href=#pg-f14fe15ecc2d41b5e901ef5e872ca657>kubectl 概述</a></li>
<li>9.2: <a href=#pg-a938176c695852fe70362c29cf615f1c>JSONPath 支持</a></li>
<li>9.3: <a href=#pg-4d3e62632c189fcc3c1357cd8fb8799c>kubectl</a></li>
<li>9.4: <a href=#pg-d7ffbf04ffbefb241fd0722423b80f5a>kubectl 命令</a></li>
<li>9.5: <a href=#pg-8aba901ac13f124e5782b90ddb166ee2>kubectl 备忘单</a></li>
<li>9.6: <a href=#pg-8de6aceb8bf692c06cced446bac5bc92>kubectl 的用法约定</a></li>
<li>9.7: <a href=#pg-a7abc09192597e614b58f8b552b682f5>适用于 Docker 用户的 kubectl</a></li>
</ul>
<li>10: <a href=#pg-54e562dd1441d0195970a6526b0055cc>组件工具</a></li>
<ul>
<li>10.1: <a href=#pg-ca5d01a42c486d535539d3038aa67eb9>特性门控</a></li>
<li>10.2: <a href=#pg-29e506a6018204679ef5459653a7aa1f>kubelet</a></li>
<li>10.3: <a href=#pg-ec8ff2888d36f533a57bc9704ccc84e0>kube-apiserver</a></li>
<li>10.4: <a href=#pg-8a37271ec8fd36a3a1ce07c4c58533d9>kube-controller-manager</a></li>
<li>10.5: <a href=#pg-a727de6cb5a090d5f115f88a8606c438>kube-proxy</a></li>
<li>10.6: <a href=#pg-57e59e5ddd9db63da6c9d27cc0e2f254>kube-scheduler</a></li>
<li>10.7: <a href=#pg-1715b765e2ff39feffd103d59ec0ef07>Kubelet 认证/鉴权</a></li>
<li>10.8: <a href=#pg-bdd3803a4bb6efcc44a7ab03590ce93c>TLS 启动引导</a></li>
</ul>
<li>11: <a href=#pg-a6ae13190e147ef3922315c2091fc258>配置 API</a></li>
<ul>
<li>11.1: <a href=#pg-2896357fe4f62fe85522254410e0be7d>Client Authentication (v1beta1)</a></li>
<li>11.2: <a href=#pg-8f61883225b6bed85530d1904e148392>kube-apiserver Audit Configuration (v1)</a></li>
<li>11.3: <a href=#pg-d8644f8d8b33ff33a31c8b55065eaf37>kube-proxy Configuration (v1alpha1)</a></li>
<li>11.4: <a href=#pg-d673af4d710babea20cd6b317502afb8>kube-scheduler Configuration (v1beta1)</a></li>
<li>11.5: <a href=#pg-699f28965d0a72527ebd04826dda8901>kube-scheduler Policy Configuration (v1)</a></li>
<li>11.6: <a href=#pg-aaa2b8b78fe84a05914c155652d10956>Kubelet Configuration (v1beta1)</a></li>
<li>11.7: <a href=#pg-74f43b2a33c21414f1ed8c359b37d326>WebhookAdmission Configuration (v1)</a></li>
</ul>
<li>12: <a href=#pg-f8b023454daa9497b7eea35b7d35c075>调度</a></li>
<ul>
<li>12.1: <a href=#pg-5a0a68fb6a7ffefb6d5f861100fa0ae3>调度策略</a></li>
<li>12.2: <a href=#pg-ef4fb938b6b63c95f5f26f9b1cec3054>调度器配置</a></li>
</ul>
<li>13: <a href=#pg-c808ce38575e73f72835d7ed02b03780>其他工具</a></li>
<ul>
</ul>
</ul>
<div class=content>
<p>这是 Kubernetes 文档的参考部分。</p>
<h2 id=api-参考>API 参考</h2>
<ul>
<li>
<p><a href=/zh/docs/reference/glossary/>术语表</a> - 一个全面的标准化的 Kubernetes 术语表</p>
</li>
<li>
<p><a href=/zh/docs/reference/kubernetes-api/>Kubernetes API 单页参考</a></p>
</li>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/>Kubernetes API 参考 v1.22</a>。</p>
</li>
<li>
<p><a href=/zh/docs/reference/using-api/>使用 Kubernetes API </a> - Kubernetes 的 API 概述</p>
</li>
<li>
<p><a href=/zh/docs/reference/access-authn-authz/>API 的访问控制</a> - 关于 Kubernetes 如何控制 API 访问的详细信息</p>
</li>
<li>
<p><a href=/zh/docs/reference/labels-annotations-taints/>常见的标签、注解和污点</a></p>
</li>
</ul>
<h2 id=官方支持的客户端库>官方支持的客户端库</h2>
<p>如果您需要通过编程语言调用 Kubernetes API，您可以使用
<a href=/zh/docs/reference/using-api/client-libraries/>客户端库</a>。以下是官方支持的客户端库：</p>
<ul>
<li><a href=https://github.com/kubernetes/client-go/>Kubernetes Go 语言客户端库</a></li>
<li><a href=https://github.com/kubernetes-client/python>Kubernetes Python 语言客户端库</a></li>
<li><a href=https://github.com/kubernetes-client/java>Kubernetes Java 语言客户端库</a></li>
<li><a href=https://github.com/kubernetes-client/javascript>Kubernetes JavaScript 语言客户端库</a></li>
<li><a href=https://github.com/kubernetes-client/csharp>Kubernetes Dotnet 语言客户端库</a></li>
<li><a href=https://github.com/kubernetes-client/haskell>Kubernetes Haskell 语言客户端库</a></li>
</ul>
<h2 id=cli>CLI</h2>
<ul>
<li><a href=/zh/docs/reference/kubectl/overview/>kubectl</a> - 主要的 CLI 工具，用于运行命令和管理 Kubernetes 集群。
<ul>
<li><a href=/zh/docs/reference/kubectl/jsonpath/>JSONPath</a> - 通过 kubectl 使用
<a href=https://goessner.net/articles/JsonPath/>JSONPath 表达式</a> 的语法指南。</li>
</ul>
</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/>kubeadm</a> - 此 CLI 工具可轻松配置安全的 Kubernetes 集群。</li>
</ul>
<h2 id=组件>组件</h2>
<ul>
<li>
<p><a href=/zh/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> -
在每个节点上运行的主代理。kubelet 接收一组 PodSpecs 并确保其所描述的容器健康地运行。</p>
</li>
<li>
<p><a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a> -
REST API，用于验证和配置 API 对象（如 Pod、服务或副本控制器等）的数据。</p>
</li>
<li>
<p><a href=/zh/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a> -
一个守护进程，其中包含 Kubernetes 所附带的核心控制回路。</p>
</li>
<li>
<p><a href=/zh/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> -
可进行简单的 TCP/UDP 流转发或针对一组后端执行轮流 TCP/UDP 转发。</p>
</li>
<li>
<p><a href=/zh/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a> -
一个调度程序，用于管理可用性、性能和容量。</p>
<ul>
<li><a href=/zh/docs/reference/scheduling/policies>调度策略</a></li>
<li><a href=/zh/docs/reference/scheduling/config#profiles>调度配置</a></li>
</ul>
</li>
</ul>
<h2 id=配置-api>配置 API</h2>
<p>本节包含用于配置 kubernetes 组件或工具的 "未发布" API 的文档。
尽管这些 API 对于用户或操作者使用或管理集群来说是必不可少的，
它们大都没有以 RESTful 的方式在 API 服务器上公开。</p>
<ul>
<li><a href=/zh/docs/reference/config-api/kubelet-config.v1beta1/>kubelet 配置 (v1beta1)</a></li>
<li><a href=/zh/docs/reference/config-api/kube-scheduler-config.v1beta1/>kube-scheduler 配置 (v1beta1)</a></li>
<li><a href=/zh/docs/reference/config-api/kube-scheduler-policy-config.v1/>kube-scheduler 策略参考 (v1)</a></li>
<li><a href=/zh/docs/reference/config-api/kube-proxy-config.v1alpha1/>kube-proxy 配置 (v1alpha1)</a></li>
<li><a href=/zh/docs/reference/config-api/apiserver-audit.v1/><code>audit.k8s.io/v1</code> API</a></li>
<li><a href=/zh/docs/reference/config-api/client-authentication.v1beta1/>客户端认证 API (v1beta1)</a></li>
<li><a href=/zh/docs/reference/config-api/apiserver-webhookadmission.v1/>WebhookAdmission 配置 (v1)</a></li>
</ul>
<h2 id=设计文档>设计文档</h2>
<p>Kubernetes 功能的设计文档归档，不妨考虑从
<a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md>Kubernetes 架构</a> 和
<a href=https://git.k8s.io/community/contributors/design-proposals>Kubernetes 设计概述</a>
开始阅读。</p>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2b03679960950df772fb4fe7d78427b9>1 - 词汇表</h1>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-882c82a32bfb4d7946585a93a966b442>2 - API 概述</h1>
<p>本文提供了 Kubernetes API 的参考信息。</p>
<p>REST API 是 Kubernetes 的基本结构。
所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。
因此，Kubernetes 平台视一切皆为 API 对象，
且它们在 <a href=/docs/reference/generated/kubernetes-api/v1.22/>API</a> 中有相应的定义。</p>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/>Kubernetes API 参考</a>列
出了 Kubernetes v1.22 版本的 API。</p>
<p>如需了解一般背景信息，请查阅 <a href=/zh/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>。
<a href=/zh/docs/concepts/security/controlling-access/>Kubernetes API 控制访问</a>描述了客户端如何
向 Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。</p>
<h2 id=api-版本控制>API 版本控制</h2>
<p>JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。
以下描述涵盖了这两种格式。</p>
<p>API 版本控制和软件版本控制是间接相关的。
<a href=https://git.k8s.io/community/contributors/design-proposals/release/versioning.md>API 和发布版本控制提案</a>
描述了 API 版本控制和软件版本控制间的关系。</p>
<p>不同的 API 版本代表着不同的稳定性和支持级别。
你可以在 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions>API 变更文档</a>
中查看到更多的不同级别的判定标准。</p>
<p>下面是每个级别的摘要：</p>
<ul>
<li>Alpha:
<ul>
<li>版本名称包含 <code>alpha</code>（例如，<code>v1alpha1</code>）。</li>
<li>软件可能会有 Bug。启用某个特性可能会暴露出 Bug。
某些特性可能默认禁用。</li>
<li>对某个特性的支持可能会随时被删除，恕不另行通知。</li>
<li>API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。</li>
<li>由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>Beta:</p>
<ul>
<li>版本名称包含 <code>beta</code> （例如， <code>v2beta3</code>）。</li>
<li>软件被很好的测试过。启用某个特性被认为是安全的。
特性默认开启。</li>
<li>尽管一些特性会发生细节上的变化，但它们将会被长期支持。</li>
</ul>
<ul>
<li>在随后的 Beta 版或稳定版中，对象的模式和（或）语义可能以不兼容的方式改变。
当这种情况发生时，将提供迁移说明。
模式更改可能需要删除、编辑和重建 API 对象。
编辑过程可能并不简单。
对于依赖此功能的应用程序，可能需要停机迁移。</li>
<li>该版本的软件不建议生产使用。
后续发布版本可能会有不兼容的变动。
如果你有多个集群可以独立升级，可以放宽这一限制。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 请试用测试版特性时并提供反馈。特性完成 Beta 阶段测试后，
就可能不会有太多的变更了。
</div>
</li>
</ul>
<ul>
<li>Stable:
<ul>
<li>版本名称如 <code>vX</code>，其中 <code>X</code> 为整数。</li>
<li>特性的稳定版本会出现在后续很多版本的发布软件中。</li>
</ul>
</li>
</ul><!--## API groups-->
<h2 id=api-组>API 组</h2>
<p><a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md>API 组</a>
能够简化对 Kubernetes API 的扩展。
API 组信息出现在REST 路径中，也出现在序列化对象的 <code>apiVersion</code> 字段中。</p>
<p>以下是 Kubernetes 中的几个组：</p>
<ul>
<li><em>核心</em>（也叫 <em>legacy</em>）组的 REST 路径为 <code>/api/v1</code>。
核心组并不作为 <code>apiVersion</code> 字段的一部分，例如， <code>apiVersion: v1</code>。</li>
<li>指定的组位于 REST 路径 <code>/apis/$GROUP_NAME/$VERSION</code>，
并且使用 <code>apiVersion: $GROUP_NAME/$VERSION</code> （例如， <code>apiVersion: batch/v1</code>）。
你可以在 <a href=/docs/reference/generated/kubernetes-api/v1.22/#-strong-api-groups-strong->Kubernetes API 参考文档</a>
中查看全部的 API 组。</li>
</ul>
<h2 id=enabling-or-disabling>启用或禁用 API 组 </h2>
<p>资源和 API 组是在默认情况下被启用的。
你可以通过在 API 服务器上设置 <code>--runtime-config</code> 参数来启用或禁用它们。
<code>--runtime-config</code> 参数接受逗号分隔的 <code>&lt;key>[=&lt;value>]</code> 对，
来描述 API 服务器的运行时配置。如果省略了 <code>=&lt;value></code> 部分，那么视其指定为 <code>=true</code>。
例如：</p>
<ul>
<li>禁用 <code>batch/v1</code>， 对应参数设置 <code>--runtime-config=batch/v1=false</code></li>
<li>启用 <code>batch/v2alpha1</code>， 对应参数设置 <code>--runtime-config=batch/v2alpha1</code></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 启用或禁用组或资源时，
你需要重启 API 服务器和控制器管理器来使 <code>--runtime-config</code> 生效。
</div>
<h2 id=持久化>持久化</h2>
<p>Kubernetes 通过 API 资源来将序列化的状态写到 <a class=glossary-tooltip title="etcd 是兼具一致性和高可用性的键值数据库，用作保存 Kubernetes 所有集群数据的后台数据库。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a> 中存储。</p>
<h2 id=接下来>接下来</h2>
<ul>
<li>进一步了解 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#api-conventions>API 惯例</a></li>
<li>阅读 <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/aggregated-api-servers.md>聚合器</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2b5428a2ff6f4831fd972ef50e12b3eb>2.1 - Kubernetes API 概念</h1>
<p>本页描述 Kubernetes API 的通用概念。</p>
<p>Kubernetes API 是基于资源的（RESTful）、通过 HTTP 提供的编程接口。
API 支持通过标准的 HTTP 动词（POST、PUT、PATCH、DELETE 和 GET）
检视、创建、更新和删除主要资源，为很多允许细粒度权限控制的对象提供子资源
（如将 Pod 绑定到节点上），并且出于便利性或效率考虑，支持并提供这些资源的
不同表示形式。
Kubernetes API 还通过 "watch" 和一致性的列表支持高效的资源变更通知，
从而允许其他组件对资源的状态进行高效的缓存和同步。</p>
<h2 id=standard-api-terminology>标准 API 术语 </h2>
<p>大多数 Kubernetes API 资源类型都是
<a href=/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>对象</a>：
它们代表的是集群中某一概念的具体实例，例如一个 Pod 或名字空间。
为数不多的几个 API 资源类型是“虚拟的” - 它们通常代表的是操作而非对象本身，
例如访问权限检查（使用 POST 请求发送一个 JSON 编码的 <code>SubjectAccessReview</code>
负载到 <code>subjectaccessreviews</code> 资源）。
所有对象都有一个唯一的名字，以便支持幂等的创建和检视操作，不过如果虚拟资源类型
不可检视或者不要求幂等，可以不具有唯一的名字。</p>
<p>Kubernetes 一般会利用标准的 RESTful 术语来描述 API 概念：</p>
<ul>
<li><strong>资源类型（Resource Type）</strong> 是在 URL 中使用的名称（<code>pods</code>、<code>namespaces</code>、<code>services</code>）</li>
<li>所有资源类型都有具有一个 JSON 形式（其对象的模式定义）的具体表示，称作<strong>类别（Kind）</strong></li>
<li>某资源类型的实例的列表称作 <strong>集合（Collection）</strong></li>
<li>资源类型的单个实例被称作 <strong>资源（Resource）</strong></li>
</ul>
<p>所有资源类型要么是集群作用域的（<code>/apis/GROUP/VERSION/*</code>），要么是名字空间
作用域的（<code>/apis/GROUP/VERSION/namespaces/NAMESPACE/*</code>）。
名字空间作用域的资源类型会在其名字空间被删除时也被删除，并且对该资源类型的
访问是由定义在名字空间域中的授权检查来控制的。
下列路径用来检视集合和资源：</p>
<ul>
<li>集群作用域的资源：
<ul>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - 返回指定资源类型的资源的集合</li>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME</code> - 返回指定资源类型下名称为 NAME 的资源</li>
</ul>
</li>
<li>名字空间作用域的资源：
<ul>
<li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - 返回所有名字空间中指定资源类型的全部实例的集合</li>
<li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE</code> - 返回名字空间 NAMESPACE 内给定资源类型的全部实例的集合</li>
<li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME</code> - 返回名字空间 NAMESPACE 中给定资源类型的名称为 NAME 的实例</li>
</ul>
</li>
</ul>
<p>由于名字空间本身是一个集群作用域的资源类型，你可以通过 <code>GET /api/v1/namespaces/</code>
检视所有名字空间的列表，使用 <code>GET /api/v1/namespaces/NAME</code> 查看特定名字空间的
详细信息。</p>
<p>几乎所有对象资源类型都支持标准的 HTTP 动词 - GET、POST、PUT、PATCH 和 DELETE。
Kubernetes 使用术语 <strong>list</strong> 来描述返回资源集合的操作，以便与返回单个资源的、
通常称作 <strong>get</strong> 的操作相区分。</p>
<p>某些资源类型有一个或多个子资源（Sub-resource），表现为对应资源下面的子路径：</p>
<ul>
<li>集群作用域的子资源：<code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME/SUBRESOURCE</code></li>
<li>名字空间作用域的子资源：<code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME/SUBRESOURCE</code></li>
</ul>
<p>取决于对象是什么，每个子资源所支持的动词有所不同 - 参见 API 文档以了解更多信息。
跨多个资源来访问其子资源是不可能的 - 如果需要这一能力，则通常意味着需要一种
新的虚拟资源类型了。</p>
<h2 id=efficient-detection-of-changes>高效检测变更 </h2>
<p>为了使客户端能够构造一个模型来表达集群的当前状态，所有 Kubernetes 对象资源类型
都需要支持一致的列表和一个称作 <strong>watch</strong> 的增量变更通知信源（feed）。
每个 Kubernetes 对象都有一个 <code>resourceVersion</code> 字段，代表该资源在下层数据库中
存储的版本。检视资源集合（名字空间作用域或集群作用域）时，服务器返回的响应
中会包含 <code>resourceVersion</code> 值，可用来向服务器发起 watch 请求。
服务器会返回所提供的 <code>resourceVersion</code> 之后发生的所有变更（创建、删除和更新）。
这使得客户端能够取回当前的状态并监视其变更，且不会错过任何变更事件。
客户端的监视连接被断开时，可以从最后返回的 <code>resourceVersion</code> 重启新的监视连接，
或者执行一个新的集合请求之后从头开始监视操作。
参阅<a href=#resource-versions>资源版本语义</a>以了解更多细节。</p>
<p>例如：</p>
<ol>
<li>
<p>列举给定名字空间中的所有 Pods：</p>
<pre><code class=language-console data-lang=console>GET /api/v1/namespaces/test/pods
---
200 OK
Content-Type: application/json
{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {&quot;resourceVersion&quot;:&quot;10245&quot;},
  &quot;items&quot;: [...]
}
</code></pre></li>
</ol>
<ol start=2>
<li>
<p>从资源版本 10245 开始，以 JSON 对象的形式接收所有创建、删除或更新操作的通知：</p>
<pre><code class=language-console data-lang=console>GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  &quot;type&quot;: &quot;ADDED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;10596&quot;, ...}, ...}
}
{
  &quot;type&quot;: &quot;MODIFIED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;11020&quot;, ...}, ...}
}
...
</code></pre></li>
</ol>
<p>给定的 Kubernetes 服务器只会保留一定的时间内发生的历史变更列表。
使用 etcd3 的集群默认保存过去 5 分钟内发生的变更。
当所请求的 watch 操作因为资源的历史版本不存在而失败，客户端必须能够处理
因此而返回的状态代码 <code>410 Gone</code>，清空其本地的缓存，重新执行 list 操作，
并基于新的 list 操作所返回的 <code>resourceVersion</code> 来开始新的 watch 操作。
大多数客户端库都能够提供某种形式的、包含此逻辑的工具。
（在 Go 语言客户端库中，这一设施称作 <code>Reflector</code>，位于
<code>k8s.io/client-go/cache</code> 包中。)</p>
<h3 id=Watch-bookmark>监视书签 </h3>
<p>为了处理历史窗口过短的问题，我们引入了 <code>bookmark（书签）</code> 监视事件的概念。
该事件是一种特殊事件，用来标示客户端所请求的、指定的 <code>resourceVersion</code> 之前
的所有变更都以被发送。该事件中返回的对象是所请求的资源类型，但其中仅包含
<code>resourceVersion</code> 字段，例如：</p>
<pre><code class=language-console data-lang=console>GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245&amp;allowWatchBookmarks=true
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  &quot;type&quot;: &quot;ADDED&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;10596&quot;, ...}, ...}
}
...
{
  &quot;type&quot;: &quot;BOOKMARK&quot;,
  &quot;object&quot;: {&quot;kind&quot;: &quot;Pod&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: {&quot;resourceVersion&quot;: &quot;12746&quot;} }
}
</code></pre>
<p>通过在 watch 请求中设置 <code>allowWatchBookmarks=true</code> 选项，可以请求 <code>bookmark</code>
事件，但是客户端不能假定服务器端会按某特定时间间隔返回书签事件，甚至也不能
假定服务器一定会发送 <code>bookmark</code> 事件。</p>
<h2 id=retrieving-large-results-sets-in-chunks>分块检视大体量结果 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.9 [beta]</code>
</div>
<p>在较大规模的集群中，检视某些资源类型的集合时可能会返回较大体量的响应数据，对
服务器和客户端都会造成影响。例如，某集群可能包含数万个 Pod，每个 Pod 的 JSON
编码都有 1-2 KB 的大小。返回所有名字空间的全部 Pod 时，其结果可能体量很大
（10-20 MB）且耗用大量的服务器资源。
从 Kubernetes 1.9 开始，服务器支持将单一的大体量集合请求分解成多个小数据块
同时还保证整个请求的一致性的能力。
各个数据块可以按顺序返回，进而降低请求的尺寸，允许面向用户的客户端以增量形式
呈现返回结果，改进系统响应效果。</p>
<p>为了用分块的形式返回一个列表，集合请求上可以设置两个新的参数 <code>limit</code> 和
<code>continue</code>，并且所有 list 操作的返回结果列表的 <code>metadata</code> 字段中会包含一个
新的 <code>continue</code> 字段。
客户端应该将 <code>limit</code> 设置为希望在每个数据块中收到的结果个数上限，而服务器则
会在结果中至多返回 <code>limit</code> 个资源并在集合中还有更多资源的时候包含一个
<code>continue</code> 值。客户端在下次请求时则可以将此 <code>continue</code> 值传递给服务器，
告知后者要从何处开始返回结果的下一个数据块。
通过重复这一操作直到服务器端返回空的 <code>continue</code> 值，客户端可以受到结果的
全集。</p>
<p>与 watch 操作类似，<code>continue</code> 令牌也会在很短的时间（默认为 5 分钟）内过期，
并在无法返回更多结果时返回 <code>410 Gone</code> 代码。
这时，客户端需要从头开始执行上述检视操作或者忽略 <code>limit</code> 参数。</p>
<p>例如，如果集群上有 1253 个 Pods，客户端希望每次收到包含至多 500 个 Pod 的
数据块，它应按下面的步骤来请求数据块：</p>
<ol>
<li>列举集群中所有 Pod，每次接收至多 500 个 Pods：</li>
</ol>
<pre><code class=language-console data-lang=console>GET /api/v1/pods?limit=500
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;ENCODED_CONTINUE_TOKEN&quot;,
    ...
  },
  &quot;items&quot;: [...] // returns pods 1-500
}
</code></pre>
<ol start=2>
<li>继续前面的调用，返回下一组 500 个 Pods：</li>
</ol>
<pre><code class=language-console data-lang=console>GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;ENCODED_CONTINUE_TOKEN_2&quot;,
    ...
  },
  &quot;items&quot;: [...] // returns pods 501-1000
}
</code></pre>
<ol start=3>
<li>继续前面的调用，返回最后 253 个 Pods：</li>
</ol>
<pre><code class=language-console data-lang=console>GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN_2
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;PodList&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  &quot;metadata&quot;: {
    &quot;resourceVersion&quot;:&quot;10245&quot;,
    &quot;continue&quot;: &quot;&quot;, // continue token is empty because we have reached the end of the list
    ...
  },
  &quot;items&quot;: [...] // returns pods 1001-1253
}
</code></pre>
<p>注意 list 操作的 <code>resourceVersion</code> 在每个请求中都设置的是同一个数值，
这表明服务器要向我们展示一个一致的 Pods 快照视图。
在版本 <code>10245</code> 之后创建、更新或删除的 Pods 都不会显示出来，除非用户发出
list 请求时不指定 <code>continue</code> 令牌。
这一设计使得客户端能够将较大的响应切分为较小的数据块，且能够对较大的集合
执行监视动作而不会错失任何更新事件。</p>
<h2 id=receiving-resources-as-tables>以表格形式接收资源 </h2>
<p><code>kubectl get</code> 命令的输出是一个包含一个或多个资源的简单表格形式。
过去，客户端需要重复 <code>kubectl</code> 中所实现的表格输出和描述输出逻辑，以执行
简单的对象列表操作。
这一方法在处理某些对象时，需要引入不容忽视的逻辑。
此外，<a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API 聚合</a>
和<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源</a>
所提供的资源类型都是编译时不可预知的。这意味着，客户端必须针对无法
识别的类型提供通用的实现逻辑。</p>
<p>为了避免上述各种潜在的局限性，客户端可以请求服务器端返回对象的表格（Table）
表现形式，从而将打印输出的特定细节委托给服务器。
Kubernetes API 实现标准的 HTTP 内容类型（Content Type）协商：为 <code>GET</code> 调用
传入一个值为 <code>application/json;as=Table;g=meta.k8s.io;v=v1beta1</code> 的 <code>Accept</code>
头部即可请求服务器以 Table 的内容类型返回对象。</p>
<p>例如，以 Table 格式列举集群中所有 Pods：</p>
<pre><code class=language-console data-lang=console>GET /api/v1/pods
Accept: application/json;as=Table;g=meta.k8s.io;v=v1beta1
---
200 OK
Content-Type: application/json

{
    &quot;kind&quot;: &quot;Table&quot;,
    &quot;apiVersion&quot;: &quot;meta.k8s.io/v1beta1&quot;,
    ...
    &quot;columnDefinitions&quot;: [
        ...
    ]
}
</code></pre>
<p>对于在服务器上不存在定制的 Table 定义的 API 资源类型而言，服务器会返回
一个默认的 Table 响应，其中包含资源的 <code>name</code> 和 <code>creationTimestamp</code> 字段。</p>
<pre><code class=language-console data-lang=console>GET /apis/crd.example.com/v1alpha1/namespaces/default/resources
---
200 OK
Content-Type: application/json
...

{
    &quot;kind&quot;: &quot;Table&quot;,
    &quot;apiVersion&quot;: &quot;meta.k8s.io/v1beta1&quot;,
    ...
    &quot;columnDefinitions&quot;: [
        {
            &quot;name&quot;: &quot;Name&quot;,
            &quot;type&quot;: &quot;string&quot;,
            ...
        },
        {
            &quot;name&quot;: &quot;Created At&quot;,
            &quot;type&quot;: &quot;date&quot;,
            ...
        }
    ]
}
</code></pre>
<p><code>kube-apiserver</code> 从 1.10 版本开始提供 Table 响应。
因此，并非所有 API 资源类型都支持 Table 响应，尤其是使用客户端访问较老的集群时。
如果客户端需要能够处理所有资源类型，或者有可能需要与较老的集群交互，
则需要在其 <code>Accept</code> 头部设定多个内容类型值，以便可以回退到非表格形式的 JSON
表示。</p>
<pre><code>Accept: application/json;as=Table;g=meta.k8s.io;v=v1beta1, application/json
</code></pre>
<h2 id=alternate-representations-of-resources>资源的其他表示形式 </h2>
<p>默认情况下，Kubernetes 返回 JSON 序列化的的对象并设定内容类型为
<code>application/json</code>。这是 API 的默认序列化格式。
不过，客户端也可出于大规模环境中更佳性能的需求而请求对象的更为高效的 Protobuf
表现形式。
Kubernetes API 实现了标准的 HTTP 内容类型协商：为 <code>GET</code> 调用传递一个 <code>Accept</code>
头部来请求服务器以所指定的内容类型返回对象，同时在通过 <code>PUT</code> 或 <code>POST</code> 调用
向服务器发送 Protobuf 格式的对象时提供 <code>Content-Type</code> 头部。
服务器会能够支持所请求的格式时返回 <code>Content-Type</code> 头部，并在所提供的内容类型
不合法时返回 <code>406 Not acceptable（无法接受）</code> 错误。</p>
<p>请参阅 API 文档了解每个 API 所支持的内容类型。</p>
<p>例如：</p>
<ol>
<li>以 Protobuf 格式列举集群上的所有 Pods：</li>
</ol>
<pre><code class=language-console data-lang=console>GET /api/v1/pods
Accept: application/vnd.kubernetes.protobuf
---
200 OK
Content-Type: application/vnd.kubernetes.protobuf

... binary encoded PodList object
</code></pre>
<ol start=2>
<li>通过向服务器发送 Protobuf 编码的数据创建 Pod，但请求以 JSON 形式接收响应：</li>
</ol>
<pre><code class=language-console data-lang=console>POST /api/v1/namespaces/test/pods
Content-Type: application/vnd.kubernetes.protobuf
Accept: application/json
... binary encoded Pod object
---
200 OK
Content-Type: application/json

{
  &quot;kind&quot;: &quot;Pod&quot;,
  &quot;apiVersion&quot;: &quot;v1&quot;,
  ...
}
</code></pre>
<p>并非所有 API 资源类型都支持 Protobuf，尤其是那些通过定制资源定义（CRD）或通过
API 扩展而加入的资源。如果客户端必须能够处理所有资源类型，则应在其 <code>Accept</code>
头部指定多种内容类型以便可以回退到 JSON 格式：</p>
<pre><code class=language-console data-lang=console>Accept: application/vnd.kubernetes.protobuf, application/json
</code></pre>
<h3 id=protobuf-encoding>Protobuf encoding</h3>
<p>Kubernetes 使用封套形式来对 Protobuf 响应进行编码。
封套外层由 4 个字节的特殊数字开头，便于从磁盘文件或 etcd 中辩识 Protobuf
格式的（而不是 JSON）数据。
接下来存放的是 Protobuf 编码的封套消息，其中描述下层对象的编码和类型，最后
才是对象本身。</p>
<p>封套格式如下：</p>
<pre><code class=language-console data-lang=console>四个字节的特殊数字前缀：
  字节 0-3: &quot;k8s\x00&quot; [0x6b, 0x38, 0x73, 0x00]

使用下面 IDL 来编码的 Protobuf 消息：
  message Unknown {
    // typeMeta 应该包含 &quot;kind&quot; 和 &quot;apiVersion&quot; 的字符串值，就像
    // 对应的 JSON 对象中所设置的那样
    optional TypeMeta typeMeta = 1;

    // raw 中将保存用 protobuf 序列化的完整对象。
    // 参阅客户端库中为指定 kind 所作的 protobuf 定义
    optional bytes raw = 2;

    // contentEncoding 用于 raw 数据的编码格式。未设置此值意味着没有特殊编码。
    optional string contentEncoding = 3;

    // contentType 包含 raw 数据所采用的序列化方法。
    // 未设置此值意味着  application/vnd.kubernetes.protobuf，且通常被忽略
    optional string contentType = 4;
  }

  message TypeMeta {
    // apiVersion 是 type 对应的组名/版本
    optional string apiVersion = 1;
    // kind 是对象模式定义的名称。此对象应该存在一个 protobuf 定义。
    optional string kind = 2;
  }
</code></pre>
<p>收到 <code>application/vnd.kubernetes.protobuf</code> 格式响应的客户端在响应与预期的前缀
不匹配时应该拒绝响应，因为将来的版本可能需要以某种不兼容的方式更改序列化格式，
并且这种更改是通过变更前缀完成的。</p>
<h2 id=resource-deletion>资源删除 </h2>
<p>资源删除要经过两个阶段：1) 终止（finalization），和 2）去除。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ConfigMap&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;finalizers&#34;</span>: {<span style=color:green;font-weight:700>&#34;url.io/neat-finalization&#34;</span>, <span style=color:green;font-weight:700>&#34;other-url.io/my-finalizer&#34;</span>},
    <span style=color:green;font-weight:700>&#34;deletionTimestamp&#34;</span>: <span>nil</span>,
  }
}
</code></pre></div>
<p>当客户端首先删除某资源时，其 <code>.metadata.deletionTimestamp</code> 会被设置为当前时间。
一旦 <code>.metadata.deletionTimestamp</code> 被设置，则对终结器（finalizers）执行动作
的外部控制器就可以在任何时候、以任何顺序执行其清理工作。
这里不强调顺序是因为很可能带来 <code>.metadata.finalizers</code> 被锁定的风险。
<code>.metadata.finalizers</code> 是一个共享的字段，任何具有相关权限的主体都可以对其
执行重排序的操作。如果终结器列表要按顺序处理，则很可能导致负责列表中第一个
终结器的组件要等待负责列表中排序靠后的终结器的组件的信号（可能是字段值变更、
外部系统或者其他形式），从而导致死锁行为。
在不对终结器顺序作强制要求的情况下，终结器可以自行排序，且不会因为其在列表
中的顺序而引入任何不稳定因素。</p>
<p>当最后一个终结器也被移除时，资源才真正从 etcd 中移除。</p>
<h2 id=single-resource-api>单个资源 API </h2>
<p>API 动词 GET、CREATE、UPDATE、PATCH、DELETE 和 PROXY 仅支持单个资源。
这些支持单一资源的动词不支持以有序或无序列表甚或事务的形式同时提交给
多个资源。
包括 kubectl 在内的客户端将解析资源的列表，并执行单一资源的 API 请求。</p>
<p>API 动词 LIST 和 WATCH 支持获取多个资源，而 DELETECOLLECTION 支持删除多个
资源。</p>
<h2 id=dry-run>试运行 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>修改性质的动词（<code>POST</code>、<code>PUT</code>、<code>PATCH</code> 和 <code>DELETE</code>）可以支持 <em>试运行（dry
run）</em> 模式的请求。试运行模式可帮助通过典型的请求阶段（准入控制链、合法性
检查、合并冲突）来评估请求，只是最终的对象不会写入存储。请求的响应主体与
非试运行模式下的响应尽可能接近。系统会保证试运行模式的请求不会被写入到存储
中，也不会产生其他副作用。</p>
<h3 id=make-a-dry-run-request>发起试运行请求 </h3>
<p>通过设置 <code>dryRun</code> 查询参数可以触发试运行模式。此参数是一个字符串，以枚举值
的形式工作且可接受的值只有：</p>
<ul>
<li>
<p><code>All</code>：每个阶段被会正常运行，除了最后的存储阶段。准入控制器会被运行来检查请求
是否合法，变更性（Mutating）控制器会变更请求，<code>PATCH</code> 请求也会触发合并操作，
对象字段的默认值也会被设置，且基于模式定义的合法性检查也会被执行。
所生成的变更不会被写入到下层的持久性存储中，但本来会写入到数据库中的最终对象
会和正常的状态代码一起被返回给用户。如果请求会触发准入控制器而该准入控制器
带有一定的副作用，则请求会失败而不是冒险产生不希望的副作用。
所有的内置准入控制器插件都支持试运行模式。此外，准入控制 Webhook 也可在其
<a href=/docs/reference/generated/kubernetes-api/v1.22/#webhook-v1beta1-admissionregistration-k8s-io>配置对象</a>
中通过将 <code>sideEffects</code> 字段设置为 "None" 来声明自身不会产生副作用。
如果某 Webhook 确实会产生副作用，那么 <code>sideEffects</code> 字段应该设置为 "NoneOnDryRun"，
并且 Webhook 应该被更改以支持 AdmissionReview 中的 <code>dryRun</code> 字段，从而避免
在试运行时产生副作用。</p>
</li>
<li>
<p>空字符串（也即默认值）：保留默认的修改行为。</p>
</li>
</ul>
<p>例如：</p>
<pre><code class=language-console data-lang=console>POST /api/v1/namespaces/test/pods?dryRun=All
Content-Type: application/json
Accept: application/json
</code></pre>
<p>响应会与非试运行模式请求的响应看起来相同，只是某些生成字段的值可能会不同。</p>
<h3 id=dry-run-authorization>试运行的授权 </h3>
<p>试运行和非试运行请求的鉴权是完全相同的。因此，要发起一个试运行请求，用户必须
被授权执行非试运行请求。</p>
<p>例如，要在 Deployment 对象上试运行 <code>PATCH</code> 操作，你必须具有对 Deployment 执行
<code>PATCH</code> 操作的访问权限，如下面的 RBAC 规则所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;extensions&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;patch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>参阅<a href=/zh/docs/reference/access-authn-authz/authorization/>鉴权概述</a>以了解鉴权细节。</p>
<h3 id=generated-values>生成的值 </h3>
<p>对象的某些值通常是在对象被写入数据库之前生成的。很重要的一点是不要依赖试运行
请求为这些字段所设置的值，因为试运行模式下所得到的这些值与真实请求所获得的
值很可能不同。这类字段有：</p>
<ul>
<li><code>name</code>：如果设置了 <code>generateName</code> 字段，则 <code>name</code> 会获得一个唯一的随机名称</li>
<li><code>creationTimestamp</code>/<code>deletionTimestamp</code>：记录对象的创建/删除时间</li>
<li><code>UID</code>：唯一性标识对象，取值随机生成（非确定性）</li>
<li><code>resourceVersion</code>： 跟踪对象的持久化（存储）版本</li>
<li>变更性准入控制器所设置的字段</li>
<li>对于 <code>Service</code> 资源：<code>kube-apiserver</code> 为 <code>v1.Service</code> 对象分配的端口和 IP</li>
</ul>
<h2 id=server-side-apply>服务器端应用 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code>
</div>
<p>从 Kubernetes v1.18 开始，可以启用<a href=/zh/docs/reference/using-api/server-side-apply/>服务器端应用</a>功能
特性，启用该特性后，控制面会跟踪所有新创建的对象的托管字段。服务器端应用提供了一种简洁的模式来管理字段冲突，提供服务器端的 <code>Apply</code> 和 <code>Update</code> 操作，并取代了
<code>kubectl apply</code> 的客户端功能。有关该特性的详细描述，请参见<a href=/zh/docs/reference/using-api/server-side-apply/>服务器端应用</a>章节</p>
<h2 id=resource-versions>资源版本 </h2>
<p>资源版本采用字符串来表达，用来标示对象的服务器端内部版本。
客户端可以使用资源版本来判定对象是否被更改，或者在读取、列举或监视资源时
用来表达数据一致性需求。
客户端必需将资源版本视为不透明的对象，将其原封不动地传递回服务器端。
例如，客户端一定不能假定资源版本是某种数值标识，也不可以对两个资源版本值
进行比较看其是否相同（也就是不可以比较两个版本值以判断其中一个比另一个
大或小）。</p>
<h3 id=resourceVersion-in-metadata><code>metadata</code> 中的 <code>resourceVersion</code> </h3>
<p>客户端可以在资源中看到资源版本信息，这里的资源包括从服务器返回的 Watch 事件
以及 list 操作响应：</p>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#objectmeta-v1-meta>v1.meta/ObjectMeta</a> - 资源
的 <code>metadata.resourceVersion</code> 值标明该实例上次被更改时的资源版本。</p>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#listmeta-v1-meta>v1.meta/ListMeta</a> - 资源集合
（即 list 操作的响应）的 <code>metadata.resourceVersion</code> 所标明的是 list 响应被构造
时的资源版本。</p>
<h3 id=the-resourceversion-parameter><code>resourceVersion</code> 参数 </h3>
<p>GET、LIST 和 WATCH 操作都支持 <code>resourceVersion</code> 参数。</p>
<p>参数的具体含义取决于所执行的操作和所给的 <code>resourceVersion</code> 值：</p>
<p>对于 GET 和 LIST 而言，资源版本的语义为：</p>
<p><strong>GET：</strong></p>
<table>
<thead>
<tr>
<th>resourceVersion 未设置</th>
<th>resourceVersion="0"</th>
<th>resourceVersion="&lt;非零值>"</th>
</tr>
</thead>
<tbody>
<tr>
<td>最新版本</td>
<td>任何版本</td>
<td>不老于给定版本</td>
</tr>
</tbody>
</table>
<p><strong>LIST：</strong></p>
<p>v1.19 及以上版本的 API 服务器支持 <code>resourceVersionMatch</code> 参数，用以确定如何对
LIST 调用应用 resourceVersion 值。
强烈建议在为 LIST 调用设置了 <code>resourceVersion</code> 时也设置 <code>resourceVersionMatch</code>。
如果 <code>resourceVersion</code> 未设置，则 <code>resourceVersionMatch</code> 是不允许设置的。
为了向后兼容，客户端必须能够容忍服务器在某些场景下忽略 <code>resourceVersionMatch</code> 的行为：</p>
<ul>
<li>
<p>当设置 <code>resourceVersionMatch=NotOlderThan</code> 且指定了 <code>limit</code> 时，客户端必须能够
处理 HTTP 410 "Gone" 响应。例如，客户端可以使用更新一点的 <code>resourceVersion</code>
来重试，或者回退到 <code>resourceVersion=""</code> （即允许返回任何版本）。</p>
</li>
<li>
<p>当设置了 <code>resourceVersionMatch=Exact</code> 且未指定 <code>limit</code> 时，客户端必须验证
响应数据中 <code>ListMeta</code> 的 <code>resourceVersion</code> 与所请求的 <code>resourceVersion</code> 匹配，
并处理二者可能不匹配的情况。例如，客户端可以重试设置了 <code>limit</code> 的请求。</p>
</li>
</ul>
<p>除非你对一致性有着非常强烈的需求，使用 <code>resourceVersionMatch=NotOlderThan</code>
同时为 <code>resourceVersion</code> 设定一个已知值是优选的交互方式，因为与不设置
<code>resourceVersion</code> 和 <code>resourceVersionMatch</code> 相比，这种配置可以取得更好的
集群性能和可扩缩性。后者需要提供带票选能力的读操作。</p>
<table><caption style=display:none>list 操作的 resourceVersionMatch 与分页参数</caption>
<thead>
<tr>
<th>resourceVersionMatch 参数</th>
<th>分页参数</th>
<th>resourceVersion 未设置</th>
<th>resourceVersion="0"</th>
<th>resourceVersion="&lt;非零值>"</th>
</tr>
</thead>
<tbody>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit 未设置</td>
<td>最新版本</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit=&lt;n>, continue 未设置</td>
<td>最新版本</td>
<td>任意版本</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch 未设置</td>
<td>limit=&lt;n>, continue=&lt;token></td>
<td>从 token 开始、精确匹配</td>
<td>非法请求，视为从 token 开始、精确匹配</td>
<td>非法请求，返回 HTTP <code>400 Bad Request</code></td>
</tr>
<tr>
<td>resourceVersionMatch=Exact [1]</td>
<td>limit 未设置</td>
<td>非法请求</td>
<td>非法请求</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch=Exact [1]</td>
<td>limit=&lt;n>, continue 未设置</td>
<td>非法请求</td>
<td>非法请求</td>
<td>精确匹配</td>
</tr>
<tr>
<td>resourceVersionMatch=NotOlderThan [1]</td>
<td>limit 未设置</td>
<td>非法请求</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
<tr>
<td>resourceVersionMatch=NotOlderThan [1]</td>
<td>limit=&lt;n>, continue 未设置</td>
<td>非法请求</td>
<td>任意版本</td>
<td>不老于指定版本</td>
</tr>
</tbody>
</table>
<p><strong>脚注：</strong></p>
<p>[1] 如果服务器无法正确处理 <code>resourceVersionMatch</code> 参数，其行为与未设置该参数相同。
</small></p>
<p>GET 和 LIST 操作的语义含义如下：</p>
<ul>
<li><strong>最新版本：</strong> 返回资源版本为最新的数据。所返回的数据必须一致
（通过票选读操作从 etcd 中取出）。</li>
<li><strong>任意版本：</strong> 返回任意资源版本的数据。优选最新可用的资源版本，不过不能保证
强一致性；返回的数据可能是任何资源版本的。请求返回的数据有可能是客户端以前
看到过的很老的资源版本。尤其在某些高可用配置环境中，网络分区或者高速缓存
未被更新等状态都可能导致这种状况。不能容忍这种不一致性的客户端不应采用此
语义。</li>
</ul>
<ul>
<li>
<p><strong>不老于指定版本：</strong> 返回至少比所提供的 <code>resourceVersion</code> 还要新的数据。
优选最新的可用数据，不过最终提供的可能是不老于所给 <code>resourceVersion</code> 的任何版本。
对于发给能够正确处理 <code>resourceVersionMatch</code> 参数的服务器的 LIST 请求，此语义
保证 <code>ListMeta</code> 中的 <code>resourceVersion</code> 不老于请求的 <code>resourceVersion</code>，不过
不对列表条目之 <code>ObjectMeta</code> 的 <code>resourceVersion</code> 提供任何保证。
这是因为 <code>ObjectMeta.resourceVersion</code> 所跟踪的是列表条目对象上次更新的时间，
而不是对象被返回时是否是最新。</p>
</li>
<li>
<p><strong>确定版本：</strong> 返回精确匹配所给资源版本的数据。如果所指定的 resourceVersion
的数据不可用，服务器会响应 HTTP 410 "Gone"。
对于发送给能够正确处理 <code>resourceVersionMatch</code> 参数的服务器的 LIST 请求而言，
此语义会保证 ListMeta 中的 <code>resourceVersion</code> 与所请求的 <code>resourceVersion</code>
匹配， 不过不对列表条目之 <code>ObjectMeta</code> 的 <code>resourceVersion</code> 提供任何保证。
这是因为 <code>ObjectMeta.resourceVersion</code> 所跟踪的是列表条目对象上次更新的时间，
而不是对象被返回时是否是最新。</p>
</li>
<li>
<p><strong>Continue 令牌、精确匹配：</strong> 返回原先带分页参数的 LIST 调用中指定的资源版本的数据。
在最初的带分页参数的 LIST 调用之后，所有分页式的 LIST 调用都使用所返回的 Continue
令牌来跟踪最初提供的资源版本，</p>
</li>
</ul>
<p>对于 WATCH 操作而言，资源版本的语义如下：</p>
<p><strong>WATCH：</strong></p>
<table><caption style=display:none>watch 操作的 resourceVersion 设置</caption>
<thead>
<tr>
<th>resourceVersion 未设置</th>
<th>resourceVersion="0"</th>
<th>resourceVersion="&lt;非零值>"</th>
</tr>
</thead>
<tbody>
<tr>
<td>读取状态并从最新版本开始</td>
<td>读取状态并从任意版本开始</td>
<td>从指定版本开始</td>
</tr>
</tbody>
</table>
<p>WATCH 操作语义的含义如下：</p>
<ul>
<li><strong>读取状态并从最新版本开始：</strong> 从最新的资源版本开始 WATCH 操作。这里的
最新版本必须是一致的（即通过票选读操作从 etcd 中取出）。为了建立初始状态，
WATCH 首先会处理一组合成的 "Added" 事件，这些事件涵盖在初始资源版本中存在
的所有资源实例。
所有后续的 WATCH 事件都是关于 WATCH 开始时所处资源版本之后发生的变更。</li>
</ul>
<ul>
<li><strong>读取状态并从任意版本开始：</strong> 警告：通过这种方式初始化的 WATCH 操作可能会
返回任何状态的停滞数据。请在使用此语义之前执行复核，并在可能的情况下采用其他
语义。此语义会从任意资源版本开始执行 WATCH 操作，优选最新的可用的资源版本，
不过不是必须的；采用任何资源版本作为起始版本都是被允许的。
WATCH 操作有可能起始于客户端已经观测到的很老的版本。在高可用配置环境中，因为
网络分裂或者高速缓存未及时更新的原因都会造成此现象。
如果客户端不能容忍这种不一致性，就不要使用此语义来启动 WATCH 操作。
为了建立初始状态，WATCH 首先会处理一组合成的 "Added" 事件，这些事件涵盖在
初始资源版本中存在的所有资源实例。
所有后续的 WATCH 事件都是关于 WATCH 开始时所处资源版本之后发生的变更。</li>
</ul>
<ul>
<li><strong>从指定版本开始：</strong> 从某确切资源版本开始执行 WATCH 操作。WATCH 事件都是
关于 WATCH 开始时所处资源版本之后发生的变更。与前面两种语义不同，WATCH 操作
开始的时候不会生成或处理为所提供资源版本合成的 "Added" 事件。
我们假定客户端既然能够提供确切资源版本，就应该已经拥有了起始资源版本对应的初始状态。</li>
</ul>
<h3 id=410-gone-responses>"410 Gone" 响应 </h3>
<p>服务器不需要提供所有老的资源版本，在客户端请求的是早于服务器端所保留版本的
<code>resourceVersion</code> 时，可以返回 HTTP <code>410 (Gone)</code> 状态码。
客户端必须能够容忍 <code>410 (Gone)</code> 响应。
参阅<a href=#efficient-detection-of-changes>高效检测变更</a>以了解如何在监测资源时
处理 <code>410 (Gone)</code> 响应。</p>
<p>如果所请求的 <code>resourceVersion</code> 超出了可应用的 <code>limit</code>，那么取决于请求是否
是通过高速缓存来满足的，API 服务器可能会返回一个 <code>410 Gone</code> HTTP 响应。</p>
<h3 id=unavailable-resource-versions>不可用的资源版本 </h3>
<p>服务器不必未无法识别的资源版本提供服务。针对无法识别的资源版本的 LIST 和 GET 请求
可能会短暂等待，以期资源版本可用。如果所给的资源版本在一定的时间段内仍未变得
可用，服务器应该超时并返回 <code>504 (Gateway Timeout)</code>，且可在响应中添加
<code>Retry-After</code> 响应头部字段，标明客户端在再次尝试之前应该等待多少秒钟。
目前，<code>kube-apiserver</code> 也能使用 <code>Too large resource version（资源版本过高）</code>
消息来标识这类响应。针对某无法识别的资源版本的 WATCH 操作可能会无限期
（直到请求超时）地等待下去，直到资源版本可用。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-040d9484db673074f1b8ba3465be9d91>2.2 - 服务器端应用（Server-Side Apply）</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<h2 id=introduction>简介</h2>
<p>服务器端应用协助用户、控制器通过声明式配置的方式管理他们的资源。
客户端可以发送完整描述的目标（A fully specified intent），
声明式地创建和/或修改
<a href=/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/>对象</a>。</p>
<p>一个完整描述的目标并不是一个完整的对象，仅包括能体现用户意图的字段和值。
该目标（intent）可以用来创建一个新对象，
也可以通过服务器来实现与现有对象的<a href=#merge-strategy>合并</a>。</p>
<p>系统支持多个应用者（appliers）在同一个对象上开展协作。</p>
<p>“<a href=#field-management>字段管理（field management）</a>”机制追踪对象字段的变化。
当一个字段值改变时，其所有权从当前管理器（manager）转移到施加变更的管理器。
当尝试将新配置应用到一个对象时，如果字段有不同的值，且由其他管理器管理，
将会引发<a href=#conflicts>冲突</a>。
冲突引发警告信号：此操作可能抹掉其他协作者的修改。
冲突可以被刻意忽略，这种情况下，值将会被改写，所有权也会发生转移。</p>
<p>当你从配置文件中删除一个字段，然后应用这个配置文件，
这将触发服务端应用检查此字段是否还被其他字段管理器拥有。
如果没有，那就从活动对象中删除该字段；如果有，那就重置为默认值。
该规则同样适用于 list 或 map 项目。</p>
<p>服务器端应用既是原有 <code>kubectl apply</code> 的替代品，
也是控制器发布自身变化的一个简化机制。</p>
<p>如果你启用了服务器端应用，控制平面就会跟踪被所有新创建对象管理的字段。</p>
<h2 id=field-management>字段管理</h2>
<p>相对于通过 <code>kubectl</code> 管理的注解 <code>last-applied</code>，
服务器端应用使用了一种更具声明式特点的方法：
它持续的跟踪用户的字段管理，而不仅仅是最后一次的执行状态。
这就意味着，作为服务器端应用的一个副作用，
关于用哪一个字段管理器负责管理对象中的哪个字段的这类信息，都要对外界开放了。</p>
<p>用户管理字段这件事，在服务器端应用的场景中，意味着用户依赖并期望字段的值不要改变。
最后一次对字段值做出断言的用户将被记录到当前字段管理器。
这可以通过发送 <code>POST</code>、 <code>PUT</code>、
或非应用（non-apply）方式的 <code>PATCH</code> 等命令来修改字段值的方式实现，
或通过把字段放在配置文件中，然后发送到服务器端应用的服务端点的方式实现。
当使用服务器端应用，尝试着去改变一个被其他人管理的字段，
会导致请求被拒绝（在没有设置强制执行时，参见<a href=#conflicts>冲突</a>）。</p>
<p>如果两个或以上的应用者均把同一个字段设置为相同值，他们将共享此字段的所有权。
后续任何改变共享字段值的尝试，不管由那个应用者发起，都会导致冲突。
共享字段的所有者可以放弃字段的所有权，这只需从配置文件中删除该字段即可。</p>
<p>字段管理的信息存储在 <code>managedFields</code> 字段中，该字段是对象的
<a href=/docs/reference/generated/kubernetes-api/v1.22/#objectmeta-v1-meta><code>metadata</code></a>
中的一部分。</p>
<p>服务器端应用创建对象的简单示例如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cm<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test-label</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kubectl<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>time</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2010-10-10T0:00:00Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fieldsType</span>:<span style=color:#bbb> </span>FieldsV1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fieldsV1</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>f:test-label</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:key</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>some value<span style=color:#bbb>
</span></code></pre></div>
<p>上述对象在 <code>metadata.managedFields</code> 中包含了唯一的管理器。
管理器由管理实体自身的基本信息组成，比如操作类型、API 版本、以及它管理的字段。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 该字段由 API 服务器管理，用户不应该改动它。
</div>
<p>不过，执行 <code>Update</code> 操作修改 <code>metadata.managedFields</code> 也是可实现的。
强烈不鼓励这么做，但当发生如下情况时，
比如 <code>managedFields</code> 进入不一致的状态（显然不应该发生这种情况），
这么做也是一个合理的尝试。</p>
<p><code>managedFields</code> 的格式在
<a href=/docs/reference/generated/kubernetes-api/v1.22/#fieldsv1-v1-meta>API</a>
文档中描述。</p>
<h2 id=conflicts>冲突</h2>
<p>冲突是一种特定的错误状态，
发生在执行 <code>Apply</code> 改变一个字段，而恰巧该字段被其他用户声明过主权时。
这可以防止一个应用者不小心覆盖掉其他用户设置的值。
冲突发生时，应用者有三种办法来解决它：</p>
<ul>
<li>
<p><strong>覆盖前值，成为唯一的管理器：</strong> 如果打算覆盖该值（或应用者是一个自动化部件，比如控制器），
应用者应该设置查询参数 <code>force</code> 为 true，然后再发送一次请求。
这将强制操作成功，改变字段的值，从所有其他管理器的 managedFields 条目中删除指定字段。</p>
</li>
<li>
<p><strong>不覆盖前值，放弃管理权：</strong> 如果应用者不再关注该字段的值，
可以从配置文件中删掉它，再重新发送请求。
这就保持了原值不变，并从 managedFields 的应用者条目中删除该字段。</p>
</li>
<li>
<p><strong>不覆盖前值，成为共享的管理器：</strong> 如果应用者仍然关注字段值，并不想覆盖它，
他们可以在配置文件中把字段的值改为和服务器对象一样，再重新发送请求。
这样在不改变字段值的前提下，
就实现了字段管理被应用者和所有声明了管理权的其他的字段管理器共享。</p>
</li>
</ul>
<h2 id=managers>管理器</h2>
<p>管理器识别出正在修改对象的工作流程（在冲突时尤其有用）,
管理器可以通过修改请求的参数 <code>fieldManager</code> 指定。
虽然 kubectl 默认发往 <code>kubectl</code> 服务端点，但它则请求到应用的服务端点（apply endpoint）。
对于其他的更新，它默认的是从用户代理计算得来。</p>
<h2 id=apply-and-update>应用和更新</h2>
<p>此特性涉及两类操作，分别是 <code>Apply</code>
（内容类型为 <code>application/apply-patch+yaml</code> 的 <code>PATCH</code> 请求）
和 <code>Update</code> （所有修改对象的其他操作）。
这两类操作都会更新字段 <code>managedFields</code>，但行为表现有一点不同。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> <p>不管你提交的是 JSON 数据还是 YAML 数据，
都要使用 <code>application/apply-patch+yaml</code> 作为 <code>Content-Type</code> 的值。</p>
<p>所有的 JSON 文档 都是合法的 YAML。</p>
</div>
<p>例如，在冲突发生的时候，只有 <code>apply</code> 操作失败，而 <code>update</code> 则不会。
此外，<code>apply</code> 操作必须通过提供一个 <code>fieldManager</code> 查询参数来标识自身，
而此查询参数对于 <code>update</code> 操作则是可选的。
最后，当使用 <code>apply</code> 命令时，你不能在应用中的对象中持有 <code>managedFields</code>。</p>
<p>一个包含多个管理器的对象，示例如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cm<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test-label</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kubectl<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>f:test-label</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kube-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Update<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>time</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;2019-03-30T16:00:00.000Z&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:key</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>new value<span style=color:#bbb>
</span></code></pre></div>
<p>在这个例子中，
第二个操作被管理器 <code>kube-controller-manager</code> 以 <code>Update</code> 的方式运行。
此 <code>update</code> 更改 data 字段的值，
并使得字段管理器被改为 <code>kube-controller-manager</code>。</p>
<p>如果把 <code>update</code> 操作改为 <code>Apply</code>，那就会因为所有权冲突的原因，导致操作失败。</p>
<h2 id=merge-strategy>合并策略</h2>
<p>由服务器端应用实现的合并策略，提供了一个总体更稳定的对象生命周期。
服务器端应用试图依据负责管理它们的主体来合并字段，而不是根据值来否决。
这么做是为了多个主体可以更新同一个对象，且不会引起意外的相互干扰。</p>
<p>当用户发送一个“完整描述的目标”对象到服务器端应用的服务端点，
服务器会将它和活动对象做一次合并，如果两者中有重复定义的值，那就以配置文件的为准。
如果配置文件中的项目集合不是此用户上一次操作项目的超集，
所有缺少的、没有其他应用者管理的项目会被删除。
关于合并时用来做决策的对象规格的更多信息，参见
<a href=https://sigs.k8s.io/structured-merge-diff>sigs.k8s.io/structured-merge-diff</a>.</p>
<p>Kubernetes 1.16 和 1.17 中添加了一些标记，
允许 API 开发人员描述由 list、map、和 structs 支持的合并策略。
这些标记可应用到相应类型的对象，在 Go 文件或在
<a href=/docs/reference/generated/kubernetes-api/v1.22#jsonschemaprops-v1-apiextensions-k8s-io>CRD</a>
的 OpenAPI 的模式中定义：</p>
<table>
<thead>
<tr>
<th>Golang 标记</th>
<th>OpenAPI extension</th>
<th>可接受的值</th>
<th>描述</th>
<th>引入版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>//+listType</code></td>
<td><code>x-kubernetes-list-type</code></td>
<td><code>atomic</code>/<code>set</code>/<code>map</code></td>
<td>适用于 list。<code>set</code> 适用于仅包含标量元素的列表。这些元素必须是不重复的。<code>map</code> 仅适用于包含嵌套类型的列表。列表中的键（参见 <code>listMapKey</code>）不可以重复。<code>atomic</code> 适用于任何类型的列表。如果配置为 <code>atomic</code>，则合并时整个列表会被替换掉。任何时候，只有一个管理器负责管理指定列表。如果配置为 <code>set</code> 或 <code>map</code>，不同的管理器也可以分开管理条目。</td>
<td>1.16</td>
</tr>
<tr>
<td><code>//+listMapKey</code></td>
<td><code>x-kubernetes-list-map-keys</code></td>
<td>字段名称的列表，例如，<code>["port", "protocol"]</code></td>
<td>仅当 <code>+listType=map</code> 时适用。取值为字段名称的列表，这些字段值的组合能够唯一标识列表中的条目。尽管可以存在多个键，<code>listMapKey</code> 是单数的，这是因为键名需要在 Go 类型中各自独立指定。键字段必须是标量。</td>
<td>1.16</td>
</tr>
<tr>
<td><code>//+mapType</code></td>
<td><code>x-kubernetes-map-type</code></td>
<td><code>atomic</code>/<code>granular</code></td>
<td>适用于 map。 <code>atomic</code> 指 map 只能被单个的管理器整个的替换。 <code>granular</code> 指 map 支持多个管理器各自更新自己的字段。</td>
<td>1.17</td>
</tr>
<tr>
<td><code>//+structType</code></td>
<td><code>x-kubernetes-map-type</code></td>
<td><code>atomic</code>/<code>granular</code></td>
<td>适用于 structs；否则就像 <code>//+mapType</code> 有相同的用法和 openapi 注释.</td>
<td>1.17</td>
</tr>
</tbody>
</table>
<p>若未指定 <code>listType</code>，API 服务器将 <code>patchMergeStrategy=merge</code> 标记解释为
<code>listType=map</code> 并且视对应的 <code>patchMergeKey</code> 标记为 <code>listMapKey</code> 取值。</p>
<p><code>atomic</code> 列表类型是递归的。</p>
<p>这些标记都是用源代码注释的方式给出的，不必作为字段标签（tag）再重复。</p>
<h3 id=compatibility-across-toplogy-changes>拓扑变化时的兼容性 </h3>
<p>在极少的情况下，CRD 或者内置类型的作者可能希望更改其资源中的某个字段的
拓扑配置，同时又不提升版本号。
通过升级集群或者更新 CRD 来更改类型的拓扑信息与更新现有对象的结果不同。
变更的类型有两种：一种是将字段从 <code>map</code>/<code>set</code>/<code>granular</code> 更改为 <code>atomic</code>，
另一种是做逆向改变。</p>
<p>当 <code>listType</code>、<code>mapType</code> 或 <code>structType</code> 从 <code>map</code>/<code>set</code>/<code>granular</code> 改为
<code>atomic</code> 时，现有对象的整个列表、映射或结构的属主都会变为这些类型的
元素之一的属主。这意味着，对这些对象的进一步变更会引发冲突。</p>
<p>当一个列表、映射或结构从 <code>atomic</code> 改为 <code>map</code>/<code>set</code>/<code>granular</code> 之一
时，API 服务器无法推导这些字段的新的属主。因此，当对象的这些字段
再次被更新时不会引发冲突。出于这一原因，不建议将某类型从 <code>atomic</code> 改为
<code>map</code>/<code>set</code>/<code>granular</code>。</p>
<p>以下面的自定义资源为例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Foo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-sample<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>manager-one<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key1</span>:<span style=color:#bbb> </span>val1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key2</span>:<span style=color:#bbb> </span>val2<span style=color:#bbb>
</span></code></pre></div>
<p>在 <code>spec.data</code> 从 <code>atomic</code> 改为 <code>granular</code> 之前，<code>manager-one</code> 是
<code>spec.data</code> 字段及其所包含字段（<code>key1</code> 和 <code>key2</code>）的属主。
当对应的 CRD 被更改，使得 <code>spec.data</code> 变为 <code>granular</code> 拓扑时，
<code>manager-one</code> 继续拥有顶层字段 <code>spec.data</code>（这意味着其他管理者想
删除名为 <code>data</code> 的映射而不引起冲突是不可能的），但不再拥有
<code>key1</code> 和 <code>key2</code>。因此，其他管理者可以在不引起冲突的情况下更改
或删除这些字段。</p>
<h3 id=custom-resources>自定义资源</h3>
<p>默认情况下，服务器端应用把自定义资源看做非结构化数据。
所有的键值（keys）就像 struct 的字段一样被处理，
所有的 list 被认为是原子性的。</p>
<p>如果自定义资源定义（Custom Resource Definition，CRD）定义了一个
<a href=/docs/reference/generated/kubernetes-api/v1.22#jsonschemaprops-v1-apiextensions-k8s-io>模式</a>，
它包含类似以前“合并策略”章节中定义过的注解，
这些注解将在合并此类型的对象时使用。</p>
<h2 id=using-server-side-apply-in-controller>在控制器中使用服务器端应用</h2>
<p>控制器的开发人员可以把服务器端应用作为简化控制器的更新逻辑的方式。
读-改-写 和/或 patch 的主要区别如下所示：</p>
<ul>
<li>应用的对象必须包含控制器关注的所有字段。</li>
<li>对于在控制器没有执行过应用操作之前就已经存在的字段，不能删除。
（控制器在这种用例环境下，依然可以发送一个 PATCH/UPDATE）</li>
<li>对象不必事先读取，<code>resourceVersion</code> 不必指定。</li>
</ul>
<p>强烈推荐：设置控制器在冲突时强制执行，这是因为冲突发生时，它们没有其他解决方案或措施。</p>
<h2 id=transferring-ownership>转移所有权</h2>
<p>除了通过<a href=#conflicts>冲突解决方案</a>提供的并发控制，
服务器端应用提供了一些协作方式来将字段所有权从用户转移到控制器。</p>
<p>最好通过例子来说明这一点。
让我们来看看，在使用 Horizo​​ntalPodAutoscaler 资源和与之配套的控制器，
且开启了 Deployment 的自动水平扩展功能之后，
怎么安全的将 <code>replicas</code> 字段的所有权从用户转移到控制器。</p>
<p>假设用户定义了 Deployment，且 <code>replicas</code> 字段已经设置为期望的值：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/ssa/nginx-deployment.yaml download=application/ssa/nginx-deployment.yaml><code>application/ssa/nginx-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-ssa-nginx-deployment-yaml')" title="Copy application/ssa/nginx-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-ssa-nginx-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>并且，用户使用服务器端应用，像这样创建 Deployment：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment.yaml --server-side
</code></pre></div>
<p>然后，为 Deployment 启用 HPA，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl autoscale deployment nginx-deployment --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span> --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>
</code></pre></div>
<p>现在，用户希望从他们的配置中删除 <code>replicas</code>，所以他们总是和 HPA 控制器冲突。
然而，这里存在一个竟态：
在 HPA 需要调整 <code>replicas</code> 之前会有一个时间窗口，
如果在 HPA 写入字段成为所有者之前，用户删除了<code>replicas</code>，
那 API 服务器就会把 <code>replicas</code> 的值设为 1， 也就是默认值。
这不是用户希望发生的事情，即使是暂时的。</p>
<p>这里有两个解决方案：</p>
<ul>
<li>（基本操作）把 <code>replicas</code> 留在配置文件中；当 HPA 最终写入那个字段，
系统基于此事件告诉用户：冲突发生了。在这个时间点，可以安全的删除配置文件。</li>
<li>（高级操作）然而，如果用户不想等待，比如他们想为合作伙伴保持集群清晰，
那他们就可以执行以下步骤，安全的从配置文件中删除 <code>replicas</code>。</li>
</ul>
<p>首先，用户新定义一个只包含 <code>replicas</code> 字段的配置文件：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/ssa/nginx-deployment-replicas-only.yaml download=application/ssa/nginx-deployment-replicas-only.yaml><code>application/ssa/nginx-deployment-replicas-only.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-ssa-nginx-deployment-replicas-only-yaml')" title="Copy application/ssa/nginx-deployment-replicas-only.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-ssa-nginx-deployment-replicas-only-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>用户使用名为 <code>handover-to-hpa</code> 的字段管理器，应用此配置文件。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment-replicas-only.yaml <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --server-side --field-manager<span style=color:#666>=</span>handover-to-hpa <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --validate<span style=color:#666>=</span><span style=color:#a2f>false</span>
</code></pre></div>
<p>如果应用操作和 HPA 控制器产生冲突，那什么都不做。
冲突表明控制器在更早的流程中已经对字段声明过所有权。</p>
<p>在此时间点，用户可以从配置文件中删除 <code>replicas</code> 。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/application/ssa/nginx-deployment-no-replicas.yaml download=application/ssa/nginx-deployment-no-replicas.yaml><code>application/ssa/nginx-deployment-no-replicas.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-ssa-nginx-deployment-no-replicas-yaml')" title="Copy application/ssa/nginx-deployment-no-replicas.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-ssa-nginx-deployment-no-replicas-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>注意，只要 HPA 控制器为 <code>replicas</code> 设置了一个新值，
该临时字段管理器将不再拥有任何字段，会被自动删除。
这里不需要执行清理工作。</p>
<h3 id=transferring-ownership-between-users>在用户之间转移所有权</h3>
<p>通过在配置文件中把一个字段设置为相同的值，用户可以在他们之间转移字段的所有权，
从而共享了字段的所有权。
当用户共享了字段的所有权，任何一个用户可以从他的配置文件中删除该字段，
并应用该变更，从而放弃所有权，并实现了所有权向其他用户的转移。</p>
<h2 id=comparison-with-client-side-apply>与客户端应用的对比</h2>
<p>由服务器端应用实现的冲突检测和解决方案的一个结果就是，
应用者总是可以在本地状态中得到最新的字段值。
如果得不到最新值，下次执行应用操作时就会发生冲突。
解决冲突三个选项的任意一个都会保证：此应用过的配置文件是服务器上对象字段的最新子集。</p>
<p>这和客户端应用（Client Side Apply） 不同，如果有其他用户覆盖了此值，
过期的值被留在了应用者本地的配置文件中。
除非用户更新了特定字段，此字段才会准确，
应用者没有途径去了解下一次应用操作是否会覆盖其他用户的修改。</p>
<p>另一个区别是使用客户端应用的应用者不能改变他们正在使用的 API 版本，但服务器端应用支持这个场景。</p>
<h2 id=upgrading-from-client-side-apply-to-server-side-apply>从客户端应用升级到服务器端应用</h2>
<p>客户端应用方式时，用户使用 <code>kubectl apply</code> 管理资源，
可以通过使用下面标记切换为使用服务器端应用。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply --server-side <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</code></pre></div>
<p>默认情况下，对象的字段管理从客户端应用方式迁移到 kubectl 触发的服务器端应用时，不会发生冲突。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong> <p>保持注解 <code>last-applied-configuration</code> 是最新的。
从注解能推断出字段是由客户端应用管理的。
任何没有被客户端应用管理的字段将引发冲突。</p>
<p>举例说明，比如你在客户端应用之后，
使用 <code>kubectl scale</code> 去更新 <code>replicas</code> 字段，
可是该字段并没有被客户端应用所拥有，
在执行 <code>kubectl apply --server-side</code> 时就会产生冲突。</p>
</div>
<p>此操作以 <code>kubectl</code> 作为字段管理器来应用到服务器端应用。
作为例外，可以指定一个不同的、非默认字段管理器停止的这种行为，如下面的例子所示。
对于 kubectl 触发的服务器端应用，默认的字段管理器是 <code>kubectl</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply --server-side --field-manager<span style=color:#666>=</span>my-manager <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</code></pre></div>
<h2 id=downgrading-from-server-side-apply-to-client-side-apply>从服务器端应用降级到客户端应用</h2>
<p>如果你用 <code>kubectl apply --server-side</code> 管理一个资源，
可以直接用 <code>kubectl apply</code> 命令将其降级为客户端应用。</p>
<p>降级之所以可行，这是因为 <code>kubectl server-side apply</code>
会保存最新的 <code>last-applied-configuration</code> 注解。</p>
<p>此操作以 <code>kubectl</code> 作为字段管理器应用到服务器端应用。
作为例外，可以指定一个不同的、非默认字段管理器停止这种行为，如下面的例子所示。
对于 kubectl 触发的服务器端应用，默认的字段管理器是 <code>kubectl</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply --server-side --field-manager<span style=color:#666>=</span>my-manager <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</code></pre></div>
<h2 id=api-endpoint>API 端点</h2>
<p>启用了服务器端应用特性之后，
<code>PATCH</code> 服务端点接受额外的内容类型 <code>application/apply-patch+yaml</code>。
服务器端应用的用户就可以把 YAMl 格式的
部分定义对象（partially specified objects）发送到此端点。
当一个配置文件被应用时，它应该包含所有体现你意图的字段。</p>
<h2 id=clearing-managedfields>清除 ManagedFields</h2>
<p>可以从对象中剥离所有 managedField，
实现方法是通过使用 <code>MergePatch</code>、 <code>StrategicMergePatch</code>、
<code>JSONPatch</code>、 <code>Update</code>、以及所有的非应用方式的操作来覆盖它。
这可以通过用空条目覆盖 managedFields 字段的方式实现。以下是两个示例：</p>
<pre><code class=language-console data-lang=console>PATCH /api/v1/namespaces/default/configmaps/example-cm
Content-Type: application/merge-patch+json
Accept: application/json
Data: {&quot;metadata&quot;:{&quot;managedFields&quot;: [{}]}}
</code></pre><pre><code class=language-console data-lang=console>PATCH /api/v1/namespaces/default/configmaps/example-cm
Content-Type: application/json-patch+json
Accept: application/json
Data: [{&quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;/metadata/managedFields&quot;, &quot;value&quot;: [{}]}]
</code></pre>
<p>这一操作将用只包含一个空条目的列表覆写 managedFields，
来实现从对象中整个的去除 managedFields。
注意，只把 managedFields 设置为空列表并不会重置字段。
这么做是有目的的，所以 managedFields 将永远不会被与该字段无关的客户删除。</p>
<p>在重置操作结合 managedFields 以外其他字段更改的场景中，
将导致 managedFields 首先被重置，其他改变被押后处理。
其结果是，应用者取得了同一个请求中所有字段的所有权。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong> 对于不接受资源对象类型的子资源（sub-resources），
服务器端应用不能正确地跟踪其所有权。
如果你对这样的子资源使用服务器端应用，变更的字段将不会被跟踪。
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-79880efc25dc8cb3b6962ad78a964319>2.3 - 客户端库</h1>
<p>本页面包含基于各种编程语言使用 Kubernetes API 的客户端库概述。</p>
<p>在使用 <a href=/zh/docs/reference/using-api/>Kubernetes REST API</a> 编写应用程序时，
您并不需要自己实现 API 调用和 “请求/响应” 类型。
您可以根据自己的编程语言需要选择使用合适的客户端库。</p>
<p>客户端库通常为您处理诸如身份验证之类的常见任务。
如果 API 客户端在 Kubernetes 集群中运行，大多数客户端库可以发现并使用 Kubernetes 服务帐户进行身份验证，
或者能够理解 <a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig 文件</a>
格式来读取凭据和 API 服务器地址。</p>
<h2 id=officially-supported-kubernetes-client-libraries>官方支持的 Kubernetes 客户端库 </h2>
<p>以下客户端库由 <a href=https://github.com/kubernetes/community/tree/master/sig-api-machinery>Kubernetes SIG API Machinery</a> 正式维护。</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>客户端库</th>
<th>样例程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>dotnet</td>
<td><a href=https://github.com/kubernetes-client/csharp>github.com/kubernetes-client/csharp</a></td>
<td><a href=https://github.com/kubernetes-client/csharp/tree/master/examples/simple>浏览</a></td>
</tr>
<tr>
<td>Go</td>
<td><a href=https://github.com/kubernetes/client-go/>github.com/kubernetes/client-go/</a></td>
<td><a href=https://github.com/kubernetes/client-go/tree/master/examples>浏览</a></td>
</tr>
<tr>
<td>Haskell</td>
<td><a href=https://github.com/kubernetes-client/haskell>github.com/kubernetes-client/haskell</a></td>
<td><a href=https://github.com/kubernetes-client/haskell/tree/master/kubernetes-client/example>浏览</a></td>
</tr>
<tr>
<td>Java</td>
<td><a href=https://github.com/kubernetes-client/java/>github.com/kubernetes-client/java</a></td>
<td><a href=https://github.com/kubernetes-client/java#installation>浏览</a></td>
</tr>
<tr>
<td>JavaScript</td>
<td><a href=https://github.com/kubernetes-client/javascript>github.com/kubernetes-client/javascript</a></td>
<td><a href=https://github.com/kubernetes-client/javascript/tree/master/examples>浏览</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/kubernetes-client/python/>github.com/kubernetes-client/python/</a></td>
<td><a href=https://github.com/kubernetes-client/python/tree/master/examples>浏览</a></td>
</tr>
</tbody>
</table>
<h2 id=community-maintained-client-libraries>社区维护的客户端库 </h2>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>说明：</strong>
本部分链接到提供 Kubernetes 所需功能的第三方项目。Kubernetes 项目作者不负责这些项目。此页面遵循<a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 网站指南</a>，按字母顺序列出项目。要将项目添加到此列表中，请在提交更改之前阅读<a href=/docs/contribute/style/content-guide/#third-party-content>内容指南</a>。</div>
<p>以下 Kubernetes API 客户端库是由社区，而非 Kubernetes 团队支持、维护的。</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>客户端库</th>
</tr>
</thead>
<tbody>
<tr>
<td>Clojure</td>
<td><a href=https://github.com/yanatan16/clj-kubernetes-api>github.com/yanatan16/clj-kubernetes-api</a></td>
</tr>
<tr>
<td>DotNet</td>
<td><a href=https://github.com/tonnyeremin/kubernetes_gen>github.com/tonnyeremin/kubernetes_gen</a></td>
</tr>
<tr>
<td>DotNet (RestSharp)</td>
<td><a href=https://github.com/masroorhasan/Kubernetes.DotNet>github.com/masroorhasan/Kubernetes.DotNet</a></td>
</tr>
<tr>
<td>Elixir</td>
<td><a href=https://github.com/obmarg/kazan/>github.com/obmarg/kazan</a></td>
</tr>
<tr>
<td>Elixir</td>
<td><a href=https://github.com/coryodaniel/k8s>github.com/coryodaniel/k8s</a></td>
</tr>
<tr>
<td>Go</td>
<td><a href=https://github.com/ericchiang/k8s>github.com/ericchiang/k8s</a></td>
</tr>
<tr>
<td>Java (OSGi)</td>
<td><a href=https://bitbucket.org/amdatulabs/amdatu-kubernetes>bitbucket.org/amdatulabs/amdatu-kubernetes</a></td>
</tr>
<tr>
<td>Java (Fabric8, OSGi)</td>
<td><a href=https://github.com/fabric8io/kubernetes-client>github.com/fabric8io/kubernetes-client</a></td>
</tr>
<tr>
<td>Java</td>
<td><a href=https://github.com/manusa/yakc>github.com/manusa/yakc</a></td>
</tr>
<tr>
<td>Lisp</td>
<td><a href=https://github.com/brendandburns/cl-k8s>github.com/brendandburns/cl-k8s</a></td>
</tr>
<tr>
<td>Lisp</td>
<td><a href=https://github.com/xh4/cube>github.com/xh4/cube</a></td>
</tr>
<tr>
<td>Node.js (TypeScript)</td>
<td><a href=https://github.com/Goyoo/node-k8s-client>github.com/Goyoo/node-k8s-client</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href=https://github.com/ajpauwels/easy-k8s>github.com/ajpauwels/easy-k8s</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href=https://github.com/godaddy/kubernetes-client>github.com/godaddy/kubernetes-client</a></td>
</tr>
<tr>
<td>Node.js</td>
<td><a href=https://github.com/tenxcloud/node-kubernetes-client>github.com/tenxcloud/node-kubernetes-client</a></td>
</tr>
<tr>
<td>Perl</td>
<td><a href=https://metacpan.org/pod/Net::Kubernetes>metacpan.org/pod/Net::Kubernetes</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href=https://github.com/allansun/kubernetes-php-client>github.com/allansun/kubernetes-php-client</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href=https://github.com/maclof/kubernetes-client>github.com/maclof/kubernetes-client</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href=https://github.com/travisghansen/kubernetes-client-php>github.com/travisghansen/kubernetes-client-php</a></td>
</tr>
<tr>
<td>PHP</td>
<td><a href=https://github.com/renoki-co/php-k8s>github.com/renoki-co/php-k8s</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/fiaas/k8s>github.com/fiaas/k8s</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/mnubo/kubernetes-py>github.com/mnubo/kubernetes-py</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/tomplus/kubernetes_asyncio>github.com/tomplus/kubernetes_asyncio</a></td>
</tr>
<tr>
<td>Python</td>
<td><a href=https://github.com/Frankkkkk/pykorm>github.com/Frankkkkk/pykorm</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href=https://github.com/abonas/kubeclient>github.com/abonas/kubeclient</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href=https://github.com/k8s-ruby/k8s-ruby>github.com/k8s-ruby/k8s-ruby</a></td>
</tr>
<tr>
<td>Ruby</td>
<td><a href=https://github.com/kontena/k8s-client>github.com/kontena/k8s-client</a></td>
</tr>
<tr>
<td>Rust</td>
<td><a href=https://github.com/clux/kube-rs>github.com/clux/kube-rs</a></td>
</tr>
<tr>
<td>Rust</td>
<td><a href=https://github.com/ynqa/kubernetes-rust>github.com/ynqa/kubernetes-rust</a></td>
</tr>
<tr>
<td>Scala</td>
<td><a href=https://github.com/hagay3/skuber>github.com/hagay3/skuber</a></td>
</tr>
<tr>
<td>Scala</td>
<td><a href=https://github.com/joan38/kubernetes-client>github.com/joan38/kubernetes-client</a></td>
</tr>
<tr>
<td>Swift</td>
<td><a href=https://github.com/swiftkube/client>github.com/swiftkube/client</a></td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8d2ce3e7b2223cda0ccd428f4d5ea24b>2.4 - Kubernetes 弃用策略</h1>
<p>本文档详细解释系统中各个层面的弃用策略（Deprecation Policy）。</p>
<p>Kubernetes 是一个组件众多、贡献者人数众多的大系统。
就像很多类似的软件，所提供的功能特性集合会随着时间推移而自然发生变化，
而且有时候某个功能特性可能需要被去除。被去除的可能是一个 API、一个参数标志或者
甚至某整个功能特性。为了避免影响到现有用户，Kubernetes 对于其中渐次移除
的各个方面规定了一种弃用策略并遵从此策略。</p>
<h2 id=deprecating-parts-of-the-api>弃用 API 的一部分 </h2>
<p>由于 Kubernetes 是一个 API 驱动的系统，API 会随着时间推移而演化，以反映
人们对问题空间的认识的变化。Kubernetes API 实际上是一个 API 集合，其中每个
成员称作“API 组（API Group）”，并且每个 API 组都是独立管理版本的。
<a href=/zh/docs/reference/using-api/#api-versioning>API 版本</a>会有
三类，每类有不同的废弃策略：</p>
<table>
<thead>
<tr>
<th>示例</th>
<th>分类</th>
</tr>
</thead>
<tbody>
<tr>
<td>v1</td>
<td>正式发布（Generally available，GA，稳定版本）</td>
</tr>
<tr>
<td>v1beta1</td>
<td>Beta （预发布）</td>
</tr>
<tr>
<td>v1alpha1</td>
<td>Alpha （试验性）</td>
</tr>
</tbody>
</table>
<p>给定的 Kubernetes 发布版本中可以支持任意数量的 API 组，且每组可以包含
任意个数的版本。</p>
<p>下面的规则负责指导 API 元素的弃用，具体元素包括：</p>
<ul>
<li>REST 资源（也即 API 对象）</li>
<li>REST 资源的字段</li>
<li>REST 资源的注解，包含“beta”类注解但不包含“alpha”类注解</li>
<li>枚举值或者常数值</li>
<li>组件配置结构</li>
</ul>
<p>以下是跨正式发布版本时要实施的规则，不适用于对 master 或发布分支上
不同提交之间的变化。</p>
<p><strong>规则 #1：只能在增加 API 组版本号时删除 API 元素。</strong></p>
<p>一旦在某个特定 API 组版本中添加了 API 元素，则该元素不可从该版本中删除，
且其行为也不能大幅度地变化，无论属于哪一类（GA、Alpha 或 Beta）。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 由于历史原因，Kubernetes 中存在两个“单体式（Monolithic）”API 组 -
“core”（无组名）和“extensions”。这两个遗留 API 组中的资源会被逐渐迁移到
更为特定领域的 API 组中。
</div>
<p><strong>规则 #2：在给定的发布版本中，API 对象必须能够在不同的 API 版本之间来回
转换且不造成信息丢失，除非整个 REST 资源在某些版本中完全不存在。</strong></p>
<p>例如，一个对象可被用 v1 来写入之后用 v2 来读出并转换为 v1，所得到的 v1 必须
与原来的 v1 对象完全相同。v2 中的表现形式可能与 v1 不同，但系统知道如何
在两个版本之间执行双向转换。
此外，v2 中添加的所有新字段都必须能够转换为 v1 再转换回来。这意味着 v1 必须
添加一个新的等效字段或者将其表现为一个注解。</p>
<p><strong>规则 #3：给定类别的 API 版本在新的、稳定性未降低的 API 版本发布之前不可被废弃。</strong></p>
<p>一个正式发布的（GA）API 版本可替换现有的正式 API 版本或 alpha、beta API 版本。
Beta API 版本 <em>不可以</em> 替代正式的 API 版本。</p>
<p><strong>规则 #4a：除了每类 API 版本中的最新版本，旧的 API 版本在其被宣布被废弃之后
至少以下时长内仍需被支持：</strong></p>
<ul>
<li><strong>GA：12 个月或者 3 个发布版本（取其较长者）</strong></li>
<li><strong>Beta: 9 个月或者 3 个发布版本（取其较长者）</strong></li>
<li><strong>Alpha: 0 个发布版本</strong></li>
</ul>
<p>这里也包含了关于<a href=/zh/docs/setup/release/version-skew-policy/>最大支持 2 个发布版本的版本偏差</a>
的约定。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 在 <a href=https://github.com/kubernetes/kubernetes/issues/52185>#52185</a> 被解决之前，
已经被保存到持久性存储中的 API 版本都不可以被去除。
你可以禁止这些版本所对应的 REST 末端（在符合本文中弃用时间线的前提下），
但是 API 服务器必须仍能解析和转换存储中以前写入的数据。
</div>
<p><strong>规则 #4b：标记为“preferred（优选的）” API 版本和给定 API 组的
“storage version（存储版本）”在既支持老版本也支持新版本的 Kubernetes 发布
版本出来以前不可以提升其版本号。</strong></p>
<p>用户必须能够升级到 Kubernetes 新的发行版本，之后再回滚到前一个发行版本，且
整个过程中无需针对新的 API 版本做任何转换，也不允许出现功能损坏的情况，
除非用户显式地使用了仅在较新版本中才存在的功能特性。
就对象的存储表示而言，这一点尤其是不言自明的。</p>
<p>以上所有规则最好通过例子来说明。假定现有 Kubernetes 发行版本为 X，其中引入了
新的 API 组。大约每隔 4 个月会有一个新的 Kubernetes 版本被发布（每年 3 个版本）。
下面的表格描述了在一系列后续的发布版本中哪些 API 版本是受支持的。</p>
<table>
<thead>
<tr>
<th>发布版本</th>
<th>API 版本</th>
<th>优选/存储版本</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>v1alpha1</td>
<td>v1alpha1</td>
<td></td>
</tr>
<tr>
<td>X+1</td>
<td>v1alpha2</td>
<td>v1alpha2</td>
<td>
<ul>
<li>v1alpha1 被去除，发布说明中会包含 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+2</td>
<td>v1beta1</td>
<td>v1beta1</td>
<td>
<ul>
<li>v1alpha2 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+3</td>
<td>v1beta2、v1beta1（已弃用）</td>
<td>v1beta1</td>
<td>
<ul>
<li>v1beta1 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+4</td>
<td>v1beta2、v1beta1（已弃用）</td>
<td>v1beta2</td>
<td></td>
</tr>
<tr>
<td>X+5</td>
<td>v1、v1beta1（已弃用）、v1beta2（已弃用）</td>
<td>v1beta2</td>
<td>
<ul>
<li>v1beta2 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+6</td>
<td>v1、v1beta2（已弃用）</td>
<td>v1</td>
<td>
<ul>
<li>v1beta1 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+7</td>
<td>v1、v1beta2（已弃用）</td>
<td>v1</td>
<td></td>
</tr>
<tr>
<td>X+8</td>
<td>v2alpha1、v1</td>
<td>v1</td>
<td>
<ul>
<li>v1beta2 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+9</td>
<td>v2alpha2、v1</td>
<td>v1</td>
<td>
<ul>
<li>v2alpha1 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+10</td>
<td>v2beta1、v1</td>
<td>v1</td>
<td>
<ul>
<li>v2alpha2 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+11</td>
<td>v2beta2、v2beta1（已弃用）、v1</td>
<td>v1</td>
<td>
<ul>
<li>v2beta1 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+12</td>
<td>v2、v2beta2（已弃用）、v2beta1（已弃用）、v1（已弃用）</td>
<td>v1</td>
<td>
<ul>
<li>v2beta2 已被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
<li>v1 已被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+13</td>
<td>v2、v2beta1（已弃用）、v2beta2（已弃用）、v1（已弃用）</td>
<td>v2</td>
<td></td>
</tr>
<tr>
<td>X+14</td>
<td>v2、v2beta2（已弃用）、v1（已弃用）</td>
<td>v2</td>
<td>
<ul>
<li>v2beta1 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+15</td>
<td>v2、v1（已弃用）</td>
<td>v2</td>
<td>
<ul>
<li>v2beta2 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
<tr>
<td>X+16</td>
<td>v2、v1（已弃用）</td>
<td>v2</td>
<td></td>
</tr>
<tr>
<td>X+17</td>
<td>v2</td>
<td>v2</td>
<td>
<ul>
<li>v1 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li>
</ul>
</td>
</tr>
</tbody>
</table>
<h3 id=rest-resources-aka-api-objects>REST 资源（也即 API 对象） </h3>
<p>考虑一个假想的名为 Widget 的 REST 资源，在上述时间线中位于 API v1，
而现在打算将其弃用。
我们会在文档和
<a href=https://groups.google.com/forum/#!forum/kubernetes-announce>声明</a>
中与 X+1 版本的发布同步记述此弃用决定。
Wdiget 资源仍会在 API 版本 v1（已弃用）中存在，但不会出现在 v2alpha1 中。
Widget 资源会 X+8 发布版本之前（含 X+8）一直存在并可用。
只有在发布版本 X+9 中，API v1 寿终正寝时，Widget
才彻底消失，相应的资源行为也被移除。</p>
<p>从 Kubernetes v1.19 开始，当 API 请求被发送到一个已弃用的 REST API 末端时：</p>
<ol>
<li>
<p>API 响应中会包含一个 <code>Warning</code> 头部字段（如 <a href=https://tools.ietf.org/html/rfc7234#section-5.5>RFC7234 5.5 节</a>所定义）；</p>
</li>
<li>
<p>该请求会导致对应的
<a href=/zh/docs/tasks/debug-application-cluster/audit/>审计事件</a>
中会增加一个注解 <code>"k8s.io/deprecated":"true"</code>。</p>
</li>
<li>
<p><code>kube-apiserver</code> 进程的 <code>apiserver_requested_deprecated_apis</code> 度量值会被
设置为 <code>1</code>。
该度量值还附带 <code>group</code>、<code>version</code>、<code>resource</code> 和 <code>subresource</code> 标签
（可供添加到度量值 <code>apiserver_request_total</code> 上），
和一个 <code>removed_release</code> 标签，标明该 API 将消失的 Kubernetes 发布版本。
下面的 Prometheus 查询会返回对 v1.22 中将移除的、已弃用的 API
的请求的信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-promql data-lang=promql><span style=color:#b8860b>apiserver_requested_deprecated_apis</span>{<span style=color:#a0a000>removed_release</span><span style=color:#666>=</span>&#34;<span style=color:#b44>1.22</span>&#34;}<span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>on</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>group</span>,<span style=color:#b8860b>version</span>,<span style=color:#b8860b>resource</span>,<span style=color:#b8860b>subresource</span><span style=color:#666>)</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>group_right</span><span style=color:#666>()</span><span style=color:#bbb> </span><span style=color:#b8860b>apiserver_request_total</span><span style=color:#bbb>
</span></code></pre></div></li>
</ol>
<h3 id=fields-of-rest-resources>REST 资源的字段 </h3>
<p>就像整个 REST 资源一样，在 API v1 中曾经存在的各个字段在 API v1 被移除
之前必须一直存在且起作用。
与整个资源上的规定不同，v2 API 可以选择为字段提供不同的表示方式，
只要对应的资源对象可在不同版本之间来回转换即可。
例如，v1 版本中一个名为 "magnitude" 的已弃用字段可能在 API v2 中被命名
为 "deprecatedMagnitude"。当 v1 最终被移除时，废弃的字段也可以从 v2
中移除。</p>
<h3 id=enumerated-or-constant-values>枚举值或常数值</h3>
<p>就像前文讲述的 REST 资源及其中的单个字段一样，API v1 中所支持的常数值
必须在 API v1 被移除之前一直存在且起作用。</p>
<h3 id=component-config-structures>组件配置结构 </h3>
<p>组件的配置也是有版本的，并且按 REST 资源的方式来管理。</p>
<h3 id=future-work>将来的工作 </h3>
<p>随着时间推移，Kubernetes 会引入粒度更细的 API 版本。
到那时，这里的规则会根据需要进行调整。</p>
<h2 id=弃用一个标志或-cli-命令>弃用一个标志或 CLI 命令</h2>
<p>Kubernetes 系统中包含若干不同的、相互协作的程序。
有时，Kubernetes 可能会删除这些程序的某些标志或 CLI 命令（统称“命令行元素”）。
这些程序可以天然地划分到两个大组中：面向用户的和面向管理员的程序。
二者之间的弃用策略略有不同。
除非某个标志显示地通过前缀或文档来标明其为“alpha”或“beta”，
该标志要被视作正式发布的（GA）。</p>
<p>命令行元素相当于系统的 API 的一部分，不过因为它们并没有采用 REST API
一样的方式来管理版本，其弃用规则规定如下：</p>
<p><strong>规则 #5a：面向用户的命令行元素（例如，kubectl）必须在其宣布被弃用其
在以下时长内仍能使用：</strong></p>
<ul>
<li><strong>GA：12 个月或者 2 个发布版本（取其较长者）</strong></li>
<li><strong>Beta：3 个月或者 1 个发布版本（取其较长者）</strong></li>
<li><strong>Alpha：0 发布版本</strong></li>
</ul>
<p><strong>规则 #5b：面向管理员的命令行元素（例如，kubelet）必须在其被宣布弃用
之后以下时长内保持可用：</strong></p>
<ul>
<li><strong>GA：6 个月或 1 个发行版本（取其较长者）</strong></li>
<li><strong>Beta: 3 个月或 1 个发行版本（取其较长者）</strong></li>
<li><strong>Alpha: 0 个发布版本</strong></li>
</ul>
<p><strong>规则 #6：被弃用的 CLI 元素在被用到时必须能够产生警告，而警告的
产生是可以被禁止的。</strong></p>
<h2 id=deprecating-a-feature-or-behavior>弃用某功能特性或行为 </h2>
<p>在一些较偶然的情形下，某 Kubernetes 发行版本需要弃用系统的某项功能
特性或者行为，而对应的功能特性或行为并不受 API 或 CLI 控制。在这种情况下，
其弃用规则如下：</p>
<p><strong>规则 #7：被弃用的行为必须在被宣布弃用之后至少 1 年时间内必须保持能用。</strong></p>
<p>这并不意味着对系统的所有更改都受此策略约束。
此规则仅适用于重大的、用户可见的行为；这些行为会影响到在 Kubernetes
中运行的应用的正确性，或者影响到 Kubernetes 集群的管理。
此规则也适用于那些被整个移除的功能特性或行为。</p>
<p>上述规则的一个例外是 <em>特性门控（Feature Gates）</em>。特性门控是一些键值偶对，
允许用户启用或禁用一些试验性的功能特性。</p>
<p>特性门控意在覆盖功能特性的整个开发周期，它们无意成为长期的 API。
因此，它们会在某功能特性正式发布或被抛弃之后被弃用和删除。</p>
<p>随着一个功能特性经过不同的成熟阶段，相关的特性门控也会演化。
与功能特性生命周期对应的特性门控状态为：</p>
<ul>
<li>Alpha：特性门控默认被禁用，只能由用户显式启用。</li>
<li>Beta：特性门控默认被弃用，可被用户显式禁用。</li>
<li>GA: 特性门控被弃用（参见<a href=#deprecation>弃用</a>），并且不再起作用。</li>
<li>GA，弃用窗口期结束：特性门控被删除，不再接受调用。</li>
</ul>
<h3 id=deprecation>弃用 </h3>
<p>功能特性在正式发布之前的生命周期内任何时间点都可被移除。
当未正式发布的功能特性被移除时，它们对应的特性门控也被弃用。</p>
<p>当尝试禁用一个不再起作用的特性门控时，该调用会失败，这样可以避免
毫无迹象地执行一些不受支持的场景。</p>
<p>在某些场合，移除一个即将正式发布的功能特性需要很长时间。特性门控
可以保持其功能，直到对应的功能特性被彻底去除，直到那时特性门控
自身才可被弃用。</p>
<p>由于移除一个已经正式发布的功能特性对应的特性门控也需要一定时间，对特性
门控的调用可能一直被允许，前提是特性门控对功能本身无影响且特性门控不会
引发任何错误。</p>
<p>意在允许用户禁用的功能特性应该包含一个在相关联的特性门控中禁用该功能的机制。</p>
<p>特性门控的版本管理与之前讨论的组件版本管理不同，因此其对应的弃用策略如下：</p>
<p><strong>规则 #8：特性门控所对应的功能特性经历下面所列的成熟性阶段转换时，特性门控
必须被弃用。特性门控弃用时必须在以下时长内保持其功能可用：</strong></p>
<ul>
<li><strong>Beta 特性转为 GA：6 个月或者 2 个发布版本（取其较长者）</strong></li>
<li><strong>Beta 特性转为丢弃：3 个月或者 1 个发布版本（取其较长者）</strong></li>
<li><strong>Alpha 特性转为丢弃：0 个发布版本</strong></li>
</ul>
<p><strong>规则 #9：已弃用的特色门控再被使用时必须给出警告回应。当特性门控被
弃用时，必须在发布说明和对应的 CLI 帮助信息中通过文档宣布。
警告信息和文档都要标明是否某特性门控不再起作用。</strong></p>
<h3 id=deprecating-a-metric>弃用度量值 </h3>
<p>Kubernetes 控制平面的每个组件都公开度量值（通常是 <code>/metrics</code> 端点），它们通常由集群管理员使用。
并不是所有的度量值都是同样重要的：一些度量值通常用作 SLIs 或被使用来确定 SLOs，这些往往比较重要。
其他度量值在本质上带有实验性，或者主要用于 Kubernetes 开发过程。</p>
<p>因此，度量值分为两个稳定性类别（<code>ALPHA</code> 和 <code>STABLE</code>）;
此分类会影响在 Kubernetes 发布版本中移除某度量值。
所对应的分类取决于对该度量值重要性的预期。
弃用和移除度量值的规则如下：</p>
<p><strong>规则 #9a: 对于相应的稳定性类别，度量值起作用的周期必须不小于：</strong></p>
<ul>
<li><strong>STABLE: 4 个发布版本或者 12 个月 (取其较长者)</strong></li>
<li><strong>ALPHA: 0 个发布版本</strong></li>
</ul>
<p><strong>规则 #9b: 在度量值被宣布启用之后，它起作用的周期必须不小于：</strong></p>
<ul>
<li><strong>STABLE: 3 个发布版本或者 9 个月 (取其较长者)</strong></li>
<li><strong>ALPHA: 0 个发布版本</strong></li>
</ul>
<p>已弃用的度量值将在其描述文本前加上一个已弃用通知字符串 '(Deprecated from x.y)'，
并将在度量值被记录期间发出警告日志。就像稳定的、未被弃用的度量指标一样，
被弃用的度量值将自动注册到 metrics 端点，因此被弃用的度量值也是可见的。</p>
<p>在随后的版本中（当度量值 <code>deprecatedVersion</code> 等于_当前 Kubernetes 版本 - 3_），
被弃用的度量值将变成 _隐藏（Hidden）_ metric 度量值。
与被弃用的度量值不同，隐藏的度量值将不再被自动注册到 metrics 端点（因此被隐藏）。
但是，它们可以通过可执行文件的命令行标志显式启用
（<code>--show-hidden-metrics-for-version=</code>）。
如果集群管理员不能对早期的弃用警告作出反应，这一设计就为他们提供了抓紧迁移弃用度量值的途径。
隐藏的度量值应该在再过一个发行版本后被删除。</p>
<h2 id=exceptions>例外 </h2>
<p>没有策略可以覆盖所有情况。此策略文档是一个随时被更新的文档，会随着时间
推移演化。在实践中，会有一些情况无法很好地匹配到这里的弃用策略，或者
这里的策略变成了很严重的羁绊。这类情形要与 SIG 和项目牵头人讨论，
寻求对应场景的最佳解决方案。请一直铭记，Kubernetes 承诺要成为一个
稳定的系统，至少会尽力做到不会影响到其用户。此弃用策略的任何例外情况
都会在所有相关的发布说明中公布。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e4dbb59f8f23854d7b7d574e169923c4>2.5 - Kubernetes API 健康端点</h1>
<p>Kubernetes <a class=glossary-tooltip title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank aria-label="API 服务器">API 服务器</a> 提供 API 端点以指示 API 服务器的当前状态。
本文描述了这些 API 端点，并说明如何使用。</p>
<h2 id=api-endpoints-for-health>API 健康端点 </h2>
<p>Kubernetes API 服务器提供 3 个 API 端点（<code>healthz</code>、<code>livez</code> 和 <code>readyz</code>）来表明 API 服务器的当前状态。
<code>healthz</code> 端点已被弃用（自 Kubernetes v1.16 起），你应该使用更为明确的 <code>livez</code> 和 <code>readyz</code> 端点。
<code>livez</code> 端点可与 <code>--livez-grace-period</code> <a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver>标志</a>一起使用，来指定启动持续时间。
为了正常关机，你可以使用 <code>/readyz</code> 端点并指定 <code>--shutdown-delay-duration</code> <a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver>标志</a>。
检查 API 服务器的 <code>healthz</code>/<code>livez</code>/<code>readyz</code> 端点的机器应依赖于 HTTP 状态代码。
状态码 <code>200</code> 表示 API 服务器是 <code>healthy</code>、<code>live</code> 还是 <code>ready</code>，具体取决于所调用的端点。
以下更详细的选项供操作人员使用，用来调试其集群或了解 API 服务器的状态。</p>
<p>以下示例将显示如何与运行状况 API 端点进行交互。</p>
<p>对于所有端点，都可以使用 <code>verbose</code> 参数来打印检查项以及检查状态。
这对于操作人员调试 API 服务器的当前状态很有用，这些不打算给机器使用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -k https://localhost:6443/livez?verbose
</code></pre></div>
<p>或从具有身份验证的远程主机：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get --raw<span style=color:#666>=</span><span style=color:#b44>&#39;/readyz?verbose&#39;</span>
</code></pre></div>
<p>输出将如下所示：</p>
<pre><code>[+]ping ok
[+]log ok
[+]etcd ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
healthz check passed
</code></pre>
<p>Kubernetes API 服务器也支持排除特定的检查项。
查询参数也可以像以下示例一样进行组合：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -k <span style=color:#b44>&#39;https://localhost:6443/readyz?verbose&amp;exclude=etcd&#39;</span>
</code></pre></div>
<p>输出显示排除了 <code>etcd</code> 检查：</p>
<pre><code>[+]ping ok
[+]log ok
[+]etcd excluded: ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
[+]shutdown ok
healthz check passed
</code></pre>
<h2 id=individual-health-check>独立健康检查 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code>
</div>
<p>每个单独的健康检查都会公开一个 HTTP 端点，并且可以单独检查。
单个运行状况检查的模式为 <code>/livez/&lt;healthcheck-name></code>，其中 <code>livez</code> 和 <code>readyz</code> 表明你要检查的是 API 服务器是否存活或就绪。
<code>&lt;healthcheck-name></code> 的路径可以通过上面的 <code>verbose</code> 参数发现 ，并采用 <code>[+]</code> 和 <code>ok</code> 之间的路径。
这些单独的健康检查不应由机器使用，但对于操作人员调试系统而言，是有帮助的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -k https://localhost:6443/livez/etcd
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-99b26586d8a33ec06996dcf7892a9683>3 - 访问 API</h1>
<p>关于 Kubernetes 如何实现和控制 API 访问的介绍性材料，可阅读
<a href=/zh/docs/concepts/security/controlling-access/>控制 Kubernetes API 的访问</a>。</p>
<p>参考文档：</p>
<ul>
<li><a href=/zh/docs/reference/access-authn-authz/authentication/>身份认证</a>
<ul>
<li><a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>使用启动引导令牌来执行身份认证</a></li>
</ul>
</li>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/>准入控制器</a>
<ul>
<li><a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/>动态准入控制</a></li>
</ul>
</li>
<li><a href=/zh/docs/reference/access-authn-authz/authorization/>鉴权与授权</a>
<ul>
<li><a href=/zh/docs/reference/access-authn-authz/rbac/>基于角色的访问控制</a></li>
<li><a href=/zh/docs/reference/access-authn-authz/abac/>基于属性的访问控制</a></li>
<li><a href=/zh/docs/reference/access-authn-authz/node/>节点鉴权</a></li>
<li><a href=/zh/docs/reference/access-authn-authz/webhook/>Webhook 鉴权</a></li>
</ul>
</li>
<li><a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a>
<ul>
<li>包含 <a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection>CSR 的批复</a>
和<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/#signing>证书签名</a></li>
</ul>
</li>
<li>服务账号
<ul>
<li><a href=/zh/docs/tasks/configure-pod-container/configure-service-account/>开发者指南</a></li>
<li><a href=/zh/docs/reference/access-authn-authz/service-accounts-admin/>管理文档</a></li>
</ul>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b>3.1 - 用户认证</h1>
<p>本页提供身份认证有关的概述。</p>
<h2 id=users-in-kubernetes>Kubernetes 中的用户 </h2>
<p>所有 Kubernetes 集群都有两类用户：由 Kubernetes 管理的服务账号和普通用户。</p>
<p>Kubernetes 假定普通用户是由一个与集群无关的服务通过以下方式之一进行管理的：</p>
<ul>
<li>负责分发私钥的管理员</li>
<li>类似 Keystone 或者 Google Accounts 这类用户数据库</li>
<li>包含用户名和密码列表的文件</li>
</ul>
<p>有鉴于此，<em>Kubernetes 并不包含用来代表普通用户账号的对象</em>。
普通用户的信息无法通过 API 调用添加到集群中。</p>
<p>尽管无法通过 API 调用来添加普通用户，Kubernetes 仍然认为能够提供由集群的证书
机构签名的合法证书的用户是通过身份认证的用户。基于这样的配置，Kubernetes
使用证书中的 'subject' 的通用名称（Common Name）字段（例如，"/CN=bob"）来
确定用户名。接下来，基于角色访问控制（RBAC）子系统会确定用户是否有权针对
某资源执行特定的操作。进一步的细节可参阅
<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user>证书请求</a>
下普通用户主题。</p>
<p>与此不同，服务账号是 Kubernetes API 所管理的用户。它们被绑定到特定的名字空间，
或者由 API 服务器自动创建，或者通过 API 调用创建。服务账号与一组以 Secret 保存
的凭据相关，这些凭据会被挂载到 Pod 中，从而允许集群内的进程访问 Kubernetes
API。</p>
<p>API 请求则或者与某普通用户相关联，或者与某服务账号相关联，亦或者被视作
<a href=#anonymous-requests>匿名请求</a>。这意味着集群内外的每个进程在向 API 服务器发起
请求时都必须通过身份认证，否则会被视作匿名用户。这里的进程可以是在某工作站上
输入 <code>kubectl</code> 命令的操作人员，也可以是节点上的 <code>kubelet</code> 组件，还可以是控制面
的成员。</p>
<h2 id=authentication-strategies>身份认证策略 </h2>
<p>Kubernetes 使用身份认证插件利用客户端证书、持有者令牌（Bearer Token）、身份认证代理（Proxy）
或者 HTTP 基本认证机制来认证 API 请求的身份。HTTP 请求发给 API 服务器时，
插件会将以下属性关联到请求本身：</p>
<ul>
<li>用户名：用来辩识最终用户的字符串。常见的值可以是 <code>kube-admin</code> 或 <code>jane@example.com</code>。</li>
<li>用户 ID：用来辩识最终用户的字符串，旨在比用户名有更好的一致性和唯一性。</li>
<li>用户组：取值为一组字符串，其中各个字符串用来标明用户是某个命名的用户逻辑集合的成员。
常见的值可能是 <code>system:masters</code> 或者 <code>devops-team</code> 等。</li>
<li>附加字段：一组额外的键-值映射，键是字符串，值是一组字符串；用来保存一些鉴权组件可能
觉得有用的额外信息。</li>
</ul>
<p>所有（属性）值对于身份认证系统而言都是不透明的，只有被
<a href=/zh/docs/reference/access-authn-authz/authorization/>鉴权组件</a>
解释过之后才有意义。</p>
<p>你可以同时启用多种身份认证方法，并且你通常会至少使用两种方法：</p>
<ul>
<li>针对服务账号使用服务账号令牌</li>
<li>至少另外一种方法对用户的身份进行认证</li>
</ul>
<p>当集群中启用了多个身份认证模块时，第一个成功地对请求完成身份认证的模块会
直接做出评估决定。API 服务器并不保证身份认证模块的运行顺序。</p>
<p>对于所有通过身份认证的用户，<code>system:authenticated</code> 组都会被添加到其组列表中。</p>
<p>与其它身份认证协议（LDAP、SAML、Kerberos、X509 的替代模式等等）都可以通过
使用一个<a href=#authenticating-proxy>身份认证代理</a>或
<a href=#webhook-token-authentication>身份认证 Webhoook</a>来实现。</p>
<h3 id=x509-client-certs>X509 客户证书 </h3>
<p>通过给 API 服务器传递 <code>--client-ca-file=SOMEFILE</code> 选项，就可以启动客户端证书身份认证。
所引用的文件必须包含一个或者多个证书机构，用来验证向 API 服务器提供的客户端证书。
如果提供了客户端证书并且证书被验证通过，则 subject 中的公共名称（Common Name）就被
作为请求的用户名。
自 Kubernetes 1.4 开始，客户端证书还可以通过证书的 organization 字段标明用户的组成员信息。
要包含用户的多个组成员信息，可以在证书种包含多个 organization 字段。</p>
<p>例如，使用 <code>openssl</code> 命令行工具生成一个证书签名请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>openssl req -new -key jbeda.pem -out jbeda-csr.pem -subj <span style=color:#b44>&#34;/CN=jbeda/O=app1/O=app2&#34;</span>
</code></pre></div>
<p>此命令将使用用户名 <code>jbeda</code> 生成一个证书签名请求（CSR），且该用户属于 "app" 和
"app2" 两个用户组。</p>
<p>参阅<a href=/zh/docs/concepts/cluster-administration/certificates/>管理证书</a>了解如何生成客户端证书。</p>
<h3 id=static-token-file>静态令牌文件 </h3>
<p>当 API 服务器的命令行设置了 <code>--token-auth-file=SOMEFILE</code> 选项时，会从文件中
读取持有者令牌。目前，令牌会长期有效，并且在不重启 API 服务器的情况下
无法更改令牌列表。</p>
<p>令牌文件是一个 CSV 文件，包含至少 3 个列：令牌、用户名和用户的 UID。
其余列被视为可选的组名。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> <p>如果要设置的组名不止一个，则对应的列必须用双引号括起来，例如</p>
<pre><code class=language-conf data-lang=conf>token,user,uid,&quot;group1,group2,group3&quot;
</code></pre>
</div>
<h4 id=putting-a-bearer-token-in-a-request>在请求中放入持有者令牌 </h4>
<p>当使用持有者令牌来对某 HTTP 客户端执行身份认证时，API 服务器希望看到
一个名为 <code>Authorization</code> 的 HTTP 头，其值格式为 <code>Bearer THETOKEN</code>。
持有者令牌必须是一个可以放入 HTTP 头部值字段的字符序列，至多可使用
HTTP 的编码和引用机制。
例如：如果持有者令牌为 <code>31ada4fd-adec-460c-809a-9e56ceb75269</code>，则其
出现在 HTTP 头部时如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269
</span></code></pre></div>
<h3 id=bootstrap-tokens>启动引导令牌 </h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>为了支持平滑地启动引导新的集群，Kubernetes 包含了一种动态管理的持有者令牌类型，
称作 <em>启动引导令牌（Bootstrap Token）</em>。
这些令牌以 Secret 的形式保存在 <code>kube-system</code> 名字空间中，可以被动态管理和创建。
控制器管理器包含的 <code>TokenCleaner</code> 控制器能够在启动引导令牌过期时将其删除。</p>
<p>这些令牌的格式为 <code>[a-z0-9]{6}.[a-z0-9]{16}</code>。第一个部分是令牌的 ID；第二个部分
是令牌的 Secret。你可以用如下所示的方式来在 HTTP 头部设置令牌：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Authorization: Bearer 781292.db7bc3a58fc5f07e
</span></code></pre></div>
<p>你必须在 API 服务器上设置 <code>--enable-bootstrap-token-auth</code> 标志来启用基于启动
引导令牌的身份认证组件。
你必须通过控制器管理器的 <code>--controllers</code> 标志来启用 TokenCleaner 控制器；
这可以通过类似 <code>--controllers=*,tokencleaner</code> 这种设置来做到。
如果你使用 <code>kubeadm</code> 来启动引导新的集群，该工具会帮你完成这些设置。</p>
<p>身份认证组件的认证结果为 <code>system:bootstrap:&lt;令牌 ID></code>，该用户属于
<code>system:bootstrappers</code> 用户组。
这里的用户名和组设置都是有意设计成这样，其目的是阻止用户在启动引导集群之后
继续使用这些令牌。
这里的用户名和组名可以用来（并且已经被 <code>kubeadm</code> 用来）构造合适的鉴权
策略，以完成启动引导新集群的工作。</p>
<p>请参阅<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>启动引导令牌</a>
以了解关于启动引导令牌身份认证组件与控制器的更深入的信息，以及如何使用
<code>kubeadm</code> 来管理这些令牌。</p>
<h3 id=service-account-tokens>服务账号令牌 </h3>
<p>服务账号（Service Account）是一种自动被启用的用户认证机制，使用经过签名的
持有者令牌来验证请求。该插件可接受两个可选参数：</p>
<ul>
<li><code>--service-account-key-file</code> 一个包含用来为持有者令牌签名的 PEM 编码密钥。
若未指定，则使用 API 服务器的 TLS 私钥。</li>
<li><code>--service-account-lookup</code> 如果启用，则从 API 删除的令牌会被回收。</li>
</ul>
<p>服务账号通常由 API 服务器自动创建并通过 <code>ServiceAccount</code>
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/>准入控制器</a>
关联到集群中运行的 Pod 上。
持有者令牌会挂载到 Pod 中可预知的位置，允许集群内进程与 API 服务器通信。
服务账号也可以使用 Pod 规约的 <code>serviceAccountName</code> 字段显式地关联到 Pod 上。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> <code>serviceAccountName</code> 通常会被忽略，因为关联关系是自动建立的。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>bob-the-bot<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></code></pre></div>
<p>在集群外部使用服务账号持有者令牌也是完全合法的，且可用来为长时间运行的、需要与
Kubernetes API 服务器通信的任务创建标识。要手动创建服务账号，可以使用
<code>kubectl create serviceaccount &lt;名称></code> 命令。此命令会在当前的名字空间中生成一个
服务账号和一个与之关联的 Secret。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl create serviceaccount jenkins
</code></pre></div><pre><code>serviceaccount/jenkins created
</code></pre>
<p>查验相关联的 Secret：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get serviceaccounts jenkins -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>secrets</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jenkins-token-1yvwg<span style=color:#bbb>
</span></code></pre></div>
<p>所创建的 Secret 中会保存 API 服务器的公开的 CA 证书和一个已签名的 JSON Web
令牌（JWT）。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get secret jenkins-token-1yvwg -o yaml
</code></pre></div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ca.crt</span>:<span style=color:#bbb> </span>&lt;Base64 编码的 API 服务器 CA&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>ZGVmYXVsdA==<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token</span>:<span style=color:#bbb> </span>&lt;Base64 编码的持有者令牌&gt;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 字段值是按 Base64 编码的，这是因为 Secret 数据总是采用 Base64 编码来存储。
</div>
<p>已签名的 JWT 可以用作持有者令牌，并将被认证为所给的服务账号。
关于如何在请求中包含令牌，请参阅<a href=#putting-a-bearer-token-in-a-request>前文</a>。
通常，这些 Secret 数据会被挂载到 Pod 中以便集群内访问 API 服务器时使用，
不过也可以在集群外部使用。</p>
<p>服务账号被身份认证后，所确定的用户名为 <code>system:serviceaccount:&lt;名字空间>:&lt;服务账号></code>，
并被分配到用户组 <code>system:serviceaccounts</code> 和 <code>system:serviceaccounts:&lt;名字空间></code>。</p>
<p>警告：由于服务账号令牌保存在 Secret 对象中，任何能够读取这些 Secret 的用户
都可以被认证为对应的服务账号。在为用户授予访问服务账号的权限时，以及对 Secret
的读权限时，要格外小心。</p>
<h3 id=openid-connect-tokens>OpenID Connect（OIDC）令牌 </h3>
<p><a href=https://openid.net/connect/>OpenID Connect</a> 是一种 OAuth2 认证方式，
被某些 OAuth2 提供者支持，例如 Azure 活动目录、Salesforce 和 Google。
协议对 OAuth2 的主要扩充体现在有一个附加字段会和访问令牌一起返回，
这一字段称作 <a href=https://openid.net/specs/openid-connect-core-1_0.html#IDToken>ID Token（ID 令牌）</a>。
ID 令牌是一种由服务器签名的 JSON Web 令牌（JWT），其中包含一些可预知的字段，
例如用户的邮箱地址，</p>
<p>要识别用户，身份认证组件使用 OAuth2
<a href=https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse>令牌响应</a>
中的 <code>id_token</code>（而非 <code>access_token</code>）作为持有者令牌。
关于如何在请求中设置令牌，可参见<a href=#putting-a-bearer-token-in-a-request>前文</a>。</p>
<div class=mermaid>
sequenceDiagram
participant user as 用户
participant idp as 身份提供者
participant kube as Kubectl
participant api as API 服务器
user ->> idp: 1. 登录到 IdP
activate idp
idp -->> user: 2. 提供 access_token,<br>id_token, 和 refresh_token
deactivate idp
activate user
user ->> kube: 3. 调用 Kubectl 并<br>设置 --token 为 id_token<br>或者将令牌添加到 .kube/config
deactivate user
activate kube
kube ->> api: 4. Authorization: Bearer...
deactivate kube
activate api
api ->> api: 5. JWT 签名合法么？
api ->> api: 6. JWT 是否已过期？(iat+exp)
api ->> api: 7. 用户被授权了么？
api -->> kube: 8. 已授权：执行<br>操作并返回结果
deactivate api
activate kube
kube --x user: 9. 返回结果
deactivate kube
</div>
<noscript>
<style type=text/css>.mermaid{display:none}</style>
<h4>[JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view content]</h4>
</noscript>
<ol>
<li>登录到你的身份服务（Identity Provider）</li>
<li>你的身份服务将为你提供 <code>access_token</code>、<code>id_token</code> 和 <code>refresh_token</code></li>
<li>在使用 <code>kubectl</code> 时，将 <code>id_token</code> 设置为 <code>--token</code> 标志值，或者将其直接添加到
<code>kubeconfig</code> 中</li>
<li><code>kubectl</code> 将你的 <code>id_token</code> 放到一个称作 <code>Authorization</code> 的头部，发送给 API 服务器</li>
<li>API 服务器将负责通过检查配置中引用的证书来确认 JWT 的签名是合法的</li>
<li>检查确认 <code>id_token</code> 尚未过期</li>
<li>确认用户有权限执行操作</li>
<li>鉴权成功之后，API 服务器向 <code>kubectl</code> 返回响应</li>
<li><code>kubectl</code> 向用户提供反馈信息</li>
</ol>
<p>由于用来验证你是谁的所有数据都在 <code>id_token</code> 中，Kubernetes 不需要再去联系
身份服务。在一个所有请求都是无状态请求的模型中，这一工作方式可以使得身份认证
的解决方案更容易处理大规模请求。不过，此访问也有一些挑战：</p>
<ol>
<li>Kubernetes 没有提供用来触发身份认证过程的 "Web 界面"。
因为不存在用来收集用户凭据的浏览器或用户接口，你必须自己先行完成
对身份服务的认证过程。</li>
<li><code>id_token</code> 令牌不可收回。因其属性类似于证书，其生命期一般很短（只有几分钟），
所以，每隔几分钟就要获得一个新的令牌这件事可能很让人头疼。</li>
<li>如果不使用 <code>kubectl proxy</code> 命令或者一个能够注入 <code>id_token</code> 的反向代理，
向 Kubernetes 控制面板执行身份认证是很困难的。</li>
</ol>
<h4 id=configuring-the-api-server>配置 API 服务器 </h4>
<p>要启用此插件，须在 API 服务器上配置以下标志：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>示例</th>
<th>必需？</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--oidc-issuer-url</code></td>
<td>允许 API 服务器发现公开的签名密钥的服务的 URL。只接受模式为 <code>https://</code> 的 URL。此值通常设置为服务的发现 URL，不含路径。例如："https://accounts.google.com" 或 "https://login.salesforce.com"。此 URL 应指向 .well-known/openid-configuration 下一层的路径。</td>
<td>如果发现 URL 是 <code>https://accounts.google.com/.well-known/openid-configuration</code>，则此值应为 <code>https://accounts.google.com</code></td>
<td>是</td>
</tr>
<tr>
<td><code>--oidc-client-id</code></td>
<td>所有令牌都应发放给此客户 ID。</td>
<td>kubernetes</td>
<td>是</td>
</tr>
<tr>
<td><code>--oidc-username-claim</code></td>
<td>用作用户名的 JWT 申领（JWT Claim）。默认情况下使用 <code>sub</code> 值，即最终用户的一个唯一的标识符。管理员也可以选择其他申领，例如 <code>email</code> 或者 <code>name</code>，取决于所用的身份服务。不过，除了 <code>email</code> 之外的申领都会被添加令牌发放者的 URL 作为前缀，以免与其他插件产生命名冲突。</td>
<td>sub</td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-username-prefix</code></td>
<td>要添加到用户名申领之前的前缀，用来避免与现有用户名发生冲突（例如：<code>system:</code> 用户）。例如，此标志值为 <code>oidc:</code> 时将创建形如 <code>oidc:jane.doe</code> 的用户名。如果此标志未设置，且 <code>--oidc-username-claim</code> 标志值不是 <code>email</code>，则默认前缀为 <code>&lt;令牌发放者的 URL>#</code>，其中 <code>&lt;令牌发放者 URL ></code> 的值取自 <code>--oidc-issuer-url</code> 标志的设定。此标志值为 <code>-</code> 时，意味着禁止添加用户名前缀。</td>
<td><code>oidc:</code></td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-groups-claim</code></td>
<td>用作用户组名的 JWT 申领。如果所指定的申领确实存在，则其值必须是一个字符串数组。</td>
<td>groups</td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-groups-prefix</code></td>
<td>添加到组申领的前缀，用来避免与现有用户组名（如：<code>system:</code> 组）发生冲突。例如，此标志值为 <code>oidc:</code> 时，所得到的用户组名形如 <code>oidc:engineering</code> 和 <code>oidc:infra</code>。</td>
<td><code>oidc:</code></td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-required-claim</code></td>
<td>取值为一个 key=value 偶对，意为 ID 令牌中必须存在的申领。如果设置了此标志，则 ID 令牌会被检查以确定是否包含取值匹配的申领。此标志可多次重复，以指定多个申领。</td>
<td><code>claim=value</code></td>
<td>否</td>
</tr>
<tr>
<td><code>--oidc-ca-file</code></td>
<td>指向一个 CA 证书的路径，该 CA 负责对你的身份服务的 Web 证书提供签名。默认值为宿主系统的根 CA。</td>
<td><code>/etc/kubernetes/ssl/kc-ca.pem</code></td>
<td>否</td>
</tr>
</tbody>
</table>
<p>很重要的一点是，API 服务器并非一个 OAuth2 客户端，相反，它只能被配置为
信任某一个令牌发放者。这使得使用公共服务（如 Google）的用户可以不信任发放给
第三方的凭据。
如果管理员希望使用多个 OAuth 客户端，他们应该研究一下那些支持 <code>azp</code>
（Authorized Party，被授权方）申领的服务。
<code>azp</code> 是一种允许某客户端代替另一客户端发放令牌的机制。</p>
<p>Kubernetes 并未提供 OpenID Connect 的身份服务。
你可以使用现有的公共的 OpenID Connect 身份服务（例如 Google 或者
<a href=https://connect2id.com/products/nimbus-oauth-openid-connect-sdk/openid-connect-providers>其他服务</a>）。
或者，你也可以选择自己运行一个身份服务，例如
CoreOS <a href=https://github.com/coreos/dex>dex</a>、
<a href=https://github.com/keycloak/keycloak>Keycloak</a>、
CloudFoundry <a href=https://github.com/cloudfoundry/uaa>UAA</a> 或者
Tremolo Security 的
<a href=https://github.com/tremolosecurity/openunison>OpenUnison</a>。</p>
<p>要在 Kubernetes 环境中使用某身份服务，该服务必须：</p>
<ol>
<li>支持 <a href=https://openid.net/specs/openid-connect-discovery-1_0.html>OpenID connect 发现</a>；
但事实上并非所有服务都具备此能力</li>
<li>运行 TLS 协议且所使用的加密组件都未过时</li>
<li>拥有由 CA 签名的证书（即使 CA 不是商业 CA 或者是自签名的 CA 也可以）</li>
</ol>
<p>关于上述第三条需求，即要求具备 CA 签名的证书，有一些额外的注意事项。
如果你部署了自己的身份服务，而不是使用云厂商（如 Google 或 Microsoft）所提供的服务，
你必须对身份服务的 Web 服务器证书进行签名，签名所用证书的 <code>CA</code> 标志要设置为
<code>TRUE</code>，即使用的是自签名证书。这是因为 GoLang 的 TLS 客户端实现对证书验证
标准方面有非常严格的要求。如果你手头没有现成的 CA 证书，可以使用 CoreOS
团队所开发的<a href=https://github.com/dexidp/dex/blob/master/examples/k8s/gencert.sh>这个脚本</a>
来创建一个简单的 CA 和被签了名的证书与密钥对。
或者你也可以使用
<a href=https://raw.githubusercontent.com/TremoloSecurity/openunison-qs-kubernetes/master/src/main/bash/makessl.sh>这个类似的脚本</a>，
生成一个合法期更长、密钥尺寸更大的 SHA256 证书。</p>
<p>特定系统的安装指令：</p>
<ul>
<li><a href=https://docs.cloudfoundry.org/concepts/architecture/uaa.html>UAA</a></li>
<li><a href=https://dexidp.io/docs/kubernetes/>Dex</a></li>
<li><a href=https://www.tremolosecurity.com/orchestra-k8s/>OpenUnison</a></li>
</ul>
<h4 id=using-kubectl>使用 kubectl </h4>
<h5 id=选项一-oidc-身份认证组件>选项一 - OIDC 身份认证组件</h5>
<p>第一种方案是使用 kubectl 的 <code>oidc</code> 身份认证组件，该组件将 <code>id_token</code> 设置
为所有请求的持有者令牌，并且在令牌过期时自动刷新。在你登录到你的身份服务之后，
可以使用 kubectl 来添加你的 <code>id_token</code>、<code>refresh_token</code>、<code>client_id</code> 和
<code>client_secret</code>，以配置该插件。</p>
<p>如果服务在其刷新令牌响应中不包含 <code>id_token</code>，则此插件无法支持该服务。
这时你应该考虑下面的选项二。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config set-credentials USER_NAME <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider<span style=color:#666>=</span>oidc <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>idp-issuer-url<span style=color:#666>=(</span> issuer url <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>client-id<span style=color:#666>=(</span> your client id <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>client-secret<span style=color:#666>=(</span> your client secret <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>refresh-token<span style=color:#666>=(</span> your refresh token <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>idp-certificate-authority<span style=color:#666>=(</span> path to your ca certificate <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>id-token<span style=color:#666>=(</span> your id_token <span style=color:#666>)</span>
</code></pre></div>
<p>作为示例，在完成对你的身份服务的身份认证之后，运行下面的命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config set-credentials mmosley  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider<span style=color:#666>=</span>oidc  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>idp-issuer-url<span style=color:#666>=</span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>client-id<span style=color:#666>=</span>kubernetes  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>client-secret<span style=color:#666>=</span>1db158f6-177d-4d9c-8a8b-d36869918ec5  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>refresh-token<span style=color:#666>=</span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXqHega4GAXlF+ma+vmYpFcHe5eZR+slBFpZKtQA<span style=color:#666>=</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>idp-certificate-authority<span style=color:#666>=</span>/root/ca.pem <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>id-token<span style=color:#666>=</span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw
</code></pre></div>
<p>此操作会生成以下配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mmosley<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>auth-provider</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>config</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>client-id</span>:<span style=color:#bbb> </span>kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>client-secret</span>:<span style=color:#bbb> </span>1db158f6-177d-4d9c-8a8b-d36869918ec5<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>id-token</span>:<span style=color:#bbb> </span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>idp-certificate-authority</span>:<span style=color:#bbb> </span>/root/ca.pem<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>idp-issuer-url</span>:<span style=color:#bbb> </span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>refresh-token</span>:<span style=color:#bbb> </span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXq<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>oidc<span style=color:#bbb>
</span></code></pre></div>
<p>当你的 <code>id_token</code> 过期时，<code>kubectl</code> 会尝试使用你的 <code>refresh_token</code> 来刷新你的
<code>id_token</code>，并且在 <code>client_secret</code> 中存放 <code>refresh_token</code> 的新值，同时把
<code>id_token</code> 的新值写入到 <code>.kube/config</code> 文件中。</p>
<h5 id=选项二-使用-token-选项>选项二 - 使用 <code>--token</code> 选项</h5>
<p><code>kubectl</code> 命令允许你使用 <code>--token</code> 选项传递一个令牌。
你可以将 <code>id_token</code> 的内容复制粘贴过来，作为此标志的取值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl --token<span style=color:#666>=</span>eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJodHRwczovL21sYi50cmVtb2xvLmxhbjo4MDQzL2F1dGgvaWRwL29pZGMiLCJhdWQiOiJrdWJlcm5ldGVzIiwiZXhwIjoxNDc0NTk2NjY5LCJqdGkiOiI2RDUzNXoxUEpFNjJOR3QxaWVyYm9RIiwiaWF0IjoxNDc0NTk2MzY5LCJuYmYiOjE0NzQ1OTYyNDksInN1YiI6Im13aW5kdSIsInVzZXJfcm9sZSI6WyJ1c2VycyIsIm5ldy1uYW1lc3BhY2Utdmlld2VyIl0sImVtYWlsIjoibXdpbmR1QG5vbW9yZWplZGkuY29tIn0.f2As579n9VNoaKzoF-dOQGmXkFKf1FMyNV0-va_B63jn-_n9LGSCca_6IVMP8pO-Zb4KvRqGyTP0r3HkHxYy5c81AnIh8ijarruczl-TK_yF5akjSTHFZD-0gRzlevBDiH8Q79NAr-ky0P4iIXS8lY9Vnjch5MF74Zx0c3alKJHJUnnpjIACByfF2SCaYzbWFMUNat-K1PaUk5-ujMBG7yYnr95xD-63n8CO8teGUAAEMx6zRjzfhnhbzX-ajwZLGwGUBT4WqjMs70-6a7_8gZmLZb2az1cZynkFRj2BaCkVT3A2RrjeEwZEtGXlMqKJ1_I2ulrOVsYx01_yD35-rw get nodes
</code></pre></div>
<h3 id=webhook-token-authentication>Webhook 令牌身份认证 </h3>
<p>Webhook 身份认证是一种用来验证持有者令牌的回调机制。</p>
<ul>
<li><code>--authentication-token-webhook-config-file</code> 指向一个配置文件，其中描述
如何访问远程的 Webhook 服务。</li>
<li><code>--authentication-token-webhook-cache-ttl</code> 用来设定身份认证决定的缓存时间。
默认时长为 2 分钟。</li>
</ul>
<p>配置文件使用 <a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>
文件的格式。文件中，<code>clusters</code> 指代远程服务，<code>users</code> 指代远程 API 服务
Webhook。下面是一个例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># Kubernetes API 版本</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># API 对象类别</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># clusters 指代远程服务</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-remote-authn-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/path/to/ca.pem        <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 用来验证远程服务的 CA</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://authn.example.com/authenticate<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 要查询的远程服务 URL。必须使用 &#39;https&#39;。</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># users 指代 API 服务的 Webhook 配置</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/path/to/cert.pem<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Webhook 插件要使用的证书</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/path/to/key.pem         <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 与证书匹配的密钥</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kubeconfig 文件需要一个上下文（Context），此上下文用于本 API 服务器</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>name-of-remote-authn-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>name-of-api-sever<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span></code></pre></div>
<p>当客户端尝试在 API 服务器上使用持有者令牌完成身份认证（
如<a href=#putting-a-bearer-token-in-a-request>前</a>所述）时，
身份认证 Webhook 会用 POST 请求发送一个 JSON 序列化的对象到远程服务。
该对象是 <code>authentication.k8s.io/v1beta1</code> 组的 <code>TokenReview</code> 对象，
其中包含持有者令牌。
Kubernetes 不会强制请求提供此 HTTP 头部。</p>
<p>要注意的是，Webhook API 对象和其他 Kubernetes API 对象一样，也要受到同一
<a href=/zh/docs/concepts/overview/kubernetes-api/>版本兼容规则</a>约束。
实现者要了解对 Beta 阶段对象的兼容性承诺，并检查请求的 <code>apiVersion</code> 字段，
以确保数据结构能够正常反序列化解析。此外，API 服务器必须启用
<code>authentication.k8s.io/v1beta1</code> API 扩展组
（<code>--runtime-config=authentication.k8s.io/v1beta1=true</code>）。</p>
<p>POST 请求的 Body 部分将是如下格式：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;TokenReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;&lt;持有者令牌&gt;&#34;</span>
  }
}
</code></pre></div>
<p>远程服务应该会填充请求的 <code>status</code> 字段，以标明登录操作是否成功。
响应的 Body 中的 <code>spec</code> 字段会被忽略，因此可以省略。
如果持有者令牌验证成功，应该返回如下所示的响应：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;TokenReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;authenticated&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
    <span style=color:green;font-weight:700>&#34;user&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;janedoe@example.com&#34;</span>,
      <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;42&#34;</span>,
      <span style=color:green;font-weight:700>&#34;groups&#34;</span>: [
        <span style=color:#b44>&#34;developers&#34;</span>,
        <span style=color:#b44>&#34;qa&#34;</span>
      ],
      <span style=color:green;font-weight:700>&#34;extra&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;extrafield1&#34;</span>: [
          <span style=color:#b44>&#34;extravalue1&#34;</span>,
          <span style=color:#b44>&#34;extravalue2&#34;</span>
        ]
      }
    }
  }
}
</code></pre></div>
<p>而不成功的请求会返回：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;TokenReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;authenticated&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>
  }
}
</code></pre></div>
<p>HTTP 状态码可用来提供进一步的错误语境信息。</p>
<h3 id=authenticating-proxy>身份认证代理 </h3>
<p>API 服务器可以配置成从请求的头部字段值（如 <code>X-Remote-User</code>）中辩识用户。
这一设计是用来与某身份认证代理一起使用 API 服务器，代理负责设置请求的头部字段值。</p>
<ul>
<li><code>--requestheader-username-headers</code> 必需字段，大小写不敏感。用来设置要获得用户身份所要检查的头部字段名称列表（有序）。第一个包含数值的字段会被用来提取用户名。</li>
<li><code>--requestheader-group-headers</code> 可选字段，在 Kubernetes 1.6 版本以后支持，大小写不敏感。
建议设置为 "X-Remote-Group"。用来指定一组头部字段名称列表，以供检查用户所属的组名称。
所找到的全部头部字段的取值都会被用作用户组名。</li>
<li><code>--requestheader-extra-headers-prefix</code> 可选字段，在 Kubernetes 1.6 版本以后支持，大小写不敏感。
建议设置为 "X-Remote-Extra-"。用来设置一个头部字段的前缀字符串，API 服务器会基于所给
前缀来查找与用户有关的一些额外信息。这些额外信息通常用于所配置的鉴权插件。
API 服务器会将与所给前缀匹配的头部字段过滤出来，去掉其前缀部分，将剩余部分
转换为小写字符串并在必要时执行<a href=https://tools.ietf.org/html/rfc3986#section-2.1>百分号解码</a>
后，构造新的附加信息字段键名。原来的头部字段值直接作为附加信息字段的值。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 在 1.13.3 版本之前（包括 1.10.7、1.9.11），附加字段的键名只能包含
<a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>HTTP 头部标签的合法字符</a>。
</div>
<p>例如，使用下面的配置：</p>
<pre><code>--requestheader-username-headers=X-Remote-User
--requestheader-group-headers=X-Remote-Group
--requestheader-extra-headers-prefix=X-Remote-Extra-
</code></pre>
<p>针对所收到的如下请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#00a000>GET</span> <span style=color:#00f;font-weight:700>/</span> <span style=color:#a2f;font-weight:700>HTTP</span><span style=color:#666>/</span><span style=color:#666>1.1</span>
X-Remote-User<span style=color:#666>:</span> fido
X-Remote-Group<span style=color:#666>:</span> dogs
X-Remote-Group<span style=color:#666>:</span> dachshunds
X-Remote-Extra-Acme.com%2Fproject<span style=color:#666>:</span> some-project
X-Remote-Extra-Scopes<span style=color:#666>:</span> openid
X-Remote-Extra-Scopes<span style=color:#666>:</span> profile
</code></pre></div>
<p>会生成下面的用户信息：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fido<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>groups</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- dogs<span style=color:#bbb>
</span><span style=color:#bbb></span>- dachshunds<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>acme.com/project</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- some-project<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- openid<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- profile<span style=color:#bbb>
</span></code></pre></div>
<p>为了防范头部信息侦听，在请求中的头部字段被检视之前，
身份认证代理需要向 API 服务器提供一份合法的客户端证书，
供后者使用所给的 CA 来执行验证。
警告：<em>不要</em> 在不同的上下文中复用 CA 证书，除非你清楚这样做的风险是什么以及
应如何保护 CA 用法的机制。</p>
<ul>
<li><code>--requestheader-client-ca-file</code> 必需字段，给出 PEM 编码的证书包。
在检查请求的头部字段以提取用户名信息之前，必须提供一个合法的客户端证书，
且该证书要能够被所给文件中的机构所验证。</li>
<li><code>--requestheader-allowed-names</code> 可选字段，用来给出一组公共名称（CN）。
如果此标志被设置，则在检视请求中的头部以提取用户信息之前，必须提供
包含此列表中所给的 CN 名的、合法的客户端证书。</li>
</ul>
<h2 id=anonymous-requests>匿名请求 </h2>
<p>启用匿名请求支持之后，如果请求没有被已配置的其他身份认证方法拒绝，则被视作
匿名请求（Anonymous Requests）。这类请求获得用户名 <code>system:anonymous</code> 和
对应的用户组 <code>system:unauthenticated</code>。</p>
<p>例如，在一个配置了令牌身份认证且启用了匿名访问的服务器上，如果请求提供了非法的
持有者令牌，则会返回 <code>401 Unauthorized</code> 错误。
如果请求没有提供持有者令牌，则被视为匿名请求。</p>
<p>在 1.5.1-1.5.x 版本中，匿名访问默认情况下是被禁用的，可以通过为 API 服务器设定
<code>--anonymous-auth=true</code> 来启用。</p>
<p>在 1.6 及之后版本中，如果所使用的鉴权模式不是 <code>AlwaysAllow</code>，则匿名访问默认是被启用的。
从 1.6 版本开始，ABAC 和 RBAC 鉴权模块要求对 <code>system:anonymous</code> 用户或者
<code>system:unauthenticated</code> 用户组执行显式的权限判定，所以之前的为 <code>*</code> 用户或
<code>*</code> 用户组赋予访问权限的策略规则都不再包含匿名用户。</p>
<h2 id=user-impersonation>用户伪装 </h2>
<p>一个用户可以通过伪装（Impersonation）头部字段来以另一个用户的身份执行操作。
使用这一能力，你可以手动重载请求被身份认证所识别出来的用户信息。
例如，管理员可以使用这一功能特性来临时伪装成另一个用户，查看请求是否被拒绝，
从而调试鉴权策略中的问题，</p>
<p>带伪装的请求首先会被身份认证识别为发出请求的用户，之后会切换到使用被伪装的用户
的用户信息。</p>
<ul>
<li>用户发起 API 调用时 <em>同时</em> 提供自身的凭据和伪装头部字段信息</li>
<li>API 服务器对用户执行身份认证</li>
<li>API 服务器确认通过认证的用户具有伪装特权</li>
<li>请求用户的信息被替换成伪装字段的值</li>
<li>评估请求，鉴权组件针对所伪装的用户信息执行操作</li>
</ul>
<p>以下 HTTP 头部字段可用来执行伪装请求：</p>
<ul>
<li><code>Impersonate-User</code>：要伪装成的用户名</li>
<li><code>Impersonate-Group</code>：要伪装成的用户组名。可以多次指定以设置多个用户组。
可选字段；要求 "Impersonate-User" 必须被设置。</li>
<li><code>Impersonate-Extra-&lt;附加名称></code>：一个动态的头部字段，用来设置与用户相关的附加字段。
此字段可选；要求 "Impersonate-User" 被设置。为了能够以一致的形式保留，
<code>&lt;附加名称></code>部分必须是小写字符，如果有任何字符不是
<a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>合法的 HTTP 头部标签字符</a>，
则必须是 utf8 字符，且转换为<a href=https://tools.ietf.org/html/rfc3986#section-2.1>百分号编码</a>。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 在 1.11.3 版本之前（以及 1.10.7、1.9.11），<code>&lt;附加名称></code> 只能包含
合法的 HTTP 标签字符。
</div>
<p>头部字段集合的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Impersonate-User: jane.doe@example.com
</span><span>Impersonate-Group: developers
</span><span>Impersonate-Group: admins
</span><span>Impersonate-Extra-dn: cn=jane,ou=engineers,dc=example,dc=com
</span><span>Impersonate-Extra-acme.com%2Fproject: some-project
</span><span>Impersonate-Extra-scopes: view
</span><span>Impersonate-Extra-scopes: development
</span></code></pre></div>
<p>在使用 <code>kubectl</code> 时，可以使用 <code>--as</code> 标志来配置 <code>Impersonate-User</code> 头部字段值，
使用 <code>--as-group</code> 标志配置 <code>Impersonate-Group</code> 头部字段值。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl drain mynode
</code></pre></div><pre><code class=language-none data-lang=none>Error from server (Forbidden): User &quot;clark&quot; cannot get nodes at the cluster scope. (get nodes mynode)
</code></pre>
<p>设置 <code>--as</code> 和 <code>--as-group</code> 标志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl drain mynode --as<span style=color:#666>=</span>superman --as-group<span style=color:#666>=</span>system:masters
</code></pre></div><pre><code class=language-none data-lang=none>node/mynode cordoned
node/mynode drained
</code></pre>
<p>要伪装成某个用户、某个组或者设置附加字段，执行伪装操作的用户必须具有对所伪装的
类别（“user”、“group” 等）执行 “impersonate” 动词操作的能力。
对于启用了 RBAC 鉴权插件的集群，下面的 ClusterRole 封装了设置用户和组伪装字段
所需的规则：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;users&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;groups&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;serviceaccounts&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>附加字段会被作为 <code>userextras</code> 资源的子资源来执行权限评估。
如果要允许用户为附加字段 “scopes” 设置伪装头部，该用户需要被授予以下规则：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scopes-impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 可以设置 &#34;Impersonate-Extra-scopes&#34; 头部</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;userextras/scopes&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>你也可以通过约束资源可能对应的 <code>resourceNames</code> 限制伪装头部的取值：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>limited-impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 可以伪装成用户 &#34;jane.doe@example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;users&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;jane.doe@example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 可以伪装成用户组 &#34;developers&#34; 和 &#34;admins&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;groups&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;developers&#34;</span>,<span style=color:#b44>&#34;admins&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 可以将附加字段 &#34;scopes&#34; 伪装成 &#34;view&#34; 和 &#34;development&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;userextras/scopes&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;view&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;development&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<h2 id=client-go-credential-plugins>client-go 凭据插件 </h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p><code>k8s.io/client-go</code> 及使用它的工具（如 <code>kubectl</code> 和 <code>kubelet</code>）可以执行某个外部
命令来获得用户的凭据信息。</p>
<p>这一特性的目的是便于客户端与 <code>k8s.io/client-go</code> 并不支持的身份认证协议（LDAP、
Kerberos、OAuth2、SAML 等）继承。
插件实现特定于协议的逻辑，之后返回不透明的凭据以供使用。
几乎所有的凭据插件使用场景中都需要在服务器端存在一个支持
<a href=#webhook-token-authentication>Webhook 令牌身份认证组件</a>的模块，
负责解析客户端插件所生成的凭据格式。</p>
<h3 id=example-use-case>示例应用场景 </h3>
<p>在一个假想的应用场景中，某组织运行这一个外部的服务，能够将特定用户的已签名的
令牌转换成 LDAP 凭据。此服务还能够对
<a href=#webhook-token-authentication>Webhook 令牌身份认证组件</a>的请求做出响应以
验证所提供的令牌。用户需要在自己的工作站上安装一个凭据插件。</p>
<p>要对 API 服务器认证身份时：</p>
<ul>
<li>用户发出 <code>kubectl</code> 命令。</li>
<li>凭据插件提示用户输入 LDAP 凭据，并与外部服务交互，获得令牌。</li>
<li>凭据插件将令牌返回该 client-go，后者将其用作持有者令牌提交给 API 服务器。</li>
<li>API 服务器使用<a href=#webhook-token-authentication>Webhook 令牌身份认证组件</a>向
外部服务发出 <code>TokenReview</code> 请求。</li>
<li>外部服务检查令牌上的签名，返回用户的用户名和用户组信息。</li>
</ul>
<h3 id=configuration>配置 </h3>
<p>凭据插件通过 <a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubectl 配置文件</a>
来作为 user 字段的一部分设置。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要执行的命令。必需。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 解析 ExecCredentials 资源时使用的 API 版本。必需。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 插件返回的 API 版本必需与这里列出的版本匹配。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要与支持多个版本的工具（如 client.authentication.k8sio/v1alpha1）集成，</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 可以设置一个环境变量或者向工具传递一个参数标明 exec 插件所期望的版本。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 执行此插件时要设置的环境变量。可选字段。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;FOO&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;bar&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 执行插件时要传递的参数。可选字段。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;arg1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;arg2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 当可执行文件不存在时显示给用户的文本。可选的。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>installHint</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        需要 example-client-go-exec-plugin 来在当前集群上执行身份认证。可以通过以下命令安装：
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        MacOS: brew install example-client-go-exec-plugin
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        Ubuntu: apt-get install example-client-go-exec-plugin
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        Fedora: dnf install example-client-go-exec-plugin
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>        ...</span><span style=color:#bbb>        
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 是否使用 KUBERNETES_EXEC_INFO 环境变量的一部分向这个 exec 插件</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 提供集群信息（可能包含非常大的 CA 数据）</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>provideClusterInfo</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/ca.pem&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>extensions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>client.authentication.k8s.io/exec<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 为每个集群 exec 配置保留的扩展名</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>extension</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>arbitrary</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>this</span>:<span style=color:#bbb> </span>在设置 provideClusterInfo 时可通过环境变量 KUBERNETES_EXEC_INFO 指定<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>you</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;can&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;put&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;anything&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;here&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></code></pre></div>
<p>解析相对命令路径时，kubectl 将其视为与配置文件比较而言的相对路径。
如果 KUBECONFIG 被设置为 <code>/home/jane/kubeconfig</code>，而 exec 命令为
<code>./bin/example-client-go-exec-plugin</code>，则要执行的可执行文件为
<code>/home/jane/bin/example-client-go-exec-plugin</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 对 kubeconfig 目录而言的相对路径</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;./bin/example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span><span style=color:#bbb>
</span></code></pre></div>
<h3 id=input-and-output-formats>输出和输出格式 </h3>
<p>所执行的命令会在 <code>stdout</code> 打印 <code>ExecCredential</code> 对象。
<code>k8s.io/client-go</code> 使用 <code>status</code> 中返回的凭据信息向 Kubernetes API 服务器
执行身份认证。</p>
<p>在交互式会话中运行时，<code>stdin</code> 是直接暴露给插件使用的。
插件应该使用
<a href=https://godoc.org/golang.org/x/crypto/ssh/terminal#IsTerminal>TTY check</a>
来确定是否适合用交互方式请求用户输入。</p>
<p>与使用持有者令牌凭据，插件在 <code>ExecCredential</code> 的状态中返回一个令牌：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>
  }
}
</code></pre></div>
<p>另一种方案是，返回 PEM 编码的客户端证书和密钥，以便执行 TLS 客户端身份认证。
如果插件在后续调用中返回了不同的证书或密钥，<code>k8s.io/client-go</code>
会终止其与服务器的连接，从而强制执行新的 TLS 握手过程。</p>
<p>如果指定了这种方式，则 <code>clientKeyData</code> 和 <code>clientCertificateData</code> 字段都必需存在。</p>
<p><code>clientCertificateData</code> 字段可能包含一些要发送给服务器的中间证书（Intermediate
Certificates）。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;clientCertificateData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----&#34;</span>,
    <span style=color:green;font-weight:700>&#34;clientKeyData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----&#34;</span>
  }
}
</code></pre></div>
<p>作为一种可选方案，响应中还可以包含以 RFC3339 时间戳格式给出的证书到期时间。
证书到期时间的有无会有如下影响：</p>
<ul>
<li>如果响应中包含了到期时间，持有者令牌和 TLS 凭据会被缓存，直到到期期限到来、
或者服务器返回 401 HTTP 状态码，或者进程退出。</li>
<li>如果未指定到期时间，则持有者令牌和 TLS 凭据会被缓存，直到服务器返回 401
HTTP 状态码或者进程退出。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>,
    <span style=color:green;font-weight:700>&#34;expirationTimestamp&#34;</span>: <span style=color:#b44>&#34;2018-03-05T17:30:20-08:00&#34;</span>
  }
}
</code></pre></div>
<p>调用此插件时可以选择性地设置环境变量 <code>KUBERNETES_EXEC_INFO</code>。
该变量包含了此插件获取凭据所针对的集群信息。此信息可用于执行群集特定的凭据获取逻辑。
为了启用此行为，必须在 <a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>
中的 exec user 字段上设置<code>provideClusterInfo</code>字段。
下面是上述 <code>KUBERNETES_EXEC_INFO</code> 环境变量的示例。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;cluster&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;server&#34;</span>: <span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span>,
      <span style=color:green;font-weight:700>&#34;certificate-authority-data&#34;</span>: <span style=color:#b44>&#34;LS0t...&#34;</span>,
      <span style=color:green;font-weight:700>&#34;config&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;arbitrary&#34;</span>: <span style=color:#b44>&#34;config&#34;</span>,
        <span style=color:green;font-weight:700>&#34;this&#34;</span>: <span style=color:#b44>&#34;在设置 provideClusterInfo 时可通过环境变量 KUBERNETES_EXEC_INFO 指定&#34;</span>,
        <span style=color:green;font-weight:700>&#34;you&#34;</span>: [<span style=color:#b44>&#34;can&#34;</span>, <span style=color:#b44>&#34;put&#34;</span>, <span style=color:#b44>&#34;anything&#34;</span>, <span style=color:#b44>&#34;here&#34;</span>]
      }
    }
  }
}
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-de45b6ca7419a0e308044425b2ac52bb>3.2 - 使用启动引导令牌（Bootstrap Tokens）认证</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>启动引导令牌是一种简单的持有者令牌（Bearer Token），这种令牌是在新建集群
或者在现有集群中添加新节点时使用的。
它被设计成能够支持 <a href=/zh/docs/reference/setup-tools/kubeadm/><code>kubeadm</code></a>，
但是也可以被用在其他的案例中以便用户在不使用 <code>kubeadm</code> 的情况下启动集群。
它也被设计成可以通过 RBAC 策略，结合
<a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>Kubelet TLS 启动引导</a>
系统进行工作。</p>
<p>启动引导令牌被定义成一个特定类型的 Secret（<code>bootstrap.kubernetes.io/token</code>），
并存在于 <code>kube-system</code> 名字空间中。
这些 Secret 会被 API 服务器上的启动引导认证组件（Bootstrap Authenticator）读取。
控制器管理器中的控制器 TokenCleaner 能够删除过期的令牌。
这些令牌也被用来在节点发现的过程中会使用的一个特殊的 ConfigMap 对象。
BootstrapSigner 控制器也会使用这一 ConfigMap。</p>
<h2 id=令牌格式>令牌格式</h2>
<p>启动引导令牌使用 <code>abcdef.0123456789abcdef</code> 的形式。
更加规范地说，它们必须符合正则表达式 <code>[a-z0-9]{6}\.[a-z0-9]{16}</code>。</p>
<p>令牌的第一部分是 “Token ID”，它是一种公开信息，用于引用令牌并确保不会
泄露认证所使用的秘密信息。
第二部分是“令牌秘密（Token Secret）”，它应该被共享给受信的第三方。</p>
<h2 id=启用启动引导令牌>启用启动引导令牌</h2>
<h2 id=enabling-bootstrap-token-authentication>启用启动引导令牌身份认证 </h2>
<p>启动引导令牌认证组件可以通过 API 服务器上的如下标志启用：</p>
<pre><code>--enable-bootstrap-token-auth
</code></pre>
<p>启动引导令牌被启用后，可以作为持有者令牌的凭据，用于 API 服务器请求的身份认证。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Authorization: Bearer 07401b.f395accd246ae52d
</span></code></pre></div>
<p>令牌认证为用户名 <code>system:bootstrap:&lt;token id></code> 并且是组 <code>system:bootstrappers</code>
的成员。额外的组信息可以通过令牌的 Secret 来设置。</p>
<p>过期的令牌可以通过启用控制器管理器中的 <code>tokencleaner</code> 控制器来删除。</p>
<h2 id=bootstrap-token-secret-format>启动引导令牌的 Secret 格式 </h2>
<p>每个合法的令牌背后对应着 <code>kube-system</code> 名字空间中的某个 Secret 对象。
你可以从
<a href=https://github.com/kubernetes/community/blob/v1.22.16/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md>这里</a>.
找到完整设计文档。</p>
<p>这是 Secret 看起来的样子。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># name 必须是 &#34;bootstrap-token-&lt;token id&gt;&#34; 格式的</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-07401b<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># type 必须是 &#39;bootstrap.kubernetes.io/token&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 供人阅读的描述，可选。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;The default bootstrap token generated by &#39;kubeadm init&#39;.&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 令牌 ID 和秘密信息，必需。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>07401b<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>base64(f395accd246ae52d)<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 可选的过期时间字段</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2017-03-10T03:22:11Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 允许的用法</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 令牌要认证为的额外组，必须以 &#34;system:bootstrappers:&#34; 开头</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>system:bootstrappers:worker,system:bootstrappers:ingress<span style=color:#bbb>
</span></code></pre></div>
<p>Secret 的类型必须是 <code>bootstrap.kubernetes.io/token</code>，而且名字必须是 <code>bootstrap-token-&lt;token id></code>。
令牌必须存在于 <code>kube-system</code> 名字空间中。</p>
<p><code>usage-bootstrap-*</code> 成员表明这个 Secret 的用途。启用时，值必须设置为 <code>true</code>。</p>
<ul>
<li><code>usage-bootstrap-authentication</code> 表示令牌可以作为持有者令牌用于 API 服务器的身份认证。</li>
<li><code>usage-bootstrap-signing</code> 表示令牌可被用于 <code>cluster-info</code> ConfigMap 的签名，
就像下面描述的那样。</li>
</ul>
<p><code>expiration</code> 字段控制令牌的失效期。过期的令牌在用于身份认证时会被拒绝，在用于
ConfigMap 签名时会被忽略。
过期时间值是遵循 RFC3339 进行编码的 UTC 时间。
启用 TokenCleaner 控制器会自动删除过期的令牌。</p>
<h2 id=token-management-with-kubeadm>使用 <code>kubeadm</code> 管理令牌 </h2>
<p>你可以使用 <code>kubeadm</code> 工具管理运行中集群上的令牌。
参见 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/>kubeadm token 文档</a>
以了解详细信息。</p>
<h3 id=configmap-signing>ConfigMap 签名 </h3>
<p>除了身份认证，令牌还可以用于签名 ConfigMap。
这一用法发生在集群启动过程的早期，在客户端信任 API 服务器之前。
被签名的 ConfigMap 可以被共享令牌完成身份认证。</p>
<p>通过在控制器管理器上启用 <code>bootstrapsigner</code> 控制器可以启用 ConfigMap 签名特性。</p>
<pre><code>--controllers=*,bootstrapsigner
</code></pre>
<p>被签名的 ConfigMap 是 <code>kube-public</code> 名字空间中的 <code>cluster-info</code>。
典型的工作流中，客户端在未经认证和忽略 TLS 报错的状态下读取这个 ConfigMap。
通过检查 ConfigMap 中嵌入的签名校验 ConfigMap 的载荷。</p>
<p>ConfigMap 会是这个样子的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cluster-info<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-public<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jws-kubeconfig-07401b</span>:<span style=color:#bbb> </span>eyJhbGciOiJIUzI1NiIsImtpZCI6IjA3NDAxYiJ9..tYEfbo6zDNo40MQE07aZcQX2m3EB2rO3NuXtxVMYm9U<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubeconfig</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    apiVersion: v1
</span><span style=color:#b44;font-style:italic>    clusters:
</span><span style=color:#b44;font-style:italic>    - cluster:
</span><span style=color:#b44;font-style:italic>        certificate-authority-data: &lt;非常长的证书数据&gt;
</span><span style=color:#b44;font-style:italic>        server: https://10.138.0.2:6443
</span><span style=color:#b44;font-style:italic>      name: &#34;&#34;
</span><span style=color:#b44;font-style:italic>    contexts: []
</span><span style=color:#b44;font-style:italic>    current-context: &#34;&#34;
</span><span style=color:#b44;font-style:italic>    kind: Config
</span><span style=color:#b44;font-style:italic>    preferences: {}
</span><span style=color:#b44;font-style:italic>    users: []</span><span style=color:#bbb>    
</span></code></pre></div>
<p>ConfigMap 的 <code>kubeconfig</code> 成员是一个填好了集群信息的配置文件。
这里主要交换的信息是 <code>certificate-authority-data</code>。在将来可能会有扩展。</p>
<p>签名是一个使用 “detached” 模式生成的 JWS 签名。
为了检验签名，用户应该按照 JWS 规则（base64 编码且丢掉结尾的 <code>=</code>）对
<code>kubeconfig</code> 的载荷进行编码。完成编码的载荷会被插入到两个句点中间，形成完整的
JWS。你可以使用完整的令牌（比如 <code>07401b.f395accd246ae52d</code>）作为共享密钥，
通过 <code>HS256</code> 方式 (HMAC-SHA256) 对 JWS 进行校验。
用户 <em>必须</em> 确保使用了 HS256。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告：</strong>
<p>任何拥有了启动引导令牌的主体都可以为该令牌生成一个合法的签名。
当使用 ConfigMap 签名时，非常不建议针对很多客户使用相同的令牌，因为某个被攻击的
客户可能对另一个一来签名来开启 TLS 信任的客户发起中间人攻击。
</div>
<p>参考 <a href=/zh/docs/reference/setup-tools/kubeadm/implementation-details/>kubeadm 实现细节</a>
了解更多信息。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3d0c14d1e3cfade38febc343cd044c73>3.3 - 证书签名请求</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>
<p>证书 API 支持
<a href=https://www.itu.int/rec/T-REC-X.509>X.509</a>
的自动化配置，
它为 Kubernetes API 的客户端提供一个编程接口，
用于从证书颁发机构（CA）请求并获取 X.509
<a class=glossary-tooltip title="证书是个安全加密文件，用来确认对 Kubernetes 集群访问的合法性。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/tls/managing-tls-in-a-cluster/ target=_blank aria-label=证书>证书</a>。</p>
<p>CertificateSigningRequest（CSR）资源用来向指定的签名者申请证书签名，
在最终签名之前，申请可能被批准，也可能被拒绝。</p>
<h2 id=request-signing-process>请求签名流程</h2>
<p>CertificateSigningRequest 资源类型允许客户使用它申请发放 X.509 证书。
CertificateSigningRequest 对象 在 <code>spec.request</code> 中包含一个 PEM 编码的 PKCS#10 签名请求。
CertificateSigningRequest 使用 <code>spec.signerName</code> 字段标示 <em>签名者</em>（请求的接收方）。
注意，<code>spec.signerName</code> 在 <code>certificates.k8s.io/v1</code> 之后的 API 版本是必填项。
在 Kubernetes v1.22 和以后的版本，客户可以可选地设置 <code>spec.expirationSeconds</code>
字段来为颁发的证书设定一个特定的有效期。该字段的最小有效值是 <code>600</code>，也就是 10 分钟。</p>
<p>创建完成的 CertificateSigningRequest，要先通过批准，然后才能签名。
根据所选的签名者，CertificateSigningRequest 可能会被
<a class=glossary-tooltip title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>自动批准。
否则，就必须人工批准，
人工批准可以使用 REST API（或 go 客户端），也可以执行 <code>kubectl certificate approve</code> 命令。
同样，CertificateSigningRequest 也可能被驳回，
这就相当于通知了指定的签名者，这个证书不能签名。</p>
<p>对于已批准的证书，下一步是签名。
对应的签名控制器首先验证签名条件是否满足，然后才创建证书。
签名控制器然后更新 CertificateSigningRequest，
将新证书保存到现有 CertificateSigningRequest 对象的 <code>status.certificate</code> 字段中。
此时，字段 <code>status.certificate</code> 要么为空，要么包含一个用 PEM 编码的 X.509 证书。
直到签名完成前，CertificateSigningRequest 的字段 <code>status.certificate</code> 都为空。</p>
<p>一旦 <code>status.certificate</code> 字段完成填充，请求既算完成，
客户端现在可以从 CertificateSigningRequest 资源中获取已签名的证书的 PEM 数据。
当然如果不满足签名条件，签名者可以拒签。</p>
<p>为了减少集群中遗留的过时的 CertificateSigningRequest 资源的数量，
一个垃圾收集控制器将会周期性地运行。
此垃圾收集器会清除在一段时间内没有改变过状态的 CertificateSigningRequests：</p>
<ul>
<li>已批准的请求：1小时后自动删除</li>
<li>已拒绝的请求：1小时后自动删除</li>
<li>已失败的请求：1小时后自动删除</li>
<li>挂起的请求：24小时后自动删除</li>
<li>所有请求：在颁发的证书过期后自动删除</li>
</ul>
<h2 id=signers>签名者</h2>
<p>也可以指定自定义 signerName。
所有签名者都应该提供自己工作方式的信息，
以便客户端可以预期到他们的 CSR 将发生什么。
此类信息包括：</p>
<ol>
<li><strong>信任分发</strong>：信任（CA 证书包）是如何分发的。</li>
<li><strong>许可的主体</strong>：当一个受限制的主体（subject）发送请求时，相应的限制和应对手段。</li>
<li><strong>许可的 x509 扩展</strong>：包括 IP subjectAltNames、DNS subjectAltNames、
Email subjectAltNames、URI subjectAltNames 等，请求一个受限制的扩展项时的应对手段。</li>
<li><strong>许可的密钥用途/扩展的密钥用途</strong>：当用途和签名者在 CSR 中指定的用途不同时，
相应的限制和应对手段。</li>
<li><strong>过期时间/证书有效期</strong>：过期时间由签名者确定、由管理员配置、还是由 CSR <code>spec.expirationSeconds</code> 字段指定等，
以及签名者决定的过期时间与 CSR <code>spec.expirationSeconds</code> 字段不同时的应对手段。</li>
<li><strong>允许/不允许 CA 位</strong>：当 CSR 包含一个签名者并不允许的 CA 证书的请求时，相应的应对手段。</li>
</ol>
<p>一般来说，当 CSR 被批准通过，且证书被签名后，<code>status.certificate</code> 字段
将包含一个 PEM 编码的 X.509 证书。
有些签名者在 <code>status.certificate</code> 字段中存储多个证书。
在这种情况下，签名者的说明文档应当指明附加证书的含义。
例如，这是要在 TLS 握手时提供的证书和中继证书。</p>
<p>PKCS#10 签名请求格式并没有一种标准的方法去设置证书的过期时间或者生命期。
因此，证书的过期时间或者生命期必须通过 CSR 对象的 <code>spec.expirationSeconds</code> 字段来设置。
当 <code>spec.expirationSeconds</code> 没有被指定时，内置的签名者默认使用 <code>ClusterSigningDuration</code> 配置选项
（kube-controller-manager 的命令行选项 <code>--cluster-signing-duration</code>），该选项的默认值设为 1 年。
当 <code>spec.expirationSeconds</code> 被指定时，<code>spec.expirationSeconds</code> 和 <code>ClusterSigningDuration</code>
中的最小值会被使用。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p><code>spec.expirationSeconds</code> 字段是在 Kubernetes v1.22 中加入的。早期的 Kubernetes 版本并不认识该字段。
v1.22 版本之前的 Kubernetes API 服务器会在创建对象的时候忽略该字段。
</div>
<h3 id=kubernetes-signers>Kubernetes 签名者</h3>
<p>Kubernetes提供了内置的签名者，每个签名者都有一个众所周知的 <code>signerName</code>:</p>
<ol>
<li><code>kubernetes.io/kube-apiserver-client</code>：签名的证书将被 API 服务器视为客户证书。
<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 不会自动批准它。
<ol>
<li>信任分发：签名的证书将被 API 服务器视为客户端证书。CA 证书包不通过任何其他方式分发。</li>
<li>许可的主体：没有主体限制，但审核人和签名者可以选择不批准或不签署。
某些主体，比如集群管理员级别的用户或组因部署和安装方式不同而不同，
所以批准和签署之前需要进行额外仔细审查。
用来限制 <code>system:masters</code> 的 CertificateSubjectRestriction 准入插件默认处于启用状态，
但它通常不是集群中唯一的集群管理员主体。</li>
<li>许可的 x509 扩展：允许 subjectAltName 和 key usage 扩展，弃用其他扩展。</li>
<li>许可的密钥用途：必须包含 <code>["client auth"]</code>，但不能包含
<code>["digital signature", "key encipherment", "client auth"]</code> 之外的键。</li>
<li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li>
<li>允许/不允许 CA 位：不允许。</li>
</ol>
</li>
</ol>
<ol start=2>
<li>
<p><code>kubernetes.io/kube-apiserver-client-kubelet</code>: 签名的证书将被 kube-apiserver 视为客户证书。
<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 可以自动批准它。</p>
<ol>
<li>信任分发：签名的证书将被 API 服务器视为客户端证书。CA 证书包不通过任何其他方式分发。</li>
<li>许可的主体：组织名必须是 <code>["system:nodes"]</code>，用户名以 "<code>system:node:</code>" 开头</li>
<li>许可的 x509 扩展：允许 key usage 扩展，禁用 subjectAltName 扩展，并删除其他扩展。</li>
<li>许可的密钥用途：必须是 <code>["key encipherment", "digital signature", "client auth"]</code></li>
<li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li>
<li>允许/不允许 CA 位：不允许。</li>
</ol>
</li>
</ol>
<ol start=3>
<li><code>kubernetes.io/kubelet-serving</code>: 签名服务证书，该服务证书被 API 服务器视为有效的 kubelet 服务证书，
但没有其他保证。<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 不会自动批准它。
<ol>
<li>信任分发：签名的证书必须被 kube-apiserver 认可，可有效的中止 kubelet 连接。CA 证书包不通过任何其他方式分发。</li>
<li>许可的主体：组织名必须是 <code>["system:nodes"]</code>，用户名以 "<code>system:node:</code>" 开头</li>
<li>许可的 x509 扩展：允许 key usage、DNSName/IPAddress subjectAltName 等扩展，
禁止 EmailAddress、URI subjectAltName 等扩展，并丢弃其他扩展。
至少有一个 DNS 或 IP 的 SubjectAltName 存在。</li>
<li>许可的密钥用途：必须是 <code>["key encipherment", "digital signature", "client auth"]</code></li>
<li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li>
<li>允许/不允许 CA 位：不允许。</li>
</ol>
</li>
</ol>
<ol start=4>
<li><code>kubernetes.io/legacy-unknown</code>: 不保证信任。Kubernetes 的一些第三方发行版可能会使用它签署的客户端证书。
稳定版的 CertificateSigningRequest API（<code>certificates.k8s.io/v1</code> 以及之后的版本）不允许将
<code>signerName</code> 设置为 <code>kubernetes.io/legacy-unknown</code>。
<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 不会自动批准这类请求。
<ol>
<li>信任分发：没有。这个签名者在 Kubernetes 集群中没有标准的信任或分发。</li>
<li>许可的主体：全部。</li>
<li>许可的 x509 扩展：允许 subjectAltName 和 key usage 等扩展，并弃用其他扩展。</li>
<li>许可的密钥用途：全部。</li>
<li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li>
<li>允许/不允许 CA 位 - 不允许。</li>
</ol>
</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>注意：所有这些故障仅在 kube-controller-manager 日志中报告。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p><code>spec.expirationSeconds</code> 字段是在 Kubernetes v1.22 中加入的。早期的 Kubernetes 版本并不认识该字段。
v1.22 版本之前的 Kubernetes API 服务器会在创建对象的时候忽略该字段。
</div>
<p>对于这些签名者，信任的分发发生在带外（out of band）。上述信任之外的任何信任都是完全巧合的。
例如，一些发行版可能会将 <code>kubernetes.io/legacy-unknown</code> 作为 kube-apiserver 的客户端证书，
但这个做法并不标准。
这些用途都没有以任何方式涉及到 ServiceAccount 中的 Secrets <code>.data[ca.crt]</code>。
此 CA 证书包只保证使用默认的服务（<code>kubernetes.default.svc</code>）来验证到 API 服务器的连接。</p>
<h2 id=authorization>鉴权</h2>
<p>授权创建 CertificateSigningRequest 和检索 CertificateSigningRequest:</p>
<ul>
<li>verbs（动词）: <code>create</code>、<code>get</code>、<code>list</code>、<code>watch</code>,
group（组）：<code>certificates.k8s.io</code>，
resources：<code>certificatesigningrequests</code></li>
</ul>
<p>例如：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/access/certificate-signing-request/clusterrole-create.yaml download=access/certificate-signing-request/clusterrole-create.yaml><code>access/certificate-signing-request/clusterrole-create.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('access-certificate-signing-request-clusterrole-create-yaml')" title="Copy access/certificate-signing-request/clusterrole-create.yaml to clipboard">
</img>
</div>
<div class=includecode id=access-certificate-signing-request-clusterrole-create-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csr-creator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificatesigningrequests<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>授权批准 CertificateSigningRequest：</p>
<ul>
<li>verbs（动词）: <code>get</code>、<code>list</code>、<code>watch</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests</code></li>
<li>verbs（动词）: <code>update</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests/approval</code></li>
<li>verbs（动词）：<code>approve</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>signers</code>，
resourceName：<code>&lt;signerNameDomain>/&lt;signerNamePath></code> 或 <code>&lt;signerNameDomain>/*</code></li>
</ul>
<p>例如：</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/access/certificate-signing-request/clusterrole-approve.yaml download=access/certificate-signing-request/clusterrole-approve.yaml><code>access/certificate-signing-request/clusterrole-approve.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('access-certificate-signing-request-clusterrole-approve-yaml')" title="Copy access/certificate-signing-request/clusterrole-approve.yaml to clipboard">
</img>
</div>
<div class=includecode id=access-certificate-signing-request-clusterrole-approve-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csr-approver<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificatesigningrequests<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificatesigningrequests/approval<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- signers<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- example.com/my-signer-name<span style=color:#bbb> </span><span style=color:#080;font-style:italic># example.com/* can be used to authorize for all signers in the &#39;example.com&#39; domain</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- approve<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>授权签名 CertificateSigningRequest：</p>
<ul>
<li>verbs（动词）：<code>get</code>、<code>list</code>、<code>watch</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests</code></li>
<li>verbs（动词）：<code>update</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests/status</code></li>
<li>verbs（动词）：<code>sign</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>signers</code>，
resourceName：<code>&lt;signerNameDomain>/&lt;signerNamePath></code> 或 <code>&lt;signerNameDomain>/*</code></li>
</ul>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh/examples/access/certificate-signing-request/clusterrole-sign.yaml download=access/certificate-signing-request/clusterrole-sign.yaml><code>access/certificate-signing-request/clusterrole-sign.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('access-certificate-signing-request-clusterrole-sign-yaml')" title="Copy access/certificate-signing-request/clusterrole-sign.yaml to clipboard">
</img>
</div>
<div class=includecode id=access-certificate-signing-request-clusterrole-sign-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csr-signer<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificatesigningrequests<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificatesigningrequests/status<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- signers<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- example.com/my-signer-name<span style=color:#bbb> </span><span style=color:#080;font-style:italic># example.com/* can be used to authorize for all signers in the &#39;example.com&#39; domain</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- sign<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h2 id=normal-user>普通用户</h2>
<p>为了让普通用户能够通过认证并调用 API，需要执行几个步骤。
首先，该用户必须拥有 Kubernetes 集群签发的证书，
然后将该证书提供给 Kubernetes API。</p>
<h3 id=create-private-key>创建私钥</h3>
<p>下面的脚本展示了如何生成 PKI 私钥和 CSR。
设置 CSR 的 CN 和 O 属性很重要。CN 是用户名，O 是该用户归属的组。
你可以参考 <a href=/zh/docs/reference/access-authn-authz/rbac/>RBAC</a> 了解标准组的信息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>openssl genrsa -out myuser.key <span style=color:#666>2048</span>
openssl req -new -key myuser.key -out myuser.csr
</code></pre></div>
<h3 id=create-certificatesigningrequest>创建 CertificateSigningRequest</h3>
<p>创建一个 CertificateSigningRequest，并通过 kubectl 将其提交到 Kubernetes 集群。
下面是生成 CertificateSigningRequest 的脚本。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: certificates.k8s.io/v1
</span><span style=color:#b44>kind: CertificateSigningRequest
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: myuser
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1ZqQ0NBVDRDQVFBd0VURVBNQTBHQTFVRUF3d0dZVzVuWld4aE1JSUJJakFOQmdrcWhraUc5dzBCQVFFRgpBQU9DQVE4QU1JSUJDZ0tDQVFFQTByczhJTHRHdTYxakx2dHhWTTJSVlRWMDNHWlJTWWw0dWluVWo4RElaWjBOCnR2MUZtRVFSd3VoaUZsOFEzcWl0Qm0wMUFSMkNJVXBGd2ZzSjZ4MXF3ckJzVkhZbGlBNVhwRVpZM3ExcGswSDQKM3Z3aGJlK1o2MVNrVHF5SVBYUUwrTWM5T1Nsbm0xb0R2N0NtSkZNMUlMRVI3QTVGZnZKOEdFRjJ6dHBoaUlFMwpub1dtdHNZb3JuT2wzc2lHQ2ZGZzR4Zmd4eW8ybmlneFNVekl1bXNnVm9PM2ttT0x1RVF6cXpkakJ3TFJXbWlECklmMXBMWnoyalVnald4UkhCM1gyWnVVV1d1T09PZnpXM01LaE8ybHEvZi9DdS8wYk83c0x0MCt3U2ZMSU91TFcKcW90blZtRmxMMytqTy82WDNDKzBERHk5aUtwbXJjVDBnWGZLemE1dHJRSURBUUFCb0FBd0RRWUpLb1pJaHZjTgpBUUVMQlFBRGdnRUJBR05WdmVIOGR4ZzNvK21VeVRkbmFjVmQ1N24zSkExdnZEU1JWREkyQTZ1eXN3ZFp1L1BVCkkwZXpZWFV0RVNnSk1IRmQycVVNMjNuNVJsSXJ3R0xuUXFISUh5VStWWHhsdnZsRnpNOVpEWllSTmU3QlJvYXgKQVlEdUI5STZXT3FYbkFvczFqRmxNUG5NbFpqdU5kSGxpT1BjTU1oNndLaTZzZFhpVStHYTJ2RUVLY01jSVUyRgpvU2djUWdMYTk0aEpacGk3ZnNMdm1OQUxoT045UHdNMGM1dVJVejV4T0dGMUtCbWRSeEgvbUNOS2JKYjFRQm1HCkkwYitEUEdaTktXTU0xMzhIQXdoV0tkNjVoVHdYOWl4V3ZHMkh4TG1WQzg0L1BHT0tWQW9FNkpsYWFHdTlQVmkKdjlOSjVaZlZrcXdCd0hKbzZXdk9xVlA3SVFjZmg3d0drWm89Ci0tLS0tRU5EIENFUlRJRklDQVRFIFJFUVVFU1QtLS0tLQo=
</span><span style=color:#b44>  signerName: kubernetes.io/kube-apiserver-client
</span><span style=color:#b44>  expirationSeconds: 86400  # one day
</span><span style=color:#b44>  usages:
</span><span style=color:#b44>  - client auth
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>需要注意的几点:</p>
<ul>
<li><code>usage</code> 字段必须是 '<code>client auth</code>'</li>
<li><code>expirationSeconds</code> 可以设置为更长（例如 <code>864000</code> 是十天）或者更短（例如 <code>3600</code> 是一个小时）</li>
<li><code>request</code> 字段是 CSR 文件内容的 base64 编码值。
要得到该值，可以执行命令 <code>cat myuser.csr | base64 | tr -d "\n"</code>。</li>
</ul>
<h3 id=approve-certificate-signing-request>批准证书签名请求</h3>
<p>使用 kubectl 创建 CSR 并批准。</p>
<p>获取 CSR 列表：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr
</code></pre></div>
<p>批准 CSR：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl certificate approve myuser
</code></pre></div>
<h3 id=get-the-certificate>取得证书</h3>
<p>从 CSR 取得证书：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr/myuser -o yaml
</code></pre></div>
<p>证书的内容使用 base64 编码，存放在字段 <code>status.certificate</code>。</p>
<p>从 CertificateSigningRequest 导出颁发的证书。</p>
<pre><code>kubectl get csr myuser -o jsonpath='{.status.certificate}'| base64 -d &gt; myuser.crt
</code></pre>
<h3 id=create-role-and-role-binding>创建角色和角色绑定</h3>
<p>创建了证书之后，为了让这个用户能访问 Kubernetes 集群资源，现在就要创建
Role 和 RoleBinding 了。</p>
<p>下面是为这个新用户创建 Role 的示例命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role developer --verb<span style=color:#666>=</span>create --verb<span style=color:#666>=</span>get --verb<span style=color:#666>=</span>list --verb<span style=color:#666>=</span>update --verb<span style=color:#666>=</span>delete --resource<span style=color:#666>=</span>pods
</code></pre></div>
<p>下面是为这个新用户创建 RoleBinding 的示例命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding developer-binding-myuser --role<span style=color:#666>=</span>developer --user<span style=color:#666>=</span>myuser
</code></pre></div>
<h3 id=add-to-kubeconfig>添加到 kubeconfig </h3>
<p>最后一步是将这个用户添加到 kubeconfig 文件。
我们假设私钥和证书文件存放在 “/home/vagrant/work/” 目录中。</p>
<p>首先，我们需要添加新的凭据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config set-credentials myuser --client-key<span style=color:#666>=</span>myuser.key --client-certificate<span style=color:#666>=</span>myuser.crt --embed-certs<span style=color:#666>=</span><span style=color:#a2f>true</span>

</code></pre></div>
<p>然后，你需要添加上下文：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config set-context myuser --cluster<span style=color:#666>=</span>kubernetes --user<span style=color:#666>=</span>myuser
</code></pre></div>
<p>来测试一下，把上下文切换为 <code>myuser</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config use-context myuser
</code></pre></div>
<h2 id=approval-rejection>批准和驳回</h2>
<h3 id=approval-rejection-control-plane>控制平面的自动化批准</h3>
<p>kube-controller-manager 内建了一个证书批准者，其 signerName 为
<code>kubernetes.io/kube-apiserver-client-kubelet</code>，
该批准者将 CSR 上用于节点凭据的各种权限委托给权威认证机构。
kube-controller-manager 将 SubjectAccessReview 资源发送（POST）到 API 服务器，
以便检验批准证书的授权。</p>
<h3 id=approval-rejection-kubectl>使用 <code>kubectl</code> 批准或驳回 </h3>
<p>Kubernetes 管理员（拥有足够的权限）可以手工批准（或驳回）CertificateSigningRequests，
此操作使用 <code>kubectl certificate approve</code> 和 <code>kubectl certificate deny</code> 命令实现。</p>
<p>使用 kubectl 批准一个 CSR：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl certificate approve &lt;certificate-signing-request-name&gt;
</code></pre></div>
<p>同样地，驳回一个 CSR：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl certificate deny &lt;certificate-signing-request-name&gt;
</code></pre></div>
<h3 id=approval-rejection-api-client>使用 Kubernetes API 批准或驳回 </h3>
<p>REST API 的用户可以通过向待批准的 CSR 的 <code>approval</code> 子资源提交更新请求来批准 CSR。
例如，你可以编写一个
<a class=glossary-tooltip title=一种用于管理自定义资源的专用控制器 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operator>operator</a>
来监视特定类型的 CSR，然后发送一个更新来批准它。</p>
<p>当你发出批准或驳回的指令时，根据你期望的状态来选择设置 <code>Approved</code> 或 <code>Denied</code>。</p>
<p>批准（<code>Approved</code>） 的 CSR：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>certificates.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CertificateSigningRequest<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-08T11:37:35Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-08T11:37:35Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>Approved by my custom approver controller<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>ApprovedByMyPolicy<span style=color:#bbb> </span><span style=color:#080;font-style:italic># You can set this to any string</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Approved<span style=color:#bbb>
</span></code></pre></div>
<p>驳回（<code>Denied</code>）的 CRS：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>certificates.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CertificateSigningRequest<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-08T11:37:35Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-08T11:37:35Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>Denied by my custom approver controller<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>DeniedByMyPolicy<span style=color:#bbb> </span><span style=color:#080;font-style:italic># You can set this to any string</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Denied<span style=color:#bbb>
</span></code></pre></div>
<p><code>status.conditions.reason</code> 字段通常设置为一个首字母大写的对机器友好的原因码;
这是一个命名约定，但你也可以随你的个人喜好设置。
如果你想添加一个供人类使用的注释，那就用 <code>status.conditions.message</code> 字段。</p>
<h2 id=signing>签名 </h2>
<h3 id=signer-control-plane>控制平面签名者 </h3>
<p>Kubernetes 控制平面实现了每一个
<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers>Kubernetes 签名者</a>，
每个签名者的实现都是 kube-controller-manager 的一部分。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 在Kubernetes v1.18 之前，
kube-controller-manager 签名所有标记为 approved 的 CSR。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p><code>spec.expirationSeconds</code> 字段是在 Kubernetes v1.22 中加入的。早期的 Kubernetes 版本并不认识该字段。
v1.22 版本之前的 Kubernetes API 服务器会在创建对象的时候忽略该字段。
</div>
<h3 id=signer-api>基于 API 的签名者 </h3>
<p>REST API 的用户可以通过向待签名的 CSR 的 <code>status</code> 子资源提交更新请求来对 CSR 进行签名。</p>
<p>作为这个请求的一部分， <code>status.certificate</code> 字段应设置为已签名的证书。
此字段可包含一个或多个 PEM 编码的证书。</p>
<p>所有的 PEM 块必须具备 "CERTIFICATE" 标签，且不包含文件头，且编码的数据必须是
<a href=https://tools.ietf.org/html/rfc5280#section-4.1>RFC5280 第 4 节</a>
中描述的 BER 编码的 ASN.1 证书结构。</p>
<pre><code>-----BEGIN CERTIFICATE-----
MIIDgjCCAmqgAwIBAgIUC1N1EJ4Qnsd322BhDPRwmg3b/oAwDQYJKoZIhvcNAQEL
BQAwXDELMAkGA1UEBhMCeHgxCjAIBgNVBAgMAXgxCjAIBgNVBAcMAXgxCjAIBgNV
BAoMAXgxCjAIBgNVBAsMAXgxCzAJBgNVBAMMAmNhMRAwDgYJKoZIhvcNAQkBFgF4
MB4XDTIwMDcwNjIyMDcwMFoXDTI1MDcwNTIyMDcwMFowNzEVMBMGA1UEChMMc3lz
dGVtOm5vZGVzMR4wHAYDVQQDExVzeXN0ZW06bm9kZToxMjcuMC4wLjEwggEiMA0G
CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDne5X2eQ1JcLZkKvhzCR4Hxl9+ZmU3
+e1zfOywLdoQxrPi+o4hVsUH3q0y52BMa7u1yehHDRSaq9u62cmi5ekgXhXHzGmm
kmW5n0itRECv3SFsSm2DSghRKf0mm6iTYHWDHzUXKdm9lPPWoSOxoR5oqOsm3JEh
Q7Et13wrvTJqBMJo1GTwQuF+HYOku0NF/DLqbZIcpI08yQKyrBgYz2uO51/oNp8a
sTCsV4OUfyHhx2BBLUo4g4SptHFySTBwlpRWBnSjZPOhmN74JcpTLB4J5f4iEeA7
2QytZfADckG4wVkhH3C2EJUmRtFIBVirwDn39GXkSGlnvnMgF3uLZ6zNAgMBAAGj
YTBfMA4GA1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDAjAMBgNVHRMB
Af8EAjAAMB0GA1UdDgQWBBTREl2hW54lkQBDeVCcd2f2VSlB1DALBgNVHREEBDAC
ggAwDQYJKoZIhvcNAQELBQADggEBABpZjuIKTq8pCaX8dMEGPWtAykgLsTcD2jYr
L0/TCrqmuaaliUa42jQTt2OVsVP/L8ofFunj/KjpQU0bvKJPLMRKtmxbhXuQCQi1
qCRkp8o93mHvEz3mTUN+D1cfQ2fpsBENLnpS0F4G/JyY2Vrh19/X8+mImMEK5eOy
o0BMby7byUj98WmcUvNCiXbC6F45QTmkwEhMqWns0JZQY+/XeDhEcg+lJvz9Eyo2
aGgPsye1o3DpyXnyfJWAWMhOz7cikS5X2adesbgI86PhEHBXPIJ1v13ZdfCExmdd
M1fLPhLyR54fGaY+7/X8P9AZzPefAkwizeXwe9ii6/a08vWoiE4=
-----END CERTIFICATE-----
</code></pre>
<p>非 PEM 内容可能会出现在证书 PEM 块前后的位置，且未经验证，
以允许使用 RFC7468 第5.2节 中描述的解释性文本。</p>
<p>当使用 JSON 或 YAML 格式时，此字段是 base-64 编码。
包含上述示例证书的 CertificateSigningRequest 如下所示：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>certificates.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CertificateSigningRequest<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>certificate</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JS...&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=接下来>接下来</h2>
<ul>
<li>参阅 <a href=/zh/docs/tasks/tls/managing-tls-in-a-cluster/>管理集群中的 TLS 认证</a></li>
<li>查看 kube-controller-manager 中<a href=https://github.com/kubernetes/kubernetes/blob/32ec6c212ec9415f604ffc1f4c1f29b782968ff1/pkg/controller/certificates/signer/cfssl_signer.go>签名者</a>部分的源代码</li>
<li>查看 kube-controller-manager 中<a href=https://github.com/kubernetes/kubernetes/blob/32ec6c212ec9415f604ffc1f4c1f29b782968ff1/pkg/controller/certificates/approver/sarapprove.go>批准者</a>部分的源代码</li>
<li>有关 X.509 本身的详细信息，请参阅 <a href=https://tools.ietf.org/html/rfc5280#section-3.1>RFC 5280</a> 第3.1节</li>
<li>有关 PKCS#10 证书签名请求语法的信息，请参阅 <a href=https://tools.ietf.org/html/rfc2986>RFC 2986</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-518807b9b00bda46d7c7e6e0b17c18f8>3.4 - 使用准入控制器</h1>
<p>此页面概述了准入控制器。</p>
<h2 id=什么是准入控制插件>什么是准入控制插件？</h2>
<p>准入控制器是一段代码，它会在请求通过认证和授权之后、对象被持久化之前拦截到达 API
服务器的请求。控制器由下面的<a href=#what-does-each-admission-controller-do>列表</a>组成，
并编译进 <code>kube-apiserver</code> 二进制文件，并且只能由集群管理员配置。
在该列表中，有两个特殊的控制器：MutatingAdmissionWebhook 和 ValidatingAdmissionWebhook。
它们根据 API 中的配置，分别执行变更和验证
<a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>准入控制 webhook</a>。</p>
<p>准入控制器可以执行 “验证（Validating）” 和/或 “变更（Mutating）” 操作。
变更（mutating）控制器可以修改被其接受的对象；验证（validating）控制器则不行。</p>
<p>准入控制过程分为两个阶段。第一阶段，运行变更准入控制器。第二阶段，运行验证准入控制器。
再次提醒，某些控制器既是变更准入控制器又是验证准入控制器。</p>
<p>如果任何一个阶段的任何控制器拒绝了该请求，则整个请求将立即被拒绝，并向终端用户返回一个错误。</p>
<p>最后，除了对对象进行变更外，准入控制器还可以有其它作用：将相关资源作为请求处理的一部分进行变更。
增加使用配额就是一个典型的示例，说明了这样做的必要性。
此类用法都需要相应的回收或回调过程，因为任一准入控制器都无法确定某个请求能否通过所有其它准入控制器。</p>
<h2 id=为什么需要准入控制器>为什么需要准入控制器？</h2>
<p>Kubernetes 的许多高级功能都要求启用一个准入控制器，以便正确地支持该特性。
因此，没有正确配置准入控制器的 Kubernetes API 服务器是不完整的，它无法支持你期望的所有特性。</p>
<h2 id=如何启用一个准入控制器>如何启用一个准入控制器？</h2>
<p>Kubernetes API 服务器的 <code>enable-admission-plugins</code> 标志接受一个用于在集群修改对象之前
调用的（以逗号分隔的）准入控制插件顺序列表。</p>
<p>例如，下面的命令就启用了 <code>NamespaceLifecycle</code> 和 <code>LimitRanger</code> 准入控制插件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kube-apiserver --enable-admission-plugins<span style=color:#666>=</span>NamespaceLifecycle,LimitRanger ...
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>根据你 Kubernetes 集群的部署方式以及 API 服务器的启动方式的不同，你可能需要以不同的方式应用设置。
例如，如果将 API 服务器部署为 systemd 服务，你可能需要修改 systemd 单元文件；
如果以自托管方式部署 Kubernetes，你可能需要修改 API 服务器的清单文件。
</div>
<h2 id=怎么关闭准入控制器>怎么关闭准入控制器？</h2>
<p>Kubernetes API 服务器的 <code>disable-admission-plugins</code> 标志，会将传入的（以逗号分隔的）
准入控制插件列表禁用，即使是默认启用的插件也会被禁用。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kube-apiserver --disable-admission-plugins<span style=color:#666>=</span>PodNodeSelector,AlwaysDeny ...
</code></pre></div>
<h2 id=哪些插件是默认启用的>哪些插件是默认启用的？</h2>
<p>下面的命令可以查看哪些插件是默认启用的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kube-apiserver -h | grep enable-admission-plugins
</code></pre></div>
<p>在目前版本中，它们是：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, LimitRanger, MutatingAdmissionWebhook, NamespaceLifecycle, PersistentVolumeClaimResize, Priority, ResourceQuota, RuntimeClass, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook
</code></pre></div>
<h2 id=每个准入控制器的作用是什么>每个准入控制器的作用是什么？</h2>
<h3 id=alwaysadmit>AlwaysAdmit</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>
<p>该准入控制器会允许所有的 pod 接入集群。已废弃，因为它的行为根本就和没有准入控制器一样。</p>
<h3 id=alwaysdeny>AlwaysDeny</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>
<p>拒绝所有的请求。由于它没有实际意义，已废弃。</p>
<h3 id=alwayspullimages>AlwaysPullImages</h3>
<p>该准入控制器会修改每一个新创建的 Pod 的镜像拉取策略为 Always 。
这在多租户集群中是有用的，这样用户就可以放心，他们的私有镜像只能被那些有凭证的人使用。
如果没有这个准入控制器，一旦镜像被拉取到节点上，任何用户的 Pod 都可以通过已了解到的镜像
的名称（假设 Pod 被调度到正确的节点上）来使用它，而不需要对镜像进行任何授权检查。
当启用这个准入控制器时，总是在启动容器之前拉取镜像，这意味着需要有效的凭证。</p>
<h3 id=certificateapproval>CertificateApproval</h3>
<p>此准入控制器获取“审批” CertificateSigningRequest 资源的请求并执行额外的授权检查，
以确保审批请求的用户有权限审批 <code>spec.signerName</code> 请求 CertificateSigningRequest 资源的证书请求。</p>
<p>有关对证书签名请求资源执行不同操作所需权限的详细信息，
请参阅<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a></p>
<h3 id=certificatesigning>CertificateSigning</h3>
<p>此准入控制器获取 CertificateSigningRequest 资源的 <code>status.certificate</code> 字段更新请求并执行额外的授权检查，
以确保签发证书的用户有权限为 <code>spec.signerName</code> 请求 CertificateSigningRequest 资源的证书请求<code>签发</code>证书。</p>
<p>有关对证书签名请求资源执行不同操作所需权限的详细信息，
请参阅<a href=/zh/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a></p>
<h3 id=certificatesubjectrestrictions>CertificateSubjectRestrictions</h3>
<p>此准入控制器获取具有 <code>kubernetes.io/kube-apiserver-client</code> 的 <code>spec.signerName</code> 的
CertificateSigningRequest 资源创建请求，
它拒绝任何包含了 <code>system:masters</code> 一个“组”（或者“组织”）的请求。</p>
<h3 id=defaultingressclass>DefaultIngressClass</h3>
<p>该准入控制器监测没有请求任何特定 Ingress 类的 <code>Ingress</code> 对象的创建，并自动向其添加默认 Ingress 类。
这样，没有任何特殊 Ingress 类需求的用户根本不需要关心它们，它们将获得默认 Ingress 类。</p>
<p>当未配置默认 Ingress 类时，此准入控制器不执行任何操作。如果将多个 Ingress 类标记为默认 Ingress 类，
它将拒绝任何创建 <code>Ingress</code> 的操作，并显示错误。
要修复此错误，管理员必须重新检查其 <code>IngressClass</code> 对象，并仅将其中一个标记为默认（通过注解
"ingressclass.kubernetes.io/is-default-class"）。
此准入控制器会忽略所有 <code>Ingress</code> 更新操作，仅响应创建操作。</p>
<p>关于 Ingress 类以及如何将 Ingress 类标记为默认的更多信息，请参见
<a href=/zh/docs/concepts/services-networking/ingress/>ingress</a>。</p>
<h3 id=defaultstorageclass>DefaultStorageClass</h3>
<p>该准入控制器监测没有请求任何特定存储类的 <code>PersistentVolumeClaim</code> 对象的创建，
并自动向其添加默认存储类。
这样，没有任何特殊存储类需求的用户根本不需要关心它们，它们将获得默认存储类。</p>
<p>当未配置默认存储类时，此准入控制器不执行任何操作。如果将多个存储类标记为默认存储类，
它将拒绝任何创建 <code>PersistentVolumeClaim</code> 的操作，并显示错误。
要修复此错误，管理员必须重新访问其 <code>StorageClass</code> 对象，并仅将其中一个标记为默认。
此准入控制器会忽略所有 <code>PersistentVolumeClaim</code> 更新操作，仅响应创建操作。</p>
<p>关于持久化卷和存储类，以及如何将存储类标记为默认，请参见
<a href=/zh/docs/concepts/storage/persistent-volumes/>持久化卷</a>。</p>
<h3 id=defaulttolerationseconds>DefaultTolerationSeconds</h3>
<p>该准入控制器基于 k8s-apiserver 输入参数 <code>default-not-ready-toleration-seconds</code> 和
<code>default-unreachable-toleration-seconds</code> 为 Pod 设置默认的容忍度，以容忍 <code>notready:NoExecute</code> 和
<code>unreachable:NoExecute</code> 污点。
（如果 Pod 尚未容忍 <code>node.kubernetes.io/not-ready：NoExecute</code> 和
<code>node.kubernetes.io/unreachable：NoExecute</code> 污点的话）
<code>default-not-ready-toleration-seconds</code> 和 <code>default-unreachable-toleration-seconds</code> 的默认值是 5 分钟。</p>
<h3 id=denyescalatingexec>DenyEscalatingExec</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>
<p>该准入控制器将拒绝在由于拥有升级特权，而具备访问宿主机能力的 Pod 中执行 exec 和
attach 命令。这包括在特权模式运行的 Pod，可以访问主机 IPC 名字空间的 Pod，
和访问主机 PID 名字空间的 Pod 。</p>
<p>DenyExecOnPrivileged 准入插件已被废弃。</p>
<p>建议使用基于策略的准入插件（例如 <a href=#podsecuritypolicy>PodSecurityPolicy</a> 和自定义准入插件），
该插件可以针对特定用户或名字空间，还可以防止创建权限过高的 Pod。</p>
<h3 id=denyexeconprivileged>DenyExecOnPrivileged</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>
<p>如果一个 pod 拥有一个特权容器，该准入控制器将拦截所有在该 pod 中执行 exec 命令的请求。</p>
<p>此功能已合并至 <a href=#denyescalatingexec>DenyEscalatingExec</a>。
而 DenyExecOnPrivileged 准入插件已被废弃。</p>
<p>建议使用基于策略的准入插件（例如 <a href=#podsecuritypolicy>PodSecurityPolicy</a> 和自定义准入插件），
该插件可以针对特定用户或名字空间，还可以防止创建权限过高的 Pod。</p>
<h3 id=denyserviceexternalips>DenyServiceExternalIPs</h3>
<p>该准入控制器拒绝 <code>Service</code> 字段 <code>externalIPs</code> 的所有新规使用。 此功能非常强大（允许网络流量拦截），
并且无法很好地受策略控制。 启用后，群集用户将无法创建使用 <code>externalIPs</code> 的新服务，也无法在现有
<code>Service</code> 对象上向 <code>externalIPs</code> 添加新值。 <code>externalIPs</code> 的现有使用不受影响，用户可以从现有
<code>Service</code> 对象上的 <code>externalIPs</code> 中删除值。</p>
<p>大多数用户根本不需要此功能，集群管理员应考虑将其禁用。
确实需要使用此功能的集群应考虑使用一些自定义策略来管理其的使用。</p>
<h3 id=eventratelimit>EventRateLimit</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [alpha]</code>
</div>
<p>该准入控制器缓解了事件请求淹没 API 服务器的问题。集群管理员可以通过以下方式指定事件速率限制：</p>
<ul>
<li>启用 <code>EventRateLimit</code> 准入控制器；</li>
<li>从文件中引用 <code>EventRateLimit</code> 配置文件，并提供给 API 服务器命令的
<code>--admission-control-config-file</code> 标志：</li>
</ul>
<ul class="nav nav-tabs" id=eventratelimit-example role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#eventratelimit-example-0 role=tab aria-controls=eventratelimit-example-0 aria-selected=true>apiserver.config.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#eventratelimit-example-1 role=tab aria-controls=eventratelimit-example-1>apiserver.k8s.io/v1alpha1</a></li></ul>
<div class=tab-content id=eventratelimit-example><div id=eventratelimit-example-0 class="tab-pane show active" role=tabpanel aria-labelledby=eventratelimit-example-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>EventRateLimit<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>eventconfig.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=eventratelimit-example-1 class=tab-pane role=tabpanel aria-labelledby=eventratelimit-example-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># Deprecated in v1.17 in favor of apiserver.config.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>EventRateLimit<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>eventconfig.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<p>可以在配置中指定四种类型的限制：</p>
<ul>
<li><code>Server</code>: API 服务器收到的所有事件请求共享一个桶。</li>
<li><code>Namespace</code>: 每个名字空间都有一个专用的桶。</li>
<li><code>User</code>: 给每个用户都分配一个桶。</li>
<li><code>SourceAndObject</code>: 根据事件的源和涉及对象的每种组合分配桶。</li>
</ul>
<p>下面是一个配置示例 <code>eventconfig.yaml</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>eventratelimit.admission.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Configuration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qps</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>burst</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cacheSize</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qps</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>burst</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></code></pre></div>
<p>详情请参见
<a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/admission_control_event_rate_limit.md>事件速率限制提案</a>。</p>
<h3 id=extendedresourcetoleration>ExtendedResourceToleration</h3>
<p>该插件有助于创建可扩展资源的专用节点。
如果运营商想创建可扩展资源的专用节点（如 GPU、FPGA 等），
那他们应该以扩展资源名称作为键名，
<a href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/>为节点设置污点</a>。
如果启用了该准入控制器，会将此类污点的容忍自动添加到请求扩展资源的 Pod 中，
用户不必再手动添加这些容忍。</p>
<h3 id=imagepolicywebhook>ImagePolicyWebhook</h3>
<p>ImagePolicyWebhook 准入控制器允许使用一个后端的 webhook 做出准入决策。</p>
<h4 id=配置文件格式>配置文件格式</h4>
<p>ImagePolicyWebhook 使用配置文件来为后端行为设置配置选项。该文件可以是 JSON 或 YAML，
并具有以下格式:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>imagePolicy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span>/path/to/kubeconfig/for/backend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 以秒计的时长，控制批准请求的缓存时间</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 以秒计的时长，控制批准请求的缓存时间</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>denyTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 以毫秒计的时长，控制重试间隔</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>retryBackoff</span>:<span style=color:#bbb> </span><span style=color:#666>500</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 确定 Webhook 后端失效时的行为</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultAllow</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div>
<p>从文件中引用 ImagePolicyWebhook 的配置文件，并将其提供给 API 服务器命令标志
<code>--admission-control-config-file</code>：</p>
<ul class="nav nav-tabs" id=imagepolicywebhook-example1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#imagepolicywebhook-example1-0 role=tab aria-controls=imagepolicywebhook-example1-0 aria-selected=true>apiserver.config.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#imagepolicywebhook-example1-1 role=tab aria-controls=imagepolicywebhook-example1-1>apiserver.k8s.io/v1alpha1</a></li></ul>
<div class=tab-content id=imagepolicywebhook-example1><div id=imagepolicywebhook-example1-0 class="tab-pane show active" role=tabpanel aria-labelledby=imagepolicywebhook-example1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ImagePolicyWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>imagepolicyconfig.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=imagepolicywebhook-example1-1 class=tab-pane role=tabpanel aria-labelledby=imagepolicywebhook-example1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.17 中已废弃以鼓励使用 apiserver.config.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ImagePolicyWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>imagepolicyconfig.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<p>或者，你也可以直接将配置嵌入到文件中：</p>
<ul class="nav nav-tabs" id=imagepolicywebhook-example2 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#imagepolicywebhook-example2-0 role=tab aria-controls=imagepolicywebhook-example2-0 aria-selected=true>apiserver.config.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#imagepolicywebhook-example2-1 role=tab aria-controls=imagepolicywebhook-example2-1>apiserver.k8s.io/v1alpha1</a></li></ul>
<div class=tab-content id=imagepolicywebhook-example2><div id=imagepolicywebhook-example2-0 class="tab-pane show active" role=tabpanel aria-labelledby=imagepolicywebhook-example2-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ImagePolicyWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePolicy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span>&lt;kubeconfig 文件路径&gt;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>allowTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>denyTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>retryBackoff</span>:<span style=color:#bbb> </span><span style=color:#666>500</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultAllow</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=imagepolicywebhook-example2-1 class=tab-pane role=tabpanel aria-labelledby=imagepolicywebhook-example2-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.17 中已废弃以鼓励使用 apiserver.config.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ImagePolicyWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePolicy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span>&lt;kubeconfig 文件路径&gt;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>allowTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>denyTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>retryBackoff</span>:<span style=color:#bbb> </span><span style=color:#666>500</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultAllow</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<p>ImagePolicyWebhook 的配置文件必须引用
<a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig</a>
格式的文件；该文件设置了到后端的连接参数。
要求后端使用 TLS 进行通信。</p>
<p>kubeconfig 文件的 cluster 字段需要指向远端服务，user 字段需要包含已返回的授权者。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># clusters 指的是远程服务。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-remote-imagepolicy-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/path/to/ca.pem   <span style=color:#bbb> </span><span style=color:#080;font-style:italic># CA 用于验证远程服务</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://images.example.com/policy<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 要查询的远程服务的 URL。必须是 &#39;https&#39; 。</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># users 指的是 API 服务器的 Webhook 配置。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/path/to/cert.pem<span style=color:#bbb> </span><span style=color:#080;font-style:italic># webhook 准入控制器使用的证书</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/path/to/key.pem         <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 证书匹配的密钥</span><span style=color:#bbb>
</span></code></pre></div>
<p>关于 HTTP 配置的更多信息，请参阅
<a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig</a>
文档。</p>
<h4 id=请求载荷>请求载荷</h4>
<p>当面对一个准入决策时，API 服务器发送一个描述操作的 JSON 序列化的
<code>imagepolicy.k8s.io/v1alpha1</code> <code>ImageReview</code> 对象。
该对象包含描述被审核容器的字段，以及所有匹配 <code>*.image-policy.k8s.io/*</code> 的
Pod 注解。</p>
<p>注意，Webhook API 对象与其他 Kubernetes API 对象一样受制于相同的版本控制兼容性规则。
实现者应该知道对 alpha 对象的更宽松的兼容性，并检查请求的 "apiVersion" 字段，
以确保正确的反序列化。
此外，API 服务器必须启用 <code>imagepolicy.k8s.io/v1alpha1</code> API 扩展组
（<code>--runtime-config=imagepolicy.k8s.io/v1alpha1=true</code>）。</p>
<p>请求载荷示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;ImageReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>:{
    <span style=color:green;font-weight:700>&#34;containers&#34;</span>:[
      {
        <span style=color:green;font-weight:700>&#34;image&#34;</span>:<span style=color:#b44>&#34;myrepo/myimage:v1&#34;</span>
      },
      {
        <span style=color:green;font-weight:700>&#34;image&#34;</span>:<span style=color:#b44>&#34;myrepo/myimage@sha256:beb6bd6a68f114c1dc2ea4b28db81bdf91de202a9014972bec5e4d9171d90ed&#34;</span>
      }
    ],
    <span style=color:green;font-weight:700>&#34;annotations&#34;</span>:{
      <span style=color:green;font-weight:700>&#34;mycluster.image-policy.k8s.io/ticket-1234&#34;</span>: <span style=color:#b44>&#34;break-glass&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;mynamespace&#34;</span>
  }
}
</code></pre></div>
<p>远程服务将填充请求的 <code>ImageReviewStatus</code> 字段，并返回允许或不允许访问的响应。
响应体的 "spec" 字段会被忽略，并且可以省略。一个允许访问应答会返回：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ImageReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
  }
}
</code></pre></div>
<p>若不允许访问，服务将返回：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ImageReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>,
    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;image currently blacklisted&#34;</span>
  }
}
</code></pre></div>
<p>更多的文档，请参阅 <code>imagepolicy.v1alpha1</code> API 对象和
<code>plugin/pkg/admission/imagepolicy/admission.go</code>。</p>
<h4 id=使用注解进行扩展>使用注解进行扩展</h4>
<p>一个 Pod 中匹配 <code>*.image-policy.k8s.io/*</code> 的注解都会被发送给 Webhook。
这样做使得了解后端镜像策略的用户可以向它发送额外的信息，并为不同的后端实现
接收不同的信息。</p>
<p>你可以在这里输入的信息有：</p>
<ul>
<li>在紧急情况下，请求 "break glass" 覆盖一个策略。</li>
<li>从一个记录了 break-glass 的请求的 ticket 系统得到的一个 ticket 号码。</li>
<li>向策略服务器提供一个提示，用于提供镜像的 imageID，以方便它进行查找。</li>
</ul>
<p>在任何情况下，注解都是由用户提供的，并不会被 Kubernetes 以任何方式进行验证。
在将来，如果一个注解确定将被广泛使用，它可能会被提升为 ImageReviewSpec 的一个命名字段。</p>
<h3 id=limitpodhardantiaffinitytopology>LimitPodHardAntiAffinityTopology</h3>
<p>该准入控制器拒绝（定义了 <code>AntiAffinity</code> 拓扑键的）任何 Pod
（<code>requiredDuringSchedulingRequiredDuringExecution</code> 中的
<code>kubernetes.io/hostname</code> 除外）。</p>
<h3 id=limitranger>LimitRanger</h3>
<p>该准入控制器会观察传入的请求，并确保它不会违反 <code>Namespace</code> 中 <code>LimitRange</code>
对象枚举的任何约束。
如果你在 Kubernetes 部署中使用了 <code>LimitRange</code> 对象，则必须使用此准入控制器来
执行这些约束。
LimitRanger 还可以用于将默认资源请求应用到没有指定任何内容的 Pod；
当前，默认的 LimitRanger 对 <code>default</code> 名字空间中的所有 Pod 都应用了
0.1 CPU 的需求。</p>
<p>请查看
<a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md>limitRange 设计文档</a>
和 <a href=/zh/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>LimitRange 例子</a>
以了解更多细节。</p>
<h3 id=mutatingadmissionwebhook>MutatingAdmissionWebhook</h3>
<p>该准入控制器调用任何与请求匹配的变更 Webhook。匹配的 Webhook 将被串行调用。
每一个 Webhook 都可以根据需要修改对象。</p>
<p><code>MutatingAdmissionWebhook</code>，顾名思义，仅在变更阶段运行。</p>
<p>如果由此准入控制器调用的 Webhook 有副作用（如降低配额），
则它 <em>必须</em> 具有协调系统，因为不能保证后续的 Webhook 和验证准入控制器都会允许完成请求。</p>
<p>如果你禁用了 MutatingAdmissionWebhook，那么还必须使用 <code>--runtime-config</code> 标志禁止
<code>admissionregistration.k8s.io/v1</code> 组/版本中的 <code>MutatingWebhookConfiguration</code>
对象（版本 >=1.9 时，这两个对象都是默认启用的）。</p>
<h4 id=谨慎编写和安装变更-webhook>谨慎编写和安装变更 webhook</h4>
<ul>
<li>当用户尝试创建的对象与返回的对象不同时，用户可能会感到困惑。</li>
<li>当它们回读的对象与尝试创建的对象不同，内建的控制环可能会出问题。
<ul>
<li>与覆盖原始请求中设置的字段相比，使用原始请求未设置的字段会引起问题的可能性较小。
应尽量避免前面那种方式。</li>
</ul>
</li>
<li>内建资源和第三方资源的控制回路未来可能会受到破坏性的更改，使现在运行良好的 Webhook
无法再正常运行。即使完成了 Webhook API 安装，也不代表会为该 webhook 提供无限期的支持。</li>
</ul>
<h3 id=namespaceautoprovision>NamespaceAutoProvision</h3>
<p>该准入控制器会检查名字空间资源上的所有传入请求，并检查所引用的名字空间是否确实存在。
如果找不到，它将创建一个名字空间。
此准入控制器对于不想要求名字空间必须先创建后使用的集群部署中很有用。</p>
<h3 id=namespaceexists>NamespaceExists</h3>
<p>该准入控制器检查除 <code>Namespace</code> 以外的名字空间作用域资源上的所有请求。
如果请求引用的名字空间不存在，则拒绝该请求。</p>
<h3 id=namespacelifecycle>NamespaceLifecycle</h3>
<p>该准入控制器禁止在一个正在被终止的 <code>Namespace</code> 中创建新对象，并确保
使用不存在的 <code>Namespace</code> 的请求被拒绝。
该准入控制器还会禁止删除三个系统保留的名字空间，即 <code>default</code>、
<code>kube-system</code> 和 <code>kube-public</code>。</p>
<p>删除 <code>Namespace</code> 会触发删除该名字空间中所有对象（Pod、Service 等）的一系列操作。
为了确保这个过程的完整性，我们强烈建议启用这个准入控制器。</p>
<h3 id=noderestriction>NodeRestriction</h3>
<p>该准入控制器限制了 kubelet 可以修改的 <code>Node</code> 和 <code>Pod</code> 对象。
为了受到这个准入控制器的限制，kubelet 必须使用在 <code>system:nodes</code> 组中的凭证，
并使用 <code>system:node:&lt;nodeName></code> 形式的用户名。
这样，kubelet 只可修改自己的 <code>Node</code> API 对象，只能修改绑定到节点本身的 Pod 对象。</p>
<p>在 Kubernetes 1.11+ 的版本中，不允许 kubelet 从 <code>Node</code> API 对象中更新或删除污点。</p>
<p>在 Kubernetes 1.13+ 的版本中，<code>NodeRestriction</code> 准入插件可防止 kubelet 删除
<code>Node</code> API 对象，并对 <code>kubernetes.io/</code> 或 <code>k8s.io/</code> 前缀标签的 kubelet
强制进行如下修改：</p>
<ul>
<li><strong>防止</strong> kubelet 添加/删除/更新带有 <code>node-restriction.kubernetes.io/</code> 前缀的标签。
保留此前缀的标签，供管理员用来标记 Node 对象以隔离工作负载，并且不允许 kubelet
修改带有该前缀的标签。</li>
<li><strong>允许</strong> kubelet 添加/删除/更新这些和这些前缀的标签：
<ul>
<li><code>kubernetes.io/hostname</code></li>
<li><code>kubernetes.io/arch</code></li>
<li><code>kubernetes.io/os</code></li>
<li><code>beta.kubernetes.io/instance-type</code></li>
<li><code>node.kubernetes.io/instance-type</code></li>
<li><code>failure-domain.beta.kubernetes.io/region</code> （已弃用）</li>
<li><code>failure-domain.beta.kubernetes.io/zone</code> (已弃用）</li>
<li><code>topology.kubernetes.io/region</code></li>
<li><code>topology.kubernetes.io/zone</code></li>
<li><code>kubelet.kubernetes.io/</code>-prefixed labels</li>
<li><code>node.kubernetes.io/</code>-prefixed labels</li>
</ul>
</li>
</ul>
<p>kubelet 保留 <code>kubernetes.io</code> 或 <code>k8s.io</code> 前缀的所有标签，并且将来可能会被
<code>NodeRestriction</code> 准入插件允许或禁止。</p>
<p>将来的版本可能会增加其他限制，以确保 kubelet 具有正常运行所需的最小权限集。</p>
<h3 id=ownerreferencespermissionenforcement>OwnerReferencesPermissionEnforcement</h3>
<p>该准入控制器保护对 <code>metadata.ownerReferences</code> 对象的访问，以便只有对该对象具有
“删除” 权限的用户才能对其进行更改。
该准入控制器还保护对 <code>metadata.ownerReferences[x].blockOwnerDeletion</code> 对象的访问，
以便只有对所引用的 <strong>属主（owner）</strong> 的 <code>finalizers</code> 子资源具有 “更新”
权限的用户才能对其进行更改。</p>
<h3 id=persistentvolumeclaimresize>PersistentVolumeClaimResize</h3>
<p>该准入控制器检查传入的 <code>PersistentVolumeClaim</code> 调整大小请求，对其执行额外的验证操作。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>对调整卷大小的支持是一种 Alpha 特性。管理员必须将特性门控 <code>ExpandPersistentVolumes</code>
设置为 <code>true</code> 才能启用调整大小。
</div>
<p>启用 <code>ExpandPersistentVolumes</code> 特性门控之后，建议将 <code>PersistentVolumeClaimResize</code>
准入控制器也启用。除非 PVC 的 <code>StorageClass</code> 明确地将 <code>allowVolumeExpansion</code> 设置为
<code>true</code> 来显式启用调整大小。否则，默认情况下该准入控制器会阻止所有对 PVC 大小的调整。</p>
<p>例如：由以下 <code>StorageClass</code> 创建的所有 <code>PersistentVolumeClaim</code> 都支持卷容量扩充：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gluster-vol-default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://192.168.10.100:8080&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div>
<p>关于持久化卷申领的更多信息，请参见
<a href=/zh/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaims</a>。</p>
<h3 id=persistentvolumelabel>PersistentVolumeLabel</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [deprecated]</code>
</div>
<p>该准入控制器会自动将区（region）或区域（zone）标签附加到由云提供商（如 GCE、AWS）
定义的 PersistentVolume。这有助于确保 Pod 和 PersistentVolume 位于相同的区或区域。
如果准入控制器不支持为 PersistentVolumes 自动添加标签，那你可能需要手动添加标签，
以防止 Pod 挂载其他区域的卷。
PersistentVolumeLabel 已被废弃，标记持久卷已由
<a href=/zh/docs/tasks/administer-cluster/running-cloud-controller/>云管理控制器</a>接管。
从 1.11 开始，默认情况下禁用此准入控制器。</p>
<h3 id=podnodeselector>PodNodeSelector</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.5 [alpha]</code>
</div>
<p>该准入控制器通过读取名字空间注解和全局配置，来为名字空间中可以使用的节点选择器
设置默认值并实施限制。</p>
<h4 id=配置文件格式-1>配置文件格式</h4>
<p><code>PodNodeSelector</code> 使用配置文件来设置后端行为的选项。
请注意，配置文件格式将在将来某个版本中改为版本化文件。
该文件可以是 JSON 或 YAML，格式如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>podNodeSelectorPluginConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>clusterDefaultNodeSelector</span>:<span style=color:#bbb> </span>name-of-node-selector<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>namespace1</span>:<span style=color:#bbb> </span>name-of-node-selector<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>namespace2</span>:<span style=color:#bbb> </span>name-of-node-selector<span style=color:#bbb>
</span></code></pre></div>
<p>基于提供给 API 服务器命令行标志 <code>--admission-control-config-file</code> 的文件名，
从文件中引用 <code>PodNodeSelector</code> 配置文件：</p>
<ul class="nav nav-tabs" id=podnodeselector-example1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#podnodeselector-example1-0 role=tab aria-controls=podnodeselector-example1-0 aria-selected=true>apiserver.config.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#podnodeselector-example1-1 role=tab aria-controls=podnodeselector-example1-1>apiserver.k8s.io/v1alpha1</a></li></ul>
<div class=tab-content id=podnodeselector-example1><div id=podnodeselector-example1-0 class="tab-pane show active" role=tabpanel aria-labelledby=podnodeselector-example1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodNodeSelector<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>podnodeselector.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=podnodeselector-example1-1 class=tab-pane role=tabpanel aria-labelledby=podnodeselector-example1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 在 v1.17 中废弃，以鼓励使用 apiserver.config.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodNodeSelector<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>podnodeselector.yaml<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<h4 id=配置注解格式>配置注解格式</h4>
<p><code>PodNodeSelector</code> 使用键为 <code>scheduler.alpha.kubernetes.io/node-selector</code> 的注解
为名字空间设置节点选择算符。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scheduler.alpha.kubernetes.io/node-selector</span>:<span style=color:#bbb> </span>name-of-node-selector<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>namespace3<span style=color:#bbb>
</span></code></pre></div>
<h4 id=内部行为>内部行为</h4>
<p>该准入控制器行为如下：</p>
<ol>
<li>如果 <code>Namespace</code> 的注解带有键 <code>scheduler.alpha.kubernetes.io/node-selector</code>，
则将其值用作节点选择算符。</li>
<li>如果名字空间缺少此类注解，则使用 <code>PodNodeSelector</code> 插件配置文件中定义的
<code>clusterDefaultNodeSelector</code> 作为节点选择算符。</li>
<li>评估 Pod 节点选择算符和名字空间节点选择算符是否存在冲突。存在冲突将导致拒绝。</li>
<li>评估 Pod 节点选择算符和特定于名字空间的被允许的选择算符所定义的插件配置文件是否存在冲突。
存在冲突将导致拒绝。</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>PodNodeSelector 允许 Pod 强制在特定标签的节点上运行。
另请参阅 PodTolerationRestriction 准入插件，该插件可防止 Pod 在特定污点的节点上运行。
</div>
<h3 id=podsecuritypolicy>PodSecurityPolicy</h3>
<p>此准入控制器负责在创建和修改 Pod 时根据请求的安全上下文和可用的 Pod
安全策略确定是否可以执行请求。</p>
<p>查看 <a href=/zh/docs/concepts/policy/pod-security-policy/>Pod 安全策略文档</a>
了解更多细节。</p>
<h3 id=podtolerationrestriction>PodTolerationRestriction</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.7 [alpha]</code>
</div>
<p>准入控制器 PodTolerationRestriction 检查 Pod 的容忍度与其名字空间的容忍度之间
是否存在冲突。如果存在冲突，则拒绝 Pod 请求。
然后，它将名字空间的容忍度合并到 Pod 的容忍度中，之后根据名字空间的容忍度
白名单检查所得到的容忍度结果。如果检查成功，则将接受 Pod 请求，否则拒绝该请求。</p>
<p>如果 Pod 的名字空间没有任何关联的默认容忍度或容忍度白名单，则使用集群级别的
默认容忍度或容忍度白名单（如果有的话）。</p>
<p>名字空间的容忍度通过注解健 <code>scheduler.alpha.kubernetes.io/defaultTolerations</code>
来设置。可接受的容忍度可以通过 <code>scheduler.alpha.kubernetes.io/tolerationsWhitelist</code>
注解键来添加。</p>
<p>名字空间注解的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>apps-that-need-nodes-exclusively<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scheduler.alpha.kubernetes.io/defaultTolerations</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;[{&#34;operator&#34;: &#34;Exists&#34;, &#34;effect&#34;: &#34;NoSchedule&#34;, &#34;key&#34;: &#34;dedicated-node&#34;}]&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scheduler.alpha.kubernetes.io/tolerationsWhitelist</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;[{&#34;operator&#34;: &#34;Exists&#34;, &#34;effect&#34;: &#34;NoSchedule&#34;, &#34;key&#34;: &#34;dedicated-node&#34;}]&#39;</span><span style=color:#bbb>
</span></code></pre></div>
<h3 id=priority>优先级</h3>
<p>优先级准入控制器使用 <code>priorityClassName</code> 字段并用整型值填充优先级。
如果找不到优先级，则拒绝 Pod。</p>
<h3 id=resourcequota>ResourceQuota</h3>
<p>该准入控制器会监测传入的请求，并确保它不违反任何一个 <code>Namespace</code> 中的 <code>ResourceQuota</code>
对象中枚举出来的约束。
如果你在 Kubernetes 部署中使用了 <code>ResourceQuota</code>，你必须使用这个准入控制器来强制
执行配额限制。</p>
<p>请查看
<a href=https://git.k8s.io/community/contributors/design-proposals/admission_control_resource_quota.md>resourceQuota 设计文档</a>和 <a href=/zh/docs/concepts/policy/resource-quotas/>Resource Quota 例子</a>
了解更多细节。</p>
<h3 id=runtimeclass>RuntimeClass</h3>
<p>+
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code>
</div>
</p>
<p>如果你开启 <code>PodOverhead</code>
<a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>,
并且通过 <a href=/zh/docs/concepts/scheduling-eviction/pod-overhead/>Pod 开销</a>
配置来定义一个 RuntimeClass，这个准入控制器会检查新的 Pod。
当启用的时候，这个准入控制器会拒绝任何 overhead 字段已经设置的 Pod。
对于配置了 RuntimeClass 并在其 <code>.spec</code> 中选定 RuntimeClass 的 Pod，
此准入控制器会根据相应 RuntimeClass 中定义的值为 Pod 设置 <code>.spec.overhead</code>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> Pod 的 <code>.spec.overhead</code> 字段和 RuntimeClass 的 <code>.overhead</code> 字段均为处于 beta 版本。
如果你未启用 <code>PodOverhead</code> 特性门控，则所有 Pod 均被视为未设置 <code>.spec.overhead</code>。
</div>
<p>详情请参见 <a href=/zh/docs/concepts/scheduling-eviction/pod-overhead/>Pod 开销</a>。</p>
<h3 id=securitycontextdeny>SecurityContextDeny</h3>
<p>该准入控制器将拒绝任何试图设置特定提升
<a href=/zh/docs/tasks/configure-pod-container/security-context/>SecurityContext</a>
字段的 Pod，正如任务
<a href=/zh/docs/tasks/configure-pod-container/security-context/>为 Pod 或 Container 配置安全上下文</a>
中所展示的那样。
如果集群没有使用 <a href=/zh/docs/concepts/policy/pod-security-policy/>Pod 安全策略</a>
来限制安全上下文所能获取的值集，那么应该启用这个功能。</p>
<h3 id=serviceaccount>ServiceAccount</h3>
<p>此准入控制器实现了
<a href=/zh/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>
的自动化。
如果你打算使用 Kubernetes 的 ServiceAccount 对象，我们强烈建议你使用这个准入控制器。</p>
<h3 id=storageobjectinuseprotection>StorageObjectInUseProtection</h3>
<p><code>StorageObjectInUseProtection</code> 插件将 <code>kubernetes.io/pvc-protection</code> 或
<code>kubernetes.io/pv-protection</code> finalizers 添加到新创建的持久化卷声明（PVC）
或持久化卷（PV）中。
如果用户尝试删除 PVC/PV，除非 PVC/PV 的保护控制器移除 finalizers，否则
PVC/PV 不会被删除。
有关更多详细信息，请参考
<a href=/zh/docs/concepts/storage/persistent-volumes/#storage-object-in-use-protection>保护使用中的存储对象</a>。</p>
<h3 id=taintnodesbycondition>TaintNodesByCondition</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>
<p>该准入控制器为新创建的节点添加 <code>NotReady</code> 和 <code>NoSchedule</code>
<a class=glossary-tooltip title="污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=污点>污点</a>。
这些污点能够避免一些竞态条件的发生，这类静态条件可能导致 Pod 在更新节点污点以准确
反映其所报告状况之前，就被调度到新节点上。</p>
<h3 id=validatingadmissionwebhook>ValidatingAdmissionWebhook</h3>
<p>该准入控制器调用与请求匹配的所有验证 Webhook。
匹配的 Webhook 将被并行调用。如果其中任何一个拒绝请求，则整个请求将失败。
该准入控制器仅在验证（Validating）阶段运行；与 <code>MutatingAdmissionWebhook</code> 准入控制器
所调用的 Webhook 相反，它调用的 Webhook 应该不会使对象出现变更。</p>
<p>如果以此方式调用的 Webhook 有其它作用（如，降低配额），则它必须具有协调机制。
这是因为无法保证后续的 Webhook 或其他有效的准入控制器都允许请求完成。</p>
<p>如果你禁用了 ValidatingAdmissionWebhook，还必须通过 <code>--runtime-config</code> 标志来禁用
<code>admissionregistration.k8s.io/v1</code> 组/版本中的 <code>ValidatingWebhookConfiguration</code>
对象（默认情况下在 1.9 版和更高版本中均处于启用状态）。</p>
<h2 id=有推荐的准入控制器吗>有推荐的准入控制器吗？</h2>
<p>有。推荐使用的准入控制器默认情况下都处于启用状态
（请查看<a href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/#options>这里</a>）。
因此，你无需显式指定它们。
你可以使用 <code>--enable-admission-plugins</code> 标志（ <strong>顺序不重要</strong> ）来启用默认设置以外的其他准入控制器。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p><code>--admission-control</code> 在 1.10 中已废弃，由 <code>--enable-admission-plugins</code> 取代。
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d04751f776f1faa6a82bbb7f0a200950>3.5 - 动态准入控制</h1>
<p>除了<a href=/zh/docs/reference/access-authn-authz/admission-controllers/>内置的 admission 插件</a>，
准入插件可以作为扩展独立开发，并以运行时所配置的 Webhook 的形式运行。
此页面描述了如何构建、配置、使用和监视准入 Webhook。</p>
<h2 id=什么是准入-webhook>什么是准入 Webhook？</h2>
<p>准入 Webhook 是一种用于接收准入请求并对其进行处理的 HTTP 回调机制。
可以定义两种类型的准入 webhook，即
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook>验证性质的准入 Webhook</a> 和
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook>修改性质的准入 Webhook</a>。
修改性质的准入 Webhook 会先被调用。它们可以更改发送到 API
服务器的对象以执行自定义的设置默认值操作。</p>
<p>在完成了所有对象修改并且 API 服务器也验证了所传入的对象之后，
验证性质的 Webhook 会被调用，并通过拒绝请求的方式来强制实施自定义的策略。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 如果准入 Webhook 需要保证它们所看到的是对象的最终状态以实施某种策略。
则应使用验证性质的准入 Webhook，因为对象被修改性质 Webhook 看到之后仍然可能被修改。
</div>
<h3 id=尝试准入-webhook>尝试准入 Webhook</h3>
<p>准入 Webhook 本质上是集群控制平面的一部分。你应该非常谨慎地编写和部署它们。
如果你打算编写或者部署生产级准入 webhook，请阅读<a href=/zh/docs/reference/access-authn-authz/extensible-admission-controllers/#write-an-admission-webhook-server>用户指南</a>以获取相关说明。
在下文中，我们将介绍如何快速试验准入 Webhook。</p>
<h3 id=prerequisites>先决条件</h3>
<ul>
<li>
<p>确保 Kubernetes 集群版本至少为 v1.16（以便使用 <code>admissionregistration.k8s.io/v1</code> API） 或者 v1.9 （以便使用 <code>admissionregistration.k8s.io/v1beta1</code> API）。</p>
</li>
<li>
<p>确保启用 MutatingAdmissionWebhook 和 ValidatingAdmissionWebhook 控制器。
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use>这里</a>
是一组推荐的 admission 控制器，通常可以启用。</p>
</li>
<li>
<p>确保启用了 <code>admissionregistration.k8s.io/v1beta1</code> API。</p>
</li>
</ul>
<h3 id=编写一个准入-webhook-服务器>编写一个准入 Webhook 服务器</h3>
<p>请参阅 Kubernetes e2e 测试中的
<a href=https://github.com/kubernetes/kubernetes/blob/release-1.21/test/images/agnhost/webhook/main.go>admission webhook 服务器</a>
的实现。webhook 处理由 apiserver 发送的 <code>AdmissionReview</code> 请求，并且将其决定
作为 <code>AdmissionReview</code> 对象以相同版本发送回去。</p>
<p>有关发送到 webhook 的数据的详细信息，请参阅 <a href=#request>webhook 请求</a>。</p>
<p>要获取来自 webhook 的预期数据，请参阅 <a href=#response>webhook 响应</a>。</p>
<p>示例准入 Webhook 服务器置 <code>ClientAuth</code> 字段为
<a href=https://github.com/kubernetes/kubernetes/blob/v1.22.0/test/images/agnhost/webhook/config.go#L38-L39>空</a>，
默认为 <code>NoClientCert</code> 。这意味着 webhook 服务器不会验证客户端的身份，认为其是 apiservers。
如果你需要双向 TLS 或其他方式来验证客户端，请参阅
如何<a href=#authenticate-apiservers>对 apiservers 进行身份认证</a>。</p>
<h3 id=部署准入-webhook-服务>部署准入 Webhook 服务</h3>
<p>e2e 测试中的 webhook 服务器通过
<a href=/docs/reference/generated/kubernetes-api/v1.22/#deployment-v1-apps>deployment API</a>
部署在 Kubernetes 集群中。该测试还将创建一个
<a href=/docs/reference/generated/kubernetes-api/v1.22/#service-v1-core>service</a>
作为 webhook 服务器的前端。参见
<a href=https://github.com/kubernetes/kubernetes/blob/v1.22.0/test/e2e/apimachinery/webhook.go#L748>相关代码</a>。</p>
<p>你也可以在集群外部署 webhook。这样做需要相应地更新你的 webhook 配置。</p>
<h3 id=即时配置准入-webhook>即时配置准入 Webhook</h3>
<p>你可以通过
<a href=/docs/reference/generated/kubernetes-api/v1.22/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io>ValidatingWebhookConfiguration</a>
或者
<a href=/docs/reference/generated/kubernetes-api/v1.22/#mutatingwebhookconfiguration-v1-admissionregistration-k8s-io>MutatingWebhookConfiguration</a> 动态配置哪些资源要被哪些准入 Webhook 处理。</p>
<p>以下是一个 <code>ValidatingWebhookConfiguration</code> 示例，mutating webhook 配置与此类似。有关每个配置字段的详细信息，请参阅 <a href=#webhook-configuration>webhook 配置</a> 部分。</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-example-1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-example-1-0 role=tab aria-controls=validatingwebhookconfiguration-example-1-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-example-1-1 role=tab aria-controls=validatingwebhookconfiguration-example-1-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-example-1><div id=validatingwebhookconfiguration-example-1-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-example-1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pod-policy.example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pod-policy.example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>   </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb>  </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>   </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb>       </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-namespace&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-service&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>admissionReviewVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sideEffects</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=validatingwebhookconfiguration-example-1-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-example-1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 1.16 中被淘汰，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pod-policy.example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pod-policy.example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>   </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb>  </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>   </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb>       </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-namespace&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-service&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>admissionReviewVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<p>scope 字段指定是仅集群范围的资源（Cluster）还是名字空间范围的资源资源（Namespaced）将与此规则匹配。<code>*</code> 表示没有范围限制。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 当使用 <code>clientConfig.service</code> 时，服务器证书必须对 <code>&lt;svc_name>.&lt;svc_namespace>.svc</code> 有效。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 对于使用 <code>admissionregistration.k8s.io/v1</code> 创建的 webhook 而言，其 webhook 调用的默认超时是 10 秒；
对于使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的 webhook 而言，其默认超时是 30 秒。
从 kubernetes 1.14 开始，可以设置超时。建议对 webhooks 设置较短的超时时间。
如果 webhook 调用超时，则根据 webhook 的失败策略处理请求。
</div>
<p>当 apiserver 收到与 <code>rules</code> 相匹配的请求时，apiserver 按照 <code>clientConfig</code> 中指定的方式向 webhook 发送一个 <code>admissionReview</code> 请求。</p>
<p>创建 webhook 配置后，系统将花费几秒钟使新配置生效。</p>
<h3 id=authenticate-apiservers>对 apiservers 进行身份认证</h3>
<p>如果你的 webhook 需要身份验证，则可以将 apiserver 配置为使用基本身份验证、持有者令牌或证书来向 webhook 提供身份证明。完成此配置需要三个步骤。</p>
<ul>
<li>
<p>启动 apiserver 时，通过 <code>--admission-control-config-file</code> 参数指定准入控制配置文件的位置。</p>
</li>
<li>
<p>在准入控制配置文件中，指定 MutatingAdmissionWebhook 控制器和 ValidatingAdmissionWebhook 控制器应该读取凭据的位置。
凭证存储在 kubeConfig 文件中（是​​的，与 kubectl 使用的模式相同），因此字段名称为 <code>kubeConfigFile</code>。
以下是一个准入控制配置文件示例：</p>
</li>
</ul>
<ul class="nav nav-tabs" id=admissionconfiguration-example1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#admissionconfiguration-example1-0 role=tab aria-controls=admissionconfiguration-example1-0 aria-selected=true>apiserver.config.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#admissionconfiguration-example1-1 role=tab aria-controls=admissionconfiguration-example1-1>apiserver.k8s.io/v1alpha1</a></li></ul>
<div class=tab-content id=admissionconfiguration-example1><div id=admissionconfiguration-example1-0 class="tab-pane show active" role=tabpanel aria-labelledby=admissionconfiguration-example1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ValidatingAdmissionWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>WebhookAdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MutatingAdmissionWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>WebhookAdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style=color:#bbb>
</span></code></pre></div></div>
<div id=admissionconfiguration-example1-1 class=tab-pane role=tabpanel aria-labelledby=admissionconfiguration-example1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ValidatingAdmissionWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1，kind = WebhookAdmissionConfiguration</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>WebhookAdmission<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MutatingAdmissionWebhook<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1，kind = WebhookAdmissionConfiguration</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>WebhookAdmission<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style=color:#bbb>
</span></code></pre></div></div></div>
<p>有关 <code>AdmissionConfiguration</code> 的更多信息，请参见
<a href=/docs/reference/config-api/apiserver-webhookadmission.v1/>AdmissionConfiguration (v1) reference</a>。
有关每个配置字段的详细信息，请参见 <a href=#webhook-%E9%85%8D%E7%BD%AE>webhook 配置</a>部分。</p>
<ul>
<li>
<p>在 kubeConfig 文件中，提供证书凭据：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 名称应设置为服务的 DNS 名称或配置了 Webhook 的 URL 的主机名（包括端口）。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 如果将非 443 端口用于服务，则在配置 1.16+ API 服务器时，该端口必须包含在名称中。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 对于配置在默认端口（443）上与服务对话的 Webhook，请指定服务的 DNS 名称：</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: webhook1.ns1.svc</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 对于配置在非默认端口（例如 8443）上与服务对话的 Webhook，请在 1.16+ 中指定服务的 DNS 名称和端口：</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: webhook1.ns1.svc:8443</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 并可以选择仅使用服务的 DNS 名称来创建第二节，以与 1.15 API 服务器版本兼容：</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: webhook1.ns1.svc</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 对于配置为使用 URL 的 webhook，请匹配在 webhook 的 URL 中指定的主机（和端口）。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 带有 `url: https://www.example.com` 的 webhook：</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: www.example.com</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 带有 `url: https://www.example.com:443` 的 webhook：</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: www.example.com:443</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 带有 `url: https://www.example.com:8443` 的 webhook：</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: www.example.com:8443</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;webhook1.ns1.svc&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-certificate-data</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;pem encoded certificate&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-key-data</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;pem encoded key&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># `name` 支持使用 * 通配符匹配前缀段。</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*.webhook-company.org&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;password&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;name&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># &#39;*&#39; 是默认匹配项。</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>token</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;token&gt;&#34;</span><span style=color:#bbb>
</span></code></pre></div></li>
</ul>
<p>当然，你需要设置 webhook 服务器来处理这些身份验证。</p>
<h3 id=request>请求</h3>
<p>Webhook 发送 POST 请求时，请设置 <code>Content-Type: application/json</code> 并对 <code>admission.k8s.io</code> API 组中的 <code>AdmissionReview</code> 对象进行序列化，将所得到的 JSON 作为请求的主体。</p>
<p>Webhook 可以在配置中的 <code>admissionReviewVersions</code> 字段指定可接受的 <code>AdmissionReview</code> 对象版本：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-admissionreviewversions role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-admissionreviewversions-0 role=tab aria-controls=validatingwebhookconfiguration-admissionreviewversions-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-admissionreviewversions-1 role=tab aria-controls=validatingwebhookconfiguration-admissionreviewversions-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-admissionreviewversions><div id=validatingwebhookconfiguration-admissionreviewversions-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-admissionreviewversions-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>admissionReviewVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>创建 <code>admissionregistration.k8s.io/v1</code> webhook 配置时，<code>admissionReviewVersions</code> 是必填字段。
Webhook 必须支持至少一个当前和以前的 apiserver 都可以解析的 <code>AdmissionReview</code> 版本。</p>
</div>
<div id=validatingwebhookconfiguration-admissionreviewversions-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-admissionreviewversions-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被淘汰，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>admissionReviewVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>如果未指定 <code>admissionReviewVersions</code>，则创建 <code>admissionregistration.k8s.io/v1beta1</code> Webhook 配置时的默认值为 <code>v1beta1</code>。</p>
</div></div>
<p>API 服务器将发送的是 <code>admissionReviewVersions</code> 列表中所支持的第一个 <code>AdmissionReview</code> 版本。如果 API 服务器不支持列表中的任何版本，则不允许创建配置。</p>
<p>如果 API 服务器遇到以前创建的 Webhook 配置，并且不支持该 API 服务器知道如何发送的任何 <code>AdmissionReview</code> 版本，则调用 Webhook 的尝试将失败，并依据<a href=#failure-policy>失败策略</a>进行处理。</p>
<p>此示例显示了 <code>AdmissionReview</code> 对象中包含的数据，该数据用于请求更新 <code>apps/v1</code> <code>Deployment</code> 的 <code>scale</code> 子资源：</p>
<ul class="nav nav-tabs" id=admissionreview-request role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#admissionreview-request-0 role=tab aria-controls=admissionreview-request-0 aria-selected=true>admission.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#admissionreview-request-1 role=tab aria-controls=admissionreview-request-1>admission.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=admissionreview-request><div id=admissionreview-request-0 class="tab-pane show active" role=tabpanel aria-labelledby=admissionreview-request-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>{<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;AdmissionReview&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;request&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 唯一标识此准入回调的随机 uid</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;uid&#34;: </span><span style=color:#b44>&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 传入完全正确的 group/version/kind 对象</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;autoscaling&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 修改 resource 的完全正确的的 group/version/kind</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;resource&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;apps&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;resource&#34;</span>:<span style=color:#b44>&#34;deployments&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># subResource（如果请求是针对 subResource 的）</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;subResource&#34;: </span><span style=color:#b44>&#34;scale&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 在对 API 服务器的原始请求中，传入对象的标准 group/version/kind</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅当 webhook 指定 `matchPolicy: Equivalent` 且将对 API 服务器的原始请求转换为 webhook 注册的版本时，这才与 `kind` 不同。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;requestKind&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;autoscaling&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 在对 API 服务器的原始请求中正在修改的资源的标准 group/version/kind</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为 webhook 注册的版本时，这才与 `resource` 不同。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;requestResource&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;apps&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;resource&#34;</span>:<span style=color:#b44>&#34;deployments&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># subResource（如果请求是针对 subResource 的）</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为该 webhook 注册的版本时，这才与 `subResource` 不同。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;requestSubResource&#34;: </span><span style=color:#b44>&#34;scale&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 被修改资源的名称</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;name&#34;: </span><span style=color:#b44>&#34;my-deployment&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 如果资源是属于名字空间（或者是名字空间对象），则这是被修改的资源的名字空间</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;namespace&#34;: </span><span style=color:#b44>&#34;my-namespace&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 操作可以是 CREATE、UPDATE、DELETE 或 CONNECT</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;operation&#34;: </span><span style=color:#b44>&#34;UPDATE&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;userInfo&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的用户名</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;username&#34;: </span><span style=color:#b44>&#34;admin&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的 UID</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;uid&#34;: </span><span style=color:#b44>&#34;014fbff9a07c&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的组成员身份</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;groups&#34;: </span>[<span style=color:#b44>&#34;system:authenticated&#34;</span>,<span style=color:#b44>&#34;my-admin-group&#34;</span>],<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的用户相关的任意附加信息</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 该字段由 API 服务器身份验证层填充，并且如果 webhook 执行了任何 SubjectAccessReview 检查，则应将其包括在内。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;extra&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#b44>&#34;some-key&#34;</span>:[<span style=color:#b44>&#34;some-value1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;some-value2&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>},<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># object 是被接纳的新对象。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 对于 DELETE 操作，它为 null。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;object&#34;: </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;autoscaling/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>,...},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># oldObject 是现有对象。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 对于 CREATE 和 CONNECT 操作，它为 null。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;oldObject&#34;: </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;autoscaling/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>,...},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># options 包含要接受的操作的选项，例如 meta.k8s.io/v CreateOptions、UpdateOptions 或 DeleteOptions。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 对于 CONNECT 操作，它为 null。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;options&#34;: </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;meta.k8s.io/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;UpdateOptions&#34;</span>,...},<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># dryRun 表示 API 请求正在以 `dryrun` 模式运行，并且将不会保留。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 带有副作用的 Webhook 应该避免在 dryRun 为 true 时激活这些副作用。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 有关更多详细信息，请参见 http://k8s.io/docs/reference/using-api/api-concepts/#make-a-dry-run-request</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;dryRun&#34;: </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div></div>
<div id=admissionreview-request-1 class=tab-pane role=tabpanel aria-labelledby=admissionreview-request-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>{<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admission.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;admission.k8s.io/v1beta1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;AdmissionReview&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;request&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 唯一标识此准入回调的随机 uid</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;uid&#34;: </span><span style=color:#b44>&#34;705ab4f5-6393-11e8-b7cc-42010a800002&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 传入完全正确的 group/version/kind 对象</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;autoscaling&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 修改 resource 的完全正确的的 group/version/kind</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;resource&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;apps&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;resource&#34;</span>:<span style=color:#b44>&#34;deployments&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># subResource（如果请求是针对 subResource 的）</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;subResource&#34;: </span><span style=color:#b44>&#34;scale&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 在对 API 服务器的原始请求中，传入对象的标准 group/version/kind。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅当 Webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为该 Webhook 注册的版本时，这与 `kind` 不同。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅由 v1.15+ API 服务器发送。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;requestKind&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;autoscaling&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 在对 API 服务器的原始请求中正在修改的资源的标准 group/version/kind</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为 webhook 注册的版本时，这才与 `resource` 不同。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅由 v1.15+ API 服务器发送。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;requestResource&#34;: </span>{<span style=color:#b44>&#34;group&#34;</span>:<span style=color:#b44>&#34;apps&#34;</span>,<span style=color:#b44>&#34;version&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;resource&#34;</span>:<span style=color:#b44>&#34;deployments&#34;</span>},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># subResource（如果请求是针对 subResource 的）</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为该 webhook 注册的版本时，这才与 `subResource` 不同。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅由 v1.15+ API 服务器发送。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;requestSubResource&#34;: </span><span style=color:#b44>&#34;scale&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 被修改资源的名称</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;name&#34;: </span><span style=color:#b44>&#34;my-deployment&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 如果资源是属于名字空间（或者是名字空间对象），则这是被修改的资源的名字空间</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;namespace&#34;: </span><span style=color:#b44>&#34;my-namespace&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 操作可以是 CREATE、UPDATE、DELETE 或 CONNECT</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;operation&#34;: </span><span style=color:#b44>&#34;UPDATE&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;userInfo&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的用户名</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;username&#34;: </span><span style=color:#b44>&#34;admin&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的 UID</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;uid&#34;: </span><span style=color:#b44>&#34;014fbff9a07c&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的组成员身份</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;groups&#34;: </span>[<span style=color:#b44>&#34;system:authenticated&#34;</span>,<span style=color:#b44>&#34;my-admin-group&#34;</span>],<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的用户相关的任意附加信息</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 该字段由 API 服务器身份验证层填充，并且如果 webhook 执行了任何 SubjectAccessReview 检查，则应将其包括在内。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;extra&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#b44>&#34;some-key&#34;</span>:[<span style=color:#b44>&#34;some-value1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;some-value2&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>},<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># object 是被接纳的新对象。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 对于 DELETE 操作，它为 null。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;object&#34;: </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;autoscaling/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>,...},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># oldObject 是现有对象。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 对于 CREATE 和 CONNECT 操作（对于 v1.15.0 之前版本的 API 服务器中的 DELETE 操作），它为 null。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;oldObject&#34;: </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;autoscaling/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Scale&#34;</span>,...},<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># options 包含要接受的操作的选项，例如 meta.k8s.io/v CreateOptions、UpdateOptions 或 DeleteOptions。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 对于 CONNECT 操作，它为 null。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 仅由 v1.15+ API 服务器发送。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;options&#34;: </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;meta.k8s.io/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;UpdateOptions&#34;</span>,...},<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># dryRun 表示 API 请求正在以 `dryrun` 模式运行，并且将不会保留。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 带有副作用的 Webhook 应该避免在 dryRun 为 true 时激活这些副作用。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 有关更多详细信息，请参见 http://k8s.io/docs/reference/using-api/api-concepts/#make-a-dry-run-request</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;dryRun&#34;: </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>}<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div></div></div>
<h3 id=response>响应</h3>
<p>Webhook 使用 HTTP 200 状态码、<code>Content-Type: application/json</code> 和一个包含 <code>AdmissionReview</code> 对象的 JSON 序列化格式来发送响应。该 <code>AdmissionReview</code> 对象与发送的版本相同，且其中包含的 <code>response</code> 字段已被有效填充。</p>
<p><code>response</code> 至少必须包含以下字段：</p>
<ul>
<li><code>uid</code>，从发送到 webhook 的 <code>request.uid</code> 中复制而来</li>
<li><code>allowed</code>，设置为 <code>true</code> 或 <code>false</code></li>
</ul>
<p>Webhook 允许请求的最简单响应示例：</p>
<ul class="nav nav-tabs" id=admissionreview-response-allow role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#admissionreview-response-allow-0 role=tab aria-controls=admissionreview-response-allow-0 aria-selected=true>admission.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#admissionreview-response-allow-1 role=tab aria-controls=admissionreview-response-allow-1>admission.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=admissionreview-response-allow><div id=admissionreview-response-allow-0 class="tab-pane show active" role=tabpanel aria-labelledby=admissionreview-response-allow-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
  }
}
</code></pre></div></div>
<div id=admissionreview-response-allow-1 class=tab-pane role=tabpanel aria-labelledby=admissionreview-response-allow-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
  }
}
</code></pre></div></div></div>
<p>Webhook 禁止请求的最简单响应示例：</p>
<ul class="nav nav-tabs" id=admissionreview-response-forbid-minimal role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#admissionreview-response-forbid-minimal-0 role=tab aria-controls=admissionreview-response-forbid-minimal-0 aria-selected=true>admission.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#admissionreview-response-forbid-minimal-1 role=tab aria-controls=admissionreview-response-forbid-minimal-1>admission.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=admissionreview-response-forbid-minimal><div id=admissionreview-response-forbid-minimal-0 class="tab-pane show active" role=tabpanel aria-labelledby=admissionreview-response-forbid-minimal-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>
  }
}
</code></pre></div></div>
<div id=admissionreview-response-forbid-minimal-1 class=tab-pane role=tabpanel aria-labelledby=admissionreview-response-forbid-minimal-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>
  }
}
</code></pre></div></div></div>
<p>当拒绝请求时，Webhook 可以使用 <code>status</code> 字段自定义 http 响应码和返回给用户的消息。
有关状态类型的详细信息，请参见
<a href=/docs/reference/generated/kubernetes-api/v1.22/#status-v1-meta>API 文档</a>。
禁止请求的响应示例，它定制了向用户显示的 HTTP 状态码和消息：</p>
<ul class="nav nav-tabs" id=admissionreview-response-forbid-details role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#admissionreview-response-forbid-details-0 role=tab aria-controls=admissionreview-response-forbid-details-0 aria-selected=true>admission.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#admissionreview-response-forbid-details-1 role=tab aria-controls=admissionreview-response-forbid-details-1>admission.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=admissionreview-response-forbid-details><div id=admissionreview-response-forbid-details-0 class="tab-pane show active" role=tabpanel aria-labelledby=admissionreview-response-forbid-details-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>,
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;code&#34;</span>: <span style=color:#666>403</span>,
      <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;You cannot do this because it is Tuesday and your name starts with A&#34;</span>
    }
  }
}
</code></pre></div></div>
<div id=admissionreview-response-forbid-details-1 class=tab-pane role=tabpanel aria-labelledby=admissionreview-response-forbid-details-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>,
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;code&#34;</span>: <span style=color:#666>403</span>,
      <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;You cannot do this because it is Tuesday and your name starts with A&#34;</span>
    }
  }
}
</code></pre></div></div></div>
<p>当允许请求时，mutating准入 Webhook 也可以选择修改传入的对象。
这是通过在响应中使用 <code>patch</code> 和 <code>patchType</code> 字段来完成的。
当前唯一支持的 <code>patchType</code> 是 <code>JSONPatch</code>。
有关更多详细信息，请参见 <a href=https://jsonpatch.com/>JSON patch</a>。
对于 <code>patchType: JSONPatch</code>，<code>patch</code> 字段包含一个以 base64 编码的 JSON patch 操作数组。</p>
<p>例如，设置 <code>spec.replicas</code> 的单个补丁操作将是
<code>[{"op": "add", "path": "/spec/replicas", "value": 3}]</code>。</p>
<p>如果以 Base64 形式编码，结果将是
<code>W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=</code></p>
<p>因此，添加该标签的 webhook 响应为：
<ul class="nav nav-tabs" id=admissionreview-response-modify role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#admissionreview-response-modify-0 role=tab aria-controls=admissionreview-response-modify-0 aria-selected=true>admission.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#admissionreview-response-modify-1 role=tab aria-controls=admissionreview-response-modify-1>admission.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=admissionreview-response-modify><div id=admissionreview-response-modify-0 class="tab-pane show active" role=tabpanel aria-labelledby=admissionreview-response-modify-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
    <span style=color:green;font-weight:700>&#34;patchType&#34;</span>: <span style=color:#b44>&#34;JSONPatch&#34;</span>,
    <span style=color:green;font-weight:700>&#34;patch&#34;</span>: <span style=color:#b44>&#34;W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=&#34;</span>
  }
}
</code></pre></div></div>
<div id=admissionreview-response-modify-1 class=tab-pane role=tabpanel aria-labelledby=admissionreview-response-modify-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
    <span style=color:green;font-weight:700>&#34;patchType&#34;</span>: <span style=color:#b44>&#34;JSONPatch&#34;</span>,
    <span style=color:green;font-weight:700>&#34;patch&#34;</span>: <span style=color:#b44>&#34;W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=&#34;</span>
  }
}
</code></pre></div></div></div>
</p>
<h2 id=webhook-configuration>Webhook 配置</h2>
<p>要注册准入 Webhook，请创建 <code>MutatingWebhookConfiguration</code> 或
<code>ValidatingWebhookConfiguration</code> API 对象。</p>
<p>每种配置可以包含一个或多个 Webhook。如果在单个配置中指定了多个
Webhook，则应为每个 webhook 赋予一个唯一的名称。
这在 <code>admissionregistration.k8s.io/v1</code> 中是必需的，但是在使用
<code>admissionregistration.k8s.io/v1beta1</code> 时强烈建议使用，
以使生成的审核日志和指标更易于与活动配置相匹配。</p>
<p>每个 Webhook 定义以下内容。</p>
<h3 id=matching-requests-rules>匹配请求-规则</h3>
<p>每个 webhook 必须指定用于确定是否应将对 apiserver 的请求发送到 webhook 的规则列表。
每个规则都指定一个或多个 operations、apiGroups、apiVersions 和 resources 以及资源的 scope：</p>
<ul>
<li><code>operations</code> 列出一个或多个要匹配的操作。
可以是 <code>CREATE</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>CONNECT</code> 或 <code>*</code> 以匹配所有内容。</li>
<li><code>apiGroups</code> 列出了一个或多个要匹配的 API 组。<code>""</code> 是核心 API 组。<code>"*"</code> 匹配所有 API 组。</li>
<li><code>apiVersions</code> 列出了一个或多个要匹配的 API 版本。<code>"*"</code> 匹配所有 API 版本。</li>
<li><code>resources</code> 列出了一个或多个要匹配的资源。
<ul>
<li><code>"*"</code> 匹配所有资源，但不包括子资源。</li>
<li><code>"*/*"</code> 匹配所有资源，包括子资源。</li>
<li><code>"pods/*"</code> 匹配 pod 的所有子资源。</li>
<li><code>"*/status"</code> 匹配所有 status 子资源。</li>
</ul>
</li>
<li><code>scope</code> 指定要匹配的范围。有效值为 <code>"Cluster"</code>、<code>"Namespaced"</code> 和 <code>"*"</code>。
子资源匹配其父资源的范围。在 Kubernetes v1.14+ 版本中才被支持。
默认值为 <code>"*"</code>，对应 1.14 版本之前的行为。
<ul>
<li><code>"Cluster"</code> 表示只有集群作用域的资源才能匹配此规则（API 对象 Namespace 是集群作用域的）。</li>
<li><code>"Namespaced"</code> 意味着仅具有名字空间的资源才符合此规则。</li>
<li><code>"*"</code> 表示没有范围限制。</li>
</ul>
</li>
</ul>
<p>如果传入请求与任何 Webhook 规则的指定操作、组、版本、资源和范围匹配，则该请求将发送到 Webhook。</p>
<p>以下是可用于指定应拦截哪些资源的规则的其他示例。</p>
<p>匹配针对 <code>apps/v1</code> 和 <code>apps/v1beta1</code> 组中 <code>deployments</code> 和 <code>replicasets</code>
资源的 <code>CREATE</code> 或 <code>UPDATE</code> 请求：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-rules-1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-rules-1-0 role=tab aria-controls=validatingwebhookconfiguration-rules-1-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-rules-1-1 role=tab aria-controls=validatingwebhookconfiguration-rules-1-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-rules-1><div id=validatingwebhookconfiguration-rules-1-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-rules-1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;UPDATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;replicasets&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=validatingwebhookconfiguration-rules-1-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-rules-1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;UPDATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;replicasets&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>匹配所有 API 组和版本中的所有资源（但不包括子资源）的创建请求：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-rules-2 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-rules-2-0 role=tab aria-controls=validatingwebhookconfiguration-rules-2-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-rules-2-1 role=tab aria-controls=validatingwebhookconfiguration-rules-2-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-rules-2><div id=validatingwebhookconfiguration-rules-2-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-rules-2-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=validatingwebhookconfiguration-rules-2-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-rules-2-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>匹配所有 API 组和版本中所有 <code>status</code> 子资源的更新请求：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-rules-2 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-rules-2-0 role=tab aria-controls=validatingwebhookconfiguration-rules-2-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-rules-2-1 role=tab aria-controls=validatingwebhookconfiguration-rules-2-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-rules-2><div id=validatingwebhookconfiguration-rules-2-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-rules-2-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;UPDATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*/status&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=validatingwebhookconfiguration-rules-2-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-rules-2-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;UPDATE&#34;</span>]<span style=color:#bbb> 
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*/status&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<h3 id=matching-requests-objectselector>匹配请求：objectSelector</h3>
<p>在版本 v1.15+ 中, 通过指定 <code>objectSelector</code>，Webhook 能够根据
可能发送的对象的标签来限制哪些请求被拦截。
如果指定，则将对 <code>objectSelector</code> 和可能发送到 Webhook 的 object 和 oldObject
进行评估。如果两个对象之一与选择器匹配，则认为该请求已匹配。</p>
<p>空对象（对于创建操作而言为 oldObject，对于删除操作而言为 newObject），
或不能带标签的对象（例如 <code>DeploymentRollback</code> 或 <code>PodProxyOptions</code> 对象）
被认为不匹配。</p>
<p>仅当选择使用 webhook 时才使用对象选择器，因为最终用户可以通过设置标签来
跳过准入 Webhook。</p>
<p>这个例子展示了一个 mutating webhook，它将匹配带有标签 <code>foo:bar</code> 的任何资源的
<code>CREATE</code> 的操作：</p>
<ul class="nav nav-tabs" id=objectselector-example role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#objectselector-example-0 role=tab aria-controls=objectselector-example-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#objectselector-example-1 role=tab aria-controls=objectselector-example-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=objectselector-example><div id=objectselector-example-0 class="tab-pane show active" role=tabpanel aria-labelledby=objectselector-example-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>objectSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=objectselector-example-1 class=tab-pane role=tabpanel aria-labelledby=objectselector-example-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>objectSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>有关标签选择器的更多示例，请参见<a href=/zh/docs/concepts/overview/working-with-objects/labels>标签</a>。</p>
<h3 id=matching-requests-namespaceselector>匹配请求：namespaceSelector</h3>
<p>通过指定 <code>namespaceSelector</code>，Webhook 可以根据具有名字空间的资源所处的
名字空间的标签来选择拦截哪些资源的操作。</p>
<p><code>namespaceSelector</code> 根据名字空间的标签是否匹配选择器，决定是否针对具名字空间的资源
（或 Namespace 对象）的请求运行 webhook。
如果对象是除 Namespace 以外的集群范围的资源，则 <code>namespaceSelector</code> 标签无效。</p>
<p>本例给出的修改性质的 Webhook 将匹配到对名字空间中具名字空间的资源的 <code>CREATE</code> 请求，
前提是这些资源不含值为 "0" 或 "1" 的 "runlevel" 标签：</p>
<ul class="nav nav-tabs" id=mutatingwebhookconfiguration-namespaceselector-1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#mutatingwebhookconfiguration-namespaceselector-1-0 role=tab aria-controls=mutatingwebhookconfiguration-namespaceselector-1-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#mutatingwebhookconfiguration-namespaceselector-1-1 role=tab aria-controls=mutatingwebhookconfiguration-namespaceselector-1-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=mutatingwebhookconfiguration-namespaceselector-1><div id=mutatingwebhookconfiguration-namespaceselector-1-0 class="tab-pane show active" role=tabpanel aria-labelledby=mutatingwebhookconfiguration-namespaceselector-1-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>runlevel<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>NotIn<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;0&#34;</span>,<span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=mutatingwebhookconfiguration-namespaceselector-1-1 class=tab-pane role=tabpanel aria-labelledby=mutatingwebhookconfiguration-namespaceselector-1-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>runlevel<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>NotIn<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;0&#34;</span>,<span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>此示例显示了一个验证性质的 Webhook，它将匹配到对某名字空间中的任何具名字空间的资源的
<code>CREATE</code> 请求，前提是该名字空间具有值为 "prod" 或 "staging" 的 "environment" 标签：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-namespaceselector-2 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-namespaceselector-2-0 role=tab aria-controls=validatingwebhookconfiguration-namespaceselector-2-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-namespaceselector-2-1 role=tab aria-controls=validatingwebhookconfiguration-namespaceselector-2-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-namespaceselector-2><div id=validatingwebhookconfiguration-namespaceselector-2-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-namespaceselector-2-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>environment<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;prod&#34;</span>,<span style=color:#b44>&#34;staging&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=validatingwebhookconfiguration-namespaceselector-2-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-namespaceselector-2-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>environment<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;prod&#34;</span>,<span style=color:#b44>&#34;staging&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>有关标签选择器的更多示例，请参见
<a href=/zh/docs/concepts/overview/working-with-objects/labels>标签</a>。</p>
<h3 id=matching-requests-matchpolicy>匹配请求：matchPolicy</h3>
<p>API 服务器可以通过多个 API 组或版本来提供对象。
例如，Kubernetes API 服务器允许通过 <code>extensions/v1beta1</code>、<code>apps/v1beta1</code>、
<code>apps/v1beta2</code> 和 <code>apps/v1</code> API 创建和修改 <code>Deployment</code> 对象。</p>
<p>例如，如果一个 webhook 仅为某些 API 组/版本指定了规则（例如
<code>apiGroups:["apps"], apiVersions:["v1","v1beta1"]</code>），而修改资源的请求
是通过另一个 API 组/版本（例如 <code>extensions/v1beta1</code>）发出的，
该请求将不会被发送到 Webhook。</p>
<p>在 v1.15+ 中，<code>matchPolicy</code> 允许 webhook 定义如何使用其 <code>rules</code> 匹配传入的请求。
允许的值为 <code>Exact</code> 或 <code>Equivalent</code>。</p>
<ul>
<li><code>Exact</code> 表示仅当请求与指定规则完全匹配时才应拦截该请求。</li>
<li><code>Equivalent</code> 表示如果某个请求意在修改 <code>rules</code> 中列出的资源，
即使该请求是通过其他 API 组或版本发起，也应拦截该请求。</li>
</ul>
<p>在上面给出的示例中，仅为 <code>apps/v1</code> 注册的 webhook 可以使用 <code>matchPolicy</code>：</p>
<ul>
<li><code>matchPolicy: Exact</code> 表示不会将 <code>extensions/v1beta1</code> 请求发送到 Webhook</li>
<li><code>matchPolicy:Equivalent</code> 表示将 <code>extensions/v1beta1</code> 请求发送到 webhook
（将对象转换为 webhook 指定的版本：<code>apps/v1</code>）</li>
</ul>
<p>建议指定 <code>Equivalent</code>，确保升级后启用 API 服务器中资源的新版本时，
Webhook 继续拦截他们期望的资源。</p>
<p>当 API 服务器停止提供某资源时，该资源不再被视为等同于该资源的其他仍在提供服务的版本。
例如，<code>extensions/v1beta1</code> 中的 Deployment 已被废弃，计划在 v1.16 中默认停止使用。
在这种情况下，带有 <code>apiGroups:["extensions"], apiVersions:["v1beta1"], resources: ["deployments"]</code>
规则的 Webhook 将不再拦截通过 <code>apps/v1</code> API 来创建 Deployment 的请求。
["deployments"] 规则将不再拦截通过 <code>apps/v1</code> API 创建的部署。</p>
<p>此示例显示了一个验证性质的 Webhook，该 Webhook 拦截对 Deployment 的修改（无论 API 组或版本是什么），
始终会发送一个 <code>apps/v1</code> 版本的 Deployment 对象：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-matchpolicy role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-matchpolicy-0 role=tab aria-controls=validatingwebhookconfiguration-matchpolicy-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-matchpolicy-1 role=tab aria-controls=validatingwebhookconfiguration-matchpolicy-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-matchpolicy><div id=validatingwebhookconfiguration-matchpolicy-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-matchpolicy-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchPolicy</span>:<span style=color:#bbb> </span>Equivalent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>,<span style=color:#b44>&#34;UPDATE&#34;</span>,<span style=color:#b44>&#34;DELETE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>admissionregistration.k8s.io/v1</code> 创建的 admission webhhok 默认为 <code>Equivalent</code>。</p>
</div>
<div id=validatingwebhookconfiguration-matchpolicy-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-matchpolicy-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchPolicy</span>:<span style=color:#bbb> </span>Equivalent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>,<span style=color:#b44>&#34;UPDATE&#34;</span>,<span style=color:#b44>&#34;DELETE&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的准入 Webhook 默认为 <code>Exact</code>。</p>
</div></div>
<h3 id=调用-webhook>调用 Webhook</h3>
<p>API 服务器确定请求应发送到 webhook 后，它需要知道如何调用 webhook。
此信息在 webhook 配置的 <code>clientConfig</code> 节中指定。</p>
<p>Webhook 可以通过 URL 或服务引用来调用，并且可以选择包含自定义 CA 包，以用于验证 TLS 连接。</p>
<h4 id=url>URL</h4>
<p><code>url</code> 以标准 URL 形式给出 webhook 的位置（<code>scheme://host:port/path</code>）。</p>
<p><code>host</code> 不应引用集群中运行的服务；通过指定 <code>service</code> 字段来使用服务引用。
主机可以通过某些 apiserver 中的外部 DNS 进行解析。
（例如，<code>kube-apiserver</code> 无法解析集群内 DNS，因为这将违反分层规则）。<code>host</code> 也可以是 IP 地址。</p>
<p>请注意，将 <code>localhost</code> 或 <code>127.0.0.1</code> 用作 <code>host</code> 是有风险的，
除非你非常小心地在所有运行 apiserver 的、可能需要对此 webhook
进行调用的主机上运行。这样的安装方式可能不具有可移植性，即很难在新集群中启用。</p>
<p>scheme 必须为 "https"；URL 必须以 "https://" 开头。</p>
<p>使用用户或基本身份验证（例如："user:password@"）是不允许的。
使用片段（"#..."）和查询参数（"?..."）也是不允许的。</p>
<p>这是配置为调用 URL 的修改性质的 Webhook 的示例
（并且期望使用系统信任根证书来验证 TLS 证书，因此不指定 caBundle）：</p>
<ul class="nav nav-tabs" id=mutatingwebhookconfiguration-url role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#mutatingwebhookconfiguration-url-0 role=tab aria-controls=mutatingwebhookconfiguration-url-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#mutatingwebhookconfiguration-url-1 role=tab aria-controls=mutatingwebhookconfiguration-url-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=mutatingwebhookconfiguration-url><div id=mutatingwebhookconfiguration-url-0 class="tab-pane show active" role=tabpanel aria-labelledby=mutatingwebhookconfiguration-url-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>url</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my-webhook.example.com:9443/my-webhook-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=mutatingwebhookconfiguration-url-1 class=tab-pane role=tabpanel aria-labelledby=mutatingwebhookconfiguration-url-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>url</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my-webhook.example.com:9443/my-webhook-path&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<h4 id=service-reference>服务引用 </h4>
<p><code>clientConfig</code> 内部的 Service 是对该 Webhook 服务的引用。
如果 Webhook 在集群中运行，则应使用 <code>service</code> 而不是 <code>url</code>。
服务的 <code>namespace</code> 和 <code>name</code> 是必需的。
<code>port</code> 是可选的，默认值为 443。<code>path</code> 是可选的，默认为 "/"。</p>
<p>这是一个 mutating Webhook 的示例，该 mutating Webhook 配置为在子路径 "/my-path" 端口
"1234" 上调用服务，并使用自定义 CA 包针对 ServerName
<code>my-service-name.my-service-namespace.svc</code> 验证 TLS 连接：</p>
<ul class="nav nav-tabs" id=mutatingwebhookconfiguration-service role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#mutatingwebhookconfiguration-service-0 role=tab aria-controls=mutatingwebhookconfiguration-service-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#mutatingwebhookconfiguration-service-1 role=tab aria-controls=mutatingwebhookconfiguration-service-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=mutatingwebhookconfiguration-service><div id=mutatingwebhookconfiguration-service-0 class="tab-pane show active" role=tabpanel aria-labelledby=mutatingwebhookconfiguration-service-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>my-service-namespace<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service-name<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/my-path<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=mutatingwebhookconfiguration-service-1 class=tab-pane role=tabpanel aria-labelledby=mutatingwebhookconfiguration-service-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Ci0tLS0tQk...&lt;base64-encoded PEM bundle containing the CA that signed the webhook&#39;s serving certificate&gt;...tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>my-service-namespace<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service-name<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/my-path<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<h3 id=side-effects>副作用</h3>
<p>Webhook 通常仅对发送给他们的 <code>AdmissionReview</code> 内容进行操作。
但是，某些 Webhook 在处理 admission 请求时会进行带外更改。</p>
<p>进行带外更改的（产生“副作用”的） Webhook 必须具有协调机制（如控制器），
该机制定期确定事物的实际状态，并调整由准入 Webhook 修改的带外数据以反映现实情况。
这是因为对准入 Webhook 的调用不能保证所准入的对象将原样保留，或根本不保留。
以后，webhook 可以修改对象的内容，在写入存储时可能会发生冲突，或者
服务器可以在持久保存对象之前关闭电源。</p>
<p>此外，处理 <code>dryRun: true</code> admission 请求时，具有副作用的 Webhook 必须避免产生副作用。
一个 Webhook 必须明确指出在使用 <code>dryRun</code> 运行时不会有副作用，
否则 <code>dry-run</code> 请求将不会发送到该 Webhook，而 API 请求将会失败。</p>
<p>Webhook 使用 webhook 配置中的 <code>sideEffects</code> 字段显示它们是否有副作用：</p>
<ul>
<li><code>Unknown</code>：有关调用 Webhook 的副作用的信息是不可知的。
如果带有 <code>dryRun：true</code> 的请求将触发对该 Webhook 的调用，则该请求将失败，并且不会调用该 Webhook。</li>
<li><code>None</code>：调用 webhook 没有副作用。</li>
<li><code>Some</code>：调用 webhook 可能会有副作用。
如果请求具有 <code>dry-run</code> 属性将触发对此 Webhook 的调用，
则该请求将会失败，并且不会调用该 Webhook。</li>
<li><code>NoneOnDryRun</code>：调用 webhook 可能会有副作用，但是如果将带有 <code>dryRun: true</code>
属性的请求发送到 webhook，则 webhook 将抑制副作用（该 webhook 可识别 <code>dryRun</code>）。</li>
</ul>
<p>允许值：</p>
<ul>
<li>在 <code>admissionregistration.k8s.io/v1beta1</code> 中，<code>sideEffects</code> 可以设置为
<code>Unknown</code>、<code>None</code>、<code>Some</code> 或者 <code>NoneOnDryRun</code>，并且默认值为 <code>Unknown</code>。</li>
<li>在 <code>admissionregistration.k8s.io/v1</code> 中, <code>sideEffects</code> 必须设置为
<code>None</code> 或者 <code>NoneOnDryRun</code>。</li>
</ul>
<p>这是一个 validating webhook 的示例，表明它对 <code>dryRun: true</code> 请求没有副作用：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-sideeffects role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-sideeffects-0 role=tab aria-controls=validatingwebhookconfiguration-sideeffects-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-sideeffects-1 role=tab aria-controls=validatingwebhookconfiguration-sideeffects-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-sideeffects><div id=validatingwebhookconfiguration-sideeffects-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-sideeffects-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sideEffects</span>:<span style=color:#bbb> </span>NoneOnDryRun<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=validatingwebhookconfiguration-sideeffects-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-sideeffects-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sideEffects</span>:<span style=color:#bbb> </span>NoneOnDryRun<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<h3 id=timeouts>超时</h3>
<p>由于 Webhook 会增加 API 请求的延迟，因此应尽快完成自身的操作。
<code>timeoutSeconds</code> 用来配置在将调用视为失败之前，允许 API 服务器等待 Webhook 响应的时间长度。</p>
<p>如果超时在 Webhook 响应之前被触发，则基于<a href=#failure-policy>失败策略</a>，将忽略
Webhook 调用或拒绝 API 调用。</p>
<p>超时值必须设置在 1 到 30 秒之间。</p>
<p>这是一个自定义超时设置为 2 秒的 validating Webhook 的示例：</p>
<ul class="nav nav-tabs" id=validatingwebhookconfiguration-timeoutseconds role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#validatingwebhookconfiguration-timeoutseconds-0 role=tab aria-controls=validatingwebhookconfiguration-timeoutseconds-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#validatingwebhookconfiguration-timeoutseconds-1 role=tab aria-controls=validatingwebhookconfiguration-timeoutseconds-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=validatingwebhookconfiguration-timeoutseconds><div id=validatingwebhookconfiguration-timeoutseconds-0 class="tab-pane show active" role=tabpanel aria-labelledby=validatingwebhookconfiguration-timeoutseconds-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>admissionregistration.k8s.io/v1</code> 创建的准入 Webhook 默认超时为 10 秒。</p>
</div>
<div id=validatingwebhookconfiguration-timeoutseconds-1 class=tab-pane role=tabpanel aria-labelledby=validatingwebhookconfiguration-timeoutseconds-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的准入 Webhook 默认超时为 30 秒。</p>
</div></div>
<h3 id=reinvocation-policy>再调用策略 </h3>
<p>修改性质的准入插件（包括 Webhook）的任何一种排序方式都不会适用于所有情况。
(参见 <a href=https://issue.k8s.io/64333>https://issue.k8s.io/64333</a> 示例)。
修改性质的 Webhook 可以向对象中添加新的子结构（例如向 <code>pod</code> 中添加 <code>container</code>），
已经运行的其他修改插件可能会对这些新结构有影响
（就像在所有容器上设置 <code>imagePullPolicy</code> 一样）。</p>
<p>在 v1.15+ 中，允许修改性质的准入插件感应到其他插件所做的更改，
如果修改性质的 Webhook 修改了一个对象，则会重新运行内置的修改性质的准入插件，
并且修改性质的 Webhook 可以指定 <code>reinvocationPolicy</code> 来控制是否也重新调用它们。</p>
<p>可以将 <code>reinvocationPolicy</code> 设置为 <code>Never</code> 或 <code>IfNeeded</code>。 默认为 <code>Never</code>。</p>
<ul>
<li><code>Never</code>: 在一次准入测试中，不得多次调用 Webhook。</li>
<li><code>IfNeeded</code>: 如果在最初的 Webhook 调用之后被其他对象的插件修改了被接纳的对象，
则可以作为准入测试的一部分再次调用该 webhook。</li>
</ul>
<p>要注意的重要因素有：</p>
<ul>
<li>不能保证附加调用的次数恰好是一。</li>
<li>如果其他调用导致对该对象的进一步修改，则不能保证再次调用 Webhook。</li>
<li>使用此选项的 Webhook 可能会重新排序，以最大程度地减少额外调用的次数。</li>
<li>要在确保所有修改都完成后验证对象，请改用验证性质的 Webhook
（推荐用于有副作用的 Webhook）。</li>
</ul>
<p>这是一个修改性质的 Webhook 的示例，该 Webhook 在以后的准入插件修改对象时被重新调用：</p>
<ul class="nav nav-tabs" id=mutatingwebhookconfiguration-reinvocationpolicy role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#mutatingwebhookconfiguration-reinvocationpolicy-0 role=tab aria-controls=mutatingwebhookconfiguration-reinvocationpolicy-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#mutatingwebhookconfiguration-reinvocationpolicy-1 role=tab aria-controls=mutatingwebhookconfiguration-reinvocationpolicy-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=mutatingwebhookconfiguration-reinvocationpolicy><div id=mutatingwebhookconfiguration-reinvocationpolicy-0 class="tab-pane show active" role=tabpanel aria-labelledby=mutatingwebhookconfiguration-reinvocationpolicy-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>reinvocationPolicy</span>:<span style=color:#bbb> </span>IfNeeded<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div>
<div id=mutatingwebhookconfiguration-reinvocationpolicy-1 class=tab-pane role=tabpanel aria-labelledby=mutatingwebhookconfiguration-reinvocationpolicy-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>reinvocationPolicy</span>:<span style=color:#bbb> </span>IfNeeded<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div></div></div>
<p>修改性质的 Webhook 必须具有<a href=#idempotence>幂等</a>性，并且能够成功处理
已被接纳并可能被修改的对象的修改性质的 Webhook。
对于所有修改性质的准入 Webhook 都是如此，因为它们可以在对象中进行的
任何更改可能已经存在于用户提供的对象中，但是对于选择重新调用的 webhook
来说是必不可少的。</p>
<h3 id=failure-policy>失败策略</h3>
<p><code>failurePolicy</code> 定义了如何处理准入 webhook 中无法识别的错误和超时错误。允许的值为 <code>Ignore</code> 或 <code>Fail</code>。</p>
<ul>
<li><code>Ignore</code> 表示调用 webhook 的错误将被忽略并且允许 API 请求继续。</li>
<li><code>Fail</code> 表示调用 webhook 的错误导致准入失败并且 API 请求被拒绝。</li>
</ul>
<p>这是一个修改性质的 webhook，配置为在调用准入 Webhook 遇到错误时拒绝 API 请求：</p>
<ul class="nav nav-tabs" id=mutatingwebhookconfiguration-failurepolicy role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#mutatingwebhookconfiguration-failurepolicy-0 role=tab aria-controls=mutatingwebhookconfiguration-failurepolicy-0 aria-selected=true>admissionregistration.k8s.io/v1</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#mutatingwebhookconfiguration-failurepolicy-1 role=tab aria-controls=mutatingwebhookconfiguration-failurepolicy-1>admissionregistration.k8s.io/v1beta1</a></li></ul>
<div class=tab-content id=mutatingwebhookconfiguration-failurepolicy><div id=mutatingwebhookconfiguration-failurepolicy-0 class="tab-pane show active" role=tabpanel aria-labelledby=mutatingwebhookconfiguration-failurepolicy-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failurePolicy</span>:<span style=color:#bbb> </span>Fail<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的准入 Webhook 将
<code>failurePolicy</code> 默认设置为 <code>Ignore</code>。</p>
</div>
<div id=mutatingwebhookconfiguration-failurepolicy-1 class=tab-pane role=tabpanel aria-labelledby=mutatingwebhookconfiguration-failurepolicy-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># v1.16 中被废弃，推荐使用 admissionregistration.k8s.io/v1</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failurePolicy</span>:<span style=color:#bbb> </span>Fail<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div>
<p>使用 <code>admissionregistration.k8s.io/v1beta1</code> 创建的准入 Webhook 将
<code>failurePolicy</code> 默认设置为 <code>Ignore</code>。</p>
</div></div>
<h2 id=monitoring-admission-webhooks>监控 Admission Webhook </h2>
<p>API 服务器提供了监视准入 Webhook 行为的方法。这些监视机制可帮助集群管理员
回答以下问题：</p>
<ol>
<li>哪个修改性质的 webhook 改变了 API 请求中的对象？</li>
<li>修改性质的 Webhook 对对象做了哪些更改？</li>
<li>哪些 webhook 经常拒绝 API 请求？是什么原因拒绝？</li>
</ol>
<h3 id=mutating-webhook-审计注解>Mutating Webhook 审计注解</h3>
<p>有时，了解 API 请求中的哪个修改性质的 Webhook 使对象改变以及该
Webhook 应用了哪些更改很有用。</p>
<p>在 v1.16+ 中，kube-apiserver 针对每个修改性质的 Webhook 调用执行
<a href=/zh/docs/tasks/debug-application-cluster/audit/>审计</a>操作。
每个调用都会生成一个审计注解，记述请求对象是否发生改变，
可选地还可以根据 webhook 的准入响应生成一个注解，记述所应用的修补。
针对给定请求的给定执行阶段，注解被添加到审计事件中，
然后根据特定策略进行预处理并写入后端。</p>
<p>事件的审计级别决定了要记录哪些注解：</p>
<p>在 <code>Metadata</code> 或更高审计级别上，将使用 JSON 负载记录带有键名
<code>mutation.webhook.admission.k8s.io/round_{round idx}_index_{order idx}</code> 的注解，
该注解表示针对给定请求调用了 Webhook，以及该 Webhook 是否更改了对象。</p>
<p>例如，对于正在被重新调用的某 Webhook，所记录的注解如下。
Webhook 在 mutating Webhook 链中排在第三个位置，并且在调用期间未改变请求对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 审计事件相关记录</span><span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;Event&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;audit.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;annotations&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;mutation.webhook.admission.k8s.io/round_1_index_2&#34;: &#34;{\&#34;configuration\&#34;:\&#34;my-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook.example.com\&#34;,\&#34;mutated\&#34;: </span><span style=color:#a2f;font-weight:700>false</span>}&#34;<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 其他注解</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 其他字段</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 反序列化的注解值</span><span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;configuration&#34;: </span><span style=color:#b44>&#34;my-mutating-webhook-configuration.example.com&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;webhook&#34;: </span><span style=color:#b44>&#34;my-webhook.example.com&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;mutated&#34;: </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div>
<p>对于在第一轮中调用的 Webhook，所记录的注解如下。
Webhook 在 mutating Webhook 链中排在第一位，并在调用期间改变了请求对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 审计事件相关记录</span><span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;Event&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;audit.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;annotations&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;mutation.webhook.admission.k8s.io/round_0_index_0&#34;: &#34;{\&#34;configuration\&#34;:\&#34;my-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook-always-mutate.example.com\&#34;,\&#34;mutated\&#34;: </span><span style=color:#a2f;font-weight:700>true</span>}&#34;<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 其他注解</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 其他字段</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 反序列化的注解值</span><span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;configuration&#34;: </span><span style=color:#b44>&#34;my-mutating-webhook-configuration.example.com&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;webhook&#34;: </span><span style=color:#b44>&#34;my-webhook-always-mutate.example.com&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;mutated&#34;: </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div>
<p>在 <code>Request</code> 或更高审计级别上，将使用 JSON 负载记录带有键名为
<code>patch.webhook.admission.k8s.io/round_{round idx}_index_{order idx}</code> 的注解，
该注解表明针对给定请求调用了 Webhook 以及应用于请求对象之上的修改。</p>
<p>例如，以下是针对正在被重新调用的某 Webhook 所记录的注解。
Webhook 在修改性质的 Webhook 链中排在第四，并在其响应中包含一个 JSON 补丁，
该补丁已被应用于请求对象。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 审计事件相关记录</span><span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;Event&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;audit.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;annotations&#34;: </span>{<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;patch.webhook.admission.k8s.io/round_1_index_3&#34;: </span><span style=color:#b44>&#34;{\&#34;configuration\&#34;:\&#34;my-other-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook-always-mutate.example.com\&#34;,\&#34;patch\&#34;:[{\&#34;op\&#34;:\&#34;add\&#34;,\&#34;path\&#34;:\&#34;/data/mutation-stage\&#34;,\&#34;value\&#34;:\&#34;yes\&#34;}],\&#34;patchType\&#34;:\&#34;JSONPatch\&#34;}&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 其他注解</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 其他字段</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 反序列化的注解值</span><span style=color:#bbb>
</span><span style=color:#bbb></span>{<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;configuration&#34;: </span><span style=color:#b44>&#34;my-other-mutating-webhook-configuration.example.com&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;webhook&#34;: </span><span style=color:#b44>&#34;my-webhook-always-mutate.example.com&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;patchType&#34;: </span><span style=color:#b44>&#34;JSONPatch&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;patch&#34;: </span>[<span style=color:#bbb>
</span><span style=color:#bbb>        </span>{<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;op&#34;: </span><span style=color:#b44>&#34;add&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;path&#34;: </span><span style=color:#b44>&#34;/data/mutation-stage&#34;</span>,<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;value&#34;: </span><span style=color:#b44>&#34;yes&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></code></pre></div>
<h3 id=准入-webhook-度量值>准入 Webhook 度量值</h3>
<p>Kube-apiserver 从 <code>/metrics</code> 端点公开 Prometheus 指标，这些指标可用于监控和诊断
apiserver 状态。以下指标记录了与准入 Webhook 相关的状态。</p>
<h4 id=apiserver-准入-webhook-拒绝次数>apiserver 准入 Webhook 拒绝次数</h4>
<p>有时，了解哪些准入 Webhook 经常拒绝 API 请求以及拒绝的原因是很有用的。</p>
<p>在 v1.16+ 中，kube-apiserver 提供了 Prometheus 计数器度量值，记录
准入 Webhook 的拒绝次数。
度量值的标签给出了 Webhook 拒绝该请求的原因：</p>
<ul>
<li><code>name</code>：拒绝请求 Webhook 的名称。</li>
<li><code>operation</code>：请求的操作类型可以是 <code>CREATE</code>、<code>UPDATE</code>、<code>DELETE</code> 和 <code>CONNECT</code> 其中之一。</li>
<li><code>type</code>：Admission webhook 类型，可以是 <code>admit</code> 和 <code>validating</code> 其中之一。</li>
<li><code>error_type</code>：标识在 webhook 调用期间是否发生了错误并且导致了拒绝。其值可以是以下之一：
<ul>
<li><code>calling_webhook_error</code>：发生了来自准入 Webhook 的无法识别的错误或超时错误，
并且 webhook 的 <a href=#failure-policy>失败策略</a> 设置为 <code>Fail</code>。</li>
<li><code>no_error</code>：未发生错误。Webhook 在准入响应中以 <code>allowed: false</code> 值拒绝了请求。
度量标签 <code>rejection_code</code> 记录了在准入响应中设置的 <code>.status.code</code>。</li>
<li><code>apiserver_internal_error</code>：apiserver 发生内部错误。</li>
</ul>
</li>
<li><code>rejection_code</code>：当 Webhook 拒绝请求时，在准入响应中设置的 HTTP 状态码。</li>
</ul>
<p>拒绝计数指标示例：</p>
<pre><code># HELP apiserver_admission_webhook_rejection_count [ALPHA] Admission webhook rejection count, identified by name and broken out for each admission type (validating or admit) and operation. Additional labels specify an error type (calling_webhook_error or apiserver_internal_error if an error occurred; no_error otherwise) and optionally a non-zero rejection code if the webhook rejects the request with an HTTP status code (honored by the apiserver when the code is greater or equal to 400). Codes greater than 600 are truncated to 600, to keep the metrics cardinality bounded.
# TYPE apiserver_admission_webhook_rejection_count counter
apiserver_admission_webhook_rejection_count{error_type=&quot;calling_webhook_error&quot;,name=&quot;always-timeout-webhook.example.com&quot;,operation=&quot;CREATE&quot;,rejection_code=&quot;0&quot;,type=&quot;validating&quot;} 1
apiserver_admission_webhook_rejection_count{error_type=&quot;calling_webhook_error&quot;,name=&quot;invalid-admission-response-webhook.example.com&quot;,operation=&quot;CREATE&quot;,rejection_code=&quot;0&quot;,type=&quot;validating&quot;} 1
apiserver_admission_webhook_rejection_count{error_type=&quot;no_error&quot;,name=&quot;deny-unwanted-configmap-data.example.com&quot;,operation=&quot;CREATE&quot;,rejection_code=&quot;400&quot;,type=&quot;validating&quot;} 13
</code></pre>
<h2 id=最佳实践和警告>最佳实践和警告</h2>
<h3 id=idempotence>幂等性 </h3>
<p>幂等的修改性质的准入 Webhook 能够成功处理已经被它接纳甚或修改的对象。
即使多次执行该准入测试，也不会产生与初次执行结果相异的结果。</p>
<h4 id=幂等-mutating-admission-webhook-的示例>幂等 mutating admission Webhook 的示例：</h4>
<ol>
<li>对于 <code>CREATE</code> Pod 请求，将 Pod 的字段 <code>.spec.securityContext.runAsNonRoot</code>
设置为 true，以实施安全最佳实践。</li>
<li>对于 <code>CREATE</code> Pod 请求，如果未设置容器的字段
<code>.spec.containers[].resources.limits</code>，设置默认资源限制值。</li>
<li>对于 <code>CREATE</code> pod 请求，如果 Pod 中不存在名为 <code>foo-sidecar</code> 的边车容器，
向 Pod 注入一个 <code>foo-sidecar</code> 容器。</li>
</ol>
<p>在上述情况下，可以安全地重新调用 Webhook，或接受已经设置了字段的对象。</p>
<h4 id=非幂等-mutating-admission-webhook-的示例>非幂等 mutating admission Webhook 的示例：</h4>
<ol>
<li>对于 <code>CREATE</code> pod 请求，注入名称为 <code>foo-sidecar</code> 并带有当前时间戳的
边车容器（例如 <code>foo-sidecar-19700101-000000</code>）。</li>
<li>对于 <code>CREATE/UPDATE</code> pod 请求，如果容器已设置标签 <code>"env"</code> 则拒绝，
否则将 <code>"env": "prod"</code> 标签添加到容器。</li>
<li>对于 <code>CREATE</code> pod 请求，盲目地添加一个名为 <code>foo-sidecar</code> 的边车容器，
而未查看 Pod 中是否已经有 <code>foo-sidecar</code> 容器。</li>
</ol>
<p>在上述第一种情况下，重新调用该 Webhook 可能导致同一个 Sidecar 容器
多次注入到 Pod 中，而且每次使用不同的容器名称。
类似地，如果 Sidecar 已存在于用户提供的 Pod 中，则 Webhook 可能注入重复的容器。</p>
<p>在上述第二种情况下，重新调用 Webhook 将导致 Webhook 自身输出失败。</p>
<p>在上述第三种情况下，重新调用 Webhook 将导致 Pod 规范中的容器重复，
从而使请求无效并被 API 服务器拒绝。</p>
<h3 id=拦截对象的所有版本>拦截对象的所有版本</h3>
<p>建议通过将 <code>.webhooks[].matchPolicy</code> 设置为 <code>Equivalent</code>，
以确保准入 Webhooks 始终拦截对象的所有版本。
建议准入 Webhooks 应该更偏向注册资源的稳定版本。
如果无法拦截对象的所有版本，可能会导致准入策略未再某些版本的请求上执行。
有关示例，请参见<a href=#matching-requests-matchpolicy>匹配请求：matchPolicy</a>。</p>
<h3 id=availability>可用性 </h3>
<p>建议准入 webhook 尽快完成执行（时长通常是毫秒级），因为它们会增加 API 请求的延迟。
建议对 Webhook 使用较小的超时值。有关更多详细信息，请参见<a href=#timeouts>超时</a>。</p>
<p>建议 Admission Webhook 应该采用某种形式的负载均衡机制，以提供高可用性和高性能。
如果集群中正在运行 Webhook，则可以在服务后面运行多个 Webhook 后端，以利用该服务支持的负载均衡。</p>
<h3 id=确保看到对象的最终状态>确保看到对象的最终状态</h3>
<p>如果某准入 Webhook 需要保证自己能够看到对象的最终状态以实施策略，
则应该使用一个验证性质的 webhook，
因为可以通过 mutating Webhook 看到对象后对其进行修改。</p>
<p>例如，一个修改性质的准入Webhook 被配置为在每个 <code>CREATE</code> Pod 请求中
注入一个名称为 "foo-sidecar" 的 sidecar 容器。</p>
<p>如果<em>必须</em>存在边车容器，则还应配置一个验证性质的准入 Webhook 以拦截
<code>CREATE</code> Pod 请求，并验证要创建的对象中是否存在具有预期配置的名称为
"foo-sidecar" 的容器。</p>
<h3 id=避免自托管的-webhooks-中出现死锁>避免自托管的 Webhooks 中出现死锁</h3>
<p>如果集群内的 Webhook 配置能够拦截启动其自己的 Pod 所需的资源，
则该 Webhook 可能导致其自身部署时发生死锁。</p>
<p>例如，某修改性质的准入 Webhook 配置为仅当 Pod 中设置了某个标签
（例如 <code>"env": "prod"</code>）时，才接受 <code>CREATE</code> Pod 请求。
Webhook 服务器在未设置 <code>"env"</code> 标签的 Deployment 中运行。当运行 Webhook 服务器的
容器的节点运行不正常时，Webhook 部署尝试将容器重新调度到另一个节点。
但是，由于未设置 <code>"env"</code> 标签，因此请求将被现有的 Webhook 服务器拒绝，并且调度迁移不会发生。</p>
<p>建议使用 <a href=#matching-requests-namespaceselector>namespaceSelector</a> 排除
Webhook 所在的名字空间。</p>
<h3 id=side-effects>副作用 </h3>
<p>建议准入 Webhook 应尽可能避免副作用，这意味着该准入 webhook 仅对发送给他们的
<code>AdmissionReview</code> 的内容起作用，并且不要进行额外更改。
如果 Webhook 没有任何副作用，则 <code>.webhooks[].sideEffects</code> 字段应设置为
<code>None</code>。</p>
<p>如果在准入执行期间存在副作用，则应在处理 <code>dryRun</code> 为 <code>true</code> 的 <code>AdmissionReview</code>
对象时避免产生副作用，并且其 <code>.webhooks[].sideEffects</code> 字段应设置为
<code>NoneOnDryRun</code>。更多详细信息，请参见<a href=#side-effects>副作用</a>。</p>
<h3 id=避免对-kube-system-名字空间进行操作>避免对 kube-system 名字空间进行操作</h3>
<p><code>kube-system</code> 名字空间包含由 Kubernetes 系统创建的对象，
例如用于控制平面组件的服务账号，诸如 <code>kube-dns</code> 之类的 Pod 等。
意外更改或拒绝 <code>kube-system</code> 名字空间中的请求可能会导致控制平面组件
停止运行或者导致未知行为发生。
如果你的准入 Webhook 不想修改 Kubernetes 控制平面的行为，请使用
<a href=#matching-requests-namespaceselector><code>namespaceSelector</code></a> 避免
拦截 <code>kube-system</code> 名字空间。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bea207258f3576b8ec7444a20d498e1d>3.6 - 管理服务账号</h1>
<p>这是一篇针对服务账号的集群管理员指南。你应该熟悉
<a href=/zh/docs/tasks/configure-pod-container/configure-service-account/>配置 Kubernetes 服务账号</a>。</p>
<p>对鉴权和用户账号的支持已在规划中，当前并不完备。
为了更好地描述服务账号，有时这些不完善的特性也会被提及。</p>
<h2 id=user-accounts-versus-service-accounts>用户账号与服务账号 </h2>
<p>Kubernetes 区分用户账号和服务账号的概念，主要基于以下原因：</p>
<ul>
<li>用户账号是针对人而言的。 服务账号是针对运行在 Pod 中的进程而言的。</li>
<li>用户账号是全局性的。其名称跨集群中名字空间唯一的。服务账号是名字空间作用域的。</li>
<li>通常情况下，集群的用户账号可能会从企业数据库进行同步，其创建需要特殊权限，
并且涉及到复杂的业务流程。
服务账号创建有意做得更轻量，允许集群用户为了具体的任务创建服务账号
以遵从权限最小化原则。</li>
<li>对人员和服务账号审计所考虑的因素可能不同。</li>
<li>针对复杂系统的配置包可能包含系统组件相关的各种服务账号的定义。因为服务账号
的创建约束不多并且有名字空间域的名称，这种配置是很轻量的。</li>
</ul>
<h2 id=service-account-automation>服务账号的自动化 </h2>
<p>三个独立组件协作完成服务账号相关的自动化：</p>
<ul>
<li><code>ServiceAccount</code> 准入控制器</li>
<li>Token 控制器</li>
<li><code>ServiceAccount</code> 控制器</li>
</ul>
<h3 id=serviceaccount-admission-controller>ServiceAccount 准入控制器 </h3>
<p>对 Pod 的改动通过一个被称为
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/>准入控制器</a>
的插件来实现。它是 API 服务器的一部分。
当 Pod 被创建或更新时，它会同步地修改 Pod。
如果该插件处于激活状态（在大多数发行版中都是默认激活的），当 Pod 被创建
或更新时它会进行以下操作：</p>
<ol>
<li>如果该 Pod 没有设置 <code>ServiceAccount</code>，将其 <code>ServiceAccount</code> 设为 <code>default</code>。</li>
<li>保证 Pod 所引用的 <code>ServiceAccount</code> 确实存在，否则拒绝该 Pod。</li>
<li>如果服务账号的 <code>automountServiceAccountToken</code> 或 Pod 的
<code>automountServiceAccountToken</code> 都未显式设置为 <code>false</code>，则为 Pod 创建一个
<code>volume</code>，在其中包含用来访问 API 的令牌。</li>
<li>如果前一步中为服务账号令牌创建了卷，则为 Pod 中的每个容器添加一个
<code>volumeSource</code>，挂载在其 <code>/var/run/secrets/kubernetes.io/serviceaccount</code>
目录下。</li>
<li>如果 Pod 不包含 <code>imagePullSecrets</code> 设置，将 <code>ServiceAccount</code> 所引用
的服务账号中的 <code>imagePullSecrets</code> 信息添加到 Pod 中。</li>
</ol>
<h4 id=bound-service-account-token-volume>绑定的服务账号令牌卷 </h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<p>ServiceAccount 准入控制器将添加如下投射卷，而不是为令牌控制器
所生成的不过期的服务账号令牌而创建的基于 Secret 的卷。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-api-access-&lt;随机后缀&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>420</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 0644</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3607</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>token<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ca.crt<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>ca.crt<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-root-ca.crt<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.namespace<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>namespace<span style=color:#bbb>
</span></code></pre></div>
<p>此投射卷有三个数据源：</p>
<ol>
<li>通过 TokenRequest API 从 kube-apiserver 处获得的 ServiceAccountToken。
这一令牌默认会在一个小时之后或者 Pod 被删除时过期。
该令牌绑定到 Pod 实例上，并将 kube-apiserver 作为其受众（audience）。</li>
<li>包含用来验证与 kube-apiserver 连接的 CA 证书包的 ConfigMap 对象。
这一特性依赖于 <code>RootCAConfigMap</code> 特性门控。该特性被启用时，
控制面会公开一个名为 <code>kube-root-ca.crt</code> 的 ConfigMap 给所有名字空间。
<code>RootCAConfigMap</code> 在 1.21 版本中进入 GA 状态，默认被启用，
该特性门控会在 1.22 版本中从 <code>--feature-gate</code> 参数中删除。</li>
<li>引用 Pod 名字空间的一个 DownwardAPI。</li>
</ol>
<p>参阅<a href=/zh/docs/tasks/configure-pod-container/configure-projected-volume-storage/>投射卷</a>
了解进一步的细节。</p>
<h3 id=token-controller>Token 控制器 </h3>
<p>TokenController 作为 <code>kube-controller-manager</code> 的一部分运行，以异步的形式工作。
其职责包括：</p>
<ul>
<li>监测 ServiceAccount 的创建并创建相应的服务账号令牌 Secret 以允许访问 API。</li>
<li>监测 ServiceAccount 的删除并删除所有相应的服务账号令牌 Secret。</li>
<li>监测服务账号令牌 Secret 的添加，保证相应的 ServiceAccount 存在，如有需要，
向 Secret 中添加令牌。</li>
<li>监测服务账号令牌 Secret 的删除，如有需要，从相应的 ServiceAccount 中移除引用。</li>
</ul>
<p>你必须通过 <code>--service-account-private-key-file</code> 标志为 <code>kube-controller-manager</code>
的令牌控制器传入一个服务账号私钥文件。该私钥用于为所生成的服务账号令牌签名。
同样地，你需要通过 <code>--service-account-key-file</code> 标志将对应的公钥通知给
kube-apiserver。公钥用于在身份认证过程中校验令牌。</p>
<h4 id=to-create-additional-api-tokens>创建额外的 API 令牌 </h4>
<p>控制器中有专门的循环来保证每个 ServiceAccount 都存在对应的包含 API 令牌的 Secret。
当需要为 ServiceAccount 创建额外的 API 令牌时，可以创建一个类型为
<code>kubernetes.io/service-account-token</code> 的 Secret，并在其注解中引用对应的
ServiceAccount。控制器会生成令牌并更新该 Secret：</p>
<p>下面是这种 Secret 的一个示例配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecretname<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-account.name</span>:<span style=color:#bbb> </span>myserviceaccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./secret.json
kubectl describe secret mysecretname
</code></pre></div>
<h4 id=删除-废止服务账号令牌-secret>删除/废止服务账号令牌 Secret</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete secret mysecretname
</code></pre></div>
<h3 id=serviceaccount-controller>服务账号控制器 </h3>
<p>服务账号控制器管理各名字空间下的 ServiceAccount 对象，并且保证每个活跃的
名字空间下存在一个名为 "default" 的 ServiceAccount。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-342be69d36f174f762c36f4fe11fcb20>3.7 - 鉴权概述</h1>
<p>了解有关 Kubernetes 鉴权的更多信息，包括使用支持的鉴权模块创建策略的详细信息。</p>
<p>在 Kubernetes 中，你必须在鉴权（授予访问权限）之前进行身份验证（登录），有关身份验证的信息，
请参阅<a href=/zh/docs/concepts/security/controlling-access/>访问控制概述</a>.</p>
<p>Kubernetes 期望请求中存在 REST API 常见的属性。
这意味着 Kubernetes 鉴权适用于现有的组织范围或云提供商范围的访问控制系统，
除了 Kubernetes API 之外，它还可以处理其他 API。</p>
<h2 id=确定是允许还是拒绝请求>确定是允许还是拒绝请求</h2>
<p>Kubernetes 使用 API 服务器对 API 请求进行鉴权。
它根据所有策略评估所有请求属性来决定允许或拒绝请求。
一个 API 请求的所有部分都必须被某些策略允许才能继续。
这意味着默认情况下拒绝权限。</p>
<p>（尽管 Kubernetes 使用 API 服务器，但是依赖于特定对象种类的特定字段的访问控制
和策略由准入控制器处理。）</p>
<p>当系统配置了多个鉴权模块时，Kubernetes 将按顺序使用每个模块。
如果任何鉴权模块批准或拒绝请求，则立即返回该决定，并且不会与其他鉴权模块协商。
如果所有模块对请求没有意见，则拒绝该请求。
被拒绝响应返回 HTTP 状态代码 403。</p>
<h2 id=审查你的请求属性>审查你的请求属性</h2>
<p>Kubernetes 仅审查以下 API 请求属性：</p>
<ul>
<li><strong>用户</strong> - 身份验证期间提供的 <code>user</code> 字符串。</li>
<li><strong>组</strong> - 经过身份验证的用户所属的组名列表。</li>
<li><strong>额外信息</strong> - 由身份验证层提供的任意字符串键到字符串值的映射。</li>
<li><strong>API</strong> - 指示请求是否针对 API 资源。</li>
<li><strong>请求路径</strong> - 各种非资源端点的路径，如 <code>/api</code> 或 <code>/healthz</code>。</li>
<li><strong>API 请求动词</strong> - API 动词 <code>get</code>、<code>list</code>、<code>create</code>、<code>update</code>、<code>patch</code>、<code>watch</code>、
<code>proxy</code>、<code>redirect</code>、<code>delete</code> 和 <code>deletecollection</code> 用于资源请求。
要确定资源 API 端点的请求动词，请参阅
<a href=#determine-the-request-verb>确定请求动词</a>。</li>
<li><strong>HTTP 请求动词</strong> - HTTP 动词 <code>get</code>、<code>post</code>、<code>put</code> 和 <code>delete</code> 用于非资源请求。</li>
<li><strong>Resource</strong> - 正在访问的资源的 ID 或名称（仅限资源请求）-
对于使用 <code>get</code>、<code>update</code>、<code>patch</code> 和 <code>delete</code> 动词的资源请求，你必须提供资源名称。</li>
<li><strong>子资源</strong> - 正在访问的子资源（仅限资源请求）。</li>
<li><strong>名字空间</strong> - 正在访问的对象的名称空间（仅适用于名字空间资源请求）。</li>
<li><strong>API 组</strong> - 正在访问的 <a class=glossary-tooltip title="Kubernetes API 中的一组相关路径" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label="API 组">API 组</a>
（仅限资源请求）。空字符串表示<a href=/zh/docs/reference/using-api/#api-groups>核心 API 组</a>。</li>
</ul>
<h2 id=determine-the-request-verb>确定请求动词 </h2>
<p><strong>非资源请求</strong></p>
<p>对于 <code>/api/v1/...</code> 或 <code>/apis/&lt;group>/&lt;version>/...</code> 之外的端点的请求被
视为“非资源请求（Non-Resource Requests）”，并使用该请求的 HTTP 方法的
小写形式作为其请求动词。
例如，对 <code>/api</code> 或 <code>/healthz</code> 这类端点的 <code>GET</code> 请求将使用 <code>get</code> 作为其动词。</p>
<p><strong>资源请求</strong></p>
<p>要确定对资源 API 端点的请求动词，需要查看所使用的 HTTP 动词以及该请求是针对
单个资源还是一组资源：</p>
<table>
<thead>
<tr>
<th>HTTP 动词</th>
<th>请求动词</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>create</td>
</tr>
<tr>
<td>GET, HEAD</td>
<td>get （针对单个资源）、list（针对集合）</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
</tr>
<tr>
<td>PATCH</td>
<td>patch</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete（针对单个资源）、deletecollection（针对集合）</td>
</tr>
</tbody>
</table>
<p>Kubernetes 有时使用专门的动词以对额外的权限进行鉴权。例如：</p>
<ul>
<li><a href=/zh/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>
<ul>
<li><code>policy</code> API 组中 <code>podsecuritypolicies</code> 资源使用 <code>use</code> 动词</li>
</ul>
</li>
<li><a href=/zh/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping>RBAC</a>
<ul>
<li>对 <code>rbac.authorization.k8s.io</code> API 组中 <code>roles</code> 和 <code>clusterroles</code> 资源的 <code>bind</code>
和 <code>escalate</code> 动词</li>
</ul>
</li>
<li><a href=/zh/docs/reference/access-authn-authz/authentication/>身份认证</a>
<ul>
<li>对核心 API 组中 <code>users</code>、<code>groups</code> 和 <code>serviceaccounts</code> 以及 <code>authentication.k8s.io</code>
API 组中的 <code>userextras</code> 所使用的 <code>impersonate</code> 动词。</li>
</ul>
</li>
</ul>
<h2 id=authorization-modules>鉴权模块 </h2>
<ul>
<li><strong>Node</strong> - 一个专用鉴权组件，根据调度到 kubelet 上运行的 Pod 为 kubelet 授予权限。
了解有关使用节点鉴权模式的更多信息，请参阅<a href=/zh/docs/reference/access-authn-authz/node/>节点鉴权</a>。</li>
<li><strong>ABAC</strong> - 基于属性的访问控制（ABAC）定义了一种访问控制范型，通过使用将属性组合
在一起的策略，将访问权限授予用户。策略可以使用任何类型的属性（用户属性、资源属性、
对象，环境属性等）。要了解有关使用 ABAC 模式的更多信息，请参阅
<a href=/zh/docs/reference/access-authn-authz/abac/>ABAC 模式</a>。</li>
<li><strong>RBAC</strong> - 基于角色的访问控制（RBAC）是一种基于企业内个人用户的角色来管理对
计算机或网络资源的访问的方法。在此上下文中，权限是单个用户执行特定任务的能力，
例如查看、创建或修改文件。要了解有关使用 RBAC 模式的更多信息，请参阅
<a href=/zh/docs/reference/access-authn-authz/rbac/>RBAC 模式</a>。
<ul>
<li>被启用之后，RBAC（基于角色的访问控制）使用 <code>rbac.authorization.k8s.io</code> API 组来
驱动鉴权决策，从而允许管理员通过 Kubernetes API 动态配置权限策略。</li>
<li>要启用 RBAC，请使用 <code>--authorization-mode = RBAC</code> 启动 API 服务器。</li>
</ul>
</li>
<li><strong>Webhook</strong> - WebHook 是一个 HTTP 回调：发生某些事情时调用的 HTTP POST；
通过 HTTP POST 进行简单的事件通知。实现 WebHook 的 Web 应用程序会在发生某些事情时
将消息发布到 URL。要了解有关使用 Webhook 模式的更多信息，请参阅
<a href=/zh/docs/reference/access-authn-authz/webhook/>Webhook 模式</a>。</li>
</ul>
<h4 id=checking-api-access>检查 API 访问 </h4>
<p><code>kubectl</code> 提供 <code>auth can-i</code> 子命令，用于快速查询 API 鉴权。
该命令使用 <code>SelfSubjectAccessReview</code> API 来确定当前用户是否可以执行给定操作，
无论使用何种鉴权模式该命令都可以工作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl auth can-i create deployments --namespace dev
</code></pre></div><pre><code>yes
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl auth can-i create deployments --namespace prod
</code></pre></div><pre><code>no
</code></pre>
<p>管理员可以将此与
<a href=/zh/docs/reference/access-authn-authz/authentication/#user-impersonation>用户扮演</a>
结合使用，以确定其他用户可以执行的操作。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl auth can-i list secrets --namespace dev --as dave
</code></pre></div><pre><code>no
</code></pre>
<p><code>SelfSubjectAccessReview</code> 是 <code>authorization.k8s.io</code> API 组的一部分，它将 API
服务器鉴权公开给外部服务。该组中的其他资源包括：</p>
<ul>
<li><code>SubjectAccessReview</code> - 对任意用户的访问进行评估，而不仅仅是当前用户。
当鉴权决策被委派给 API 服务器时很有用。例如，kubelet 和扩展 API 服务器使用
它来确定用户对自己的 API 的访问权限。</li>
<li><code>LocalSubjectAccessReview</code> - 与 <code>SubjectAccessReview</code> 类似，但仅限于特定的
名字空间。</li>
<li><code>SelfSubjectRulesReview</code> - 返回用户可在名字空间内执行的操作集的审阅。
用户可以快速汇总自己的访问权限，或者用于 UI 中的隐藏/显示动作。</li>
</ul>
<p>可以通过创建普通的 Kubernetes 资源来查询这些 API，其中返回对象的响应 "status"
字段是查询的结果。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl create -f - -o yaml <span style=color:#b44>&lt;&lt; EOF
</span><span style=color:#b44>apiVersion: authorization.k8s.io/v1
</span><span style=color:#b44>kind: SelfSubjectAccessReview
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  resourceAttributes:
</span><span style=color:#b44>    group: apps
</span><span style=color:#b44>    name: deployments
</span><span style=color:#b44>    verb: create
</span><span style=color:#b44>    namespace: dev
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<p>生成的 <code>SelfSubjectAccessReview</code> 为：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>SelfSubjectAccessReview<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceAttributes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>apps<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>deployments<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>dev<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verb</span>:<span style=color:#bbb> </span>create<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>denied</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></code></pre></div>
<h2 id=为你的鉴权模块设置参数>为你的鉴权模块设置参数</h2>
<p>你必须在策略中包含一个参数标志，以指明你的策略包含哪个鉴权模块：</p>
<p>可以使用的参数有：</p>
<ul>
<li><code>--authorization-mode=ABAC</code> 基于属性的访问控制（ABAC）模式允许你
使用本地文件配置策略。</li>
<li><code>--authorization-mode=RBAC</code> 基于角色的访问控制（RBAC）模式允许你使用
Kubernetes API 创建和存储策略。</li>
<li><code>--authorization-mode=Webhook</code> WebHook 是一种 HTTP 回调模式，允许你使用远程
REST 端点管理鉴权。</li>
<li><code>--authorization-mode=Node</code> 节点鉴权是一种特殊用途的鉴权模式，专门对
kubelet 发出的 API 请求执行鉴权。</li>
<li><code>--authorization-mode=AlwaysDeny</code> 该标志阻止所有请求。仅将此标志用于测试。</li>
<li><code>--authorization-mode=AlwaysAllow</code> 此标志允许所有请求。仅在你不需要 API 请求
的鉴权时才使用此标志。</li>
</ul>
<p>你可以选择多个鉴权模块。模块按顺序检查，以便较靠前的模块具有更高的优先级来允许
或拒绝请求。</p>
<h2 id=通过创建-pod-提升权限>通过创建 Pod 提升权限</h2>
<p>能够在名字空间中创建 Pod 的用户可能会提升其在该名字空间内的权限。
他们可以创建在该名字空间内访问其权限的 Pod。
他们可以创建 Pod 访问用户自己无法读取的 Secret，或者在具有不同/更高权限的
服务帐户下运行的 Pod 。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong>
<p>系统管理员在授予对 Pod 创建的访问权限时要小心。
被授予在名字空间中创建 Pod（或创建 Pod 的控制器）的权限的用户可以：
读取名字空间中的所有 Secret；读取名字空间中的所有 ConfigMap；
并模拟名字空间中的任意服务账号并执行账号可以执行的任何操作。
无论采用何种鉴权方式，这都适用。
</div>
<h2 id=接下来>接下来</h2>
<ul>
<li>要了解有关身份验证的更多信息，请参阅
<a href=/zh/docs/concepts/security/controlling-access/>控制对 Kubernetes API 的访问</a>
中的 <strong>身份验证</strong> 部分。</li>
<li>要了解有关准入控制的更多信息，请参阅
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/>使用准入控制器</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-954776b47f2d90515f375623a0ce98e1>3.8 - 使用 RBAC 鉴权</h1>
<p>基于角色（Role）的访问控制（RBAC）是一种基于组织中用户的角色来调节控制对
计算机或网络资源的访问的方法。</p>
<p>RBAC 鉴权机制使用 <code>rbac.authorization.k8s.io</code>
<a class=glossary-tooltip title="Kubernetes API 中的一组相关路径" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label="API 组">API 组</a>
来驱动鉴权决定，允许你通过 Kubernetes API 动态配置策略。</p>
<p>要启用 RBAC，在启动 <a class=glossary-tooltip title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank aria-label="API 服务器">API 服务器</a>
时将 <code>--authorization-mode</code> 参数设置为一个逗号分隔的列表并确保其中包含 <code>RBAC</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kube-apiserver --authorization-mode<span style=color:#666>=</span>Example,RBAC --&lt;其他选项&gt; --&lt;其他选项&gt;
</code></pre></div>
<h2 id=api-overview>API 对象 </h2>
<p>RBAC API 声明了四种 Kubernetes 对象：<em>Role</em>、<em>ClusterRole</em>、<em>RoleBinding</em> 和
<em>ClusterRoleBinding</em>。你可以像使用其他 Kubernetes 对象一样，
通过类似 <code>kubectl</code> 这类工具
<a href=/zh/docs/concepts/overview/working-with-objects/kubernetes-objects/#understanding-kubernetes-objects>描述对象</a>,
或修补对象。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong>
<p>这些对象在设计时即实施了一些访问限制。如果你在学习过程中对集群做了更改，请参考
<a href=#privilege-escalation-prevention-and-bootstrapping>避免特权提升和引导</a>
一节，以了解这些限制会以怎样的方式阻止你做出修改。
</div>
<h3 id=role-and-clusterole>Role 和 ClusterRole </h3>
<p>RBAC 的 <em>Role</em> 或 <em>ClusterRole</em> 中包含一组代表相关权限的规则。
这些权限是纯粹累加的（不存在拒绝某操作的规则）。</p>
<p>Role 总是用来在某个<a class=glossary-tooltip title="名字空间是 Kubernetes 为了在同一物理集群上支持多个虚拟集群而使用的一种抽象。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a>
内设置访问权限；在你创建 Role 时，你必须指定该 Role 所属的名字空间。</p>
<p>与之相对，ClusterRole 则是一个集群作用域的资源。这两种资源的名字不同（Role 和
ClusterRole）是因为 Kubernetes 对象要么是名字空间作用域的，要么是集群作用域的，
不可两者兼具。</p>
<p>ClusterRole 有若干用法。你可以用它来：</p>
<ol>
<li>定义对某名字空间域对象的访问权限，并将在各个名字空间内完成授权；</li>
<li>为名字空间作用域的对象设置访问权限，并跨所有名字空间执行授权；</li>
<li>为集群作用域的资源定义访问权限。</li>
</ol>
<p>如果你希望在名字空间内定义角色，应该使用 Role；
如果你希望定义集群范围的角色，应该使用 ClusterRole。</p>
<h4 id=role-示例>Role 示例</h4>
<p>下面是一个位于 "default" 名字空间的 Role 的示例，可用来授予对
<a class=glossary-tooltip title="Pod 表示您的集群上一组正在运行的容器。" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=pods>pods</a> 的读访问权限：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-reader<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#34;&#34; 标明 core API 组</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<h3 id=clusterrole-示例>ClusterRole 示例</h3>
<p>ClusterRole 可以和 Role 相同完成授权。
因为 ClusterRole 属于集群范围，所以它也可以为以下资源授予访问权限：</p>
<ul>
<li>集群范围资源（比如 <a class=glossary-tooltip title="Kubernetes 中的工作机器称作节点。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/nodes/ target=_blank aria-label=节点（Node）>节点（Node）</a>）</li>
<li>非资源端点（比如 <code>/healthz</code>）</li>
<li>跨名字空间访问的名字空间作用域的资源（如 Pods），比如，你可以使用
ClusterRole 来允许某特定用户执行 <code>kubectl get pods --all-namespaces</code></li>
</ul>
<p>下面是一个 ClusterRole 的示例，可用来为任一特定名字空间中的
<a class=glossary-tooltip title="Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> 授予读访问权限，
或者跨名字空间的访问权限（取决于该角色是如何<a href=#rolebinding-and-clusterrolebinding>绑定</a>的）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># &#34;namespace&#34; 被忽略，因为 ClusterRoles 不受名字空间限制</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在 HTTP 层面，用来访问 Secret 对象的资源的名称为 &#34;secrets&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;secrets&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>Role 或 ClusterRole 对象的名称必须是合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#path-segment-names>路径区段名称</a>。</p>
<h3 id=rolebinding-and-clusterrolebinding>RoleBinding 和 ClusterRoleBinding </h3>
<p>角色绑定（Role Binding）是将角色中定义的权限赋予一个或者一组用户。
它包含若干 <strong>主体</strong>（用户、组或服务账户）的列表和对这些主体所获得的角色的引用。
RoleBinding 在指定的名字空间中执行授权，而 ClusterRoleBinding 在集群范围执行授权。</p>
<p>一个 RoleBinding 可以引用同一的名字空间中的任何 Role。
或者，一个 RoleBinding 可以引用某 ClusterRole 并将该 ClusterRole 绑定到
RoleBinding 所在的名字空间。
如果你希望将某 ClusterRole 绑定到集群中所有名字空间，你要使用 ClusterRoleBinding。</p>
<p>RoleBinding 或 ClusterRoleBinding 对象的名称必须是合法的
<a href=/zh/docs/concepts/overview/working-with-objects/names#path-segment-names>路径区段名称</a>。</p>
<h4 id=rolebinding-example>RoleBinding 示例 </h4>
<p>下面的例子中的 RoleBinding 将 "pod-reader" Role 授予在 "default" 名字空间中的用户 "jane"。
这样，用户 "jane" 就具有了读取 "default" 名字空间中 pods 的权限。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 此角色绑定允许 &#34;jane&#34; 读取 &#34;default&#34; 名字空间中的 Pods</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-pods<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 你可以指定不止一个“subject（主体）”</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jane<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#34;name&#34; 是区分大小写的</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># &#34;roleRef&#34; 指定与某 Role 或 ClusterRole 的绑定关系</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 此字段必须是 Role 或 ClusterRole</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-reader    <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>RoleBinding 也可以引用 ClusterRole，以将对应 ClusterRole 中定义的访问权限授予
RoleBinding 所在名字空间的资源。这种引用使得你可以跨整个集群定义一组通用的角色，
之后在多个名字空间中复用。</p>
<p>例如，尽管下面的 RoleBinding 引用的是一个 ClusterRole，"dave"（这里的主体，
区分大小写）只能访问 "development" 名字空间中的 Secrets 对象，因为 RoleBinding
所在的名字空间（由其 metadata 决定）是 "development"。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 此角色绑定使得用户 &#34;dave&#34; 能够读取 &#34;development&#34; 名字空间中的 Secrets</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 你需要一个名为 &#34;secret-reader&#34; 的 ClusterRole</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-secrets<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RoleBinding 的名字空间决定了访问权限的授予范围。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 这里隐含授权仅在 &#34;development&#34; 名字空间内的访问权限。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dave<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#39;name&#39; 是区分大小写的</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<h4 id=clusterrolebinding-example>ClusterRoleBinding 示例 </h4>
<p>要跨整个集群完成访问权限的授予，你可以使用一个 ClusterRoleBinding。
下面的 ClusterRoleBinding 允许 "manager" 组内的所有用户访问任何名字空间中的
Secrets。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 此集群角色绑定允许 “manager” 组中的任何人访问任何名字空间中的 secrets</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-secrets-global<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>manager<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#39;name&#39; 是区分大小写的</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>创建了绑定之后，你不能再修改绑定对象所引用的 Role 或 ClusterRole。
试图改变绑定对象的 <code>roleRef</code> 将导致合法性检查错误。
如果你想要改变现有绑定对象中 <code>roleRef</code> 字段的内容，必须删除重新创建绑定对象。</p>
<p>这种限制有两个主要原因：</p>
<ol>
<li>针对不同角色的绑定是完全不一样的绑定。要求通过删除/重建绑定来更改 <code>roleRef</code>,
这样可以确保要赋予绑定的所有主体会被授予新的角色（而不是在允许或者不小心修改
了 <code>roleRef</code> 的情况下导致所有现有主体未经验证即被授予新角色对应的权限）。</li>
<li>将 <code>roleRef</code> 设置为不可以改变，这使得可以为用户授予对现有绑定对象的 <code>update</code> 权限，
这样可以让他们管理主体列表，同时不能更改被授予这些主体的角色。</li>
</ol>
<p>命令 <code>kubectl auth reconcile</code> 可以创建或者更新包含 RBAC 对象的清单文件，
并且在必要的情况下删除和重新创建绑定对象，以改变所引用的角色。
更多相关信息请参照<a href=#kubectl-auth-reconcile>命令用法和示例</a></p>
<h3 id=referring-to-resources>对资源的引用 </h3>
<p>在 Kubernetes API 中，大多数资源都是使用对象名称的字符串表示来呈现与访问的。
例如，对于 Pod 应使用 "pods"。
RBAC 使用对应 API 端点的 URL 中呈现的名字来引用资源。
有一些 Kubernetes API 涉及 <strong>子资源（subresource）</strong>，例如 Pod 的日志。
对 Pod 日志的请求看起来像这样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>GET /api/v1/namespaces/{namespace}/pods/{name}/log
</span></code></pre></div>
<p>在这里，<code>pods</code> 对应名字空间作用域的 Pod 资源，而 <code>log</code> 是 <code>pods</code> 的子资源。
在 RBAC 角色表达子资源时，使用斜线（<code>/</code>）来分隔资源和子资源。
要允许某主体读取 <code>pods</code> 同时访问这些 Pod 的 <code>log</code> 子资源，你可以这么写：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-and-pod-logs-reader<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods/log&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>对于某些请求，也可以通过 <code>resourceNames</code> 列表按名称引用资源。
在指定时，可以将请求限定为资源的单个实例。
下面的例子中限制可以 "get" 和 "update" 一个名为 <code>my-configmap</code> 的
<a class=glossary-tooltip title="ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-updater<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在 HTTP 层面，用来访问 ConfigMap 的资源的名称为 &#34;configmaps&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;my-configmap&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;get&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>你不能针对 <code>create</code> 或者 <code>deletecollection</code> 请求来实施 resourceName 限制。
对于 <code>create</code> 操作而言，这是因为在鉴权时还不知道对象名称。
</div>
<h3 id=aggregated-clusterroles>聚合的 ClusterRole </h3>
<p>你可以将若干 ClusterRole <strong>聚合（Aggregate）</strong> 起来，形成一个复合的 ClusterRole。
某个控制器作为集群控制面的一部分会监视带有 <code>aggregationRule</code> 的 ClusterRole
对象集合。<code>aggregationRule</code> 为控制器定义一个标签
<a class=glossary-tooltip title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=选择算符>选择算符</a>供后者匹配
应该组合到当前 ClusterRole 的 <code>roles</code> 字段中的 ClusterRole 对象。</p>
<p>下面是一个聚合 ClusterRole 的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>monitoring<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>aggregationRule</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterRoleSelectors</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>rbac.example.com/aggregate-to-monitoring</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 控制面自动填充这里的规则</span><span style=color:#bbb>
</span></code></pre></div>
<p>如果你创建一个与某现有聚合 ClusterRole 的标签选择算符匹配的 ClusterRole，
这一变化会触发新的规则被添加到聚合 ClusterRole 的操作。
下面的例子中，通过创建一个标签同样为 <code>rbac.example.com/aggregate-to-monitoring: true</code>
的 ClusterRole，新的规则可被添加到 "monitoring" ClusterRole 中。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>monitoring-endpoints<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.example.com/aggregate-to-monitoring</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 当你创建 &#34;monitoring-endpoints&#34; ClusterRole 时，</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 下面的规则会被添加到 &#34;monitoring&#34; ClusterRole 中</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;services&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;endpoints&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>默认的<a href=#default-roles-and-role-bindings>面向用户的角色</a> 使用 ClusterRole 聚合。
这使得作为集群管理员的你可以为扩展默认规则，包括为定制资源设置规则，
比如通过 CustomResourceDefinitions 或聚合 API 服务器提供的定制资源。</p>
<p>例如，下面的 ClusterRoles 让默认角色 "admin" 和 "edit" 拥有管理自定义资源 "CronTabs" 的权限，
"view" 角色对 CronTab 资源拥有读操作权限。
你可以假定 CronTab 对象在 API 服务器所看到的 URL 中被命名为 <code>"crontabs"</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>aggregate-cron-tabs-edit<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 添加以下权限到默认角色 &#34;admin&#34; 和 &#34;edit&#34; 中</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stable.example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;crontabs&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>aggregate-cron-tabs-view<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 添加以下权限到 &#34;view&#34; 默认角色中</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-view</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stable.example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;crontabs&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<h4 id=role-examples>Role 示例 </h4>
<p>以下示例均为从 Role 或 CLusterRole 对象中截取出来，我们仅展示其 <code>rules</code> 部分。</p>
<p>允许读取在核心 <a class=glossary-tooltip title="Kubernetes API 中的一组相关路径" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label="API 组">API 组</a>下的
<code>"Pods"</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在 HTTP 层面，用来访问 Pod 的资源的名称为 &#34;pods&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>允许读/写在 "extensions" 和 "apps" API 组中的 Deployment（在 HTTP 层面，对应
URL 中资源部分为 "deployments"）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;extensions&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>允许读取核心 API 组中的 "pods" 和读/写 <code>"batch"</code> 或 <code>"extensions"</code> API 组中的
"jobs"：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;batch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;extensions&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;jobs&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>允许读取名称为 "my-config" 的 ConfigMap（需要通过 RoleBinding 绑定以
限制为某名字空间中特定的 ConfigMap）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;my-config&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>允许读取在核心组中的 "nodes" 资源（因为 <code>Node</code> 是集群作用域的，所以需要
ClusterRole 绑定到 ClusterRoleBinding 才生效）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;nodes&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<p>允许针对非资源端点 <code>/healthz</code> 和其子路径上发起 GET 和 POST 请求
（必须在 ClusterRole 绑定 ClusterRoleBinding 才生效）：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/healthz&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;/healthz/*&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nonResourceURL 中的 &#39;*&#39; 是一个全局通配符</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;post&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
<h3 id=referring-to-subjects>对主体的引用 </h3>
<p>RoleBinding 或者 ClusterRoleBinding 可绑定角色到某 *主体（Subject）*上。
主体可以是组，用户或者
<a class=glossary-tooltip title="为在 Pod 中运行的进程提供标识。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=服务账户>服务账户</a>。</p>
<p>Kubernetes 用字符串来表示用户名。
用户名可以是普通的用户名，像 "alice"；或者是邮件风格的名称，如 "bob@example.com"，
或者是以字符串形式表达的数字 ID。
你作为 Kubernetes 管理员负责配置
<a href=/zh/docs/reference/access-authn-authz/authentication/>身份认证模块</a>
以便后者能够生成你所期望的格式的用户名。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong>
<p>前缀 <code>system:</code> 是 Kubernetes 系统保留的，所以你要确保
所配置的用户名或者组名不能出现上述 <code>system:</code> 前缀。
除了对前缀的限制之外，RBAC 鉴权系统不对用户名格式作任何要求。
</div>
<p>在 Kubernetes 中，鉴权模块提供用户组信息。
与用户名一样，用户组名也用字符串来表示，而且对该字符串没有格式要求，
只是不能使用保留的前缀 <code>system:</code>。</p>
<p><a href=/zh/docs/tasks/configure-pod-container/configure-service-account/>服务账户</a>
的用户名前缀为 <code>system:serviceaccount:</code>，属于前缀为 <code>system:serviceaccounts:</code>
的用户组。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<ul>
<li><code>system:serviceaccount:</code> （单数）是用于服务账户用户名的前缀；</li>
<li><code>system:serviceaccounts:</code> （复数）是用于服务账户组名的前缀。</li>
</ul>
</div>
<h4 id=role-binding-examples>RoleBinding 示例 </h4>
<p>下面示例是 <code>RoleBinding</code> 中的片段，仅展示其 <code>subjects</code> 的部分。</p>
<p>对于名称为 <code>alice@example.com</code> 的用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;alice@example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>对于名称为 <code>frontend-admins</code> 的用户组：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;frontend-admins&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>对于 <code>kube-system</code> 名字空间中的默认服务账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></code></pre></div>
<p>对于任何名称空间中的 "qa" 组中所有的服务账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts:qa<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>对于 "development" 名称空间中 "dev" 组中的所有服务帐户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts:dev<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></code></pre></div>
<p>对于在任何名字空间中的服务账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>对于所有已经过认证的用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>对于所有未通过认证的用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:unauthenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>对于所有用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:unauthenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<h2 id=默认-roles-和-role-bindings>默认 Roles 和 Role Bindings</h2>
<p>API 服务器创建一组默认的 ClusterRole 和 ClusterRoleBinding 对象。
这其中许多是以 <code>system:</code> 为前缀的，用以标识对应资源是直接由集群控制面管理的。
所有的默认 ClusterRole 和 ClusterRoleBinding 都有
<code>kubernetes.io/bootstrapping=rbac-defaults</code>
标签。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong>
<p>在修改名称包含 <code>system:</code> 前缀的 ClusterRole 和 ClusterRoleBinding
时要格外小心。
对这些资源的更改可能导致集群无法继续工作。
</div>
<h3 id=auto-reconciliation>自动协商 </h3>
<p>在每次启动时，API 服务器都会更新默认 ClusterRole 以添加缺失的各种权限，并更新
默认的 ClusterRoleBinding 以增加缺失的各类主体。
这种自动协商机制允许集群去修复一些不小心发生的修改，并且有助于保证角色和角色绑定
在新的发行版本中有权限或主体变更时仍然保持最新。</p>
<p>如果要禁止此功能，请将默认 ClusterRole 以及 ClusterRoleBinding 的
<code>rbac.authorization.kubernetes.io/autoupdate</code> 注解设置成 <code>false</code>。
注意，缺少默认权限和角色绑定主体可能会导致集群无法正常工作。</p>
<p>如果基于 RBAC 的鉴权机制被启用，则自动协商功能默认是被启用的。</p>
<h3 id=discovery-roles>API 发现角色 </h3>
<p>无论是经过身份验证的还是未经过身份验证的用户，默认的角色绑定都授权他们读取被认为
是可安全地公开访问的 API（ 包括 CustomResourceDefinitions）。
如果要禁用匿名的未经过身份验证的用户访问，请在 API 服务器配置中中添加
<code>--anonymous-auth=false</code> 的配置选项。</p>
<p>通过运行命令 <code>kubectl</code> 可以查看这些角色的配置信息:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get clusterroles system:discovery -o yaml
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>如果你编辑该 ClusterRole，你所作的变更会被 API 服务器在重启时自动覆盖，这是通过
<a href=#auto-reconciliation>自动协商</a>机制完成的。要避免这类覆盖操作，
要么不要手动编辑这些角色，要么禁止自动协商机制。
</div>
<table>
<caption>
Kubernetes RBAC API 发现角色
</caption>
<col width=25%><col width=25%><col>
<thead>
<tr>
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>system:basic-user</b></td>
<td><b>system:authenticated</b> 组</td>
<td>
允许用户以只读的方式去访问他们自己的基本信息。在 1.14 版本之前，这个角色在默认情况下也绑定在 <tt>system:unauthenticated</tt> 上。
</td>
</tr>
<tr>
<td><b>system:discovery</b></td>
<td><b>system:authenticated</b> 组</td>
<td>
允许以只读方式访问 API 发现端点，这些端点用来发现和协商 API 级别。
在 1.14 版本之前，这个角色在默认情况下绑定在 <tt>system:unauthenticated</tt> 上。
</td>
</tr>
<tr>
<td><b>system:public-info-viewer</b></td>
<td><b>system:authenticated</b> 和 <b>system:unauthenticated</b> 组</td>
<td>
允许对集群的非敏感信息进行只读访问，它是在 1.14 版本中引入的。
</td>
</tr>
</tbody>
</table>
<h3 id=user-facing-roles>面向用户的角色 </h3>
<p>一些默认的 ClusterRole 不是以前缀 <code>system:</code> 开头的。这些是面向用户的角色。
它们包括超级用户（Super-User）角色（<code>cluster-admin</code>）、
使用 ClusterRoleBinding 在集群范围内完成授权的角色（<code>cluster-status</code>）、
以及使用 RoleBinding 在特定名字空间中授予的角色（<code>admin</code>、<code>edit</code>、<code>view</code>）。</p>
<p>面向用户的 ClusterRole 使用 <a href=#aggregated-clusterroles>ClusterRole 聚合</a>以允许管理员在
这些 ClusterRole 上添加用于定制资源的规则。如果想要添加规则到 <code>admin</code>、<code>edit</code> 或者 <code>view</code>，
可以创建带有以下一个或多个标签的 ClusterRole：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-view</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></code></pre></div><table>
<col width=25%><col width=25%><col>
<thead>
<tr>
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>cluster-admin</b></td>
<td><b>system:masters</b> 组</td>
<td>
允许超级用户在平台上的任何资源上执行所有操作。
当在 <b>ClusterRoleBinding</b> 中使用时，可以授权对集群中以及所有名字空间中的全部资源进行完全控制。
当在 <b>RoleBinding</b> 中使用时，可以授权控制 RoleBinding 所在名字空间中的所有资源，包括名字空间本身。
</td>
</tr>
<tr>
<td><b>admin</b></td>
<td>无</td>
<td>
允许管理员访问权限，旨在使用 <b>RoleBinding</b> 在名字空间内执行授权。
如果在 <b>RoleBinding</b> 中使用，则可授予对名字空间中的大多数资源的读/写权限，
包括创建角色和角色绑定的能力。
但是它不允许对资源配额或者名字空间本身进行写操作。
</td>
</tr>
<tr>
<td><b>edit</b></td>
<td>无</td>
<td>
允许对名字空间的大多数对象进行读/写操作。
它不允许查看或者修改角色或者角色绑定。
不过，此角色可以访问 Secret，以名字空间中任何 ServiceAccount 的身份运行 Pods，
所以可以用来了解名字空间内所有服务账户的 API 访问级别。
</td>
</tr>
<tr>
<td><b>view</b></td>
<td>无</td>
<td>
允许对名字空间的大多数对象有只读权限。
它不允许查看角色或角色绑定。
<p>此角色不允许查看 Secrets，因为读取 Secret 的内容意味着可以访问名字空间中
ServiceAccount 的凭据信息，进而允许利用名字空间中任何 ServiceAccount 的
身份访问 API（这是一种特权提升）。</p>
</td>
</tr>
</tbody>
</table>
<h3 id=core-component-roles>核心组件角色 </h3>
<table>
<col width=25%><col width=25%><col>
<thead>
<tr>
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>system:kube-scheduler</b></td>
<td><b>system:kube-scheduler</b> 用户</td>
<td>
允许访问 <a class=glossary-tooltip title="控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。" data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=scheduler>scheduler</a>
组件所需要的资源。
</td>
</tr>
<tr>
<td><b>system:volume-scheduler</b></td>
<td><b>system:kube-scheduler</b> 用户</td>
<td>
允许访问 kube-scheduler 组件所需要的卷资源。
</td>
</tr>
<tr>
<td><b>system:kube-controller-manager</b></td>
<td><b>system:kube-controller-manager</b> 用户</td>
<td>
允许访问<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=控制器管理器>控制器管理器</a>
组件所需要的资源。
各个控制回路所需要的权限在<a href=#controller-roles>控制器角色</a> 详述。
</td>
</tr>
<tr>
<td><b>system:node</b></td>
<td>无</td>
<td>
允许访问 kubelet 所需要的资源，<b>包括对所有 Secret 的读操作和对所有 Pod 状态对象的写操作。</b>
<p>你应该使用 <a href=/zh/docs/reference/access-authn-authz/node/>Node 鉴权组件</a> 和
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction 准入插件</a>
而不是 <tt>system:node</tt> 角色。同时基于 kubelet 上调度执行的 Pod 来授权
kubelet 对 API 的访问。</p>
<p><tt>system:node</tt> 角色的意义仅是为了与从 v1.8 之前版本升级而来的集群兼容。</p>
</td>
</tr>
<tr>
<td><b>system:node-proxier</b></td>
<td><b>system:kube-proxy</b> 用户</td>
<td>允许访问 <a class=glossary-tooltip title="kube-proxy 是集群中每个节点上运行的网络代理。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>
组件所需要的资源。</td>
</tr>
</tbody>
</table>
<h3 id=other-component-roles>其他组件角色 </h3>
<table>
<col width=25%><col width=25%><col>
<thead>
<tr>
<th>默认 ClusterRole</th>
<th>默认 ClusterRoleBinding</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><b>system:auth-delegator</b></td>
<td>无</td>
<td>
允许将身份认证和鉴权检查操作外包出去。
这种角色通常用在插件式 API 服务器上，以实现统一的身份认证和鉴权。
</td>
</tr>
<tr>
<td><b>system:heapster</b></td>
<td>无</td>
<td>
为 <a href=https://github.com/kubernetes/heapster>Heapster</a> 组件（已弃用）定义的角色。
</td>
</tr>
<tr>
<td><b>system:kube-aggregator</b></td>
<td>无</td>
<td>为 <a href=https://github.com/kubernetes/kube-aggregator>kube-aggregator</a> 组件定义的角色。</td>
</tr>
<tr>
<td><b>system:kube-dns</b></td>
<td>
在 <b>kube-system</b> 名字空间中的 <b>kube-dns</b> 服务账户</td>
<td>为 <a href=/docs/concepts/services-networking/dns-pod-service/>kube-dns</a> 组件定义的角色。
</td>
</tr>
<tr>
<td><b>system:kubelet-api-admin</b></td>
<td>无</td>
<td>
允许 kubelet API 的完全访问权限。
</td>
</tr>
<tr>
<td><b>system:node-bootstrapper</b></td>
<td>无</td>
<td>
允许访问执行
<a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLS 启动引导</a>
所需要的资源。
</td>
</tr>
<tr>
<td><b>system:node-problem-detector</b></td>
<td>无</td>
<td>
为 <a href=https://github.com/kubernetes/node-problem-detector>node-problem-detector</a> 组件定义的角色。
</td>
</tr>
<tr>
<td><b>system:persistent-volume-provisioner</b></td>
<td>无</td>
<td>
允许访问大部分
<a href=/docs/concepts/storage/persistent-volumes/#provisioner>动态卷驱动
</a>
所需要的资源。</td>
</tr>
<tr>
<td><b>system:monitoring</b></td>
<td><b>system:monitoring</b> 组</td>
<td>
允许对控制平面监控端点的读取访问（例如：<a class=glossary-tooltip title="提供 Kubernetes API 服务的控制面组件。" data-toggle=tooltip data-placement=top href=/zh/docs/reference/command-line-tools-reference/kube-apiserver/ target=_blank aria-label=kube-apiserver>kube-apiserver</a>
存活和就绪端点（<tt>/healthz</tt>、<tt>/livez</tt>、<tt>/readyz</tt>），
各个健康检查端点（<tt>/healthz/*</tt>、<tt>/livez/*</tt>、<tt>/readyz/*</tt>）和 <tt>/metrics</tt>）。
请注意，各个运行状况检查端点和度量标准端点可能会公开敏感信息。
</td>
</tr>
</tbody>
</table>
<h3 id=controller-roles>内置控制器的角色 </h3>
<p>Kubernetes <a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=控制器管理器>控制器管理器</a>
运行内建于 Kubernetes 控制面的<a class=glossary-tooltip title="控制器通过 apiserver 监控集群的公共状态，并致力于将当前状态转变为期望的状态。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>。
当使用 <code>--use-service-account-credentials</code> 参数启动时, kube-controller-manager
使用单独的服务账户来启动每个控制器。
每个内置控制器都有相应的、前缀为 <code>system:controller:</code> 的角色。
如果控制管理器启动时未设置 <code>--use-service-account-credentials</code>，
它使用自己的身份凭据来运行所有的控制器，该身份必须被授予所有相关的角色。
这些角色包括:</p>
<ul>
<li><code>system:controller:attachdetach-controller</code></li>
<li><code>system:controller:certificate-controller</code></li>
<li><code>system:controller:clusterrole-aggregation-controller</code></li>
<li><code>system:controller:cronjob-controller</code></li>
<li><code>system:controller:daemon-set-controller</code></li>
<li><code>system:controller:deployment-controller</code></li>
<li><code>system:controller:disruption-controller</code></li>
<li><code>system:controller:endpoint-controller</code></li>
<li><code>system:controller:expand-controller</code></li>
<li><code>system:controller:generic-garbage-collector</code></li>
<li><code>system:controller:horizontal-pod-autoscaler</code></li>
<li><code>system:controller:job-controller</code></li>
<li><code>system:controller:namespace-controller</code></li>
<li><code>system:controller:node-controller</code></li>
<li><code>system:controller:persistent-volume-binder</code></li>
<li><code>system:controller:pod-garbage-collector</code></li>
<li><code>system:controller:pv-protection-controller</code></li>
<li><code>system:controller:pvc-protection-controller</code></li>
<li><code>system:controller:replicaset-controller</code></li>
<li><code>system:controller:replication-controller</code></li>
<li><code>system:controller:resourcequota-controller</code></li>
<li><code>system:controller:root-ca-cert-publisher</code></li>
<li><code>system:controller:route-controller</code></li>
<li><code>system:controller:service-account-controller</code></li>
<li><code>system:controller:service-controller</code></li>
<li><code>system:controller:statefulset-controller</code></li>
<li><code>system:controller:ttl-controller</code></li>
</ul>
<h2 id=初始化与预防权限提升>初始化与预防权限提升</h2>
<p>RBAC API 会阻止用户通过编辑角色或者角色绑定来提升权限。
由于这一点是在 API 级别实现的，所以在 RBAC 鉴权组件未启用的状态下依然可以正常工作。</p>
<h3 id=对角色创建或更新的限制>对角色创建或更新的限制</h3>
<p>只有在符合下列条件之一的情况下，你才能创建/更新角色:</p>
<ol>
<li>你已经拥有角色中包含的所有权限，且其作用域与正被修改的对象作用域相同。
（对 ClusterRole 而言意味着集群范围，对 Role 而言意味着相同名字空间或者集群范围）。</li>
<li>你被显式授权在 <code>rbac.authorization.k8s.io</code> API 组中的 <code>roles</code> 或 <code>clusterroles</code> 资源
使用 <code>escalate</code> 动词。</li>
</ol>
<p>例如，如果 <code>user-1</code> 没有列举集群范围所有 Secret 的权限，他将不能创建包含该权限的 ClusterRole。
若要允许用户创建/更新角色：</p>
<ol>
<li>根据需要赋予他们一个角色，允许他们根据需要创建/更新 Role 或者 ClusterRole 对象。</li>
<li>授予他们在所创建/更新角色中包含特殊权限的权限:
<ul>
<li>隐式地为他们授权（如果它们试图创建或者更改 Role 或 ClusterRole 的权限，
但自身没有被授予相应权限，API 请求将被禁止）。</li>
<li>通过允许他们在 Role 或 ClusterRole 资源上执行 <code>escalate</code> 动作显式完成授权。
这里的 <code>roles</code> 和 <code>clusterroles</code> 资源包含在 <code>rbac.authorization.k8s.io</code> API 组中。</li>
</ul>
</li>
</ol>
<h3 id=对角色绑定创建或更新的限制>对角色绑定创建或更新的限制</h3>
<p>只有你已经具有了所引用的角色中包含的全部权限时，或者你被授权在所引用的角色上执行 <code>bind</code>
动词时，你才可以创建或更新角色绑定。这里的权限与角色绑定的作用域相同。
例如，如果用户 <code>user-1</code> 没有列举集群范围所有 Secret 的能力，则他不可以创建
ClusterRoleBinding 引用授予该许可权限的角色。
如要允许用户创建或更新角色绑定：</p>
<ol>
<li>赋予他们一个角色，使得他们能够根据需要创建或更新 RoleBinding 或 ClusterRoleBinding
对象。</li>
<li>授予他们绑定某特定角色所需要的许可权限：
<ul>
<li>隐式授权下，可以将角色中包含的许可权限授予他们；</li>
<li>显式授权下，可以授权他们在特定 Role （或 ClusterRole）上执行 <code>bind</code> 动词的权限。</li>
</ul>
</li>
</ol>
<p>例如，下面的 ClusterRole 和 RoleBinding 将允许用户 <code>user-1</code> 把名字空间 <code>user-1-namespace</code>
中的 <code>admin</code>、<code>edit</code> 和 <code>view</code> 角色赋予其他用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rbac.authorization.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rolebindings&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;create&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rbac.authorization.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;clusterroles&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;bind&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 忽略 resourceNames 意味着允许绑定任何 ClusterRole</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;admin&#34;</span>,<span style=color:#b44>&#34;edit&#34;</span>,<span style=color:#b44>&#34;view&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor-binding<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>user-1-namespace<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>user-1<span style=color:#bbb>
</span></code></pre></div>
<p>当启动引导第一个角色和角色绑定时，需要为初始用户授予他们尚未拥有的权限。
对初始角色和角色绑定进行初始化时需要：</p>
<ul>
<li>使用用户组为 <code>system:masters</code> 的凭据，该用户组由默认绑定关联到 <code>cluster-admin</code>
这个超级用户角色。</li>
<li>如果你的 API 服务器启动时启用了不安全端口（使用 <code>--insecure-port</code>）, 你也可以通过
该端口调用 API ，这样的操作会绕过身份验证或鉴权。</li>
</ul>
<h2 id=一些命令行工具>一些命令行工具</h2>
<h3 id=kubectl-create-role><code>kubectl create role</code></h3>
<p>创建 Role 对象，定义在某一名字空间中的权限。例如:</p>
<ul>
<li>
<p>创建名称为 "pod-reader" 的 Role 对象，允许用户对 Pods 执行 <code>get</code>、<code>watch</code> 和 <code>list</code> 操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role pod-reader --verb<span style=color:#666>=</span>get --verb<span style=color:#666>=</span>list --verb<span style=color:#666>=</span>watch --resource<span style=color:#666>=</span>pods
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名称为 "pod-reader" 的 Role 对象并指定 <code>resourceNames</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role pod-reader --verb<span style=color:#666>=</span>get --resource<span style=color:#666>=</span>pods --resource-name<span style=color:#666>=</span>readablepod --resource-name<span style=color:#666>=</span>anotherpod
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "foo" 的 Role 对象并指定 <code>apiGroups</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>replicasets.apps
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "foo" 的 Role 对象并指定子资源权限:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods,pods/status
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "my-component-lease-holder" 的 Role 对象，使其具有对特定名称的
资源执行 get/update 的权限：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role my-component-lease-holder --verb<span style=color:#666>=</span>get,list,watch,update --resource<span style=color:#666>=</span>lease --resource-name<span style=color:#666>=</span>my-component
</code></pre></div></li>
</ul>
<h3 id=kubectl-create-clusterrole><code>kubectl create clusterrole</code></h3>
<p>创建 ClusterRole 对象。例如：</p>
<ul>
<li>
<p>创建名称为 "pod-reader" 的 ClusterRole<code>对象，允许用户对 Pods 对象执行 </code>get<code>、</code>watch<code>和</code>list` 操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole pod-reader --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "pod-reader" 的 ClusterRole 对象并指定 <code>resourceNames</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole pod-reader --verb<span style=color:#666>=</span>get --resource<span style=color:#666>=</span>pods --resource-name<span style=color:#666>=</span>readablepod --resource-name<span style=color:#666>=</span>anotherpod
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "foo" 的 ClusterRole 对象并指定 <code>apiGroups</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>replicasets.apps
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "foo" 的 ClusterRole 对象并指定子资源:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods,pods/status
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "foo" 的 ClusterRole 对象并指定 <code>nonResourceURL</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole <span style=color:#b44>&#34;foo&#34;</span> --verb<span style=color:#666>=</span>get --non-resource-url<span style=color:#666>=</span>/logs/*
</code></pre></div></li>
</ul>
<ul>
<li>
<p>创建名为 "monitoring" 的 ClusterRole 对象并指定 <code>aggregationRule</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole monitoring --aggregation-rule<span style=color:#666>=</span><span style=color:#b44>&#34;rbac.example.com/aggregate-to-monitoring=true&#34;</span>
</code></pre></div></li>
</ul>
<h3 id=kubectl-create-rolebinding><code>kubectl create rolebinding</code></h3>
<p>在特定的名字空间中对 <code>Role</code> 或 <code>ClusterRole</code> 授权。例如：</p>
<ul>
<li>
<p>在名字空间 "acme" 中，将名为 <code>admin</code> 的 ClusterRole 中的权限授予名称 "bob" 的用户:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding bob-admin-binding --clusterrole<span style=color:#666>=</span>admin --user<span style=color:#666>=</span>bob --namespace<span style=color:#666>=</span>acme
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在名字空间 "acme" 中，将名为 <code>view</code> 的 ClusterRole 中的权限授予名字空间 "acme"
中名为 <code>myapp</code> 的服务账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>acme:myapp --namespace<span style=color:#666>=</span>acme
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在名字空间 "acme" 中，将名为 <code>view</code> 的 ClusterRole 对象中的权限授予名字空间
"myappnamespace" 中名称为 <code>myapp</code> 的服务账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding myappnamespace-myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>myappnamespace:myapp --namespace<span style=color:#666>=</span>acme
</code></pre></div></li>
</ul>
<h3 id=kubectl-create-clusterrolebinding><code>kubectl create clusterrolebinding</code></h3>
<p>在整个集群（所有名字空间）中用 ClusterRole 授权。例如：</p>
<ul>
<li>
<p>在整个集群范围，将名为 <code>cluster-admin</code> 的 ClusterRole 中定义的权限授予名为
"root" 用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole<span style=color:#666>=</span>cluster-admin --user<span style=color:#666>=</span>root
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在整个集群范围内，将名为 <code>system:node-proxier</code> 的 ClusterRole 的权限授予名为
"system:kube-proxy" 的用户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding kube-proxy-binding --clusterrole<span style=color:#666>=</span>system:node-proxier --user<span style=color:#666>=</span>system:kube-proxy
</code></pre></div></li>
</ul>
<ul>
<li>
<p>在整个集群范围内，将名为 <code>view</code> 的 ClusterRole 中定义的权限授予 "acme" 名字空间中
名为 "myapp" 的服务账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>acme:myapp
</code></pre></div></li>
</ul>
<h3 id=kubectl-auth-reconcile><code>kubectl auth reconcile</code></h3>
<p>使用清单文件来创建或者更新 <code>rbac.authorization.k8s.io/v1</code> API 对象。</p>
<p>尚不存在的对象会被创建，如果对应的名字空间也不存在，必要的话也会被创建。
已经存在的角色会被更新，使之包含输入对象中所给的权限。如果指定了
<code>--remove-extra-permissions</code>，可以删除额外的权限。</p>
<p>已经存在的绑定也会被更新，使之包含输入对象中所给的主体。如果指定了
<code>--remove-extra-permissions</code>，则可以删除多余的主体。</p>
<p>例如:</p>
<ul>
<li>
<p>测试应用 RBAC 对象的清单文件，显示将要进行的更改：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl auth reconcile -f my-rbac-rules.yaml --dry-run
</code></pre></div></li>
</ul>
<ul>
<li>
<p>应用 RBAC 对象的清单文件，保留角色中的额外权限和绑定中的其他主体：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl auth reconcile -f my-rbac-rules.yaml
</code></pre></div></li>
</ul>
<ul>
<li>
<p>应用 RBAC 对象的清单文件, 删除角色中的额外权限和绑定中的其他主体：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl auth reconcile -f my-rbac-rules.yaml --remove-extra-subjects --remove-extra-permissions
</code></pre></div></li>
</ul>
<p>查看 CLI 帮助获取详细的用法。</p>
<h2 id=service-account-permissions>服务账户权限 </h2>
<p>默认的 RBAC 策略为控制面组件、节点和控制器授予权限。
但是不会对 <code>kube-system</code> 名字空间之外的服务账户授予权限。
（除了授予所有已认证用户的发现权限）</p>
<p>这使得你可以根据需要向特定服务账户授予特定权限。
细粒度的角色绑定可带来更好的安全性，但需要更多精力管理。
粗粒度的授权可能导致服务账户被授予不必要的 API 访问权限（甚至导致潜在的权限提升），
但更易于管理。</p>
<p>按从最安全到最不安全的顺序，存在以下方法：</p>
<ol>
<li>
<p>为特定应用的服务账户授予角色（最佳实践）</p>
<p>这要求应用在其 Pod 规约中指定 <code>serviceAccountName</code>，
并额外创建服务账户（包括通过 API、应用程序清单、<code>kubectl create serviceaccount</code> 等）。</p>
<p>例如，在名字空间 "my-namespace" 中授予服务账户 "my-sa" 只读权限：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding my-sa-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>my-namespace:my-sa <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</code></pre></div></li>
</ol>
<ol start=2>
<li>
<p>将角色授予某名字空间中的 "default" 服务账户</p>
<p>如果某应用没有指定 <code>serviceAccountName</code>，那么它将使用 "default" 服务账户。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> "default" 服务账户所具有的权限会被授予给名字空间中所有未指定
<code>serviceAccountName</code> 的 Pod。
</div>
<p>例如，在名字空间 "my-namespace" 中授予服务账户 "default" 只读权限：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding default-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>my-namespace:default <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</code></pre></div>
<p>许多<a href=/zh/docs/concepts/cluster-administration/addons/>插件组件</a> 在 <code>kube-system</code>
名字空间以 "default" 服务账户运行。
要允许这些插件组件以超级用户权限运行，需要将集群的 <code>cluster-admin</code> 权限授予
<code>kube-system</code> 名字空间中的 "default" 服务账户。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 启用这一配置意味着在 <code>kube-system</code> 名字空间中包含以超级用户账号来访问 API
的 Secrets。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding add-on-cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>kube-system:default
</code></pre></div></li>
</ol>
<ol start=3>
<li>
<p>将角色授予名字空间中所有服务账户</p>
<p>如果你想要名字空间中所有应用都具有某角色，无论它们使用的什么服务账户，
可以将角色授予该名字空间的服务账户组。</p>
<p>例如，在名字空间 "my-namespace" 中的只读权限授予该名字空间中的所有服务账户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding serviceaccounts-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts:my-namespace <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>在集群范围内为所有服务账户授予一个受限角色（不鼓励）</p>
<p>如果你不想管理每一个名字空间的权限，你可以向所有的服务账户授予集群范围的角色。</p>
<p>例如，为集群范围的所有服务账户授予跨所有名字空间的只读权限：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding serviceaccounts-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</code></pre></div></li>
</ol>
<ol start=5>
<li>
<p>授予超级用户访问权限给集群范围内的所有服务帐户（强烈不鼓励）</p>
<p>如果你不关心如何区分权限，你可以将超级用户访问权限授予所有服务账户。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告：</strong> 这样做会允许所有应用都对你的集群拥有完全的访问权限，并将允许所有能够读取
Secret（或创建 Pod）的用户对你的集群有完全的访问权限。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding serviceaccounts-cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</code></pre></div></li>
</ol>
<h2 id=从-abac-升级>从 ABAC 升级</h2>
<p>原来运行较老版本 Kubernetes 的集群通常会使用限制宽松的 ABAC 策略，
包括授予所有服务帐户全权访问 API 的能力。</p>
<p>默认的 RBAC 策略为控制面组件、节点和控制器等授予有限的权限，但不会为
<code>kube-system</code> 名字空间外的服务账户授权
（除了授予所有认证用户的发现权限之外）。</p>
<p>这样做虽然安全得多，但可能会干扰期望自动获得 API 权限的现有工作负载。
这里有两种方法来完成这种转换:</p>
<h3 id=parallel-authorizers>并行鉴权 </h3>
<p>同时运行 RBAC 和 ABAC 鉴权模式, 并指定包含
<a href=/zh/docs/reference/access-authn-authz/abac/#policy-file-format>现有的 ABAC 策略</a>
的策略文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--authorization-mode<span style=color:#666>=</span>RBAC,ABAC --authorization-policy-file<span style=color:#666>=</span>mypolicy.json
</code></pre></div>
<p>关于命令行中的第一个选项：如果早期的鉴权组件，例如 Node，拒绝了某个请求，则
RBAC 鉴权组件尝试对该 API 请求鉴权。如果 RBAC 也拒绝了该 API 请求，则运行 ABAC
鉴权组件。这意味着被 RBAC 或 ABAC 策略所允许的任何请求都是被允许的请求。</p>
<p>如果 API 服务器启动时，RBAC 组件的日志级别为 5 或更高（<code>--vmodule=rbac*=5</code> 或 <code>--v=5</code>），
你可以在 API 服务器的日志中看到 RBAC 的细节 （前缀 <code>RBAC:</code>）
你可以使用这些信息来确定需要将哪些角色授予哪些用户、组或服务帐户。</p>
<p>一旦你<a href=#service-account-permissions>将角色授予服务账户</a> ，工作负载运行时
在服务器日志中没有出现 RBAC 拒绝消息，就可以删除 ABAC 鉴权器。</p>
<h2 id=permissive-rbac-permissions>宽松的 RBAC 权限 </h2>
<p>你可以使用 RBAC 角色绑定在多个场合使用宽松的策略。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告：</strong>
<p>下面的策略允许 <strong>所有</strong> 服务帐户充当集群管理员。
容器中运行的所有应用程序都会自动收到服务帐户的凭据，可以对 API 执行任何操作，
包括查看 Secrets 和修改权限。这一策略是不被推荐的。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding permissive-binding <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --user<span style=color:#666>=</span>admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --user<span style=color:#666>=</span>kubelet <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</code></pre></div>
</div>
<p>在你完成到 RBAC 的迁移后，应该调整集群的访问控制，确保相关的策略满足你的
信息安全需求。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9cbb97d4d9f08d67931a1baae4e6519c>3.9 - 使用 Node 鉴权</h1>
<p>节点鉴权是一种特殊用途的鉴权模式，专门对 kubelet 发出的 API 请求进行鉴权。</p>
<h2 id=概述>概述</h2>
<p>节点鉴权器允许 kubelet 执行 API 操作。包括：</p>
<p>读取操作：</p>
<ul>
<li>services</li>
<li>endpoints</li>
<li>nodes</li>
<li>pods</li>
<li>secrets、configmaps、pvcs 以及绑定到 kubelet 节点的与 pod 相关的持久卷</li>
</ul>
<p>写入操作：</p>
<ul>
<li>节点和节点状态（启用 <code>NodeRestriction</code> 准入插件以限制 kubelet 只能修改自己的节点）</li>
<li>Pod 和 Pod 状态 (启用 <code>NodeRestriction</code> 准入插件以限制 kubelet 只能修改绑定到自身的 Pod)</li>
<li>事件</li>
</ul>
<p>鉴权相关操作：</p>
<ul>
<li>对于基于 TLS 的启动引导过程时使用的 certificationsigningrequests API 的读/写权限</li>
<li>为委派的身份验证/授权检查创建 tokenreviews 和 subjectaccessreviews 的能力</li>
</ul>
<p>在将来的版本中，节点鉴权器可能会添加或删除权限，以确保 kubelet 具有正确操作所需的最小权限集。</p>
<p>为了获得节点鉴权器的授权，kubelet 必须使用一个凭证以表示它在 <code>system:nodes</code> 组中，用户名为 <code>system:node:&lt;nodeName></code>。
上述的组名和用户名格式要与 <a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLS 启动引导</a>过程中为每个 kubelet 创建的标识相匹配。</p>
<p>要启用节点授权器，请使用 <code>--authorization-mode = Node</code> 启动 apiserver。</p>
<p>要限制 kubelet 具有写入权限的 API 对象，请使用 <code>--enable-admission-plugins=...,NodeRestriction,...</code> 启动 apiserver，从而启用 <a href=/zh/docs/reference/access-authn-authz/admission-controllers#NodeRestriction>NodeRestriction</a> 准入插件。</p>
<h2 id=迁移考虑因素>迁移考虑因素</h2>
<h3 id=在-system-nodes-组之外的-kubelet>在 <code>system:nodes</code> 组之外的 Kubelet</h3>
<p><code>system:nodes</code> 组之外的 kubelet 不会被 <code>Node</code> 鉴权模式授权，并且需要继续通过当前授权它们的机制来授权。
节点准入插件不会限制来自这些 kubelet 的请求。</p>
<h3 id=具有无差别用户名的-kubelet>具有无差别用户名的 Kubelet</h3>
<p>在一些部署中，kubelet 具有 <code>system:nodes</code> 组的凭证，但是无法给出它们所关联的节点的标识，因为它们没有 <code>system:node:...</code> 格式的用户名。
这些 kubelet 不会被 <code>Node</code> 授权模式授权，并且需要继续通过当前授权它们的任何机制来授权。</p>
<p>因为默认的节点标识符实现不会把它当作节点身份标识，<code>NodeRestriction</code> 准入插件会忽略来自这些 kubelet 的请求。</p>
<h3 id=相对于以前使用-rbac-的版本的更新>相对于以前使用 RBAC 的版本的更新</h3>
<p>升级的 1.7 之前的使用 <a href=/zh/docs/reference/access-authn-authz/rbac/>RBAC</a> 的集群将继续按原样运行，因为 <code>system:nodes</code> 组绑定已经存在。</p>
<p>如果集群管理员希望开始使用 <code>Node</code> 鉴权器和 <code>NodeRestriction</code> 准入插件来限制节点对 API 的访问，这一需求可以通过下列操作来完成且不会影响已部署的应用：</p>
<ol>
<li>启用 <code>Node</code> 鉴权模式 (<code>--authorization-mode=Node,RBAC</code>) 和 <code>NodeRestriction</code> 准入插件</li>
<li>确保所有 kubelet 的凭据符合组/用户名要求</li>
<li>审核 apiserver 日志以确保 <code>Node</code> 鉴权器不会拒绝来自 kubelet 的请求（日志中没有持续的 <code>NODE DENY</code> 消息）</li>
<li>删除 <code>system:node</code> 集群角色绑定</li>
</ol>
<h3 id=rbac-节点权限>RBAC 节点权限</h3>
<p>在 1.6 版本中，当使用 <a href=/zh/docs/reference/access-authn-authz/rbac/>RBAC 鉴权模式</a> 时，<code>system:nodes</code> 集群角色会被自动绑定到 <code>system:node</code> 组。</p>
<p>在 1.7 版本中，不再推荐将 <code>system:nodes</code> 组自动绑定到 <code>system:node</code> 角色，因为节点鉴权器通过对 secret 和 configmap 访问的额外限制完成了相同的任务。
如果同时启用了 <code>Node</code> 和 <code>RBAC</code> 授权模式，1.7 版本则不会创建 <code>system:nodes</code> 组到 <code>system:node</code> 角色的自动绑定。</p>
<p>在 1.8 版本中，绑定将根本不会被创建。</p>
<p>使用 RBAC 时，将继续创建 <code>system:node</code> 集群角色，以便与将其他用户或组绑定到该角色的部署方法兼容。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-215c25173044b8f97e9b0494b0c7e53f>3.10 - Webhook 模式</h1>
<p>WebHook 是一种 HTTP 回调：某些条件下触发的 HTTP POST 请求；通过 HTTP POST 发送的简单事件通知。一个基于 web 应用实现的 WebHook 会在特定事件发生时把消息发送给特定的 URL。</p>
<p>具体来说，当在判断用户权限时，<code>Webhook</code> 模式会使 Kubernetes 查询外部的 REST 服务。</p>
<h2 id=配置文件格式>配置文件格式</h2>
<p><code>Webhook</code> 模式需要一个 HTTP 配置文件，通过 <code>--authorization-webhook-config-file=SOME_FILENAME</code> 的参数声明。</p>
<p>配置文件的格式使用 <a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig</a>。在文件中，"users" 代表着 API 服务器的 webhook，而 "cluster" 代表着远程服务。</p>
<p>使用 HTTPS 客户端认证的配置例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># Kubernetes API 版本</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># API 对象种类</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># clusters 代表远程服务。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-remote-authz-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 对远程服务进行身份认证的 CA。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/path/to/ca.pem<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 远程服务的查询 URL。必须使用 &#39;https&#39;。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://authz.example.com/authorize<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># users 代表 API 服务器的 webhook 配置</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/path/to/cert.pem<span style=color:#bbb> </span><span style=color:#080;font-style:italic># webhook plugin 使用 cert</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/path/to/key.pem         <span style=color:#bbb> </span><span style=color:#080;font-style:italic># cert 所对应的 key</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kubeconfig 文件必须有 context。需要提供一个给 API 服务器。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>name-of-remote-authz-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span></code></pre></div>
<h2 id=请求载荷>请求载荷</h2>
<p>在做认证决策时，API 服务器会 POST 一个 JSON 序列化的 <code>authorization.k8s.io/v1beta1</code> <code>SubjectAccessReview</code> 对象来描述这个动作。这个对象包含了描述用户请求的字段，同时也包含了需要被访问资源或请求特征的具体信息。</p>
<p>需要注意的是 webhook API 对象与其他 Kubernetes API 对象一样都同样都服从<a href=/zh/docs/concepts/overview/kubernetes-api/>版本兼容规则</a>。实施人员应该了解 beta 对象的更宽松的兼容性承诺，同时确认请求的 "apiVersion" 字段能被正确地反序列化。此外，API 服务器还必须启用 <code>authorization.k8s.io/v1beta1</code> API 扩展组 (<code>--runtime-config=authorization.k8s.io/v1beta1=true</code>)。</p>
<p>一个请求内容的例子：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;resourceAttributes&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;kittensandponies&#34;</span>,
      <span style=color:green;font-weight:700>&#34;verb&#34;</span>: <span style=color:#b44>&#34;get&#34;</span>,
      <span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;unicorn.example.org&#34;</span>,
      <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;jane&#34;</span>,
    <span style=color:green;font-weight:700>&#34;group&#34;</span>: [
      <span style=color:#b44>&#34;group1&#34;</span>,
      <span style=color:#b44>&#34;group2&#34;</span>
    ]
  }
}
</code></pre></div>
<p>期待远程服务填充请求的 <code>status</code> 字段并响应允许或禁止访问。响应主体的 <code>spec</code> 字段被忽略，可以省略。允许的响应将返回:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
  }
}
</code></pre></div>
<p>为了禁止访问，有两种方法。</p>
<p>在大多数情况下，第一种方法是首选方法，它指示授权 webhook 不允许或对请求"无意见"，但是，如果配置了其他授权者，则可以给他们机会允许请求。如果没有其他授权者，或者没有一个授权者，则该请求被禁止。webhook 将返回:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>,
    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;user does not have read access to the namespace&#34;</span>
  }
}
</code></pre></div>
<p>第二种方法立即拒绝其他配置的授权者进行短路评估。仅应由对集群的完整授权者配置有详细了解的 webhook 使用。webhook 将返回:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>,
    <span style=color:green;font-weight:700>&#34;denied&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;user does not have read access to the namespace&#34;</span>
  }
}
</code></pre></div>
<p>对于非资源的路径访问是这么发送的:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;nonResourceAttributes&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;path&#34;</span>: <span style=color:#b44>&#34;/debug&#34;</span>,
      <span style=color:green;font-weight:700>&#34;verb&#34;</span>: <span style=color:#b44>&#34;get&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;jane&#34;</span>,
    <span style=color:green;font-weight:700>&#34;group&#34;</span>: [
      <span style=color:#b44>&#34;group1&#34;</span>,
      <span style=color:#b44>&#34;group2&#34;</span>
    ]
  }
}
</code></pre></div>
<p>非资源类的路径包括：<code>/api</code>, <code>/apis</code>, <code>/metrics</code>, <code>/resetMetrics</code>,
<code>/logs</code>, <code>/debug</code>, <code>/healthz</code>, <code>/swagger-ui/</code>, <code>/swaggerapi/</code>, <code>/ui</code>, 和
<code>/version</code>。客户端需要访问 <code>/api</code>, <code>/api/*</code>, <code>/apis</code>, <code>/apis/*</code>, 和 <code>/version</code> 以便
能发现服务器上有什么资源和版本。对于其他非资源类的路径访问在没有 REST API 访问限制的情况下拒绝。</p>
<p>更多信息可以参考 authorization.v1beta1 API 对象和<a href=https://github.com/kubernetes/kubernetes/blob/v1.22.16/staging/src/k8s.io/apiserver/plugin/pkg/authorizer/webhook/webhook.go>webhook.go</a>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a5bdc757c01991e5e6ab1a82b90639ea>3.11 - 使用 ABAC 鉴权</h1>
<p>基于属性的访问控制（Attribute-based access control - ABAC）定义了访问控制范例，其中通过使用将属性组合在一起的策略来向用户授予访问权限。</p>
<h2 id=策略文件格式>策略文件格式</h2>
<p>基于 <code>ABAC</code> 模式，可以这样指定策略文件 <code>--authorization-policy-file=SOME_FILENAME</code>。</p>
<p>此文件格式是 <a href=https://jsonlines.org/>JSON Lines</a>，不应存在封闭的列表或映射，每行一个映射。</p>
<p>每一行都是一个策略对象，策略对象是具有以下属性的映射：</p>
<ul>
<li>版本控制属性：
<ul>
<li><code>apiVersion</code>，字符串类型：有效值为<code>abac.authorization.kubernetes.io/v1beta1</code>，允许对策略格式进行版本控制和转换。</li>
<li><code>kind</code>，字符串类型：有效值为 <code>Policy</code>，允许对策略格式进行版本控制和转换。</li>
</ul>
</li>
<li><code>spec</code> 配置为具有以下映射的属性：
<ul>
<li>主体匹配属性：
<ul>
<li><code>user</code>，字符串类型；来自 <code>--token-auth-file</code> 的用户字符串，如果你指定 <code>user</code>，它必须与验证用户的用户名匹配。</li>
<li><code>group</code>，字符串类型；如果指定 <code>group</code>，它必须与经过身份验证的用户的一个组匹配，<code>system:authenticated</code>匹配所有经过身份验证的请求。<code>system:unauthenticated</code>匹配所有未经过身份验证的请求。</li>
</ul>
</li>
</ul>
</li>
<li>资源匹配属性：
<ul>
<li><code>apiGroup</code>，字符串类型；一个 API 组。
<ul>
<li>例： <code>extensions</code></li>
<li>通配符：<code>*</code>匹配所有 API 组。</li>
</ul>
</li>
<li><code>namespace</code>，字符串类型；一个命名空间。
<ul>
<li>例如：<code>kube-system</code></li>
<li>通配符：<code>*</code>匹配所有资源请求。</li>
</ul>
</li>
<li><code>resource</code>，字符串类型；资源类型。
<ul>
<li>例：<code>pods</code></li>
<li>通配符：<code>*</code>匹配所有资源请求。</li>
</ul>
</li>
</ul>
</li>
<li>非资源匹配属性：
<ul>
<li><code>nonResourcePath</code>，字符串类型；非资源请求路径。
<ul>
<li>例如：<code>/version</code>或 <code>/apis</code></li>
<li>通配符：
<ul>
<li><code>*</code> 匹配所有非资源请求。</li>
<li><code>/foo/*</code> 匹配 <code>/foo/</code> 的所有子路径。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>readonly</code>，键入布尔值，如果为 true，则表示该策略仅适用于 get、list 和 watch 操作。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>属性未设置等效于属性被设置为对应类型的零值( 例如空字符串、0、false)，然而，出于可读性考虑，应尽量选择不设置这类属性。</p>
<p>在将来，策略可能以 JSON 格式表示，并通过 REST 界面进行管理。</p>
</div>
<h2 id=鉴权算法>鉴权算法</h2>
<p>请求具有与策略对象的属性对应的属性。</p>
<p>当接收到请求时，确定属性。未知属性设置为其类型的零值（例如：空字符串，0，false）。</p>
<p>设置为 <code>"*"</code> 的属性将匹配相应属性的任何值。</p>
<p>检查属性的元组，以匹配策略文件中的每个策略。如果至少有一行匹配请求属性，则请求被鉴权（但仍可能无法通过稍后的合法性检查）。</p>
<p>要允许任何经过身份验证的用户执行某些操作，请将策略组属性设置为 <code>"system:authenticated"</code>。</p>
<p>要允许任何未经身份验证的用户执行某些操作，请将策略组属性设置为 <code>"system:authentication"</code>。</p>
<p>要允许用户执行任何操作，请使用 apiGroup，命名空间，
资源和 nonResourcePath 属性设置为 <code>"*"</code> 的策略。</p>
<p>要允许用户执行任何操作，请使用设置为 <code>"*"</code> 的 apiGroup，namespace，resource 和 nonResourcePath 属性编写策略。</p>
<h2 id=kubectl>Kubectl</h2>
<p>Kubectl 使用 api-server 的 <code>/api</code> 和 <code>/apis</code> 端点来发现服务资源类型，并使用位于 <code>/openapi/v2</code> 的模式信息来验证通过创建/更新操作发送到 API 的对象。</p>
<p>当使用 ABAC 鉴权时，这些特殊资源必须显式地通过策略中的 <code>nonResourcePath</code> 属性暴露出来（参见下面的 <a href=#examples>示例</a>）：</p>
<ul>
<li><code>/api</code>，<code>/api/*</code>，<code>/apis</code>和 <code>/apis/*</code> 用于 API 版本协商。</li>
<li><code>/version</code> 通过 <code>kubectl version</code> 检索服务器版本。</li>
<li><code>/swaggerapi/*</code> 用于创建 / 更新操作。</li>
</ul>
<p>要检查涉及到特定 kubectl 操作的 HTTP 调用，您可以调整详细程度：
kubectl --v=8 version</p>
<h2 id=examples>例子</h2>
<ol>
<li>
<p>Alice 可以对所有资源做任何事情：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;alice&#34;</span>, <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>, <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>, <span style=color:green;font-weight:700>&#34;apiGroup&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>}}
</code></pre></div></li>
<li>
<p>Kubelet 可以读取任何 pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;kubelet&#34;</span>, <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>, <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>, <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}}
</code></pre></div></li>
<li>
<p>Kubelet 可以读写事件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;kubelet&#34;</span>, <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>, <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;events&#34;</span>}}
</code></pre></div></li>
</ol>
<ol start=4>
<li>
<p>Bob 可以在命名空间 <code>projectCaribou</code> 中读取 pod：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;bob&#34;</span>, <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;projectCaribou&#34;</span>, <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>, <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}}
</code></pre></div></li>
<li>
<p>任何人都可以对所有非资源路径进行只读请求：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;system:authenticated&#34;</span>, <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>, <span style=color:green;font-weight:700>&#34;nonResourcePath&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>}}
{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;system:unauthenticated&#34;</span>, <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>, <span style=color:green;font-weight:700>&#34;nonResourcePath&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>}}
</code></pre></div></li>
</ol>
<p><a href=https://releases.k8s.io/v1.22.16/pkg/auth/authorizer/abac/example_policy_file.jsonl>完整文件示例</a></p>
<h2 id=服务帐户的快速说明>服务帐户的快速说明</h2>
<p>服务帐户自动生成用户。用户名是根据命名约定生成的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>system:serviceaccount:&lt;namespace&gt;:&lt;serviceaccountname&gt;
</code></pre></div>
<p>创建新的命名空间也会导致创建一个新的服务帐户：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>system:serviceaccount:&lt;namespace&gt;:default
</code></pre></div><p>例如，如果要将 API 的 kube-system 完整权限中的默认服务帐户授予，则可以将此行添加到策略文件中：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>,<span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Policy&#34;</span>,<span style=color:green;font-weight:700>&#34;spec&#34;</span>:{<span style=color:green;font-weight:700>&#34;user&#34;</span>:<span style=color:#b44>&#34;system:serviceaccount:kube-system:default&#34;</span>,<span style=color:green;font-weight:700>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;*&#34;</span>,<span style=color:green;font-weight:700>&#34;resource&#34;</span>:<span style=color:#b44>&#34;*&#34;</span>,<span style=color:green;font-weight:700>&#34;apiGroup&#34;</span>:<span style=color:#b44>&#34;*&#34;</span>}}
</code></pre></div><p>需要重新启动 apiserver 以获取新的策略行。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-232c8c895125744f56a31038ab6fa4e9>4 - 常见的标签、注解和污点</h1>
<p>Kubernetes 预留命名空间 kubernetes.io 用于所有的标签和注解。</p>
<p>本文档有两个作用，一是作为可用值的参考，二是作为赋值的协调点。</p>
<h2 id=kubernetes-io-arch>kubernetes.io/arch</h2>
<p>示例：<code>kubernetes.io/arch=amd64</code></p>
<p>用于：Node</p>
<p>Kubelet 用 Go 定义的 <code>runtime.GOARCH</code> 生成该标签的键值。在混合使用 arm 和 x86 节点的场景中，此键值可以带来极大便利。</p>
<h2 id=kubernetes-io-os>kubernetes.io/os</h2>
<p>示例：<code>kubernetes.io/os=linux</code></p>
<p>用于：Node</p>
<p>Kubelet 用 Go 定义的 <code>runtime.GOOS</code> 生成该标签的键值。在混合使用异构操作系统场景下（例如：混合使用 Linux 和 Windows 节点），此键值可以带来极大便利。</p>
<h2 id=kubernetes-io-metadata-name>kubernetes.io/metadata.name</h2>
<p>示例：<code>kubernetes.io/metadata.name=mynamespace</code></p>
<p>用于：Namespaces</p>
<p>当 <code>NamespaceDefaultLabelName</code> <a href=/zh/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
被启用时，Kubernetes API 服务器会在所有命名空间上设置此标签。标签值被设置为命名空间的名称。</p>
<p>如果你想使用标签 <a class=glossary-tooltip title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=选择器>选择器</a> 来指向特定的命名空间，这很有用。</p>
<h2 id=beta-kubernetes-io-arch-deprecated>beta.kubernetes.io/arch (deprecated)</h2>
<p>此标签已被弃用，取而代之的是 <code>kubernetes.io/arch</code>.</p>
<h2 id=beta-kubernetes-io-os-deprecated>beta.kubernetes.io/os (deprecated)</h2>
<p>此标签已被弃用，取而代之的是 <code>kubernetes.io/os</code>.</p>
<h2 id=kubernetesiohostname>kubernetes.io/hostname</h2>
<p>示例：<code>kubernetes.io/hostname=ip-172-20-114-199.ec2.internal</code></p>
<p>用于：Node</p>
<p>Kubelet 用主机名生成此标签。需要注意的是主机名可修改，这是把“实际的”主机名通过参数 <code>--hostname-override</code> 传给 <code>kubelet</code> 实现的。</p>
<p>此标签也可用做拓扑层次的一个部分。更多信息参见<a href=#topologykubernetesiozone>topology.kubernetes.io/zone</a>。</p>
<h2 id=pod-deletion-cost>controller.kubernetes.io/pod-deletion-cost</h2>
<p>示例：<code>controller.kubernetes.io/pod-deletion-cost=10</code></p>
<p>用于：Pod</p>
<p>该注解用于设置 <a href=/zh/docs/concepts/workloads/controllers/replicaset/#pod-deletion-cost>Pod 删除开销</a>，
允许用户影响 ReplicaSet 的缩减顺序。该注解解析为 <code>int32</code> 类型。</p>
<h2 id=beta-kubernetes-io-instance-type-deprecated>beta.kubernetes.io/instance-type (deprecated)</h2>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>从 v1.17 起，此标签被弃用，取而代之的是 <a href=#nodekubernetesioinstance-type>node.kubernetes.io/instance-type</a>.
</div>
<h2 id=nodekubernetesioinstance-type>node.kubernetes.io/instance-type</h2>
<p>示例：<code>node.kubernetes.io/instance-type=m3.medium</code></p>
<p>用于：Node</p>
<p>Kubelet 用 <code>cloudprovider</code> 定义的实例类型生成此标签。
所以只有用到 <code>cloudprovider</code> 的场合，才会设置此标签。
此标签非常有用，特别是在你希望把特定工作负载打到特定实例类型的时候，但更常见的调度方法是基于 Kubernetes 调度器来执行基于资源的调度。
你应该聚焦于使用基于属性的调度方式，而尽量不要依赖实例类型（例如：应该申请一个 GPU，而不是 <code>g2.2xlarge</code>）。</p>
<h2 id=failure-domainbetakubernetesioregion>failure-domain.beta.kubernetes.io/region (deprecated)</h2>
<p>参见 <a href=#topologykubernetesioregion>topology.kubernetes.io/region</a>.</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>从 v1.17 开始，此标签被弃用，取而代之的是 <a href=#topologykubernetesioregion>topology.kubernetes.io/region</a>.
</div>
<h2 id=failure-domainbetakubernetesiozone>failure-domain.beta.kubernetes.io/zone (deprecated)</h2>
<p>参见 <a href=#topologykubernetesiozone>topology.kubernetes.io/zone</a>.</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>从 v1.17 开始，此标签被弃用，取而代之的是 <a href=#topologykubernetesiozone>topology.kubernetes.io/zone</a>.
</div>
<h2 id=statefulsetkubernetesiopod-name>statefulset.kubernetes.io/pod-name</h2>
<p>示例：<code>statefulset.kubernetes.io/pod-name=mystatefulset-7</code></p>
<p>当 StatefulSet 控制器为 StatefulSet 创建 Pod 时，控制平面会在该 Pod 上设置此标签。
标签的值是正在创建的 Pod 的名称。</p>
<p>更多细节请参见 StatefulSet 文章中的 <a href=/zh/docs/concepts/workloads/controllers/statefulset/#pod-name-label>Pod 名称标签</a>。</p>
<h2 id=topologykubernetesioregion>topology.kubernetes.io/region</h2>
<p>示例</p>
<p><code>topology.kubernetes.io/region=us-east-1</code></p>
<p>参见 <a href=#topologykubernetesiozone>topology.kubernetes.io/zone</a>.</p>
<h2 id=topologykubernetesiozone>topology.kubernetes.io/zone</h2>
<p>示例:</p>
<p><code>topology.kubernetes.io/zone=us-east-1c</code></p>
<p>用于：Node, PersistentVolume</p>
<p>Node 场景：<code>kubelet</code> 或外部的 <code>cloud-controller-manager</code> 用 <code>cloudprovider</code> 提供的信息生成此标签。
所以只有在用到 <code>cloudprovider</code> 的场景下，此标签才会被设置。
但如果此标签在你的拓扑中有意义，你也可以考虑在 node 上设置它。</p>
<p>PersistentVolume 场景：拓扑自感知的卷制备程序将在 <code>PersistentVolumes</code> 上自动设置节点亲和性限制。</p>
<p>一个可用区（zone）表示一个逻辑故障域。Kubernetes 集群通常会跨越多个可用区以提高可用性。
虽然可用区的确切定义留给基础设施来决定，但可用区常见的属性包括：可用区内的网络延迟非常低，可用区内的网络通讯没成本，独立于其他可用区的故障域。
例如，一个可用区中的节点可以共享交换机，但不同可用区则不会。</p>
<p>一个地区（region）表示一个更大的域，由一个到多个可用区组成。对于 Kubernetes 来说，跨越多个地区的集群很罕见。
虽然可用区和地区的确切定义留给基础设施来决定，但地区的常见属性包括：地区间比地区内更高的网络延迟，地区间网络流量更高的成本，独立于其他可用区或是地区的故障域。例如，一个地区内的节点可以共享电力基础设施（例如 UPS 或发电机），但不同地区内的节点显然不会。</p>
<p>Kubernetes 对可用区和地区的结构做出一些假设：
1）地区和可用区是层次化的：可用区是地区的严格子集，任何可用区都不能再 2 个地区中出现。
2）可用区名字在地区中独一无二：例如地区 "africa-east-1" 可由可用区 "africa-east-1a" 和 "africa-east-1b" 构成。</p>
<p>你可以安全的假定拓扑类的标签是固定不变的。即使标签严格来说是可变的，但使用者依然可以假定一个节点只有通过销毁、重建的方式，才能在可用区间移动。</p>
<p>Kubernetes 能以多种方式使用这些信息。
例如，调度器自动地尝试将 ReplicaSet 中的 Pod 打散在单可用区集群的不同节点上（以减少节点故障的影响，参见<a href=#kubernetesiohostname>kubernetes.io/hostname</a>）。
在多可用区的集群中，这类打散分布的行为也会应用到可用区（以减少可用区故障的影响）。
做到这一点靠的是 <em>SelectorSpreadPriority</em>。</p>
<p><em>SelectorSpreadPriority</em> 是一种最大能力分配方法（best effort）。如果集群中的可用区是异构的（例如：不同数量的节点，不同类型的节点，或不同的 Pod 资源需求），这种分配方法可以防止平均分配 Pod 到可用区。如果需要，你可以用同构的可用区（相同数量和类型的节点）来减少潜在的不平衡分布。</p>
<p>调度器（通过 <em>VolumeZonePredicate</em> 的预测）也会保障声明了某卷的 Pod 只能分配到该卷相同的可用区。
卷不支持跨可用区挂载。</p>
<p>如果 <code>PersistentVolumeLabel</code> 不支持给 PersistentVolume 自动打标签，你可以考虑手动加标签（或增加 <code>PersistentVolumeLabel</code> 支持）。
有了 <code>PersistentVolumeLabel</code>，调度器可以防止 Pod 挂载不同可用区中的卷。
如果你的基础架构没有此限制，那你根本就没有必要给卷增加 zone 标签。</p>
<h2 id=nodekubernetesiowindows-build>node.kubernetes.io/windows-build</h2>
<p>示例: <code>node.kubernetes.io/windows-build=10.0.17763</code></p>
<p>用于：Node</p>
<p>当 kubelet 运行于 Microsoft Windows，它给节点自动打标签，以记录 Windows Server 的版本。</p>
<p>标签值的格式为 "主版本.次版本.构建号"</p>
<h2 id=servicekubernetesioheadless>service.kubernetes.io/headless</h2>
<p>示例：<code>service.kubernetes.io/headless=""</code></p>
<p>用于：Service</p>
<p>在无头（headless）服务的场景下，控制平面为 Endpoint 对象添加此标签。</p>
<h2 id=kubernetesioservice-name>kubernetes.io/service-name</h2>
<p>示例：<code>kubernetes.io/service-name="nginx"</code></p>
<p>用于：Service</p>
<p>Kubernetes 用此标签区分多个服务。当前仅用于 <code>ELB</code>(Elastic Load Balancer)。</p>
<h2 id=endpointslicekubernetesiomanaged-by>endpointslice.kubernetes.io/managed-by</h2>
<p>示例：<code>endpointslice.kubernetes.io/managed-by="controller"</code></p>
<p>用于：EndpointSlices</p>
<p>此标签用来指向管理 EndpointSlice 的控制器或实体。
此标签的目的是用集群中不同的控制器或实体来管理不同的 EndpointSlice。</p>
<h2 id=endpointslicekubernetesioskip-mirror>endpointslice.kubernetes.io/skip-mirror</h2>
<p>示例：<code>endpointslice.kubernetes.io/skip-mirror="true"</code></p>
<p>用于：Endpoints</p>
<p>此标签在 Endpoints 资源上设为 <code>"true"</code> 指示 EndpointSliceMirroring 控制器不要镜像此 EndpointSlices 资源。</p>
<h2 id=servicekubernetesioservice-proxy-name>service.kubernetes.io/service-proxy-name</h2>
<p>示例：<code>service.kubernetes.io/service-proxy-name="foo-bar"</code></p>
<p>用于：Service</p>
<p>kube-proxy 把此标签用于客户代理，将服务控制委托给客户代理。</p>
<h2 id=experimental-windows-kubernetes-io-isolation-type>experimental.windows.kubernetes.io/isolation-type</h2>
<p>示例：<code>experimental.windows.kubernetes.io/isolation-type: "hyperv"</code></p>
<p>用于：Pod</p>
<p>此注解用于运行 Hyper-V 隔离的 Windows 容器。
要使用 Hyper-V 隔离特性，并创建 Hyper-V 隔离容器，kubelet 应该用特性门控 HyperVContainer=true 来启动，并且 Pod 应该包含注解 <code>experimental.windows.kubernetes.io/isolation-type=hyperv</code>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 你只能在单容器 Pod 上设置此注解。
</div>
<h2 id=ingressclass-kubernetes-io-is-default-class>ingressclass.kubernetes.io/is-default-class</h2>
<p>示例：<code>ingressclass.kubernetes.io/is-default-class: "true"</code></p>
<p>用于：IngressClass</p>
<p>当唯一的 IngressClass 资源将此注解的值设为 "true"，没有指定类型的新 Ingress 资源将使用此默认类型。</p>
<h2 id=kubernetes-io-ingress-class-deprecated>kubernetes.io/ingress.class (deprecated)</h2>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>从 v1.18 开始，此注解被弃用，取而代之的是 <code>spec.ingressClassName</code>。
</div>
<h2 id=storageclass-kubernetes-io-is-default-class>storageclass.kubernetes.io/is-default-class</h2>
<p>示例：<code>storageclass.kubernetes.io/is-default-class=true</code></p>
<p>用于：StorageClass</p>
<p>当单个的 StorageClass 资源将这个注解设置为 <code>"true"</code> 时，新的持久卷申领（PVC）
资源若未指定类别，将被设定为此默认类别。</p>
<h2 id=alpha-kubernetes-io-provided-node-ip>alpha.kubernetes.io/provided-node-ip</h2>
<p>示例：<code>alpha.kubernetes.io/provided-node-ip: "10.0.0.1"</code></p>
<p>用于：Node</p>
<p>kubectl 在 Node 上设置此注解，表示它的 IPv4 地址。</p>
<p>当 kubectl 由外部的云供应商启动时，在 Node 上设置此注解，表示由命令行标记(<code>--node-ip</code>)设置的 IP 地址。
cloud-controller-manager 向云供应商验证此 IP 是否有效。</p>
<h2 id=batch-kubernetes-io-job-completion-index>batch.kubernetes.io/job-completion-index</h2>
<p>示例：<code>batch.kubernetes.io/job-completion-index: "3"</code></p>
<p>用于：Pod</p>
<p>kube-controller-manager 中的 Job 控制器给创建使用索引
<a href=/zh/docs/concepts/workloads/controllers/job/#completion-mode>完成模式</a>
的 Pod 设置此注解。</p>
<h2 id=kubectl-kubernetes-io-default-container>kubectl.kubernetes.io/default-container</h2>
<p>示例：<code>kubectl.kubernetes.io/default-container: "front-end-app"</code></p>
<p>注解的值是此 Pod 的默认容器名称。
例如，<code>kubectl logs</code> 或 <code>kubectl exec</code> 没有 <code>-c</code> 或 <code>--container</code> 参数时，将使用这个默认的容器。</p>
<h2 id=endpoints-kubernetes-io-over-capacity>endpoints.kubernetes.io/over-capacity</h2>
<p>示例：<code>endpoints.kubernetes.io/over-capacity:warning</code></p>
<p>用于：Endpoints</p>
<p>在 Kubernetes 集群 v1.21（或更高版本）中，如果 Endpoint 超过 1000 个，Endpoint 控制器
就会向其添加这个注解。该注解表示 Endpoint 资源已超过容量。</p>
<p><strong>以下列出的污点只能用于 Node</strong></p>
<h2 id=node-kubernetes-io-not-ready>node.kubernetes.io/not-ready</h2>
<p>示例：<code>node.kubernetes.io/not-ready:NoExecute</code></p>
<p>节点控制器通过健康监控来检测节点是否就绪，并据此添加/删除此污点。</p>
<h2 id=node-kubernetes-io-unreachable>node.kubernetes.io/unreachable</h2>
<p>示例：<code>node.kubernetes.io/unreachable:NoExecute</code></p>
<p>如果 <a href=/docs/concepts/architecture/nodes/#condition>NodeCondition</a> 的 <code>Ready</code> 键值为 <code>Unknown</code>，节点控制器将添加污点到 node。</p>
<h2 id=node-kubernetes-io-unschedulable>node.kubernetes.io/unschedulable</h2>
<p>示例：<code>node.kubernetes.io/unschedulable:NoSchedule</code></p>
<p>当初始化节点时，添加此污点，来避免竟态的发生。</p>
<h2 id=node-kubernetes-io-memory-pressure>node.kubernetes.io/memory-pressure</h2>
<p>示例：<code>node.kubernetes.io/memory-pressure:NoSchedule</code></p>
<p>kubelet 依据节点上观测到的 <code>memory.available</code> 和 <code>allocatableMemory.available</code> 来检测内存压力。
用观测值对比 kubelet 设置的阈值，以判断节点状态和污点是否可以被添加/移除。</p>
<h2 id=node-kubernetes-io-disk-pressure>node.kubernetes.io/disk-pressure</h2>
<p>示例：<code>node.kubernetes.io/disk-pressure:NoSchedule</code></p>
<p>kubelet 依据节点上观测到的 <code>imagefs.available</code>、<code>imagefs.inodesFree</code>、<code>nodefs.available</code> 和 <code>nodefs.inodesFree</code>(仅 Linux) 来判断磁盘压力。
用观测值对比 kubelet 设置的阈值，以确定节点状态和污点是否可以被添加/移除。</p>
<h2 id=node-kubernetes-io-network-unavailable>node.kubernetes.io/network-unavailable</h2>
<p>示例：<code>node.kubernetes.io/network-unavailable:NoSchedule</code></p>
<p>它初始由 kubectl 设置，云供应商用它来指示对额外网络配置的需求。
仅当云中的路由器配置妥当后，云供应商才会移除此污点。</p>
<h2 id=node-kubernetes-io-pid-pressure>node.kubernetes.io/pid-pressure</h2>
<p>示例：<code>node.kubernetes.io/pid-pressure:NoSchedule</code></p>
<p>kubelet 检查 <code>/proc/sys/kernel/pid_max</code> 尺寸的 D 值（D-value），以及节点上 Kubernetes 消耗掉的 PID，以获取可用的 PID 数量，此数量可通过指标 <code>pid.available</code> 得到。
然后用此指标对比 kubelet 设置的阈值，以确定节点状态和污点是否可以被添加/移除。</p>
<h2 id=node-cloudprovider-kubernetes-io-uninitialized>node.cloudprovider.kubernetes.io/uninitialized</h2>
<p>示例：<code>node.cloudprovider.kubernetes.io/uninitialized:NoSchedule</code></p>
<p>当 kubelet 由外部云供应商启动时，在节点上设置此污点以标记节点不可用，直到一个 cloud-controller-manager 控制器初始化此节点之后，才会移除此污点。</p>
<h2 id=node-cloudprovider-kubernetes-io-shutdown>node.cloudprovider.kubernetes.io/shutdown</h2>
<p>示例：<code>node.cloudprovider.kubernetes.io/shutdown:NoSchedule</code></p>
<p>如果一个云供应商的节点被指定为关机状态，节点被打上污点 <code>node.cloudprovider.kubernetes.io/shutdown</code>，污点的影响为 <code>NoSchedule</code>。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-60a16da3955f1de774f1f8dd756f2251>5 - Kubernetes API</h1>
<p>Kubernetes API 是通过 RESTful 接口提供 Kubernetes 功能服务并负责集群状态存储的应用程序。</p>
<p>Kubernetes 资源和"意向记录"都是作为 API 对象储存的，并可以通过调用 RESTful 风格的 API 进行修改。
API 允许以声明方式管理配置。
用户可以直接和 Kubernetes API 交互，也可以通过 <code>kubectl</code> 这样的工具进行交互。
核心的 Kubernetes API 是很灵活的，可以扩展以支持定制资源。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-af7c1f9168ec67f957edc504f43faf9a>6 - Kubernetes 问题和安全</h1>
</div>
<div class=td-content>
<h1 id=pg-980c0542a3b195a20cfd4358792e2a38>6.1 - Kubernetes 问题追踪</h1>
<p>要报告安全问题，请遵循
<a href=/zh/docs/reference/issues-security/security/#report-a-vulnerability>Kubernetes 安全问题公开流程</a>。</p>
<p>使用 <a href=https://github.com/kubernetes/kubernetes/issues/>GitHub Issues</a>
跟踪 Kubernetes 编码工作和公开问题。</p>
<ul>
<li><a href="https://github.com/kubernetes/kubernetes/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3Aarea%2Fsecurity+in%3Atitle+CVE">CVE 相关问题</a></li>
</ul>
<p>与安全性相关的公告请发送到
<a href=https://groups.google.com/forum/#!forum/kubernetes-security-announce>kubernetes-security-announce@googlegroups.com</a>
邮件列表。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1f7dc06f1cc1ea2cdde4480e54d5fb34>6.2 - Kubernetes 安全和信息披露</h1>
<p>本页面介绍 Kubernetes 安全和信息披露相关的内容。</p>
<h2 id=安全公告>安全公告</h2>
<p>加入 <a href=https://groups.google.com/forum/#!forum/kubernetes-security-announce>kubernetes-security-announce</a> 组，以获取关于安全性和主要 API 公告的电子邮件。</p>
<p>你也可以使用<a href="https://groups.google.com/forum/feed/kubernetes-security-announce/msgs/rss_v2_0.xml?num=50">此链接</a> 订阅上述的 RSS 反馈。</p>
<h2 id=报告一个漏洞>报告一个漏洞</h2>
<p>我们非常感谢向 Kubernetes 开源社区报告漏洞的安全研究人员和用户。
所有的报告都由社区志愿者进行彻底调查。</p>
<p>如需报告，请连同安全细节以及预期的<a href=https://git.k8s.io/kubernetes/.github/ISSUE_TEMPLATE/bug-report.md>所有 Kubernetes bug 报告</a>
详细信息电子邮件到<a href=mailto:security@kubernetes.io>security@kubernetes.io</a>列表。</p>
<p>你还可以通过电子邮件向私有 <a href=mailto:security@kubernetes.io>security@kubernetes.io</a> 列表发送电子邮件，邮件中应该包含<a href=https://git.k8s.io/kubernetes/.github/ISSUE_TEMPLATE/bug-report.md>所有 Kubernetes 错误报告</a>所需的详细信息。</p>
<p>你可以使用<a href=https://git.k8s.io/security/README.md#product-security-committee-psc>产品安全团队成员</a>
的 GPG 密钥加密你的电子邮件到此列表。使用 GPG 加密不需要公开。</p>
<h3 id=我应该在什么时候报告漏洞>我应该在什么时候报告漏洞？</h3>
<ul>
<li>你认为在 Kubernetes 中发现了一个潜在的安全漏洞</li>
<li>你不确定漏洞如何影响 Kubernetes</li>
<li>你认为你在 Kubernetes 依赖的另一个项目中发现了一个漏洞</li>
<li>对于具有漏洞报告和披露流程的项目，请直接在该项目处报告</li>
</ul>
<h3 id=我什么时候不应该报告漏洞>我什么时候不应该报告漏洞？</h3>
<ul>
<li>你需要帮助调整 Kubernetes 组件的安全性</li>
<li>你需要帮助应用与安全相关的更新</li>
<li>你的问题与安全无关</li>
</ul>
<h2 id=安全漏洞响应>安全漏洞响应</h2>
<p>每个报告在 3 个工作日内由产品安全团队成员确认和分析。这将启动<a href=https://git.k8s.io/sig-release/security-release-process-documentation/security-release-process.md#disclosures>安全发布过程</a>。</p>
<p>与产品安全团队共享的任何漏洞信息都保留在 Kubernetes 项目中，除非有必要修复该问题，否则不会传播到其他项目。</p>
<p>随着安全问题从分类、识别修复、发布计划等方面的进展，我们将不断更新报告。</p>
<h2 id=公开披露时间>公开披露时间</h2>
<p>公开披露日期由 Kubernetes 产品安全团队和 bug 提交者协商。我们倾向于在用户缓解措施可用时尽快完全披露该 bug。</p>
<p>当 bug 或其修复还没有被完全理解，解决方案没有经过良好的测试，或者为了处理供应商协调问题时，延迟披露是合理的。</p>
<p>信息披露的时间范围从即时（尤其是已经公开的）到几周。作为一个基本的约定，我们希望报告日期到披露日期的间隔是 7 天。在设置披露日期时，Kubernetes 产品安全团队拥有最终决定权。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5bbbc5163b35431b3bff029ab9ec57d3>7 - 安装工具</h1>
</div>
<div class=td-content>
<h1 id=pg-f351ced098abbb076bc8c4be1053672b>7.1 - Kubeadm</h1>
<img src=/images/kubeadm-stacked-color.png align=right width=150px>
<p>Kubeadm 是一个提供了 <code>kubeadm init</code> 和 <code>kubeadm join</code> 的工具，
作为创建 Kubernetes 集群的 “快捷途径” 的最佳实践。</p>
<p>kubeadm 通过执行必要的操作来启动和运行最小可用集群。
按照设计，它只关注启动引导，而非配置机器。同样的，
安装各种 “锦上添花” 的扩展，例如 Kubernetes Dashboard、
监控方案、以及特定云平台的扩展，都不在讨论范围内。</p>
<p>相反，我们希望在 kubeadm 之上构建更高级别以及更加合规的工具，
理想情况下，使用 kubeadm 作为所有部署工作的基准将会更加易于创建一致性集群。</p>
<h2 id=如何安装>如何安装</h2>
<p>要安装 kubeadm, 请查阅
<a href=/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/>安装指南</a>.</p>
<h2 id=接下来>接下来</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init>kubeadm init</a>
用于搭建控制平面节点</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join>kubeadm join</a>
用于搭建工作节点并将其加入到集群中</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade>kubeadm upgrade</a>
用于升级 Kubernetes 集群到新版本</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-config>kubeadm config</a>
如果你使用了 v1.7.x 或更低版本的 kubeadm 版本初始化你的集群，则使用
<code>kubeadm upgrade</code> 来配置你的集群</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-token>kubeadm token</a>
用于管理 <code>kubeadm join</code> 使用的令牌</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset>kubeadm reset</a>
用于恢复通过 <code>kubeadm init</code> 或者 <code>kubeadm join</code> 命令对节点进行的任何变更</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-certs>kubeadm certs</a>
用于管理 Kubernetes 证书</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-kubeconfig>kubeadm kubeconfig</a>
用于管理 kubeconfig 文件</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-version>kubeadm version</a>
用于打印 kubeadm 的版本信息</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha>kubeadm alpha</a>
用于预览一组可用于收集社区反馈的特性</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-36c22b52e8447eb3d2452d4f56fbea9b>7.1.1 - 创建 Kubeadm</h1>
</div>
<div class=td-content>
<h1 id=pg-fd3ad295c1f10bfa333f841bbdffba81>7.1.1.1 - </h1>
<h3 id=摘要>摘要</h3>
<pre><code>┌──────────────────────────────────────────────────────────┐
│ KUBEADM                                                  │
│ 轻松创建一个安全的 Kubernetes 集群                       │
│                                                          │
│ 给我们反馈意见的地址：                                   │
│ https://github.com/kubernetes/kubeadm/issues             │
└──────────────────────────────────────────────────────────┘
</code></pre>
<p>用途示例：</p>
<p>创建一个有两台机器的集群，包含一个主节点（用来控制集群），和一个工作节点（运行您的工作负载，像 Pod 和 Deployment）。</p>
<pre><code>┌──────────────────────────────────────────────────────────┐
│ 在第一台机器上：                                         │
├──────────────────────────────────────────────────────────┤
│ control-plane# kubeadm init                              │
└──────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────┐
│ 在第二台机器上：                                         │
├──────────────────────────────────────────────────────────┤
│ worker# kubeadm join &amp;lt;arguments-returned-from-init&amp;gt;│
└──────────────────────────────────────────────────────────┘
</code></pre><p>您可以重复第二步，向集群添加更多机器。</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 操作的帮助信息
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-185ec44b69a851237e5cbde8b34d60b8>7.1.1.2 - </h1>
<h3 id=概要>概要</h3>
<p>kubeadm 实验子命令</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
alpha 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机的根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5106075da35b6c976e6f8d7d225df0ff>7.1.1.3 - </h1>
<h3 id=概要>概要</h3>
<p>kubeconfig 文件应用程序。</p>
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d7af99919faca6010658b893fa2a6890>7.1.1.4 - </h1>
<h3 id=概要>概要</h3>
<p>为其他用户输出 kubeconfig 文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm alpha kubeconfig user [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 使用名为 bar 的 kubeadm 配置文件为名为 foo 的另一用户输出 kubeconfig 文件
kubeadm alpha kubeconfig user --client-name=foo --config=bar
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--client-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用户名。如果生成客户端证书，则用作其 CN。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向 kubeadm 配置文件的路径
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
user 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--org stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
客户端证书的组织。如果创建客户端证书，此值将用作其 O 字段值。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
应该用此 kubeconfig 的身份验证机制的令牌，而不是客户端证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机的根目录。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8df9aba508b2736a6712ef46227eea7d>7.1.1.5 - </h1>
<h3 id=概要>概要</h3>
<p>与处理 kubernetes 证书相关的命令</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>certs 命令的帮助</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-018648dfc6f28bc9b969f45af0563cae>7.1.1.6 - </h1>
<h3 id=概要>概要</h3>
<p>该命令将打印出可以与 "init" 命令一起使用的安全的随机生成的证书密钥。</p>
<p>你也可以使用 <code>kubeadm init --upload-certs</code> 而无需指定证书密钥；
命令将为你生成并打印一个证书密钥。</p>
<pre><code>kubeadm certs certificate-key [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
certificate-key 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4a1ff27cdf01c1c47d034278048e776b>7.1.1.7 - </h1>
<h3 id=概要>概要</h3>
<p>检查 kubeadm 管理的本地 PKI 中证书的到期时间。</p>
<pre><code>kubeadm certs check-expiration [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存证书的路径</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>check-expiration 的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5d6b2999153cd86f56329534249fc4ec>7.1.1.8 - </h1>
<p>为运行控制平面所需的所有证书生成密钥和证书签名请求（CSR）。该命令会生成部分 kubeconfig 文件，
其中 "users > user > client-key-data" 字段包含私钥数据，并为每个 kubeconfig
文件创建一个随附的 ".csr" 文件。</p>
<p>此命令设计用于
<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode>Kubeadm 外部 CA 模式</a>。
它生成你可以提交给外部证书颁发机构进行签名的 CSR。</p>
<p>应使用 ".crt" 作为文件扩展名将 PEM 编码的签名证书与密钥文件一起保存。
或者，对于 kubeconfig 文件，PEM 编码的签名证书应使用 base64 编码，
并添加到 "users > user > client-certificate-data" 字段。</p>
<pre><code>kubeadm certs generate-csr [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 以下命令将为所有控制平面证书和 kubeconfig 文件生成密钥和 CSR :
kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存证书的路径</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>generate-csr 命令的帮助</td>
</tr>
<tr>
<td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存 kubeconfig 文件的路径。</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-adb5eecdc351074cc2e0cc2b1b4f04a8>7.1.1.9 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm certs renew [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
renew 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-df4c2dc6cba0be90d8d7de2fca9b87f7>7.1.1.10 - </h1>
<h3 id=概要>概要</h3>
<p>续订 kubeconfig 文件中嵌入的证书，供管理员 和 kubeadm 自身使用。</p>
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew admin.conf [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
admin.conf 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6d6746e8ac1f1602f7dab1056b27e5c2>7.1.1.11 - </h1>
<h3 id=概要>概要</h3>
<p>续订运行控制平面所需的所有已知证书。续订是无条件进行的，与到期日期无关。续订也可以单独运行以进行更多控制。</p>
<pre><code>kubeadm certs renew all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7449c7fa06f25b967cf531e937b0f4b2>7.1.1.12 - </h1>
<h3 id=概要>概要</h3>
<p>续订 apiserver 用于访问 etcd 的证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver-etcd-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b5c6ae77d3be9bd358c68667006cfc18>7.1.1.13 - </h1>
<h3 id=概要>概要</h3>
<p>续订 apiserver 用于连接 kubelet 的证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可能调用 K8s 证书 API 进行证书更新；亦或者，作为最后一个选择，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver-kubelet-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4f804e59ec1739e733807d2b591d771f>7.1.1.14 - </h1>
<h3 id=概要>概要</h3>
<p>续订用于提供 Kubernetes API 的证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5cf8caa95834803b133d53c321ab4a9>7.1.1.15 - </h1>
<h3 id=概要>概要</h3>
<p>续订 kubeconfig 文件中嵌入的证书，以供控制器管理器（Controller Manager）使用。</p>
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用 kubeadm 管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm alpha renew controller-manager.conf [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
controller-manager.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ee770858e2bb767b79d572b4882af656>7.1.1.16 - </h1>
<h3 id=概要>概要</h3>
<p>续订存活态探针的证书，用于对 etcd 执行健康检查。</p>
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-healthcheck-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7484bf11b6183f4c329b1f66734cc886>7.1.1.17 - </h1>
<h3 id=概要>概要</h3>
<p>续订 etcd 节点间用来相互通信的证书。</p>
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；
作为替代方案，也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-peer [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bf444d915ab856dba693c36294c5427b>7.1.1.18 - </h1>
<h3 id=概要>概要</h3>
<p>续订用于提供 etcd 服务的证书。</p>
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订，或者作为最后一种选择来生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-server [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-server 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5c087e087714c5290b4967dd7924b3b>7.1.1.19 - </h1>
<h3 id=概要>概要</h3>
<p>为前端代理客户端续订证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种方案，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew front-proxy-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-20703ce1c236264ad78cb1ad7244723e>7.1.1.20 - </h1>
<h3 id=概要>概要</h3>
<p>续订 kubeconfig 文件中嵌入的证书，以供调度管理器使用。</p>
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew scheduler.conf [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
scheduler.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-49aaa494ef75de67609987a43e5ee520>7.1.1.21 - </h1>
<h3 id=概要>概要</h3>
<p>为指定的 shell（bash 或 zsh）输出 shell 自动补全代码。
必须激活 shell 代码以提供交互式 kubeadm 命令补全。这可以通过加载 .bash_profile 文件完成。</p>
<p>注意: 此功能依赖于 <code>bash-completion</code> 框架。</p>
<p>在 Mac 上使用 homebrew 安装:</p>
<pre><code>brew install bash-completion
</code></pre><p>安装后，必须激活 bash_completion。这可以通过在 .bash_profile 文件中添加下面的命令行来完成</p>
<pre><code>source $(brew --prefix)/etc/bash_completion
</code></pre>
<p>如果在 Linux 上没有安装 bash-completion，请通过您的发行版的包管理器安装 <code>bash-completion</code> 软件包。</p>
<p>zsh 用户注意事项：[1] zsh 自动补全仅在 >=v5.2 及以上版本中支持。</p>
<pre><code>kubeadm completion SHELL [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 在 Mac 上使用 homebrew 安装 bash completion
brew install bash-completion
printf &quot;\n# Bash completion support\nsource $(brew --prefix)/etc/bash_completion\n&quot; &gt;&gt; $HOME/.bash_profile
source $HOME/.bash_profile

# 将 bash 版本的 kubeadm 自动补全代码加载到当前 shell 中
source &lt;(kubeadm completion bash)

# 将 bash 自动补全完成代码写入文件并且从 .bash_profile 文件加载它
printf &quot;\n# Kubeadm shell completion\nsource '$HOME/.kube/kubeadm_completion.bash.inc'\n&quot; &gt;&gt; $HOME/.bash_profile
source $HOME/.bash_profile

# 将 zsh 版本的 kubeadm 自动补全代码加载到当前 shell 中
source &lt;(kubeadm completion zsh)
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
completion 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d63311c16e6468f5a5940aadd902faa7>7.1.1.22 - </h1>
<h3 id=概要>概要</h3>
<p>kube-system 命名空间里有一个名为 "kubeadm-config" 的 ConfigMap，kubeadm 用它来存储有关集群的内部配置。
kubeadm CLI v1.8.0+ 通过一个配置自动创建该 ConfigMap，这个配置是和 'kubeadm init' 共用的。
但是您如果使用 kubeadm v1.7.x 或更低的版本初始化集群，那么必须使用 'config upload' 命令创建该 ConfigMap。
这是必要的操作，目的是使 'kubeadm upgrade' 能够正确地配置升级后的集群。</p>
<pre><code>kubeadm config [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
config 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6678a79b85306310066616185153377d>7.1.1.23 - </h1>
<h3 id=概要>概要</h3>
<p>与 kubeadm 使用的容器镜像交互。</p>
<pre><code>kubeadm config images [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
images 的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8f73e208cc67d221165f6294393881a7>7.1.1.24 - </h1>
<h3 id=概要>概要</h3>
<p>打印 kubeadm 要使用的镜像列表。配置文件用于自定义任何镜像或镜像存储库。</p>
<pre><code>kubeadm config images list [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan=2>
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对（key=value），用于描述各种特征。选项是：
<br>Auditing=true|false (ALPHA - 默认=false)
<br>CoreDNS=true|false (默认=true)
<br>DynamicKubeletConfig=true|false (BETA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
list 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个特定的 Kubernetes 版本
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9aec3477159c105a46f4479de1c21418>7.1.1.25 - </h1>
<h3 id=概要>概要</h3>
<p>拉取 kubeadm 使用的镜像。</p>
<pre><code>kubeadm config images pull [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一系列键值对（key=value），用于描述各种特征。可选项是：<br>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
pull 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-045e41c28798930e21f77a90c3a90263>7.1.1.26 - </h1>
<h3 id=概要>概要</h3>
<p>此命令允许您在 CLI 工具中将本地旧版本的配置对象转换为最新支持的版本，而无需变更集群中的任何内容。在此版本的 kubeadm 中，支持以下 API 版本：</p>
<ul>
<li>kubeadm.k8s.io/v1beta2</li>
</ul>
<p>因此，无论您在此处传递 --old-config 参数的版本是什么，当写入到 stdout 或 --new-config （如果已指定）时，
都会读取、反序列化、默认、转换、验证和重新序列化 API 对象。</p>
<p>换句话说，如果您将此文件传递给 "kubeadm init"，则该命令的输出就是 kubeadm 实际上在内部读取的内容。</p>
<pre><code>kubeadm config migrate [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
migrate 操作的帮助信息
</td>
</tr>
<tr>
<td colspan=2>--new-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用新的 API 版本生成的 kubeadm 配置文件的路径。这个路径是可选的。如果没有指定，输出将被写到 stdout。
</td>
</tr>
<tr>
<td colspan=2>--old-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用旧 API 版本且应转换的 kubeadm 配置文件的路径。此参数是必需的。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果未设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e7d83478123771ad14f475ee44440303>7.1.1.27 - </h1>
<p>打印配置</p>
<h3 id=概要>概要</h3>
<p>此命令打印子命令所提供的配置信息。
相关细节可参阅 <a href=https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2>https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2</a></p>
<pre><code>kubeadm config print [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>print 命令的帮助信息</p></td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承而来的选项>从父命令继承而来的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>与集群通信时使用的 kubeconfig 文件。如此标志未设置，将在一组标准位置中搜索现有的kubeconfig 文件。</p></td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>[试验性] 指向“真实”宿主根文件系统的路径。</p></td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-57a6b20d9571220989a7a445d4459468>7.1.1.28 - </h1>
<h3 id=概要>概要</h3>
<p>此命令打印对象，例如用于 'kubeadm init' 的默认 init 配置对象。</p>
<p>请注意，Bootstrap Token 字段之类的敏感值已替换为 {"abcdef.0123456789abcdef" "" "nil" &lt;nil> [] []} 之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre><code>kubeadm config print init-defaults [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
init-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-92a2c11eef37937af846b55d9b87a544>7.1.1.29 - </h1>
<h3 id=概要>概要</h3>
<p>此命令打印对象，例如用于 'kubeadm join' 的默认 join 配置对象。</p>
<p>请注意，诸如启动引导令牌字段之类的敏感值已替换为 {"abcdef.0123456789abcdef" "" "nil" &lt;nil> [] []}
之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre><code>kubeadm config print join-defaults [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
join-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-dcfffcaafb438cd650475945ddc129ee>7.1.1.30 - </h1>
<h3 id=概要>概要</h3>
<p>运行此命令来搭建 Kubernetes 控制平面节点。</p>
<p>"init" 命令执行以下阶段：</p>
<pre><code>preflight                    Run pre-flight checks
certs                        Certificate generation
  /ca                          Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components
  /apiserver                   Generate the certificate for serving the Kubernetes API
  /apiserver-kubelet-client    Generate the certificate for the API server to connect to kubelet
  /front-proxy-ca              Generate the self-signed CA to provision identities for front proxy
  /front-proxy-client          Generate the certificate for the front proxy client
  /etcd-ca                     Generate the self-signed CA to provision identities for etcd
  /etcd-server                 Generate the certificate for serving etcd
  /etcd-peer                   Generate the certificate for etcd nodes to communicate with each other
  /etcd-healthcheck-client     Generate the certificate for liveness probes to healthcheck etcd
  /apiserver-etcd-client       Generate the certificate the apiserver uses to access etcd
  /sa                          Generate a private key for signing service account tokens along with its public key
kubeconfig                   Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file
  /admin                       Generate a kubeconfig file for the admin to use and for kubeadm itself
  /kubelet                     Generate a kubeconfig file for the kubelet to use *only* for cluster bootstrapping purposes
  /controller-manager          Generate a kubeconfig file for the controller manager to use
  /scheduler                   Generate a kubeconfig file for the scheduler to use
kubelet-start                Write kubelet settings and (re)start the kubelet
control-plane                Generate all static Pod manifest files necessary to establish the control plane
  /apiserver                   Generates the kube-apiserver static Pod manifest
  /controller-manager          Generates the kube-controller-manager static Pod manifest
  /scheduler                   Generates the kube-scheduler static Pod manifest
etcd                         Generate static Pod manifest file for local etcd
  /local                       Generate the static Pod manifest file for a local, single-node local etcd instance
upload-config                Upload the kubeadm and kubelet configuration to a ConfigMap
  /kubeadm                     Upload the kubeadm ClusterConfiguration to a ConfigMap
  /kubelet                     Upload the kubelet component config to a ConfigMap
upload-certs                 Upload certificates to kubeadm-certs
mark-control-plane           Mark a node as a control-plane
bootstrap-token              Generates bootstrap tokens used to join a node to a cluster
kubelet-finalize             Updates settings relevant to the kubelet after TLS bootstrap
  /experimental-cert-rotation  Enable kubelet client certificate rotation
addon                        Install required addons for passing Conformance tests
  /coredns                     Install the CoreDNS addon to a Kubernetes cluster
  /kube-proxy                  Install the kube-proxy addon to a Kubernetes cluster
</code></pre><pre><code>kubeadm init [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API Server 服务证书的可选附加主题备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要应用任何更改；只是输出将要执行的操作。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组用来描述各种功能特性的键值（key=value）对。选项是：<br>IPv6DualStack=true|false (ALPHA - default=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
init 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指明 pod 网络可以使用的 IP 地址段。如果设置了这个参数，控制平面将会为每一个节点自动分配 CIDRs。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务的虚拟 IP 地址另外指定 IP 地址段
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务另外指定域名，例如："myorg.internal"。
</td>
</tr>
<tr>
<td colspan=2>--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要打印用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan=2>--skip-token-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
这个令牌用于建立控制平面节点与工作节点间的双向通信。格式为 [a-z0-9]{6}\.[a-z0-9]{16} - 示例：abcdef.0123456789abcdef
</td>
</tr>
<tr>
<td colspan=2>
--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
令牌被自动删除之前的持续时间（例如 1 s，2 m，3 h）。如果设置为 '0'，则令牌将永不过期
</td>
</tr>
<tr>
<td colspan=2>--upload-certs</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6eaa2624c512051ff2a9cdbc6ee54949>7.1.1.31 - </h1>
<h3 id=概要>概要</h3>
<p>使用此命令可以调用 init 工作流程的单个阶段</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选择项>继承于父命令的选择项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4b7ada30e3923594b2907dcb8b431080>7.1.1.32 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase addon [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
addon 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6d1154da2e554de858cf4e7b37c054fa>7.1.1.33 - </h1>
<h3 id=概要>概要</h3>
<p>安装所有插件（addon）</p>
<pre><code>kubeadm init phase addon all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对（key=value），描述了各种特征。选项包括：<br>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d3a16914ddc849435ed864163978ddbf>7.1.1.34 - </h1>
<h3 id=概要>概要</h3>
<p>通过 API 服务器安装 CoreDNS 附加组件。请注意，即使 DNS 服务器已部署，在安装 CNI 之前 DNS 服务器不会被调度执行。</p>
<pre><code>kubeadm init phase addon coredns [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组用来描述各种功能特性的键值（key=value）对。选项是：<br>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
coredns 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8a257337ea78e5d9a0c54aa971eaf991>7.1.1.35 - </h1>
<h3 id=概要>概要</h3>
<p>通过 API 服务器安装 kube-proxy 附加组件。</p>
<pre><code>kubeadm init phase addon kube-proxy [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kube-proxy 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-77759011117e7974cbfee9694b6f8801>7.1.1.36 - </h1>
<h3 id=概要>概要</h3>
<p>启动引导令牌（bootstrap token）用于在即将加入集群的节点和控制平面节点之间建立双向信任。</p>
<p>该命令使启动引导令牌（bootstrap token）所需的所有配置生效，然后创建初始令牌。</p>
<pre><code>kubeadm init phase bootstrap-token [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 进行所有引导令牌配置，并创建一个初始令牌，功能上与 kubeadm init 生成的令牌等效。
kubeadm init phase bootstrap-token
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
bootstrap-token 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--skip-token-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8e1920b2caaa8de839cd3997edca80e9>7.1.1.37 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase certs [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
certs 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父指令中继承的选项>从父指令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-00aa8c2e4b3b2fd3a4b7986976b7bfda>7.1.1.38 - </h1>
<h3 id=概要>概要</h3>
<p>生成所有证书</p>
<pre><code>kubeadm init phase certs all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API 服务器服务证书的可选额外替代名称（SAN）。可以同时使用 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
VIP 服务使用其它的 IP 地址范围。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-316aa97ee5719be5a723ac1b77c44f5a>7.1.1.39 - </h1>
<h3 id=概要>概要</h3>
<p>生成 apiserver 用于访问 etcd 的证书，并将其保存到 apiserver-etcd-client.cert 和 apiserver-etcd-client.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver-etcd-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-759e85e62b32c0697ab37c214e99a864>7.1.1.40 - </h1>
<h3 id=概要>概要</h3>
<p>生成供 API 服务器连接 kubelet 的证书，并将其保存到 apiserver-kubelet-client.cert 和 apiserver-kubelet-client.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver-kubelet-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向宿主机上的 '实际' 根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2e7091074560abc2a8e7b897cdd8a7b6>7.1.1.41 - </h1>
<h3 id=概要>概要</h3>
<p>生成用于服务 Kubernetes API 的证书，并将其保存到 apiserver.cert 和 apiserver.key 文件中。</p>
<p>默认 SAN 是 kubernetes、kubernetes.default、kubernetes.default.svc、kubernetes.default.svc.cluster.local、10.96.0.1、127.0.0.1。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API Server 服务证书的可选附加主体备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定服务 VIP 可使用的其他 IP 地址段。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eedb8f5a6ed4cff1dfb1a5d14176b5b3>7.1.1.42 - </h1>
<h3 id=概要>概要</h3>
<p>生成自签名的 Kubernetes CA 以提供其他 Kubernetes 组件的身份，并将其保存到 ca.cert 和 ca.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs ca [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c55f2fa6bdaa124b37da090a3ef90902>7.1.1.43 - </h1>
<h3 id=概要>概要</h3>
<p>生成用于为 etcd 设置身份的自签名 CA，并将其保存到 etcd/ca.cert 和 etcd/ca.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-ca [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-10f416336efdcee22d691869e7585b9f>7.1.1.44 - </h1>
<h3 id=概要>概要</h3>
<p>生成用于 etcd 健康检查的活跃性探针的证书，并将其保存到 healthcheck-client.cert 和 etcd/healthcheck-client.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-healthcheck-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书存储的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c4b6d149cda7cac896f4374c821b7fc6>7.1.1.45 - </h1>
<h3 id=概要>概要</h3>
<p>生成 etcd 节点相互通信的证书，并将其保存到 etcd/peer.cert 和 etcd/peer.key 文件中。</p>
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-peer [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1db087626f4f368e932df6f12993a5ab>7.1.1.46 - </h1>
<h3 id=概要>概要</h3>
<p>生成用于提供 etcd 服务的证书，并将其保存到 etcd/server.cert 和 etcd/server.key 文件中。</p>
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-server [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-server 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e85da83e18a50e472eb56320af55768a>7.1.1.47 - </h1>
<h3 id=概要>概要</h3>
<p>生成自签名 CA 来提供前端代理的身份，并将其保存到 front-proxy-ca.cert 和 front-proxy-ca.key 文件中。</p>
<p>如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。</p>
<p>Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre><code>kubeadm init phase certs front-proxy-ca [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
front-proxy-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eb911bdcb8bb53ceb8b253089ab0d814>7.1.1.48 - </h1>
<h3 id=概要>概要</h3>
<p>为前端代理客户端生成证书，并将其保存到 front-proxy-client.cert 和 front-proxy-client.key 文件中。
如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。
Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre><code>kubeadm init phase certs front-proxy-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-62c5dc89c39f3ecd6aee57545d12891a>7.1.1.49 - </h1>
<h3 id=概要>概要</h3>
<p>生成用于签名 service account 令牌的私钥及其公钥，并将其保存到 sa.key 和 sa.pub 文件中。如果两个文件都已存在，则 kubeadm 会跳过生成步骤，而将使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 阶段。</p>
<pre><code>kubeadm init phase certs sa [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
sa 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2a79e12b9455f0ca1a6d5b00a9841249>7.1.1.50 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a2c8efac328fcf416e558bf167ef417d>7.1.1.51 - </h1>
<h3 id=概要>概要</h3>
<p>生成所有的静态 Pod 清单文件</p>
<pre><code>kubeadm init phase control-plane all [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 为控制平面组件生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase control-plane all

# 使用从某配置文件中读取的选项为生成静态 Pod 清单文件。
kubeadm init phase control-plane all --config config.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
形式为 &lt;flagname>=&lt;value> 的一组额外参数，用来传递给 API 服务器，
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个稳定的 IP 地址或者 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组形式为 &lt;flagname>=&lt;value> 的额外参数，用来传递给控制管理器（Controller Manager）
或覆盖其默认设置值
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组用来描述各种特性门控的键值（key=value）对。选项是：
<br>IPv6DualStack=true|false (ALPHA - 默认=false)
<br>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择指定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果设置了此标志，控制平面将自动地为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan=2>--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组形式为 &lt;flagname>=&lt;value> 的额外参数，用来传递给调度器（Scheduler）
或覆盖其默认设置值
<p>传递给调度器（scheduler）一组额外的参数或者以 &lt;flagname>=&lt;value> 形式覆盖其默认值。</p>
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
</tbody>
</table>
<h3 id=从父指令继承的选项>从父指令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机的根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d93bd37094201bdefdb3908c9a6c86b3>7.1.1.52 - </h1>
<h3 id=概要>概要</h3>
<p>生成 kube-apiserver 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane apiserver [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： 6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组 &lt;flagname>=&lt;value> 形式的额外参数，用来传递给 API 服务器
或者覆盖其默认参数配置
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对，用于描述各种功能特性的特性门控。选项是：
<br>IPv6DualStack=true|false (ALPHA - 默认=false)
<br>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-efa9ae4c92ed1c26dc04bb049db38cec>7.1.1.53 - </h1>
<h3 id=概要>概要</h3>
<p>生成 kube-controller-manager 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane controller-manager [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组 &lt;flagname>=&lt; 形式的额外参数，传递给控制器管理器（Controller Manager）
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-576c00359074987304b3b418cec9a5b1>7.1.1.54 - </h1>
<h3 id=概要>概要</h3>
<p>生成 kube-scheduler 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane scheduler [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值:"k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组 &lt;flagname>=&lt;value> 形式的额外参数，用来传递给调度器
或者覆盖其默认参数配置
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e6097fe5dd013abd9f356c2566ef7b63>7.1.1.55 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase etcd [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5ab65eab2498cc1893af5b3bf8fe08fc>7.1.1.56 - </h1>
<h3 id=概要>概要</h3>
<p>为本地单节点 etcd 实例生成静态 Pod 清单文件</p>
<pre><code>kubeadm init phase etcd local [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 为 etcd 生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase etcd local

# 使用从配置文件读取的选项为 etcd 生成静态 Pod 清单文件。
kubeadm init phase etcd local --config config.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
local 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fcb78718510a9d3027d1bb9d379c0c17>7.1.1.57 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请阅读可用子命令列表。</p>
<pre><code>kubeadm init phase kubeconfig [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a0e1457f667eb757f82f8c42901aa6c5>7.1.1.58 - </h1>
<h3 id=概要>概要</h3>
<p>为管理员和 kubeadm 本身生成 kubeconfig 文件，并将其保存到 admin.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig admin [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
admin 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-59e362bf565041872395d165e99eafc1>7.1.1.59 - </h1>
<h3 id=概要>概要</h3>
<p>生成所有 kubeconfig 文件</p>
<pre><code>kubeadm init phase kubeconfig all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果没有设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2a5040747a02ae2b2326c9901f1725d3>7.1.1.60 - </h1>
<h3 id=概要>概要</h3>
<p>生成控制器管理器要使用的 kubeconfig 文件，并保存到 controller-manager.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig controller-manager [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
</tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-043bd19497eefb77a6ed30a4d704fe7c>7.1.1.61 - </h1>
<h3 id=概要>概要</h3>
<p>生成 kubelet 要使用的 kubeconfig 文件，并将其保存到 kubelet.conf 文件。</p>
<p>请注意，该操作目的是<em>仅</em>应用于引导集群。在控制平面启动之后，应该从 CSR API 请求所有 kubelet 凭据。</p>
<pre><code>kubeadm init phase kubeconfig kubelet [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bffb0d67824e75ade7232d09754b9718>7.1.1.62 - </h1>
<h3 id=概要>概要</h3>
<p>生成调度器（scheduler）要使用的 kubeconfig 文件，并保存到 scheduler.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig scheduler [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a37b5872c572c71775e389df50fca215>7.1.1.63 - </h1>
<p>TLS 引导后更新与 kubelet 相关的设置</p>
<pre><code>kubeadm init phase kubelet-finalize [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubelet-finalize 操作的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3f49598c499c3356d89d98fdc8c8ad79>7.1.1.64 - </h1>
<p>运行所有 kubelet-finalize 阶段</p>
<pre><code>kubeadm init phase kubelet-finalize all [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>all 操作的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7d68ac74e5301f789ddd2e25dd36218e>7.1.1.65 - </h1>
<p>启用 kubelet 客户端证书轮换</p>
<pre><code>kubeadm init phase kubelet-finalize experimental-cert-rotation [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>experimental-cert-rotation 操作的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e7c1ae3d905d9b6854216e26651955cd>7.1.1.66 - </h1>
<h3 id=概要>概要</h3>
<p>使用 kubelet 配置文件编写一个文件，并使用特定节点的 kubelet 设置编写一个环境文件，然后（重新）启动 kubelet。</p>
<pre><code>kubeadm init phase kubelet-start [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 从 InitConfiguration 文件中写入带有 kubelet 参数的动态环境文件。
kubeadm init phase kubelet-start --config config.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
连接到 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-967a98823c19c8338bfc0e1338a20fb1>7.1.1.67 - </h1>
<h3 id=概要>概要</h3>
<p>标记 Node 节点为控制平面节点</p>
<pre><code>kubeadm init phase mark-control-plane [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 将控制平面标签和污点应用于当前节点，其功能等效于 kubeadm init执行的操作。
kubeadm init phase mark-control-plane --config config.yml

# 将控制平面标签和污点应用于特定节点
kubeadm init phase mark-control-plane --node-name myNode
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b5838cc93a3fdb37b61afd201a71edd9>7.1.1.68 - </h1>
<h3 id=概要>概要</h3>
<p>运行 kubeadm init 前的启动检查。</p>
<pre><code>kubeadm init phase preflight [flags]
</code></pre>
<h3 id=案例>案例</h3>
<pre><code># 使用配置文件对 kubeadm init 进行启动检查。
kubeadm init phase preflight --config kubeadm-config.yml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表：例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f54c84a0fdada369a87b2ced6ccfc38f>7.1.1.69 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase upload-certs [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
upload-certs 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用来与集群通信的 kubeconfig 文件。
如果此标志未设置，则可以在一组标准的位置搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要打印输出用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--upload-certs</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0d96e214c09a8f014e984a6b980522b3>7.1.1.70 - </h1>
<h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用的子命令列表。</p>
<pre><code>kubeadm init phase upload-config [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
upload-config 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-48afa88840a20edf1ad613c18480d4fc>7.1.1.71 - </h1>
<h3 id=概要>概要</h3>
<p>将所有配置上传到 ConfigMap</p>
<pre><code>kubeadm init phase upload-config all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-14da359f76a0f36af507d289dd4a5050>7.1.1.72 - </h1>
<h3 id=概要>概要</h3>
<p>将 kubeadm ClusterConfiguration 上传到 kube-system 命名空间中名为 kubeadm-config 的 ConfigMap 中。
这样就可以正确配置系统组件，并在升级时提供无缝的用户体验。</p>
<p>另外，可以使用 kubeadm 配置。</p>
<pre><code>kubeadm init phase upload-config kubeadm [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 上传集群配置
kubeadm init phase upload-config --config=myConfig.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3fda282409b804a14879b9c65c035797>7.1.1.73 - </h1>
<h3 id=概要>概要</h3>
<p>将从 kubeadm InitConfiguration 对象提取的 kubelet 配置上传到集群中 kubelet-config-1.X 形式的
ConfigMap，其中 X 是当前（API 服务器）Kubernetes 版本的次要版本。</p>
<pre><code>kubeadm init phase upload-config kubelet [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 将 kubelet 配置从 kubeadm 配置文件上传到集群中的 ConfigMap。
kubeadm init phase upload-config kubelet --config kubeadm.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
到 kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该标签，则可以通过一组标准路径来寻找已有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e044e6c69c2b1512c8d89430e0400771>7.1.1.74 - </h1>
<h3 id=摘要>摘要</h3>
<p>当节点加入 kubeadm 初始化的集群时，我们需要建立双向信任。
这个过程可以分解为发现（让待加入节点信任 Kubernetes 控制平面节点）和 TLS 引导（让Kubernetes 控制平面节点信任待加入节点）两个部分。</p>
<p>有两种主要的发现方案。
第一种方法是使用共享令牌和 API 服务器的 IP 地址。
第二种是提供一个文件 - 标准 kubeconfig 文件的一个子集。
该文件可以是本地文件，也可以通过 HTTPS URL 下载。
格式是 <code>kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443</code>、<code>kubeadm join--discovery-file path/to/file.conf</code> 或者<code>kubeadm join --discovery-file https://url/file.conf</code>。
只能使用其中一种。
如果发现信息是从 URL 加载的，必须使用 HTTPS。
此外，在这种情况下，主机安装的 CA 包用于验证连接。</p>
<p>如果使用共享令牌进行发现，还应该传递 --discovery-token-ca-cert-hash 参数来验证 Kubernetes 控制平面节点提供的根证书颁发机构（CA）的公钥。
此参数的值指定为 "&lt;hash-type>:&lt;hex-encoded-value>"，其中支持的哈希类型为 "sha256"。哈希是通过 Subject Public Key Info（SPKI）对象的字节计算的（如 RFC7469）。
这个值可以从 "kubeadm init" 的输出中获得，或者可以使用标准工具进行计算。
可以多次重复 --discovery-token-ca-cert-hash 参数以允许多个公钥。</p>
<p>如果无法提前知道 CA 公钥哈希，则可以通过 --discovery-token-unsafe-skip-ca-verification 参数禁用此验证。
这削弱了kubeadm 安全模型，因为其他节点可能会模仿 Kubernetes 控制平面节点。</p>
<p>TLS 引导机制也通过共享令牌驱动。
这用于向 Kubernetes 控制平面节点进行临时的身份验证，以提交本地创建的密钥对的证书签名请求（CSR）。
默认情况下，kubeadm 将设置 Kubernetes 控制平面节点自动批准这些签名请求。
这个令牌通过 --tls-bootstrap-token abcdef.1234567890abcdef 参数传入。</p>
<p>通常两个部分会使用相同的令牌。
在这种情况下可以使用 --token 参数，而不是单独指定每个令牌。</p>
<p>"join [api-server-endpoint]" 命令执行下列阶段：</p>
<pre><code>preflight              Run join pre-flight checks
control-plane-prepare  Prepare the machine for serving a control plane
  /download-certs        [EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret
  /certs                 Generate the certificates for the new control plane components
  /kubeconfig            Generate the kubeconfig for the new control plane components
  /control-plane         Generate the manifests for the new control plane components
kubelet-start          Write kubelet settings, certificates and (re)start the kubelet
control-plane-join     Join a machine as a control plane instance
  /etcd                  Add a new local etcd member
  /update-status         Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap
  /mark-control-plane    Mark a node as a control-plane
</code></pre><pre><code>kubeadm join [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果节点应该托管新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对基于令牌的发现，验证根 CA 公钥是否与此哈希匹配 (格式: "&lt;type>:&lt;value>")。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
join 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9f968809f867b76728697577492429e8>7.1.1.75 - </h1>
<h3 id=概要>概要</h3>
<p>使用此命令来调用 <code>join</code> 工作流程的某个阶段</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c3c506c1683aed34398a34ab66d609da>7.1.1.76 - </h1>
<h3 id=概要>概要</h3>
<p>添加作为控制平面实例的机器</p>
<pre><code>kubeadm join phase control-plane-join [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 将机器作为控制平面实例加入
kubeadm join phase control-plane-join all
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane-join 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2c1a5a4405dca745ef50b4e86f5977c7>7.1.1.77 - </h1>
<h3 id=概要>概要</h3>
<p>添加作为控制平面实例的机器</p>
<pre><code>kubeadm join phase control-plane-join all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--experimental-control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-003aaef561d065ecdaeb2c325b6b9253>7.1.1.78 - </h1>
<h3 id=概要>概要</h3>
<p>添加新的本地 etcd 成员</p>
<pre><code>kubeadm join phase control-plane-join etcd [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是"strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-535f050663a6d8db3a61df2b19a0714b>7.1.1.79 - </h1>
<h3 id=概要>概要</h3>
<p>将 Node 节点标记为控制平面节点</p>
<pre><code>kubeadm join phase control-plane-join mark-control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2f0a684baffe3cdf830c16693412f8e0>7.1.1.80 - </h1>
<h2 id=概要>概要</h2>
<p>将新的控制平面节点注册到 kubeadm-config ConfigMap 维护的 ClusterStatus 中</p>
<pre><code>kubeadm join phase control-plane-join update-status [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
update-status 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-aba528e06c437710b269f4e41f854fdd>7.1.1.81 - </h1>
<h3 id=概要>概要</h3>
<p>准备为控制平面服务的机器</p>
<pre><code>kubeadm join phase control-plane-prepare [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 准备为控制平面服务的机器
kubeadm join phase control-plane-prepare all
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane-prepare 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1d7987a759cd1519def4d433710cdff1>7.1.1.82 - </h1>
<h3 id=概要>概要</h3>
<p>准备为控制平面服务的机器</p>
<pre><code>kubeadm join phase control-plane-prepare all [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥解密由 init 上传的证书 secrets。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-33216a69b333c330cb8b305a119abc7c>7.1.1.83 - </h1>
<h3 id=概要>概要</h3>
<p>为新的控制平面组件生成证书</p>
<pre><code>kubeadm join phase control-plane-prepare certs [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
certs 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-53abd743076fc859067264f3e8e676e0>7.1.1.84 - </h1>
<h3 id=概要>概要</h3>
<p>为新的控制平面组件生成清单（manifest）</p>
<pre><code>kubeadm join phase control-plane-prepare control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3a08eb202d572e417768a942ad24c59f>7.1.1.85 - </h1>
<h3 id=概要>概要</h3>
<p>[实验]从 kubeadm-certs Secret 下载控制平面节点之间共享的证书</p>
<pre><code>kubeadm join phase control-plane-prepare download-certs [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-11ed4820a6c3b411d9c4b87163cf0ae7>7.1.1.86 - </h1>
<h3 id=概要>概要</h3>
<p>为新的控制平面组件生成 kubeconfig</p>
<pre><code>kubeadm join phase control-plane-prepare kubeconfig [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e81c9d9320242b5ed4b063beea6696f8>7.1.1.87 - </h1>
<h3 id=概要>概要</h3>
<p>生成一个包含 KubeletConfiguration 的文件和一个包含特定于节点的 kubelet 配置的环境文件，然后（重新）启动 kubelet。</p>
<pre><code>kubeadm join phase kubelet-start [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
For file-based discovery, a file or URL from which to load cluster information.
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-47f2d404188d6eb1fbf6fffd7fba4e48>7.1.1.88 - </h1>
<h3 id=概要>概要</h3>
<p>运行 kubeadm join 命令添加节点前检查。</p>
<pre><code>kubeadm join phase preflight [api-server-endpoint] [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 使用配置文件运行 kubeadm join 命令添加节点前检查。
kubeadm join phase preflight --config kubeadm-config.yml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 `init` 操作上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a46a193f2322aa88cb3b2de2447b0461>7.1.1.89 - </h1>
<h3 id=概要>概要</h3>
<p>尽最大努力还原通过 'kubeadm init' 或者 'kubeadm join' 操作对主机所做的更改</p>
<p>"reset" 命令执行以下阶段：</p>
<pre><code>preflight              Run reset pre-flight checks
update-cluster-status  Remove this node from the ClusterStatus object.
remove-etcd-member     Remove a local etcd member.
cleanup-node           Run cleanup node.
</code></pre><pre><code>kubeadm reset [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>-f, --force</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
reset 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该标志，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段列表
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5b27d7bd0eeed918f8635c68d220dc5>7.1.1.90 - </h1>
<h3 id=概要>概要</h3>
<p>使用此命令来调用 <code>reset</code> 工作流程的某个阶段</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-370e9ffda66b4c48dfa54ea37c3aad21>7.1.1.91 - </h1>
<h3 id=概要>概要</h3>
<p>执行 cleanup node（清理节点）操作。</p>
<pre><code>kubeadm reset phase cleanup-node [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
cleanup-node 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6bd27042c883aa5c498647d37762392c>7.1.1.92 - </h1>
<h3 id=概要>概要</h3>
<p>kubeadm reset（重置）前运行启动前检查。</p>
<pre><code>kubeadm reset phase preflight [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-f, --force</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3a000435e1cca0be398b44b487f530c8>7.1.1.93 - </h1>
<h3 id=概要>概要</h3>
<p>上传关于当前状态的配置，以便 'kubeadm upgrade' 以后可以知道如何配置升级后的集群。</p>
<pre><code>kubeadm config upload [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>upload 操作的帮助信息</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-97fbe97ca22de377e7fbf2517e0451b6>7.1.1.94 - </h1>
<h3 id=概要>概要</h3>
<p>如果该节点是控制平面节点，从 ClusterStatus 对象中删除该节点。</p>
<pre><code>kubeadm reset phase update-cluster-status [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
update-cluster-status 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bee6749065a369c2ab5b311eb43c40ba>7.1.1.95 - </h1>
<h3 id=概要>概要</h3>
<p>此命令管理引导令牌（bootstrap token）。它是可选的，仅适用于高级用例。</p>
<p>简而言之，引导令牌（bootstrap token）用于在客户端和服务器之间建立双向信任。
当客户端（例如，即将加入集群的节点）需要时，可以使用引导令牌相信正在与之通信的服务器。
然后可以使用具有 “签名” 的引导令牌。</p>
<p>引导令牌还可以作为一种允许对 API 服务器进行短期身份验证的方法（令牌用作 API 服务器信任客户端的方式），例如用于执行 TLS 引导程序。</p>
<p>引导令牌准确来说是什么？</p>
<ul>
<li>它是位于 kube-system 命名空间中类型为 “bootstrap.kubernetes.io/token” 的一个 Secret。</li>
<li>引导令牌的格式必须为 “[a-z0-9]{6}.[a-z0-9]{16}”，前一部分是公共令牌 ID，而后者是令牌秘钥，必须在任何情况下都保密！</li>
<li>必须将 Secret 的名称命名为 “bootstrap-token-(token-id)”。</li>
</ul>
<p>您可以在此处阅读有关引导令牌（bootstrap token）的更多信息：
/docs/admin/bootstrap-tokens/</p>
<pre><code>kubeadm token [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 模式
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
token 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置，则搜索一组标准位置以查找现有 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bdd9680ec894593d17f782d5e5665fd4>7.1.1.96 - </h1>
<h3 id=概要>概要</h3>
<p>这个命令将为你创建一个引导令牌。
您可以设置此令牌的用途，"有效时间" 和可选的人性化的描述。</p>
<p>这里的 [token] 是指将要生成的实际令牌。
该令牌应该是一个通过安全机制生成的随机令牌，形式为 "[a-z0-9]{6}.[a-z0-9]{16}"。
如果没有给出 [token]，kubeadm 将生成一个随机令牌。</p>
<pre><code>kubeadm token create [token]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--description string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对令牌用途的人性化的描述。
</td>
</tr>
<tr>
<td colspan=2>
--groups stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[system:bootstrappers:kubeadm:default-node-token]
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此令牌用于身份验证时将进行身份验证的其他组。必须匹配 "\\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\\z"
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
create 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--print-join-command</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不仅仅打印令牌，而是打印使用令牌加入集群所需的完整 'kubeadm join' 参数。
</td>
</tr>
<tr>
<td colspan=2>
--ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
令牌有效时间，超过该时间令牌被自动删除。(例如： 1s, 2m, 3h)。如果设置为 '0'，令牌将永远不过期。
</td>
</tr>
<tr>
<td colspan=2>
--usages stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[signing,authentication]
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
描述可以使用此令牌的方式。你可以多次使用 `--usages` 或者提供一个以逗号分隔的选项列表。合法选项有: [signing,authentication]
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1d005baad1a1e217d7ae0210fec96c3f>7.1.1.97 - </h1>
<h3 id=概要>概要</h3>
<p>这个命令将为你删除指定的引导令牌列表。</p>
<p><code>[token-value]</code> 是要删除的 "[a-z0-9]{6}.[a-z0-9]{16}" 形式的完整令牌或者是 "[a-z0-9]{6}" 形式的的令牌 ID。</p>
<pre><code>kubeadm token delete [token-value] ...
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
delete 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c79d11d27bed54caac743c93e0b2fb24>7.1.1.98 - </h1>
<h3 id=概要>概要</h3>
<p>此命令将打印一个随机生成的可以被 "init" 和 "join" 命令使用的引导令牌。
您不必使用此命令来生成令牌。你可以自己设定，只要格式符合 "[a-z0-9]{6}.[a-z0-9]{16}"。这个命令提供是为了方便生成规定格式的令牌。
您也可以使用 "kubeadm init" 并且不指定令牌，该命令会生成一个令牌并打印出来。</p>
<pre><code>kubeadm token generate [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
generate 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 运行模式</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ba78e64c325e4131dd741235e2a1b2c0>7.1.1.99 - </h1>
<h3 id=概要>概要</h3>
<p>此命令将为您列出所有的引导令牌。</p>
<pre><code>kubeadm token list [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan=2>
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
list 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 模式
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-872d33f1fbc83cb2f0bf89b4bd545174>7.1.1.100 - </h1>
<h3 id=概要>概要</h3>
<p>此命令能将集群平滑升级到新版本</p>
<pre><code>kubeadm upgrade [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
upgrade 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7d8c1710684742ca940f580674225d9d>7.1.1.101 - </h1>
<h3 id=概要>概要</h3>
<p>将 Kubernetes 集群升级到指定版本</p>
<pre><code>kubeadm upgrade apply [version]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
显示 Kubernetes 的不稳定版本作为升级替代方案，并允许升级到 Kubernetes 的 alpha/beta 或 RC 版本。
</td>
</tr>
<tr>
<td colspan=2>--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
显示 Kubernetes 的候选版本作为升级替代方案，并允许升级到 Kubernetes 的 RC 版本。
</td>
</tr>
<tr>
<td colspan=2>--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行升级期间更改的组件所使用的证书的更新。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要更改任何状态，只输出要执行的操作。
</td>
</tr>
<tr>
<td colspan=2>
--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对，用于描述各种功能。选项包括：
<br>IPv6DualStack=true|false (ALPHA - 默认=false)
<br>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-f, --force</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
强制升级，但可能无法满足某些要求。这也意味着非交互模式。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apply 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置标志，则在相关目录下搜索以查找现有 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--print-config</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定是否应打印将在升级中使用的配置文件。
</td>
</tr>
<tr>
<td colspan=2>-y, --yes</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行升级，不提示确认（非交互模式）。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-28dcf20d89c7bb1c8e7a3873d7703d5d>7.1.1.102 - </h1>
<h3 id=概述>概述</h3>
<p>显示哪些差异将被应用于现有的静态 pod 资源清单。参考: kubeadm upgrade apply --dry-run</p>
<pre><code>kubeadm upgrade diff [version] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--api-server-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-apiserver.yaml"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>API服务器清单的路径</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径</td>
</tr>
<tr>
<td colspan=2>-c, --context-lines int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：3</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>差异中有多少行上下文</td>
</tr>
<tr>
<td colspan=2>--controller-manager-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/manifests/kube-controller-manager.yaml"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>控制器清单的路径</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>帮助</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>与集群通信时使用的 kubeconfig 文件，如果标志是未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<tr>
<td colspan=2>--scheduler-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-scheduler.yaml"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>调度程序清单的路径</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f869b6331e40c6f9eb01314f96d3113e>7.1.1.103 - </h1>
<h3 id=概要>概要</h3>
<p>升级集群中某个节点的命令</p>
<p>"node" 命令执行以下阶段：</p>
<pre><code>preflight       执行节点升级前检查
control-plane   如果存在的话，升级部署在该节点上的管理面实例
kubelet-config  更新该节点上的 kubelet 配置
</code></pre><pre><code>kubeadm upgrade node [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-renewal</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对升级期间变化的组件所使用的证书执行更新。
</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不更改任何状态，只输出将要执行的操作。
</td>
</tr>
<tr>
<td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
node 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于与集群交互的 kubeconfig 文件。如果参数未指定，将从一系列标准位置检索存在的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--kubelet-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
升级后 *期望的* kubelet 配置版本。如未指定，将使用 kubeadm-config ConfigMap 中的 KubernetesVersion
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段的列表
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-19a94d2f7649959b218952cef00729f4>7.1.1.104 - </h1>
<h3 id=概要>概要</h3>
<p>使用此命令调用 node 工作流的某个阶段</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b22d3ed181fb7f926ae2081f8fc8c14d>7.1.1.105 - </h1>
<h3 id=概要>概要</h3>
<p>升级部署在此节点上的控制平面实例，如果有的话</p>
<pre><code>kubeadm upgrade node phase control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-renewal</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>更新在升级期间变更的组件使用的证书。</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>不改变任何状态，只输出将要执行的动作。</td>
</tr>
<tr>
<td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>执行 etcd 的升级。</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>control-plane 的帮助信息</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ae1ea74c2c21b25a3c1eacdaf549274b>7.1.1.106 - </h1>
<p>从群集中 "kubelet-config-1.X" 的 ConfigMap 下载 kubelet 配置，其中 X 是kubelet 的次要版本。
kubeadm 使用 --kubelet-version 参数来确定所需的 kubelet 版本。</p>
<pre><code>kubeadm upgrade node phase kubelet-config [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>不改变任何状态，只输出将要执行的操作</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>配置操作的帮助信息</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/kubelet.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan=2>--kubelet-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>升级后的 kubelet 的*期望*版本。</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-633020ef232bc34f60c82153578a6c9b>7.1.1.107 - </h1>
<p>执行 kubeadm 升级节点的预检。</p>
<pre><code>kubeadm upgrade node phase preflight [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>preflight 操作的帮助命令</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>错误将显示为警告的检查清单。示例：'IsPrivilegedUser,Swap'。值为'all'表示忽略所有检查的错误。</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e938edeb3d824f9b364de617a1f10a93>7.1.1.108 - </h1>
<h3 id=概述>概述</h3>
<p>检查可升级到哪些版本，并验证您当前的集群是否可升级。 要跳过互联网检查，请传递可选的 [version] 参数</p>
<pre><code>kubeadm upgrade plan [version] [flags]
</code></pre><h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>显示不稳定版本的 Kubernetes 作为升级替代方案，并允许升级到 Kubernetes 的 Alpha/Beta/发行候选版本。</td>
</tr>
<tr>
<td colspan=2>--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>显示 Kubernetes 的发行候选版本作为升级选择，并允许升级到 Kubernetes 的发行候选版本。</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>一组描述各种特征特性门控的键值对。选项有：IPv6DualStack=true|false (ALPHA - default=false) PublicKeysECDSA=true|false (ALPHA - default=false)</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>帮助</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>检查清单，其错误将显示为警告。 例如：“IsPrivilegedUser，Swap”。 值 “all” 忽略所有检查的错误。</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>与集群通信时使用的 kubeconfig 文件。 如果标志为未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<tr>
<td colspan=2>--print-config</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>指定是否打印将在升级中使用的配置文件。</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-aa9f718186487df2ab6885cae45f5d37>7.1.1.109 - </h1>
<h3 id=概要>概要</h3>
<p>打印 kubeadm 的版本</p>
<pre><code>kubeadm version [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
version 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>-o, --output string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出格式；可用的选项有 'yaml', 'json' 和 'short'
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-60d816e74ec8e0301cc484b19d7694e6>7.1.1.110 - </h1>
<p>此目录下的所有文件都是从其他仓库自动生成的。 <strong>不要人工编辑它们。 您必须在上游仓库中编辑它们</strong></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-82b2fcf985bae77dcb754387a9fcc64f>7.1.2 - kubeadm init</h1>
<p>此命令初始化一个 Kubernetes 控制平面节点。</p>
<h3 id=概要>概要</h3>
<p>运行此命令来搭建 Kubernetes 控制平面节点。</p>
<p>"init" 命令执行以下阶段：</p>
<pre><code>preflight                    Run pre-flight checks
certs                        Certificate generation
  /ca                          Generate the self-signed Kubernetes CA to provision identities for other Kubernetes components
  /apiserver                   Generate the certificate for serving the Kubernetes API
  /apiserver-kubelet-client    Generate the certificate for the API server to connect to kubelet
  /front-proxy-ca              Generate the self-signed CA to provision identities for front proxy
  /front-proxy-client          Generate the certificate for the front proxy client
  /etcd-ca                     Generate the self-signed CA to provision identities for etcd
  /etcd-server                 Generate the certificate for serving etcd
  /etcd-peer                   Generate the certificate for etcd nodes to communicate with each other
  /etcd-healthcheck-client     Generate the certificate for liveness probes to healthcheck etcd
  /apiserver-etcd-client       Generate the certificate the apiserver uses to access etcd
  /sa                          Generate a private key for signing service account tokens along with its public key
kubeconfig                   Generate all kubeconfig files necessary to establish the control plane and the admin kubeconfig file
  /admin                       Generate a kubeconfig file for the admin to use and for kubeadm itself
  /kubelet                     Generate a kubeconfig file for the kubelet to use *only* for cluster bootstrapping purposes
  /controller-manager          Generate a kubeconfig file for the controller manager to use
  /scheduler                   Generate a kubeconfig file for the scheduler to use
kubelet-start                Write kubelet settings and (re)start the kubelet
control-plane                Generate all static Pod manifest files necessary to establish the control plane
  /apiserver                   Generates the kube-apiserver static Pod manifest
  /controller-manager          Generates the kube-controller-manager static Pod manifest
  /scheduler                   Generates the kube-scheduler static Pod manifest
etcd                         Generate static Pod manifest file for local etcd
  /local                       Generate the static Pod manifest file for a local, single-node local etcd instance
upload-config                Upload the kubeadm and kubelet configuration to a ConfigMap
  /kubeadm                     Upload the kubeadm ClusterConfiguration to a ConfigMap
  /kubelet                     Upload the kubelet component config to a ConfigMap
upload-certs                 Upload certificates to kubeadm-certs
mark-control-plane           Mark a node as a control-plane
bootstrap-token              Generates bootstrap tokens used to join a node to a cluster
kubelet-finalize             Updates settings relevant to the kubelet after TLS bootstrap
  /experimental-cert-rotation  Enable kubelet client certificate rotation
addon                        Install required addons for passing Conformance tests
  /coredns                     Install the CoreDNS addon to a Kubernetes cluster
  /kube-proxy                  Install the kube-proxy addon to a Kubernetes cluster
</code></pre><pre><code>kubeadm init [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API Server 服务证书的可选附加主题备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要应用任何更改；只是输出将要执行的操作。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组用来描述各种功能特性的键值（key=value）对。选项是：<br>IPv6DualStack=true|false (ALPHA - default=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
init 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指明 pod 网络可以使用的 IP 地址段。如果设置了这个参数，控制平面将会为每一个节点自动分配 CIDRs。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务的虚拟 IP 地址另外指定 IP 地址段
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务另外指定域名，例如："myorg.internal"。
</td>
</tr>
<tr>
<td colspan=2>--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要打印用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan=2>--skip-token-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
这个令牌用于建立控制平面节点与工作节点间的双向通信。格式为 [a-z0-9]{6}\.[a-z0-9]{16} - 示例：abcdef.0123456789abcdef
</td>
</tr>
<tr>
<td colspan=2>
--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
令牌被自动删除之前的持续时间（例如 1 s，2 m，3 h）。如果设置为 '0'，则令牌将永不过期
</td>
</tr>
<tr>
<td colspan=2>--upload-certs</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h3 id=init-workflow>Init 命令的工作流程</h3>
<p><code>kubeadm init</code> 命令通过执行下列步骤来启动一个 Kubernetes 控制平面节点。</p>
<ol>
<li>在做出变更前运行一系列的预检项来验证系统状态。一些检查项目仅仅触发警告，
其它的则会被视为错误并且退出 kubeadm，除非问题得到解决或者用户指定了
<code>--ignore-preflight-errors=&lt;错误列表></code> 参数。</li>
</ol>
<ol start=2>
<li>生成一个自签名的 CA 证书来为集群中的每一个组件建立身份标识。
用户可以通过将其放入 <code>--cert-dir</code> 配置的证书目录中（默认为 <code>/etc/kubernetes/pki</code>）
来提供他们自己的 CA 证书以及/或者密钥。
APIServer 证书将为任何 <code>--apiserver-cert-extra-sans</code> 参数值提供附加的 SAN 条目，必要时将其小写。</li>
</ol>
<ol start=3>
<li>将 kubeconfig 文件写入 <code>/etc/kubernetes/</code> 目录以便 kubelet、控制器管理器和调度器用来连接到
API 服务器，它们每一个都有自己的身份标识，同时生成一个名为 <code>admin.conf</code> 的独立的 kubeconfig
文件，用于管理操作。</li>
</ol>
<ol start=4>
<li>
<p>为 API 服务器、控制器管理器和调度器生成静态 Pod 的清单文件。假使没有提供一个外部的 etcd
服务的话，也会为 etcd 生成一份额外的静态 Pod 清单文件。</p>
<p>静态 Pod 的清单文件被写入到 <code>/etc/kubernetes/manifests</code> 目录;
kubelet 会监视这个目录以便在系统启动的时候创建 Pod。</p>
<p>一旦控制平面的 Pod 都运行起来， <code>kubeadm init</code> 的工作流程就继续往下执行。</p>
</li>
</ol>
<ol start=5>
<li>对控制平面节点应用标签和污点标记以便不会在它上面运行其它的工作负载。</li>
</ol>
<ol start=6>
<li>生成令牌，将来其他节点可使用该令牌向控制平面注册自己。
如 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/>kubeadm token</a> 文档所述，
用户可以选择通过 <code>--token</code> 提供令牌。</li>
</ol>
<ol start=7>
<li>
<p>为了使得节点能够遵照<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>启动引导令牌</a>
和 <a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLS 启动引导</a>
这两份文档中描述的机制加入到集群中，kubeadm 会执行所有的必要配置：</p>
<ul>
<li>
<p>创建一个 ConfigMap 提供添加集群节点所需的信息，并为该 ConfigMap 设置相关的 RBAC 访问规则。</p>
</li>
<li>
<p>允许启动引导令牌访问 CSR 签名 API。</p>
</li>
<li>
<p>配置自动签发新的 CSR 请求。</p>
</li>
</ul>
<p>更多相关信息，请查看 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>。</p>
</li>
</ol>
<ol start=8>
<li>
<p>通过 API 服务器安装一个 DNS 服务器 (CoreDNS) 和 kube-proxy 附加组件。
在 Kubernetes 版本 1.11 和更高版本中，CoreDNS 是默认的 DNS 服务器。
请注意，尽管已部署 DNS 服务器，但直到安装 CNI 时才调度它。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告：</strong> 从 v1.18 开始，在 kubeadm 中使用 kube-dns 的支持已被废弃，并已在 v1.21 版本中删除。
</div>
</li>
</ol>
<h3 id=init-phases>在 kubeadm 中使用 init phases</h3>
<p>Kubeadm 允许你使用 <code>kubeadm init phase</code> 命令分阶段创建控制平面节点。</p>
<p>要查看阶段和子阶段的有序列表，可以调用 <code>kubeadm init --help</code>。
该列表将位于帮助屏幕的顶部，每个阶段旁边都有一个描述。
注意，通过调用 <code>kubeadm init</code>，所有阶段和子阶段都将按照此确切顺序执行。</p>
<p>某些阶段具有唯一的标志，因此，如果要查看可用选项的列表，请添加 <code>--help</code>，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo kubeadm init phase control-plane controller-manager --help
</code></pre></div>
<p>你也可以使用 <code>--help</code> 查看特定父阶段的子阶段列表：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo kubeadm init phase control-plane --help
</code></pre></div>
<p><code>kubeadm init</code> 还公开了一个名为 <code>--skip-phases</code> 的参数，该参数可用于跳过某些阶段。
参数接受阶段名称列表，并且这些名称可以从上面的有序列表中获取。</p>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo kubeadm init phase control-plane all --config<span style=color:#666>=</span>configfile.yaml
sudo kubeadm init phase etcd <span style=color:#a2f>local</span> --config<span style=color:#666>=</span>configfile.yaml
<span style=color:#080;font-style:italic># 你现在可以修改控制平面和 etcd 清单文件</span>
sudo kubeadm init --skip-phases<span style=color:#666>=</span>control-plane,etcd --config<span style=color:#666>=</span>configfile.yaml
</code></pre></div>
<p>该示例将执行的操作是基于 <code>configfile.yaml</code> 中的配置在 <code>/etc/kubernetes/manifests</code>
中写入控制平面和 etcd 的清单文件。
这允许你修改文件，然后使用 <code>--skip-phases</code> 跳过这些阶段。
通过调用最后一个命令，你将使用自定义清单文件创建一个控制平面节点。</p>
<h3 id=config-file>结合一份配置文件来使用 kubeadm init</h3>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong> 配置文件的功能仍然处于 alpha 状态并且在将来的版本中可能会改变。
</div>
<p>通过一份配置文件而不是使用命令行参数来配置 <code>kubeadm init</code> 命令是可能的，
但是一些更加高级的功能只能够通过配置文件设定。
这份配置文件通过 <code>--config</code> 选项参数指定的，
它必须包含 <code>ClusterConfiguration</code> 结构，并可能包含更多由 <code>---\n</code> 分隔的结构。
在某些情况下，可能不允许将 <code>--config</code> 与其他标志混合使用。</p>
<p>可以使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config print</a>
命令打印出默认配置。</p>
<p>如果你的配置没有使用最新版本，
<strong>推荐</strong>使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config migrate</a>
命令进行迁移。</p>
<p>有关配置的字段和用法的更多信息，
你可以访问 API 参考页面并从
<a href=https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories>列表</a>
中选择一个版本。</p>
<h3 id=kube-proxy>添加 kube-proxy 参数</h3>
<p>kubeadm 配置中有关 kube-proxy 的说明请查看：</p>
<ul>
<li><a href=/zh/docs/reference/config-api/kube-proxy-config.v1alpha1/>kube-proxy 参考</a></li>
</ul>
<p>使用 kubeadm 启用 IPVS 模式的说明请查看：</p>
<ul>
<li><a href=https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/ipvs/README.md>IPVS</a></li>
</ul>
<h3 id=control-plane-flags>向控制平面组件传递自定义的命令行参数</h3>
<p>有关向控制平面组件传递命令行参数的说明请查看：
<a href=/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags/>控制平面命令行参数</a></p>
<h3 id=custom-images>使用自定义的镜像</h3>
<p>默认情况下, kubeadm 会从 <code>k8s.gcr.io</code> 仓库拉取镜像。如果请求的 Kubernetes 版本是 CI 标签
（例如 <code>ci/latest</code>），则使用 <code>gcr.io/k8s-staging-ci-images</code>。</p>
<p>你可以通过使用<a href=#config-file>带有配置文件的 kubeadm</a> 来重写此操作。</p>
<p>允许的自定义功能有：</p>
<ul>
<li>使用其他的 <code>imageRepository</code> 来代替 <code>k8s.gcr.io</code>。</li>
<li>将 <code>useHyperKubeImage</code> 设置为 <code>true</code>，使用 HyperKube 镜像。</li>
<li>为 etcd 或 DNS 附件提供特定的 <code>imageRepository</code> 和 <code>imageTag</code>。</li>
</ul>
<p>请注意配置文件中的配置项 <code>kubernetesVersion</code> 或者命令行参数 <code>--kubernetes-version</code>
会影响到镜像的版本。</p>
<h3 id=将控制平面证书上传到集群>将控制平面证书上传到集群</h3>
<p>通过将参数 <code>--upload-certs</code> 添加到 <code>kubeadm init</code>，你可以将控制平面证书临时上传到集群中的 Secret。
请注意，此 Secret 将在 2 小时后自动过期。证书使用 32 字节密钥加密，可以使用 <code>--certificate-key</code> 指定。
通过将 <code>--control-plane</code> 和 <code>--certificate-key</code> 传递给 <code>kubeadm join</code>，
可以在添加其他控制平面节点时使用相同的密钥下载证书。</p>
<p>以下阶段命令可用于证书到期后重新上传证书：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm init phase upload-certs --upload-certs --certificate-key<span style=color:#666>=</span>SOME_VALUE --config<span style=color:#666>=</span>SOME_YAML_FILE
</code></pre></div>
<p>如果未将参数 <code>--certificate-key</code> 传递给 <code>kubeadm init</code> 和 <code>kubeadm init phase upload-certs</code>，
则会自动生成一个新密钥。</p>
<p>以下命令可用于按需生成新密钥：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm certs certificate-key
</code></pre></div>
<h3 id=使用-kubeadm-管理证书>使用 kubeadm 管理证书</h3>
<p>有关使用 kubeadm 进行证书管理的详细信息，请参阅
<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/>使用 kubeadm 进行证书管理</a>。
该文档包括有关使用外部 CA，自定义证书和证书更新的信息。</p>
<h3 id=kubelet-drop-in>管理 kubeadm 为 kubelet 提供的 systemd 配置文件</h3>
<p><code>kubeadm</code> 包自带了关于 <code>systemd</code> 如何运行 <code>kubelet</code> 的配置文件。
请注意 <code>kubeadm</code> 客户端命令行工具永远不会修改这份 <code>systemd</code> 配置文件。
这份 <code>systemd</code> 配置文件属于 kubeadm DEB/RPM 包。</p>
<p>有关更多信息，请阅读
<a href=/zh/docs/setup/production-environment/tools/kubeadm/kubelet-integration/#the-kubelet-drop-in-file-for-systemd>管理 systemd 的 kubeadm 内嵌文件</a>。</p>
<h3 id=结合-cri-运行时使用-kubeadm>结合 CRI 运行时使用 kubeadm</h3>
<p>默认情况下，kubeadm 尝试检测你的容器运行环境。有关此检测的更多详细信息，请参见
<a href=/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#installing-runtime>kubeadm CRI 安装指南</a>。</p>
<h3 id=设置节点的名称>设置节点的名称</h3>
<p>默认情况下, <code>kubeadm</code> 基于机器的主机地址分配一个节点名称。你可以使用 <code>--node-name</code> 参数覆盖此设置。
此标识将合适的
<a href=/zh/docs/reference/command-line-tools-reference/kubelet/#options><code>--hostname-override</code></a>
值传递给 kubelet。</p>
<h3 id=在没有互联网连接的情况下运行-kubeadm>在没有互联网连接的情况下运行 kubeadm</h3>
<p>要在没有互联网连接的情况下运行 kubeadm，你必须提前拉取所需的控制平面镜像。</p>
<p>你可以使用 <code>kubeadm config images</code> 子命令列出并拉取镜像：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm config images list
kubeadm config images pull
</code></pre></div>
<p>kubeadm 需要的所有镜像，例如 <code>k8s.gcr.io/kube-*</code>、<code>k8s.gcr.io/etcd</code> 和 <code>k8s.gcr.io/pause</code>
都支持多种架构。</p>
<h3 id=kubeadm-自动化>kubeadm 自动化</h3>
<p>除了像文档 <a href=/zh/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>kubeadm 基础教程</a>
中所描述的那样，将从 <code>kubeadm init</code> 取得的令牌复制到每个节点，
你还可以并行地分发令牌以实现简单自动化。
要实现自动化，你必须知道控制平面节点启动后将拥有的 IP 地址，或使用 DNS 名称或负载均衡器的地址。</p>
<ol>
<li>
<p>生成一个令牌。这个令牌必须具有以下格式：<code>&lt; 6 个字符的字符串>.&lt; 16 个字符的字符串></code>。
更加正式的说法是，它必须符合以下正则表达式：<code>[a-z0-9]{6}\.[a-z0-9]{16}</code>。</p>
<p>kubeadm 可以为你生成一个令牌：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm token generate
</code></pre></div></li>
</ol>
<ol start=2>
<li>使用这个令牌同时启动控制平面节点和工作节点。它们一旦运行起来应该就会互相寻找对方并且建立集群。
同样的 <code>--token</code> 参数可以同时用于 <code>kubeadm init</code> 和 <code>kubeadm join</code> 命令。</li>
</ol>
<ol start=3>
<li>
<p>当加入其他控制平面节点时，可以对 <code>--certificate-key</code> 执行类似的操作。可以使用以下方式生成密钥：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm certs certificate-key
</code></pre></div></li>
</ol>
<p>一旦集群启动起来，你就可以从控制平面节点的 <code>/etc/kubernetes/admin.conf</code> 文件获取管理凭证，
并使用这个凭证同集群通信。</p>
<p>注意这种搭建集群的方式在安全保证上会有一些宽松，因为这种方式不允许使用 <code>--discovery-token-ca-cert-hash</code>
来验证根 CA 的哈希值（因为当配置节点的时候，它还没有被生成）。
更多信息请参阅 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> 文档。</p>
<h2 id=接下来>接下来</h2>
<ul>
<li>进一步阅读了解 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/>kubeadm init phase</a></li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>
启动一个 Kubernetes 工作节点并且将其加入到集群</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/>kubeadm upgrade</a>
将 Kubernetes 集群升级到新版本</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
恢复 <code>kubeadm init</code> 或 <code>kubeadm join</code> 命令对节点所作的变更</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2a2b5f34806b4b1bd2c12682ac170d68>7.1.3 - kubeadm join</h1>
<p>此命令用来初始化 Kubernetes 工作节点并将其加入集群。</p>
<h3 id=摘要>摘要</h3>
<p>当节点加入 kubeadm 初始化的集群时，我们需要建立双向信任。
这个过程可以分解为发现（让待加入节点信任 Kubernetes 控制平面节点）和 TLS 引导（让Kubernetes 控制平面节点信任待加入节点）两个部分。</p>
<p>有两种主要的发现方案。
第一种方法是使用共享令牌和 API 服务器的 IP 地址。
第二种是提供一个文件 - 标准 kubeconfig 文件的一个子集。
该文件可以是本地文件，也可以通过 HTTPS URL 下载。
格式是 <code>kubeadm join --discovery-token abcdef.1234567890abcdef 1.2.3.4:6443</code>、<code>kubeadm join--discovery-file path/to/file.conf</code> 或者<code>kubeadm join --discovery-file https://url/file.conf</code>。
只能使用其中一种。
如果发现信息是从 URL 加载的，必须使用 HTTPS。
此外，在这种情况下，主机安装的 CA 包用于验证连接。</p>
<p>如果使用共享令牌进行发现，还应该传递 --discovery-token-ca-cert-hash 参数来验证 Kubernetes 控制平面节点提供的根证书颁发机构（CA）的公钥。
此参数的值指定为 "&lt;hash-type>:&lt;hex-encoded-value>"，其中支持的哈希类型为 "sha256"。哈希是通过 Subject Public Key Info（SPKI）对象的字节计算的（如 RFC7469）。
这个值可以从 "kubeadm init" 的输出中获得，或者可以使用标准工具进行计算。
可以多次重复 --discovery-token-ca-cert-hash 参数以允许多个公钥。</p>
<p>如果无法提前知道 CA 公钥哈希，则可以通过 --discovery-token-unsafe-skip-ca-verification 参数禁用此验证。
这削弱了kubeadm 安全模型，因为其他节点可能会模仿 Kubernetes 控制平面节点。</p>
<p>TLS 引导机制也通过共享令牌驱动。
这用于向 Kubernetes 控制平面节点进行临时的身份验证，以提交本地创建的密钥对的证书签名请求（CSR）。
默认情况下，kubeadm 将设置 Kubernetes 控制平面节点自动批准这些签名请求。
这个令牌通过 --tls-bootstrap-token abcdef.1234567890abcdef 参数传入。</p>
<p>通常两个部分会使用相同的令牌。
在这种情况下可以使用 --token 参数，而不是单独指定每个令牌。</p>
<p>"join [api-server-endpoint]" 命令执行下列阶段：</p>
<pre><code>preflight              Run join pre-flight checks
control-plane-prepare  Prepare the machine for serving a control plane
  /download-certs        [EXPERIMENTAL] Download certificates shared among control-plane nodes from the kubeadm-certs Secret
  /certs                 Generate the certificates for the new control plane components
  /kubeconfig            Generate the kubeconfig for the new control plane components
  /control-plane         Generate the manifests for the new control plane components
kubelet-start          Write kubelet settings, certificates and (re)start the kubelet
control-plane-join     Join a machine as a control plane instance
  /etcd                  Add a new local etcd member
  /update-status         Register the new control-plane node into the ClusterStatus maintained in the kubeadm-config ConfigMap
  /mark-control-plane    Mark a node as a control-plane
</code></pre><pre><code>kubeadm join [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果节点应该托管新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对基于令牌的发现，验证根 CA 公钥是否与此哈希匹配 (格式: "&lt;type>:&lt;value>")。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
join 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段列表
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h3 id=join-workflow>join 工作流</h3>
<p><code>kubeadm join</code> 初始化 Kubernetes 工作节点并将其加入集群。
该操作过程包含下面几个步骤：</p>
<ol>
<li>kubeadm 从 API 服务器下载必要的集群信息。
默认情况下，它使用引导令牌和 CA 密钥哈希来验证数据的真实性。
也可以通过文件或 URL 直接发现根 CA。</li>
</ol>
<ol start=2>
<li>
<p>一旦知道集群信息，kubelet 就可以开始 TLS 引导过程。</p>
<p>TLS 引导程序使用共享令牌与 Kubernetes API 服务器进行临时的身份验证，以提交证书签名请求 (CSR)；
默认情况下，控制平面自动对该 CSR 请求进行签名。</p>
</li>
</ol>
<ol start=3>
<li>最后，kubeadm 配置本地 kubelet 使用分配给节点的确定标识连接到 API 服务器。</li>
</ol>
<p>对于控制平面节点，执行额外的步骤：</p>
<ol>
<li>
<p>从集群下载控制平面节点之间共享的证书（如果用户明确要求）。</p>
</li>
<li>
<p>生成控制平面组件清单、证书和 kubeconfig。</p>
</li>
<li>
<p>添加新的本地 etcd 成员。</p>
</li>
<li>
<p>将此节点添加到 kubeadm 集群的 ClusterStatus。</p>
</li>
</ol>
<h3 id=join-phases>使用 kubeadm 的 join phase 命令</h3>
<p>Kubeadm 允许你使用 <code>kubeadm join phase</code> 分阶段将节点加入集群。</p>
<p>要查看阶段和子阶段的有序列表，可以调用 <code>kubeadm join --help</code>。
该列表将位于帮助屏幕的顶部，每个阶段旁边都有一个描述。
注意，通过调用 <code>kubeadm join</code>，所有阶段和子阶段都将按照此确切顺序执行。</p>
<p>有些阶段具有唯一的标志，因此，如果要查看可用选项列表，请添加 <code>--help</code>，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm join phase kubelet-start --help
</code></pre></div>
<p>类似于 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-phases>kubeadm init phase</a>命令，
<code>kubeadm join phase</code> 允许你使用 <code>--skip-phases</code> 标志跳过阶段列表。</p>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo kubeadm join --skip-phases<span style=color:#666>=</span>preflight --config<span style=color:#666>=</span>config.yaml
</code></pre></div>
<h3 id=发现要信任的集群-ca>发现要信任的集群 CA</h3>
<p>Kubeadm 的发现有几个选项，每个选项都有安全性上的优缺点。
适合你的环境的正确方法取决于节点是如何准备的以及你对网络的安全性期望
和节点的生命周期特点。</p>
<h4 id=带-ca-锁定模式的基于令牌的发现>带 CA 锁定模式的基于令牌的发现</h4>
<p>这是 Kubernetes 1.8 及以上版本中的默认模式。
在这种模式下，kubeadm 下载集群配置（包括根CA）并使用令牌验证它，
并且会验证根 CA 的公钥与所提供的哈希是否匹配，
以及 API 服务器证书在根 CA 下是否有效。</p>
<p>CA 键哈希格式为 <code>sha256:&lt;hex_encoded_hash></code>。
默认情况下，在 <code>kubeadm init</code> 最后打印的 <code>kubeadm join</code> 命令
或者 <code>kubeadm token create --print-join-command</code> 的输出信息中返回哈希值。
它使用标准格式 (请参考 <a href=https://tools.ietf.org/html/rfc7469#section-2.4>RFC7469</a>)
并且也能通过第三方工具或者制备系统进行计算。
例如，使用 OpenSSL CLI：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed <span style=color:#b44>&#39;s/^.* //&#39;</span>
</code></pre></div>
<p><strong><code>kubeadm join</code> 命令示例</strong></p>
<p>对于工作节点：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm join --discovery-token abcdef.1234567890abcdef --discovery-token-ca-cert-hash sha256:1234..cdef 1.2.3.4:6443
</code></pre></div>
<p>对于控制面节点：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm join --discovery-token abcdef.1234567890abcdef --discovery-token-ca-cert-hash sha256:1234..cdef --control-plane 1.2.3.4:6443
</code></pre></div>
<p>如果使用 <code>--upload-certs</code> 调用 <code>kubeadm init</code> 命令，
你也可以对控制平面节点调用带 <code>--certificate-key</code> 参数的 <code>join</code> 命令，
将证书复制到该节点。</p>
<p><strong>优势：</strong></p>
<ul>
<li>
<p>允许引导节点安全地发现主节点的信任根，即使其他工作节点或网络受到损害。</p>
</li>
<li>
<p>方便手动执行，因为所需的所有信息都可放到一个 <code>kubeadm join</code> 命令中。</p>
</li>
</ul>
<p><strong>劣势：</strong></p>
<ul>
<li>CA 哈希通常在主节点被提供之前是不知道的，这使得构建使用 kubeadm 的自动化配置工具更加困难。
通过预先生成CA，你可以解除这个限制。</li>
</ul>
<h4 id=无-ca-锁定模式的基于令牌的发现>无 CA 锁定模式的基于令牌的发现</h4>
<p>_这是 Kubernetes 1.7 和早期版本_中的默认设置；使用时要注意一些重要的补充说明。
此模式仅依赖于对称令牌来签名(HMAC-SHA256)发现信息，这些发现信息为主节点建立信任根。
在 Kubernetes 1.8 及以上版本中仍然可以使用 <code>--discovery-token-unsafe-skip-ca-verification</code>
参数，但是如果可能的话，你应该考虑使用一种其他模式。</p>
<p><strong><code>kubeadm join</code> 命令示例</strong></p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubeadm join --token abcdef.1234567890abcdef --discovery-token-unsafe-skip-ca-verification 1.2.3.4:6443
</code></pre></div>
<p><strong>优势</strong></p>
<ul>
<li>
<p>仍然可以防止许多网络级攻击。</p>
</li>
<li>
<p>可以提前生成令牌并与主节点和工作节点共享，这样主节点和工作节点就可以并行引导而无需协调。
这允许它在许多配置场景中使用。</p>
</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>如果攻击者能够通过某些漏洞窃取引导令牌，那么他们可以使用该令牌（连同网络级访问）
为其它处于引导过程中的节点提供假冒的主节点。
在你的环境中，这可能是一个适当的折衷方法，也可能不是。</li>
</ul>
<h4 id=基于-https-或文件发现>基于 HTTPS 或文件发现</h4>
<p>这种方案提供了一种带外方式在主节点和引导节点之间建立信任根。
如果使用 kubeadm 构建自动配置，请考虑使用此模式。
发现文件的格式为常规的 Kubernetes
<a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig</a> 文件。</p>
<p>如果发现文件不包含凭据，则将使用 TLS 发现令牌。</p>
<p><strong><code>kubeadm join</code> 命令示例：</strong></p>
<ul>
<li>
<p><code>kubeadm join --discovery-file path/to/file.conf</code> （本地文件）</p>
</li>
<li>
<p><code>kubeadm join --discovery-file https://url/file.conf</code> (远程 HTTPS URL)</p>
</li>
</ul>
<p><strong>优势：</strong></p>
<ul>
<li>允许引导节点安全地发现主节点的信任根，即使网络或其他工作节点受到损害。</li>
</ul>
<p><strong>劣势：</strong></p>
<ul>
<li>要求你有某种方法将发现信息从主节点传送到引导节点。
例如，这可以通过云提供商或驱动工具实现。
该文件中的信息不是加密的，而是需要 HTTPS 或等效文件来保证其完整性。</li>
</ul>
<h3 id=securing-more>确保你的安装更加安全</h3>
<p>Kubeadm 的默认值可能不适用于所有人。
本节说明如何以牺牲可用性为代价来加强 kubeadm 安装。</p>
<h4 id=关闭节点客户端证书的自动批准>关闭节点客户端证书的自动批准</h4>
<p>默认情况下，Kubernetes 启用了 CSR 自动批准器，如果在身份验证时使用启动引导令牌，
它会批准对 kubelet 的任何客户端证书的请求。
如果不希望集群自动批准kubelet客户端证书，可以通过执行以下命令关闭它：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete clusterrolebinding kubeadm:node-autoapprove-bootstrap
</code></pre></div>
<p>关闭后，<code>kubeadm join</code> 操作将会被阻塞，直到管理员已经手动批准了在途中的 CSR 才会继续：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ   18s       system:bootstrap:878f07   Pending
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl certificate approve node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ
</code></pre></div>
<p>输出类似于：</p>
<pre><code>certificatesigningrequest &quot;node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ&quot; approved
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csr
</code></pre></div>
<p>输出类似于：</p>
<pre><code>NAME                                                   AGE       REQUESTOR                 CONDITION
node-csr-c69HXe7aYcqkS1bKmH4faEnHAWxn6i2bHZ2mD04jZyQ   1m        system:bootstrap:878f07   Approved,Issued
</code></pre>
<p>这迫使工作流只有在运行了 kubectl 证书批准后，kubeadm join 才能成功。</p>
<h4 id=关闭对集群信息-configmap-的公开访问>关闭对集群信息 ConfigMap 的公开访问</h4>
<p>为了实现使用令牌作为唯一验证信息的加入工作流，默认情况下会公开带有验证主节点标识
所需数据的 ConfigMap。
虽然此 ConfigMap 中没有私有数据，但一些用户可能希望无论如何都关闭它。
这样做需要禁用 <code>kubeadm join</code> 工作流的 <code>--discovery-token</code> 参数。
以下是实现步骤：</p>
<ul>
<li>从 API 服务器获取 <code>cluster-info</code> 文件：</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl -n kube-public get cm cluster-info -o yaml | grep <span style=color:#b44>&#34;kubeconfig:&#34;</span> -A11 | grep <span style=color:#b44>&#34;apiVersion&#34;</span> -A10 | sed <span style=color:#b44>&#34;s/    //&#34;</span> | tee cluster-info.yaml
</code></pre></div>
<p>输出类似于：</p>
<pre><code>apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority-data: &lt;ca-cert&gt;
    server: https://&lt;ip&gt;:&lt;port&gt;
  name: &quot;&quot;
contexts: []
current-context: &quot;&quot;
preferences: {}
users: []
</code></pre>
<ul>
<li>
<p>使用 <code>cluster-info.yaml</code> 文件作为 <code>kubeadm join --discovery-file</code> 参数。</p>
</li>
<li>
<p>关闭 <code>cluster-info</code> ConfigMap 的公开访问：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl -n kube-public delete rolebinding kubeadm:bootstrap-signer-clusterinfo
</code></pre></div></li>
</ul>
<p>这些命令应该在执行 <code>kubeadm init</code> 之后、在<code>kubeadm join</code> 之前执行。</p>
<h3 id=使用带有配置文件的-kubeadm-join>使用带有配置文件的 kubeadm join</h3>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong>
<p>配置文件目前是 alpha 功能，在将来的版本中可能会变动。
</div>
<p>可以用配置文件替代命令行参数的方法配置 <code>kubeadm join</code>，一些高级功能也只有在使用配置文件时才可选用。
该文件通过 <code>--config</code> 参数来传递，并且文件中必须包含 <code>JoinConfiguration</code> 结构。
在某些情况下，不允许将 <code>--config</code> 与其他标志混合使用。</p>
<p>使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config print</a>
命令可以打印默认配置。</p>
<p>如果你的配置没有使用最新版本，
<strong>推荐</strong>使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config migrate</a>
命令转换。</p>
<p>有关配置的字段和用法的更多信息，你可以导航到我们的 API 参考页
并从[列表]中选择一个版本(<a href=https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#pkg-subdirectories>https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#pkg-subdirectories</a>)。</p>
<h2 id=接下来>接下来</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a>
初始化 Kubernetes 主节点</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/>kubeadm token</a>
管理 <code>kubeadm join</code> 的令牌</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
将 <code>kubeadm init</code> 或 <code>kubeadm join</code> 对主机的更改恢复到之前状态</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2c20539d9fabf5982e2dd931742714bd>7.1.4 - kubeadm upgrade</h1>
<p><code>kubeadm upgrade</code> 是一个对用户友好的命令，它将复杂的升级逻辑包装在一个命令后面，支持升级的规划和实际执行。</p>
<h2 id=kubeadm-upgrade-指南>kubeadm upgrade 指南</h2>
<p><a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>本文档</a>概述
使用 kubeadm 执行升级的步骤。
与 kubeadm 旧版本相关的文档，请参阅 Kubernetes 网站的旧版文档。</p>
<p>你可以使用 <code>kubeadm upgrade diff</code> 来查看将应用于静态 Pod 清单的更改。</p>
<p>在 Kubernetes v1.15.0 和更高版本中，<code>kubeadm upgrade apply</code> 和 <code>kubeadm upgrade node</code>
也将自动续订该节点上的 kubeadm 托管证书，包括存储在 kubeconfig 文件中的证书。
要选择退出，可以传递参数 <code>--certificate-renewal=false</code>。
有关证书续订的更多详细信息请参见<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs>证书管理文档</a>。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p><code>kubeadm upgrade apply</code> 和 <code>kubeadm upgrade plan</code> 命令都具有遗留的 <code>--config</code> 标志，
可以在执行特定控制平面节点的规划或升级时重新配置集群。
请注意，升级工作流不是为这种情况而设计的，并且有意外结果的报告。
</div>
<h2 id=cmd-upgrade-plan>kubeadm upgrade plan</h2>
<h3 id=概述>概述</h3>
<p>检查可升级到哪些版本，并验证您当前的集群是否可升级。 要跳过互联网检查，请传递可选的 [version] 参数</p>
<pre><code>kubeadm upgrade plan [version] [flags]
</code></pre><h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>显示不稳定版本的 Kubernetes 作为升级替代方案，并允许升级到 Kubernetes 的 Alpha/Beta/发行候选版本。</td>
</tr>
<tr>
<td colspan=2>--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>显示 Kubernetes 的发行候选版本作为升级选择，并允许升级到 Kubernetes 的发行候选版本。</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>一组描述各种特征特性门控的键值对。选项有：IPv6DualStack=true|false (ALPHA - default=false) PublicKeysECDSA=true|false (ALPHA - default=false)</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>帮助</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>检查清单，其错误将显示为警告。 例如：“IsPrivilegedUser，Swap”。 值 “all” 忽略所有检查的错误。</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>与集群通信时使用的 kubeconfig 文件。 如果标志为未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<tr>
<td colspan=2>--print-config</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>指定是否打印将在升级中使用的配置文件。</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
<h2 id=cmd-upgrade-apply>kubeadm upgrade apply </h2>
<h3 id=概要>概要</h3>
<p>将 Kubernetes 集群升级到指定版本</p>
<pre><code>kubeadm upgrade apply [version]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--allow-experimental-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
显示 Kubernetes 的不稳定版本作为升级替代方案，并允许升级到 Kubernetes 的 alpha/beta 或 RC 版本。
</td>
</tr>
<tr>
<td colspan=2>--allow-release-candidate-upgrades</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
显示 Kubernetes 的候选版本作为升级替代方案，并允许升级到 Kubernetes 的 RC 版本。
</td>
</tr>
<tr>
<td colspan=2>--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行升级期间更改的组件所使用的证书的更新。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要更改任何状态，只输出要执行的操作。
</td>
</tr>
<tr>
<td colspan=2>
--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对，用于描述各种功能。选项包括：
<br>IPv6DualStack=true|false (ALPHA - 默认=false)
<br>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-f, --force</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
强制升级，但可能无法满足某些要求。这也意味着非交互模式。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apply 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置标志，则在相关目录下搜索以查找现有 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--print-config</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定是否应打印将在升级中使用的配置文件。
</td>
</tr>
<tr>
<td colspan=2>-y, --yes</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行升级，不提示确认（非交互模式）。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-upgrade-diff>kubeadm upgrade diff</h2>
<h3 id=概述>概述</h3>
<p>显示哪些差异将被应用于现有的静态 pod 资源清单。参考: kubeadm upgrade apply --dry-run</p>
<pre><code>kubeadm upgrade diff [version] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--api-server-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-apiserver.yaml"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>API服务器清单的路径</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径</td>
</tr>
<tr>
<td colspan=2>-c, --context-lines int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：3</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>差异中有多少行上下文</td>
</tr>
<tr>
<td colspan=2>--controller-manager-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/manifests/kube-controller-manager.yaml"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>控制器清单的路径</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>帮助</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>与集群通信时使用的 kubeconfig 文件，如果标志是未设置，则可以在一组标准位置中搜索现有的 kubeconfig 文件。</td>
</tr>
<tr>
<td colspan=2>--scheduler-manifest string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/manifests/kube-scheduler.yaml"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>调度程序清单的路径</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[EXPERIMENTAL] “真实”主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
<h2 id=cmd-upgrade-node>kubeadm upgrade node</h2>
<h3 id=概要>概要</h3>
<p>升级集群中某个节点的命令</p>
<p>"node" 命令执行以下阶段：</p>
<pre><code>preflight       执行节点升级前检查
control-plane   如果存在的话，升级部署在该节点上的管理面实例
kubelet-config  更新该节点上的 kubelet 配置
</code></pre><pre><code>kubeadm upgrade node [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-renewal</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对升级期间变化的组件所使用的证书执行更新。
</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不更改任何状态，只输出将要执行的操作。
</td>
</tr>
<tr>
<td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
执行 etcd 的升级。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
node 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于与集群交互的 kubeconfig 文件。如果参数未指定，将从一系列标准位置检索存在的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--kubelet-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
升级后 *期望的* kubelet 配置版本。如未指定，将使用 kubeadm-config ConfigMap 中的 KubernetesVersion
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段的列表
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=接下来>接下来</h2>
<ul>
<li>如果你使用 kubeadm v1.7.x 或更低版本初始化集群，则可以参考
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm 配置</a>
配置集群用于 <code>kubeadm upgrade</code>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5042dc49c5348b3674d3878f37f7670b>7.1.5 - kubeadm config</h1>
<p>在 <code>kubeadm init</code> 执行期间，kubeadm 将 <code>ClusterConfiguration</code> 对象上传
到你的集群的 <code>kube-system</code> 名字空间下名为 <code>kubeadm-config</code> 的 ConfigMap 对象中。
然后在 <code>kubeadm join</code>、<code>kubeadm reset</code> 和 <code>kubeadm upgrade</code> 执行期间读取此配置。
要查看此 ConfigMap，请调用 <code>kubeadm config view</code>。</p>
<p>你可以使用 <code>kubeadm config print</code> 命令打印默认配置，
并使用 <code>kubeadm config migrate</code> 命令将旧版本的配置转化成新版本。
<code>kubeadm config images list</code> 和 <code>kubeadm config images pull</code>
命令可以用来列出并拉取 kubeadm 所需的镜像。</p>
<p>更多信息请浏览<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file>使用带配置文件的 kubeadm init</a>
或<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/#config-file>使用带配置文件的 kubeadm join</a>.</p>
<p>你也可以在使用 <code>kubeadm init</code> 命令时配置若干 kubelet 配置选项。
这些选项对于集群中所有节点而言都是相同的。
参阅<a href=/zh/docs/setup/production-environment/tools/kubeadm/kubelet-integration/>使用 kubeadm 来配置集群中的各个 kubelet</a>
了解详细信息。</p>
<p>在 Kubernetes v1.13.0 及更高版本中，要列出/拉取 kube-dns 镜像而不是 CoreDNS 镜像，
必须使用<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon>这里</a>
所描述的 <code>--config</code> 方法。</p>
<h2 id=cmd-config-from-file>kubeadm config upload from-file</h2>
<h2 id=cmd-config-view>kubeadm config print</h2>
<p>打印配置</p>
<h3 id=概要>概要</h3>
<p>此命令打印子命令所提供的配置信息。
相关细节可参阅 <a href=https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2>https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2</a></p>
<pre><code>kubeadm config print [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>print 命令的帮助信息</p></td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承而来的选项>从父命令继承而来的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>与集群通信时使用的 kubeconfig 文件。如此标志未设置，将在一组标准位置中搜索现有的kubeconfig 文件。</p></td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>[试验性] 指向“真实”宿主根文件系统的路径。</p></td>
</tr>
</tbody>
</table>
<h2 id=cmd-config-print-init-defaults>kubeadm config print init-defaults</h2>
<h3 id=概要>概要</h3>
<p>此命令打印对象，例如用于 'kubeadm init' 的默认 init 配置对象。</p>
<p>请注意，Bootstrap Token 字段之类的敏感值已替换为 {"abcdef.0123456789abcdef" "" "nil" &lt;nil> [] []} 之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre><code>kubeadm config print init-defaults [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
init-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-config-print-join-defaults>kubeadm config print join-defaults</h2>
<h3 id=概要>概要</h3>
<p>此命令打印对象，例如用于 'kubeadm join' 的默认 join 配置对象。</p>
<p>请注意，诸如启动引导令牌字段之类的敏感值已替换为 {"abcdef.0123456789abcdef" "" "nil" &lt;nil> [] []}
之类的占位符值以通过验证，但不执行创建令牌的实际计算。</p>
<pre><code>kubeadm config print join-defaults [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--component-configs stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
组件配置 API 对象的逗号分隔列表，打印其默认值。可用值：[KubeProxyConfiguration KubeletConfiguration]。如果未设置此参数，则不会打印任何组件配置。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
join-defaults 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-config-migrate>kubeadm config migrate</h2>
<h3 id=概要>概要</h3>
<p>此命令允许您在 CLI 工具中将本地旧版本的配置对象转换为最新支持的版本，而无需变更集群中的任何内容。在此版本的 kubeadm 中，支持以下 API 版本：</p>
<ul>
<li>kubeadm.k8s.io/v1beta2</li>
</ul>
<p>因此，无论您在此处传递 --old-config 参数的版本是什么，当写入到 stdout 或 --new-config （如果已指定）时，
都会读取、反序列化、默认、转换、验证和重新序列化 API 对象。</p>
<p>换句话说，如果您将此文件传递给 "kubeadm init"，则该命令的输出就是 kubeadm 实际上在内部读取的内容。</p>
<pre><code>kubeadm config migrate [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
migrate 操作的帮助信息
</td>
</tr>
<tr>
<td colspan=2>--new-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用新的 API 版本生成的 kubeadm 配置文件的路径。这个路径是可选的。如果没有指定，输出将被写到 stdout。
</td>
</tr>
<tr>
<td colspan=2>--old-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用旧 API 版本且应转换的 kubeadm 配置文件的路径。此参数是必需的。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果未设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-config-images-list>kubeadm config images list</h2>
<h3 id=概要>概要</h3>
<p>打印 kubeadm 要使用的镜像列表。配置文件用于自定义任何镜像或镜像存储库。</p>
<pre><code>kubeadm config images list [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan=2>
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对（key=value），用于描述各种特征。选项是：
<br>Auditing=true|false (ALPHA - 默认=false)
<br>CoreDNS=true|false (默认=true)
<br>DynamicKubeletConfig=true|false (BETA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
list 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个特定的 Kubernetes 版本
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-config-images-pull>kubeadm config images pull</h2>
<h3 id=概要>概要</h3>
<p>拉取 kubeadm 使用的镜像。</p>
<pre><code>kubeadm config images pull [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个 CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一系列键值对（key=value），用于描述各种特征。可选项是：<br>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
pull 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=接下来>接下来</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/>kubeadm upgrade</a>
将 Kubernetes 集群升级到更新版本 [kubeadm upgrade]</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6eb5bc1e7114609930a76c683cc27c2b>7.1.6 - kubeadm reset</h1>
<p>该命令尽力还原由 <code>kubeadm init</code> 或 <code>kubeadm join</code> 所做的更改。</p>
<h3 id=概要>概要</h3>
<p>尽最大努力还原通过 'kubeadm init' 或者 'kubeadm join' 操作对主机所做的更改</p>
<p>"reset" 命令执行以下阶段：</p>
<pre><code>preflight              Run reset pre-flight checks
update-cluster-status  Remove this node from the ClusterStatus object.
remove-etcd-member     Remove a local etcd member.
cleanup-node           Run cleanup node.
</code></pre><pre><code>kubeadm reset [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>-f, --force</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
reset 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该标志，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--skip-phases stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要跳过的阶段列表
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h3 id=reset-workflow>Reset 工作流程</h3>
<p><code>kubeadm reset</code> 负责从使用 <code>kubeadm init</code> 或 <code>kubeadm join</code> 命令创建的文件中清除节点本地文件系统。对于控制平面节点，<code>reset</code> 还从 etcd 集群中删除该节点的本地 etcd 堆成员，还从 kubeadm <code>ClusterStatus</code> 对象中删除该节点的信息。
<code>ClusterStatus</code> 是一个 kubeadm 管理的 Kubernetes API 对象，该对象包含 kube-apiserver 端点列表。</p>
<p><code>kubeadm reset phase</code> 可用于执行上述工作流程的各个阶段。
要跳过阶段列表，你可以使用 <code>--skip-phases</code> 参数，该参数的工作方式类似于 <code>kubeadm join</code> 和 <code>kubeadm init</code> 阶段运行器。</p>
<h3 id=外部-etcd-清理>外部 etcd 清理</h3>
<p>如果使用了外部 etcd，<code>kubeadm reset</code> 将不会删除任何 etcd 中的数据。这意味着，如果再次使用相同的 etcd 端点运行 <code>kubeadm init</code>，你将看到先前集群的状态。</p>
<p>要清理 etcd 中的数据，建议你使用 etcdctl 这样的客户端，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>etcdctl del <span style=color:#b44>&#34;&#34;</span> --prefix
</code></pre></div>
<p>更多详情请参考 <a href=https://github.com/coreos/etcd/tree/master/etcdctl>etcd 文档</a>。</p>
<h2 id=接下来>接下来</h2>
<ul>
<li>参考 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a> 来初始化 Kubernetes 主节点。</li>
<li>参考 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> 来初始化 Kubernetes 工作节点并加入集群。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-516f4705fb2f5f62c76c7742772726a3>7.1.7 - kubeadm token</h1>
<p>如<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>使用引导令牌进行身份验证</a>所描述的，引导令牌用于在即将加入集群的节点和主节点间建立双向认证。</p>
<p><code>kubeadm init</code> 创建了一个有效期为 24 小时的令牌，下面的命令允许你管理令牌，也可以创建和管理新的令牌。</p>
<h2 id=cmd-token-create>kubeadm token create</h2>
<h3 id=概要>概要</h3>
<p>这个命令将为你创建一个引导令牌。
您可以设置此令牌的用途，"有效时间" 和可选的人性化的描述。</p>
<p>这里的 [token] 是指将要生成的实际令牌。
该令牌应该是一个通过安全机制生成的随机令牌，形式为 "[a-z0-9]{6}.[a-z0-9]{16}"。
如果没有给出 [token]，kubeadm 将生成一个随机令牌。</p>
<pre><code>kubeadm token create [token]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--description string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对令牌用途的人性化的描述。
</td>
</tr>
<tr>
<td colspan=2>
--groups stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[system:bootstrappers:kubeadm:default-node-token]
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此令牌用于身份验证时将进行身份验证的其他组。必须匹配 "\\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\\z"
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
create 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--print-join-command</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不仅仅打印令牌，而是打印使用令牌加入集群所需的完整 'kubeadm join' 参数。
</td>
</tr>
<tr>
<td colspan=2>
--ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
令牌有效时间，超过该时间令牌被自动删除。(例如： 1s, 2m, 3h)。如果设置为 '0'，令牌将永远不过期。
</td>
</tr>
<tr>
<td colspan=2>
--usages stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[signing,authentication]
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
描述可以使用此令牌的方式。你可以多次使用 `--usages` 或者提供一个以逗号分隔的选项列表。合法选项有: [signing,authentication]
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-token-delete>kubeadm token delete</h2>
<h3 id=概要>概要</h3>
<p>这个命令将为你删除指定的引导令牌列表。</p>
<p><code>[token-value]</code> 是要删除的 "[a-z0-9]{6}.[a-z0-9]{16}" 形式的完整令牌或者是 "[a-z0-9]{6}" 形式的的令牌 ID。</p>
<pre><code>kubeadm token delete [token-value] ...
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
delete 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 运行模式
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-token-generate>kubeadm token generate</h2>
<h3 id=概要>概要</h3>
<p>此命令将打印一个随机生成的可以被 "init" 和 "join" 命令使用的引导令牌。
您不必使用此命令来生成令牌。你可以自己设定，只要格式符合 "[a-z0-9]{6}.[a-z0-9]{16}"。这个命令提供是为了方便生成规定格式的令牌。
您也可以使用 "kubeadm init" 并且不指定令牌，该命令会生成一个令牌并打印出来。</p>
<pre><code>kubeadm token generate [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
generate 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 运行模式</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=cmd-token-list>kubeadm token list</h2>
<h3 id=概要>概要</h3>
<p>此命令将为您列出所有的引导令牌。</p>
<pre><code>kubeadm token list [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置为 true，则在模板中缺少字段或哈希表的键时忽略模板中的任何错误。
仅适用于 golang 和 jsonpath 输出格式。
</td>
</tr>
<tr>
<td colspan=2>
-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出格式：text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file 其中之一
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
list 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用 `dry-run` 模式
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
<h2 id=接下来>接下来</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> 引导 Kubernetes 工作节点并将其加入集群</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-34c4af6f36d969ed08ba840e7fb64c6d>7.1.8 - kubeadm version</h1>
<p>此命令用来输出 kubeadm 的版本。</p>
<h3 id=概要>概要</h3>
<p>打印 kubeadm 的版本</p>
<pre><code>kubeadm version [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
version 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>-o, --output string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出格式；可用的选项有 'yaml', 'json' 和 'short'
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-92a39c69c3689119dd5fa12886cb73a3>7.1.9 - kubeadm alpha</h1>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong>
<p><code>kubeadm alpha</code> 提供了一组可用于收集社区反馈的预览性质功能。
请试用这些功能并给我们提供反馈！
</div>
<p>目前在 <code>kubeadm alpha</code> 之下没有试验性质的命令。</p>
<h2 id=接下来>接下来</h2>
<ul>
<li>用来启动引导 Kubernetes 控制平面节点的
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a>
命令</li>
<li>用来将节点连接到集群的
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>
命令</li>
<li>用来还原 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改的
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
命令</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6a1fed09235bbf3644c804339928f10e>7.1.10 - kubeadm certs</h1>
<p><code>kubeadm certs</code> 提供管理证书的工具。关于如何使用这些命令的细节，可参见
<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/>使用 kubeadm 管理证书</a>。</p>
<h2 id=cmd-certs>kubeadm certs</h2>
<p>用来操作 Kubernetes 证书的一组命令。</p>
<ul class="nav nav-tabs" id=tab-certs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-0 role=tab aria-controls=tab-certs-0 aria-selected=true>概览</a></li>
</ul>
<div class=tab-content id=tab-certs><div id=tab-certs-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-0>
<p><h3 id=概要>概要</h3>
<p>与处理 kubernetes 证书相关的命令</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>certs 命令的帮助</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-certs-renew>kubeadm certs renew</h2>
<p>你可以使用 <code>all</code> 子命令来续订所有 Kubernetes 证书，也可以选择性地续订部分证书。
更多的相关细节，可参见
<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#manual-certificate-renewal>手动续订证书</a>。</p>
<ul class="nav nav-tabs" id=tab-certs-renew role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-renew-0 role=tab aria-controls=tab-certs-renew-0 aria-selected=true>renew</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-1 role=tab aria-controls=tab-certs-renew-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-2 role=tab aria-controls=tab-certs-renew-2>admin.conf</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-3 role=tab aria-controls=tab-certs-renew-3>apiserver-etcd-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-4 role=tab aria-controls=tab-certs-renew-4>apiserver-kubelet-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-5 role=tab aria-controls=tab-certs-renew-5>apiserver</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-6 role=tab aria-controls=tab-certs-renew-6>controller-manager.conf</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-7 role=tab aria-controls=tab-certs-renew-7>etcd-healthcheck-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-8 role=tab aria-controls=tab-certs-renew-8>etcd-peer</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-9 role=tab aria-controls=tab-certs-renew-9>etcd-server</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-10 role=tab aria-controls=tab-certs-renew-10>front-proxy-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-11 role=tab aria-controls=tab-certs-renew-11>scheduler.conf</a></li></ul>
<div class=tab-content id=tab-certs-renew><div id=tab-certs-renew-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-renew-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm certs renew [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
renew 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-1 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-1>
<p><h3 id=概要>概要</h3>
<p>续订运行控制平面所需的所有已知证书。续订是无条件进行的，与到期日期无关。续订也可以单独运行以进行更多控制。</p>
<pre><code>kubeadm certs renew all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-2 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-2>
<p><h3 id=概要>概要</h3>
<p>续订 kubeconfig 文件中嵌入的证书，供管理员 和 kubeadm 自身使用。</p>
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew admin.conf [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
admin.conf 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-3 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-3>
<p><h3 id=概要>概要</h3>
<p>续订 apiserver 用于访问 etcd 的证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver-etcd-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-4 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-4>
<p><h3 id=概要>概要</h3>
<p>续订 apiserver 用于连接 kubelet 的证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可能调用 K8s 证书 API 进行证书更新；亦或者，作为最后一个选择，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver-kubelet-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-5 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-5>
<p><h3 id=概要>概要</h3>
<p>续订用于提供 Kubernetes API 的证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书更新，或者作为最后一个选择来生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew apiserver [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver 子操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-6 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-6>
<p><h3 id=概要>概要</h3>
<p>续订 kubeconfig 文件中嵌入的证书，以供控制器管理器（Controller Manager）使用。</p>
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用 kubeadm 管理的本地 PKI 中的证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm alpha renew controller-manager.conf [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
controller-manager.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-7 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-7>
<p><h3 id=概要>概要</h3>
<p>续订存活态探针的证书，用于对 etcd 执行健康检查。</p>
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；作为替代方案，
也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-healthcheck-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-8 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-8>
<p><h3 id=概要>概要</h3>
<p>续订 etcd 节点间用来相互通信的证书。</p>
<p>无论证书的到期日期如何，续订都是无条件进行的；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用由 kubeadm 管理的本地 PKI 中的证书机构；
作为替代方案，也可以使用 K8s certificate API 进行证书续订，或者（作为最后一种选择）生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防证书文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-peer [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-9 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-9>
<p><h3 id=概要>概要</h3>
<p>续订用于提供 etcd 服务的证书。</p>
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试在 kubeadm 管理的本地 PKI 中使用证书颁发机构；作为替代方案，
可以使用 K8s 证书 API 进行证书续订，或者作为最后一种选择来生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew etcd-server [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-server 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-10 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-10>
<p><h3 id=概要>概要</h3>
<p>为前端代理客户端续订证书。</p>
<p>无论证书的到期日期如何，续订都会无条件地进行；SAN 等额外属性将基于现有文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订尝试使用位于 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种方案，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew front-proxy-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
输出 CSR 和私钥的路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-renew-11 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-11>
<p><h3 id=概要>概要</h3>
<p>续订 kubeconfig 文件中嵌入的证书，以供调度管理器使用。</p>
<p>续订无条件地进行，与证书的到期日期无关；SAN 等额外属性将基于现有的文件/证书，因此无需重新提供它们。</p>
<p>默认情况下，续订会尝试使用在 kubeadm 所管理的本地 PKI 中的证书颁发机构；作为替代方案，
也可以使用 K8s 证书 API 进行证书续订；亦或者，作为最后一种选择，生成 CSR 请求。</p>
<p>续订后，为了使更改生效，需要重新启动控制平面组件，并最终重新分发更新的证书，以防文件在其他地方使用。</p>
<pre><code>kubeadm certs renew scheduler.conf [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--csr-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CSR 和私钥的输出路径
</td>
</tr>
<tr>
<td colspan=2>--csr-only</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
创建 CSR 而不是生成证书
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
scheduler.conf 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。
如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--use-api</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 Kubernetes 证书 API 续订证书
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-certs-certificate-key>kubeadm certs certificate-key</h2>
<p>此命令可用来生成一个新的控制面证书密钥。密钥可以作为 <code>--certificate-key</code>
标志的取值传递给 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init><code>kubeadm init</code></a>
和 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join><code>kubeadm join</code></a>
命令，从而在添加新的控制面节点时能够自动完成证书复制。</p>
<ul class="nav nav-tabs" id=tab-certs-certificate-key role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-certificate-key-0 role=tab aria-controls=tab-certs-certificate-key-0 aria-selected=true>certificate-key</a></li>
</ul>
<div class=tab-content id=tab-certs-certificate-key><div id=tab-certs-certificate-key-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-certificate-key-0>
<p><h3 id=概要>概要</h3>
<p>该命令将打印出可以与 "init" 命令一起使用的安全的随机生成的证书密钥。</p>
<p>你也可以使用 <code>kubeadm init --upload-certs</code> 而无需指定证书密钥；
命令将为你生成并打印一个证书密钥。</p>
<pre><code>kubeadm certs certificate-key [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
certificate-key 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-certs-check-expiration>kubeadm certs check-expiration</h2>
<p>此命令检查 kubeadm 所管理的本地 PKI 中的证书是否以及何时过期。
更多的相关细节，可参见
<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#check-certificate-expiration>检查证书过期</a>。</p>
<ul class="nav nav-tabs" id=tab-certs-check-expiration role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-check-expiration-0 role=tab aria-controls=tab-certs-check-expiration-0 aria-selected=true>check-expiration</a></li>
</ul>
<div class=tab-content id=tab-certs-check-expiration><div id=tab-certs-check-expiration-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-check-expiration-0>
<p><h3 id=概要>概要</h3>
<p>检查 kubeadm 管理的本地 PKI 中证书的到期时间。</p>
<pre><code>kubeadm certs check-expiration [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存证书的路径</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>check-expiration 的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-certs-generate-csr>kubeadm certs generate-csr</h2>
<p>此命令可用来为所有控制面证书和 kubeconfig 文件生成密钥和 CSR（签名请求）。
用户可以根据自身需要选择 CA 为 CSR 签名。</p>
<ul class="nav nav-tabs" id=tab-certs-generate-csr role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-generate-csr-0 role=tab aria-controls=tab-certs-generate-csr-0 aria-selected=true>generate-csr</a></li>
</ul>
<div class=tab-content id=tab-certs-generate-csr><div id=tab-certs-generate-csr-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-generate-csr-0>
<p><p>为运行控制平面所需的所有证书生成密钥和证书签名请求（CSR）。该命令会生成部分 kubeconfig 文件，
其中 "users > user > client-key-data" 字段包含私钥数据，并为每个 kubeconfig
文件创建一个随附的 ".csr" 文件。</p>
<p>此命令设计用于
<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode>Kubeadm 外部 CA 模式</a>。
它生成你可以提交给外部证书颁发机构进行签名的 CSR。</p>
<p>应使用 ".crt" 作为文件扩展名将 PEM 编码的签名证书与密钥文件一起保存。
或者，对于 kubeconfig 文件，PEM 编码的签名证书应使用 base64 编码，
并添加到 "users > user > client-certificate-data" 字段。</p>
<pre><code>kubeadm certs generate-csr [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 以下命令将为所有控制平面证书和 kubeconfig 文件生成密钥和 CSR :
kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存证书的路径</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>generate-csr 命令的帮助</td>
</tr>
<tr>
<td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存 kubeconfig 文件的路径。</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=接下来>接下来</h2>
<ul>
<li>用来启动引导 Kubernetes 控制面节点的
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a>
命令</li>
<li>用来将节点连接到集群的
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>
命令</li>
<li>用来回滚 <code>kubeadm init</code> 或 <code>kubeadm join</code> 对当前主机所做修改的
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
命令</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fbe8dcd222ce5795a5c325670a26b067>7.1.11 - kubeadm init phase</h1>
<p><code>kubeadm init phase</code> 能确保调用引导过程的原子步骤。
因此，如果希望自定义应用，则可以让 kubeadm 做一些工作，然后填补空白。</p>
<p><code>kubeadm init phase</code> 与 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow>kubeadm init 工作流</a>
一致，后台都使用相同的代码。</p>
<h2 id=cmd-phase-preflight>kubeadm init phase preflight</h2>
<p>使用此命令可以在控制平面节点上执行启动前检查。</p>
<ul class="nav nav-tabs" id=tab-preflight role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-preflight-0 role=tab aria-controls=tab-preflight-0 aria-selected=true>preflight</a></li>
</ul>
<div class=tab-content id=tab-preflight><div id=tab-preflight-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-preflight-0>
<p><h3 id=概要>概要</h3>
<p>运行 kubeadm init 前的启动检查。</p>
<pre><code>kubeadm init phase preflight [flags]
</code></pre>
<h3 id=案例>案例</h3>
<pre><code># 使用配置文件对 kubeadm init 进行启动检查。
kubeadm init phase preflight --config kubeadm-config.yml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表：例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-kubelet-start>kubeadm init phase kubelet-start</h2>
<p>此阶段将检查 kubelet 配置文件和环境文件，然后启动 kubelet。</p>
<ul class="nav nav-tabs" id=tab-kubelet-start role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubelet-start-0 role=tab aria-controls=tab-kubelet-start-0 aria-selected=true>kubelet-start</a></li>
</ul>
<div class=tab-content id=tab-kubelet-start><div id=tab-kubelet-start-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubelet-start-0>
<p><h3 id=概要>概要</h3>
<p>使用 kubelet 配置文件编写一个文件，并使用特定节点的 kubelet 设置编写一个环境文件，然后（重新）启动 kubelet。</p>
<pre><code>kubeadm init phase kubelet-start [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 从 InitConfiguration 文件中写入带有 kubelet 参数的动态环境文件。
kubeadm init phase kubelet-start --config config.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
连接到 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-certs>kubeadm init phase certs</h2>
<p>该阶段可用于创建 kubeadm 所需的所有证书。</p>
<ul class="nav nav-tabs" id=tab-certs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-0 role=tab aria-controls=tab-certs-0 aria-selected=true>certs</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-1 role=tab aria-controls=tab-certs-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-2 role=tab aria-controls=tab-certs-2>ca</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-3 role=tab aria-controls=tab-certs-3>apiserver</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-4 role=tab aria-controls=tab-certs-4>apiserver-kubelet-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-5 role=tab aria-controls=tab-certs-5>front-proxy-ca</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-6 role=tab aria-controls=tab-certs-6>front-proxy-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-7 role=tab aria-controls=tab-certs-7>etcd-ca</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-8 role=tab aria-controls=tab-certs-8>etcd-server</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-9 role=tab aria-controls=tab-certs-9>etcd-peer</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-10 role=tab aria-controls=tab-certs-10>healthcheck-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-11 role=tab aria-controls=tab-certs-11>apiserver-etcd-client</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-12 role=tab aria-controls=tab-certs-12>sa</a></li></ul>
<div class=tab-content id=tab-certs><div id=tab-certs-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase certs [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
certs 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父指令中继承的选项>从父指令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-1 class=tab-pane role=tabpanel aria-labelledby=tab-certs-1>
<p><h3 id=概要>概要</h3>
<p>生成所有证书</p>
<pre><code>kubeadm init phase certs all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API 服务器服务证书的可选额外替代名称（SAN）。可以同时使用 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
VIP 服务使用其它的 IP 地址范围。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-2 class=tab-pane role=tabpanel aria-labelledby=tab-certs-2>
<p><h3 id=概要>概要</h3>
<p>生成自签名的 Kubernetes CA 以提供其他 Kubernetes 组件的身份，并将其保存到 ca.cert 和 ca.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs ca [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-3 class=tab-pane role=tabpanel aria-labelledby=tab-certs-3>
<p><h3 id=概要>概要</h3>
<p>生成用于服务 Kubernetes API 的证书，并将其保存到 apiserver.cert 和 apiserver.key 文件中。</p>
<p>默认 SAN 是 kubernetes、kubernetes.default、kubernetes.default.svc、kubernetes.default.svc.cluster.local、10.96.0.1、127.0.0.1。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-cert-extra-sans stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API Server 服务证书的可选附加主体备用名称（SAN）。可以是 IP 地址和 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定服务 VIP 可使用的其他 IP 地址段。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-4 class=tab-pane role=tabpanel aria-labelledby=tab-certs-4>
<p><h3 id=概要>概要</h3>
<p>生成供 API 服务器连接 kubelet 的证书，并将其保存到 apiserver-kubelet-client.cert 和 apiserver-kubelet-client.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver-kubelet-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-kubelet-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向宿主机上的 '实际' 根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-5 class=tab-pane role=tabpanel aria-labelledby=tab-certs-5>
<p><h3 id=概要>概要</h3>
<p>生成自签名 CA 来提供前端代理的身份，并将其保存到 front-proxy-ca.cert 和 front-proxy-ca.key 文件中。</p>
<p>如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。</p>
<p>Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre><code>kubeadm init phase certs front-proxy-ca [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
front-proxy-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-6 class=tab-pane role=tabpanel aria-labelledby=tab-certs-6>
<p><h3 id=概要>概要</h3>
<p>为前端代理客户端生成证书，并将其保存到 front-proxy-client.cert 和 front-proxy-client.key 文件中。
如果两个文件都已存在，kubeadm 将跳过生成步骤并将使用现有文件。
Alpha 免责声明：此命令目前是 alpha 阶段。</p>
<pre><code>kubeadm init phase certs front-proxy-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
front-proxy-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-7 class=tab-pane role=tabpanel aria-labelledby=tab-certs-7>
<p><h3 id=概要>概要</h3>
<p>生成用于为 etcd 设置身份的自签名 CA，并将其保存到 etcd/ca.cert 和 etcd/ca.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-ca [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-ca 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-8 class=tab-pane role=tabpanel aria-labelledby=tab-certs-8>
<p><h3 id=概要>概要</h3>
<p>生成用于提供 etcd 服务的证书，并将其保存到 etcd/server.cert 和 etcd/server.key 文件中。</p>
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-server [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-server 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-9 class=tab-pane role=tabpanel aria-labelledby=tab-certs-9>
<p><h3 id=概要>概要</h3>
<p>生成 etcd 节点相互通信的证书，并将其保存到 etcd/peer.cert 和 etcd/peer.key 文件中。</p>
<p>默认 SAN 为 localhost、127.0.0.1、127.0.0.1、:: 1</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-peer [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-peer 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-10 class=tab-pane role=tabpanel aria-labelledby=tab-certs-10>
<p><h3 id=概要>概要</h3>
<p>生成用于 etcd 健康检查的活跃性探针的证书，并将其保存到 healthcheck-client.cert 和 etcd/healthcheck-client.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 功能。</p>
<pre><code>kubeadm init phase certs etcd-healthcheck-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书存储的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd-healthcheck-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-11 class=tab-pane role=tabpanel aria-labelledby=tab-certs-11>
<p><h3 id=概要>概要</h3>
<p>生成 apiserver 用于访问 etcd 的证书，并将其保存到 apiserver-etcd-client.cert 和 apiserver-etcd-client.key 文件中。</p>
<p>如果两个文件都已存在，则 kubeadm 将跳过生成步骤，使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 Alpha 功能。</p>
<pre><code>kubeadm init phase certs apiserver-etcd-client [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书的存储路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver-etcd-client 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-certs-12 class=tab-pane role=tabpanel aria-labelledby=tab-certs-12>
<p><h3 id=概要>概要</h3>
<p>生成用于签名 service account 令牌的私钥及其公钥，并将其保存到 sa.key 和 sa.pub 文件中。如果两个文件都已存在，则 kubeadm 会跳过生成步骤，而将使用现有文件。</p>
<p>Alpha 免责声明：此命令当前为 alpha 阶段。</p>
<pre><code>kubeadm init phase certs sa [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
sa 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-kubeconfig>kubeadm init phase kubeconfig</h2>
<p>可以通过调用 <code>all</code> 子命令来创建所有必需的 kubeconfig 文件，或者分别调用它们。</p>
<ul class="nav nav-tabs" id=tab-kubeconfig role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubeconfig-0 role=tab aria-controls=tab-kubeconfig-0 aria-selected=true>kubeconfig</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-1 role=tab aria-controls=tab-kubeconfig-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-2 role=tab aria-controls=tab-kubeconfig-2>admin</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-3 role=tab aria-controls=tab-kubeconfig-3>kubelet</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-4 role=tab aria-controls=tab-kubeconfig-4>controller-manager</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubeconfig-5 role=tab aria-controls=tab-kubeconfig-5>scheduler</a></li></ul>
<div class=tab-content id=tab-kubeconfig><div id=tab-kubeconfig-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubeconfig-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请阅读可用子命令列表。</p>
<pre><code>kubeadm init phase kubeconfig [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-kubeconfig-1 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-1>
<p><h3 id=概要>概要</h3>
<p>生成所有 kubeconfig 文件</p>
<pre><code>kubeadm init phase kubeconfig all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果没有设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-kubeconfig-2 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-2>
<p><h3 id=概要>概要</h3>
<p>为管理员和 kubeadm 本身生成 kubeconfig 文件，并将其保存到 admin.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig admin [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
admin 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-kubeconfig-3 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-3>
<p><h3 id=概要>概要</h3>
<p>生成 kubelet 要使用的 kubeconfig 文件，并将其保存到 kubelet.conf 文件。</p>
<p>请注意，该操作目的是<em>仅</em>应用于引导集群。在控制平面启动之后，应该从 CSR API 请求所有 kubelet 凭据。</p>
<pre><code>kubeadm init phase kubeconfig kubelet [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-kubeconfig-4 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-4>
<p><h3 id=概要>概要</h3>
<p>生成控制器管理器要使用的 kubeconfig 文件，并保存到 controller-manager.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig controller-manager [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
</tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-kubeconfig-5 class=tab-pane role=tabpanel aria-labelledby=tab-kubeconfig-5>
<p><h3 id=概要>概要</h3>
<p>生成调度器（scheduler）要使用的 kubeconfig 文件，并保存到 scheduler.conf 文件中。</p>
<pre><code>kubeadm init phase kubeconfig scheduler [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 文件的保存路径。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定特定的 Kubernetes 版本。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-control-plane>kubeadm init phase control-plane</h2>
<p>使用此阶段，可以为控制平面组件创建所有必需的静态 Pod 文件。</p>
<ul class="nav nav-tabs" id=tab-control-plane role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-control-plane-0 role=tab aria-controls=tab-control-plane-0 aria-selected=true>control-plane</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-1 role=tab aria-controls=tab-control-plane-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-2 role=tab aria-controls=tab-control-plane-2>apiserver</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-3 role=tab aria-controls=tab-control-plane-3>controller-manager</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-4 role=tab aria-controls=tab-control-plane-4>scheduler</a></li></ul>
<div class=tab-content id=tab-control-plane><div id=tab-control-plane-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-control-plane-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-1 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-1>
<p><h3 id=概要>概要</h3>
<p>生成所有的静态 Pod 清单文件</p>
<pre><code>kubeadm init phase control-plane all [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 为控制平面组件生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase control-plane all

# 使用从某配置文件中读取的选项为生成静态 Pod 清单文件。
kubeadm init phase control-plane all --config config.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认的网络接口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
形式为 &lt;flagname>=&lt;value> 的一组额外参数，用来传递给 API 服务器，
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择一个稳定的 IP 地址或者 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组形式为 &lt;flagname>=&lt;value> 的额外参数，用来传递给控制管理器（Controller Manager）
或覆盖其默认设置值
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组用来描述各种特性门控的键值（key=value）对。选项是：
<br>IPv6DualStack=true|false (ALPHA - 默认=false)
<br>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择指定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果设置了此标志，控制平面将自动地为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan=2>--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组形式为 &lt;flagname>=&lt;value> 的额外参数，用来传递给调度器（Scheduler）
或覆盖其默认设置值
<p>传递给调度器（scheduler）一组额外的参数或者以 &lt;flagname>=&lt;value> 形式覆盖其默认值。</p>
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
</tbody>
</table>
<h3 id=从父指令继承的选项>从父指令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机的根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-2 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-2>
<p><h3 id=概要>概要</h3>
<p>生成 kube-apiserver 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane apiserver [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： 6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要绑定到 API 服务器的端口。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组 &lt;flagname>=&lt;value> 形式的额外参数，用来传递给 API 服务器
或者覆盖其默认参数配置
</td>
</tr>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保存和存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对，用于描述各种功能特性的特性门控。选项是：
<br>IPv6DualStack=true|false (ALPHA - 默认=false)
<br>PublicKeysECDSA=true|false (ALPHA - 默认=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
apiserver 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-3 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-3>
<p><h3 id=概要>概要</h3>
<p>生成 kube-controller-manager 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane controller-manager [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--controller-manager-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组 &lt;flagname>=&lt; 形式的额外参数，传递给控制器管理器（Controller Manager）
或者覆盖其默认配置值
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
controller-manager 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-4 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-4>
<p><h3 id=概要>概要</h3>
<p>生成 kube-scheduler 静态 Pod 清单</p>
<pre><code>kubeadm init phase control-plane scheduler [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录。
例如，"kube-apiserver0+merge.yaml" 或者 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，分别与 kubectl
所支持的 patch 格式相匹配。默认的 "patchtype" 是 "strategic"。
"extension" 必须是 "json" 或 "yaml"。
"suffix" 是一个可选的字符串，用来确定按字母顺序排序时首先应用哪些 patch。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
scheduler 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值:"k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--scheduler-extra-args mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组 &lt;flagname>=&lt;value> 形式的额外参数，用来传递给调度器
或者覆盖其默认参数配置
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-etcd>kubeadm init phase etcd</h2>
<p>根据静态 Pod 文件，使用以下阶段创建本地 etcd 实例。</p>
<ul class="nav nav-tabs" id=tab-etcd role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-etcd-0 role=tab aria-controls=tab-etcd-0 aria-selected=true>etcd</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-etcd-1 role=tab aria-controls=tab-etcd-1>local</a></li></ul>
<div class=tab-content id=tab-etcd><div id=tab-etcd-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-etcd-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase etcd [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-etcd-1 class=tab-pane role=tabpanel aria-labelledby=tab-etcd-1>
<p><h3 id=概要>概要</h3>
<p>为本地单节点 etcd 实例生成静态 Pod 清单文件</p>
<pre><code>kubeadm init phase etcd local [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 为 etcd 生成静态 Pod 清单文件，其功能等效于 kubeadm init 生成的文件。
kubeadm init phase etcd local

# 使用从配置文件读取的选项为 etcd 生成静态 Pod 清单文件。
kubeadm init phase etcd local --config config.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的路径。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
local 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择要从中拉取控制平面镜像的容器仓库
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-upload-config>kubeadm init phase upload-config</h2>
<p>可以使用此命令将 kubeadm 配置文件上传到集群。或者使用
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config</a>。</p>
<ul class="nav nav-tabs" id=upload-config role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#upload-config-0 role=tab aria-controls=upload-config-0 aria-selected=true>upload-config</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#upload-config-1 role=tab aria-controls=upload-config-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#upload-config-2 role=tab aria-controls=upload-config-2>kubeadm</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#upload-config-3 role=tab aria-controls=upload-config-3>kubelet</a></li></ul>
<div class=tab-content id=upload-config><div id=upload-config-0 class="tab-pane show active" role=tabpanel aria-labelledby=upload-config-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用的子命令列表。</p>
<pre><code>kubeadm init phase upload-config [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
upload-config 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=upload-config-1 class=tab-pane role=tabpanel aria-labelledby=upload-config-1>
<p><h3 id=概要>概要</h3>
<p>将所有配置上传到 ConfigMap</p>
<pre><code>kubeadm init phase upload-config all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=upload-config-2 class=tab-pane role=tabpanel aria-labelledby=upload-config-2>
<p><h3 id=概要>概要</h3>
<p>将 kubeadm ClusterConfiguration 上传到 kube-system 命名空间中名为 kubeadm-config 的 ConfigMap 中。
这样就可以正确配置系统组件，并在升级时提供无缝的用户体验。</p>
<p>另外，可以使用 kubeadm 配置。</p>
<pre><code>kubeadm init phase upload-config kubeadm [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 上传集群配置
kubeadm init phase upload-config --config=myConfig.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=upload-config-3 class=tab-pane role=tabpanel aria-labelledby=upload-config-3>
<p><h3 id=概要>概要</h3>
<p>将从 kubeadm InitConfiguration 对象提取的 kubelet 配置上传到集群中 kubelet-config-1.X 形式的
ConfigMap，其中 X 是当前（API 服务器）Kubernetes 版本的次要版本。</p>
<pre><code>kubeadm init phase upload-config kubelet [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 将 kubelet 配置从 kubeadm 配置文件上传到集群中的 ConfigMap。
kubeadm init phase upload-config kubelet --config kubeadm.yaml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
到 kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该标签，则可以通过一组标准路径来寻找已有的 kubeconfig 文件。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-upload-certs>kubeadm init phase upload-certs</h2>
<p>使用以下阶段将控制平面证书上传到集群。默认情况下，证书和加密密钥会在两个小时后过期。</p>
<ul class="nav nav-tabs" id=tab-upload-certs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-upload-certs-0 role=tab aria-controls=tab-upload-certs-0 aria-selected=true>upload-certs</a></li>
</ul>
<div class=tab-content id=tab-upload-certs><div id=tab-upload-certs-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-upload-certs-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase upload-certs [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于加密 kubeadm-certs Secret 中的控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
upload-certs 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用来与集群通信的 kubeconfig 文件。
如果此标志未设置，则可以在一组标准的位置搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--skip-certificate-key-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不要打印输出用于加密控制平面证书的密钥。
</td>
</tr>
<tr>
<td colspan=2>--upload-certs</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将控制平面证书上传到 kubeadm-certs Secret。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-mark-control-plane>kubeadm init phase mark-control-plane</h2>
<p>使用以下阶段来给具有 <code>node-role.kubernetes.io/master=""</code> 键值对的节点
打标签（label）和记录污点（taint）。</p>
<ul class="nav nav-tabs" id=tab-mark-control-plane role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-mark-control-plane-0 role=tab aria-controls=tab-mark-control-plane-0 aria-selected=true>mark-control-plane</a></li>
</ul>
<div class=tab-content id=tab-mark-control-plane><div id=tab-mark-control-plane-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-mark-control-plane-0>
<p><h3 id=概要>概要</h3>
<p>标记 Node 节点为控制平面节点</p>
<pre><code>kubeadm init phase mark-control-plane [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 将控制平面标签和污点应用于当前节点，其功能等效于 kubeadm init执行的操作。
kubeadm init phase mark-control-plane --config config.yml

# 将控制平面标签和污点应用于特定节点
kubeadm init phase mark-control-plane --node-name myNode
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs 字符串</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-bootstrap-token>kubeadm init phase bootstrap-token</h2>
<p>使用以下阶段来配置引导令牌。</p>
<ul class="nav nav-tabs" id=tab-bootstrap-token role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-bootstrap-token-0 role=tab aria-controls=tab-bootstrap-token-0 aria-selected=true>bootstrap-token</a></li>
</ul>
<div class=tab-content id=tab-bootstrap-token><div id=tab-bootstrap-token-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-bootstrap-token-0>
<p><h3 id=概要>概要</h3>
<p>启动引导令牌（bootstrap token）用于在即将加入集群的节点和控制平面节点之间建立双向信任。</p>
<p>该命令使启动引导令牌（bootstrap token）所需的所有配置生效，然后创建初始令牌。</p>
<pre><code>kubeadm init phase bootstrap-token [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 进行所有引导令牌配置，并创建一个初始令牌，功能上与 kubeadm init 生成的令牌等效。
kubeadm init phase bootstrap-token
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
bootstrap-token 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于和集群通信的 kubeconfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>--skip-token-print</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
跳过打印 'kubeadm init' 生成的默认引导令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-kubelet-finalize-all>kubeadm init phase kubelet-finialize</h2>
<p>使用以下阶段在 TLS 引导后更新与 kubelet 相关的设置。
你可以使用 <code>all</code> 子命令来运行所有 <code>kubelet-finalize</code> 阶段。</p>
<ul class="nav nav-tabs" id=tab-kubelet-finalize role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubelet-finalize-0 role=tab aria-controls=tab-kubelet-finalize-0 aria-selected=true>kublet-finalize</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubelet-finalize-1 role=tab aria-controls=tab-kubelet-finalize-1>kublet-finalize-all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-kubelet-finalize-2 role=tab aria-controls=tab-kubelet-finalize-2>kublet-finalize-cert-rotation</a></li></ul>
<div class=tab-content id=tab-kubelet-finalize><div id=tab-kubelet-finalize-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubelet-finalize-0>
<p><p>TLS 引导后更新与 kubelet 相关的设置</p>
<pre><code>kubeadm init phase kubelet-finalize [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubelet-finalize 操作的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-kubelet-finalize-1 class=tab-pane role=tabpanel aria-labelledby=tab-kubelet-finalize-1>
<p><p>运行所有 kubelet-finalize 阶段</p>
<pre><code>kubeadm init phase kubelet-finalize all [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code>  # 在 TLS 引导后更新与 kubelet 相关的设置
  kubeadm init phase kubelet-finalize all --config
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>all 操作的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-kubelet-finalize-2 class=tab-pane role=tabpanel aria-labelledby=tab-kubelet-finalize-2>
<p><p>启用 kubelet 客户端证书轮换</p>
<pre><code>kubeadm init phase kubelet-finalize experimental-cert-rotation [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>保存和存储证书的路径。</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>kubeadm 配置文件的路径。</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>experimental-cert-rotation 操作的帮助命令</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-phase-addon>kubeadm init phase addon</h2>
<p>可以使用 <code>all</code> 子命令安装所有可用的插件，或者有选择性地安装它们。</p>
<ul class="nav nav-tabs" id=tab-addon role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-addon-0 role=tab aria-controls=tab-addon-0 aria-selected=true>addon</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-addon-1 role=tab aria-controls=tab-addon-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-addon-2 role=tab aria-controls=tab-addon-2>coredns</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-addon-3 role=tab aria-controls=tab-addon-3>kube-proxy</a></li></ul>
<div class=tab-content id=tab-addon><div id=tab-addon-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-addon-0>
<p><h3 id=概要>概要</h3>
<p>此命令并非设计用来单独运行。请参阅可用子命令列表。</p>
<pre><code>kubeadm init phase addon [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
addon 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-addon-1 class=tab-pane role=tabpanel aria-labelledby=tab-addon-1>
<p><h3 id=概要>概要</h3>
<p>安装所有插件（addon）</p>
<pre><code>kubeadm init phase addon all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组键值对（key=value），描述了各种特征。选项包括：<br>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务 VIP 使用 IP 地址的其他范围。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务使用其他域名，例如 "myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-addon-2 class=tab-pane role=tabpanel aria-labelledby=tab-addon-2>
<p><h3 id=概要>概要</h3>
<p>通过 API 服务器安装 CoreDNS 附加组件。请注意，即使 DNS 服务器已部署，在安装 CNI 之前 DNS 服务器不会被调度执行。</p>
<pre><code>kubeadm init phase addon coredns [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组用来描述各种功能特性的键值（key=value）对。选项是：<br>IPv6DualStack=true|false (ALPHA - 默认值=false)
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
coredns 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>
--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："10.96.0.0/12"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为服务 VIP 选择 IP 地址范围。
</td>
</tr>
<tr>
<td colspan=2>
--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："cluster.local"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务使用其它的域名，例如："myorg.internal"。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-addon-3 class=tab-pane role=tabpanel aria-labelledby=tab-addon-3>
<p><h3 id=概要>概要</h3>
<p>通过 API 服务器安装 kube-proxy 附加组件。</p>
<pre><code>kubeadm init phase addon kube-proxy [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器所公布的其正在监听的 IP 地址。如果未设置，则将使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面指定一个稳定的 IP 地址或 DNS 名称。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kube-proxy 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>
--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："k8s.gcr.io"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
选择用于拉取控制平面镜像的容器仓库
</td>
</tr>
<tr>
<td colspan=2>
--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/admin.conf"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与集群通信时使用的 kubeconfig 文件。如果未设置该参数，则可以在一组标准位置中搜索现有的 kubeconfig 文件。
</td>
</tr>
<tr>
<td colspan=2>
--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："stable-1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为控制平面选择特定的 Kubernetes 版本。
</td>
</tr>
<tr>
<td colspan=2>--pod-network-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 Pod 网络的 IP 地址范围。如果已设置，控制平面将自动为每个节点分配 CIDR。
</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<p>有关 <code>v1beta2</code> 配置中每个字段的更多详细信息，可以访问
<a href=https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2>API</a>。</p>
<h2 id=接下来>接下来</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a>
引导 Kubernetes 控制平面节点</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>
将节点加入到集群</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
恢复通过 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/>kubeadm alpha</a>
尝试实验性功能</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-62a742c564b0b5b7ac12a95e67cc425a>7.1.12 - kubeadm join phase</h1>
<p><code>kubeadm join phase</code> 使你能够调用 <code>join</code> 过程的基本原子步骤。
因此，如果希望执行自定义操作，可以让 kubeadm 做一些工作，然后由用户来补足剩余操作。</p>
<p><code>kubeadm join phase</code> 与
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/#join-workflow>kubeadm join 工作流程</a>
一致，后台都使用相同的代码。</p>
<h2 id=cmd-join-phase>kubeadm join phase</h2>
<ul class="nav nav-tabs" id=tab-phase role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-phase-0 role=tab aria-controls=tab-phase-0 aria-selected=true>phase</a></li>
</ul>
<div class=tab-content id=tab-phase><div id=tab-phase-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-phase-0>
<p><h3 id=概要>概要</h3>
<p>使用此命令来调用 <code>join</code> 工作流程的某个阶段</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-join-phase-preflight>kubeadm join phase preflight</h2>
<p>使用此命令可以在即将加入集群的节点上执行启动前检查。</p>
<ul class="nav nav-tabs" id=tab-preflight role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-preflight-0 role=tab aria-controls=tab-preflight-0 aria-selected=true>preflight</a></li>
</ul>
<div class=tab-content id=tab-preflight><div id=tab-preflight-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-preflight-0>
<p><h3 id=概要>概要</h3>
<p>运行 kubeadm join 命令添加节点前检查。</p>
<pre><code>kubeadm join phase preflight [api-server-endpoint] [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 使用配置文件运行 kubeadm join 命令添加节点前检查。
kubeadm join phase preflight --config kubeadm-config.yml
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 `init` 操作上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-join-phase-control-plane-prepare>kubeadm join phase control-plane-prepare</h2>
<p>使用此阶段，你可以准备一个作为控制平面的节点。</p>
<ul class="nav nav-tabs" id=tab-control-plane-prepare role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-control-plane-prepare-0 role=tab aria-controls=tab-control-plane-prepare-0 aria-selected=true>control-plane-prepare</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-1 role=tab aria-controls=tab-control-plane-prepare-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-2 role=tab aria-controls=tab-control-plane-prepare-2>download-certs</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-3 role=tab aria-controls=tab-control-plane-prepare-3>certs</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-4 role=tab aria-controls=tab-control-plane-prepare-4>kubeconfig</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-prepare-5 role=tab aria-controls=tab-control-plane-prepare-5>control-plane</a></li></ul>
<div class=tab-content id=tab-control-plane-prepare><div id=tab-control-plane-prepare-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-control-plane-prepare-0>
<p><h3 id=概要>概要</h3>
<p>准备为控制平面服务的机器</p>
<pre><code>kubeadm join phase control-plane-prepare [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 准备为控制平面服务的机器
kubeadm join phase control-plane-prepare all
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane-prepare 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-prepare-1 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-1>
<p><h3 id=概要>概要</h3>
<p>准备为控制平面服务的机器</p>
<pre><code>kubeadm join phase control-plane-prepare all [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则为 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥解密由 init 上传的证书 secrets。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-prepare-2 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-2>
<p><h3 id=概要>概要</h3>
<p>[实验]从 kubeadm-certs Secret 下载控制平面节点之间共享的证书</p>
<pre><code>kubeadm join phase control-plane-prepare download-certs [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-prepare-3 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-3>
<p><h3 id=概要>概要</h3>
<p>为新的控制平面组件生成证书</p>
<pre><code>kubeadm join phase control-plane-prepare certs [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
certs 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-prepare-4 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-4>
<p><h3 id=概要>概要</h3>
<p>为新的控制平面组件生成 kubeconfig</p>
<pre><code>kubeadm join phase control-plane-prepare kubeconfig [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用此密钥可以解密由 init 上传的证书 secret。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，请验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-prepare-5 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-prepare-5>
<p><h3 id=概要>概要</h3>
<p>为新的控制平面组件生成清单（manifest）</p>
<pre><code>kubeadm join phase control-plane-prepare control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于将要托管新的控制平面实例的节点，指定 API 服务器将公布的其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>
--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对将要托管新的控制平面实例的节点，设置 API 服务器要绑定的端口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-join-phase-kubelet-start>kubeadm join phase kubelet-start</h2>
<p>使用此阶段，你可以配置 kubelet 设置、证书和（重新）启动 kubelet。</p>
<ul class="nav nav-tabs" id=tab-kubelet-start role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubelet-start-0 role=tab aria-controls=tab-kubelet-start-0 aria-selected=true>kubelet-start</a></li>
</ul>
<div class=tab-content id=tab-kubelet-start><div id=tab-kubelet-start-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubelet-start-0>
<p><h3 id=概要>概要</h3>
<p>生成一个包含 KubeletConfiguration 的文件和一个包含特定于节点的 kubelet 配置的环境文件，然后（重新）启动 kubelet。</p>
<pre><code>kubeadm join phase kubelet-start [api-server-endpoint] [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
提供给 CRI 套接字建立连接的路径。如果为空，则 kubeadm 将尝试自动检测该值；仅当安装了多个 CRI 或具有非标准 CRI 套接字时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>--discovery-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
For file-based discovery, a file or URL from which to load cluster information.
对于基于文件的发现，给出用于加载集群信息的文件或者 URL。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，该令牌用于验证从 API 服务器获取的集群信息。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-ca-cert-hash stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，验证根 CA 公钥是否匹配此哈希值（格式："&lt;type>:&lt;value>"）。
</td>
</tr>
<tr>
<td colspan=2>--discovery-token-unsafe-skip-ca-verification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于基于令牌的发现，允许在未关联 --discovery-token-ca-cert-hash 参数的情况下添加节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet-start 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
<tr>
<td colspan=2>--tls-bootstrap-token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定在加入节点时用于临时通过 Kubernetes 控制平面进行身份验证的令牌。
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果未提供这些值，则将它们用于 discovery-token 令牌和 tls-bootstrap 令牌。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-join-phase-control-plane-join>kubeadm join phase control-plane-join</h2>
<p>使用此阶段，你可以将节点作为控制平面实例加入。</p>
<ul class="nav nav-tabs" id=tab-control-plane-join role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-control-plane-join-0 role=tab aria-controls=tab-control-plane-join-0 aria-selected=true>control-plane-join</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-join-1 role=tab aria-controls=tab-control-plane-join-1>all</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-join-2 role=tab aria-controls=tab-control-plane-join-2>etcd</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-join-3 role=tab aria-controls=tab-control-plane-join-3>update-status</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-control-plane-join-4 role=tab aria-controls=tab-control-plane-join-4>mark-control-plane</a></li></ul>
<div class=tab-content id=tab-control-plane-join><div id=tab-control-plane-join-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-control-plane-join-0>
<p><h3 id=概要>概要</h3>
<p>添加作为控制平面实例的机器</p>
<pre><code>kubeadm join phase control-plane-join [flags]
</code></pre>
<h3 id=示例>示例</h3>
<pre><code># 将机器作为控制平面实例加入
kubeadm join phase control-plane-join all
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
control-plane-join 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-join-1 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-join-1>
<p><h3 id=概要>概要</h3>
<p>添加作为控制平面实例的机器</p>
<pre><code>kubeadm join phase control-plane-join all [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--experimental-control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
all 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-join-2 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-join-2>
<p><h3 id=概要>概要</h3>
<p>添加新的本地 etcd 成员</p>
<pre><code>kubeadm join phase control-plane-join etcd [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是"strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-join-3 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-join-3>
<p><h2 id=概要>概要</h2>
<p>将新的控制平面节点注册到 kubeadm-config ConfigMap 维护的 ClusterStatus 中</p>
<pre><code>kubeadm join phase control-plane-join update-status [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--apiserver-advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果该节点托管一个新的控制平面实例，则 API 服务器将公布其正在侦听的 IP 地址。如果未设置，则使用默认网络接口。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
update-status 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点名称。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-control-plane-join-4 class=tab-pane role=tabpanel aria-labelledby=tab-control-plane-join-4>
<p><h3 id=概要>概要</h3>
<p>将 Node 节点标记为控制平面节点</p>
<pre><code>kubeadm join phase control-plane-join mark-control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeadm 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--control-plane</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此节点上创建一个新的控制平面实例
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
mark-control-plane 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--node-name string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定节点的名称
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令中继承的选项>从父命令中继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 到 '真实' 主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=接下来>接下来</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a>
引导 Kubernetes 控制平面节点</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>
将节点添加到集群</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
恢复通过 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/>kubeadm alpha</a>
尝试实验性功能</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b969d0033ce5d9036463521fb1f150b3>7.1.13 - kubeadm reset phase</h1>
<p><code>kubeadm reset phase</code> 使你能够调用 <code>reset</code> 过程的基本原子步骤。
因此，如果希望执行自定义操作，可以让 kubeadm 做一些工作，然后由用户来补足剩余操作。</p>
<p><code>kubeadm reset phase</code> 与
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/#reset-workflow>kubeadm reset 工作流程</a>
一致，后台都使用相同的代码。</p>
<h2 id=cmd-reset-phase>kubeadm reset phase</h2>
<ul class="nav nav-tabs" id=tab-phase role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-phase-0 role=tab aria-controls=tab-phase-0 aria-selected=true>phase</a></li>
</ul>
<div class=tab-content id=tab-phase><div id=tab-phase-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-phase-0>
<p><h3 id=概要>概要</h3>
<p>使用此命令来调用 <code>reset</code> 工作流程的某个阶段</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-reset-phase-preflight>kubeadm reset phase preflight</h2>
<p>使用此阶段，你可以在要重置的节点上执行启动前检查阶段。</p>
<ul class="nav nav-tabs" id=tab-preflight role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-preflight-0 role=tab aria-controls=tab-preflight-0 aria-selected=true>preflight</a></li>
</ul>
<div class=tab-content id=tab-preflight><div id=tab-preflight-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-preflight-0>
<p><h3 id=概要>概要</h3>
<p>kubeadm reset（重置）前运行启动前检查。</p>
<pre><code>kubeadm reset phase preflight [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-f, --force</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在不提示确认的情况下重置节点。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
preflight 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
错误将显示为警告的检查列表；例如：'IsPrivilegedUser,Swap'。取值为 'all' 时将忽略检查中的所有错误。
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-reset-phase-update-cluster-status>kubeadm reset phase update-cluster-status</h2>
<p>使用此阶段，你可以从 ClusterStatus 对象中删除此控制平面节点。</p>
<ul class="nav nav-tabs" id=tab-update-cluster-status role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-update-cluster-status-0 role=tab aria-controls=tab-update-cluster-status-0 aria-selected=true>update-cluster-status</a></li>
</ul>
<div class=tab-content id=tab-update-cluster-status><div id=tab-update-cluster-status-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-update-cluster-status-0>
<p><h3 id=概要>概要</h3>
<p>如果该节点是控制平面节点，从 ClusterStatus 对象中删除该节点。</p>
<pre><code>kubeadm reset phase update-cluster-status [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
update-cluster-status 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-reset-phase-remove-etcd-member>kubeadm reset phase remove-etcd-member</h2>
<p>使用此阶段，你可以从 etcd 集群中删除此控制平面节点的 etcd 成员。</p>
<ul class="nav nav-tabs" id=tab-remove-etcd-member role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-remove-etcd-member-0 role=tab aria-controls=tab-remove-etcd-member-0 aria-selected=true>remove-etcd-member</a></li>
</ul>
<div class=tab-content id=tab-remove-etcd-member><div id=tab-remove-etcd-member-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-remove-etcd-member-0>
<p><h3 id=概要>概要</h3>
<p>上传关于当前状态的配置，以便 'kubeadm upgrade' 以后可以知道如何配置升级后的集群。</p>
<pre><code>kubeadm config upload [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>upload 操作的帮助信息</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=cmd-reset-phase-cleanup-node>kubeadm reset phase cleanup-node</h2>
<p>使用此阶段，你可以在此节点上执行清理工作。</p>
<ul class="nav nav-tabs" id=tab-cleanup-node role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-cleanup-node-0 role=tab aria-controls=tab-cleanup-node-0 aria-selected=true>cleanup-node</a></li>
</ul>
<div class=tab-content id=tab-cleanup-node><div id=tab-cleanup-node-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-cleanup-node-0>
<p><h3 id=概要>概要</h3>
<p>执行 cleanup node（清理节点）操作。</p>
<pre><code>kubeadm reset phase cleanup-node [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>
--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/kubernetes/pki"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
存储证书的目录路径。如果已指定，则需要清空此目录。
</td>
</tr>
<tr>
<td colspan=2>--cri-socket string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 CRI 套接字的路径。如果为空，则 kubeadm 将尝试自动检测此值；仅当安装了多个CRI 或具有非标准 CRI 插槽时，才使用此选项。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
cleanup-node 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=接下来>接下来</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a>
引导 Kubernetes 控制平面节点</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>
将节点添加到集群</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
恢复通过 <code>kubeadm init</code> 或 <code>kubeadm join</code> 操作对主机所做的任何更改</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/>kubeadm alpha</a>
尝试实验性功能</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-dfd085b5ab706bd84dda15847dd27f1b>7.1.14 - kubeadm upgrade phase</h1>
<p>在 Kubernetes v1.15.0 版本中，kubeadm 引入了对 <code>kubeadm upgrade node</code> 阶段的初步支持。其他 <code>kubeadm upgrade</code> 子命令如 <code>apply</code> 等阶段将在未来发行版中添加。</p>
<h2 id=cmd-node-phase>kubeadm upgrade node phase</h2>
<p>使用此阶段，可以选择执行辅助控制平面或工作节点升级的单独步骤。请注意，<code>kubeadm upgrade apply</code> 命令仍然必须在主控制平面节点上调用。</p>
<ul class="nav nav-tabs" id=tab-phase role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-phase-0 role=tab aria-controls=tab-phase-0 aria-selected=true>phase</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-phase-1 role=tab aria-controls=tab-phase-1>preflight</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-phase-2 role=tab aria-controls=tab-phase-2>control-plane</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-phase-3 role=tab aria-controls=tab-phase-3>kubelet-config</a></li></ul>
<div class=tab-content id=tab-phase><div id=tab-phase-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-phase-0>
<p><h3 id=概要>概要</h3>
<p>使用此命令调用 node 工作流的某个阶段</p>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
phase 操作的帮助命令
</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验] 指向 '真实' 宿主机根文件系统的路径。
</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-phase-1 class=tab-pane role=tabpanel aria-labelledby=tab-phase-1>
<p><p>执行 kubeadm 升级节点的预检。</p>
<pre><code>kubeadm upgrade node phase preflight [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>preflight 操作的帮助命令</td>
</tr>
<tr>
<td colspan=2>--ignore-preflight-errors stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>错误将显示为警告的检查清单。示例：'IsPrivilegedUser,Swap'。值为'all'表示忽略所有检查的错误。</td>
</tr>
</tbody>
</table>
<h3 id=继承于父命令的选项>继承于父命令的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-phase-2 class=tab-pane role=tabpanel aria-labelledby=tab-phase-2>
<p><h3 id=概要>概要</h3>
<p>升级部署在此节点上的控制平面实例，如果有的话</p>
<pre><code>kubeadm upgrade node phase control-plane [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--certificate-renewal</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>更新在升级期间变更的组件使用的证书。</td>
</tr>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>不改变任何状态，只输出将要执行的动作。</td>
</tr>
<tr>
<td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>执行 etcd 的升级。</td>
</tr>
<tr>
<td colspan=2>--experimental-patches string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含名为 "target[suffix][+patchtype].extension" 的文件的目录的路径。
例如，"kube-apiserver0+merge.yaml" 或仅仅是 "etcd.json"。
"patchtype" 可以是 "strategic"、"merge" 或 "json" 之一，并且它们与 kubectl 支持的补丁格式匹配。
默认的 "patchtype" 为 "strategic"。 "extension" 必须为 "json" 或 "yaml"。
"suffix" 是一个可选字符串，可用于确定首先按字母顺序应用哪些补丁。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>control-plane 的帮助信息</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "/etc/kubernetes/admin.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div>
<div id=tab-phase-3 class=tab-pane role=tabpanel aria-labelledby=tab-phase-3>
<p><p>从群集中 "kubelet-config-1.X" 的 ConfigMap 下载 kubelet 配置，其中 X 是kubelet 的次要版本。
kubeadm 使用 --kubelet-version 参数来确定所需的 kubelet 版本。</p>
<pre><code>kubeadm upgrade node phase kubelet-config [flags]
</code></pre>
<h3 id=选项>选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--dry-run</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>不改变任何状态，只输出将要执行的操作</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>配置操作的帮助信息</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： "/etc/kubernetes/kubelet.conf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>用于和集群通信的 KubeConfig 文件。如果它没有被设置，那么 kubeadm 将会搜索一个已经存在于标准路径的 KubeConfig 文件。</td>
</tr>
<tr>
<td colspan=2>--kubelet-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>升级后的 kubelet 的*期望*版本。</td>
</tr>
</tbody>
</table>
<h3 id=从父命令继承的选项>从父命令继承的选项</h3>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--rootfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>[实验] 到'真实'主机根文件系统的路径。</td>
</tr>
</tbody>
</table>
</div></div>
<h2 id=接下来>接下来</h2>
<ul>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/>kubeadm init</a> 引导一个 Kubernetes 控制平面节点</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> 将节点加入到集群</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a> 还原 <code>kubeadm init</code> 或 <code>kubeadm join</code> 命令对主机所做的任何更改</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/>kubeadm upgrade</a> 升级 kubeadm 节点</li>
<li><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-alpha/>kubeadm alpha</a> 尝试实验性功能</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-455b6412a275b743ee8ad90f35808393>7.1.15 - 实现细节</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.10 [stable]</code>
</div>
<p><code>kubeadm init</code> 和 <code>kubeadm join</code> 结合在一起提供了良好的用户体验，因为从头开始创建实践最佳而配置最基本的 Kubernetes 集群。
但是，kubeadm <em>如何</em> 做到这一点可能并不明显。</p>
<p>本文档提供了更多幕后的详细信息，旨在分享有关 Kubernetes 集群最佳实践的知识。</p>
<h2 id=core-design-principles>核心设计原则 </h2>
<p><code>kubeadm init</code> 和 <code>kubeadm join</code> 设置的集群该是：</p>
<ul>
<li><strong>安全的</strong>：它应采用最新的最佳实践，例如：
<ul>
<li>实施 RBAC 访问控制</li>
<li>使用节点鉴权机制（Node Authorizer）</li>
<li>在控制平面组件之间使用安全通信</li>
<li>在 API 服务器和 kubelet 之间使用安全通信</li>
<li>锁定 kubelet API</li>
<li>锁定对系统组件（例如 kube-proxy 和 CoreDNS）的 API 的访问</li>
<li>锁定启动引导令牌（Bootstrap Token）可以访问的内容</li>
</ul>
</li>
<li><strong>用户友好</strong>：用户只需要运行几个命令即可：
<ul>
<li><code>kubeadm init</code></li>
<li><code>export KUBECONFIG=/etc/kubernetes/admin.conf</code></li>
<li><code>kubectl apply -f &lt;所选网络.yaml></code></li>
<li><code>kubeadm join --token &lt;令牌> &lt;端点>:&lt;端口></code></li>
</ul>
</li>
<li><strong>可扩展的</strong>：
<ul>
<li><em>不</em> 应偏向任何特定的网络提供商。不涉及配置集群网络</li>
<li>应该可以使用配置文件来自定义各种参数</li>
</ul>
</li>
</ul>
<h2 id=constants-and-well-known-values-and-paths>常量以及众所周知的值和路径 </h2>
<p>为了降低复杂性并简化基于 kubeadm 的高级工具的开发，对于众所周知的路径和文件名，
kubeadm 使用了一组有限的常量值。</p>
<p>Kubernetes 目录 <code>/etc/kubernetes</code> 在应用程序中是一个常量，因为在大多数情况下
它显然是给定的路径，并且是最直观的位置；其他路径常量和文件名有：</p>
<ul>
<li><code>/etc/kubernetes/manifests</code> 作为 kubelet 查找静态 Pod 清单的路径。静态 Pod 清单的名称为：
<ul>
<li><code>etcd.yaml</code></li>
<li><code>kube-apiserver.yaml</code></li>
<li><code>kube-controller-manager.yaml</code></li>
<li><code>kube-scheduler.yaml</code></li>
</ul>
</li>
<li><code>/etc/kubernetes/</code> 作为带有控制平面组件身份标识的 kubeconfig 文件的路径。kubeconfig 文件的名称为：
<ul>
<li><code>kubelet.conf</code> (在 TLS 引导时名称为 <code>bootstrap-kubelet.conf</code> )</li>
<li><code>controller-manager.conf</code></li>
<li><code>scheduler.conf</code></li>
<li><code>admin.conf</code> 用于集群管理员和 kubeadm 本身</li>
</ul>
</li>
<li>证书和密钥文件的名称：
<ul>
<li><code>ca.crt</code>, <code>ca.key</code> 用于 Kubernetes 证书颁发机构</li>
<li><code>apiserver.crt</code>, <code>apiserver.key</code> 用于 API 服务器证书</li>
<li><code>apiserver-kubelet-client.crt</code>, <code>apiserver-kubelet-client.key</code>
用于 API 服务器安全地连接到 kubelet 的客户端证书</li>
<li><code>sa.pub</code>, <code>sa.key</code> 用于控制器管理器签署 ServiceAccount 时使用的密钥</li>
<li><code>front-proxy-ca.crt</code>, <code>front-proxy-ca.key</code> 用于前端代理证书颁发机构</li>
<li><code>front-proxy-client.crt</code>, <code>front-proxy-client.key</code> 用于前端代理客户端</li>
</ul>
</li>
</ul>
<h2 id=kubeadm-init-workflow-internal-design>kubeadm init 工作流程内部设计 </h2>
<p><code>kubeadm init</code> <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#init-workflow>内部工作流程</a>
包含一系列要执行的原子性工作任务，如 <code>kubeadm init</code> 中所述。</p>
<p><a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/><code>kubeadm init phase</code></a>
命令允许用户分别调用每个任务，并最终提供可重用且可组合的 API 或工具箱，
其他 Kubernetes 引导工具、任何 IT 自动化工具和高级用户都可以使用它来
创建自定义集群。</p>
<h3 id=preflight-checks>预检 </h3>
<p>Kubeadm 在启动 init 之前执行一组预检，目的是验证先决条件并避免常见的集群启动问题。
用户可以使用 <code>--ignore-preflight-errors</code> 选项跳过特定的预检查或全部检查。</p>
<ul>
<li>[警告] 如果要使用的 Kubernetes 版本（由 <code>--kubernetes-version</code> 标志指定）比 kubeadm CLI
版本至少高一个小版本。</li>
<li>Kubernetes 系统要求：
<ul>
<li>如果在 linux上运行：
<ul>
<li>[错误] 如果内核早于最低要求的版本</li>
<li>[错误] 如果未设置所需的 cgroups 子系统</li>
</ul>
</li>
<li>如果使用 docker：
<ul>
<li>[警告/错误] 如果 Docker 服务不存在、被禁用或未激活。</li>
<li>[错误] 如果 Docker 端点不存在或不起作用</li>
<li>[警告] 如果 docker 版本不在经过验证的 docker 版本列表中</li>
</ul>
</li>
<li>如果使用其他 cri 引擎：
<ul>
<li>[错误] 如果 crictl 套接字未应答</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>[错误] 如果用户不是 root 用户</li>
<li>[错误] 如果机器主机名不是有效的 DNS 子域</li>
<li>[警告] 如果通过网络查找无法访问主机名</li>
<li>[错误] 如果 kubelet 版本低于 kubeadm 支持的最低 kubelet 版本（当前小版本 -1）</li>
<li>[错误] 如果 kubelet 版本比所需的控制平面板版本至少高一个小（不支持的版本偏斜）</li>
<li>[警告] 如果 kubelet 服务不存在或已被禁用</li>
<li>[警告] 如果 firewalld 处于活动状态</li>
<li>[错误] 如果 API ​​服务器绑定的端口或 10250/10251/10252 端口已被占用</li>
<li>[错误] 如果 <code>/etc/kubernetes/manifest</code> 文件夹已经存在并且不为空</li>
<li>[错误] 如果 <code>/proc/sys/net/bridge/bridge-nf-call-iptables</code> 文件不存在或不包含 1</li>
<li>[错误] 如果建议地址是 ipv6，并且 <code>/proc/sys/net/bridge/bridge-nf-call-ip6tables</code> 不存在或不包含 1</li>
<li>[错误] 如果启用了交换分区</li>
<li>[错误] 如果命令路径中没有 <code>conntrack</code>、<code>ip</code>、<code>iptables</code>、<code>mount</code>、<code>nsenter</code> 命令</li>
<li>[警告] 如果命令路径中没有 <code>ebtables</code>、<code>ethtool</code>、<code>socat</code>、<code>tc</code>、<code>touch</code>、<code>crictl</code> 命令</li>
<li>[警告] 如果 API 服务器、控制器管理器、调度程序的其他参数标志包含一些无效选项</li>
<li>[警告] 如果与 https://API.AdvertiseAddress:API.BindPort 的连接通过代理</li>
<li>[警告] 如果服务子网的连接通过代理（仅检查第一个地址）</li>
<li>[警告] 如果 Pod 子网的连接通过代理（仅检查第一个地址）</li>
</ul>
<ul>
<li>如果提供了外部 etcd：
<ul>
<li>[错误] 如果 etcd 版本低于最低要求版本</li>
<li>[错误] 如果指定了 etcd 证书或密钥，但无法找到</li>
</ul>
</li>
<li>如果未提供外部 etcd（因此将安装本地 etcd）：
<ul>
<li>[错误] 如果端口 2379 已被占用</li>
<li>[错误] 如果 Etcd.DataDir 文件夹已经存在并且不为空</li>
</ul>
</li>
<li>如果授权模式为 ABAC：
<ul>
<li>[错误] 如果 abac_policy.json 不存在</li>
</ul>
</li>
<li>如果授权方式为 Webhook
<ul>
<li>[错误] 如果 webhook_authz.conf 不存在</li>
</ul>
</li>
</ul>
<p>请注意：</p>
<ol>
<li>可以使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-preflight><code>kubeadm init phase preflight</code></a>
命令单独触发预检。</li>
</ol>
<h3 id=generate-the-necessary-certificate>生成必要的证书 </h3>
<p>Kubeadm 生成用于不同目的的证书和私钥对：</p>
<ul>
<li>
<p>Kubernetes 集群的自签名证书颁发机构会保存到 <code>ca.crt</code> 文件和 <code>ca.key</code> 私钥文件中</p>
</li>
<li>
<p>用于 API 服务器的服务证书，使用 <code>ca.crt</code> 作为 CA 生成，并将证书保存到 <code>apiserver.crt</code>
文件中，私钥保存到 <code>apiserver.key</code> 文件中
该证书应包含以下备用名称：</p>
<ul>
<li>Kubernetes 服务的内部 clusterIP（服务 CIDR 的第一个地址。
例如：如果服务的子网是 <code>10.96.0.0/12</code>，则为 <code>10.96.0.1</code>）</li>
<li>Kubernetes DNS 名称，例如：如果 <code>--service-dns-domain</code> 标志值是 <code>cluster.local</code>，
则为 <code>kubernetes.default.svc.cluster.local</code>；
加上默认的 DNS 名称 <code>kubernetes.default.svc</code>、<code>kubernetes.default</code> 和 <code>kubernetes</code>，</li>
<li>节点名称</li>
<li><code>--apiserver-advertise-address</code></li>
<li>用户指定的其他备用名称</li>
</ul>
</li>
<li>
<p>用于 API 服务器安全连接到 kubelet 的客户端证书，使用 <code>ca.crt</code> 作为 CA 生成，
并保存到 <code>apiserver-kubelet-client.crt</code>，私钥保存到 <code>apiserver-kubelet-client.key</code>
文件中。该证书应该在 <code>system:masters</code> 组织中。</p>
</li>
<li>
<p>用于签名 ServiceAccount 令牌的私钥保存到 <code>sa.key</code> 文件中，公钥保存到 <code>sa.pub</code> 文件中</p>
</li>
<li>
<p>用于前端代理的证书颁发机构保存到 <code>front-proxy-ca.crt</code> 文件中，私钥保存到
<code>front-proxy-ca.key</code> 文件中</p>
</li>
<li>
<p>前端代理客户端的客户端证书，使用 <code>front-proxy-ca.crt</code> 作为 CA 生成，并保存到
<code>front-proxy-client.crt</code> 文件中，私钥保存到 <code>front-proxy-client.key</code> 文件中</p>
</li>
</ul>
<p>证书默认情况下存储在 <code>/etc/kubernetes/pki</code> 中，但是该目录可以使用 <code>--cert-dir</code> 标志进行配置。</p>
<p>请注意：</p>
<ol>
<li>如果证书和私钥对都存在，并且其内容经过评估符合上述规范，将使用现有文件，
并且跳过给定证书的生成阶段。
这意味着用户可以将现有的 CA 复制到 <code>/etc/kubernetes/pki/ca.{crt,key}</code>，
kubeadm 将使用这些文件对其余证书进行签名。
请参阅<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#custom-certificates>使用自定义证书</a>。</li>
<li>仅对 CA 来说，如果所有其他证书和 kubeconfig 文件都已就位，则可以只提供 <code>ca.crt</code> 文件，
而不提供 <code>ca.key</code> 文件。
kubeadm 能够识别出这种情况并启用 ExternalCA，这也意味着了控制器管理器中的
<code>csrsigner</code> 控制器将不会启动</li>
<li>如果 kubeadm 在
<a href=/zh/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#external-ca-mode>外部 CA 模式</a>
下运行，所有证书必须由用户提供，因为 kubeadm 无法自行生成它们。</li>
<li>如果在 <code>--dry-run</code> 模式下执行 kubeadm，证书文件将写入一个临时文件夹中</li>
<li>可以使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-certs><code>kubeadm init phase certs all</code></a>
命令单独生成证书。</li>
</ol>
<h3 id=generate-kubeconfig-files-for-control-plane-components>为控制平面组件生成 kubeconfig 文件 </h3>
<p>Kubeadm 生成具有用于控制平面组件身份标识的 kubeconfig 文件：</p>
<ul>
<li>
<p>供 kubelet 在 TLS 引导期间使用的 kubeconfig 文件 —— <code>/etc/kubernetes/bootstrap-kubelet.conf</code>。
在此文件中，有一个引导令牌或内嵌的客户端证书，向集群表明此节点身份。
此客户端证书应：</p>
<ul>
<li>根据<a href=/zh/docs/reference/access-authn-authz/node/>节点鉴权</a>模块的要求，属于 <code>system:nodes</code> 组织</li>
<li>具有通用名称（CN）：<code>system:node:&lt;小写主机名></code></li>
</ul>
</li>
<li>
<p>控制器管理器的 kubeconfig 文件 —— <code>/etc/kubernetes/controller-manager.conf</code>；
在此文件中嵌入了一个具有控制器管理器身份标识的客户端证书。
此客户端证书应具有 CN：<code>system:kube-controller-manager</code>，
该 CN 由 <a href=/zh/docs/reference/access-authn-authz/rbac/#core-component-roles>RBAC 核心组件角色</a>
默认定义的。</p>
</li>
<li>
<p>调度器的 kubeconfig 文件 —— <code>/etc/kubernetes/scheduler.conf</code>；
此文件中嵌入了具有调度器身份标识的客户端证书。此客户端证书应具有 CN：<code>system:kube-scheduler</code>，
该 CN 由 <a href=/zh/docs/reference/access-authn-authz/rbac/#core-component-roles>RBAC 核心组件角色</a>
默认定义的。</p>
</li>
</ul>
<p>另外，用于 kubeadm 本身和 admin 的 kubeconfig 文件也被生成并保存到
<code>/etc/kubernetes/admin.conf</code> 文件中。
此处的 admin 定义为正在管理集群并希望完全控制集群（<strong>root</strong>）的实际人员。
内嵌的 admin 客户端证书应是 <code>system:masters</code> 组织的成员，
这一组织名由默认的 <a href=/zh/docs/reference/access-authn-authz/rbac/#user-facing-roles>RBAC 面向用户的角色绑定</a>
定义。它还应包括一个 CN。kubeadm 使用 <code>kubernetes-admin</code> CN。</p>
<p>请注意：</p>
<ol>
<li><code>ca.crt</code> 证书内嵌在所有 kubeconfig 文件中。</li>
<li>如果给定的 kubeconfig 文件存在且其内容经过评估符合上述规范，则 kubeadm 将使用现有文件，
并跳过给定 kubeconfig 的生成阶段</li>
<li>如果 kubeadm 以 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#external-ca-mode>ExternalCA 模式</a>
运行，则所有必需的 kubeconfig 也必须由用户提供，因为 kubeadm 不能自己生成</li>
<li>如果在 <code>--dry-run</code> 模式下执行 kubeadm，则 kubeconfig 文件将写入一个临时文件夹中</li>
<li>可以使用
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-kubeconfig><code>kubeadm init phase kubeconfig all</code></a>
命令分别生成 kubeconfig 文件。</li>
</ol>
<h3 id=generate-static-pod-manifests-for-control-plane-components>为控制平面组件生成静态 Pod 清单 </h3>
<p>Kubeadm 将用于控制平面组件的静态 Pod 清单文件写入 <code>/etc/kubernetes/manifests</code> 目录。
Kubelet 启动后会监视这个目录以便创建 Pod。</p>
<p>静态 Pod 清单有一些共同的属性：</p>
<ul>
<li>
<p>所有静态 Pod 都部署在 <code>kube-system</code> 名字空间</p>
</li>
<li>
<p>所有静态 Pod 都打上 <code>tier:ontrol-plane</code> 和 <code>component:{组件名称}</code> 标签</p>
</li>
<li>
<p>所有静态 Pod 均使用 <code>system-node-critical</code> 优先级</p>
</li>
<li>
<p>所有静态 Pod 都设置了 <code>hostNetwork:true</code>，使得控制平面在配置网络之前启动；结果导致：</p>
<ul>
<li>控制器管理器和调度器用来调用 API 服务器的地址为 127.0.0.1。</li>
<li>如果使用本地 etcd 服务器，则 <code>etcd-servers</code> 地址将设置为 <code>127.0.0.1:2379</code></li>
</ul>
</li>
<li>
<p>同时为控制器管理器和调度器启用了领导者选举</p>
</li>
<li>
<p>控制器管理器和调度器将引用 kubeconfig 文件及其各自的唯一标识</p>
</li>
<li>
<p>如<a href=/zh/docs/setup/production-environment/tools/kubeadm/control-plane-flags/>将自定义参数传递给控制平面组件</a>
中所述，所有静态 Pod 都会获得用户指定的额外标志</p>
</li>
<li>
<p>所有静态 Pod 都会获得用户指定的额外卷（主机路径）</p>
</li>
</ul>
<p>请注意：</p>
<ol>
<li>所有镜像默认从 k8s.gcr.io 拉取。
关于自定义镜像仓库，请参阅
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images>使用自定义镜像</a>。</li>
<li>如果在 <code>--dry-run</code> 模式下执行 kubeadm，则静态 Pod 文件写入一个临时文件夹中。</li>
<li>可以使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-control-plane><code>kubeadm init phase control-plane all</code></a>
命令分别生成主控组件的静态 Pod 清单。</li>
</ol>
<h4 id=api-server>API 服务器 </h4>
<p>API 服务器的静态 Pod 清单会受到用户提供的以下参数的影响:</p>
<ul>
<li>要绑定的 <code>apiserver-advertise-address</code> 和 <code>apiserver-bind-port</code>；
如果未提供，则这些值默认为机器上默认网络接口的 IP 地址和 6443 端口。</li>
<li><code>service-cluster-ip-range</code> 给 service 使用</li>
<li>如果指定了外部 etcd 服务器，则应指定 <code>etcd-servers</code> 地址和相关的 TLS 设置
（<code>etcd-cafile</code>，<code>etcd-certfile</code>，<code>etcd-keyfile</code>）；
如果未提供外部 etcd 服务器，则将使用本地 etcd（通过主机网络）</li>
<li>如果指定了云提供商，则配置相应的 <code>--cloud-provider</code>，如果该路径存在，则配置 <code>--cloud-config</code>
（这是实验性的，是 Alpha 版本，将在以后的版本中删除）</li>
</ul>
<p>无条件设置的其他 API 服务器标志有：</p>
<ul>
<li><code>--insecure-port=0</code> 禁止到 API 服务器不安全的连接</li>
<li><code>--enable-bootstrap-token-auth=true</code> 启用 <code>BootstrapTokenAuthenticator</code> 身份验证模块。
更多细节请参见 <a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLS 引导</a>。</li>
<li><code>--allow-privileged</code> 设为 <code>true</code>（诸如 kube-proxy 这些组件有此要求）</li>
<li><code>--requestheader-client-ca-file</code> 设为 <code>front-proxy-ca.crt</code></li>
</ul>
<ul>
<li><code>--enable-admission-plugins</code> 设为：
<ul>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#namespacelifecycle><code>NamespaceLifecycle</code></a>
例如，避免删除系统保留的名字空间</li>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#limitranger><code>LimitRanger</code></a> 和
<a href=/zh/docs/reference/access-authn-authz/admission-controllers/#resourcequota><code>ResourceQuota</code></a>
对名字空间实施限制</li>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#serviceaccount><code>ServiceAccount</code></a>
实施服务账户自动化</li>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#persistentvolumelabel><code>PersistentVolumeLabel</code></a>
将区域（Region）或区（Zone）标签附加到由云提供商定义的 PersistentVolumes
（此准入控制器已被弃用并将在以后的版本中删除）。
如果未明确选择使用 <code>gce</code> 或 <code>aws</code> 作为云提供商，则默认情况下，v1.9 以后的版本 kubeadm 都不会部署。</li>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code></a>
在 <code>PersistentVolumeClaim</code> 对象上强制使用默认存储类型</li>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#defaulttolerationseconds><code>DefaultTolerationSeconds</code></a></li>
<li><a href=/zh/docs/reference/access-authn-authz/admission-controllers/#noderestriction><code>NodeRestriction</code></a>
限制 kubelet 可以修改的内容（例如，仅此节点上的 pod）</li>
</ul>
</li>
</ul>
<ul>
<li>
<p><code>--kubelet-preferred-address-types</code> 设为 <code>InternalIP,ExternalIP,Hostname;</code>
这使得在节点的主机名无法解析的环境中，<code>kubectl log</code> 和 API 服务器与 kubelet
的其他通信可以工作</p>
</li>
<li>
<p>使用在前面步骤中生成的证书的标志：</p>
<ul>
<li><code>--client-ca-file</code> 设为 <code>ca.crt</code></li>
<li><code>--tls-cert-file</code> 设为 <code>apiserver.crt</code></li>
<li><code>--tls-private-key-file</code> 设为 <code>apiserver.key</code></li>
<li><code>--kubelet-client-certificate</code> 设为 <code>apiserver-kubelet-client.crt</code></li>
<li><code>--kubelet-client-key</code> 设为 <code>apiserver-kubelet-client.key</code></li>
<li><code>--service-account-key-file</code> 设为 <code>sa.pub</code></li>
<li><code>--requestheader-client-ca-file</code> 设为 <code>front-proxy-ca.crt</code></li>
<li><code>--proxy-client-cert-file</code> 设为 <code>front-proxy-client.crt</code></li>
<li><code>--proxy-client-key-file</code> 设为 <code>front-proxy-client.key</code></li>
</ul>
</li>
<li>
<p>其他用于保护前端代理（
<a href=/zh/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API 聚合层</a>）
通信的标志:</p>
<ul>
<li><code>--requestheader-username-headers=X-Remote-User</code></li>
<li><code>--requestheader-group-headers=X-Remote-Group</code></li>
<li><code>--requestheader-extra-headers-prefix=X-Remote-Extra-</code></li>
<li><code>--requestheader-allowed-names=front-proxy-client</code></li>
</ul>
</li>
</ul>
<h4 id=controller-manager>控制器管理器 </h4>
<p>控制器管理器的静态 Pod 清单受用户提供的以下参数的影响:</p>
<ul>
<li>如果调用 kubeadm 时指定了 <code>--pod-network-cidr</code> 参数，则可以通过以下方式启用
某些 CNI 网络插件所需的子网管理器功能：
<ul>
<li>设置 <code>--allocate-node-cidrs=true</code></li>
<li>根据给定 CIDR 设置 <code>--cluster-cidr</code> 和 <code>--node-cidr-mask-size</code> 标志</li>
</ul>
</li>
<li>如果指定了云提供商，则指定相应的 <code>--cloud-provider</code>，如果存在这样的配置文件，
则指定 <code>--cloud-config</code> 路径（此为试验性功能，是 Alpha 版本，将在以后的版本中删除）。</li>
</ul>
<p>其他无条件设置的标志包括：</p>
<ul>
<li>
<p><code>--controllers</code> 为 TLS 引导程序启用所有默认控制器以及 <code>BootstrapSigner</code> 和
<code>TokenCleaner</code> 控制器。详细信息请参阅
<a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLS 引导</a></p>
</li>
<li>
<p><code>--use-service-account-credentials</code> 设为 <code>true</code></p>
</li>
<li>
<p>使用先前步骤中生成的证书的标志：</p>
<p>-<code>--root-ca-file</code> 设为 <code>ca.crt</code></p>
<ul>
<li>如果禁用了 External CA 模式，则 <code>--cluster-signing-cert-file</code> 设为 <code>ca.crt</code>，否则设为 <code>""</code></li>
<li>如果禁用了 External CA 模式，则 <code>--cluster-signing-key-file</code> 设为 <code>ca.key</code>，否则设为 <code>""</code></li>
<li><code>--service-account-private-key-file</code> 设为 <code>sa.key</code></li>
</ul>
</li>
</ul>
<h4 id=scheduler>调度器 </h4>
<p>调度器的静态 Pod 清单不受用户提供的参数的影响。</p>
<h3 id=generate-static-pod-manifest-for-local-etcd>为本地 etcd 生成静态 Pod 清单 </h3>
<p>如果用户指定了外部 etcd，则将跳过此步骤，否则 kubeadm 会生成静态 Pod 清单文件，
以创建在 Pod 中运行的具有以下属性的本地 etcd 实例：</p>
<ul>
<li>在 <code>localhost:2379</code> 上监听并使用 <code>HostNetwork=true</code></li>
<li>将 <code>hostPath</code> 从 <code>dataDir</code> 挂载到主机的文件系统</li>
<li>用户指定的任何其他标志</li>
</ul>
<p>请注意：</p>
<ol>
<li>etcd 镜像默认从 <code>k8s.gcr.io</code> 拉取。有关自定义镜像仓库，请参阅
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init/#custom-images>使用自定义镜像</a>。</li>
<li>如果 kubeadm 以 <code>--dry-run</code> 模式执行，etcd 静态 Pod 清单将写入一个临时文件夹。</li>
<li>可以使用
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-etcd>'kubeadm init phase etcd local'</a>
命令单独为本地 etcd 生成静态 Pod 清单</li>
</ol>
<h3 id=wait-for-the-control-plane-to-come-up>等待控制平面启动 </h3>
<p>kubeadm 等待（最多 4m0s），直到 <code>localhost:6443/healthz</code>（kube-apiserver 存活）返回 <code>ok</code>。
但是为了检测死锁条件，如果 <code>localhost:10255/healthz</code>（kubelet 存活）或
<code>localhost:10255/healthz/syncloop</code>（kubelet 就绪）未能在 40s 和 60s 内未返回 <code>ok</code>，
则 kubeadm 会快速失败。</p>
<p>kubeadm 依靠 kubelet 拉取控制平面镜像并将其作为静态 Pod 正确运行。
控制平面启动后，kubeadm 将完成以下段落中描述的任务。</p>
<h3 id=save-the-kubeadm-clusterConfiguration-in-a-configMap-for-later-reference>将 kubeadm ClusterConfiguration 保存在 ConfigMap 中以供以后参考 </h3>
<p>kubeadm 将传递给 <code>kubeadm init</code> 的配置保存在 <code>kube-system</code> 名字空间下名为
<code>kubeadm-config</code> 的 ConfigMap 中。</p>
<p>这将确保将来执行的 kubeadm 操作（例如 <code>kubeadm upgrade</code>）将能够确定实际/当前集群状态，
并根据该数据做出新的决策。</p>
<p>请注意：</p>
<ol>
<li>在保存 ClusterConfiguration 之前，从配置中删除令牌等敏感信息。</li>
<li>可以使用
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-upload-config><code>kubeadm init phase upload-config</code></a>
命令单独上传主控节点配置。</li>
</ol>
<h3 id=mark-the-node-as-control-plane>将节点标记为控制平面 </h3>
<p>一旦控制平面可用，kubeadm 将执行以下操作：</p>
<ul>
<li>给节点打上 <code>node-role.kubernetes.io/master=""</code> 标签，标记其为控制平面</li>
<li>给节点打上 <code>node-role.kubernetes.io/master:NoSchedule</code> 污点</li>
</ul>
<p>请注意：</p>
<ol>
<li>可以使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-mark-control-plane><code>kubeadm init phase mark-control-plane</code></a>
命令单独触发控制平面标记</li>
</ol>
<h3 id=configure-tls-bootstrapping-for-node-joining>为即将加入的节点加入 TLS 启动引导 </h3>
<p>Kubeadm 使用<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>引导令牌认证</a>
将新节点连接到现有集群；
更多的详细信息，请参见
<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md>设计提案</a>。</p>
<p><code>kubeadm init</code> 确保为该过程正确配置了所有内容，这包括以下步骤以及设置 API 服务器
和控制器标志，如前几段所述。</p>
<p>请注意：</p>
<ol>
<li>可以使用
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-bootstrap-token><code>kubeadm init phase bootstrap-token</code></a>
命令配置节点的 TLS 引导，执行以下段落中描述的所有配置步骤；
或者每个步骤都单独触发。</li>
</ol>
<h4 id=create-a-bootstrap-token>创建引导令牌 </h4>
<p><code>kubeadm init</code> 创建第一个引导令牌，该令牌是自动生成的或由用户提供的 <code>--token</code>
标志的值；如引导令牌规范中记录的那样，
令牌应保存在 <code>kube-system</code> 名字空间下名为 <code>bootstrap-token-&lt;令牌-id></code>
的 Secret 中。</p>
<p>请注意：</p>
<ol>
<li>由 <code>kubeadm init</code> 创建的默认令牌将用于在 TLS 引导过程中验证临时用户；
这些用户会成为 <code>system:bootstrappers:kubeadm:default-node-token</code> 组的成员。</li>
<li>令牌的有效期有限，默认为 24 小时（间隔可以通过 <code>-token-ttl</code> 标志进行更改）</li>
<li>可以使用 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-token/><code>kubeadm token</code></a>
命令创建其他令牌，这些令牌还提供其他有用的令牌管理功能</li>
</ol>
<h4 id=allow-joining-nodes-to-call-csr-api>允许加入的节点调用 CSR API </h4>
<p>Kubeadm 确保 <code>system:bootstrappers:kubeadm:default-node-token</code> 组中的用户
能够访问证书签名 API。</p>
<p>这是通过在上述组与默认 RBAC 角色 <code>system:node-bootstrapper</code> 之间创建名为
<code>kubeadm:kubelet-bootstrap</code> 的 ClusterRoleBinding 来实现的。</p>
<h4 id=setup-auto-approval-for-new-bootstrap-tokens>为新的引导令牌设置自动批准 </h4>
<p>Kubeadm 确保 csrapprover 控制器自动批准引导令牌的 CSR 请求。</p>
<p>这是通过在 <code>system:bootstrappers:kubeadm:default-node-token</code> 用户组和
<code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code> 默认角色之间
创建名为 <code>kubeadm:node-autoapprove-bootstrap</code> 的 ClusterRoleBinding 来实现的。</p>
<p>还应创建 <code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code> 角色，
授予对 <code>/apis/certificates.k8s.io/certificatesigningrequests/nodeclient</code>
执行 POST 的权限。</p>
<h4 id=setup-nodes-certificate-rotation-with-auto-approval>通过自动批准设置节点证书轮换</h4>
<p>Kubeadm 确保节点启用了证书轮换，csrapprover 控制器将自动批准节点的
新证书的 CSR 请求。</p>
<p>这是通过在 <code>system:nodes</code> 组和
<code>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</code>
默认角色之间创建名为 <code>kubeadm:node-autoapprove-certificate-rotation</code> 的
ClusterRoleBinding 来实现的。</p>
<h4 id=创建公共-cluster-info-configmap>创建公共 cluster-info ConfigMap</h4>
<p>本步骤在 <code>kube-public</code> 名字空间中创建名为 <code>cluster-info</code> 的 ConfigMap。</p>
<p>另外，它创建一个 Role 和一个 RoleBinding，为未经身份验证的用户授予对 ConfigMap
的访问权限（即 RBAC 组 <code>system:unauthenticated</code> 中的用户）。</p>
<p>请注意：</p>
<ol>
<li>对 <code>cluster-info</code> ConfigMap 的访问 <em>不受</em> 速率限制。
如果你把 API 服务器暴露到外网，这可能是一个问题，也可能不是；
这里最坏的情况是 DoS 攻击，攻击者使用 kube-apiserver 能够处理的所有动态请求
来为 <code>cluster-info</code> ConfigMap 提供服务。</li>
</ol>
<h3 id=install-addons>安装插件 </h3>
<p>Kubeadm 通过 API 服务器安装内部 DNS 服务器和 kube-proxy 插件。</p>
<p>请注意：</p>
<ol>
<li>此步骤可以调用
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon>'kubeadm init phase addon all'</a>
命令单独执行。</li>
</ol>
<h4 id=proxy>代理 </h4>
<p>在 <code>kube-system</code> 名字空间中创建一个用于 <code>kube-proxy</code> 的 ServiceAccount；
然后以 DaemonSet 的方式部署 kube-proxy：</p>
<ul>
<li>主控节点凭据（<code>ca.crt</code> 和 <code>token</code>）来自 ServiceAccount</li>
<li>API 服务器节点的位置（URL）来自 ConfigMap</li>
<li><code>kube-proxy</code> 的 ServiceAccount 绑定了 <code>system:node-proxier</code> ClusterRole
中的特权</li>
</ul>
<h4 id=dns>DNS</h4>
<ul>
<li>CoreDNS 服务的名称为 <code>kube-dns</code>。这样做是为了防止当用户将集群 DNS 从 kube-dns
切换到 CoreDNS 时出现服务中断。<code>--config</code> 方法在
<a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/#cmd-phase-addon>这里</a>
有描述。</li>
<li>在 <code>kube-system</code> 名字空间中创建 CoreDNS 的 ServiceAccount</li>
<li><code>coredns</code> 的 ServiceAccount 绑定了 <code>system:coredns</code> ClusterRole 中的特权</li>
</ul>
<p>在 Kubernetes 1.21 版本中，kubeadm 对 <code>kube-dns</code> 的支持被移除。
你可以在 kubeadm 使用 CoreDNS，即使相关的 Service 名字仍然是 <code>kube-dns</code>。</p>
<h2 id=kubeadm-join-phases-internal-design>kubeadm join 步骤内部设计 </h2>
<p>与 <code>kubeadm init</code> 类似，<code>kubeadm join</code> 内部工作流由一系列待执行的原子工作任务组成。</p>
<p>这分为发现（让该节点信任 Kubernetes 的主控节点）和 TLS 引导
（让 Kubernetes 的主控节点信任该节点）。</p>
<p>请参阅<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>使用引导令牌进行身份验证</a>
或相应的<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/cluster-lifecycle/bootstrap-discovery.md>设计提案</a>。</p>
<h3 id=preflight-checks>预检 </h3>
<p><code>kubeadm</code> 在开始执行之前执行一组预检，目的是验证先决条件，避免常见的集群启动问题。</p>
<p>请注意：</p>
<ol>
<li><code>kubeadm join</code> 预检基本上是 <code>kubeadm init</code> 预检的一个子集</li>
<li>从 1.9 开始，kubeadm 为 CRI 通用的功能提供了更好的支持；在这种情况下，
Docker 特定的控制参数将跳过或替换为 crictl 中与之相似的控制参数。</li>
<li>从 1.9 开始，kubeadm 支持加入在 Windows 上运行的节点；在这种情况下，
将跳过 Linux 特定的控制参数。</li>
<li>在任何情况下，用户都可以通过 <code>--ignore-preflight-errors</code> 选项跳过
特定的预检（或者进而跳过所有预检）。</li>
</ol>
<h3 id=discovery-cluster-info>发现 cluster-info </h3>
<p>主要有两种发现方案。第一种是使用一个共享令牌以及 API 服务器的 IP 地址。
第二种是提供一个文件（它是标准 kubeconfig 文件的子集）。</p>
<h4 id=shared-token-discovery>共享令牌发现 </h4>
<p>如果带 <code>--discovery-token</code> 参数调用 <code>kubeadm join</code>，则使用了令牌发现功能；
在这种情况下，节点基本上从 <code>kube-public</code> 名字空间中的 <code>cluster-info</code> ConfigMap
中检索集群 CA 证书。</p>
<p>为了防止“中间人”攻击，采取了以下步骤：</p>
<ul>
<li>首先，通过不安全连接检索 CA 证书（这是可能的，因为 <code>kubeadm init</code> 授予
<code>system:unauthenticated</code> 的用户对 <code>cluster-info</code> 访问权限）</li>
<li>然后 CA 证书通过以下验证步骤：
<ul>
<li>基本验证：使用令牌 ID 而不是 JWT 签名</li>
<li>公钥验证：使用提供的 <code>--discovery-token-ca-cert-hash</code>。这个值来自 <code>kubeadm init</code> 的输出，
或者可以使用标准工具计算（哈希值是按 RFC7469 中主体公钥信息（SPKI）对象的字节计算的）
<code>--discovery-token-ca-cert-hash</code> 标志可以重复多次，以允许多个公钥。</li>
<li>作为附加验证，通过安全连接检索 CA 证书，然后与初始检索的 CA 进行比较</li>
</ul>
</li>
</ul>
<p>请注意：</p>
<ol>
<li>通过 <code>--discovery-token-unsafe-skip-ca-verification</code> 标志可以跳过公钥验证；
这削弱了 kubeadm 安全模型，因为其他人可能冒充 Kubernetes 主控节点。</li>
</ol>
<h4 id=file-or-https-discovery>文件/HTTPS 发现 </h4>
<p>如果带 <code>--discovery-file</code> 参数调用 <code>kubeadm join</code>，则使用文件发现功能；
该文件可以是本地文件或通过 HTTPS URL 下载；对于 HTTPS，主机安装的 CA 包
用于验证连接。</p>
<p>通过文件发现，集群 CA 证书是文件本身提供；事实上，这个发现文件是一个 kubeconfig 文件，
只设置了 <code>server</code> 和 <code>certificate-authority-data</code> 属性，
如 <a href=/zh/docs/reference/setup-tools/kubeadm/kubeadm-join/#file-or-https-based-discovery><code>kubeadm join</code></a>
参考文档中所述，当与集群建立连接时，kubeadm 尝试访问 <code>cluster-info</code> ConfigMap，
如果可用，就使用它。</p>
<h2 id=tls-boostrap>TLS 引导 </h2>
<p>知道集群信息后，kubeadm 将写入文件 <code>bootstrap-kubelet.conf</code>，从而允许 kubelet 执行
TLS 引导。</p>
<p>TLS 引导机制使用共享令牌对 Kubernetes API 服务器进行临时身份验证，以便
为本地创建的密钥对提交证书签名请求（CSR）。</p>
<p>该请求会被自动批准，并且该操作保存 <code>ca.crt</code> 文件和 <code>kubelet.conf</code> 文件，用于
kubelet 加入集群，同时删除 <code>bootstrap-kubelet.conf</code>。</p>
<p>请注意：</p>
<ul>
<li>临时身份验证根据 <code>kubeadm init</code> 过程中保存的令牌进行验证（或者使用 <code>kubeadm token</code>
创建的其他令牌）</li>
<li>临时身份验证解析到 <code>system:bootstrappers:kubeadm:default-node-token</code> 组的一个用户成员，
该成员在 <code>kubeadm init</code> 过程中被授予对 CSR API 的访问权</li>
<li>根据 <code>kubeadm init</code> 过程的配置，自动 CSR 审批由 csrapprover 控制器管理</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-df8ff2190764e70c3de2015e2cb46b14>8 - 端口和协议</h1>
<p>当你在一个有严格网络边界的环境里运行 Kubernetes，例如拥有物理网络防火墙或者拥有公有云中虚拟网络的自有数据中心，了解 Kubernetes 组件使用了哪些端口和协议是非常有用的。</p>
<h2 id=control-plane>控制面 </h2>
<table>
<thead>
<tr>
<th>协议</th>
<th>方向</th>
<th>端口范围</th>
<th>目的</th>
<th>使用者</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>入站</td>
<td>6443</td>
<td>Kubernetes API server</td>
<td>所有</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>2379-2380</td>
<td>etcd server client API</td>
<td>kube-apiserver, etcd</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>10250</td>
<td>Kubelet API</td>
<td>自身, 控制面</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>10259</td>
<td>kube-scheduler</td>
<td>自身</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>10257</td>
<td>kube-controller-manager</td>
<td>自身</td>
</tr>
</tbody>
</table>
<p>尽管 etcd 的端口也列举在控制面的部分，但你也可以在外部自己托管 etcd 集群或者自定义端口。</p>
<h2 id=node>工作节点 </h2>
<table>
<thead>
<tr>
<th>协议</th>
<th>方向</th>
<th>端口范围</th>
<th>目的</th>
<th>使用者</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>入站</td>
<td>10250</td>
<td>Kubelet API</td>
<td>自身, 控制面</td>
</tr>
<tr>
<td>TCP</td>
<td>入站</td>
<td>30000-32767</td>
<td>NodePort Services†</td>
<td>所有</td>
</tr>
</tbody>
</table>
<p>† <a href=/zh/docs/concepts/services-networking/service/>NodePort Services</a>的默认端口范围。</p>
<p>所有默认端口都可以重新配置。当使用自定义的端口时，你需要打开这些端口来代替这里提到的默认端口。</p>
<p>一个常见的例子是 API 服务器的端口有时会配置为443。或者你也可以使用默认端口，把 API 服务器放到一个监听443 端口的负载均衡器后面，并且路由所有请求到 API 服务器的默认端口。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-03460a7254c6c73eb2a1bb3dd7d25910>9 - kubectl</h1>
</div>
<div class=td-content>
<h1 id=pg-f14fe15ecc2d41b5e901ef5e872ca657>9.1 - kubectl 概述</h1>
<p>你可以使用 Kubectl 命令行工具管理 Kubernetes 集群。
<code>kubectl</code> 在 <code>$HOME/.kube</code> 目录中查找一个名为 <code>config</code> 的配置文件。
你可以通过设置 KUBECONFIG 环境变量或设置
<a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/><code>--kubeconfig</code></a>
参数来指定其它 <a href=/zh/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a> 文件。</p>
<p>本文概述了 <code>kubectl</code> 语法和命令操作描述，并提供了常见的示例。
有关每个命令的详细信息，包括所有受支持的参数和子命令，
请参阅 <a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a> 参考文档。
有关安装说明，请参见<a href=/zh/docs/tasks/tools/install-kubectl/>安装 kubectl</a> 。</p>
<h2 id=语法>语法</h2>
<p>使用以下语法 <code>kubectl</code> 从终端窗口运行命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> <span style=color:#666>[</span>flags<span style=color:#666>]</span>
</code></pre></div>
<p>其中 <code>command</code>、<code>TYPE</code>、<code>NAME</code> 和 <code>flags</code> 分别是：</p>
<ul>
<li>
<p><code>command</code>：指定要对一个或多个资源执行的操作，例如 <code>create</code>、<code>get</code>、<code>describe</code>、<code>delete</code>。</p>
</li>
<li>
<p><code>TYPE</code>：指定<a href=#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B>资源类型</a>。资源类型不区分大小写，
可以指定单数、复数或缩写形式。例如，以下命令输出相同的结果:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod pod1
kubectl get pods pod1
kubectl get po pod1
</code></pre></div></li>
</ul>
<ul>
<li>
<p><code>NAME</code>：指定资源的名称。名称区分大小写。
如果省略名称，则显示所有资源的详细信息 <code>kubectl get pods</code>。</p>
<p>在对多个资源执行操作时，你可以按类型和名称指定每个资源，或指定一个或多个文件：</p>
<ul>
<li>
<p>要按类型和名称指定资源：</p>
<ul>
<li>
<p>要对所有类型相同的资源进行分组，请执行以下操作：<code>TYPE1 name1 name2 name&lt;#></code>。</p>
<p>例子：<code>kubectl get pod example-pod1 example-pod2</code></p>
</li>
<li>
<p>分别指定多个资源类型：<code>TYPE1/name1 TYPE1/name2 TYPE2/name3 TYPE&lt;#>/name&lt;#></code>。</p>
<p>例子：<code>kubectl get pod/example-pod1 replicationcontroller/example-rc1</code></p>
</li>
</ul>
</li>
<li>
<p>用一个或多个文件指定资源：<code>-f file1 -f file2 -f file&lt;#></code></p>
<ul>
<li><a href=/zh/docs/concepts/configuration/overview/#general-configuration-tips>使用 YAML 而不是 JSON</a>
因为 YAML 更容易使用，特别是用于配置文件时。
例子：<code>kubectl get -f ./pod.yaml</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>flags</code>: 指定可选的参数。例如，可以使用 <code>-s</code> 或 <code>-server</code> 参数指定
Kubernetes API 服务器的地址和端口。</li>
</ul>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意：</strong>
<p>从命令行指定的参数会覆盖默认值和任何相应的环境变量。
</div>
<p>如果你需要帮助，从终端窗口运行 <code>kubectl help</code> 。</p>
<h2 id=操作>操作</h2>
<p>下表包含所有 kubectl 操作的简短描述和普通语法：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alpha</code></td>
<td><code>kubectl alpha SUBCOMMAND [flags]</code></td>
<td>列出与 alpha 特性对应的可用命令，这些特性在 Kubernetes 集群中默认情况下是不启用的。</td>
</tr>
<tr>
<td><code>annotate</code></td>
<td><code>kubectl annotate (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td>
<td>添加或更新一个或多个资源的注解。</td>
</tr>
<tr>
<td><code>api-resources</code></td>
<td><code>kubectl api-resources [flags]</code></td>
<td>列出可用的 API 资源。</td>
</tr>
<tr>
<td><code>api-versions</code></td>
<td><code>kubectl api-versions [flags]</code></td>
<td>列出可用的 API 版本。</td>
</tr>
<tr>
<td><code>apply</code></td>
<td><code>kubectl apply -f FILENAME [flags]</code></td>
<td>从文件或 stdin 对资源应用配置更改。</td>
</tr>
<tr>
<td><code>attach</code></td>
<td><code>kubectl attach POD -c CONTAINER [-i] [-t] [flags]</code></td>
<td>附加到正在运行的容器，查看输出流或与容器（stdin）交互。</td>
</tr>
<tr>
<td><code>auth</code></td>
<td><code>kubectl auth [flags] [options]</code></td>
<td>检查授权。</td>
</tr>
<tr>
<td><code>autoscale</code></td>
<td><code>kubectl autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]</code></td>
<td>自动伸缩由副本控制器管理的一组 pod。</td>
</tr>
<tr>
<td><code>certificate</code></td>
<td><code>kubectl certificate SUBCOMMAND [options]</code></td>
<td>修改证书资源。</td>
</tr>
<tr>
<td><code>cluster-info</code></td>
<td><code>kubectl cluster-info [flags]</code></td>
<td>显示有关集群中主服务器和服务的端口信息。</td>
</tr>
<tr>
<td><code>completion</code></td>
<td><code>kubectl completion SHELL [options]</code></td>
<td>为指定的 shell （bash 或 zsh）输出 shell 补齐代码。</td>
</tr>
<tr>
<td><code>config</code></td>
<td><code>kubectl config SUBCOMMAND [flags]</code></td>
<td>修改 kubeconfig 文件。有关详细信息，请参阅各个子命令。</td>
</tr>
<tr>
<td><code>convert</code></td>
<td><code>kubectl convert -f FILENAME [options]</code></td>
<td>在不同的 API 版本之间转换配置文件。配置文件可以是 YAML 或 JSON 格式。</td>
</tr>
<tr>
<td><code>cordon</code></td>
<td><code>kubectl cordon NODE [options]</code></td>
<td>将节点标记为不可调度。</td>
</tr>
<tr>
<td><code>cp</code></td>
<td><code>kubectl cp &lt;file-spec-src> &lt;file-spec-dest> [options]</code></td>
<td>在容器之间复制文件和目录。</td>
</tr>
<tr>
<td><code>create</code></td>
<td><code>kubectl create -f FILENAME [flags]</code></td>
<td>从文件或 stdin 创建一个或多个资源。</td>
</tr>
<tr>
<td><code>delete</code></td>
<td><code>kubectl delete (-f FILENAME | TYPE [NAME | /NAME | -l label | --all]) [flags]</code></td>
<td>从文件、标准输入或指定标签选择器、名称、资源选择器或资源中删除资源。</td>
</tr>
<tr>
<td><code>describe</code></td>
<td><code>kubectl describe (-f FILENAME | TYPE [NAME_PREFIX | /NAME | -l label]) [flags]</code></td>
<td>显示一个或多个资源的详细状态。</td>
</tr>
<tr>
<td><code>diff</code></td>
<td><code>kubectl diff -f FILENAME [flags]</code></td>
<td>将 live 配置和文件或标准输入做对比 (<strong>BETA</strong>)</td>
</tr>
<tr>
<td><code>drain</code></td>
<td><code>kubectl drain NODE [options]</code></td>
<td>腾空节点以准备维护。</td>
</tr>
<tr>
<td><code>edit</code></td>
<td><code>kubectl edit (-f FILENAME | TYPE NAME | TYPE/NAME) [flags]</code></td>
<td>使用默认编辑器编辑和更新服务器上一个或多个资源的定义。</td>
</tr>
<tr>
<td><code>exec</code></td>
<td><code>kubectl exec POD [-c CONTAINER] [-i] [-t] [flags] [-- COMMAND [args...]]</code></td>
<td>对 pod 中的容器执行命令。</td>
</tr>
<tr>
<td><code>explain</code></td>
<td><code>kubectl explain [--recursive=false] [flags]</code></td>
<td>获取多种资源的文档。例如 pod, node, service 等。</td>
</tr>
<tr>
<td><code>expose</code></td>
<td><code>kubectl expose (-f FILENAME | TYPE NAME | TYPE/NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type] [flags]</code></td>
<td>将副本控制器、服务或 pod 作为新的 Kubernetes 服务暴露。</td>
</tr>
<tr>
<td><code>get</code></td>
<td><code>kubectl get (-f FILENAME | TYPE [NAME | /NAME | -l label]) [--watch] [--sort-by=FIELD] [[-o | --output]=OUTPUT_FORMAT] [flags]</code></td>
<td>列出一个或多个资源。</td>
</tr>
<tr>
<td><code>kustomize</code></td>
<td><code>kubectl kustomize &lt;dir> [flags] [options]</code></td>
<td>列出从 kustomization.yaml 文件中的指令生成的一组 API 资源。参数必须是包含文件的目录的路径，或者是 git 存储库 URL，其路径后缀相对于存储库根目录指定了相同的路径。</td>
</tr>
<tr>
<td><code>label</code></td>
<td><code>kubectl label (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td>
<td>添加或更新一个或多个资源的标签。</td>
</tr>
<tr>
<td><code>logs</code></td>
<td><code>kubectl logs POD [-c CONTAINER] [--follow] [flags]</code></td>
<td>在 pod 中打印容器的日志。</td>
</tr>
<tr>
<td><code>options</code></td>
<td><code>kubectl options</code></td>
<td>全局命令行选项列表，适用于所有命令。</td>
</tr>
<tr>
<td><code>patch</code></td>
<td><code>kubectl patch (-f FILENAME | TYPE NAME | TYPE/NAME) --patch PATCH [flags]</code></td>
<td>使用策略合并 patch 程序更新资源的一个或多个字段。</td>
</tr>
<tr>
<td><code>plugin</code></td>
<td><code>kubectl plugin [flags] [options]</code></td>
<td>提供用于与插件交互的实用程序。</td>
</tr>
<tr>
<td><code>port-forward</code></td>
<td><code>kubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N] [flags]</code></td>
<td>将一个或多个本地端口转发到一个 pod。</td>
</tr>
<tr>
<td><code>proxy</code></td>
<td><code>kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]</code></td>
<td>运行 Kubernetes API 服务器的代理。</td>
</tr>
<tr>
<td><code>replace</code></td>
<td><code>kubectl replace -f FILENAME</code></td>
<td>从文件或标准输入中替换资源。</td>
</tr>
<tr>
<td><code>rollout</code></td>
<td><code>kubectl rollout SUBCOMMAND [options]</code></td>
<td>管理资源的部署。有效的资源类型包括：Deployments, DaemonSets 和 StatefulSets。</td>
</tr>
<tr>
<td><code>run</code></td>
<td><code>kubectl run NAME --image=image [--env="key=value"] [--port=port] [--dry-run=server | client | none] [--overrides=inline-json] [flags]</code></td>
<td>在集群上运行指定的镜像。</td>
</tr>
<tr>
<td><code>scale</code></td>
<td><code>kubectl scale (-f FILENAME | TYPE NAME | TYPE/NAME) --replicas=COUNT [--resource-version=version] [--current-replicas=count] [flags]</code></td>
<td>更新指定副本控制器的大小。</td>
</tr>
<tr>
<td><code>set</code></td>
<td><code>kubectl set SUBCOMMAND [options]</code></td>
<td>配置应用程序资源。</td>
</tr>
<tr>
<td><code>taint</code></td>
<td><code>kubectl taint NODE NAME KEY_1=VAL_1:TAINT_EFFECT_1 ... KEY_N=VAL_N:TAINT_EFFECT_N [options]</code></td>
<td>更新一个或多个节点上的污点。</td>
</tr>
<tr>
<td><code>top</code></td>
<td><code>kubectl top [flags] [options]</code></td>
<td>显示资源（CPU/内存/存储）的使用情况。</td>
</tr>
<tr>
<td><code>uncordon</code></td>
<td><code>kubectl uncordon NODE [options]</code></td>
<td>将节点标记为可调度。</td>
</tr>
<tr>
<td><code>version</code></td>
<td><code>kubectl version [--client] [flags]</code></td>
<td>显示运行在客户端和服务器上的 Kubernetes 版本。</td>
</tr>
<tr>
<td><code>wait</code></td>
<td><code>kubectl wait ([-f FILENAME] | resource.group/resource.name | resource.group [(-l label | --all)]) [--for=delete|--for condition=available] [options]</code></td>
<td>实验性：等待一种或多种资源的特定条件。</td>
</tr>
</tbody>
</table>
<p>了解更多有关命令操作的信息，请参阅 <a href=/zh/docs/reference/kubectl/kubectl/>kubectl</a> 参考文档。</p>
<h2 id=资源类型>资源类型</h2>
<p>下表列出所有受支持的资源类型及其缩写别名:</p>
<p>(以下输出可以通过 <code>kubectl api-resources</code> 获取，内容以 Kubernetes 1.19.1 版本为准。)</p>
<table>
<thead>
<tr>
<th>资源名</th>
<th>缩写名</th>
<th>API 分组</th>
<th>按命名空间</th>
<th>资源类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bindings</code></td>
<td></td>
<td></td>
<td>true</td>
<td>Binding</td>
</tr>
<tr>
<td><code>componentstatuses</code></td>
<td><code>cs</code></td>
<td></td>
<td>false</td>
<td>ComponentStatus</td>
</tr>
<tr>
<td><code>configmaps</code></td>
<td><code>cm</code></td>
<td></td>
<td>true</td>
<td>ConfigMap</td>
</tr>
<tr>
<td><code>endpoints</code></td>
<td><code>ep</code></td>
<td></td>
<td>true</td>
<td>Endpoints</td>
</tr>
<tr>
<td><code>events</code></td>
<td><code>ev</code></td>
<td></td>
<td>true</td>
<td>Event</td>
</tr>
<tr>
<td><code>limitranges</code></td>
<td><code>limits</code></td>
<td></td>
<td>true</td>
<td>LimitRange</td>
</tr>
<tr>
<td><code>namespaces</code></td>
<td><code>ns</code></td>
<td></td>
<td>false</td>
<td>Namespace</td>
</tr>
<tr>
<td><code>nodes</code></td>
<td><code>no</code></td>
<td></td>
<td>false</td>
<td>Node</td>
</tr>
<tr>
<td><code>persistentvolumeclaims</code></td>
<td><code>pvc</code></td>
<td></td>
<td>true</td>
<td>PersistentVolumeClaim</td>
</tr>
<tr>
<td><code>persistentvolumes</code></td>
<td><code>pv</code></td>
<td></td>
<td>false</td>
<td>PersistentVolume</td>
</tr>
<tr>
<td><code>pods</code></td>
<td><code>po</code></td>
<td></td>
<td>true</td>
<td>Pod</td>
</tr>
<tr>
<td><code>podtemplates</code></td>
<td></td>
<td></td>
<td>true</td>
<td>PodTemplate</td>
</tr>
<tr>
<td><code>replicationcontrollers</code></td>
<td><code>rc</code></td>
<td></td>
<td>true</td>
<td>ReplicationController</td>
</tr>
<tr>
<td><code>resourcequotas</code></td>
<td><code>quota</code></td>
<td></td>
<td>true</td>
<td>ResourceQuota</td>
</tr>
<tr>
<td><code>secrets</code></td>
<td></td>
<td></td>
<td>true</td>
<td>Secret</td>
</tr>
<tr>
<td><code>serviceaccounts</code></td>
<td><code>sa</code></td>
<td></td>
<td>true</td>
<td>ServiceAccount</td>
</tr>
<tr>
<td><code>services</code></td>
<td><code>svc</code></td>
<td></td>
<td>true</td>
<td>Service</td>
</tr>
<tr>
<td><code>mutatingwebhookconfigurations</code></td>
<td></td>
<td>admissionregistration.k8s.io</td>
<td>false</td>
<td>MutatingWebhookConfiguration</td>
</tr>
<tr>
<td><code>validatingwebhookconfigurations</code></td>
<td></td>
<td>admissionregistration.k8s.io</td>
<td>false</td>
<td>ValidatingWebhookConfiguration</td>
</tr>
<tr>
<td><code>customresourcedefinitions</code></td>
<td><code>crd,crds</code></td>
<td>apiextensions.k8s.io</td>
<td>false</td>
<td>CustomResourceDefinition</td>
</tr>
<tr>
<td><code>apiservices</code></td>
<td></td>
<td>apiregistration.k8s.io</td>
<td>false</td>
<td>APIService</td>
</tr>
<tr>
<td><code>controllerrevisions</code></td>
<td></td>
<td>apps</td>
<td>true</td>
<td>ControllerRevision</td>
</tr>
<tr>
<td><code>daemonsets</code></td>
<td><code>ds</code></td>
<td>apps</td>
<td>true</td>
<td>DaemonSet</td>
</tr>
<tr>
<td><code>deployments</code></td>
<td><code>deploy</code></td>
<td>apps</td>
<td>true</td>
<td>Deployment</td>
</tr>
<tr>
<td><code>replicasets</code></td>
<td><code>rs</code></td>
<td>apps</td>
<td>true</td>
<td>ReplicaSet</td>
</tr>
<tr>
<td><code>statefulsets</code></td>
<td><code>sts</code></td>
<td>apps</td>
<td>true</td>
<td>StatefulSet</td>
</tr>
<tr>
<td><code>tokenreviews</code></td>
<td></td>
<td>authentication.k8s.io</td>
<td>false</td>
<td>TokenReview</td>
</tr>
<tr>
<td><code>localsubjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>true</td>
<td>LocalSubjectAccessReview</td>
</tr>
<tr>
<td><code>selfsubjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SelfSubjectAccessReview</td>
</tr>
<tr>
<td><code>selfsubjectrulesreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SelfSubjectRulesReview</td>
</tr>
<tr>
<td><code>subjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SubjectAccessReview</td>
</tr>
<tr>
<td><code>horizontalpodautoscalers</code></td>
<td><code>hpa</code></td>
<td>autoscaling</td>
<td>true</td>
<td>HorizontalPodAutoscaler</td>
</tr>
<tr>
<td><code>cronjobs</code></td>
<td><code>cj</code></td>
<td>batch</td>
<td>true</td>
<td>CronJob</td>
</tr>
<tr>
<td><code>jobs</code></td>
<td></td>
<td>batch</td>
<td>true</td>
<td>Job</td>
</tr>
<tr>
<td><code>certificatesigningrequests</code></td>
<td><code>csr</code></td>
<td>certificates.k8s.io</td>
<td>false</td>
<td>CertificateSigningRequest</td>
</tr>
<tr>
<td><code>leases</code></td>
<td></td>
<td>coordination.k8s.io</td>
<td>true</td>
<td>Lease</td>
</tr>
<tr>
<td><code>endpointslices</code></td>
<td></td>
<td>discovery.k8s.io</td>
<td>true</td>
<td>EndpointSlice</td>
</tr>
<tr>
<td><code>events</code></td>
<td><code>ev</code></td>
<td>events.k8s.io</td>
<td>true</td>
<td>Event</td>
</tr>
<tr>
<td><code>ingresses</code></td>
<td><code>ing</code></td>
<td>extensions</td>
<td>true</td>
<td>Ingress</td>
</tr>
<tr>
<td><code>flowschemas</code></td>
<td></td>
<td>flowcontrol.apiserver.k8s.io</td>
<td>false</td>
<td>FlowSchema</td>
</tr>
<tr>
<td><code>prioritylevelconfigurations</code></td>
<td></td>
<td>flowcontrol.apiserver.k8s.io</td>
<td>false</td>
<td>PriorityLevelConfiguration</td>
</tr>
<tr>
<td><code>ingressclasses</code></td>
<td></td>
<td>networking.k8s.io</td>
<td>false</td>
<td>IngressClass</td>
</tr>
<tr>
<td><code>ingresses</code></td>
<td><code>ing</code></td>
<td>networking.k8s.io</td>
<td>true</td>
<td>Ingress</td>
</tr>
<tr>
<td><code>networkpolicies</code></td>
<td><code>netpol</code></td>
<td>networking.k8s.io</td>
<td>true</td>
<td>NetworkPolicy</td>
</tr>
<tr>
<td><code>runtimeclasses</code></td>
<td></td>
<td>node.k8s.io</td>
<td>false</td>
<td>RuntimeClass</td>
</tr>
<tr>
<td><code>poddisruptionbudgets</code></td>
<td><code>pdb</code></td>
<td>policy</td>
<td>true</td>
<td>PodDisruptionBudget</td>
</tr>
<tr>
<td><code>podsecuritypolicies</code></td>
<td><code>psp</code></td>
<td>policy</td>
<td>false</td>
<td>PodSecurityPolicy</td>
</tr>
<tr>
<td><code>clusterrolebindings</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>false</td>
<td>ClusterRoleBinding</td>
</tr>
<tr>
<td><code>clusterroles</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>false</td>
<td>ClusterRole</td>
</tr>
<tr>
<td><code>rolebindings</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>true</td>
<td>RoleBinding</td>
</tr>
<tr>
<td><code>roles</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>true</td>
<td>Role</td>
</tr>
<tr>
<td><code>priorityclasses</code></td>
<td><code>pc</code></td>
<td>scheduling.k8s.io</td>
<td>false</td>
<td>PriorityClass</td>
</tr>
<tr>
<td><code>csidrivers</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>CSIDriver</td>
</tr>
<tr>
<td><code>csinodes</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>CSINode</td>
</tr>
<tr>
<td><code>storageclasses</code></td>
<td><code>sc</code></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>StorageClass</td>
</tr>
<tr>
<td><code>volumeattachments</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>VolumeAttachment</td>
</tr>
</tbody>
</table>
<h2 id=输出选项>输出选项</h2>
<p>有关如何格式化或排序某些命令的输出的信息，请使用以下部分。有关哪些命令支持各种输出选项的详细信息，请参阅<a href=/zh/docs/reference/kubectl/kubectl/>kubectl</a> 参考文档。</p>
<h3 id=格式化输出>格式化输出</h3>
<p>所有 <code>kubectl</code> 命令的默认输出格式都是人类可读的纯文本格式。要以特定格式向终端窗口输出详细信息，可以将 <code>-o</code> 或 <code>--output</code> 参数添加到受支持的 <code>kubectl</code> 命令中。</p>
<h4 id=语法-1>语法</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> -o<span style=color:#666>=</span>&lt;output_format&gt;
</code></pre></div>
<p>根据 <code>kubectl</code> 操作，支持以下输出格式：</p>
<table>
<thead>
<tr>
<th>Output format</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o custom-columns=&lt;spec></code></td>
<td>使用逗号分隔的<a href=#custom-columns>自定义列</a>列表打印表。</td>
</tr>
<tr>
<td><code>-o custom-columns-file=&lt;filename></code></td>
<td>使用 <code>&lt;filename></code> 文件中的<a href=#custom-columns>自定义列</a>模板打印表。</td>
</tr>
<tr>
<td><code>-o json</code></td>
<td>输出 JSON 格式的 API 对象</td>
</tr>
<tr>
<td><code>-o jsonpath=&lt;template></code></td>
<td>打印 <a href=/zh/docs/reference/kubectl/jsonpath/>jsonpath</a> 表达式定义的字段</td>
</tr>
<tr>
<td><code>-o jsonpath-file=&lt;filename></code></td>
<td>打印 <code>&lt;filename></code> 文件中 <a href=/zh/docs/reference/kubectl/jsonpath/>jsonpath</a> 表达式定义的字段。</td>
</tr>
<tr>
<td><code>-o name</code></td>
<td>仅打印资源名称而不打印任何其他内容。</td>
</tr>
<tr>
<td><code>-o wide</code></td>
<td>以纯文本格式输出，包含任何附加信息。对于 pod 包含节点名。</td>
</tr>
<tr>
<td><code>-o yaml</code></td>
<td>输出 YAML 格式的 API 对象。</td>
</tr>
</tbody>
</table>
<h5 id=示例>示例</h5>
<p>在此示例中，以下命令将单个 pod 的详细信息输出为 YAML 格式的对象：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod web-pod-13je7 -o yaml
</code></pre></div>
<p>请记住：有关每个命令支持哪种输出格式的详细信息，请参阅 <a href=/zh/docs/reference/kubectl/kubectl/>kubectl</a> 参考文档。</p>
<h4 id=自定义列>自定义列</h4>
<p>要定义自定义列并仅将所需的详细信息输出到表中，可以使用该 custom-columns 选项。你可以选择内联定义自定义列或使用模板文件：<code>-o=custom-columns=&lt;spec></code> 或 <code>-o=custom-columns-file=&lt;filename></code>。</p>
<h5 id=示例-1>示例</h5>
<p>内联：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; -o custom-columns<span style=color:#666>=</span>NAME:.metadata.name,RSRC:.metadata.resourceVersion
</code></pre></div>
<p>模板文件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; -o custom-columns-file<span style=color:#666>=</span>template.txt
</code></pre></div>
<p>其中，<code>template.txt</code> 文件包含：</p>
<pre><code>NAME          RSRC
metadata.name metadata.resourceVersion
</code></pre>
<p>运行任何一个命令的结果类似于:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME           RSRC
submit-queue   <span style=color:#666>610995</span>
</code></pre></div>
<h4 id=server-side-列>Server-side 列</h4>
<p><code>kubectl</code> 支持从服务器接收关于对象的特定列信息。
这意味着对于任何给定的资源，服务器将返回与该资源相关的列和行，以便客户端打印。
通过让服务器封装打印的细节，这允许在针对同一集群使用的客户端之间提供一致的人类可读输出。</p>
<p>此功能默认启用。要禁用它，请将该 <code>--server-print=false</code> 参数添加到 <code>kubectl get</code> 命令中。</p>
<h5 id=例子>例子：</h5>
<p>要打印有关 pod 状态的信息，请使用如下命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; --server-print<span style=color:#666>=</span><span style=color:#a2f>false</span>
</code></pre></div>
<p>输出类似于：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME       AGE
pod-name   1m
</code></pre></div>
<h3 id=排序列表对象>排序列表对象</h3>
<p>要将对象排序后输出到终端窗口，可以将 <code>--sort-by</code> 参数添加到支持的 <code>kubectl</code> 命令。通过使用 <code>--sort-by</code> 参数指定任何数字或字符串字段来对对象进行排序。要指定字段，请使用 <a href=/zh/docs/reference/kubectl/jsonpath/>jsonpath</a> 表达式。</p>
<h4 id=语法-2>语法</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> --sort-by<span style=color:#666>=</span>&lt;jsonpath_exp&gt;
</code></pre></div>
<h5 id=示例-2>示例</h5>
<p>要打印按名称排序的 pod 列表，请运行：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --sort-by<span style=color:#666>=</span>.metadata.name
</code></pre></div>
<h2 id=示例-常用操作>示例：常用操作</h2>
<p>使用以下示例集来帮助你熟悉运行常用 kubectl 操作：</p>
<p><code>kubectl apply</code> - 以文件或标准输入为准应用或更新资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 使用 example-service.yaml 中的定义创建服务。</span>
kubectl apply -f example-service.yaml

<span style=color:#080;font-style:italic># 使用 example-controller.yaml 中的定义创建 replication controller。</span>
kubectl apply -f example-controller.yaml

<span style=color:#080;font-style:italic># 使用 &lt;directory&gt; 路径下的任意 .yaml, .yml, 或 .json 文件 创建对象。</span>
kubectl apply -f &lt;directory&gt;
</code></pre></div>
<p><code>kubectl get</code> - 列出一个或多个资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 以纯文本输出格式列出所有 pod。</span>
kubectl get pods

<span style=color:#080;font-style:italic># 以纯文本输出格式列出所有 pod，并包含附加信息(如节点名)。</span>
kubectl get pods -o wide

<span style=color:#080;font-style:italic># 以纯文本输出格式列出具有指定名称的副本控制器。提示：你可以使用别名 &#39;rc&#39; 缩短和替换 &#39;replicationcontroller&#39; 资源类型。</span>
kubectl get replicationcontroller &lt;rc-name&gt;

<span style=color:#080;font-style:italic># 以纯文本输出格式列出所有副本控制器和服务。</span>
kubectl get rc,services

<span style=color:#080;font-style:italic># 以纯文本输出格式列出所有守护程序集，包括未初始化的守护程序集。</span>
kubectl get ds --include-uninitialized

<span style=color:#080;font-style:italic># 列出在节点 server01 上运行的所有 pod</span>
kubectl get pods --field-selector<span style=color:#666>=</span>spec.nodeName<span style=color:#666>=</span>server01
</code></pre></div>
<p><code>kubectl describe</code> - 显示一个或多个资源的详细状态，默认情况下包括未初始化的资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 显示名称为 &lt;node-name&gt; 的节点的详细信息。</span>
kubectl describe nodes &lt;node-name&gt;

<span style=color:#080;font-style:italic># 显示名为 &lt;pod-name&gt; 的 pod 的详细信息。</span>
kubectl describe pods/&lt;pod-name&gt;

<span style=color:#080;font-style:italic># 显示由名为 &lt;rc-name&gt; 的副本控制器管理的所有 pod 的详细信息。</span>
<span style=color:#080;font-style:italic># 记住：副本控制器创建的任何 pod 都以复制控制器的名称为前缀。</span>
kubectl describe pods &lt;rc-name&gt;

<span style=color:#080;font-style:italic># 描述所有的 pod，不包括未初始化的 pod</span>
kubectl describe pods
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p><code>kubectl get</code> 命令通常用于检索同一资源类型的一个或多个资源。
它具有丰富的参数，允许你使用 <code>-o</code> 或 <code>--output</code> 参数自定义输出格式。你可以指定 <code>-w</code> 或 <code>--watch</code> 参数以开始观察特定对象的更新。
<code>kubectl describe</code> 命令更侧重于描述指定资源的许多相关方面。它可以调用对 <code>API 服务器</code> 的多个 API 调用来为用户构建视图。
例如，该 <code>kubectl describe node</code> 命令不仅检索有关节点的信息，还检索在其上运行的 pod 的摘要，为节点生成的事件等。
</div>
<p><code>kubectl delete</code> - 从文件、stdin 或指定标签选择器、名称、资源选择器或资源中删除资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 使用 pod.yaml 文件中指定的类型和名称删除 pod。</span>
kubectl delete -f pod.yaml

<span style=color:#080;font-style:italic># 删除所有带有 &#39;&lt;label-key&gt;=&lt;label-value&gt;&#39; 标签的 Pod 和服务。</span>
kubectl delete pods,services -l &lt;label-key&gt;<span style=color:#666>=</span>&lt;label-value&gt;

<span style=color:#080;font-style:italic># 删除所有 pod，包括未初始化的 pod。</span>
kubectl delete pods --all
</code></pre></div>
<p><code>kubectl exec</code> - 对 pod 中的容器执行命令。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 从 pod &lt;pod-name&gt; 中获取运行 &#39;date&#39; 的输出。默认情况下，输出来自第一个容器。</span>
kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -- date

<span style=color:#080;font-style:italic># 运行输出 &#39;date&#39; 获取在容器的 &lt;container-name&gt; 中 pod &lt;pod-name&gt; 的输出。</span>
kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -c &lt;container-name&gt; -- date

<span style=color:#080;font-style:italic># 获取一个交互 TTY 并运行 /bin/bash &lt;pod-name &gt;。默认情况下，输出来自第一个容器。</span>
kubectl <span style=color:#a2f>exec</span> -ti &lt;pod-name&gt; -- /bin/bash
</code></pre></div>
<p><code>kubectl logs</code> - 打印 Pod 中容器的日志。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 从 pod 返回日志快照。</span>
kubectl logs &lt;pod-name&gt;

<span style=color:#080;font-style:italic># 从 pod &lt;pod-name&gt; 开始流式传输日志。这类似于 &#39;tail -f&#39; Linux 命令。</span>
kubectl logs -f &lt;pod-name&gt;
</code></pre></div>
<h2 id=示例-创建和使用插件>示例：创建和使用插件</h2>
<p>使用以下示例来帮助你熟悉编写和使用 <code>kubectl</code> 插件：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 用任何语言创建一个简单的插件，并为生成的可执行文件命名</span>
<span style=color:#080;font-style:italic># 以前缀 &#34;kubectl-&#34; 开始</span>
cat ./kubectl-hello
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080>#!/bin/sh
</span><span style=color:#080></span>
<span style=color:#080;font-style:italic># 这个插件打印单词 &#34;hello world&#34;</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;hello world&#34;</span>
</code></pre></div><p>这个插件写好了，把它变成可执行的：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo chmod a+x ./kubectl-hello

<span style=color:#080;font-style:italic># 并将其移动到路径中的某个位置</span>
sudo mv ./kubectl-hello /usr/local/bin
sudo chown root:root /usr/local/bin

<span style=color:#080;font-style:italic># 你现在已经创建并&#34;安装了&#34;一个 kubectl 插件。</span>
<span style=color:#080;font-style:italic># 你可以开始使用这个插件，从 kubectl 调用它，就像它是一个常规命令一样</span>
kubectl hello
</code></pre></div><pre><code>hello world
</code></pre>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 你可以&#34;卸载&#34;一个插件，只需从你的路径中删除它</span>
sudo rm /usr/local/bin/kubectl-hello
</code></pre></div>
<p>为了查看可用的所有 <code>kubectl</code> 插件，你可以使用 <code>kubectl plugin list</code> 子命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl plugin list
</code></pre></div>
<p>输出类似于：</p>
<pre><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
/usr/local/bin/kubectl-bar
</code></pre>
<p><code>kubectl plugin list</code>指令也可以向你告警哪些插件被运行，或是被其它插件覆盖了,例如:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo chmod -x /usr/local/bin/kubectl-foo <span style=color:#080;font-style:italic># 删除执行权限</span>
kubectl plugin list
</code></pre></div>
<pre><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
  - warning: /usr/local/bin/kubectl-foo identified as a plugin, but it is not executable
/usr/local/bin/kubectl-bar

error: one plugin warning was found
</code></pre>
<p>你可以将插件视为在现有 kubectl 命令之上构建更复杂功能的一种方法：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat ./kubectl-whoami
</code></pre></div>
<p>接下来的几个示例假设你已经将 <code>kubectl-whoami</code> 设置为以下内容:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080>#!/bin/bash
</span><span style=color:#080></span>
<span style=color:#080;font-style:italic>#这个插件利用 `kubectl config` 命令基于当前所选上下文输出当前用户的信息</span>
kubectl config view --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{ range .contexts }}{{ if eq .name &#34;&#39;</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config current-context<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#39;&#34; }}Current user: {{ printf &#34;%s\n&#34; .context.user }}{{ end }}{{ end }}&#39;</span>
</code></pre></div>
<p>运行以上命令将为你提供一个输出，其中包含 KUBECONFIG 文件中当前上下文的用户:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080>#!/bin/bash
</span><span style=color:#080></span><span style=color:#080;font-style:italic># 使文件成为可执行的</span>
sudo chmod +x ./kubectl-whoami

<span style=color:#080;font-style:italic># 然后移动到你的路径中</span>
sudo mv ./kubectl-whoami /usr/local/bin

kubectl whoami
Current user: plugins-user
</code></pre></div>
<p>要了解关于插件的更多信息，请查看<a href=https://github.com/kubernetes/sample-cli-plugin>示例 cli 插件</a>。</p>
<h2 id=接下来>接下来</h2>
<ul>
<li>
<p>开始使用 <a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a> 命令。</p>
</li>
<li>
<p>查看更多<a href=https://github.com/kubernetes/sample-cli-plugin>示例 cli 插件</a>。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a938176c695852fe70362c29cf615f1c>9.2 - JSONPath 支持</h1>
<p>Kubectl 支持 JSONPath 模板。</p>
<p>JSONPath 模板由 {} 包起来的 JSONPath 表达式组成。Kubectl 使用 JSONPath 表达式来过滤 JSON 对象中的特定字段并格式化输出。除了原始的 JSONPath 模板语法，以下函数和语法也是有效的:</p>
<ol>
<li>使用双引号将 JSONPath 表达式内的文本引起来。</li>
<li>使用 <code>range</code>，<code>end</code> 运算符来迭代列表。</li>
<li>使用负片索引后退列表。负索引不会“环绕”列表，并且只要 <code>-index + listLength> = 0</code> 就有效。</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<ul>
<li>
<p><code>$</code> 运算符是可选的，因为默认情况下表达式总是从根对象开始。</p>
</li>
<li>
<p>结果对象将作为其 String() 函数输出。</p>
</li>
</ul>
</div>
<p>给定 JSON 输入:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;List&#34;</span>,
  <span style=color:green;font-weight:700>&#34;items&#34;</span>:[
    {
      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>},
      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;4&#34;</span>},
        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[{<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>}]
      }
    },
    {
      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;8&#34;</span>},
        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[
          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;another&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.3&#34;</span>}
        ]
      }
    }
  ],
  <span style=color:green;font-weight:700>&#34;users&#34;</span>:[
    {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;myself&#34;</span>,
      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {}
    },
    {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;e2e&#34;</span>,
      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {<span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;admin&#34;</span>, <span style=color:green;font-weight:700>&#34;password&#34;</span>: <span style=color:#b44>&#34;secret&#34;</span>}
    }
  ]
}
</code></pre></div>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>text</code></td>
<td>纯文本</td>
<td><code>kind is {.kind}</code></td>
<td><code>kind is List</code></td>
</tr>
<tr>
<td><code>@</code></td>
<td>当前对象</td>
<td><code>{@}</code></td>
<td>与输入相同</td>
</tr>
<tr>
<td><code>.</code> or <code>[]</code></td>
<td>子运算符</td>
<td><code>{.kind}</code>, <code>{['kind']}</code> or <code>{['name\.type']}</code></td>
<td><code>List</code></td>
</tr>
<tr>
<td><code>..</code></td>
<td>递归下降</td>
<td><code>{..name}</code></td>
<td><code>127.0.0.1 127.0.0.2 myself e2e</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>通配符。获取所有对象</td>
<td><code>{.items[*].metadata.name}</code></td>
<td><code>[127.0.0.1 127.0.0.2]</code></td>
</tr>
<tr>
<td><code>[start:end :step]</code></td>
<td>下标运算符</td>
<td><code>{.users[0].name}</code></td>
<td><code>myself</code></td>
</tr>
<tr>
<td><code>[,]</code></td>
<td>并集运算符</td>
<td><code>{.items[*]['metadata.name', 'status.capacity']}</code></td>
<td><code>127.0.0.1 127.0.0.2 map[cpu:4] map[cpu:8]</code></td>
</tr>
<tr>
<td><code>?()</code></td>
<td>过滤</td>
<td><code>{.users[?(@.name=="e2e")].user.password}</code></td>
<td><code>secret</code></td>
</tr>
<tr>
<td><code>range</code>, <code>end</code></td>
<td>迭代列表</td>
<td><code>{range .items[*]}[{.metadata.name}, {.status.capacity}] {end}</code></td>
<td><code>[127.0.0.1, map[cpu:4]] [127.0.0.2, map[cpu:8]]</code></td>
</tr>
<tr>
<td><code>''</code></td>
<td>引用解释执行字符串</td>
<td><code>{range .items[*]}{.metadata.name}{'\t'}{end}</code></td>
<td><code>127.0.0.1 127.0.0.2</code></td>
</tr>
</tbody>
</table>
<p>使用 <code>kubectl</code> 和 JSONPath 表达式的示例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -o json
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{@}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0]}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0].metadata.name}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*][&#39;metadata.name&#39;, &#39;status.capacity&#39;]}&#34;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{.metadata.name}{&#34;\t&#34;}{.status.startTime}{&#34;\n&#34;}{end}&#39;</span>
</code></pre></div>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> <p>在 Windows 上，对于任何包含空格的 JSONPath 模板，您必须使用双引号（不是上面 bash 所示的单引号）。
反过来，这意味着您必须在模板中的所有文字周围使用单引号或转义的双引号。
例如:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd>C:<span style=color:#a0a000>\</span><span style=color:#080;font-style:italic>&gt; kubectl get pods -o=jsonpath=&#34;{range .items[*]}{.metadata.name}{&#39;\t&#39;}{.status.startTime}{&#39;\n&#39;}{end}&#34;</span>
C:<span style=color:#a0a000>\</span><span style=color:#080;font-style:italic>&gt; kubectl get pods -o=jsonpath=&#34;{range .items[*]}{.metadata.name}{\&#34;\t\&#34;}{.status.startTime}{\&#34;\n\&#34;}{end}&#34;</span>
</code></pre></div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> <p>不支持 JSONPath 正则表达式。如需使用正则表达式进行匹配操作，您可以使用如 <code>jq</code> 之类的工具。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># kubectl 的 JSONpath 输出不支持正则表达式</span>
<span style=color:#080;font-style:italic># 下面的命令不会生效</span>
kubectl get pods -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[?(@.metadata.name=~/^test$/)].metadata.name}&#39;</span>

<span style=color:#080;font-style:italic># 下面的命令可以获得所需的结果</span>
kubectl get pods -o json | jq -r <span style=color:#b44>&#39;.items[] | select(.metadata.name | test(&#34;test-&#34;)).spec.containers[].image&#39;</span>
</code></pre></div>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4d3e62632c189fcc3c1357cd8fb8799c>9.3 - kubectl</h1>
<h2 id=简介>简介</h2>
<p>kubectl 管理控制 Kubernetes 集群。</p>
<p>获取更多信息，请访问 <a href=/zh/docs/reference/kubectl/overview/>kubectl 概述</a>。</p>
<pre><code>kubectl [flags]
</code></pre><h2 id=选项>选项</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--add-dir-header</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示添加文件目录到日志信息头中
</td>
</tr>
<tr>
<td colspan=2>--alsologtostderr</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
表示将日志输出到文件的同时输出到 stderr
</td>
</tr>
<tr>
<td colspan=2>--as string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
以指定用户的身份执行操作
</td>
</tr>
<tr>
<td colspan=2>--as-group stringArray</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
模拟指定的组来执行操作，可以使用这个标志来指定多个组。
</td>
</tr>
<tr>
<td colspan=2>--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Azure 容器仓库配置信息的文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--cache-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "$HOME/.kube/cache"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
默认缓存目录
</td>
</tr>
<tr>
<td colspan=2>--certificate-authority string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向证书机构的 cert 文件路径
</td>
</tr>
<tr>
<td colspan=2>--client-certificate string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 使用的客户端证书路径
</td>
</tr>
<tr>
<td colspan=2>--client-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 使用的客户端密钥文件路径
</td>
</tr>
<tr>
<td colspan=2>--cloud-provider-gce-l7lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 130.211.0.0/22,35.191.0.0/16</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在 GCE 防火墙中开放的 CIDR，用来进行 L7 LB 流量代理和健康检查。
</td>
</tr>
<tr>
<td colspan=2>--cloud-provider-gce-lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 130.211.0.0/22,209.85.152.0/22,209.85.204.0/22,35.191.0.0/16</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在 GCE 防火墙中开放的 CIDR，用来进行 L4 LB 流量代理和健康检查。
</td>
</tr>
<tr>
<td colspan=2>--cluster string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要使用的 kubeconfig 集群的名称
</td>
</tr>
<tr>
<td colspan=2>--context string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要使用的 kubeconfig 上下文的名称
</td>
</tr>
<tr>
<td colspan=2>--default-not-ready-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 300</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
表示 `notReady` 状态的容忍度秒数：默认情况下，`NoExecute` 被添加到尚未具有此容忍度的每个 Pod 中。
</td>
</tr>
<tr>
<td colspan=2>--default-unreachable-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 300</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
表示 `unreachable` 状态的容忍度秒数：默认情况下，`NoExecute` 被添加到尚未具有此容忍度的每个 Pod 中。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubectl 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--insecure-skip-tls-verify</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true，则表示不会检查服务器证书的有效性。这样会导致您的 HTTPS 连接不安全。
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CLI 请求使用的 kubeconfig 配置文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当日志机制运行到指定文件的指定行（file:N）时，打印调用堆栈信息
</td>
</tr>
<tr>
<td colspan=2>--log-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果不为空，则将日志文件写入此目录
</td>
</tr>
<tr>
<td colspan=2>--log-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果不为空，则将使用此日志文件
</td>
</tr>
<tr>
<td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
定义日志文件的最大尺寸。单位为兆字节。如果值设置为 0，则表示日志文件大小不受限制。
</td>
</tr>
<tr>
<td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 5s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
两次日志刷新操作之间的最长时间（秒）
</td>
</tr>
<tr>
<td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
日志输出到 stderr 而不是文件中
</td>
</tr>
<tr>
<td colspan=2>--match-server-version</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要求客户端版本和服务端版本相匹配
</td>
</tr>
<tr>
<td colspan=2>-n, --namespace string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果存在，CLI 请求将使用此命名空间
</td>
<tr>
<td colspan=2>--one-output</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则只将日志写入初始严重级别（而不是同时写入所有较低的严重级别）。
</td>
</tr>
</tr>
<tr>
<td colspan=2>--password string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 服务器进行基本身份验证的密码
</td>
</tr>
<tr>
<td colspan=2>--profile string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "none"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要记录的性能指标的名称。可取 (none|cpu|heap|goroutine|threadcreate|block|mutex) 其中之一。
</td>
</tr>
<tr>
<td colspan=2>--profile-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "profile.pprof"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于转储所记录的性能信息的文件名
</td>
</tr>
<tr>
<td colspan=2>--request-timeout string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "0"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
放弃单个服务器请求之前的等待时间，非零值需要包含相应时间单位（例如：1s、2m、3h）。零值则表示不做超时要求。
</td>
</tr>
<tr>
<td colspan=2>-s, --server string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
Kubernetes API 服务器的地址和端口
</td>
</tr>
<tr>
<td colspan=2>--skip-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 则表示跳过在日志消息中出现 header 前缀信息
</td>
</tr>
<tr>
<td colspan=2>--skip-log-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 则表示在打开日志文件时跳过 header 信息
</td>
</tr>
<tr>
<td colspan=2>--stderrthreshold severity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 2</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
等于或高于此阈值的日志将输出到标准错误输出（stderr）
</td>
</tr>
<tr>
<td colspan=2>--token string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于对 API 服务器进行身份认证的持有者令牌
</td>
</tr>
<tr>
<td colspan=2>--user string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定使用 kubeconfig 配置文件中的用户名
</td>
</tr>
<tr>
<td colspan=2>--username string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 API 服务器的基本身份验证的用户名
</td>
</tr>
<tr>
<td colspan=2>-v, --v Level</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定输出日志的日志详细级别
</td>
</tr>
<tr>
<td colspan=2>--version version[=true]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
打印 kubectl 版本信息并退出
</td>
</tr>
<tr>
<td colspan=2>--vmodule moduleSpec</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
以逗号分隔的 pattern=N 设置列表，用于过滤文件的日志记录
</td>
</tr>
</tbody>
</table>
<h2 id=环境变量>环境变量</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>KUBECONFIG</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubectl 的配置 ("kubeconfig") 文件的路径。默认值: "$HOME/.kube/config"
</td>
</tr>
<tr>
<td colspan=2>KUBECTL_COMMAND_HEADERS</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 false 时，关闭用于详细说明被调用的 kubectl 命令的额外 HTTP 标头 (Kubernetes 版本为 v1.22 或者更高)
</td>
</tr>
</tbody>
</table>
<h2 id=另请参见>另请参见</h2>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#annotate>kubectl annotate</a> - 更新资源所关联的注解</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#api-resources>kubectl api-resources</a> - 打印服务器上所支持的 API 资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#api-versions>kubectl api-versions</a> - 以“组/版本”的格式输出服务端所支持的 API 版本</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#apply>kubectl apply</a> - 基于文件名或标准输入，将新的配置应用到资源上</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#attach>kubectl attach</a> - 连接到一个正在运行的容器</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#auth>kubectl auth</a> - 检查授权信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#autoscale>kubectl autoscale</a> - 对一个资源对象（Deployment、ReplicaSet 或 ReplicationController ）进行扩缩</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#certificate>kubectl certificate</a> - 修改证书资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#cluster-info>kubectl cluster-info</a> - 显示集群信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#completion>kubectl completion</a> - 根据已经给出的 Shell（bash 或 zsh），输出 Shell 补全后的代码</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#config>kubectl config</a> - 修改 kubeconfig 配置文件</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#convert>kubectl convert</a> - 在不同的 API 版本之间转换配置文件</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#cordon>kubectl cordon</a> - 标记节点为不可调度的</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#cp>kubectl cp</a> - 将文件和目录拷入/拷出容器</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#create>kubectl create</a> - 通过文件或标准输入来创建资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#debug>kubectl debug</a> - 创建用于排查工作负载和节点故障的调试会话</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#delete>kubectl delete</a> - 通过文件名、标准输入、资源和名字删除资源，或者通过资源和标签选择器来删除资源</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#describe>kubectl describe</a> - 显示某个资源或某组资源的详细信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#diff>kubectl diff</a> - 显示目前版本与将要应用的版本之间的差异</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#drain>kubectl drain</a> - 腾空节点，准备维护</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#edit>kubectl edit</a> - 修改服务器上的某资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#exec>kubectl exec</a> - 在容器中执行相关命令</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#explain>kubectl explain</a> - 显示资源文档说明</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#expose>kubectl expose</a> - 给定副本控制器、服务、Deployment 或 Pod，将其暴露为新的 kubernetes Service</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#get>kubectl get</a> - 显示一个或者多个资源信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#kustomize>kubectl kustomize</a> - 从目录或远程 URL 中构建 kustomization</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#label>kubectl label</a> - 更新资源的标签</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#logs>kubectl logs</a> - 输出 pod 中某容器的日志</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#options>kubectl options</a> - 打印所有命令都支持的共有参数列表</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#patch>kubectl patch</a> - 基于策略性合并修补（Stategic Merge Patch）规则更新某资源中的字段</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#plugin>kubectl plugin</a> - 运行命令行插件</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#port-forward>kubectl port-forward</a> - 将一个或者多个本地端口转发到 pod</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#proxy>kubectl proxy</a> - 运行一个 kubernetes API 服务器代理</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#replace>kubectl replace</a> - 基于文件名或标准输入替换资源</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#rollout>kubectl rollout</a> - 管理资源的上线</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#run>kubectl run</a> - 在集群中使用指定镜像启动容器</li>
</ul>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#scale>kubectl scale</a> - 为一个 Deployment、ReplicaSet 或 ReplicationController 设置一个新的规模尺寸值</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#set>kubectl set</a> - 为对象设置功能特性</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a> - 在一个或者多个节点上更新污点配置</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#top>kubectl top</a> - 显示资源（CPU /内存/存储）使用率</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#uncordon>kubectl uncordon</a> - 标记节点为可调度的</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#version>kubectl version</a> - 打印客户端和服务器的版本信息</li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#wait>kubectl wait</a> - 实验性：等待一个或多个资源达到某种状态</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d7ffbf04ffbefb241fd0722423b80f5a>9.4 - kubectl 命令</h1>
<p><a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl 命令参考</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8aba901ac13f124e5782b90ddb166ee2>9.5 - kubectl 备忘单</h1>
<p>本页列举了常用的 “kubectl” 命令和标志</p>
<h2 id=kubectl-自动补全>Kubectl 自动补全</h2>
<h3 id=bash>BASH</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion bash<span style=color:#666>)</span> <span style=color:#080;font-style:italic># 在 bash 中设置当前 shell 的自动补全，要先安装 bash-completion 包。</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;source &lt;(kubectl completion bash)&#34;</span> &gt;&gt; ~/.bashrc <span style=color:#080;font-style:italic># 在您的 bash shell 中永久的添加自动补全</span>
</code></pre></div><p>您还可以为 <code>kubectl</code> 使用一个速记别名，该别名也可以与 completion 一起使用：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>alias</span> <span style=color:#b8860b>k</span><span style=color:#666>=</span>kubectl
<span style=color:#a2f>complete</span> -F __start_kubectl k
</code></pre></div><h3 id=zsh>ZSH</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>  <span style=color:#080;font-style:italic># 在 zsh 中设置当前 shell 的自动补全</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;[[ </span><span style=color:#b8860b>$commands</span><span style=color:#b44>[kubectl] ]] &amp;&amp; source &lt;(kubectl completion zsh)&#34;</span> &gt;&gt; ~/.zshrc <span style=color:#080;font-style:italic># 在您的 zsh shell 中永久的添加自动补全</span>
</code></pre></div>
<h2 id=kubectl-上下文和配置>Kubectl 上下文和配置</h2>
<p>设置 <code>kubectl</code> 与哪个 Kubernetes 集群进行通信并修改配置信息。
查看<a href=/zh/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>使用 kubeconfig 跨集群授权访问</a>
文档获取配置文件详细信息。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config view <span style=color:#080;font-style:italic># 显示合并的 kubeconfig 配置。</span>

<span style=color:#080;font-style:italic># 同时使用多个 kubeconfig 文件并查看合并的配置</span>
<span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>~/.kube/config:~/.kube/kubconfig2 kubectl config view

<span style=color:#080;font-style:italic># 获取 e2e 用户的密码</span>
kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[?(@.name == &#34;e2e&#34;)].user.password}&#39;</span>

kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[].name}&#39;</span>    <span style=color:#080;font-style:italic># 显示第一个用户</span>
kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[*].name}&#39;</span>   <span style=color:#080;font-style:italic># 获取用户列表</span>
kubectl config get-contexts                          <span style=color:#080;font-style:italic># 显示上下文列表</span>
kubectl config current-context                       <span style=color:#080;font-style:italic># 展示当前所处的上下文</span>
kubectl config use-context my-cluster-name           <span style=color:#080;font-style:italic># 设置默认的上下文为 my-cluster-name</span>

<span style=color:#080;font-style:italic># 添加新的用户配置到 kubeconf 中，使用 basic auth 进行身份认证</span>
kubectl config set-credentials kubeuser/foo.kubernetes.com --username<span style=color:#666>=</span>kubeuser --password<span style=color:#666>=</span>kubepassword

<span style=color:#080;font-style:italic># 在指定上下文中持久性地保存名字空间，供所有后续 kubectl 命令使用</span>
kubectl config set-context --current --namespace<span style=color:#666>=</span>ggckad-s2

<span style=color:#080;font-style:italic># 使用特定的用户名和名字空间设置上下文</span>
kubectl config set-context gce --user<span style=color:#666>=</span>cluster-admin --namespace<span style=color:#666>=</span>foo <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> kubectl config use-context gce

kubectl config <span style=color:#a2f>unset</span> users.foo                       <span style=color:#080;font-style:italic># 删除用户 foo</span>
</code></pre></div>
<h2 id=kubectl-apply>Kubectl apply</h2>
<p><code>apply</code> 通过定义 Kubernetes 资源的文件来管理应用。
它通过运行 <code>kubectl apply</code> 在集群中创建和更新资源。
这是在生产中管理 Kubernetes 应用的推荐方法。
参见 <a href=https://kubectl.docs.kubernetes.io>Kubectl 文档</a>。</p>
<h2 id=creating-objects>创建对象</h2>
<p>Kubernetes 配置可以用 YAML 或 JSON 定义。可以使用的文件扩展名有
<code>.yaml</code>、<code>.yml</code> 和 <code>.json</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f ./my-manifest.yaml           <span style=color:#080;font-style:italic># 创建资源</span>
kubectl apply -f ./my1.yaml -f ./my2.yaml     <span style=color:#080;font-style:italic># 使用多个文件创建</span>
kubectl apply -f ./dir                        <span style=color:#080;font-style:italic># 基于目录下的所有清单文件创建资源</span>
kubectl apply -f https://git.io/vPieo         <span style=color:#080;font-style:italic># 从 URL 中创建资源</span>
kubectl create deployment nginx --image<span style=color:#666>=</span>nginx <span style=color:#080;font-style:italic># 启动单实例 nginx</span>

<span style=color:#080;font-style:italic># 创建一个打印 “Hello World” 的 Job</span>
kubectl create job hello --image<span style=color:#666>=</span>busybox -- <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;Hello World&#34;</span> 

<span style=color:#080;font-style:italic># 创建一个打印 “Hello World” 间隔1分钟的 CronJob</span>
kubectl create cronjob hello --image<span style=color:#666>=</span>busybox   --schedule<span style=color:#666>=</span><span style=color:#b44>&#34;*/1 * * * *&#34;</span> -- <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;Hello World&#34;</span>    

kubectl explain pods                          <span style=color:#080;font-style:italic># 获取 pod 清单的文档说明</span>

<span style=color:#080;font-style:italic># 从标准输入创建多个 YAML 对象</span>
cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: busybox-sleep
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>  - name: busybox
</span><span style=color:#b44>    image: busybox
</span><span style=color:#b44>    args:
</span><span style=color:#b44>    - sleep
</span><span style=color:#b44>    - &#34;1000000&#34;
</span><span style=color:#b44>---
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: busybox-sleep-less
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>  - name: busybox
</span><span style=color:#b44>    image: busybox
</span><span style=color:#b44>    args:
</span><span style=color:#b44>    - sleep
</span><span style=color:#b44>    - &#34;1000&#34;
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># 创建有多个 key 的 Secret</span>
cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Secret
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: mysecret
</span><span style=color:#b44>type: Opaque
</span><span style=color:#b44>data:
</span><span style=color:#b44>  password: $(echo -n &#34;s33msi4&#34; | base64 -w0)
</span><span style=color:#b44>  username: $(echo -n &#34;jane&#34; | base64 -w0)
</span><span style=color:#b44>EOF</span>
</code></pre></div>
<h2 id=查看和查找资源>查看和查找资源</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># get 命令的基本输出</span>
kubectl get services                          <span style=color:#080;font-style:italic># 列出当前命名空间下的所有 services</span>
kubectl get pods --all-namespaces             <span style=color:#080;font-style:italic># 列出所有命名空间下的全部的 Pods</span>
kubectl get pods -o wide                      <span style=color:#080;font-style:italic># 列出当前命名空间下的全部 Pods，并显示更详细的信息</span>
kubectl get deployment my-dep                 <span style=color:#080;font-style:italic># 列出某个特定的 Deployment</span>
kubectl get pods                              <span style=color:#080;font-style:italic># 列出当前命名空间下的全部 Pods</span>
kubectl get pod my-pod -o yaml                <span style=color:#080;font-style:italic># 获取一个 pod 的 YAML</span>

<span style=color:#080;font-style:italic># describe 命令的详细输出</span>
kubectl describe nodes my-node
kubectl describe pods my-pod

<span style=color:#080;font-style:italic># 列出当前名字空间下所有 Services，按名称排序</span>
kubectl get services --sort-by<span style=color:#666>=</span>.metadata.name

<span style=color:#080;font-style:italic># 列出 Pods，按重启次数排序</span>
kubectl get pods --sort-by<span style=color:#666>=</span><span style=color:#b44>&#39;.status.containerStatuses[0].restartCount&#39;</span>

<span style=color:#080;font-style:italic># 列举所有 PV 持久卷，按容量排序</span>
kubectl get pv --sort-by<span style=color:#666>=</span>.spec.capacity.storage

<span style=color:#080;font-style:italic># 获取包含 app=cassandra 标签的所有 Pods 的 version 标签</span>
kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra -o <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.labels.version}&#39;</span>

<span style=color:#080;font-style:italic># 检索带有 “.” 键值，例： &#39;ca.crt&#39;</span>
kubectl get configmap myconfig <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.ca\.crt}&#39;</span>

<span style=color:#080;font-style:italic># 获取所有工作节点（使用选择器以排除标签名称为 &#39;node-role.kubernetes.io/master&#39; 的结果）</span>
kubectl get node --selector<span style=color:#666>=</span><span style=color:#b44>&#39;!node-role.kubernetes.io/master&#39;</span>

<span style=color:#080;font-style:italic># 获取当前命名空间中正在运行的 Pods</span>
kubectl get pods --field-selector<span style=color:#666>=</span>status.phase<span style=color:#666>=</span>Running

<span style=color:#080;font-style:italic># 获取全部节点的 ExternalIP 地址</span>
kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].status.addresses[?(@.type==&#34;ExternalIP&#34;)].address}&#39;</span>

<span style=color:#080;font-style:italic># 列出属于某个特定 RC 的 Pods 的名称</span>
<span style=color:#080;font-style:italic># 在转换对于 jsonpath 过于复杂的场合，&#34;jq&#34; 命令很有用；可以在 https://stedolan.github.io/jq/ 找到它。</span>
<span style=color:#b8860b>sel</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get rc my-rc --output<span style=color:#666>=</span>json | jq -j <span style=color:#b44>&#39;.spec.selector | to_entries | .[] | &#34;\(.key)=\(.value),&#34;&#39;</span><span style=color:#a2f;font-weight:700>)</span>%?<span style=color:#b68;font-weight:700>}</span>
<span style=color:#a2f>echo</span> <span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>$sel</span> --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>

<span style=color:#080;font-style:italic># 显示所有 Pods 的标签（或任何其他支持标签的 Kubernetes 对象）</span>
kubectl get pods --show-labels

<span style=color:#080;font-style:italic># 检查哪些节点处于就绪状态</span>
<span style=color:#b8860b>JSONPATH</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span> <span style=color:#666>&amp;&amp;</span> kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$JSONPATH</span><span style=color:#b44>&#34;</span> | grep <span style=color:#b44>&#34;Ready=True&#34;</span>

<span style=color:#080;font-style:italic># 不使用外部工具来输出解码后的 Secret</span>
kubectl get secret my-secret -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range $k,$v := .data}}{{&#34;### &#34;}}{{$k}}{{&#34;\n&#34;}}{{$v|base64decode}}{{&#34;\n\n&#34;}}{{end}}&#39;</span>

<span style=color:#080;font-style:italic># 列出被一个 Pod 使用的全部 Secret</span>
kubectl get pods -o json | jq <span style=color:#b44>&#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39;</span> | grep -v null | sort | uniq

<span style=color:#080;font-style:italic># 列举所有 Pods 中初始化容器的容器 ID（containerID）</span>
<span style=color:#080;font-style:italic># 可用于在清理已停止的容器时避免删除初始化容器</span>
kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*].status.initContainerStatuses[*]}{.containerID}{&#34;\n&#34;}{end}&#39;</span> | cut -d/ -f3

<span style=color:#080;font-style:italic># 列出事件（Events），按时间戳排序</span>
kubectl get events --sort-by<span style=color:#666>=</span>.metadata.creationTimestamp

<span style=color:#080;font-style:italic># 比较当前的集群状态和假定某清单被应用之后的集群状态</span>
kubectl diff -f ./my-manifest.yaml

<span style=color:#080;font-style:italic># 生成一个句点分隔的树，其中包含为节点返回的所有键</span>
<span style=color:#080;font-style:italic># 在复杂的嵌套JSON结构中定位键时非常有用</span>
kubectl get nodes -o json | jq -c <span style=color:#b44>&#39;path(..)|[.[]|tostring]|join(&#34;.&#34;)&#39;</span>

<span style=color:#080;font-style:italic># 生成一个句点分隔的树，其中包含为pod等返回的所有键</span>
kubectl get pods -o json | jq -c <span style=color:#b44>&#39;path(..)|[.[]|tostring]|join(&#34;.&#34;)&#39;</span>

<span style=color:#080;font-style:italic># 假设你的 Pods 有默认的容器和默认的名字空间，并且支持 &#39;env&#39; 命令，可以使用以下脚本为所有 Pods 生成 ENV 变量。</span>
<span style=color:#080;font-style:italic># 该脚本也可用于在所有的 Pods 里运行任何受支持的命令，而不仅仅是 &#39;env&#39;。 </span>
<span style=color:#a2f;font-weight:700>for</span> pod in <span style=color:#a2f;font-weight:700>$(</span>kubectl get po --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span> <span style=color:#a2f>echo</span> <span style=color:#b8860b>$pod</span> <span style=color:#666>&amp;&amp;</span> kubectl <span style=color:#a2f>exec</span> -it <span style=color:#b8860b>$pod</span> -- env; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div>
<h2 id=更新资源>更新资源</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl <span style=color:#a2f>set</span> image deployment/frontend <span style=color:#b8860b>www</span><span style=color:#666>=</span>image:v2               <span style=color:#080;font-style:italic># 滚动更新 &#34;frontend&#34; Deployment 的 &#34;www&#34; 容器镜像</span>
kubectl rollout <span style=color:#a2f>history</span> deployment/frontend                      <span style=color:#080;font-style:italic># 检查 Deployment 的历史记录，包括版本</span>
kubectl rollout undo deployment/frontend                         <span style=color:#080;font-style:italic># 回滚到上次部署版本</span>
kubectl rollout undo deployment/frontend --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>         <span style=color:#080;font-style:italic># 回滚到特定部署版本</span>
kubectl rollout status -w deployment/frontend                    <span style=color:#080;font-style:italic># 监视 &#34;frontend&#34; Deployment 的滚动升级状态直到完成</span>
kubectl rollout restart deployment/frontend                      <span style=color:#080;font-style:italic># 轮替重启 &#34;frontend&#34; Deployment</span>

cat pod.json | kubectl replace -f -                              <span style=color:#080;font-style:italic># 通过传入到标准输入的 JSON 来替换 Pod</span>

<span style=color:#080;font-style:italic># 强制替换，删除后重建资源。会导致服务不可用。</span>
kubectl replace --force -f ./pod.json

<span style=color:#080;font-style:italic># 为多副本的 nginx 创建服务，使用 80 端口提供服务，连接到容器的 8000 端口。</span>
kubectl expose rc nginx --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8000</span>

<span style=color:#080;font-style:italic># 将某单容器 Pod 的镜像版本（标签）更新到 v4</span>
kubectl get pod mypod -o yaml | sed <span style=color:#b44>&#39;s/\(image: myimage\):.*$/\1:v4/&#39;</span> | kubectl replace -f -

kubectl label pods my-pod new-label<span style=color:#666>=</span>awesome                      <span style=color:#080;font-style:italic># 添加标签</span>
kubectl annotate pods my-pod icon-url<span style=color:#666>=</span>http://goo.gl/XXBTWq       <span style=color:#080;font-style:italic># 添加注解</span>
kubectl autoscale deployment foo --min<span style=color:#666>=</span><span style=color:#666>2</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>                <span style=color:#080;font-style:italic># 对 &#34;foo&#34; Deployment 自动伸缩容</span>
</code></pre></div>
<h2 id=部分更新资源>部分更新资源</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 部分更新某节点</span>
kubectl patch node k8s-node-1 -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;unschedulable&#34;:true}}&#39;</span>

<span style=color:#080;font-style:italic># 更新容器的镜像；spec.containers[*].name 是必须的。因为它是一个合并性质的主键。</span>
kubectl patch pod valid-pod -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;kubernetes-serve-hostname&#34;,&#34;image&#34;:&#34;new image&#34;}]}}&#39;</span>

<span style=color:#080;font-style:italic># 使用带位置数组的 JSON patch 更新容器的镜像</span>
kubectl patch pod valid-pod --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/containers/0/image&#34;, &#34;value&#34;:&#34;new image&#34;}]&#39;</span>

<span style=color:#080;font-style:italic># 使用带位置数组的 JSON patch 禁用某 Deployment 的 livenessProbe</span>
kubectl patch deployment valid-deployment  --type json   -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/livenessProbe&#34;}]&#39;</span>

<span style=color:#080;font-style:italic># 在带位置数组中添加元素</span>
kubectl patch sa default --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/secrets/1&#34;, &#34;value&#34;: {&#34;name&#34;: &#34;whatever&#34; } }]&#39;</span>
</code></pre></div>
<h2 id=编辑资源>编辑资源</h2>
<p>使用你偏爱的编辑器编辑 API 资源。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl edit svc/docker-registry                      <span style=color:#080;font-style:italic># 编辑名为 docker-registry 的服务</span>
<span style=color:#b8860b>KUBE_EDITOR</span><span style=color:#666>=</span><span style=color:#b44>&#34;nano&#34;</span> kubectl edit svc/docker-registry   <span style=color:#080;font-style:italic># 使用其他编辑器</span>
</code></pre></div>
<h2 id=对资源进行伸缩>对资源进行伸缩</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> rs/foo                                 <span style=color:#080;font-style:italic># 将名为 &#39;foo&#39; 的副本集伸缩到 3 副本</span>
kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> -f foo.yaml                            <span style=color:#080;font-style:italic># 将在 &#34;foo.yaml&#34; 中的特定资源伸缩到 3 个副本</span>
kubectl scale --current-replicas<span style=color:#666>=</span><span style=color:#666>2</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span> deployment/mysql  <span style=color:#080;font-style:italic># 如果名为 mysql 的 Deployment 的副本当前是 2，那么将它伸缩到 3</span>
kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>5</span> rc/foo rc/bar rc/baz                   <span style=color:#080;font-style:italic># 伸缩多个副本控制器</span>
</code></pre></div>
<h2 id=删除资源>删除资源</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl delete -f ./pod.json                                              <span style=color:#080;font-style:italic># 删除在 pod.json 中指定的类型和名称的 Pod</span>
kubectl delete pod,service baz foo                                        <span style=color:#080;font-style:italic># 删除名称为 &#34;baz&#34; 和 &#34;foo&#34; 的 Pod 和服务</span>
kubectl delete pods,services -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                              <span style=color:#080;font-style:italic># 删除包含 name=myLabel 标签的 pods 和服务</span>
kubectl -n my-ns delete pod,svc --all                                     <span style=color:#080;font-style:italic># 删除在 my-ns 名字空间中全部的 Pods 和服务</span>
<span style=color:#080;font-style:italic># 删除所有与 pattern1 或 pattern2 awk 模式匹配的 Pods</span>
kubectl get pods  -n mynamespace --no-headers<span style=color:#666>=</span><span style=color:#a2f>true</span> | awk <span style=color:#b44>&#39;/pattern1|pattern2/{print $1}&#39;</span> | xargs  kubectl delete -n mynamespace pod
</code></pre></div>
<h2 id=与运行中的-pods-进行交互>与运行中的 Pods 进行交互</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl logs my-pod                                 <span style=color:#080;font-style:italic># 获取 pod 日志（标准输出）</span>
kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                        <span style=color:#080;font-style:italic># 获取含 name=myLabel 标签的 Pods 的日志（标准输出）</span>
kubectl logs my-pod --previous                      <span style=color:#080;font-style:italic># 获取上个容器实例的 pod 日志（标准输出）</span>
kubectl logs my-pod -c my-container                 <span style=color:#080;font-style:italic># 获取 Pod 容器的日志（标准输出, 多容器场景）</span>
kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel -c my-container        <span style=color:#080;font-style:italic># 获取含 name=myLabel 标签的 Pod 容器日志（标准输出, 多容器场景）</span>
kubectl logs my-pod -c my-container --previous      <span style=color:#080;font-style:italic># 获取 Pod 中某容器的上个实例的日志（标准输出, 多容器场景）</span>
kubectl logs -f my-pod                              <span style=color:#080;font-style:italic># 流式输出 Pod 的日志（标准输出）</span>
kubectl logs -f my-pod -c my-container              <span style=color:#080;font-style:italic># 流式输出 Pod 容器的日志（标准输出, 多容器场景）</span>
kubectl logs -f -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel --all-containers    <span style=color:#080;font-style:italic># 流式输出含 name=myLabel 标签的 Pod 的所有日志（标准输出）</span>
kubectl run -i --tty busybox --image<span style=color:#666>=</span>busybox -- sh  <span style=color:#080;font-style:italic># 以交互式 Shell 运行 Pod</span>
kubectl run nginx --image<span style=color:#666>=</span>nginx -n mynamespace      <span style=color:#080;font-style:italic># 在指定名字空间中运行 nginx Pod</span>
kubectl run nginx --image<span style=color:#666>=</span>nginx                     <span style=color:#080;font-style:italic># 运行 ngins Pod 并将其规约写入到名为 pod.yaml 的文件</span>
  --dry-run<span style=color:#666>=</span>client -o yaml &gt; pod.yaml

kubectl attach my-pod -i                            <span style=color:#080;font-style:italic># 挂接到一个运行的容器中</span>
kubectl port-forward my-pod 5000:6000               <span style=color:#080;font-style:italic># 在本地计算机上侦听端口 5000 并转发到 my-pod 上的端口 6000</span>
kubectl <span style=color:#a2f>exec</span> my-pod -- ls /                         <span style=color:#080;font-style:italic># 在已有的 Pod 中运行命令（单容器场景）</span>
kubectl <span style=color:#a2f>exec</span> --stdin --tty my-pod -- /bin/sh        <span style=color:#080;font-style:italic># 使用交互 shell 访问正在运行的 Pod (一个容器场景)</span>
kubectl <span style=color:#a2f>exec</span> my-pod -c my-container -- ls /         <span style=color:#080;font-style:italic># 在已有的 Pod 中运行命令（多容器场景）</span>
kubectl top pod POD_NAME --containers               <span style=color:#080;font-style:italic># 显示给定 Pod 和其中容器的监控数据</span>
kubectl top pod POD_NAME --sort-by<span style=color:#666>=</span>cpu              <span style=color:#080;font-style:italic># 显示给定 Pod 的指标并且按照 &#39;cpu&#39; 或者 &#39;memory&#39; 排序</span>
</code></pre></div>
<h2 id=与-deployments-和-services-进行交互>与 Deployments 和 Services 进行交互</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl logs deploy/my-deployment                         <span style=color:#080;font-style:italic># 获取一个 Deployment 的 Pod 的日志（单容器例子）</span>
kubectl logs deploy/my-deployment -c my-container         <span style=color:#080;font-style:italic># 获取一个 Deployment 的 Pod 的日志（多容器例子）</span>

kubectl port-forward svc/my-service <span style=color:#666>5000</span>                  <span style=color:#080;font-style:italic># 侦听本地端口 5000 并转发到 Service 后端端口 5000</span>
kubectl port-forward svc/my-service 5000:my-service-port  <span style=color:#080;font-style:italic># 侦听本地端口 5000 并转发到名字为 &lt;my-service-port&gt; 的 Service 目标端口</span>

kubectl port-forward deploy/my-deployment 5000:6000       <span style=color:#080;font-style:italic># 侦听本地端口 5000 并转发到 &lt;my-deployment&gt; 创建的 Pod 里的端口 6000</span>
kubectl <span style=color:#a2f>exec</span> deploy/my-deployment -- ls                   <span style=color:#080;font-style:italic># 在 Deployment 里的第一个 Pod 的第一个容器里运行命令（单容器和多容器例子）</span>
</code></pre></div>
<h2 id=与节点和集群进行交互>与节点和集群进行交互</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl cordon my-node                                                <span style=color:#080;font-style:italic># 标记 my-node 节点为不可调度</span>
kubectl drain my-node                                                 <span style=color:#080;font-style:italic># 对 my-node 节点进行清空操作，为节点维护做准备</span>
kubectl uncordon my-node                                              <span style=color:#080;font-style:italic># 标记 my-node 节点为可以调度</span>
kubectl top node my-node                                              <span style=color:#080;font-style:italic># 显示给定节点的度量值</span>
kubectl cluster-info                                                  <span style=color:#080;font-style:italic># 显示主控节点和服务的地址</span>
kubectl cluster-info dump                                             <span style=color:#080;font-style:italic># 将当前集群状态转储到标准输出</span>
kubectl cluster-info dump --output-directory<span style=color:#666>=</span>/path/to/cluster-state   <span style=color:#080;font-style:italic># 将当前集群状态输出到 /path/to/cluster-state</span>

<span style=color:#080;font-style:italic># 如果已存在具有指定键和效果的污点，则替换其值为指定值。</span>
kubectl taint nodes foo <span style=color:#b8860b>dedicated</span><span style=color:#666>=</span>special-user:NoSchedule
</code></pre></div>
<h3 id=资源类型>资源类型</h3>
<p>列出所支持的全部资源类型和它们的简称、<a href=/zh/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning>API 组</a>, 是否是<a href=/zh/docs/concepts/overview/working-with-objects/namespaces>名字空间作用域</a> 和 <a href=/zh/docs/concepts/overview/working-with-objects/kubernetes-objects>Kind</a>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl api-resources
</code></pre></div>
<p>用于探索 API 资源的其他操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>      <span style=color:#080;font-style:italic># 所有命名空间作用域的资源</span>
kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>     <span style=color:#080;font-style:italic># 所有非命名空间作用域的资源</span>
kubectl api-resources -o name                <span style=color:#080;font-style:italic># 用简单格式列举所有资源（仅显示资源名称）</span>
kubectl api-resources -o wide                <span style=color:#080;font-style:italic># 用扩展格式列举所有资源（又称 &#34;wide&#34; 格式）</span>
kubectl api-resources --verbs<span style=color:#666>=</span>list,get       <span style=color:#080;font-style:italic># 支持 &#34;list&#34; 和 &#34;get&#34; 请求动词的所有资源</span>
kubectl api-resources --api-group<span style=color:#666>=</span>extensions <span style=color:#080;font-style:italic># &#34;extensions&#34; API 组中的所有资源</span>
</code></pre></div>
<h3 id=格式化输出>格式化输出</h3>
<p>要以特定格式将详细信息输出到终端窗口，将 <code>-o</code>（或者 <code>--output</code>）参数添加到支持的 <code>kubectl</code> 命令中。</p>
<table>
<thead>
<tr>
<th>输出格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o=custom-columns=&lt;spec></code></td>
<td>使用逗号分隔的自定义列来打印表格</td>
</tr>
<tr>
<td><code>-o=custom-columns-file=&lt;filename></code></td>
<td>使用 <code>&lt;filename></code> 文件中的自定义列模板打印表格</td>
</tr>
<tr>
<td><code>-o=json</code></td>
<td>输出 JSON 格式的 API 对象</td>
</tr>
<tr>
<td><code>-o=jsonpath=&lt;template></code></td>
<td>打印 <a href=/zh/docs/reference/kubectl/jsonpath>jsonpath</a> 表达式中定义的字段</td>
</tr>
<tr>
<td><code>-o=jsonpath-file=&lt;filename></code></td>
<td>打印在 <code>&lt;filename></code> 文件中定义的 <a href=/zh/docs/reference/kubectl/jsonpath>jsonpath</a> 表达式所指定的字段。</td>
</tr>
<tr>
<td><code>-o=name</code></td>
<td>仅打印资源名称而不打印其他内容</td>
</tr>
<tr>
<td><code>-o=wide</code></td>
<td>以纯文本格式输出额外信息，对于 Pod 来说，输出中包含了节点名称</td>
</tr>
<tr>
<td><code>-o=yaml</code></td>
<td>输出 YAML 格式的 API 对象</td>
</tr>
</tbody>
</table>
<p>使用 <code>-o=custom-columns</code> 的示例：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 集群中运行着的所有镜像</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[*].image&#39;</span>

<span style=color:#080;font-style:italic># 列举 default 名字空间中运行的所有镜像，按 Pod 分组</span>
kubectl get pods --namespace default --output<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#34;NAME:.metadata.name,IMAGE:.spec.containers[*].image&#34;</span>

<span style=color:#080;font-style:italic># 除 &#34;k8s.gcr.io/coredns:1.6.2&#34; 之外的所有镜像</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[?(@.image!=&#34;k8s.gcr.io/coredns:1.6.2&#34;)].image&#39;</span>

<span style=color:#080;font-style:italic># 输出 metadata 下面的所有字段，无论 Pod 名字为何</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:metadata.*&#39;</span>
</code></pre></div><p>有关更多示例，请参看 kubectl <a href=/zh/docs/reference/kubectl/overview/#custom-columns>参考文档</a>。</p>
<h3 id=kubectl-日志输出详细程度和调试>Kubectl 日志输出详细程度和调试</h3>
<p>Kubectl 日志输出详细程度是通过 <code>-v</code> 或者 <code>--v</code> 来控制的，参数后跟一个数字表示日志的级别。
Kubernetes 通用的日志习惯和相关的日志级别在
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>这里</a> 有相应的描述。</p>
<table>
<thead>
<tr>
<th>详细程度</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--v=0</code></td>
<td>用于那些应该 <em>始终</em> 对运维人员可见的信息，因为这些信息一般很有用。</td>
</tr>
<tr>
<td><code>--v=1</code></td>
<td>如果您不想要看到冗余信息，此值是一个合理的默认日志级别。</td>
</tr>
<tr>
<td><code>--v=2</code></td>
<td>输出有关服务的稳定状态的信息以及重要的日志消息，这些信息可能与系统中的重大变化有关。这是建议大多数系统设置的默认日志级别。</td>
</tr>
<tr>
<td><code>--v=3</code></td>
<td>包含有关系统状态变化的扩展信息。</td>
</tr>
<tr>
<td><code>--v=4</code></td>
<td>包含调试级别的冗余信息。</td>
</tr>
<tr>
<td><code>--v=5</code></td>
<td>跟踪级别的详细程度。</td>
</tr>
<tr>
<td><code>--v=6</code></td>
<td>显示所请求的资源。</td>
</tr>
<tr>
<td><code>--v=7</code></td>
<td>显示 HTTP 请求头。</td>
</tr>
<tr>
<td><code>--v=8</code></td>
<td>显示 HTTP 请求内容。</td>
</tr>
<tr>
<td><code>--v=9</code></td>
<td>显示 HTTP 请求内容而且不截断内容。</td>
</tr>
</tbody>
</table>
<h2 id=接下来>接下来</h2>
<ul>
<li>参阅 <a href=/zh/docs/reference/kubectl/overview/>kubectl 概述</a>，进一步了解<a href=/zh/docs/reference/kubectl/jsonpath>JsonPath</a>。</li>
<li>参阅 <a href=/zh/docs/reference/kubectl/kubectl/>kubectl</a> 选项。</li>
<li>参阅 <a href=/zh/docs/reference/kubectl/conventions/>kubectl 使用约定</a>来理解如何在可复用的脚本中使用它。</li>
<li>查看社区中其他的 <a href=https://github.com/dennyzhang/cheatsheet-kubernetes-A4>kubectl 备忘单</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8de6aceb8bf692c06cced446bac5bc92>9.6 - kubectl 的用法约定</h1>
<p><code>kubectl</code> 的推荐用法约定。</p>
<h2 id=在可重用脚本中使用-kubectl>在可重用脚本中使用 <code>kubectl</code></h2>
<p>对于脚本中的稳定输出：</p>
<ul>
<li>请求一个面向机器的输出格式，例如 <code>-o name</code>、<code>-o json</code>、<code>-o yaml</code>、<code>-o go template</code> 或 <code>-o jsonpath</code>。</li>
<li>完全限定版本。例如 <code>jobs.v1.batch/myjob</code>。这将确保 kubectl 不会使用其默认版本，该版本会随着时间的推移而更改。</li>
<li>不要依赖上下文、首选项或其他隐式状态。</li>
</ul>
<h2 id=最佳实践>最佳实践</h2>
<h3 id=kubectl-run><code>kubectl run</code></h3>
<p>若希望 <code>kubectl run</code> 满足基础设施即代码的要求：</p>
<ul>
<li>使用特定版本的标签标记镜像，不要将该标签移动到新版本。例如，使用 <code>:v1234</code>、<code>v1.2.3</code>、<code>r03062016-1-4</code>，而不是 <code>:latest</code>（有关详细信息，请参阅<a href=/zh/docs/concepts/configuration/overview/#container-images>配置的最佳实践</a>)。</li>
<li>使用基于版本控制的脚本来运行包含大量参数的镜像。</li>
<li>对于无法通过 <code>kubectl run</code> 参数来表示的功能特性，使用基于源码控制的配置文件，以记录要使用的功能特性。</li>
</ul>
<p>你可以使用 <code>--dry-run=client</code> 参数来预览而不真正提交即将下发到集群的对象实例：</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>所有的 <code>kubectl run</code> 生成器已弃用。
查阅 Kubernetes v1.17 文档中的生成器<a href=https://v1-17.docs.kubernetes.io/docs/reference/kubectl/conventions/#generators>列表</a>以及它们的用法。
</div>
<h4 id=生成器>生成器</h4>
<p>你可以使用 kubectl 命令生成以下资源， <code>kubectl create --dry-run=client -o yaml</code>：</p>
<ul>
<li><code>clusterrole</code>: 创建 ClusterRole。</li>
<li><code>clusterrolebinding</code>: 为特定的 ClusterRole 创建 ClusterRoleBinding。</li>
<li><code>configmap</code>: 使用本地文件、目录或文本值创建 Configmap。</li>
<li><code>cronjob</code>: 使用指定的名称创建 Cronjob。</li>
<li><code>deployment</code>: 使用指定的名称创建 Deployment。</li>
<li><code>job</code>: 使用指定的名称创建 Job。</li>
<li><code>namespace</code>: 使用指定的名称创建名称空间。</li>
<li><code>poddisruptionbudget</code>: 使用指定名称创建 Pod 干扰预算。</li>
<li><code>priorityclass</code>: 使用指定的名称创建 Priorityclass。</li>
<li><code>quota</code>: 使用指定的名称创建配额。</li>
<li><code>role</code>: 使用单一规则创建角色。</li>
<li><code>rolebinding</code>: 为特定角色或 ClusterRole 创建 RoleBinding。</li>
<li><code>secret</code>: 使用指定的子命令创建 Secret。</li>
<li><code>service</code>: 使用指定的子命令创建服务。</li>
<li><code>serviceaccount</code>: 使用指定的名称创建服务帐户。</li>
</ul>
<h3 id=kubectl-apply><code>kubectl apply</code></h3>
<ul>
<li>您可以使用 <code>kubectl apply</code> 命令创建或更新资源。有关使用 kubectl apply 更新资源的详细信息，请参阅 <a href=https://kubectl.docs.kubernetes.io>Kubectl 文档</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a7abc09192597e614b58f8b552b682f5>9.7 - 适用于 Docker 用户的 kubectl</h1>
<p>您可以使用 Kubernetes 命令行工具 <code>kubectl</code> 与 API 服务器进行交互。如果您熟悉 Docker 命令行工具，则使用 kubectl 非常简单。但是，Docker 命令和 kubectl 命令之间有一些区别。以下显示了 Docker 子命令，并描述了等效的 <code>kubectl</code> 命令。</p>
<h2 id=docker-run>docker run</h2>
<p>要运行 nginx 部署并将其暴露，请参见<a href=/docs/reference/generated/kubectl/kubectl-commands#-em-deployment-em->kubectl create deployment</a>
docker:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker run -d --restart<span style=color:#666>=</span>always -e <span style=color:#b8860b>DOMAIN</span><span style=color:#666>=</span>cluster --name nginx-app -p 80:80 nginx
</code></pre></div><pre><code>55c103fa129692154a7652490236fee9be47d70a8dd562281ae7d2f9a339a6db
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   9 seconds ago       Up 9 seconds        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><p>kubectl:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 启动运行 nginx 的 Pod</span>
kubectl create deployment --image<span style=color:#666>=</span>nginx nginx-app
</code></pre></div><pre><code>deployment.apps/nginx-app created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># add env to nginx-app</span>
kubectl <span style=color:#a2f>set</span> env deployment/nginx-app  <span style=color:#b8860b>DOMAIN</span><span style=color:#666>=</span>cluster
</code></pre></div><pre><code>deployment.apps/nginx-app env updated
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p><code>kubectl</code> 命令打印创建或突变资源的类型和名称，然后可以在后续命令中使用。部署后，您可以公开新服务。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 通过服务公开端口</span>
kubectl expose deployment nginx-app --port<span style=color:#666>=</span><span style=color:#666>80</span> --name<span style=color:#666>=</span>nginx-http
</code></pre></div><pre><code>service &quot;nginx-http&quot; exposed
</code></pre>
<p>在 kubectl 命令中，我们创建了一个 <a href=/zh/docs/concepts/workloads/controllers/deployment/>Deployment</a>，这将保证有 N 个运行 nginx 的 pod(N 代表 spec 中声明的 replica 数，默认为 1)。我们还创建了一个 <a href=/zh/docs/concepts/services-networking/service/>service</a>，其选择器与容器标签匹配。查看<a href=/zh/docs/tasks/access-application-cluster/service-access-application-cluster>使用服务访问群集中的应用程序</a> 获取更多信息。</p>
<p>默认情况下镜像会在后台运行，与 <code>docker run -d ...</code> 类似，如果您想在前台运行，使用 <a href=/docs/reference/generated/kubectl/kubectl-commands/#run><code>kubectl run</code></a> 在前台运行 Pod:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run <span style=color:#666>[</span>-i<span style=color:#666>]</span> <span style=color:#666>[</span>--tty<span style=color:#666>]</span> --attach &lt;name&gt; --image<span style=color:#666>=</span>&lt;image&gt;
</code></pre></div>
<p>与 <code>docker run ...</code> 不同的是，如果指定了 <code>--attach</code> ，我们将连接到 <code>stdin</code>，<code>stdout</code> 和 <code>stderr</code>，而不能控制具体连接到哪个输出流（<code>docker -a ...</code>）。要从容器中退出，可以输入 Ctrl + P，然后按 Ctrl + Q。</p>
<p>因为我们使用 Deployment 启动了容器，如果您终止连接到的进程（例如 <code>ctrl-c</code>），容器将会重启，这跟 <code>docker run -it</code> 不同。
如果想销毁该 Deployment（和它的 pod），您需要运行 <code>kubectl delete deployment &lt;name></code>。</p>
<h2 id=docker-ps>docker ps</h2>
<p>如何列出哪些正在运行？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#get>kubectl get</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps -a
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                     PORTS                NAMES
14636241935f        ubuntu:16.04        &quot;echo test&quot;              5 seconds ago        Exited (0) 5 seconds ago                        cocky_fermi
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   About a minute ago   Up About a minute          0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po
</code></pre></div><pre><code>NAME                        READY     STATUS      RESTARTS   AGE
nginx-app-8df569cb7-4gd89   1/1       Running     0          3m
ubuntu                      0/1       Completed   0          20s
</code></pre><h2 id=docker-attach>docker attach</h2>
<p>如何连接到已经运行在容器中的进程？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#attach>kubectl attach</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   5 minutes ago       Up 5 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker attach 55c103fa1296
...
</code></pre></div><p>kubectl:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl attach -it nginx-app-5jyvm
...
</code></pre></div>
<p>要从容器中分离，可以输入 Ctrl + P，然后按 Ctrl + Q。</p>
<h2 id=docker-exec>docker exec</h2>
<p>如何在容器中执行命令？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &quot;nginx -g 'daemon of…&quot;   6 minutes ago       Up 6 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker <span style=color:#a2f>exec</span> 55c103fa1296 cat /etc/hostname
</code></pre></div><pre><code>55c103fa1296
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po
</code></pre></div><pre><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> nginx-app-5jyvm -- cat /etc/hostname
</code></pre></div><pre><code>nginx-app-5jyvm
</code></pre>
<p>执行交互式命令怎么办？</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker <span style=color:#a2f>exec</span> -ti 55c103fa1296 /bin/sh
<span style=color:#080;font-style:italic># exit</span>
</code></pre></div><p>kubectl:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -ti nginx-app-5jyvm -- /bin/sh      
<span style=color:#080;font-style:italic># exit</span>
</code></pre></div>
<p>更多信息请查看<a href=/zh/docs/tasks/debug-application-cluster/get-shell-running-container/>获取运行中容器的 Shell 环境</a>。</p>
<h2 id=docker-logs>docker logs</h2>
<p>如何查看运行中进程的 stdout/stderr？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#logs>kubectl logs</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker logs -f a9e
</code></pre></div><pre><code>192.168.9.1 - - [14/Jul/2015:01:04:02 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.35.0&quot; &quot;-&quot;
192.168.9.1 - - [14/Jul/2015:01:04:03 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.35.0&quot; &quot;-&quot;
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs -f nginx-app-zibvs
</code></pre></div><pre><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
</code></pre>
<p>现在是时候提一下 pod 和容器之间的细微差别了；默认情况下如果 pod 中的进程退出 pod 也不会终止，相反它将会重启该进程。这类似于 docker run 时的 <code>--restart=always</code> 选项， 这是主要差别。在 docker 中，进程的每个调用的输出都是被连接起来的，但是对于 kubernetes，每个调用都是分开的。要查看以前在 kubernetes 中执行的输出，请执行以下操作：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs --previous nginx-app-zibvs
</code></pre></div><pre><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.26.0&quot; &quot;-&quot;
</code></pre>
<p>查看<a href=/zh/docs/concepts/cluster-administration/logging/>日志架构</a>获取更多信息。</p>
<h2 id=docker-stop-and-docker-rm>docker stop and docker rm</h2>
<p>如何停止和删除运行中的进程？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#delete>kubectl delete</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                         NAMES
a9ec34d98787        nginx               &quot;nginx -g 'daemon of&quot;  22 hours ago        Up 22 hours         0.0.0.0:80-&gt;80/tcp, 443/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker stop a9ec34d98787
</code></pre></div><pre><code>a9ec34d98787
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker rm a9ec34d98787
</code></pre></div><pre><code>a9ec34d98787
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment nginx-app
</code></pre></div><pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
nginx-app    1/1     1            1           2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx-app
</code></pre></div><pre><code>NAME                         READY     STATUS    RESTARTS   AGE
nginx-app-2883164633-aklf7   1/1       Running   0          2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment nginx-app
</code></pre></div><pre><code>deployment &quot;nginx-app&quot; deleted
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get po -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx-app
<span style=color:#080;font-style:italic># Return nothing</span>
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>请注意，我们不直接删除 pod。使用 kubectl 命令，我们要删除拥有该 pod 的 Deployment。如果我们直接删除 pod，Deployment 将会重新创建该 pod。
</div>
<h2 id=docker-login>docker login</h2>
<p>在 kubectl 中没有对 <code>docker login</code> 的直接模拟。如果您有兴趣在私有镜像仓库中使用 Kubernetes，请参阅<a href=/zh/docs/concepts/containers/images/#using-a-private-registry>使用私有镜像仓库</a>。</p>
<h2 id=docker-version>docker version</h2>
<p>如何查看客户端和服务端的版本？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#version>kubectl version</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker version
</code></pre></div><pre><code>Client version: 1.7.0
Client API version: 1.19
Go version (client): go1.4.2
Git commit (client): 0baf609
OS/Arch (client): linux/amd64
Server version: 1.7.0
Server API version: 1.19
Go version (server): go1.4.2
Git commit (server): 0baf609
OS/Arch (server): linux/amd64
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl version
</code></pre></div><pre><code>Client Version: version.Info{Major:&quot;1&quot;, Minor:&quot;6&quot;, GitVersion:&quot;v1.6.9+a3d1dfa6f4335&quot;, GitCommit:&quot;9b77fed11a9843ce3780f70dd251e92901c43072&quot;, GitTreeState:&quot;dirty&quot;, BuildDate:&quot;2017-08-29T20:32:58Z&quot;, OpenPaasKubernetesVersion:&quot;v1.03.02&quot;, GoVersion:&quot;go1.7.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;}
Server Version: version.Info{Major:&quot;1&quot;, Minor:&quot;6&quot;, GitVersion:&quot;v1.6.9+a3d1dfa6f4335&quot;, GitCommit:&quot;9b77fed11a9843ce3780f70dd251e92901c43072&quot;, GitTreeState:&quot;dirty&quot;, BuildDate:&quot;2017-08-29T20:32:58Z&quot;, OpenPaasKubernetesVersion:&quot;v1.03.02&quot;, GoVersion:&quot;go1.7.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;}
</code></pre><h2 id=docker-info>docker info</h2>
<p>如何获取有关环境和配置的各种信息？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#cluster-info>kubectl cluster-info</a>。</p>
<p>使用 docker 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker info
</code></pre></div><pre><code>Containers: 40
Images: 168
Storage Driver: aufs
 Root Dir: /usr/local/google/docker/aufs
 Backing Filesystem: extfs
 Dirs: 248
 Dirperm1 Supported: false
Execution Driver: native-0.2
Logging Driver: json-file
Kernel Version: 3.13.0-53-generic
Operating System: Ubuntu 14.04.2 LTS
CPUs: 12
Total Memory: 31.32 GiB
Name: k8s-is-fun.mtv.corp.google.com
ID: ADUV:GCYR:B3VJ:HMPO:LNPQ:KD5S:YKFQ:76VN:IANZ:7TFV:ZBF4:BYJO
WARNING: No swap limit support
</code></pre>
<p>使用 kubectl 命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info
</code></pre></div><pre><code>Kubernetes master is running at https://108.59.85.141
KubeDNS is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/kube-dns/proxy
kubernetes-dashboard is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy
Grafana is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy
Heapster is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/monitoring-heapster/proxy
InfluxDB is running at https://108.59.85.141/api/v1/namespaces/kube-system/services/monitoring-influxdb/proxy
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-54e562dd1441d0195970a6526b0055cc>10 - 组件工具</h1>
</div>
<div class=td-content>
<h1 id=pg-ca5d01a42c486d535539d3038aa67eb9>10.1 - 特性门控</h1>
<p>本页详述了管理员可以在不同的 Kubernetes 组件上指定的各种特性门控。</p>
<p>关于特性各个阶段的说明，请参见<a href=#feature-stages>特性阶段</a>。</p>
<h2 id=概述>概述</h2>
<p>特性门控是描述 Kubernetes 特性的一组键值对。你可以在 Kubernetes 的各个组件中使用
<code>--feature-gates</code> flag 来启用或禁用这些特性。</p>
<p>每个 Kubernetes 组件都支持启用或禁用与该组件相关的一组特性门控。
使用 <code>-h</code> 参数来查看所有组件支持的完整特性门控。
要为诸如 kubelet 之类的组件设置特性门控，请使用 <code>--feature-gates</code> 参数，并向其
传递一个特性设置键值对列表：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--feature-gates<span style=color:#666>=</span><span style=color:#b44>&#34;...,GracefulNodeShutdown=true&#34;</span>
</code></pre></div>
<p>下表总结了在不同的 Kubernetes 组件上可以设置的特性门控。</p>
<ul>
<li>引入特性或更改其发布阶段后，"开始（Since）" 列将包含 Kubernetes 版本。</li>
<li>"结束（Until）" 列（如果不为空）包含最后一个 Kubernetes 版本，你仍可以在其中使用特性门控。</li>
<li>如果某个特性处于 Alpha 或 Beta 状态，你可以在
<a href=#feature-gates-for-alpha-or-beta-features>Alpha 和 Beta 特性门控表</a>中找到该特性。</li>
<li>如果某个特性处于稳定状态，你可以在
<a href=#feature-gates-for-graduated-or-deprecated-features>已毕业和废弃特性门控表</a>
中找到该特性的所有阶段。</li>
<li><a href=#feature-gates-for-graduated-or-deprecated-features>已毕业和废弃特性门控表</a>
还列出了废弃的和已被移除的特性。</li>
</ul>
<h3 id=feature-gates-for-alpha-or-beta-features>Alpha 和 Beta 状态的特性门控 </h3>
<table><caption style=display:none>处于 Alpha 或 Beta 状态的特性门控</caption>
<thead>
<tr>
<th>特性</th>
<th>默认值</th>
<th>状态</th>
<th>开始（Since）</th>
<th>结束（Until）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>APIListChunking</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>APIListChunking</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.9</td>
<td></td>
</tr>
<tr>
<td><code>APIPriorityAndFairness</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.19</td>
</tr>
<tr>
<td><code>APIPriorityAndFairness</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>APIResponseCompression</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.15</td>
</tr>
<tr>
<td><code>APIResponseCompression</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>APIServerIdentity</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>APIServerTracing</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>AllowInsecureBackendProxy</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>AnyVolumeDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>AppArmor</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.4</td>
<td></td>
</tr>
<tr>
<td><code>ControllerManagerLeaderMigration</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>CPUManager</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CPUManager</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>CPUManagerPolicyOptions</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>CSIInlineVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CSIInlineVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigration</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSIMigration</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAWS</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAWS</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAzureDisk</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.18</td>
</tr>
<tr>
<td><code>CSIMigrationAzureDisk</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.19</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAzureFile</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.19</td>
</tr>
<tr>
<td><code>CSIMigrationAzureFile</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationGCE</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSIMigrationGCE</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationOpenStack</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.17</td>
</tr>
<tr>
<td><code>CSIMigrationOpenStack</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationvSphere</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.19</td>
<td></td>
</tr>
<tr>
<td><code>CSIStorageCapacity</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIStorageCapacity</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>CSIVolumeFSGroupPolicy</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>CSIVolumeFSGroupPolicy</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>CSIVolumeHealth</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>CSRDuration</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ConfigurableFSGroupPolicy</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.19</td>
</tr>
<tr>
<td><code>ConfigurableFSGroupPolicy</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>ControllerManagerLeaderMigration</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ControllerManagerLeaderMigration</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>CustomCPUCFSQuotaPeriod</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>DaemonSetUpdateSurge</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>DaemonSetUpdateSurge</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>DefaultPodTopologySpread</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>DefaultPodTopologySpread</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>DelegateFSGroupToCSIDriver</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>DevicePlugins</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>DevicePlugins</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>DisableAcceleratorUsageMetrics</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>DisableAcceleratorUsageMetrics</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>DisableCloudProviders</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>DownwardAPIHugePages</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>DownwardAPIHugePages</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>EfficientWatchResumption</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>EfficientWatchResumption</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>EndpointSliceTerminatingCondition</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.21</td>
</tr>
<tr>
<td><code>EndpointSliceTerminatingCondition</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>EphemeralContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>ExpandCSIVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ExpandCSIVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>ExpandedDNSConfig</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ExpandInUsePersistentVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.14</td>
</tr>
<tr>
<td><code>ExpandInUsePersistentVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>ExpandPersistentVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.10</td>
</tr>
<tr>
<td><code>ExpandPersistentVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>ExperimentalHostUserNamespaceDefaulting</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.5</td>
<td></td>
</tr>
<tr>
<td><code>GenericEphemeralVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>GenericEphemeralVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>GracefulNodeShutdown</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>GracefulNodeShutdown</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>HPAContainerMetrics</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>HPAScaleToZero</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>IndexedJob</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>IndexedJob</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>IngressClassNamespacedParams</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>IngressClassNamespacedParams</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginAWSUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginAzureDiskUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginAzureFileUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginGCEUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginOpenStackUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>InTreePluginvSphereUnregister</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>IPv6DualStack</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.20</td>
</tr>
<tr>
<td><code>IPv6DualStack</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>JobTrackingWithFinalizers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>KubeletCredentialProviders</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>KubeletInUserNamespace</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>KubeletPodResourcesGetAllocatable</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.9</td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolationFSQuotaMonitoring</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>LogarithmicScaleDown</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>LogarithmicScaleDown</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>MemoryManager</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>MemoryManager</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>MemoryQoS</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>MixedProtocolLBService</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>NetworkPolicyEndPort</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>NetworkPolicyEndPort</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>NodeSwap</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>NonPreemptingPriority</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.18</td>
</tr>
<tr>
<td><code>NonPreemptingPriority</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td></td>
</tr>
<tr>
<td><code>PodDeletionCost</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>PodDeletionCost</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>PodAffinityNamespaceSelector</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>PodAffinityNamespaceSelector</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>PodOverhead</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>PodOverhead</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>PodSecurity</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>PreferNominatedNode</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>PreferNominatedNode</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ProbeTerminationGracePeriod</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ProbeTerminationGracePeriod</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ProcMountType</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>ProxyTerminatingEndpoints</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>QOSReserved</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>ReadWriteOncePod</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>RemainingItemCount</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>RemainingItemCount</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>RemoveSelfLink</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.19</td>
</tr>
<tr>
<td><code>RemoveSelfLink</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>RotateKubeletServerCertificate</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.11</td>
</tr>
<tr>
<td><code>RotateKubeletServerCertificate</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>SeccompDefault</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ServiceInternalTrafficPolicy</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ServiceInternalTrafficPolicy</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ServiceLBNodePortControl</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ServiceLBNodePortControl</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>ServiceLoadBalancerClass</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerClass</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>SizeMemoryBackedVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.21</td>
</tr>
<tr>
<td><code>SizeMemoryBackedVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>StatefulSetMinReadySeconds</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>StorageVersionAPI</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>StorageVersionHash</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>StorageVersionHash</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>SuspendJob</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>SuspendJob</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>TTLAfterFinished</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.20</td>
</tr>
<tr>
<td><code>TTLAfterFinished</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>TopologyAwareHints</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>TopologyManager</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>TopologyManager</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>VolumeCapacityPriority</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>WinDSR</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>WinOverlay</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.19</td>
</tr>
<tr>
<td><code>WinOverlay</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>WindowsHostProcessContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id=feature-gates-for-graduated-or-deprecated-features>已毕业和已废弃的特性门控 </h3>
<table><caption style=display:none>已毕业或不推荐使用的特性门控</caption>
<thead>
<tr>
<th>特性</th>
<th>默认值</th>
<th>状态</th>
<th>开始（Since）</th>
<th>结束（Until）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Accelerators</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.10</td>
</tr>
<tr>
<td><code>Accelerators</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.7</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.8</td>
<td>1.11</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>AffinityInAnnotations</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.7</td>
</tr>
<tr>
<td><code>AffinityInAnnotations</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.8</td>
<td>-</td>
</tr>
<tr>
<td><code>AllowExtTrafficLocalEndpoints</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.4</td>
<td>1.6</td>
</tr>
<tr>
<td><code>AllowExtTrafficLocalEndpoints</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.7</td>
<td>-</td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>BalanceAttachedNodeVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.21</td>
</tr>
<tr>
<td><code>BalanceAttachedNodeVolumes</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.12</td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td>1.17</td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>BoundServiceAccountTokenVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.20</td>
</tr>
<tr>
<td><code>BoundServiceAccountTokenVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>BoundServiceAccountTokenVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>CRIContainerLogRotation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>CRIContainerLogRotation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CRIContainerLogRotation</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.17</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.17</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAWSComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationAWSComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationAzureDiskComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationAzureDiskComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationAzureFileComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationAzureFileComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationGCEComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationGCEComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationOpenStackComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIMigrationOpenStackComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigrationvSphereComplete</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.21</td>
</tr>
<tr>
<td><code>CSIMigrationvSphereComplete</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIServiceAccountToken</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CSIServiceAccountToken</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>CSIServiceAccountToken</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>CronJobControllerV2</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>CronJobControllerV2</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>CronJobControllerV2</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceDefaulting</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceDefaulting</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CustomResourceDefaulting</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.9</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.14</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>DryRun</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.12</td>
</tr>
<tr>
<td><code>DryRun</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td>1.18</td>
</tr>
<tr>
<td><code>DryRun</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicAuditing</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.18</td>
</tr>
<tr>
<td><code>DynamicAuditing</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.4</td>
<td>1.10</td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.21</td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicProvisioningScheduling</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>DynamicProvisioningScheduling</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicVolumeProvisioning</code></td>
<td><code>true</code></td>
<td>Alpha</td>
<td>1.3</td>
<td>1.7</td>
</tr>
<tr>
<td><code>DynamicVolumeProvisioning</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.8</td>
<td>-</td>
</tr>
<tr>
<td><code>EnableAggregatedDiscoveryTimeout</code></td>
<td><code>true</code></td>
<td>Deprecated</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>EnableEquivalenceClassCache</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.14</td>
</tr>
<tr>
<td><code>EnableEquivalenceClassCache</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.15</td>
<td>-</td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td>1.17</td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td>1.20</td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>EndpointSliceNodeName</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>EndpointSliceNodeName</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>EndpointSliceProxying</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>EndpointSliceProxying</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.21</td>
</tr>
<tr>
<td><code>EndpointSliceProxying</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>ExperimentalCriticalPodAnnotation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.5</td>
<td>1.12</td>
</tr>
<tr>
<td><code>ExperimentalCriticalPodAnnotation</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>EvenPodsSpread</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>EvenPodsSpread</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>EvenPodsSpread</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>ExecProbeTimeout</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ExternalPolicyForExternalIP</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>GCERegionalPersistentDisk</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>GCERegionalPersistentDisk</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.21</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.21</td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>HyperVContainer</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.19</td>
</tr>
<tr>
<td><code>HyperVContainer</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ImmutableEphemeralVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>ImmutableEphemeralVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>ImmutableEphemeralVolumes</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>Initializers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.13</td>
</tr>
<tr>
<td><code>Initializers</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>KubeletConfigFile</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>KubeletConfigFile</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.10</td>
<td>-</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.12</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>KubeletPodResources</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.14</td>
</tr>
<tr>
<td><code>KubeletPodResources</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>KubeletPodResources</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td></td>
</tr>
<tr>
<td><code>LegacyNodeRoleBehavior</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.18</td>
</tr>
<tr>
<td><code>LegacyNodeRoleBehavior</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>LegacyNodeRoleBehavior</code></td>
<td><code>false</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>MountContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.16</td>
</tr>
<tr>
<td><code>MountContainers</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>NodeDisruptionExclusion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.18</td>
</tr>
<tr>
<td><code>NodeDisruptionExclusion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>NodeDisruptionExclusion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>NamespaceDefaultLabelName</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>NamespaceDefaultLabelName</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>PVCProtection</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>PVCProtection</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.10</td>
<td>-</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.9</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodDisruptionBudget</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.3</td>
<td>1.4</td>
</tr>
<tr>
<td><code>PodDisruptionBudget</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.5</td>
<td>1.20</td>
</tr>
<tr>
<td><code>PodDisruptionBudget</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.10</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>RequestManagement</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.16</td>
</tr>
<tr>
<td><code>RequestManagement</code></td>
<td>-</td>
<td>Derecated</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>ResourceLimitsPriorityFunction</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.18</td>
</tr>
<tr>
<td><code>ResourceLimitsPriorityFunction</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>RootCAConfigMap</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.19</td>
</tr>
<tr>
<td><code>RootCAConfigMap</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>RootCAConfigMap</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>RotateKubeletClientCertificate</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.8</td>
<td>1.18</td>
</tr>
<tr>
<td><code>RotateKubeletClientCertificate</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.19</td>
<td>-</td>
</tr>
<tr>
<td><code>RunAsGroup</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.20</td>
</tr>
<tr>
<td><code>RunAsGroup</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>RuntimeClass</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>RuntimeClass</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.19</td>
</tr>
<tr>
<td><code>RuntimeClass</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>SCTPSupport</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.18</td>
</tr>
<tr>
<td><code>SCTPSupport</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SCTPSupport</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>SelectorIndex</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>SelectorIndex</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SelectorIndex</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ServerSideApply</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ServerSideApply</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ServerSideApply</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceAccountIssuerDiscovery</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.19</td>
</tr>
<tr>
<td><code>ServiceAccountIssuerDiscovery</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td>1.20</td>
</tr>
<tr>
<td><code>ServiceAccountIssuerDiscovery</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceAppProtocol</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td>1.18</td>
</tr>
<tr>
<td><code>ServiceAppProtocol</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>ServiceAppProtocol</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceNodeExclusion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.18</td>
</tr>
<tr>
<td><code>ServiceNodeExclusion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>ServiceNodeExclusion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceTopology</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td>1.19</td>
</tr>
<tr>
<td><code>ServiceTopology</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>SetHostnameAsFQDN</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SetHostnameAsFQDN</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.20</td>
<td>1.21</td>
</tr>
<tr>
<td><code>SetHostnameAsFQDN</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>StartupProbe</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>StartupProbe</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td>1.19</td>
</tr>
<tr>
<td><code>StartupProbe</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>StorageObjectInUseProtection</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>StorageObjectInUseProtection</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.5</td>
<td>1.5</td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.6</td>
<td>1.17</td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>true</code></td>
<td>Deprecated</td>
<td>1.18</td>
<td>1.21</td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>SupportNodePidsLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>SupportNodePidsLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SupportNodePidsLimit</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>SupportPodPidsLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>SupportPodPidsLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.19</td>
</tr>
<tr>
<td><code>SupportPodPidsLimit</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>Sysctls</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.20</td>
</tr>
<tr>
<td><code>Sysctls</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.12</td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td>1.17</td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>TokenRequest</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TokenRequest</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.19</td>
</tr>
<tr>
<td><code>TokenRequest</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>TokenRequestProjection</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TokenRequestProjection</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.19</td>
</tr>
<tr>
<td><code>TokenRequestProjection</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>ValidateProxyRedirects</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>ValidateProxyRedirects</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.21</td>
</tr>
<tr>
<td><code>ValidateProxyRedirects</code></td>
<td><code>true</code></td>
<td>Deprecated</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeSnapshotDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>VolumeSnapshotDataSource</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td>1.19</td>
</tr>
<tr>
<td><code>VolumeSnapshotDataSource</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.20</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeSubpath</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.10</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.16</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>WarningHeaders</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.19</td>
<td>1.21</td>
</tr>
<tr>
<td><code>WarningHeaders</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsEndpointSliceProxying</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.19</td>
<td>1.20</td>
</tr>
<tr>
<td><code>WindowsEndpointSliceProxying</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td>1.21</td>
</tr>
<tr>
<td><code>WindowsEndpointSliceProxying</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.22</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsHostProcessContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.22</td>
<td></td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td>1.17</td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id=using-a-feature>使用特性 </h2>
<h3 id=feature-stages>特性阶段 </h3>
<p>处于 <em>Alpha</em> 、<em>Beta</em> 、 <em>GA</em> 阶段的特性。</p>
<p><em>Alpha</em> 特性代表：</p>
<ul>
<li>默认禁用。</li>
<li>可能有错误，启用此特性可能会导致错误。</li>
<li>随时可能删除对此特性的支持，恕不另行通知。</li>
<li>在以后的软件版本中，API 可能会以不兼容的方式更改，恕不另行通知。</li>
<li>建议将其仅用于短期测试中，因为开启特性会增加错误的风险，并且缺乏长期支持。</li>
</ul>
<p><em>Beta</em> 特性代表：</p>
<ul>
<li>默认启用。</li>
<li>该特性已经经过良好测试。启用该特性是安全的。</li>
<li>尽管详细信息可能会更改，但不会放弃对整体特性的支持。</li>
<li>对象的架构或语义可能会在随后的 Beta 或稳定版本中以不兼容的方式更改。当发生这种情况时，我们将提供迁移到下一版本的说明。此特性可能需要删除、编辑和重新创建 API 对象。编辑过程可能需要慎重操作，因为这可能会导致依赖该特性的应用程序停机。</li>
<li>推荐仅用于非关键业务用途，因为在后续版本中可能会发生不兼容的更改。如果你具有多个可以独立升级的，则可以放宽此限制。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>请试用 <em>Beta</em> 特性并提供相关反馈！
一旦特性结束 Beta 状态，我们就不太可能再对特性进行大幅修改。
</div>
<p><em>General Availability</em> (GA) 特性也称为 <em>稳定</em> 特性，<em>GA</em> 特性代表着：</p>
<ul>
<li>此特性会一直启用；你不能禁用它。</li>
<li>不再需要相应的特性门控。</li>
<li>对于许多后续版本，特性的稳定版本将出现在发行的软件中。</li>
</ul>
<h3 id=特性门控列表>特性门控列表</h3>
<p>每个特性门控均用于启用或禁用某个特定的特性：</p>
<ul>
<li><code>APIListChunking</code>：启用 API 客户端以块的形式从 API 服务器检索（“LIST” 或 “GET”）资源。</li>
<li><code>APIPriorityAndFairness</code>: 在每个服务器上启用优先级和公平性来管理请求并发。（由 <code>RequestManagement</code> 重命名而来）</li>
<li><code>APIResponseCompression</code>：压缩 “LIST” 或 “GET” 请求的 API 响应。</li>
<li><code>APIServerIdentity</code>：为集群中的每个 API 服务器赋予一个 ID。</li>
<li><code>APIServerTracing</code>: 为集群中的每个 API 服务器添加对分布式跟踪的支持。</li>
</ul>
<ul>
<li><code>Accelerators</code>：使用 Docker 时启用 Nvidia GPU 支持。</li>
<li><code>AdvancedAuditing</code>：启用<a href=/zh/docs/tasks/debug-application-cluster/audit/#advanced-audit>高级审计功能</a>。</li>
<li><code>AffinityInAnnotations</code>：启用 <a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity>Pod 亲和或反亲和</a>。</li>
<li><code>AllowExtTrafficLocalEndpoints</code>：启用服务用于将外部请求路由到节点本地终端。</li>
<li><code>AllowInsecureBackendProxy</code>：允许用户在执行 Pod 日志访问请求时跳过 TLS 验证。</li>
<li><code>AnyVolumeDataSource</code>: 允许使用任何自定义的资源来做作为
<a class=glossary-tooltip title=声明在持久卷中定义的存储资源，以便可以将其挂载为容器中的卷。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PVC>PVC</a> 中的 <code>DataSource</code>.</li>
<li><code>AppArmor</code>：使用 Docker 时，在 Linux 节点上启用基于 AppArmor 机制的强制访问控制。
请参见 <a href=/zh/docs/tutorials/clusters/apparmor/>AppArmor 教程</a> 获取详细信息。</li>
</ul>
<ul>
<li><code>AttachVolumeLimit</code>：启用卷插件用于报告可连接到节点的卷数限制。有关更多详细信息，请参阅
<a href=/zh/docs/concepts/storage/storage-limits/#dynamic-volume-limits>动态卷限制</a>。</li>
<li><code>BalanceAttachedNodeVolumes</code>：在进行平衡资源分配的调度时，考虑节点上的卷数。
调度器在决策时会优先考虑 CPU、内存利用率和卷数更近的节点。</li>
<li><code>BlockVolume</code>：在 Pod 中启用原始块设备的定义和使用。有关更多详细信息，请参见
<a href=/zh/docs/concepts/storage/persistent-volumes/#raw-block-volume-support>原始块卷支持</a>。</li>
<li><code>BoundServiceAccountTokenVolume</code>：迁移 ServiceAccount 卷以使用由
ServiceAccountTokenVolumeProjection 组成的投射卷。集群管理员可以使用
<code>serviceaccount_stale_tokens_total</code> 度量值来监控依赖于扩展令牌的负载。
如果没有这种类型的负载，你可以在启动 <code>kube-apiserver</code> 时添加
<code>--service-account-extend-token-expiration=false</code> 参数关闭扩展令牌。查看
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-auth/1205-bound-service-account-tokens/README.md>绑定服务账号令牌</a>
获取更多详细信息。</li>
<li><code>ControllerManagerLeaderMigration</code>: 为
<a href=/zh/docs/tasks/administer-cluster/controller-manager-leader-migration/#initial-leader-migration-configuration>kube-controller-manager</a> 和
<a href=/zh/docs/tasks/administer-cluster/controller-manager-leader-migration/#deploy-cloud-controller-manager>cloud-controller-manager</a>
启用 Leader 迁移，它允许集群管理者在没有停机的高可用集群环境下，实时
把 kube-controller-manager 迁移迁移到外部的 controller-manager (例如 cloud-controller-manager) 中。</li>
</ul>
<ul>
<li><code>CPUManager</code>：启用容器级别的 CPU 亲和性支持，有关更多详细信息，请参见
<a href=/zh/docs/tasks/administer-cluster/cpu-management-policies/>CPU 管理策略</a>。</li>
<li><code>CRIContainerLogRotation</code>：为 CRI 容器运行时启用容器日志轮换。日志文件的默认最大大小为
10MB，缺省情况下，一个容器允许的最大日志文件数为5。这些值可以在kubelet配置中配置。
更多细节请参见 <a href=/zh/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>日志架构</a>。</li>
<li><code>CPUManagerPolicyOptions</code>: 允许微调 CPU 管理策略。</li>
<li><code>CSIBlockVolume</code>：启用外部 CSI 卷驱动程序用于支持块存储。有关更多详细信息，请参见
<a href=/zh/docs/concepts/storage/volumes/#csi-raw-block-volume-support><code>csi</code> 原始块卷支持</a>。</li>
<li><code>CSIDriverRegistry</code>：在 csi.storage.k8s.io 中启用与 CSIDriver API 对象有关的所有逻辑。</li>
<li><code>CSIInlineVolume</code>：为 Pod 启用 CSI 内联卷支持。</li>
<li><code>CSIMigration</code>：确保封装和转换逻辑能够将卷操作从内嵌插件路由到相应的预安装 CSI 插件。</li>
</ul>
<ul>
<li><code>CSIMigrationAWS</code>：确保填充和转换逻辑能够将卷操作从 AWS-EBS 内嵌插件路由到 EBS CSI 插件。
如果节点未安装和配置 EBS CSI 插件，则支持回退到内嵌 EBS 插件。
这需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationAWSComplete</code>：停止在 kubelet 和卷控制器中注册 EBS 内嵌插件，
并启用 shims 和转换逻辑将卷操作从AWS-EBS 内嵌插件路由到 EBS CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationAWS 特性标志，并在集群中的所有节点上安装和配置
EBS CSI 插件。该特性标志已被废弃，取而代之的是 <code>InTreePluginAWSUnregister</code> ，这会阻止注册 EBS 内嵌插件。</li>
<li><code>CSIMigrationAzureDisk</code>：确保填充和转换逻辑能够将卷操作从 Azure 磁盘内嵌插件路由到
Azure 磁盘 CSI 插件。如果节点未安装和配置 AzureDisk CSI 插件，
支持回退到内建 AzureDisk 插件。这需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationAzureDiskComplete</code>：停止在 kubelet 和卷控制器中注册 Azure 磁盘内嵌插件，
并启用 shims 和转换逻辑以将卷操作从 Azure 磁盘内嵌插件路由到 AzureDisk CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationAzureDisk 特性标志，
并在集群中的所有节点上安装和配置 AzureDisk CSI 插件。该特性标志已被废弃，取而代之的是
能防止注册内嵌 AzureDisk 插件的 <code>InTreePluginAzureDiskUnregister</code> 特性标志。</li>
</ul>
<ul>
<li><code>CSIMigrationAzureFile</code>：确保封装和转换逻辑能够将卷操作从 Azure 文件内嵌插件路由到
Azure 文件 CSI 插件。如果节点未安装和配置 AzureFile CSI 插件，
支持回退到内嵌 AzureFile 插件。这需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationAzureFileComplete</code>：停止在 kubelet 和卷控制器中注册 Azure-File 内嵌插件，
并启用 shims 和转换逻辑以将卷操作从 Azure-File 内嵌插件路由到 AzureFile CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationAzureFile 特性标志，
并在集群中的所有节点上安装和配置 AzureFile CSI 插件。该特性标志已被废弃，取而代之的是
能防止注册内嵌 AzureDisk 插件的 <code>InTreePluginAzureFileUnregister</code> 特性标志。</li>
</ul>
<ul>
<li><code>CSIMigrationGCE</code>：启用 shims 和转换逻辑，将卷操作从 GCE-PD 内嵌插件路由到
PD CSI 插件。如果节点未安装和配置 PD CSI 插件，支持回退到内嵌 GCE 插件。
这需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationGCEComplete</code>：停止在 kubelet 和卷控制器中注册 GCE-PD 内嵌插件，
并启用 shims 和转换逻辑以将卷操作从 GCE-PD 内嵌插件路由到 PD CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationGCE 特性标志，并在集群中的所有节点上
安装和配置 PD CSI 插件。该特性标志已被废弃，取而代之的是
能防止注册内嵌 GCE PD 插件的 <code>InTreePluginGCEUnregister</code> 特性标志。</li>
</ul>
<ul>
<li><code>CSIMigrationOpenStack</code>：确保填充和转换逻辑能够将卷操作从 Cinder 内嵌插件路由到
Cinder CSI 插件。如果节点未安装和配置 Cinder CSI 插件，支持回退到内嵌 Cinder 插件。
这需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationOpenStackComplete</code>：停止在 kubelet 和卷控制器中注册 Cinder 内嵌插件，
并启用 shims 和转换逻辑将卷操作从 Cinder 内嵌插件路由到 Cinder CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationOpenStack 特性标志，并在集群中的所有节点上
安装和配置 Cinder CSI 插件。该特性标志已被废弃，取而代之的是
能防止注册内嵌 openstack cinder 插件的 <code>InTreePluginOpenStackUnregister</code> 特性标志。</li>
</ul>
<ul>
<li><code>CSIMigrationvSphere</code>: 允许封装和转换逻辑将卷操作从 vSphere 内嵌插件路由到
vSphere CSI 插件。如果节点未安装和配置 vSphere CSI 插件，则支持回退到
vSphere 内嵌插件。这需要启用 CSIMigration 特性标志。</li>
<li><code>CSIMigrationvSphereComplete</code>: 停止在 kubelet 和卷控制器中注册 vSphere 内嵌插件，
并启用 shims 和转换逻辑以将卷操作从 vSphere 内嵌插件路由到 vSphere CSI 插件。
这需要启用 CSIMigration 和 CSIMigrationvSphere 特性标志，并在集群中的所有节点上
安装和配置 vSphere CSI 插件。该特性标志已被废弃，取而代之的是
能防止注册内嵌 vsphere 插件的 <code>InTreePluginvSphereUnregister</code> 特性标志。</li>
</ul>
<ul>
<li><code>CSINodeInfo</code>：在 csi.storage.k8s.io 中启用与 CSINodeInfo API 对象有关的所有逻辑。</li>
<li><code>CSIPersistentVolume</code>：启用发现和挂载通过
<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md>CSI（容器存储接口）</a>
兼容卷插件配置的卷。</li>
<li><code>CSIServiceAccountToken</code>: 允许 CSI 驱动接收挂载卷目标 Pods 的服务账户令牌。
参阅<a href=https://kubernetes-csi.github.io/docs/token-requests.html>令牌请求（Token Requests）</a>。</li>
<li><code>CSIStorageCapacity</code>: 使 CSI 驱动程序可以发布存储容量信息，并使 Kubernetes
调度程序在调度 Pod 时使用该信息。参见
<a href=/zh/docs/concepts/storage/storage-capacity/>存储容量</a>。
详情请参见 <a href=/zh/docs/concepts/storage/volumes/#csi><code>csi</code> 卷类型</a>。</li>
</ul>
<ul>
<li><code>CSIVolumeFSGroupPolicy</code>: 允许 CSIDrivers 使用 <code>fsGroupPolicy</code> 字段.
该字段能控制由 CSIDriver 创建的卷在挂载这些卷时是否支持卷所有权和权限修改。</li>
<li><code>CSIVolumeHealth</code>: 启用对节点上的 CSI volume 运行状况监控的支持</li>
<li><code>CSRDuration</code>: 允许客户端来通过请求 Kubernetes CSR API 签署的证书的持续时间。</li>
<li><code>ConfigurableFSGroupPolicy</code>：在 Pod 中挂载卷时，允许用户为 fsGroup
配置卷访问权限和属主变更策略。请参见
<a href=/zh/docs/tasks/configure-pod-container/security-context/#configure-volume-permission-and-ownership-change-policy-for-pods>为 Pod 配置卷访问权限和属主变更策略</a>。</li>
<li><code>ControllerManagerLeaderMigration</code>: 为 <code>kube-controller-manager</code> 和 <code>cloud-controller-manager</code>
开启 leader 迁移功能。</li>
<li><code>CronJobControllerV2</code>：使用 <a class=glossary-tooltip title=周期调度的任务（作业）。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/cron-jobs/ target=_blank aria-label=CronJob>CronJob</a>
控制器的一种替代实现。否则，系统会选择同一控制器的 v1 版本。</li>
</ul>
<ul>
<li><code>CustomCPUCFSQuotaPeriod</code>：使节点能够更改
<a href=/zh/docs/tasks/administer-cluster/kubelet-config-file/>kubelet 配置</a>.
中的 <code>cpuCFSQuotaPeriod</code>。</li>
<li><code>CustomPodDNS</code>：允许使用 Pod 的 <code>dnsConfig</code> 属性自定义其 DNS 设置。
更多详细信息，请参见
<a href=/zh/docs/concepts/services-networking/dns-pod-service/#pods-dns-config>Pod 的 DNS 配置</a>。</li>
<li><code>CustomResourceDefaulting</code>：为 CRD 启用在其 OpenAPI v3 验证模式中提供默认值的支持。</li>
<li><code>CustomResourcePublishOpenAPI</code>：启用 CRD OpenAPI 规范的发布。</li>
<li><code>CustomResourceSubresources</code>：对于用
<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>CustomResourceDefinition</a>
创建的资源启用其 <code>/status</code> 和 <code>/scale</code> 子资源。</li>
<li><code>CustomResourceValidation</code>：对于用
<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>CustomResourceDefinition</a>
创建的资源启用基于模式的验证。</li>
<li><code>CustomResourceWebhookConversion</code>：对于用
<a href=/zh/docs/concepts/extend-kubernetes/api-extension/custom-resources/>CustomResourceDefinition</a>
创建的资源启用基于 Webhook 的转换。</li>
<li><code>DaemonSetUpdateSurge</code>: 使 DaemonSet 工作负载在每个节点的更新期间保持可用性。</li>
</ul>
<ul>
<li><code>DefaultPodTopologySpread</code>: 启用 <code>PodTopologySpread</code> 调度插件来完成
<a href=/zh/docs/concepts/workloads/pods/pod-topology-spread-constraints/#internal-default-constraints>默认的调度传播</a>.</li>
<li><code>DelegateFSGroupToCSIDriver</code>: 如果 CSI 驱动程序支持，则通过 NodeStageVolume 和
NodePublishVolume CSI 调用传递 <code>fsGroup</code> ，将应用 <code>fsGroup</code> 从 Pod 的
<code>securityContext</code> 的角色委托给驱动。</li>
<li><code>DevicePlugins</code>：在节点上启用基于
<a href=/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>设备插件</a>的
资源制备。</li>
<li><code>DisableAcceleratorUsageMetrics</code>：
<a href=/zh/docs/concepts/cluster-administration/system-metrics/#disable-accelerator-metrics>禁用 kubelet 收集加速器指标</a>.</li>
<li><code>DisableCloudProviders</code>: 禁用 <code>kube-apiserver</code>，
<code>kube-controller-manager</code> 和 <code>kubelet</code> 组件的 <code>--cloud-provider</code> 标志相关
的所有功能。</li>
<li><code>DownwardAPIHugePages</code>：允许在
<a href=/zh/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information>下行（Downward）API</a>
中使用巨页信息。</li>
<li><code>DryRun</code>：启用在服务器端对请求进行
<a href=/zh/docs/reference/using-api/api-concepts/#dry-run>彩排（Dry Run）</a>，
以便测试验证、合并和修改，同时避免提交更改。</li>
<li><code>DynamicAuditing</code>：在 v1.19 版本前用于启用动态审计。</li>
</ul>
<ul>
<li><code>DynamicKubeletConfig</code>：启用 kubelet 的动态配置。请参阅
<a href=/zh/docs/tasks/administer-cluster/reconfigure-kubelet/>重新配置 kubelet</a>。</li>
<li><code>DynamicProvisioningScheduling</code>：扩展默认调度器以了解卷拓扑并处理 PV 配置。
此特性已在 v1.12 中完全被 <code>VolumeScheduling</code> 特性取代。</li>
<li><code>DynamicVolumeProvisioning</code>：启用持久化卷到 Pod 的
<a href=/zh/docs/concepts/storage/dynamic-provisioning/>动态预配置</a>。</li>
<li><code>EfficientWatchResumption</code>：允许从存储发起的 bookmark（进度通知）事件被
通知到用户。此特性仅适用于 watch 操作。</li>
<li><code>EnableAggregatedDiscoveryTimeout</code>：对聚集的发现调用启用五秒钟超时设置。</li>
</ul>
<ul>
<li><code>EnableEquivalenceClassCache</code>：调度 Pod 时，使 scheduler 缓存节点的等效项。</li>
<li><code>EndpointSlice</code>：启用 EndpointSlice 以实现可扩缩性和可扩展性更好的网络端点。
参阅<a href=/zh/docs/tasks/administer-cluster/enabling-endpointslices/>启用 EndpointSlice</a>。</li>
<li><code>EndpointSliceNodeName</code>：允许使用 EndpointSlice 的 <code>nodeName</code> 字段。</li>
<li><code>EndpointSliceProxying</code>：启用此特性门控时，Linux 上运行的 kube-proxy 会使用
EndpointSlices 而不是 Endpoints 作为其主要数据源，从而使得可扩缩性和性能
提升成为可能。参阅
<a href=/zh/docs/tasks/administer-cluster/enabling-endpointslices/>启用 EndpointSlice</a>。</li>
<li><code>EndpointSliceTerminatingCondition</code>：允许使用 EndpointSlice 的 <code>terminating</code> 和
<code>serving</code> 状况字段。</li>
</ul>
<ul>
<li><code>EphemeralContainers</code>：启用添加
<a class=glossary-tooltip title="您可以在 Pod 中临时运行的一种容器类型" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/pods/ephemeral-containers/ target=_blank aria-label=临时容器>临时容器</a>
到正在运行的 Pod 的特性。</li>
<li><code>EvenPodsSpread</code>：使 Pod 能够在拓扑域之间平衡调度。请参阅
<a href=/zh/docs/concepts/workloads/pods/pod-topology-spread-constraints/>Pod 拓扑扩展约束</a>。</li>
<li><code>ExecProbeTimeout</code>：确保 kubelet 会遵从 exec 探针的超时值设置。
此特性门控的主要目的是方便你处理现有的、依赖于已被修复的缺陷的工作负载；
该缺陷导致 Kubernetes 会忽略 exec 探针的超时值设置。
参阅<a href=/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes>就绪态探针</a>.</li>
</ul>
<ul>
<li><code>ExpandCSIVolumes</code>: 启用扩展 CSI 卷。</li>
<li><code>ExpandedDNSConfig</code>: 在 kubelet 和 kube-apiserver 上启用后，
允许更多的 DNS 搜索域和搜索域列表。 参阅
<a href=/zh/docs/concepts/services-networking/dns-pod-service/#expanded-dns-configuration>扩展 DNS 配置</a>.</li>
<li><code>ExpandInUsePersistentVolumes</code>：启用扩充使用中的 PVC 的尺寸。请查阅
<a href=/zh/docs/concepts/storage/persistent-volumes/#resizing-an-in-use-persistentvolumeclaim>调整使用中的 PersistentVolumeClaim 的大小</a>。</li>
<li><code>ExpandPersistentVolumes</code>：允许扩充持久卷。请查阅
<a href=/zh/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims>扩展持久卷申领</a>。</li>
<li><code>ExperimentalCriticalPodAnnotation</code>：启用将特定 Pod 注解为 <em>critical</em> 的方式，用于
<a href=/zh/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/>确保其被调度</a>。
从 v1.13 开始已弃用此特性，转而使用 Pod 优先级和抢占功能。</li>
</ul>
<ul>
<li><code>ExperimentalHostUserNamespaceDefaulting</code>：启用主机默认的用户名字空间。
这适用于使用其他主机名字空间、主机安装的容器，或具有特权或使用特定的非名字空间功能
（例如 MKNODE、SYS_MODULE 等）的容器。
如果在 Docker 守护程序中启用了用户名字空间重新映射，则启用此选项。</li>
<li><code>ExternalPolicyForExternalIP</code>： 修复 ExternalPolicyForExternalIP 没有应用于 Service ExternalIPs 的 bug。</li>
<li><code>GCERegionalPersistentDisk</code>：在 GCE 上启用带地理区域信息的 PD 特性。</li>
<li><code>GenericEphemeralVolume</code>：启用支持临时的内联卷，这些卷支持普通卷
（可以由第三方存储供应商提供、存储容量跟踪、从快照还原等等）的所有功能。请参见
<a href=/zh/docs/concepts/storage/ephemeral-volumes/>临时卷</a>。</li>
<li><code>GracefulNodeShutdown</code>：在 kubelet 中启用体面地关闭节点的支持。
在系统关闭时，kubelet 会尝试监测该事件并体面地终止节点上运行的 Pods。参阅
<a href=/zh/docs/concepts/architecture/nodes/#graceful-node-shutdown>体面地关闭节点</a>
以了解更多细节。</li>
</ul>
<ul>
<li><code>HPAContainerMetrics</code>：允许 <code>HorizontalPodAutoscaler</code> 基于目标 Pods 中各容器
的度量值来执行扩缩操作。</li>
<li><code>HPAScaleToZero</code>：使用自定义指标或外部指标时，可将 <code>HorizontalPodAutoscaler</code>
资源的 <code>minReplicas</code> 设置为 0。</li>
<li><code>HugePages</code>：启用分配和使用预分配的
<a href=/zh/docs/tasks/manage-hugepages/scheduling-hugepages/>巨页资源</a>。</li>
<li><code>HugePageStorageMediumSize</code>：启用支持多种大小的预分配
<a href=/zh/docs/tasks/manage-hugepages/scheduling-hugepages/>巨页资源</a>。</li>
</ul>
<ul>
<li><code>HyperVContainer</code>：为 Windows 容器启用
<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container>Hyper-V 隔离</a>。</li>
<li><code>ImmutableEphemeralVolumes</code>：允许将各个 Secret 和 ConfigMap 标记为不可变更的，
以提高安全性和性能。</li>
<li><code>InTreePluginAWSUnregister</code>: 在 kubelet 和 卷控制器上关闭注册 aws-ebs 内嵌插件。</li>
<li><code>InTreePluginAzureDiskUnregister</code>: 在 kubelet 和 卷控制器上关闭注册 azuredisk 内嵌插件。</li>
<li><code>InTreePluginAzureFileUnregister</code>: 在 kubelet 和 卷控制器上关闭注册 azurefile 内嵌插件。</li>
<li><code>InTreePluginGCEUnregister</code>: 在 kubelet 和 卷控制器上关闭注册 gce-pd 内嵌插件。</li>
<li><code>InTreePluginOpenStackUnregister</code>: 在 kubelet 和 卷控制器上关闭注册 OpenStack cinder 内嵌插件。</li>
<li><code>InTreePluginvSphereUnregister</code>: 在 kubelet 和 卷控制器上关闭注册 vSphere 内嵌插件。</li>
<li><code>IndexedJob</code>：允许 <a href=/zh/docs/concepts/workloads/controllers/job/>Job</a> 控制器按每个完成的索引去管理 Pod 完成。</li>
<li><code>IngressClassNamespacedParams</code>：允许引用命名空间范围的参数引用 <code>IngressClass</code>资源。该特性增加了两个字段 —— <code>Scope</code> 和 <code>Namespace</code> 到 <code>IngressClass.spec.parameters</code>。</li>
<li><code>Initializers</code>： 使用 Initializers 准入插件允许异步协调对象创建。</li>
<li><code>IPv6DualStack</code>：启用 <a href=/zh/docs/concepts/services-networking/dual-stack/>双协议栈</a>
以支持 IPv6。</li>
<li><code>JobTrackingWithFinalizers</code>: 启用跟踪 <a href=/zh/docs/concepts/workloads/controllers/job>Job</a>
完成情况，而不是永远从集群剩余 pod 来获取信息判断完成情况。Job 控制器使
用 Pod finalizers 和 Job 状态中的一个字段来跟踪已完成的 Pod 以计算完成。</li>
<li><code>KubeletConfigFile</code>：启用从使用配置文件指定的文件中加载 kubelet 配置。
有关更多详细信息，请参见
<a href=/zh/docs/tasks/administer-cluster/kubelet-config-file/>通过配置文件设置 kubelet 参数</a>。</li>
<li><code>KubeletCredentialProviders</code>：允许使用 kubelet exec 凭据提供程序来设置
镜像拉取凭据。</li>
<li><code>KubeletInUserNamespace</code>: 支持在 <a class=glossary-tooltip title="A Linux kernel feature to emulate superuser privilege for unprivileged users." data-toggle=tooltip data-placement=top href=https://man7.org/linux/man-pages/man7/user_namespaces.7.html target=_blank aria-label="user namespace">user namespace</a> 里运行 kubelet 。
请参见 <a href=/zh/docs/tasks/administer-cluster/kubelet-in-userns/>使用非 Root 用户来运行 Kubernetes 节点组件</a>.</li>
<li><code>KubeletPluginsWatcher</code>：启用基于探针的插件监视应用程序，使 kubelet 能够发现
类似 <a href=/zh/docs/concepts/storage/volumes/#csi>CSI 卷驱动程序</a>这类插件。</li>
</ul>
<ul>
<li><code>KubeletPodResources</code>：启用 kubelet 上 Pod 资源 GRPC 端点。更多详细信息，请参见
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/compute-device-assignment.md>支持设备监控</a>。</li>
<li><code>KubeletPodResourcesGetAllocatable</code>：启用 kubelet 的 pod 资源
的 <code>GetAllocatableResources</code> 功能。
该 API 增强了[资源分配报告]（/zh/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/#monitoring-device-plugin-resources）
包含有关可分配资源的信息，使客户端能够正确跟踪节点上的可用计算资源。</li>
<li><code>LegacyNodeRoleBehavior</code>：禁用此门控时，服务负载均衡器中和节点干扰中的原先行为
会忽略 <code>node-role.kubernetes.io/master</code> 标签，使用 <code>NodeDisruptionExclusion</code> 和
<code>ServiceNodeExclusion</code> 对应特性所提供的标签。</li>
</ul>
<ul>
<li><code>LocalStorageCapacityIsolation</code>：允许使用
<a href=/zh/docs/concepts/configuration/manage-resources-containers/>本地临时存储</a>
以及 <a href=/zh/docs/concepts/storage/volumes/#emptydir>emptyDir 卷</a> 的 <code>sizeLimit</code> 属性。</li>
<li><code>LocalStorageCapacityIsolationFSQuotaMonitoring</code>：如果
<a href=/zh/docs/concepts/configuration/manage-resources-containers/>本地临时存储</a>
启用了 <code>LocalStorageCapacityIsolation</code>，并且
<a href=/zh/docs/concepts/storage/volumes/#emptydir>emptyDir 卷</a>
的后备文件系统支持项目配额，并且启用了这些配额，将使用项目配额来监视
<a href=/zh/docs/concepts/storage/volumes/#emptydir>emptyDir 卷</a>的存储消耗
而不是遍历文件系统，以此获得更好的性能和准确性。</li>
<li><code>LogarithmicScaleDown</code>：启用 Pod 的半随机（semi-random）选择，控制器将根据 Pod 时间戳的对数桶按比例缩小去驱逐 Pod。</li>
<li><code>MemoryManager</code>: 允许基于 NUMA 拓扑为容器设置内存亲和性。</li>
<li><code>MemoryQoS</code>: 使用 cgroup v2 内存控制器在 pod / 容器上启用内存保护和使用限制。</li>
<li><code>MixedProtocolLBService</code>：允许在同一 <code>LoadBalancer</code> 类型的 Service 实例中使用不同
的协议。</li>
<li><code>MountContainers</code>：允许使用主机上的工具容器作为卷挂载程序。</li>
</ul>
<ul>
<li><code>MountPropagation</code>：启用将一个容器安装的共享卷共享到其他容器或 Pod。
更多详细信息，请参见<a href=/zh/docs/concepts/storage/volumes/#mount-propagation>挂载传播</a>。</li>
<li><code>NamespaceDefaultLabelName</code>：配置 API 服务器以在所有名字空间上设置一个不可变的 <a class=glossary-tooltip title=用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=label>label</a>
<code>kubernetes.io/metadata.name</code>，也包括名字空间。</li>
<li><code>NodeDisruptionExclusion</code>：启用节点标签 <code>node.kubernetes.io/exclude-disruption</code>，
以防止在可用区发生故障期间驱逐节点。</li>
<li><code>NodeLease</code>：启用新的 Lease（租期）API 以报告节点心跳，可用作节点运行状况信号。</li>
<li><code>NodeSwap</code>: 启用 kubelet 为节点上的 Kubernetes 工作负载分配交换内存的能力。
必须将 <code>KubeletConfiguration.failSwapOn</code> 设置为 false 的情况下才能使用。
更多详细信息，请参见 <a href=/zh/docs/concepts/architecture/nodes/#swap-memory>交换内存</a>。</li>
<li><code>NonPreemptingPriority</code>：为 PriorityClass 和 Pod 启用 <code>preemptionPolicy</code> 选项。</li>
<li><code>PVCProtection</code>：启用防止仍被某 Pod 使用的 PVC 被删除的特性。</li>
<li><code>PodDeletionCost</code>：启用 <a href=/zh/docs/concepts/workloads/controllers/replicaset/#pod-deletion-cost>Pod 删除成本</a> 功能。
该功能使用户可以影响 ReplicaSet 的降序顺序。</li>
<li><code>PersistentLocalVolumes</code>：允许在 Pod 中使用 <code>local（本地）</code> 卷类型。
如果请求 <code>local</code> 卷，则必须指定 Pod 亲和性属性。</li>
<li><code>PodDisruptionBudget</code>：启用 <a href=/zh/docs/tasks/run-application/configure-pdb/>PodDisruptionBudget</a> 特性。</li>
<li><code>PodAffinityNamespaceSelector</code>：启用 <a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/#namespace-selector>Pod 亲和性名称空间选择器</a>
和 <a href=/zh/docs/concepts/policy/resource-quotas/#cross-namespace-pod-affinity-quota>CrossNamespacePodAffinity</a> 资源配额功能。</li>
<li><code>PodOverhead</code>：启用 <a href=/zh/docs/concepts/scheduling-eviction/pod-overhead/>PodOverhead</a>
特性以考虑 Pod 开销。</li>
</ul>
<ul>
<li><code>PodPriority</code>：根据 <a href=/zh/docs/concepts/scheduling-eviction/pod-priority-preemption/>优先级</a>
启用 Pod 的调度和抢占。</li>
<li><code>PodReadinessGates</code>：启用 <code>podReadinessGate</code> 字段的设置以扩展 Pod 准备状态评估。
有关更多详细信息，请参见
<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate>Pod 就绪状态判别</a>。</li>
<li><code>PodSecurity</code>: 开启 <code>PodSecurity</code> 准入控制插件。</li>
<li><code>PodShareProcessNamespace</code>：在 Pod 中启用 <code>shareProcessNamespace</code> 的设置，
以便在 Pod 中运行的容器之间共享同一进程名字空间。更多详细信息，请参见
<a href=/zh/docs/tasks/configure-pod-container/share-process-namespace/>在 Pod 中的容器间共享同一进程名字空间</a>。</li>
<li><code>PreferNominatedNode</code>: 这个标志告诉调度器在循环遍历集群中的所有其他节点
之前，是否首先检查指定的节点。</li>
<li><code>ProbeTerminationGracePeriod</code>：在 Pod 上 启用
<a href=/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#probe-level-terminationgraceperiodseconds>设置探测器级别 <code>terminationGracePeriodSeconds</code></a>。
有关更多信息，请参见 <a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2238-liveness-probe-grace-period>enhancement proposal</a>。</li>
<li><code>ProcMountType</code>：允许容器通过设置 SecurityContext 的 <code>procMount</code> 字段来控制
对 proc 文件系统的挂载方式。</li>
<li><code>ProxyTerminatingEndpoints</code>: 当 <code>ExternalTrafficPolicy=Local</code> 时，
允许 kube-proxy 来处理终止过程中的端点。</li>
<li><code>QOSReserved</code>：允许在 QoS 级别进行资源预留，以防止处于较低 QoS 级别的 Pod
突发进入处于较高 QoS 级别的请求资源（目前仅适用于内存）。</li>
<li><code>ReadWriteOncePod</code>: 允许使用 <code>ReadWriteOncePod</code> 访问模式的 PersistentVolume。</li>
<li><code>RemainingItemCount</code>：允许 API 服务器在
<a href=/zh/docs/reference/using-api/api-concepts/#retrieving-large-results-sets-in-chunks>分块列表请求</a>
的响应中显示剩余条目的个数。</li>
</ul>
<ul>
<li><code>RemoveSelfLink</code>：将 ObjectMeta 和 ListMeta 中的 <code>selfLink</code> 字段废弃并删除。</li>
<li><code>RequestManagement</code>：允许在每个 API 服务器上通过优先级和公平性管理请求并发性。
自 1.17 以来已被 <code>APIPriorityAndFairness</code> 弃用。</li>
<li><code>ResourceLimitsPriorityFunction</code>：启用某调度器优先级函数，
该函数将最低得分 1 指派给至少满足输入 Pod 的 CPU 和内存限制之一的节点，
目的是打破得分相同的节点之间的关联。</li>
<li><code>ResourceQuotaScopeSelectors</code>：启用资源配额范围选择器。</li>
<li><code>RootCAConfigMap</code>：配置 <code>kube-controller-manager</code>，使之发布一个名为 <code>kube-root-ca.crt</code>
的 <a class=glossary-tooltip title="ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。" data-toggle=tooltip data-placement=top href=/zh/docs/tasks/configure-pod-container/configure-pod-configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>，到
所有名字空间中。该 ConfigMap 包含用来验证与 kube-apiserver 之间连接的
CA 证书包。参阅
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-auth/1205-bound-service-account-tokens/README.md>绑定服务账户令牌</a>
以了解更多细节。</li>
</ul>
<ul>
<li><code>RotateKubeletClientCertificate</code>：在 kubelet 上启用客户端 TLS 证书的轮换。
更多详细信息，请参见
<a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/#kubelet-configuration>kubelet 配置</a>。</li>
<li><code>RotateKubeletServerCertificate</code>：在 kubelet 上启用服务器 TLS 证书的轮换。
更多详细信息，请参见
<a href=/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/#kubelet-configuration>kubelet 配置</a>。</li>
<li><code>RunAsGroup</code>：启用对容器初始化过程中设置的主要组 ID 的控制。</li>
<li><code>RuntimeClass</code>：启用 <a href=/zh/docs/concepts/containers/runtime-class/>RuntimeClass</a>
特性用于选择容器运行时配置。</li>
<li><code>ScheduleDaemonSetPods</code>：启用 DaemonSet Pods 由默认调度程序而不是
DaemonSet 控制器进行调度。</li>
</ul>
<ul>
<li><code>SCTPSupport</code>：在 Pod、Service、Endpoints、NetworkPolicy 定义中
允许将 <em>SCTP</em> 用作 <code>protocol</code> 值。</li>
<li><code>SeccompDefault</code>: 允许将所有工作负载的默认 seccomp 配置文件为 <code>RuntimeDefault</code>。
seccomp 配置在 Pod 或者容器的 <code>securityContext</code> 字段中指定。</li>
<li><code>SelectorIndex</code>: 允许在 API 服务器 watch 的缓存中基于标签和字段的索引来加速 list 的操作。</li>
<li><code>ServerSideApply</code>：在 API 服务器上启用
<a href=/zh/docs/reference/using-api/server-side-apply/>服务器端应用（SSA）</a> 。</li>
<li><code>ServiceAccountIssuerDiscovery</code>：在 API 服务器中为服务帐户颁发者启用 OIDC 发现端点
（颁发者和 JWKS URL）。详情参见
<a href=/zh/docs/tasks/configure-pod-container/configure-service-account/#service-account-issuer-discovery>为 Pod 配置服务账户</a> 。</li>
<li><code>ServiceAppProtocol</code>：为 Service 和 Endpoints 启用 <code>appProtocol</code> 字段。</li>
<li><code>ServiceInternalTrafficPolicy</code>：为服务启用 <code>internalTrafficPolicy</code> 字段。</li>
<li><code>ServiceLBNodePortControl</code>：为服务启用 <code>allocateLoadBalancerNodePorts</code> 字段。
<code>ServiceLoadBalancerClass</code>: 为服务启用 <code>loadBalancerClass</code> 字段。
有关更多信息，请参见 <a href=/zh/docs/concepts/services-networking/service/#load-balancer-class>负载均衡器类的定义 implementation</a>。</li>
<li><code>ServiceLoadBalancerFinalizer</code>：为服务负载均衡启用终结器（finalizers）保护。</li>
</ul>
<ul>
<li><code>ServiceNodeExclusion</code>：启用从云提供商创建的负载均衡中排除节点。
如果节点标记有 <code>node.kubernetes.io/exclude-from-external-load-balancers</code>，
标签，则可以排除该节点。</li>
<li><code>ServiceTopology</code>：启用服务拓扑可以让一个服务基于集群的节点拓扑进行流量路由。
有关更多详细信息，请参见
<a href=/zh/docs/concepts/services-networking/service-topology/>服务拓扑</a>。</li>
<li><code>SetHostnameAsFQDN</code>：启用将全限定域名（FQDN）设置为 Pod 主机名的功能。
请参见<a href=/zh/docs/concepts/services-networking/dns-pod-service/#pod-sethostnameasfqdn-field>为 Pod 设置 <code>setHostnameAsFQDN</code> 字段</a>。</li>
<li><code>SizeMemoryBackedVolumes</code>：允许 kubelet 检查基于内存制备的卷的尺寸约束
（目前主要针对 <code>emptyDir</code> 卷）。</li>
</ul>
<ul>
<li><code>StartupProbe</code>：在 kubelet 中启用
<a href=/zh/docs/concepts/workloads/pods/pod-lifecycle/#when-should-you-use-a-startup-probe>启动探针</a>。</li>
<li><code>StatefulSetMinReadySeconds</code>: 允许 StatefulSet 控制器采纳 <code>minReadySeconds</code> 设置。</li>
<li><code>StorageObjectInUseProtection</code>：如果仍在使用 PersistentVolume 或
PersistentVolumeClaim 对象，则将其删除操作推迟。</li>
<li><code>StorageVersionAPI</code>: 启用
<a href=/docs/reference/generated/kubernetes-api/v1.22/#storageversion-v1alpha1-internal-apiserver-k8s-io>存储版本 API</a>。</li>
<li><code>StorageVersionHash</code>：允许 API 服务器在版本发现中公开存储版本的哈希值。</li>
<li><code>StreamingProxyRedirects</code>：指示 API 服务器拦截（并跟踪）后端（kubelet）
的重定向以处理流请求。
流请求的例子包括 <code>exec</code>、<code>attach</code> 和 <code>port-forward</code> 请求。</li>
</ul>
<ul>
<li><code>SupportIPVSProxyMode</code>：启用使用 IPVS 提供内服务负载平衡。更多详细信息，请参见
<a href=/zh/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>服务代理</a>。</li>
<li><code>SupportNodePidsLimit</code>：启用支持，限制节点上的 PID 用量。
<code>--system-reserved</code> 和 <code>--kube-reserved</code> 中的参数 <code>pid=&lt;数值></code> 可以分别用来
设定为整个系统所预留的进程 ID 个数和为 Kubernetes 系统守护进程预留的进程
ID 个数。</li>
<li><code>SupportPodPidsLimit</code>：启用支持限制 Pod 中的进程 PID。</li>
<li><code>SuspendJob</code>： 启用支持以暂停和恢复作业。 更多详细信息，请参见
<a href=zh//docs/concepts/workloads/controllers/job/>Jobs 文档</a>。</li>
<li><code>Sysctls</code>：允许为每个 Pod 设置的名字空间内核参数（sysctls）。
更多详细信息，请参见 <a href=/zh/docs/tasks/administer-cluster/sysctl-cluster/>sysctls</a>。</li>
</ul>
<ul>
<li><code>TTLAfterFinished</code>：资源完成执行后，允许
<a href=/zh/docs/concepts/workloads/controllers/ttlafterfinished/>TTL 控制器</a>清理资源。</li>
<li><code>TaintBasedEvictions</code>：根据节点上的污点和 Pod 上的容忍度启用从节点驱逐 Pod 的特性。
更多详细信息可参见<a href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/>污点和容忍度</a>。</li>
<li><code>TaintNodesByCondition</code>：根据<a href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/>节点状况</a>
启用自动为节点标记污点。</li>
<li><code>TokenRequest</code>：在服务帐户资源上启用 <code>TokenRequest</code> 端点。</li>
<li><code>TokenRequestProjection</code>：启用通过
<a href=/zh/docs/concepts/storage/volumes/#projected><code>projected</code> 卷</a>
将服务帐户令牌注入到 Pod 中的特性。</li>
<li><code>TopologyAwareHints</code>： 在 EndpointSlices 中启用基于拓扑提示的拓扑感知路由。
更多详细信息可参见<a href=/zh/docs/concepts/services-networking/topology-aware-hints/>Topology Aware Hints</a></li>
<li><code>TopologyManager</code>：启用一种机制来协调 Kubernetes 不同组件的细粒度硬件资源分配。
详见<a href=/zh/docs/tasks/administer-cluster/topology-manager/>控制节点上的拓扑管理策略</a>。</li>
</ul>
<ul>
<li><code>ValidateProxyRedirects</code>： 这个标志控制 API 服务器是否应该验证只跟随到相同的主机的重定向。
仅在启用 <code>StreamingProxyRedirects</code> 标志时被使用。</li>
<li><code>VolumeCapacityPriority</code>: 基于可用 PV 容量的拓扑，启用对不同节点的优先级支持。</li>
<li><code>VolumePVCDataSource</code>：启用对将现有 PVC 指定数据源的支持。</li>
<li><code>VolumeScheduling</code>：启用卷拓扑感知调度，并使 PersistentVolumeClaim（PVC）
绑定能够了解调度决策；当与 PersistentLocalVolumes 特性门控一起使用时，
还允许使用 <a href=/zh/docs/concepts/storage/volumes/#local><code>local</code></a> 卷类型。</li>
<li><code>VolumeSnapshotDataSource</code>：启用卷快照数据源支持。</li>
<li><code>VolumeSubpath</code>： 允许在容器中挂载卷的子路径。</li>
</ul>
<ul>
<li><code>VolumeSubpathEnvExpansion</code>：启用 <code>subPathExpr</code> 字段用于将环境变量在 <code>subPath</code>
中展开。</li>
<li><code>WarningHeaders</code>：允许在 API 响应中发送警告头部。</li>
<li><code>WatchBookmark</code>：启用对 watch 操作中 bookmark 事件的支持。</li>
<li><code>WinDSR</code>：允许 kube-proxy 为 Windows 创建 DSR 负载均衡。</li>
<li><code>WinOverlay</code>：允许 kube-proxy 在 Windows 的覆盖网络模式下运行。</li>
<li><code>WindowsEndpointSliceProxying</code>: 当启用时，运行在 Windows 上的 kube-proxy
将使用 EndpointSlices 而不是 Endpoints 作为主要数据源，从而实现可伸缩性和并改进性能。
详情请参见<a href=/zh/docs/tasks/administer-cluster/enabling-endpointslices/>启用端点切片</a>.</li>
<li><code>WindowsGMSA</code>：允许将 GMSA 凭据规范从 Pod 传递到容器运行时。</li>
<li><code>WindowsHostProcessContainers</code>: 启用对 Windows HostProcess 容器的支持。</li>
<li><code>WindowsRunAsUserName</code>：提供使用非默认用户在 Windows 容器中运行应用程序的支持。
详情请参见
<a href=/zh/docs/tasks/configure-pod-container/configure-runasusername>配置 RunAsUserName</a>。</li>
</ul>
<h2 id=接下来>接下来</h2>
<ul>
<li>Kubernetes 的<a href=/zh/docs/reference/using-api/deprecation-policy/>弃用策略</a>
介绍了项目针对已移除特性和组件的处理方法。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-29e506a6018204679ef5459653a7aa1f>10.2 - kubelet</h1>
<h2 id=简介>简介</h2>
<p>kubelet 是在每个 Node 节点上运行的主要 “节点代理”。它可以使用以下之一向 apiserver 注册：
主机名（hostname）；覆盖主机名的参数；某云驱动的特定逻辑。</p>
<p>kubelet 是基于 PodSpec 来工作的。每个 PodSpec 是一个描述 Pod 的 YAML 或 JSON 对象。
kubelet 接受通过各种机制（主要是通过 apiserver）提供的一组 PodSpec，并确保这些
PodSpec 中描述的容器处于运行状态且运行状况良好。
kubelet 不管理不是由 Kubernetes 创建的容器。</p>
<p>除了来自 apiserver 的 PodSpec 之外，还可以通过以下三种方式将容器清单（manifest）提供给 kubelet。</p>
<p>文件（File）：利用命令行参数传递路径。kubelet 周期性地监视此路径下的文件是否有更新。
监视周期默认为 20s，且可通过参数进行配置。</p>
<p>HTTP 端点（HTTP endpoint）：利用命令行参数指定 HTTP 端点。
此端点的监视周期默认为 20 秒，也可以使用参数进行配置。</p>
<p>HTTP 服务器（HTTP server）：kubelet 还可以侦听 HTTP 并响应简单的 API
（目前没有完整规范）来提交新的清单。</p>
<pre><code>kubelet [flags]
</code></pre><h2 id=选项>选项</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--add-dir-header</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示将文件目录添加到日志消息的头部
</td>
</tr>
<tr>
<td colspan=2>--address ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.0.0.0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 用来提供服务的 IP 地址（设置为<code>0.0.0.0</code> 表示使用所有 IPv4 接口，
设置为 <code>::</code> 表示使用所有 IPv6 接口）。已弃用：应在 <code>--config</code> 所给的
配置文件中进行设置。（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--allowed-unsafe-sysctls strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用逗号分隔的字符串序列设置允许使用的非安全的 sysctls 或 sysctl 模式（以 <code>*</code> 结尾) 。
使用此参数时风险自担。已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）.
</td>
</tr>
<tr>
<td colspan=2>--alsologtostderr</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示将日志输出到文件的同时输出到 stderr
</td>
</tr>
<tr>
<td colspan=2>--anonymous-auth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示 kubelet 服务器可以接受匿名请求。未被任何认证组件拒绝的请求将被视为匿名请求。
匿名请求的用户名为 <code>system:anonymous</code>，用户组为 <code>system:unauthenticated</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--authentication-token-webhook</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用 <code>TokenReview</code> API 对持有者令牌进行身份认证。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--authentication-token-webhook-cache-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>2m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 Webhook 令牌认证组件所返回的响应的缓存时间。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--authorization-mode string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 服务器的鉴权模式。可选值包括：<code>AlwaysAllow</code>、<code>Webhook</code>。<code>Webhook</code> 模式使用 <code>SubjectAccessReview</code> API 鉴权。
当 <code>--config</code> 参数未被设置时，默认值为 <code>AlwaysAllow</code>，当使用了
<code>--config</code> 时，默认值为 <code>Webhook</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-authorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>5m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 Webhook 认证组件所返回的 “Authorized（已授权）” 应答的缓存时间。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-unauthorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>30s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 Webhook 认证组件所返回的 “Unauthorized（未授权）” 应答的缓存时间。
<code>--config</code> 时，默认值为 <code>Webhook</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Azure 容器镜像库配置信息的文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--bootstrap-kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
某 kubeconfig 文件的路径，该文件将用于获取 kubelet 的客户端证书。
如果 <code>--kubeconfig</code> 所指定的文件不存在，则使用引导所用 kubeconfig
从 API 服务器请求客户端证书。成功后，将引用生成的客户端证书和密钥的 kubeconfig
写入 --kubeconfig 所指定的路径。客户端证书和密钥文件将存储在 <code>--cert-dir</code>
所指的目录。
</td>
</tr>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/var/lib/kubelet/pki</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 证书所在的目录。如果设置了 <code>--tls-cert-file</code> 和 <code>--tls-private-key-file</code>，
则此标志将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--cgroup-driver string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>cgroupfs</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 用来操作本机 cgroup 时使用的驱动程序。支持的选项包括 <code>cgroupfs</code>
和 <code>systemd</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
/td>
</tr>
<tr>
<td colspan=2>--cgroup-root string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>""</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可选的选项，为 Pod 设置根 cgroup。容器运行时会尽可能使用此配置。
默认值 <code>""</code> 意味着将使用容器运行时的默认设置。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cgroups-per-qos&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用创建 QoS cgroup 层次结构。此值为 true 时 kubelet 为 QoS 和 Pod 创建顶级的 cgroup。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--chaos-chance float</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果此值大于 0.0，则引入随机客户端错误和延迟。用于测试。
已启用：将在未来版本中移除。
</td>
</tr>
<tr>
<td colspan=2>--client-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置了此参数，则使用对应文件中机构之一检查请求中所携带的客户端证书。
若客户端证书通过身份认证，则其对应身份为其证书中所设置的 CommonName。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cloud-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
云驱动配置文件的路径。空字符串表示没有配置文件。
已弃用：将在 1.23 版本中移除，以便于从 kubelet 中去除云驱动代码。
</td>
</tr>
<tr>
<td colspan=2>--cloud-provider string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
云服务的提供者。设置为空字符串表示在没有云驱动的情况下运行。
如果设置了此标志，则云驱动负责确定节点的名称（参考云提供商文档以确定是否以及如何使用主机名）。
已弃用：将在 1.23 版本中移除，以便于从 kubelet 中去除云驱动代码。
</td>
</tr>
<tr>
<td colspan=2>--cluster-dns strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
DNS 服务器的 IP 地址，以逗号分隔。此标志值用于 Pod 中设置了 “<code>dnsPolicy=ClusterFirst</code>”
时为容器提供 DNS 服务。注意：列表中出现的所有 DNS 服务器必须包含相同的记录组，
否则集群中的名称解析可能无法正常工作。至于名称解析过程中会牵涉到哪些 DNS 服务器，
这一点无法保证。
<code>--config</code> 时，默认值为 <code>Webhook</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cluster-domain string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
集群的域名。如果设置了此值，kubelet 除了将主机的搜索域配置到所有容器之外，还会为其
配置所搜这里指定的域名。
<code>--config</code> 时，默认值为 <code>Webhook</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cni-bin-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/opt/cni/bin</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> 此值为以逗号分隔的完整路径列表。
kubelet 将在所指定路径中搜索 CNI 插件的可执行文件。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan=2>--cni-cache-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/var/lib/cni/cache</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> 此值为一个目录的全路径名。CNI 将在其中缓存文件。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan=2>--cni-conf-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/etc/cni/net.d</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> 此值为某目录的全路径名。kubelet 将在其中搜索 CNI 配置文件。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 将从此标志所指的文件中加载其初始配置。此路径可以是绝对路径，也可以是相对路径。
相对路径按 kubelet 的当前工作目录起计。省略此参数时 kubelet 会使用内置的默认配置值。
命令行参数会覆盖此文件中的配置。
</td>
</tr>
<tr>
<td colspan=2>--container-log-max-files int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置容器的日志文件个数上限。此值必须不小于 2。
此标志只能与 <code>--container-runtime=remote</code> 标志一起使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--container-log-max-size string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>10Mi</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置容器日志文件在轮换生成新文件时之前的最大值（例如，<code>10Mi</code>）。
此标志只能与 <code>--container-runtime=remote</code> 标志一起使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--container-runtime string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>docker</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要使用的容器运行时。目前支持 <code>docker<code>、</code>remote</code>。
</td>
</tr>
<tr>
<td colspan=2>--container-runtime-endpoint string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>unix:///var/run/dockershim.sock</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验性特性] 远程运行时服务的端点。目前支持 Linux 系统上的 UNIX 套接字和
Windows 系统上的 npipe 和 TCP 端点。例如：
<code>unix:///var/run/dockershim.sock</code>、
<code>npipe:////./pipe/dockershim</code>。
</td>
</tr>
<tr>
<td colspan=2>--contention-profiling</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当启用了性能分析时，启用锁竞争分析。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cpu-cfs-quota&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为设置了 CPU 限制的容器启用 CPU CFS 配额保障。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cpu-cfs-quota-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>100ms</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置 CPU CFS 配额周期 <code>cpu.cfs_period_us</code>。默认使用 Linux 内核所设置的默认值 。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cpu-manager-policy string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>none</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要使用的 CPU 管理器策略。可选值包括：<code>none</code> 和 <code>static</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--cpu-manager-reconcile-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>10s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> 设置 CPU 管理器的调和时间。例如：<code>10s</code> 或者 <code>1m</code>。
如果未设置，默认使用节点状态更新频率。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--docker-endpoint string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>unix:///var/run/docker.sock</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用这里的端点与 docker 端点通信。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan=2>--dynamic-config-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 使用此目录来保存所下载的配置，跟踪配置运行状况。
如果目录不存在，则 kubelet 创建该目录。此路径可以是绝对路径，也可以是相对路径。
相对路径从 kubelet 的当前工作目录计算。
设置此参数将启用动态 kubelet 配置。必须启用 <code>DynamicKubeletConfig</code>
特性门控之后才能设置此标志；由于此特性为 beta 阶段，对应的特性门控当前默认为
<code>true</code>。
</td>
</tr>
<tr>
<td colspan=2>--enable-controller-attach-detach&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用 Attach/Detach 控制器来挂接和摘除调度到该节点的卷，同时禁用 kubelet 执行挂接和摘除操作。
</td>
</tr>
<tr>
<td colspan=2>--enable-debugging-handlers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: `true`</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用服务器上用于日志收集和在本地运行容器和命令的端点。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--enable-server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用 kubelet 服务器。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--enforce-node-allocatable strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: `pods`</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用逗号分隔的列表，包含由 kubelet 强制执行的节点可分配资源级别。
可选配置为：<code>none</code>、<code>pods</code>、<code>system-reserved</code> 和 <code>kube-reserved</code>。
在设置 <code>system-reserved</code> 和 <code>kube-reserved</code> 这两个值时，同时要求设置
<code>--system-reserved-cgroup</code> 和 <code>--kube-reserved-cgroup</code> 这两个参数。
如果设置为 <code>none</code>，则不需要设置其他参数。
<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/reserve-compute-resources/>参考相关文档</a>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--event-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
事件记录的个数的突发峰值上限，在遵从 <code>--event-qps</code> 阈值约束的前提下
临时允许事件记录达到此数目。仅在 <code>--event-qps</code> 大于 0 时使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--event-qps int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置大于 0 的值表示限制每秒可生成的事件数量。设置为 0 表示不限制。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--eviction-hard string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>imagefs.available&lt;15%,memory.available&lt;100Mi,nodefs.available&lt;10%</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
触发 Pod 驱逐操作的一组硬性门限（例如：<code>memory.available&lt;1Gi</code>
（内存可用值小于 1 G））设置。在 Linux 节点上，默认值还包括
<code>nodefs.inodesFree<5%</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--eviction-max-pod-grace-period int32</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
响应满足软性驱逐阈值（Soft Eviction Threshold）而终止 Pod 时使用的最长宽限期（以秒为单位）。
如果设置为负数，则遵循 Pod 的指定值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--eviction-minimum-reclaim mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当某资源压力过大时，kubelet 将执行 Pod 驱逐操作。
此参数设置软性驱逐操作需要回收的资源的最小数量（例如：<code>imagefs.available=2Gi</code>）。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--eviction-pressure-transition-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>5m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 在驱逐压力状况解除之前的最长等待时间。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--eviction-soft mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置一组驱逐阈值（例如：<code>memory.available&lt;1.5Gi</code>）。
如果在相应的宽限期内达到该阈值，则会触发 Pod 驱逐操作。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--eviction-soft-grace-period mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置一组驱逐宽限期（例如，<code>memory.available=1m30s</code>），对应于触发软性 Pod
驱逐操作之前软性驱逐阈值所需持续的时间长短。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--exit-on-lock-contention</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示当发生锁文件竞争时 kubelet 可以退出。
</td>
</tr>
<tr>
<td colspan=2>--experimental-allocatable-ignore-eviction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>false</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 <code>true</code> 表示在计算节点可分配资源数量时忽略硬性逐出阈值设置。
参考<a href=https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/>
相关文档</a>。
已启用：将在 1.23 版本中移除。
</td>
</tr>
<tr>
<td colspan=2>--experimental-bootstrap-kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用：应使用 <code>--bootstrap-kubeconfig</code> 标志
</td>
</tr>
<tr>
<td colspan=2>--experimental-check-node-capabilities-before-mount</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验性特性] 设置为 <code>true</code> 表示 kubelet 在进行挂载卷操作之前要
在本节点上检查所需的组件（如可执行文件等）是否存在。
已弃用：将在 1.23 版本中移除，以便使用 CSI。
</td>
</tr>
<tr>
<td colspan=2>--experimental-kernel-memcg-notification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示 kubelet 将会集成内核的 memcg 通知机制而不是使用轮询机制来
判断是否达到了内存驱逐阈值。
此标志将在 1.23 版本移除。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--experimental-log-sanitization</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[试验性功能] 启用此标志之后，kubelet 会避免将标记为敏感的字段（密码、密钥、令牌等）
写入日志中。运行时的日志清理可能会带来相当的计算开销，因此不应该在
产品环境中启用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</tr>
<tr>
<td colspan=2>--experimental-mounter-path string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>mount</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验性特性] 卷挂载器（mounter）的可执行文件的路径。设置为空表示使用默认挂载器 <code>mount</code>。
已弃用：将在 1.23 版本移除以支持 CSI。
</td>
</tr>
<tr>
<td colspan=2>--fail-swap-on&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示如果主机启用了交换分区，kubelet 将直接失败。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--feature-gates mapStringBool</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 alpha 实验性质的特性开关组，每个开关以 key=value 形式表示。当前可用开关包括：
APIListChunking=true|false (BETA - 默认值为 true)<br>
APIPriorityAndFairness=true|false (BETA - 默认值为 true)<br>
APIResponseCompression=true|false (BETA - 默认值为 true)<br>
APIServerIdentity=true|false (ALPHA - 默认值为 false)<br>
AllAlpha=true|false (ALPHA - 默认值为 false)<br>
AllBeta=true|false (BETA - 默认值为 false)<br>
AllowInsecureBackendProxy=true|false (BETA - 默认值为 true)<br>
AnyVolumeDataSource=true|false (ALPHA - 默认值为 false)<br>
AppArmor=true|false (BETA - 默认值为 true)<br>
BalanceAttachedNodeVolumes=true|false (ALPHA - 默认值为 false)<br>
BoundServiceAccountTokenVolume=true|false (ALPHA - 默认值为 false)<br>
CPUManager=true|false (BETA - 默认值为 true)<br>
CSIInlineVolume=true|false (BETA - 默认值为 true)<br>
CSIMigration=true|false (BETA - 默认值为 true)<br>
CSIMigrationAWS=true|false (BETA - 默认值为 false)<br>
CSIMigrationAWSComplete=true|false (ALPHA - 默认值为 false)<br>
CSIMigrationAzureDisk=true|false (BETA - 默认值为 false)<br>
CSIMigrationAzureDiskComplete=true|false (ALPHA - 默认值为 false)<br>
CSIMigrationAzureFile=true|false (ALPHA - 默认值为 false)<br>
CSIMigrationAzureFileComplete=true|false (ALPHA - 默认值为 false)<br>
CSIMigrationGCE=true|false (BETA - 默认值为 false)<br>
CSIMigrationGCEComplete=true|false (ALPHA - 默认值为 false)<br>
CSIMigrationOpenStack=true|false (BETA - 默认值为 false)<br>
CSIMigrationOpenStackComplete=true|false (ALPHA - 默认值为 false)<br>
CSIMigrationvSphere=true|false (BETA - 默认值为 false)<br>
CSIMigrationvSphereComplete=true|false (BETA - 默认值为 false)<br>
CSIServiceAccountToken=true|false (ALPHA - 默认值为 false)<br>
CSIStorageCapacity=true|false (ALPHA - 默认值为 false)<br>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值为 true)<br>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值为 true)<br>
CronJobControllerV2=true|false (ALPHA - 默认值为 false)<br>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值为 false)<br>
DefaultPodTopologySpread=true|false (BETA - 默认值为 true)<br>
DevicePlugins=true|false (BETA - 默认值为 true)<br>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值为 true)<br>
DownwardAPIHugePages=true|false (ALPHA - 默认值为 false)<br>
DynamicKubeletConfig=true|false (BETA - 默认值为 true)<br>
EfficientWatchResumption=true|false (ALPHA - 默认值为 false)<br>
EndpointSlice=true|false (BETA - 默认值为 true)<br>
EndpointSliceNodeName=true|false (ALPHA - 默认值为 false)<br>
EndpointSliceProxying=true|false (BETA - 默认值为 true)<br>
EndpointSliceTerminatingCondition=true|false (ALPHA - 默认值为 false)<br>
EphemeralContainers=true|false (ALPHA - 默认值为 false)<br>
ExpandCSIVolumes=true|false (BETA - 默认值为 true)<br>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值为 true)<br>
ExpandPersistentVolumes=true|false (BETA - 默认值为 true)<br>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - 默认值为 false)<br>
GenericEphemeralVolume=true|false (ALPHA - 默认值为 false)<br>
GracefulNodeShutdown=true|false (ALPHA - 默认值为 false)<br>
HPAContainerMetrics=true|false (ALPHA - 默认值为 false)<br>
HPAScaleToZero=true|false (ALPHA - 默认值为 false)<br>
HugePageStorageMediumSize=true|false (BETA - 默认值为 true)<br>
IPv6DualStack=true|false (ALPHA - 默认值为 false)<br>
ImmutableEphemeralVolumes=true|false (BETA - 默认值为 true)<br>
KubeletCredentialProviders=true|false (ALPHA - 默认值为 false)<br>
KubeletPodResources=true|false (BETA - 默认值为 true)<br>
LegacyNodeRoleBehavior=true|false (BETA - 默认值为 true)<br>
LocalStorageCapacityIsolation=true|false (BETA - 默认值为 true)<br>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值为 false)<br>
MixedProtocolLBService=true|false (ALPHA - 默认值为 false)<br>
NodeDisruptionExclusion=true|false (BETA - 默认值为 true)<br>
NonPreemptingPriority=true|false (BETA - 默认值为 true)<br>
PodDisruptionBudget=true|false (BETA - 默认值为 true)<br>
PodOverhead=true|false (BETA - 默认值为 true)<br>
ProcMountType=true|false (ALPHA - 默认值为 false)<br>
QOSReserved=true|false (ALPHA - 默认值为 false)<br>
RemainingItemCount=true|false (BETA - 默认值为 true)<br>
RemoveSelfLink=true|false (BETA - 默认值为 true)<br>
RootCAConfigMap=true|false (BETA - 默认值为 true)<br>
RotateKubeletServerCertificate=true|false (BETA - 默认值为 true)<br>
RunAsGroup=true|false (BETA - 默认值为 true)<br>
ServerSideApply=true|false (BETA - 默认值为 true)<br>
ServiceAccountIssuerDiscovery=true|false (BETA - 默认值为 true)<br>
ServiceLBNodePortControl=true|false (ALPHA - 默认值为 false)<br>
ServiceNodeExclusion=true|false (BETA - 默认值为 true)<br>
ServiceTopology=true|false (ALPHA - 默认值为 false)<br>
SetHostnameAsFQDN=true|false (BETA - 默认值为 true)<br>
SizeMemoryBackedVolumes=true|false (ALPHA - 默认值为 false)<br>
StorageVersionAPI=true|false (ALPHA - 默认值为 false)<br>
StorageVersionHash=true|false (BETA - 默认值为 true)<br>
Sysctls=true|false (BETA - 默认值为 true)<br>
TTLAfterFinished=true|false (ALPHA - 默认值为 false)<br>
TopologyManager=true|false (BETA - 默认值为 true)<br>
ValidateProxyRedirects=true|false (BETA - 默认值为 true)<br>
WarningHeaders=true|false (BETA - 默认值为 true)<br>
WinDSR=true|false (ALPHA - 默认值为 false)<br>
WinOverlay=true|false (BETA - 默认值为 true)<br>
WindowsEndpointSliceProxying=true|false (ALPHA - 默认值为 false)<br>
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--file-check-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>20s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
检查配置文件中新数据的时间间隔。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--hairpin-mode string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>promiscuous-bridge</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置 kubelet 执行发夹模式（hairpin）网络地址转译的方式。
该模式允许后端端点对其自身服务的访问能够再次经由负载均衡转发回自身。
可选项包括 “<code>promiscuous-bridge</code>”、“<code>hairpin-veth</code>” 和 “<code>none</code>”。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--healthz-bind-address ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>127.0.0.1</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于运行 healthz 服务器的 IP 地址（设置为 <code>0.0.0.0</code> 表示使用所有 IPv4 接口，
设置为 <code>::</code> 表示使用所有 IPv6 接口。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--healthz-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10248</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
本地 healthz 端点使用的端口（设置为 0 表示禁用）。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 操作的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--hostname-override string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为非空，将使用此字符串而不是实际的主机名作为节点标识。如果设置了
<code>--cloud-provider</code>，则云驱动将确定节点的名称
（请查阅云服务商文档以确定是否以及如何使用主机名）。
</td>
</tr>
<tr>
<td colspan=2>--housekeeping-interval duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>10s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
清理容器操作的时间间隔。
</td>
</tr>
<tr>
<td colspan=2>--http-check-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>20s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
HTTP 服务以获取新数据的时间间隔。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--image-credential-provider-bin-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向凭据提供组件可执行文件所在目录的路径。
</td>
</tr>
<tr>
<td colspan=2>--image-credential-provider-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向凭据提供插件配置文件所在目录的路径。
</tr>
<tr>
<td colspan=2>--image-gc-high-threshold int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：85</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
镜像垃圾回收上限。磁盘使用空间达到该百分比时，镜像垃圾回收将持续工作。
值必须在 [0，100] 范围内。要禁用镜像垃圾回收，请设置为 100。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--image-gc-low-threshold int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：80</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
镜像垃圾回收下限。磁盘使用空间在达到该百分比之前，镜像垃圾回收操作不会运行。
值必须在 [0，100] 范围内，并且不得大于 <code>--image-gc-high-threshold</code>的值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--image-pull-progress-deadline duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>1m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果在该参数值所设置的期限之前没有拉取镜像的进展，镜像拉取操作将被取消。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan=2>--image-service-endpoint string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[实验性特性] 远程镜像服务的端点。若未设定则默认情况下使用 <code>--container-runtime-endpoint</code>
的值。目前支持的类型包括在 Linux 系统上的 UNIX 套接字端点和 Windows 系统上的 npipe 和 TCP 端点。
例如：<code>unix:///var/run/dockershim.sock</code>、<code>npipe:////./pipe/dockershim</code>。
</td>
</tr>
<tr>
<td colspan=2>--iptables-drop-bit int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：15</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
标记数据包将被丢弃的 fwmark 位设置。必须在 [0，31] 范围内。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--iptables-masquerade-bit int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：14</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
标记数据包将进行 SNAT 的 fwmark 空间位设置。必须在 [0，31] 范围内。
请将此参数与 <code>kube-proxy</code> 中的相应参数匹配。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--keep-terminated-pod-volumes</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示 Pod 终止后仍然保留之前挂载过的卷，常用于调试与卷有关的问题。
已弃用：将未来版本中移除。
</td>
</tr>
<tr>
<td colspan=2>--kernel-memcg-notification</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
若启用，则 kubelet 将与内核中的 memcg 通知机制集成，不再使用轮询的方式来判定
是否 Pod 达到内存驱逐阈值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--kube-api-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
每秒发送到 apiserver 的突发请求数量上限。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--kube-api-content-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>application/vnd.kubernetes.protobuf</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
发送到 apiserver 的请求的内容类型。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--kube-api-qps int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与 apiserver 通信的每秒查询个数（QPS）。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--kube-reserved mapStringString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：&lt;None></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubernetes 系统预留的资源配置，以一组 <code>资源名称=资源数量</code> 格式表示。
（例如：<code>cpu=200m,memory=500Mi,ephemeral-storage=1Gi,pid='100'</code>）。
当前支持 <code>cpu</code>、<code>memory</code> 和用于根文件系统的 <code>ephemeral-storage</code>。
请参阅<a href=http://kubernetes.io/zh/docs/concepts/configuration/manage-resources-containers/>相关文档</a>获取更多信息。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--kube-reserved-cgroup string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>""</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
给出某个顶层 cgroup 绝对名称，该 cgroup 用于管理通过标志 <code>--kube-reserved</code>
为 kubernetes 组件所预留的计算资源。例如：<code>"/kube-reserved"</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubeconfig 配置文件的路径，指定如何连接到 API 服务器。
提供 <code>--kubeconfig</code> 将启用 API 服务器模式，而省略 <code>--kubeconfig</code> 将启用独立模式。
</td>
</tr>
<tr>
<td colspan=2>--kubelet-cgroups string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于创建和运行 kubelet 的 cgroup 的绝对名称。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--lock-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> kubelet 使用的锁文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>:0</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
形式为 <code>&lt;file>:&lt;N></code>。
当日志逻辑执行到命中 &lt;file> 的第 &lt;N> 行时，转储调用堆栈。
</td>
</tr>
<tr>
<td colspan=2>--log-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果此值为非空，则在所指定的目录中写入日志文件。
</td>
</tr>
<tr>
<td colspan=2>--log-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果此值非空，使用所给字符串作为日志文件名。
</td>
</tr>
<tr>
<td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置日志文件的最大值。单位为兆字节（M）。如果值为 0，则表示文件大小无限制。
</td>
</tr>
<tr>
<td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>5s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
两次日志刷新之间的最大秒数（默认值为 5s）。
</td>
</tr>
<tr>
<td colspan=2>--logging-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>"text"</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置日志文件格式。可以设置的格式有：<code>"text"</code>、<code>"json"</code>。
非默认的格式不会使用以下标志的配置：<code>--add-dir-header</code>, <code>--alsologtostderr</code>,
<code>--log-backtrace-at</code>, <code>--log-dir</code>, <code>--log-file</code>,
<code>--log-file-max-size</code>, <code>--logtostderr</code>, <code>--skip-headers</code>,
<code>--skip-log-headers</code>, <code>--stderrthreshold</code>, <code>--log-flush-frequency</code>。
非默认选项的其它值都应视为 Alpha 特性，将来出现更改时不会额外警告。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
日志输出到 stderr 而不是文件。
</td>
</tr>
<tr>
<td colspan=2>--make-iptables-util-chains&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示 kubelet 将确保 <code>iptables</code> 规则在主机上存在。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--manifest-url string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于访问要运行的其他 Pod 规范的 URL。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--manifest-url-header string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
取值为由 HTTP 头部组成的逗号分隔列表，在访问 <code>--manifest-url</code> 所给出的 URL 时使用。
名称相同的多个头部将按所列的顺序添加。该参数可以多次使用。例如：
<code>--manifest-url-header 'a:hello,b:again,c:world' --manifest-url-header 'b:beautiful'</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--master-service-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>default</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 向 Pod 注入 Kubernetes 主控服务信息时使用的命名空间。
已弃用：此标志将在未来的版本中删除。
</td>
</tr>
<tr>
<td colspan=2>--max-open-files int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1000000</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 进程可以打开的最大文件数量。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--max-pods int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：110</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此 kubelet 能运行的 Pod 最大数量。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--maximum-dead-containers int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：-1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置全局可保留的已停止容器实例个数上限。
每个实例会占用一些磁盘空间。要禁用，请设置为负数。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--maximum-dead-containers-per-container int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
每个已停止容器可以保留的的最大实例数量。每个容器占用一些磁盘空间。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--minimum-container-ttl-duration duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已结束的容器在被垃圾回收清理之前的最少存活时间。
例如：<code>300ms</code>、<code>10s</code> 或者 <code>2h45m</code>。
已弃用：请改用 <code>--eviction-hard</code> 或者 <code>--eviction-soft</code>。
此标志将在未来的版本中删除。
</td>
</tr>
<tr>
<td colspan=2>--minimum-image-ttl-duration duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>2m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
不再使用的镜像在被垃圾回收清理之前的最少存活时间。
例如：<code>300ms</code>、<code>10s</code> 或者 <code>2h45m</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--network-plugin string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> 设置 kubelet/Pod 生命周期中各种事件调用的网络插件的名称。
仅当容器运行环境设置为 <code>docker</code> 时，此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan=2>--network-plugin-mtu int32</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> 传递给网络插件的 MTU 值，将覆盖默认值。
设置为 0 则使用默认的 MTU 1460。仅当容器运行环境设置为 <code>docker</code> 时，
此特定于 docker 的参数才有效。
</td>
</tr>
<tr>
<td colspan=2>--node-ip string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
节点的 IP 地址。如果设置，kubelet 将使用该 IP 地址作为节点的 IP 地址。
</td>
</tr>
<tr>
<td colspan=2>--node-labels mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> kubelet 在集群中注册本节点时设置的标签。标签以
<code>key=value</code> 的格式表示，多个标签以逗号分隔。名字空间 <code>kubernetes.io</code>
中的标签必须以 <code>kubelet.kubernetes.io</code> 或 <code>node.kubernetes.io</code> 为前缀，
或者在以下明确允许范围内：
<code>beta.kubernetes.io/arch</code>, <code>beta.kubernetes.io/instance-type</code>,
<code>beta.kubernetes.io/os</code>, <code>failure-domain.beta.kubernetes.io/region</code>,
<code>failure-domain.beta.kubernetes.io/zone</code>, <code>kubernetes.io/arch</code>,
<code>kubernetes.io/hostname</code>, <code>kubernetes.io/os</code>,
<code>node.kubernetes.io/instance-type</code>, <code>topology.kubernetes.io/region</code>,
<code>topology.kubernetes.io/zone</code>。
</td>
</tr>
<tr>
<td colspan=2>--node-status-max-images int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：50</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在 <code>node.status.images</code> 中可以报告的最大镜像数量。如果指定为 -1，则不设上限。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--node-status-update-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>10s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 kubelet 向主控节点汇报节点状态的时间间隔。注意：更改此常量时请务必谨慎，
它必须与节点控制器中的 <code>nodeMonitorGracePeriod</code> 一起使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--non-masquerade-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>10.0.0.0/8</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 向该 IP 段之外的 IP 地址发送的流量将使用 IP 伪装技术。
设置为 <code>0.0.0.0/0</code> 则不使用伪装。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--one-output</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置此标志为 <code>true</code>，则仅将日志写入其原来的严重性级别中，
而不是同时将其写入更低严重性级别中。
</td>
</tr>
<tr>
<td colspan=2>--oom-score-adj int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：-999</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 进程的 oom-score-adj 参数值。有效范围为 <code>[-1000，1000]</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--pod-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于给 Pod 分配 IP 地址的 CIDR 地址池，仅在独立运行模式下使用。
在集群模式下，CIDR 设置是从主服务器获取的。对于 IPv6，分配的 IP 的最大数量为 65536。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--pod-infra-container-image string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>k8s.gcr.io/pause:3.2</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
所指定的镜像不会被镜像垃圾收集器删除。
当容器运行环境设置为 <code>docker</code> 时，各个 Pod 中的所有容器都会
使用此镜像中的网络和 IPC 名字空间。
其他 CRI 实现有自己的配置来设置此镜像。
</td>
</tr>
<tr>
<td colspan=2>--pod-manifest-path string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置包含要运行的静态 Pod 的文件的路径，或单个静态 Pod 文件的路径。以点（<code>.</code>）
开头的文件将被忽略。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--pod-max-pids int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：-1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置每个 Pod 中的最大进程数目。如果为 -1，则 kubelet 使用节点可分配的 PID 容量作为默认值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--pods-per-core int32</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 在每个处理器核上可运行的 Pod 数量。此 kubelet 上的 Pod 总数不能超过
<code>--max-pods</code> 标志值。因此，如果此计算结果导致在 kubelet
上允许更多数量的 Pod，则使用 <code>--max-pods</code> 值。值为 0 表示不作限制。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10250</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 服务监听的本机端口号。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--protect-kernel-defaults</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置 kubelet 的默认内核调整行为。如果已设置该参数，当任何内核可调参数与
kubelet 默认值不同时，kubelet 都会出错。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--provider-id string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置主机数据库（即，云驱动）中用来标识节点的唯一标识。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--qos-reserved mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> 设置在指定的 QoS 级别预留的 Pod 资源请求，以一组
<code>"资源名称=百分比"</code> 的形式进行设置，例如 <code>memory=50%</code>。
当前仅支持内存（memory）。要求启用 <code>QOSReserved</code> 特性门控。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--read-only-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10255</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 可以在没有身份验证/鉴权的情况下提供只读服务的端口（设置为 0 表示禁用）。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--really-crash-for-testing</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示发生失效时立即崩溃。仅用于测试。
已弃用：将在未来版本中移除。
</td>
</tr>
<tr>
<td colspan=2>--redirect-container-streaming</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用容器流数据重定向。如果设置为 false，则 kubelet 将在 apiserver 和容器运行时
之间转发容器流数据；如果设置为 true，则 kubelet 将返回指向 apiserver 的 HTTP 重定向信息，
而 apiserver 将直接访问容器运行时。代理方法更安全，但会带来一些开销。
重定向方法性能更高，但安全性较低，因为 apiserver 和容器运行时之间的连接可能未通过身份验证。<br>
已弃用：容器流数据重定向会在 v1.20 中从 kubelet 中移除，此标志会在 v1.22
中移除。
相关信息可参见<a href=http://git.k8s.io/enhancements/keps/sig-node/20191205-container-streaming-requests.md>改进说明</a>。
</td>
</tr>
<tr>
<td colspan=2>--register-node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将本节点注册到 API 服务器。如果未提供 <code>--kubeconfig</code> 标志设置，
则此参数无关紧要，因为 kubelet 将没有要注册的 API 服务器。
</td>
</tr>
<tr>
<td colspan=2>--register-schedulable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
注册本节点为可调度的节点。当 <code>--register-node</code>标志为 false 时此设置无效。
已弃用：此参数将在未来的版本中删除。
</td>
</tr>
<tr>
<td colspan=2>--register-with-taints mapStringString</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置本节点的污点标记，格式为 <code>&lt;key>=&lt;value>:&lt;effect></code>，
以逗号分隔。当 <code>--register-node</code> 为 false 时此标志无效。
已弃用：将在未来版本中移除。
</td>
</tr>
<tr>
<td colspan=2>--registry-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置突发性镜像拉取的个数上限，在不超过 <code>--registration-qps</code> 设置值的前提下
暂时允许此参数所给的镜像拉取个数。仅在 <code>--registry-qps</code> 大于 0 时使用。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--registry-qps int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: 5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如此值大于 0，可用来限制镜像仓库的 QPS 上限。设置为 0，表示不受限制。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--reserved-cpus string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用逗号分隔的一组 CPU 或 CPU 范围列表，给出为系统和 Kubernetes 保留使用的 CPU。
此列表所给出的设置优先于通过 <code>--system-reserved</code> 和
<code>--kube-reskube-reserved</code> 所保留的 CPU 个数配置。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--resolv-conf string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/etc/resolv.conf</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
名字解析服务的配置文件名，用作容器 DNS 解析配置的基础。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--root-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/var/lib/kubelet</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置用于管理 kubelet 文件的根目录（例如挂载卷的相关文件等）。
</td>
</tr>
<tr>
<td colspan=2>--rotate-certificates</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：Beta 特性> 设置当客户端证书即将过期时 kubelet 自动从
<code>kube-apiserver</code> 请求新的证书进行轮换。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--rotate-server-certificates</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当 kubelet 的服务证书即将过期时自动从 kube-apiserver 请求新的证书进行轮换。
要求启用 <code>RotateKubeletServerCertificate</code> 特性门控，以及对提交的
<code>CertificateSigningRequest</code> 对象进行批复（Approve）操作。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--runonce</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 表示从本地清单或远程 URL 创建完 Pod 后立即退出 kubelet 进程。
与 <code>--enable-server</code> 标志互斥。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--runtime-cgroups string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置用于创建和运行容器运行时的 cgroup 的绝对名称。
</td>
</tr>
<tr>
<td colspan=2>--runtime-request-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>2m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置除了长时间运行的请求（包括 <code>pull</code>、<code>logs</code>、<code>exec</code>
和 <code>attach</code> 等操作）之外的其他运行时请求的超时时间。
到达超时时间时，请求会被取消，抛出一个错误并会等待重试。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--seccomp-profile-root string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/var/lib/kubelet/seccomp</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
&lt;警告：alpha 特性> seccomp 配置文件目录。
已弃用：将在 1.23 版本中移除，以使用 <code>&lt;root-dir>/seccomp</code> 目录。
</td>
</tr>
<tr>
<td colspan=2>--serialize-image-pulls&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>true</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
逐一拉取镜像。建议 *不要* 在 docker 守护进程版本低于 1.9 或启用了 Aufs 存储后端的节点上
更改默认值。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--skip-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true 时在日志消息中去掉标头前缀。
</td>
</tr>
<tr>
<td colspan=2>--skip-log-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置为 true，打开日志文件时去掉标头。
</td>
</tr>
<tr>
<td colspan=2>--stderrthreshold int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：2</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置严重程度达到或超过此阈值的日志输出到标准错误输出。
</td>
</tr>
<tr>
<td colspan=2>--streaming-connection-idle-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>4h0m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置流连接在自动关闭之前可以空闲的最长时间。0 表示没有超时限制。
例如：<code>5m</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--sync-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>1m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在运行中的容器与其配置之间执行同步操作的最长时间间隔。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--system-cgroups /</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志值为一个 cgroup 的绝对名称，用于所有尚未放置在根目录下某 cgroup 内的非内核进程。
空值表示不指定 cgroup。回滚该参数需要重启机器。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--system-reserved mapStringString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：无</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
系统预留的资源配置，以一组 <code>资源名称=资源数量</code> 的格式表示，
（例如：<code>cpu=200m,memory=500Mi,ephemeral-storage=1Gi,pid='100'</code>）。
目前仅支持 <code>cpu</code> 和 <code>memory</code> 的设置。
更多细节可参考
<a href=http://kubernetes.io/zh/docs/concepts/configuration/manage-resources-containers/>相关文档</a>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--system-reserved-cgroup string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>""</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志给出一个顶层 cgroup 绝对名称，该 cgroup 用于管理非 kubernetes 组件，
这些组件的计算资源通过 <code>--system-reserved</code> 标志进行预留。
例如 <code>"/system-reserved"</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--tls-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 x509 证书的文件路径，用于 HTTPS 认证。
如果有中间证书，则中间证书要串接在在服务器证书之后。
如果未提供 <code>--tls-cert-file</code> 和 <code>--tls-private-key-file</code>，
kubelet 会为公开地址生成自签名证书和密钥，并将其保存到通过
<code>--cert-dir</code> 指定的目录中。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--tls-cipher-suites string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务器端加密算法列表，以逗号分隔。如果不设置，则使用 Go 语言加密包的默认算法列表。<br>
可选加密算法包括：TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,TLS_ECDHE_RSA_WITH_RC4_128_SHA,TLS_RSA_WITH_3DES_EDE_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_GCM_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_RSA_WITH_AES_256_GCM_SHA384,TLS_RSA_WITH_RC4_128_SHA <br>
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--tls-min-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置支持的最小 TLS 版本号，可选的版本号包括：<code>VersionTLS10</code>、
<code>VersionTLS11</code>、<code>VersionTLS12</code> 和 <code>VersionTLS13</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--tls-private-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含与 <code>--tls-cert-file</code> 对应的 x509 私钥文件路径。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--topology-manager-policy string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>none</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置拓扑管理策略（Topology Manager policy）。可选值包括：<code>none</code>、
<code>best-effort</code>、<code>restricted</code> 和 <code>single-numa-node</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--topology-manager-scope string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>container</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
拓扑提示信息使用范围。拓扑管理器从提示提供者（Hints Providers）处收集提示信息，
并将其应用到所定义的范围以确保 Pod 准入。
可选值包括：<code>container</code>（默认）、<code>pod</code>。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>-v, --v Level</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置 kubelet 日志级别详细程度的数值。
</td>
</tr>
<tr>
<td colspan=2>--version version[=true]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
打印 kubelet 版本信息并退出。
</td>
</tr>
<tr>
<td colspan=2>--vmodule moduleSpec</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
以逗号分隔的 <code>pattern=N</code> 设置列表，用于文件过滤的日志记录
</td>
</tr>
<tr>
<td colspan=2>--volume-plugin-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用来搜索第三方存储卷插件的目录。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
<tr>
<td colspan=2>--volume-stats-agg-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>1m0s</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指定 kubelet 计算和缓存所有 Pod 和卷的磁盘用量总值的时间间隔。要禁用磁盘用量计算，
请设置为 0。
已弃用：应在 <code>--config</code> 所给的配置文件中进行设置。
（<a href=https://kubernetes.io/zh/docs/tasks/administer-cluster/kubelet-config-file/>进一步了解</a>）
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ec8ff2888d36f533a57bc9704ccc84e0>10.3 - kube-apiserver</h1>
<h2 id=简介>简介</h2>
<p>Kubernetes API 服务器验证并配置 API 对象的数据，
这些对象包括 pods、services、replicationcontrollers 等。
API 服务器为 REST 操作提供服务，并为集群的共享状态提供前端，
所有其他组件都通过该前端进行交互。</p>
<pre><code>kube-apiserver [flags]
</code></pre><h2 id=选项>选项</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--add-dir-header</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>如果为 true，则将文件目录添加到日志消息的标题中</p>
</td>
</tr>
<tr>
<td colspan=2>--admission-control-config-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>包含准入控制配置的文件。</p>
</td>
</tr>
<tr>
<td colspan=2>--advertise-address string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>
向集群成员通知 apiserver 消息的 IP 地址。
这个地址必须能够被集群中其他成员访问。
如果 IP 地址为空，将会使用 --bind-address，
如果未指定 --bind-address，将会使用主机的默认接口地址。
</p>
</td>
</tr>
<tr>
<td colspan=2>--allow-metric-labels stringToString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
允许使用的指标标签到指标值的映射列表。键的格式为 &lt;MetricName>,&lt;LabelName>.
值的格式为 &lt;allowed_value>,&lt;allowed_value>...。
例如：<code>metric1,label1='v1,v2,v3', metric1,label2='v1,v2,v3' metric2,label1='v1,v2,v3'</code>。
</p></td>
</tr>
<tr>
<td colspan=2>--allow-privileged</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true, 将允许特权容器。[默认值=false]
</td>
</tr>
<tr>
<td colspan=2>--alsologtostderr</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在向文件输出日志的同时，也将日志写到标准输出。
</td>
</tr>
<tr>
<td colspan=2>--anonymous-auth&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用到 API 服务器的安全端口的匿名请求。
未被其他认证方法拒绝的请求被当做匿名请求。
匿名请求的用户名为 <code>system:anonymous</code>，
用户组名为 </code>system:unauthenticated</code>。
</td>
</tr>
<tr>
<td colspan=2>--api-audiences strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
API 的标识符。
服务帐户令牌验证者将验证针对 API 使用的令牌是否已绑定到这些受众中的至少一个。
如果配置了 <code>--service-account-issuer</code> 标志，但未配置此标志，
则此字段默认为包含发布者 URL 的单个元素列表。
</td>
</tr>
<tr>
<td colspan=2>--apiserver-count int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
集群中运行的 API 服务器数量，必须为正数。
（在启用 --endpoint-reconciler-type=master-count 时使用。）
</td>
</tr>
<tr>
<td colspan=2>--audit-log-batch-buffer-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10000</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
批处理和写入之前用于存储事件的缓冲区大小。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-batch-max-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1</td>
</tr><tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
每个批次的最大大小。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-batch-max-wait duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
强制写入尚未达到最大大小的批次之前要等待的时间。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-batch-throttle-burst int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果之前未使用 ThrottleQPS，则为同时发送的最大请求数。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-batch-throttle-enable</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用了批量限制。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-batch-throttle-qps float</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
每秒的最大平均批次数。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-compress</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
若设置了此标志，则被轮换的日志文件会使用 gzip 压缩。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："json" </td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
所保存的审计格式。
"legacy" 表示每行一个事件的文本格式。"json" 表示结构化的 JSON 格式。
已知格式为 legacy，json。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-maxage int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
根据文件名中编码的时间戳保留旧审计日志文件的最大天数。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-maxbackup int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要保留的旧的审计日志文件个数上限。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-maxsize int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
轮换之前，审计日志文件的最大大小（以兆字节为单位）。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-mode string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："blocking"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用来发送审计事件的策略。
阻塞（blocking）表示发送事件应阻止服务器响应。
批处理（batch）会导致后端异步缓冲和写入事件。
已知的模式是批处理（batch），阻塞（blocking），严格阻塞（blocking-strict）。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-path string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置，则所有到达 API 服务器的请求都将记录到该文件中。
"-" 表示标准输出。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-truncate-enabled</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用事件和批次截断。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-truncate-max-batch-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10485760</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
发送到下层后端的每批次的最大数据量。
实际的序列化大小可能会增加数百个字节。
如果一个批次超出此限制，则将其分成几个较小的批次。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-truncate-max-event-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：102400</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
发送到下层后端的每批次的最大数据量。
如果事件的大小大于此数字，则将删除第一个请求和响应；
如果这样做没有减小足够大的程度，则将丢弃事件。
</td>
</tr>
<tr>
<td colspan=2>--audit-log-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："audit.k8s.io/v1"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于对写入日志的审计事件执行序列化的 API 组和版本。
</td>
</tr>
<tr>
<td colspan=2>--audit-policy-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
定义审计策略配置的文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-batch-buffer-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10000</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
划分批次和写入之前用于存储事件的缓冲区大小。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-batch-max-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：400</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
批次的最大大小。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-batch-max-wait duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
强制写入尚未达到最大大小的批处理之前要等待的时间。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-batch-throttle-burst int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：15</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果之前未使用 ThrottleQPS，同时发送的最大请求数。
仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-batch-throttle-enable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用了批量限制。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-batch-throttle-qps float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
每秒的最大平均批次数。仅在批处理模式下使用。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-config-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
定义审计 webhook 配置的 kubeconfig 格式文件的路径。
</tr>
<tr>
<td colspan=2>--audit-webhook-initial-backoff duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
重试第一个失败的请求之前要等待的时间。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-mode string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："batch"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
发送审计事件的策略。
阻止（Blocking）表示发送事件应阻止服务器响应。
批处理（Batch）导致后端异步缓冲和写入事件。
已知的模式是批处理（batch），阻塞（blocking），严格阻塞（blocking-strict）。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-truncate-enabled</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
是否启用事件和批处理截断。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-truncate-max-batch-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10485760</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
发送到下层后端的批次的最大数据量。
实际的序列化大小可能会增加数百个字节。
如果一个批次超出此限制，则将其分成几个较小的批次。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-truncate-max-event-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：102400</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
发送到下层后端的批次的最大数据量。
如果事件的大小大于此数字，则将删除第一个请求和响应；
如果事件和事件的大小没有减小到一定幅度，则将丢弃事件。
</td>
</tr>
<tr>
<td colspan=2>--audit-webhook-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："audit.k8s.io/v1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于序列化写入 Webhook 的审计事件的 API 组和版本。
</td>
</tr>
<tr>
<td colspan=2>--authentication-token-webhook-cache-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对来自 Webhook 令牌身份验证器的响应的缓存时间。
</td>
</tr>
<tr>
<td colspan=2>--authentication-token-webhook-config-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Webhook 配置的 kubeconfig 格式文件，用于进行令牌认证。
API 服务器将查询远程服务，以对持有者令牌进行身份验证。
</td>
</tr>
<tr>
<td colspan=2>--authentication-token-webhook-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："v1beta1"
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与 Webhook 之间交换 authentication.k8s.io TokenReview 时使用的 API 版本。
</td>
</tr>
<tr>
<td colspan=2>--authorization-mode stringSlice&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："AlwaysAllow"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在安全端口上进行鉴权的插件的顺序列表。
逗号分隔的列表：AlwaysAllow、AlwaysDeny、ABAC、Webhook、RBAC、Node。
</td>
</tr>
<tr>
<td colspan=2>--authorization-policy-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含鉴权策略的文件，其内容为分行 JSON 格式，
在安全端口上与 --authorization-mode=ABAC 一起使用。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-authorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对来自 Webhook 鉴权组件的 “授权（authorized）” 响应的缓存时间。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-unauthorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对来自 Webhook 鉴权模块的 “未授权（unauthorized）” 响应的缓存时间。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-config-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Webhook 配置的文件，其格式为 kubeconfig，
与 --authorization-mode=Webhook 一起使用。
API 服务器将查询远程服务，以对 API 服务器的安全端口的访问执行鉴权。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："v1beta1"</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与 Webhook 之间交换 authorization.k8s.io SubjectAccessReview 时使用的 API 版本。
</td>
</tr>
<tr>
<td colspan=2>--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Azure 容器仓库配置信息的文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--bind-address string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："0.0.0.0"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用来监听 <code>--secure-port</code> 端口的 IP 地址。
集群的其余部分以及 CLI/web 客户端必须可以访问所关联的接口。
如果为空白或未指定地址（<tt>0.0.0.0</tt> 或 <tt>::</tt>），则将使用所有接口。
</td>
</tr>
<tr>
<td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/var/run/kubernetes"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 证书所在的目录。
如果提供了 <code>--tls-cert-file</code> 和 <code>--tls-private-key-file</code>
标志值，则将忽略此标志。
</td>
</tr>
<tr>
<td colspan=2>--client-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果已设置，则使用与客户端证书的 CommonName 对应的标识对任何出示由
client-ca 文件中的授权机构之一签名的客户端证书的请求进行身份验证。
</td>
</tr>
<tr>
<td colspan=2>--cloud-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
云厂商配置文件的路径。空字符串表示无配置文件。
</td>
</tr>
<tr>
<td colspan=2>--cloud-provider string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
云服务提供商。空字符串表示没有云厂商。
</td>
</tr>
<tr>
<td colspan=2>--cloud-provider-gce-l7lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："130.211.0.0/22,35.191.0.0/16"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在 GCE 防火墙中打开 CIDR，以进行第 7 层负载均衡流量代理和健康状况检查。
</td>
</tr>
<tr>
<td colspan=2>--contention-profiling</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果启用了性能分析，则启用锁争用性能分析。
</td>
</tr>
<tr>
<td colspan=2>--cors-allowed-origins strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CORS 允许的来源清单，以逗号分隔。
允许的来源可以是支持子域匹配的正则表达式。
如果此列表为空，则不会启用 CORS。
</td>
</tr>
<tr>
<td colspan=2>--default-not-ready-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：300</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对污点 NotReady:NoExecute 的容忍时长（以秒计）。
默认情况下这一容忍度会被添加到尚未具有此容忍度的每个 pod 中。
</td>
</tr>
<tr>
<td colspan=2>--default-unreachable-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：300</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对污点 Unreachable:NoExecute 的容忍时长（以秒计）
默认情况下这一容忍度会被添加到尚未具有此容忍度的每个 pod 中。
</td>
</tr>
<tr>
<td colspan=2>--default-watch-cache-size int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：100</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
默认监听（watch）缓存大小。
如果为零，则将为没有设置默认监视大小的资源禁用监视缓存。
</td>
</tr>
<tr>
<td colspan=2>--delete-collection-workers int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： 1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为 DeleteCollection 调用而产生的工作线程数。
这些用于加速名字空间清理。
</td>
</tr>
<tr>
<td colspan=2>--disable-admission-plugins strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
尽管位于默认启用的插件列表中（NamespaceLifecycle、LimitRanger、ServiceAccount、TaintNodesByCondition、PodSecurity、Priority、DefaultTolerationSeconds、DefaultStorageClass、StorageObjectInUseProtection、PersistentVolumeClaimResize、RuntimeClass、CertificateApproval、CertificateSigning、CertificateSubjectRestriction、DefaultIngressClass、MutatingAdmissionWebhook、ValidatingAdmissionWebhook、ResourceQuota）仍须被禁用的插件。
<br>取值为逗号分隔的准入插件列表：AlwaysAdmit、AlwaysDeny、AlwaysPullImages、CertificateApproval、CertificateSigning、CertificateSubjectRestriction、DefaultIngressClass、DefaultStorageClass、DefaultTolerationSeconds、DenyServiceExternalIPs、EventRateLimit、ExtendedResourceToleration、ImagePolicyWebhook、LimitPodHardAntiAffinityTopology、LimitRanger、MutatingAdmissionWebhook、NamespaceAutoProvision、NamespaceExists、NamespaceLifecycle、NodeRestriction、OwnerReferencesPermissionEnforcement、PersistentVolumeClaimResize、PersistentVolumeLabel、PodNodeSelector、PodSecurity、PodSecurityPolicy、PodTolerationRestriction、Priority、ResourceQuota、RuntimeClass、SecurityContextDeny、ServiceAccount、StorageObjectInUseProtection、TaintNodesByCondition、ValidatingAdmissionWebhook。
<br>该标志中插件的顺序无关紧要。
</td>
</tr>
<tr>
<td colspan=2>--disabled-metrics strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志为行为不正确的度量指标提供一种处理方案。
你必须提供完全限定的指标名称才能将其禁止。
声明：禁用度量值的行为优先于显示已隐藏的度量值。
</td>
</tr>
<tr>
<td colspan=2>--egress-selector-config-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
带有 API 服务器出站选择器配置的文件。
</td>
</tr>
<tr>
<td colspan=2>--enable-admission-plugins stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
除了默认启用的插件（NamespaceLifecycle、LimitRanger、ServiceAccount、TaintNodesByCondition、PodSecurity、Priority、DefaultTolerationSeconds、DefaultStorageClass、StorageObjectInUseProtection、PersistentVolumeClaimResize、RuntimeClass、CertificateApproval、CertificateSigning、CertificateSubjectRestriction、DefaultIngressClass、MutatingAdmissionWebhook、ValidatingAdmissionWebhook、ResourceQuota）之外要启用的插件
</br>取值为逗号分隔的准入插件列表：AlwaysAdmit、AlwaysDeny、AlwaysPullImages、CertificateApproval、CertificateSigning、CertificateSubjectRestriction、DefaultIngressClass、DefaultStorageClass、DefaultTolerationSeconds、DenyServiceExternalIPs、EventRateLimit、ExtendedResourceToleration、ImagePolicyWebhook、LimitPodHardAntiAffinityTopology、LimitRanger、MutatingAdmissionWebhook、NamespaceAutoProvision、NamespaceExists、NamespaceLifecycle、NodeRestriction、OwnerReferencesPermissionEnforcement、PersistentVolumeClaimResize、PersistentVolumeLabel、PodNodeSelector、PodSecurity、PodSecurityPolicy、PodTolerationRestriction、Priority、ResourceQuota、RuntimeClass、SecurityContextDeny、ServiceAccount、StorageObjectInUseProtection、TaintNodesByCondition、ValidatingAdmissionWebhook
<br>该标志中插件的顺序无关紧要。
</td>
</tr>
<tr>
<td colspan=2>--enable-aggregator-routing</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
允许聚合器将请求路由到端点 IP 而非集群 IP。
</td>
</tr>
<tr>
<td colspan=2>--enable-bootstrap-token-auth</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用以允许将 "kube-system" 名字空间中类型为 "bootstrap.kubernetes.io/token"
的 Secret 用于 TLS 引导身份验证。
</td>
</tr>
<tr>
<td colspan=2>--enable-garbage-collector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用通用垃圾收集器。必须与 kube-controller-manager 的相应标志同步。
</td>
</tr>
<tr>
<td colspan=2>--enable-priority-and-fairness&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true 且启用了 <code>APIPriorityAndFairness</code> 特性门控，
请使用增强的处理程序替换 max-in-flight 处理程序，
以便根据优先级和公平性完成排队和调度。
</td>
</tr>
<tr>
<td colspan=2>--encryption-provider-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含加密提供程序配置信息的文件，用在 etcd 中所存储的 Secret 上。
</td>
</tr>
<tr>
<td colspan=2>--endpoint-reconciler-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："lease"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
使用端点协调器（<code>master-count</code>、<code>lease</code> 或 <code>none</code>）。
</td>
</tr>
<tr>
<td colspan=2>--etcd-cafile string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于保护 etcd 通信的 SSL 证书颁发机构文件。
</td>
</tr>
<tr>
<td colspan=2>--etcd-certfile string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于保护 etcd 通信的 SSL 证书文件。
</td>
</tr>
<tr>
<td colspan=2>--etcd-compaction-interval duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
压缩请求的间隔。
如果为0，则禁用来自 API 服务器的压缩请求。
</td>
</tr>
<tr>
<td colspan=2>--etcd-count-metric-poll-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对每种类型的资源数量轮询 etcd 的频率。
0 值表示禁用度量值收集。
</td>
</tr>
<tr>
<td colspan=2>--etcd-db-metric-poll-interval duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
轮询 etcd 和更新度量值的请求间隔。0 值表示禁用度量值收集。
</td>
</tr>
<tr>
<td colspan=2>--etcd-healthcheck-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
检查 etcd 健康状况时使用的超时时长。
</td>
</tr>
<tr>
<td colspan=2>--etcd-keyfile string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于保护 etcd 通信的 SSL 密钥文件。
</td>
</tr>
<tr>
<td colspan=2>--etcd-prefix string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/registry"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要在 etcd 中所有资源路径之前添加的前缀。
</td>
</tr>
<tr>
<td colspan=2>--etcd-servers strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要连接的 etcd 服务器列表（<code>scheme://ip:port</code>），以逗号分隔。
</td>
</tr>
<tr>
<td colspan=2>--etcd-servers-overrides strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
etcd 服务器针对每个资源的重载设置，以逗号分隔。
单个替代格式：组/资源#服务器（group/resource#servers），
其中服务器是 URL，以分号分隔。
</td>
</tr>
<tr>
<td colspan=2>--event-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1h0m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
事件的保留时长。
</td>
</tr>
<tr>
<td colspan=2>--experimental-logging-sanitization</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[试验性功能] 启用此标志时，被标记为敏感的字段（密码、密钥、令牌）都不会被日志输出。<br>
运行时的日志清理可能会引入相当程度的计算开销，因此不应该在产品环境中启用。
</td>
</tr>
<tr>
<td colspan=2>--external-hostname string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为此主机生成外部化 UR L时要使用的主机名（例如 Swagger API 文档或 OpenID 发现）。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates &lt;逗号分隔的 'key=True|False' 键值对></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>一组 key=value 对，用来描述测试性/试验性功能的特性门控。可选项有：
APIListChunking=true|false (BETA - 默认值=true)<br>
APIPriorityAndFairness=true|false (BETA - 默认值=true)<br>
APIResponseCompression=true|false (BETA - 默认值=true)<br>
APIServerIdentity=true|false (ALPHA - 默认值=false)<br>
APIServerTracing=true|false (ALPHA - 默认值=false)<br>
AllAlpha=true|false (ALPHA - 默认值=false)<br>
AllBeta=true|false (BETA - 默认值=false)<br>
AnyVolumeDataSource=true|false (ALPHA - 默认值=false)<br>
AppArmor=true|false (BETA - 默认值=true)<br>
CPUManager=true|false (BETA - 默认值=true)<br>
CPUManagerPolicyOptions=true|false (ALPHA - 默认值=false)<br>
CSIInlineVolume=true|false (BETA - 默认值=true)<br>
CSIMigration=true|false (BETA - 默认值=true)<br>
CSIMigrationAWS=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureDisk=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureFile=true|false (BETA - 默认值=false)<br>
CSIMigrationGCE=true|false (BETA - 默认值=false)<br>
CSIMigrationOpenStack=true|false (BETA - 默认值=true)<br>
CSIMigrationvSphere=true|false (BETA - 默认值=false)<br>
CSIStorageCapacity=true|false (BETA - 默认值=true)<br>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值=true)<br>
CSIVolumeHealth=true|false (ALPHA - 默认值=false)<br>
CSRDuration=true|false (BETA - 默认值=true)<br>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值=true)<br>
ControllerManagerLeaderMigration=true|false (BETA - 默认值=true)<br>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值=false)<br>
DaemonSetUpdateSurge=true|false (BETA - 默认值=true)<br>
默认值PodTopologySpread=true|false (BETA - 默认值=true)<br>
DelegateFSGroupToCSIDriver=true|false (ALPHA - 默认值=false)<br>
DevicePlugins=true|false (BETA - 默认值=true)<br>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值=true)<br>
DisableCloudProviders=true|false (ALPHA - 默认值=false)<br>
DownwardAPIHugePages=true|false (BETA - 默认值=false)<br>
EfficientWatchResumption=true|false (BETA - 默认值=true)<br>
EndpointSliceTerminatingCondition=true|false (BETA - 默认值=true)<br>
EphemeralContainers=true|false (ALPHA - 默认值=false)<br>
ExpandCSIVolumes=true|false (BETA - 默认值=true)<br>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值=true)<br>
ExpandPersistentVolumes=true|false (BETA - 默认值=true)<br>
ExpandedDNSConfig=true|false (ALPHA - 默认值=false)<br>
ExperimentalHostUserNamespace默认值ing=true|false (BETA - 默认值=false)<br>
GenericEphemeralVolume=true|false (BETA - 默认值=true)<br>
GracefulNodeShutdown=true|false (BETA - 默认值=true)<br>
HPAContainerMetrics=true|false (ALPHA - 默认值=false)<br>
HPAScaleToZero=true|false (ALPHA - 默认值=false)<br>
IPv6DualStack=true|false (BETA - 默认值=true)<br>
InTreePluginAWSUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureDiskUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureFileUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginGCEUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginOpenStackUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginvSphereUnregister=true|false (ALPHA - 默认值=false)<br>
IndexedJob=true|false (BETA - 默认值=true)<br>
IngressClassNamespacedParams=true|false (BETA - 默认值=true)<br>
JobTrackingWithFinalizers=true|false (ALPHA - 默认值=false)<br>
KubeletCredentialProviders=true|false (ALPHA - 默认值=false)<br>
KubeletInUserNamespace=true|false (ALPHA - 默认值=false)<br>
KubeletPodResources=true|false (BETA - 默认值=true)<br>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - 默认值=false)<br>
LocalStorageCapacityIsolation=true|false (BETA - 默认值=true)<br>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值=false)<br>
LogarithmicScaleDown=true|false (BETA - 默认值=true)<br>
MemoryManager=true|false (BETA - 默认值=true)<br>
MemoryQoS=true|false (ALPHA - 默认值=false)<br>
MixedProtocolLBService=true|false (ALPHA - 默认值=false)<br>
NetworkPolicyEndPort=true|false (BETA - 默认值=true)<br>
NodeSwap=true|false (ALPHA - 默认值=false)<br>
NonPreemptingPriority=true|false (BETA - 默认值=true)<br>
PodAffinityNamespaceSelector=true|false (BETA - 默认值=true)<br>
PodDeletionCost=true|false (BETA - 默认值=true)<br>
PodOverhead=true|false (BETA - 默认值=true)<br>
PodSecurity=true|false (ALPHA - 默认值=false)<br>
PreferNominatedNode=true|false (BETA - 默认值=true)<br>
ProbeTerminationGracePeriod=true|false (BETA - 默认值=false)<br>
ProcMountType=true|false (ALPHA - 默认值=false)<br>
ProxyTerminatingEndpoints=true|false (ALPHA - 默认值=false)<br>
QOSReserved=true|false (ALPHA - 默认值=false)<br>
ReadWriteOncePod=true|false (ALPHA - 默认值=false)<br>
RemainingItemCount=true|false (BETA - 默认值=true)<br>
RemoveSelfLink=true|false (BETA - 默认值=true)<br>
RotateKubeletServerCertificate=true|false (BETA - 默认值=true)<br>
Seccomp默认值=true|false (ALPHA - 默认值=false)<br>
ServiceInternalTrafficPolicy=true|false (BETA - 默认值=true)<br>
ServiceLBNodePortControl=true|false (BETA - 默认值=true)<br>
ServiceLoadBalancerClass=true|false (BETA - 默认值=true)<br>
SizeMemoryBackedVolumes=true|false (BETA - 默认值=true)<br>
StatefulSetMinReadySeconds=true|false (ALPHA - 默认值=false)<br>
StorageVersionAPI=true|false (ALPHA - 默认值=false)<br>
StorageVersionHash=true|false (BETA - 默认值=true)<br>
SuspendJob=true|false (BETA - 默认值=true)<br>
TTLAfterFinished=true|false (BETA - 默认值=true)<br>
TopologyAwareHints=true|false (ALPHA - 默认值=false)<br>
TopologyManager=true|false (BETA - 默认值=true)<br>
VolumeCapacityPriority=true|false (ALPHA - 默认值=false)<br>
WinDSR=true|false (ALPHA - 默认值=false)<br>
WinOverlay=true|false (BETA - 默认值=true)<br>
WindowsHostProcessContainers=true|false (ALPHA - 默认值=false)</p>
</td>
</tr>
<tr>
<td colspan=2>--goaway-chance float</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
为防止 HTTP/2 客户端卡在单个 API 服务器上，可启用随机关闭连接（GOAWAY）。
客户端的其他运行中请求将不会受到影响，并且客户端将重新连接，
可能会在再次通过负载平衡器后登陆到其他 API 服务器上。
此参数设置将发送 GOAWAY 的请求的比例。
具有单个 API 服务器或不使用负载平衡器的群集不应启用此功能。
最小值为0（关闭），最大值为 .02（1/50 请求）； 建议使用 .001（1/1000）。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kube-apiserver 的帮助命令
</td>
</tr>
<tr>
<td colspan=2>--http2-max-streams-per-connection int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务器为客户端提供的 HTTP/2 连接中最大流数的限制。
零表示使用 GoLang 的默认值。
</td>
</tr>
<tr>
<td colspan=2>--identity-lease-duration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：3600</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kube-apiserver 租约时长（按秒计），必须是正数。
（当 APIServerIdentity 特性门控被启用时使用此标志值）
</td>
</tr>
<tr>
<td colspan=2>--identity-lease-renew-interval-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kube-apiserver 对其租约进行续期的时间间隔（按秒计），必须是正数。
（当 APIServerIdentity 特性门控被启用时使用此标志值）
</td>
</tr>
<tr>
<td colspan=2>--kubelet-certificate-authority string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
证书颁发机构的证书文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--kubelet-client-certificate string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 的客户端证书文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--kubelet-client-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 客户端密钥文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--kubelet-preferred-address-types strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：Hostname,InternalDNS,InternalIP,ExternalDNS,ExternalIP</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于 kubelet 连接的首选 NodeAddressTypes 列表。
</td>
</tr>
<tr>
<td colspan=2>--kubelet-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kubelet 操作超时时间。
</td>
</tr>
<tr>
<td colspan=2>--kubernetes-service-node-port int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果非零，那么 Kubernetes 主服务（由 apiserver 创建/维护）将是 NodePort 类型，
使用它作为端口的值。
如果为零，则 Kubernetes 主服务将为 ClusterIP 类型。
</td>
</tr>
<tr>
<td colspan=2>--lease-reuse-duration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：60</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
每个租约被重用的时长。
如果此值比较低，可以避免大量对象重用此租约。
注意，如果此值过小，可能导致存储层出现性能问题。
</td>
</tr>
<tr>
<td colspan=2>--livez-grace-period duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此选项代表 API 服务器完成启动序列并生效所需的最长时间。
从 API 服务器的启动时间到这段时间为止，
<tt>/livez</tt> 将假定未完成的启动后钩子将成功完成，因此返回 true。
</td>
</tr>
<tr>
<td colspan=2>--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<tt>:0</tt></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当日志机制执行到'文件 :N'时，生成堆栈跟踪。
</td>
</tr>
<tr>
<td colspan=2>--log-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为非空，则在此目录中写入日志文件。
</td>
</tr>
<tr>
<td colspan=2>--log-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为非空，使用此值作为日志文件。
</td>
</tr>
<tr>
<td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
定义日志文件可以增长到的最大大小。单位为兆字节。
如果值为 0，则最大文件大小为无限制。
</td>
</tr>
<tr>
<td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
两次日志刷新之间的最大秒数
</td>
</tr>
<tr>
<td colspan=2>--logging-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置日志格式。允许的格式："text"。<br>
非默认格式不支持以下标志：<code>--add-dir-header</code>、<code>--alsologtostderr</code>、<code>--log-backtrace-at</code>、<code>--log-dir</code>、<code>--log-file</code>、<code>--log-file-max-size</code>、<code>--logtostderr</code>、<code>--one-output</code>、<code>-skip-headers</code>、<code>-skip-log-headers</code>、<code>--stderrthreshold</code>、<code>-vmodule</code> 和 <code>--log-flush-frequency</code>。<br>
当前非默认选择为 alpha，会随时更改而不会发出警告。
</td>
</tr>
<tr>
<td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在标准错误而不是文件中输出日志记录。
</td>
</tr>
<tr>
<td colspan=2>--master-service-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："default"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已废弃：应该从其中将 Kubernetes 主服务注入到 Pod 中的名字空间。
</td>
</tr>
<tr>
<td colspan=2>--max-connection-bytes-per-sec int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果不为零，则将每个用户连接限制为该数（字节数/秒）。
当前仅适用于长时间运行的请求。
</td>
</tr>
<tr>
<td colspan=2>--max-mutating-requests-inflight int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：200</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果 --enable-priority-and-fairness 为 true，那么此值和 --max-requests-inflight 的和将确定服务器的总并发限制（必须是正数）。
否则，该值限制进行中变更类型请求的最大个数，零表示无限制。
</td>
</tr>
<tr>
<td colspan=2>--max-requests-inflight int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：400</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果 --enable-priority-and-fairness 为 true，那么此值和 --max-mutating-requests-inflight 的和将确定服务器的总并发限制（必须是正数）。
否则，该值限制进行中非变更类型请求的最大个数，零表示无限制。
</td>
</tr>
<tr>
<td colspan=2>--min-request-timeout int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可选字段，表示处理程序在请求超时前，必须保持其处于打开状态的最小秒数。
当前只对监听（Watch）请求的处理程序有效，它基于这个值选择一个随机数作为连接超时值，
以达到分散负载的目的。
</td>
</tr>
<tr>
<td colspan=2>--oidc-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置该值，将会使用 oidc-ca-file 中的机构之一对 OpenID 服务的证书进行验证，
否则将会使用主机的根 CA 对其进行验证。
</td>
</tr>
<tr>
<td colspan=2>--oidc-client-id string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
OpenID 连接客户端的要使用的客户 ID，如果设置了 oidc-issuer-url，则必须设置这个值。
</td>
</tr>
<tr>
<td colspan=2>--oidc-groups-claim string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果提供该值，这个自定义 OpenID 连接声明将被用来设定用户组。
该声明值需要是一个字符串或字符串数组。
此标志为实验性的，请查阅身份认证相关文档进一步了解详细信息。
</td>
</tr>
<tr>
<td colspan=2>--oidc-groups-prefix string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果提供了此值，则所有组都将以该值作为前缀，以防止与其他身份认证策略冲突。
</td>
</tr>
<tr>
<td colspan=2>--oidc-issuer-url string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
OpenID 颁发者 URL，只接受 HTTPS 方案。
如果设置该值，它将被用于验证 OIDC JSON Web Token(JWT)。
</td>
</tr>
<tr>
<td colspan=2>--oidc-required-claim &lt;逗号分隔的 'key=value' 键值对列表></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
描述 ID 令牌中必需声明的键值对。
如果设置此值，则会验证 ID 令牌中存在与该声明匹配的值。
重复此标志以指定多个声明。
</td>
</tr>
<tr>
<td colspan=2>--oidc-signing-algs strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：RS256</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
允许的 JOSE 非对称签名算法的逗号分隔列表。
若 JWT 所带的 "alg" 标头值不在列表中，则该 JWT 将被拒绝。
取值依据 RFC 7518 https://tools.ietf.org/html/rfc7518#section-3.1 定义。
</td>
</tr>
<tr>
<td colspan=2>--oidc-username-claim string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："sub"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要用作用户名的 OpenID 声明。
请注意，除默认声明（"sub"）以外的其他声明不能保证是唯一且不可变的。
此标志是实验性的，请参阅身份认证文档以获取更多详细信息。
</td>
</tr>
<tr>
<td colspan=2>--oidc-username-prefix string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果提供，则所有用户名都将以该值作为前缀。
如果未提供，则除 "email" 之外的用户名声明都会添加颁发者 URL 作为前缀，以避免冲突。
要略过添加前缀处理，请设置值为 "-"。
</td>
</tr>
<tr>
<td colspan=2>--one-output</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志为真时，日志只会被写入到其原生的严重性级别中（而不是同时写到所有较低
严重性级别中）。
</td>
</tr>
<tr>
<td colspan=2>--permit-address-sharing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：false</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
若此标志为 true，则使用 <tt>SO_REUSEADDR</tt> 来绑定端口。
这样设置可以同时绑定到用通配符表示的类似 0.0.0.0 这种 IP 地址，
以及特定的 IP 地址。也可以避免等待内核释放 <tt>TIME_WAIT</tt> 状态的套接字。
</p></td>
</tr>
<tr>
<td colspan=2>--permit-port-sharing&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：false</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则在绑定端口时将使用 <tt>SO_REUSEPORT</tt>，
这样多个实例可以绑定到同一地址和端口上。
</td>
</tr>
<tr>
<td colspan=2>--profiling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
通过 Web 接口 <code>host:port/debug/pprof/</code> 启用性能分析。
</td>
</tr>
<tr>
<td colspan=2>--proxy-client-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当必须调用外部程序以处理请求时，用于证明聚合器或者 kube-apiserver 的身份的客户端证书。
包括代理转发到用户 api-server 的请求和调用 Webhook 准入控制插件的请求。
Kubernetes 期望此证书包含来自于 --requestheader-client-ca-file 标志中所给 CA 的签名。
该 CA 在 kube-system 命名空间的 "extension-apiserver-authentication" ConfigMap 中公开。
从 kube-aggregator 收到调用的组件应该使用该 CA 进行各自的双向 TLS 验证。
</td>
</tr>
<tr>
<td colspan=2>--proxy-client-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当必须调用外部程序来处理请求时，用来证明聚合器或者 kube-apiserver 的身份的客户端私钥。
这包括代理转发给用户 api-server 的请求和调用 Webhook 准入控制插件的请求。
</td>
</tr>
<tr>
<td colspan=2>--request-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可选字段，指示处理程序在超时之前必须保持打开请求的持续时间。
这是请求的默认请求超时，但对于特定类型的请求，可能会被
<code>--min-request-timeout</code>等标志覆盖。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-allowed-names strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此值为客户端证书通用名称（Common Name）的列表；表中所列的表项可以用来提供用户名，
方式是使用 <code>--requestheader-username-headers</code> 所指定的头部。
如果为空，能够通过 <code>--requestheader-client-ca-file</code> 中机构
认证的客户端证书都是被允许的。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-client-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在信任请求头中以 <code>--requestheader-username-headers</code> 指示的用户名之前，
用于验证接入请求中客户端证书的根证书包。
警告：一般不要假定传入请求已被授权。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-extra-headers-prefix strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于查验请求头部的前缀列表。建议使用 <code>X-Remote-Extra-</code>。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-group-headers strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于查验用户组的请求头部列表。建议使用 <code>X-Remote-Group</code>。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-username-headers strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于查验用户名的请求头头列表。建议使用 <code>X-Remote-User</code>。
</td>
</tr>
<tr>
<td colspan=2>--runtime-config &lt;逗号分隔的 'key=value' 对列表></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组启用或禁用内置 API 的键值对。支持的选项包括：
<br>v1=true|false（针对核心 API 组）
<br>&lt;group>/&lt;version>=true|false（针对特定 API 组和版本，例如：apps/v1=true）
<br>api/all=true|false 控制所有 API 版本
<br>api/ga=true|false 控制所有 v[0-9]+ API 版本
<br>api/beta=true|false 控制所有 v[0-9]+beta[0-9]+ API 版本
<br>api/alpha=true|false 控制所有 v[0-9]+alpha[0-9]+ API 版本
<br>api/legacy 已弃用，并将在以后的版本中删除
</td>
</tr>
<tr>
<td colspan=2>--secure-port int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：6443</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
带身份验证和鉴权机制的 HTTPS 服务端口。
不能用 0 关闭。
</td>
</tr>
<tr>
<td colspan=2>--service-account-extend-token-expiration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在生成令牌时，启用投射服务帐户到期时间扩展，
这有助于从旧版令牌安全地过渡到绑定的服务帐户令牌功能。
如果启用此标志，则准入插件注入的令牌的过期时间将延长至 1 年，以防止过渡期间发生意外故障，
并忽略 service-account-max-token-expiration 的值。
</td>
</tr>
<tr>
<td colspan=2>--service-account-issuer strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务帐号令牌颁发者的标识符。
颁发者将在已办法令牌的 "iss" 声明中检查此标识符。
此值为字符串或 URI。
如果根据 OpenID Discovery 1.0 规范检查此选项不是有效的 URI，则即使特性门控设置为 true，
ServiceAccountIssuerDiscovery 功能也将保持禁用状态。
强烈建议该值符合 OpenID 规范：https://openid.net/specs/openid-connect-discovery-1_0.html。
实践中，这意味着 service-account-issuer 取值必须是 HTTPS URL。
还强烈建议此 URL 能够在 {service-account-issuer}/.well-known/openid-configuration
处提供 OpenID 发现文档。
当此值被多次指定时，第一次的值用于生成令牌，所有的值用于确定接受哪些发行人。
</td>
</tr>
<tr>
<td colspan=2>--service-account-jwks-uri string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
覆盖 <code>/.well-known/openid-configuration</code> 提供的发现文档中 JSON Web 密钥集的 URI。
如果发现文档和密钥集是通过 API 服务器外部
（而非自动检测到或被外部主机名覆盖）之外的 URL 提供给依赖方的，则此标志很有用。
仅在启用 ServiceAccountIssuerDiscovery 特性门控的情况下有效。
</td>
</tr>
<tr>
<td colspan=2>--service-account-key-file strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 x509 RSA 或 ECDSA 私钥或公钥的文件，用于验证 ServiceAccount 令牌。
指定的文件可以包含多个键，并且可以使用不同的文件多次指定标志。
如果未指定，则使用 <code>--tls-private-key-file</code>。
提供 <code>--service-account-signing-key</code> 时必须指定。
</td>
</tr>
<tr>
<td colspan=2>--service-account-lookup&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则在身份认证时验证 etcd 中是否存在 ServiceAccount 令牌。
</td>
</tr>
<tr>
<td colspan=2>--service-account-max-token-expiration duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务帐户令牌发布者创建的令牌的最长有效期。
如果请求有效期大于此值的有效令牌请求，将使用此值的有效期颁发令牌。
</td>
</tr>
<tr>
<td colspan=2>--service-account-signing-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含服务帐户令牌颁发者当前私钥的文件的路径。
颁发者将使用此私钥签署所颁发的 ID 令牌。
</td>
</tr>
<tr>
<td colspan=2>--service-cluster-ip-range string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
CIDR 表示的 IP 范围用来为服务分配集群 IP。
此地址不得与指定给节点或 Pod 的任何 IP 范围重叠。
</td>
</tr>
<tr>
<td colspan=2>--service-node-port-range &lt;形式为 'N1-N2' 的字符串>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30000-32767</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
保留给具有 NodePort 可见性的服务的端口范围。
例如："30000-32767"。范围的两端都包括在内。
</td>
</tr>
<tr>
<td colspan=2>--show-hidden-metrics-for-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
你要显示隐藏指标的先前版本。仅先前的次要版本有意义，不允许其他值。
格式为 &lt;major>.&lt;minor>，例如："1.16"。
这种格式的目的是确保你有机会注意到下一个版本是否隐藏了其他指标，
而不是在此之后将它们从发行版中永久删除时感到惊讶。
</td>
</tr>
<tr>
<td colspan=2>--shutdown-delay-duration duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
延迟终止时间。在此期间，服务器将继续正常处理请求。
端点 /healthz 和 /livez 将返回成功，但是 /readyz 立即返回失败。
在此延迟过去之后，将开始正常终止。
这可用于允许负载平衡器停止向该服务器发送流量。
</td>
</tr>
<tr>
<td colspan=2>--skip-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，日志消息中避免标题前缀。
</td>
</tr>
<tr>
<td colspan=2>--skip-log-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则在打开日志文件时避免标题。
</td>
</tr>
<tr>
<td colspan=2>--stderrthreshold int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：2</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将达到或超过此阈值的日志写到标准错误输出
</td>
</tr>
<tr>
<td colspan=2>--storage-backend string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
持久化存储后端。选项："etcd3"（默认）。
</td>
</tr>
<tr>
<td colspan=2>--storage-media-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："application/vnd.kubernetes.protobuf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于在存储中存储对象的媒体类型。
某些资源或存储后端可能仅支持特定的媒体类型，并且将忽略此设置。
</td>
</tr>
<tr>
<td colspan=2>--strict-transport-security-directives strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
为 HSTS 所设置的指令列表，用逗号分隔。
如果此列表为空，则不会添加 HSTS 指令。
例如： 'max-age=31536000,includeSubDomains,preload'
</p></td>
</tr>
<tr>
<td colspan=2>--tls-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含用于 HTTPS 的默认 x509 证书的文件。（CA 证书（如果有）在服务器证书之后并置）。
如果启用了 HTTPS 服务，并且未提供 <code>--tls-cert-file</code> 和
<code>--tls-private-key-file</code>，
为公共地址生成一个自签名证书和密钥，并将其保存到 <code>--cert-dir</code> 指定的目录中。
</td>
</tr>
<tr>
<td colspan=2>--tls-cipher-suites strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务器的密码套件的列表，以逗号分隔。如果省略，将使用默认的 Go 密码套件。
<br>首选值：
TLS_AES_128_GCM_SHA256、TLS_AES_256_GCM_SHA384、TLS_CHACHA20_POLY1305_SHA256、TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256、TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA、TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384、TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305、TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256、TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256、TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384、TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305、TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256、TLS_RSA_WITH_3DES_EDE_CBC_SHA、TLS_RSA_WITH_AES_128_CBC_SHA、TLS_RSA_WITH_AES_128_GCM_SHA256、 TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_GCM_SHA384.
不安全的值有：
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256、TLS_ECDHE_ECDSA_WITH_RC4_128_SHA、TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256、TLS_ECDHE_RSA_WITH_RC4_128_SHA、TLS_RSA_WITH_AES_128_CBC_SHA256、TLS_RSA_WITH_RC4_128_SHA。
</td>
</tr>
<tr>
<td colspan=2>--tls-min-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
支持的最低 TLS 版本。可能的值：VersionTLS10，VersionTLS11，VersionTLS12，VersionTLS13
</td>
</tr>
<tr>
<td colspan=2>--tls-private-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含匹配 <code>--tls-cert-file</code> 的 x509 证书私钥的文件。
</td>
</tr>
<tr>
<td colspan=2>--tls-sni-cert-key string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： []</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一对 x509 证书和私钥文件路径，（可选）后缀为全限定域名的域名模式列表，可以使用带有通配符的前缀。
域模式也允许使用 IP 地址，但仅当 apiserver 对客户端请求的IP地址具有可见性时，才应使用 IP。
如果未提供域模式，则提取证书的名称。
非通配符匹配优先于通配符匹配，显式域模式优先于提取出的名称。
对于多个密钥/证书对，请多次使用 <code>--tls-sni-cert-key</code>。
示例："example.crt,example.key" 或 "foo.crt,foo.key:\*.foo.com,foo.com"。
</td>
</tr>
<tr>
<td colspan=2>--token-auth-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置该值，这个文件将被用于通过令牌认证来保护 API 服务的安全端口。
</td>
</tr>
<tr>
<td colspan=2>--tracing-config-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 API 服务器跟踪配置的文件。
</td>
</tr>
<tr>
<td colspan=2>-v, --v int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
日志级别详细程度的数字。
</td>
</tr>
<tr>
<td colspan=2>--version version[=true]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
打印版本信息并退出
</td>
</tr>
<tr>
<td colspan=2>--vmodule &lt;用逗号分隔的多个 'pattern=N' 配置字符串></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
以逗号分隔的 <code>pattern=N</code> 设置列表，用于文件过滤的日志记录。
</td>
</tr>
<tr>
<td colspan=2>--watch-cache&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在 API 服务器中启用监视缓存。
</td>
</tr>
<tr>
<td colspan=2>--watch-cache-sizes strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
某些资源（Pods、Nodes 等）的监视缓存大小设置，以逗号分隔。
每个资源对应的设置格式：<code>resource[.group]#size</code>，其中
<code>resource</code> 为小写复数（无版本），
对于 apiVersion v1（旧版核心 API）的资源要省略 <code>group</code>，
对其它资源要给出 <code>group</code>；<code>size 为一个数字</code>。
启用 <code>watch-cache</code> 时，此功能生效。
某些资源（<code>replicationcontrollers</code>、<code>endpoints</code>、
<code>nodes</code>、<code>pods</code>、<code>services</code>、
<code>apiservices.apiregistration.k8s.io</code>）
具有通过启发式设置的系统默认值，其他资源默认为
<code>default-watch-cache-size<code>。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8a37271ec8fd36a3a1ce07c4c58533d9>10.4 - kube-controller-manager</h1>
<h2 id=简介>简介</h2>
<p>Kubernetes 控制器管理器是一个守护进程，内嵌随 Kubernetes 一起发布的核心控制回路。
在机器人和自动化的应用中，控制回路是一个永不休止的循环，用于调节系统状态。
在 Kubernetes 中，每个控制器是一个控制回路，通过 API 服务器监视集群的共享状态，
并尝试进行更改以将当前状态转为期望状态。
目前，Kubernetes 自带的控制器例子包括副本控制器、节点控制器、命名空间控制器和服务账号控制器等。</p>
<pre><code>kube-controller-manager [flags]
</code></pre><h2 id=选项>选项</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--add-dir-header</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
若为 true，将文件目录添加到日志消息的头部。
</td>
</tr>
<tr>
<td colspan=2>--allocate-node-cidrs</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
基于云驱动来为 Pod 分配和设置子网掩码。
</td>
</tr>
<tr>
<td colspan=2>--allow-metric-labels stringToString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：""</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
<p>
从度量值标签到准许值列表的映射。键名的格式为&lt;MetricName>,&lt;LabelName>。
准许值的格式为&lt;allowed_value>,&lt;allowed_value>...。
例如，<code>metric1,label1='v1,v2,v3', metric1,label2='v1,v2,v3'
metric2,label='v1,v2,v3'</code>。
</p>
</td>
</tr>
<tr>
<td colspan=2>--alsologtostderr</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在向文件输出日志的同时，也将日志写到标准输出。
</td>
</tr>
<tr>
<td colspan=2>--attach-detach-reconcile-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
协调器（reconciler）在相邻两次对存储卷进行挂载和解除挂载操作之间的等待时间。
此时长必须长于 1 秒钟。此值设置为大于默认值时，可能导致存储卷无法与 Pods 匹配。
</td>
</tr>
<tr>
<td colspan=2>--authentication-kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志值为一个 kubeconfig 文件的路径名。该文件中包含与某 Kubernetes “核心”
服务器相关的信息，并支持足够的权限以创建 tokenreviews.authentication.k8s.io。
此选项是可选的。如果设置为空值，所有令牌请求都会被认作匿名请求，
Kubernetes 也不再在集群中查找客户端的 CA 证书信息。
</td>
</tr>
<tr>
<td colspan=2>--authentication-skip-lookup</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此值为 false 时，通过 authentication-kubeconfig 参数所指定的文件会被用来
检索集群中缺失的身份认证配置信息。
</td>
</tr>
<tr>
<td colspan=2>--authentication-token-webhook-cache-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 Webhook 令牌认证设施返回结果的缓存时长。
</td>
</tr>
<tr>
<td colspan=2>--authentication-tolerate-lookup-failure</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此值为 true 时，即使无法从集群中检索到缺失的身份认证配置信息也无大碍。
需要注意的是，这样设置可能导致所有请求都被视作匿名请求。
</td>
</tr>
<tr>
<td colspan=2>--authorization-always-allow-paths strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/healthz,/readyz,/livez"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
鉴权过程中会忽略的一个 HTTP 路径列表。
换言之，控制器管理器会对列表中路径的访问进行授权，并且无须征得
Kubernetes “核心” 服务器同意。
</td>
</tr>
<tr>
<td colspan=2>--authorization-kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Kubernetes “核心” 服务器信息的 kubeconfig 文件路径，
所包含信息具有创建 subjectaccessreviews.authorization.k8s.io 的足够权限。
此参数是可选的。如果配置为空字符串，未被鉴权模块所忽略的请求都会被禁止。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-authorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 Webhook 形式鉴权组件所返回的“已授权（Authorized）”响应的缓存时长。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-unauthorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 Webhook 形式鉴权组件所返回的“未授权（Unauthorized）”响应的缓存时长。
</td>
</tr>
<tr>
<td colspan=2>--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向包含 Azure 容器仓库配置信息的文件的路径名。
</td>
</tr>
<tr>
<td colspan=2>--bind-address ip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.0.0.0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
针对 <code>--secure-port</code> 端口上请求执行监听操作的 IP 地址。
所对应的网络接口必须从集群中其它位置可访问（含命令行及 Web 客户端）。
如果此值为空或者设定为非特定地址（<code>0.0.0.0</code> 或 <code>::</code>），
意味着所有网络接口都在监听范围。
</td>
</tr>
<tr>
<td colspan=2>--cert-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 证书所在的目录。如果提供了 <code>--tls-cert-file</code> 和
<code>--tls-private-key-file</code>，此标志会被忽略。
</td>
</tr>
<tr>
<td colspan=2>--cidr-allocator-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："RangeAllocator"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要使用的 CIDR 分配器类型。
</td>
</tr>
<tr>
<td colspan=2>--client-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果设置了此标志，对于所有能够提供客户端证书的请求，若该证书由
<code>--client-ca-file</code> 中所给机构之一签署，则该请求会被
成功认证为客户端证书中 CommonName 所标识的实体。
</td>
</tr>
<tr>
<td colspan=2>--cloud-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
云驱动程序配置文件的路径。空字符串表示没有配置文件。
</td>
</tr>
<tr>
<td colspan=2>--cloud-provider string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
云服务的提供者。空字符串表示没有对应的提供者（驱动）。
</td>
</tr>
<tr>
<td colspan=2>--cluster-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
集群中 Pods 的 CIDR 范围。要求 <code>--allocate-node-cidrs</code> 标志为 true。
</td>
</tr>
<tr>
<td colspan=2>--cluster-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kubernetes"</td -->
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
集群实例的前缀。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码格式的 X509 CA 证书的文件名。该证书用来发放集群范围的证书。
如果设置了此标志，则不能指定更具体的<code>--cluster-signing-*</code> 标志。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-duration duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：8760h0m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
所签名证书的有效期限。每个 CSR 可以通过设置 spec.expirationSeconds 来请求更短的证书。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 RSA 或 ECDSA 私钥的文件名。该私钥用来对集群范围证书签名。
若指定了此选项，则不可再设置 <code>--cluster-signing-*</code> 参数。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-kube-apiserver-client-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 X509 CA 证书的文件名，
该证书用于为 kubernetes.io/kube-apiserver-client 签署者颁发证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-kube-apiserver-client-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 RSA 或 ECDSA 私钥的文件名，
该私钥用于为 kubernetes.io/kube-apiserver-client 签署者签名证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-kubelet-client-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 X509 CA 证书的文件名，
该证书用于为 kubernetes.io/kube-apiserver-client-kubelet 签署者颁发证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-kubelet-client-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 RSA 或 ECDSA 私钥的文件名，
该私钥用于为 kubernetes.io/kube-apiserver-client-kubelet 签署者签名证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-kubelet-serving-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 X509 CA 证书的文件名，
该证书用于为 kubernetes.io/kubelet-serving 签署者颁发证书。
如果指定，则不得设置 </code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-kubelet-serving-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 RSA或ECDSA 私钥的文件名，
该私钥用于对 kubernetes.io/kubelet-serving 签署者的证书进行签名。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-legacy-unknown-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 X509 CA 证书的文件名，
用于为 kubernetes.io/legacy-unknown 签署者颁发证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--cluster-signing-legacy-unknown-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 RSA 或 ECDSA 私钥的文件名，
用于为 kubernetes.io/legacy-unknown 签署者签名证书。
如果指定，则不得设置 <code>--cluster-signing-{cert,key}-file</code>。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-deployment-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的 Deployment 对象个数。数值越大意味着对 Deployment 的响应越及时，
同时也意味着更大的 CPU（和网络带宽）压力。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-endpoint-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发执行的 Endpoints 同步操作个数。数值越大意味着更快的 Endpoints 更新操作，
同时也意味着更大的 CPU （和网络）压力。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-gc-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：20</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的垃圾收集工作线程个数。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-namespace-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的 Namespace 对象个数。较大的数值意味着更快的名字空间终结操作，
不过也意味着更多的 CPU （和网络）占用。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-rc-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
可以并发同步的副本控制器对象个数。较大的数值意味着更快的副本管理操作，
不过也意味着更多的 CPU （和网络）占用。
</p></td>
</tr>
<tr>
<td colspan=2>--concurrent-replicaset-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的 ReplicaSet 个数。数值越大意味着副本管理的响应速度越快，
同时也意味着更多的 CPU （和网络）占用。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-resource-quota-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的 ResourceQuota 对象个数。数值越大，配额管理的响应速度越快，
不过对 CPU （和网络）的占用也越高。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-service-endpoint-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发执行的服务端点同步操作个数。数值越大，端点片段（Endpoint Slice）
的更新速度越快，不过对 CPU （和网络）的占用也越高。默认值为 5。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-service-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的 Service 对象个数。数值越大，服务管理的响应速度越快，
不过对 CPU （和网络）的占用也越高。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-serviceaccount-token-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的服务账号令牌对象个数。数值越大，令牌生成的速度越快，
不过对 CPU （和网络）的占用也越高。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-statefulset-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的 StatefulSet 对象个数。数值越大，StatefulSet 管理的响应速度越快，
不过对 CPU （和网络）的占用也越高。
</td>
</tr>
<tr>
<td colspan=2>--concurrent-ttl-after-finished-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可以并发同步的 TTL-after-finished 控制器线程个数。
</td>
</tr>
<tr>
<td colspan=2>--configure-cloud-routes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
决定是否由 <code>--allocate-node-cidrs</code> 所分配的 CIDR 要通过云驱动程序来配置。
</td>
</tr>
<tr>
<td colspan=2>--contention-profiling</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在启用了性能分析（profiling）时，也启用锁竞争情况分析。
</td>
</tr>
<tr>
<td colspan=2>--controller-start-interval duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在两次启动控制器管理器之间的时间间隔。
</td>
</tr>
<tr>
<td colspan=2>--controllers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>[*]</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要启用的控制器列表。<code>\*</code> 表示启用所有默认启用的控制器；
<code>foo</code> 启用名为 foo 的控制器；
<code>-foo</code> 表示禁用名为 foo 的控制器。<br>
控制器的全集：attachdetach、bootstrapsigner、cloud-node-lifecycle、clusterrole-aggregation、cronjob、csrapproving、csrcleaner、csrsigning、daemonset、deployment、disruption、endpoint、endpointslice、endpointslicemirroring、ephemeral-volume、garbagecollector、horizontalpodautoscaling、job、namespace、nodeipam、nodelifecycle、persistentvolume-binder、persistentvolume-expander、podgc、pv-protection、pvc-protection、replicaset、replicationcontroller、resourcequota、root-ca-cert-publisher、route、service、serviceaccount、serviceaccount-token、statefulset、tokencleaner、ttl、ttl-after-finished<br>
默认禁用的控制器有：bootstrapsigner 和 tokencleaner。</td>
</tr>
<tr>
<td colspan=2>--deployment-controller-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
Deployment 资源的同步周期。
</td>
</tr>
<tr>
<td colspan=2>--disable-attach-detach-reconcile-sync</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
禁用卷挂接/解挂调节器的同步。禁用此同步可能导致卷存储与 Pod 之间出现错位。
请小心使用。
</td>
</tr>
<tr>
<td colspan=2>--disabled-metrics strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
此标志提供对行为异常的度量值的防控措施。你必须提供度量值的
完全限定名称才能将其禁用。<b>声明</b>：禁用度量值的操作比显示隐藏度量值
的操作优先级高。
</p></td>
</tr>
<tr>
<td colspan=2>--enable-dynamic-provisioning&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在环境允许的情况下启用动态卷制备。
</td>
</tr>
<tr>
<td colspan=2>--enable-garbage-collector&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
启用通用垃圾收集器。必须与 kube-apiserver 中对应的标志一致。
</td>
</tr>
<tr>
<td colspan=2>--enable-hostpath-provisioner</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在没有云驱动程序的情况下，启用 HostPath 持久卷的制备。
此参数便于对卷供应功能进行开发和测试。HostPath 卷的制备并非受支持的功能特性，
在多节点的集群中也无法工作，因此除了开发和测试环境中不应使用。
</td>
</tr>
<tr>
<td colspan=2>--enable-leader-migration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
此标志决定是否启用控制器领导者迁移。
</p></td>
</tr>
<tr>
<td colspan=2>--enable-taint-manager&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
警告：此为Beta 阶段特性。设置为 true 时会启用 NoExecute 污点，
并在所有标记了此污点的节点上逐出所有无法忍受该污点的 Pods。
</td>
</tr>
<tr>
<td colspan=2>--endpoint-updates-batch-period duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
端点（Endpoint）批量更新周期时长。对 Pods 变更的处理会被延迟，
以便将其与即将到来的更新操作合并，从而减少端点更新操作次数。
较大的数值意味着端点更新的迟滞时间会增长，也意味着所生成的端点版本个数会变少。
</td>
</tr>
<tr>
<td colspan=2>--endpointslice-updates-batch-period duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
端点片段（Endpoint Slice）批量更新周期时长。对 Pods 变更的处理会被延迟，
以便将其与即将到来的更新操作合并，从而减少端点更新操作次数。
较大的数值意味着端点更新的迟滞时间会增长，也意味着所生成的端点版本个数会变少。
</td>
</tr>
<tr>
<td colspan=2>--experimental-logging-sanitization</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[试验性功能] 当启用此标志时，被标记为敏感的字段（密码、密钥、令牌）不会被日志输出。<br>
运行时的日志清理操作可能会引入相当程度的计算开销，因此不应在生产环境中启用。
</td>
</tr>
<tr>
<td colspan=2>--external-cloud-volume-plugin string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当云驱动程序设置为 external 时要使用的插件名称。此字符串可以为空。
只能在云驱动程序为 external 时设置。目前用来保证节点控制器和卷控制器能够
在三种云驱动上正常工作。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates &lt;逗号分隔的 'key=True|False' 对列表></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
<p>
一组 key=value 对，用来描述测试性/试验性功能的特性门控（Feature Gate）。可选项有：
APIListChunking=true|false (BETA - 默认值=true)<br>
APIPriorityAndFairness=true|false (BETA - 默认值=true)<br>
APIResponseCompression=true|false (BETA - 默认值=true)<br>
APIServerIdentity=true|false (ALPHA - 默认值=false)<br>
APIServerTracing=true|false (ALPHA - 默认值=false)<br>
AllAlpha=true|false (ALPHA - 默认值=false)<br>
AllBeta=true|false (BETA - 默认值=false)<br>
AnyVolumeDataSource=true|false (ALPHA - 默认值=false)<br>
AppArmor=true|false (BETA - 默认值=true)<br>
CPUManager=true|false (BETA - 默认值=true)<br>
CPUManagerPolicyOptions=true|false (ALPHA - 默认值=false)<br>
CSIInlineVolume=true|false (BETA - 默认值=true)<br>
CSIMigration=true|false (BETA - 默认值=true)<br>
CSIMigrationAWS=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureDisk=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureFile=true|false (BETA - 默认值=false)<br>
CSIMigrationGCE=true|false (BETA - 默认值=false)<br>
CSIMigrationOpenStack=true|false (BETA - 默认值=true)<br>
CSIMigrationvSphere=true|false (BETA - 默认值=false)<br>
CSIStorageCapacity=true|false (BETA - 默认值=true)<br>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值=true)<br>
CSIVolumeHealth=true|false (ALPHA - 默认值=false)<br>
CSRDuration=true|false (BETA - 默认值=true)<br>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值=true)<br>
ControllerManagerLeaderMigration=true|false (BETA - 默认值=true)<br>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值=false)<br>
DaemonSetUpdateSurge=true|false (BETA - 默认值=true)<br>
默认值PodTopologySpread=true|false (BETA - 默认值=true)<br>
DelegateFSGroupToCSIDriver=true|false (ALPHA - 默认值=false)<br>
DevicePlugins=true|false (BETA - 默认值=true)<br>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值=true)<br>
DisableCloudProviders=true|false (ALPHA - 默认值=false)<br>
DownwardAPIHugePages=true|false (BETA - 默认值=false)<br>
EfficientWatchResumption=true|false (BETA - 默认值=true)<br>
EndpointSliceTerminatingCondition=true|false (BETA - 默认值=true)<br>
EphemeralContainers=true|false (ALPHA - 默认值=false)<br>
ExpandCSIVolumes=true|false (BETA - 默认值=true)<br>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值=true)<br>
ExpandPersistentVolumes=true|false (BETA - 默认值=true)<br>
ExpandedDNSConfig=true|false (ALPHA - 默认值=false)<br>
ExperimentalHostUserNamespace默认值ing=true|false (BETA - 默认值=false)<br>
GenericEphemeralVolume=true|false (BETA - 默认值=true)<br>
GracefulNodeShutdown=true|false (BETA - 默认值=true)<br>
HPAContainerMetrics=true|false (ALPHA - 默认值=false)<br>
HPAScaleToZero=true|false (ALPHA - 默认值=false)<br>
IPv6DualStack=true|false (BETA - 默认值=true)<br>
InTreePluginAWSUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureDiskUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureFileUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginGCEUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginOpenStackUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginvSphereUnregister=true|false (ALPHA - 默认值=false)<br>
IndexedJob=true|false (BETA - 默认值=true)<br>
IngressClassNamespacedParams=true|false (BETA - 默认值=true)<br>
JobTrackingWithFinalizers=true|false (ALPHA - 默认值=false)<br>
KubeletCredentialProviders=true|false (ALPHA - 默认值=false)<br>
KubeletInUserNamespace=true|false (ALPHA - 默认值=false)<br>
KubeletPodResources=true|false (BETA - 默认值=true)<br>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - 默认值=false)<br>
LocalStorageCapacityIsolation=true|false (BETA - 默认值=true)<br>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值=false)<br>
LogarithmicScaleDown=true|false (BETA - 默认值=true)<br>
MemoryManager=true|false (BETA - 默认值=true)<br>
MemoryQoS=true|false (ALPHA - 默认值=false)<br>
MixedProtocolLBService=true|false (ALPHA - 默认值=false)<br>
NetworkPolicyEndPort=true|false (BETA - 默认值=true)<br>
NodeSwap=true|false (ALPHA - 默认值=false)<br>
NonPreemptingPriority=true|false (BETA - 默认值=true)<br>
PodAffinityNamespaceSelector=true|false (BETA - 默认值=true)<br>
PodDeletionCost=true|false (BETA - 默认值=true)<br>
PodOverhead=true|false (BETA - 默认值=true)<br>
PodSecurity=true|false (ALPHA - 默认值=false)<br>
PreferNominatedNode=true|false (BETA - 默认值=true)<br>
ProbeTerminationGracePeriod=true|false (BETA - 默认值=false)<br>
ProcMountType=true|false (ALPHA - 默认值=false)<br>
ProxyTerminatingEndpoints=true|false (ALPHA - 默认值=false)<br>
QOSReserved=true|false (ALPHA - 默认值=false)<br>
ReadWriteOncePod=true|false (ALPHA - 默认值=false)<br>
RemainingItemCount=true|false (BETA - 默认值=true)<br>
RemoveSelfLink=true|false (BETA - 默认值=true)<br>
RotateKubeletServerCertificate=true|false (BETA - 默认值=true)<br>
Seccomp默认值=true|false (ALPHA - 默认值=false)<br>
ServiceInternalTrafficPolicy=true|false (BETA - 默认值=true)<br>
ServiceLBNodePortControl=true|false (BETA - 默认值=true)<br>
ServiceLoadBalancerClass=true|false (BETA - 默认值=true)<br>
SizeMemoryBackedVolumes=true|false (BETA - 默认值=true)<br>
StatefulSetMinReadySeconds=true|false (ALPHA - 默认值=false)<br>
StorageVersionAPI=true|false (ALPHA - 默认值=false)<br>
StorageVersionHash=true|false (BETA - 默认值=true)<br>
SuspendJob=true|false (BETA - 默认值=true)<br>
TTLAfterFinished=true|false (BETA - 默认值=true)<br>
TopologyAwareHints=true|false (ALPHA - 默认值=false)<br>
TopologyManager=true|false (BETA - 默认值=true)<br>
VolumeCapacityPriority=true|false (ALPHA - 默认值=false)<br>
WinDSR=true|false (ALPHA - 默认值=false)<br>
WinOverlay=true|false (BETA - 默认值=true)<br>
WindowsHostProcessContainers=true|false (ALPHA - 默认值=false)
</p>
</td>
</tr>
<tr>
<td colspan=2>--flex-volume-plugin-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/usr/libexec/kubernetes/kubelet-plugins/volume/exec/"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
FlexVolume 插件要搜索第三方卷插件的目录路径全名。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kube-controller-manager 的帮助信息。
</td>
</tr>
<tr>
<td colspan=2>--horizontal-pod-autoscaler-cpu-initialization-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
Pod 启动之后可以忽略 CPU 采样值的时长。
</td>
</tr>
<tr>
<td colspan=2>--horizontal-pod-autoscaler-downscale-stabilization duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
自动扩缩程序的回溯时长。自动扩缩器不会基于在给定的时长内所建议的规模
对负载执行规模缩小的操作。
</td>
</tr>
<tr>
<td colspan=2>--horizontal-pod-autoscaler-initial-readiness-delay duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
Pod 启动之后，在此值所给定的时长内，就绪状态的变化都不会作为初始的就绪状态。
</td>
</tr>
<tr>
<td colspan=2>--horizontal-pod-autoscaler-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：15s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
水平 Pod 扩缩器对 Pods 数目执行同步操作的周期。
</td>
</tr>
<tr>
<td colspan=2>--horizontal-pod-autoscaler-tolerance float&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此值为目标值与实际值的比值与 1.0 的差值。只有超过此标志所设的阈值时，
HPA 才会考虑执行缩放操作。
</td>
</tr>
<tr>
<td colspan=2>--http2-max-streams-per-connection int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务器为客户端所设置的 HTTP/2 连接中流式连接个数上限。
此值为 0 表示采用 Go 语言库所设置的默认值。
</td>
</tr>
<tr>
<td colspan=2>--kube-api-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与 Kubernetes API 服务器通信时突发峰值请求个数上限。
</td>
</tr>
<tr>
<td colspan=2>--kube-api-content-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："application/vnd.kubernetes.protobuf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
向 API 服务器发送请求时使用的内容类型（Content-Type）。
</td>
</tr>
<tr>
<td colspan=2>--kube-api-qps float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：20</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
与 API 服务器通信时每秒请求数（QPS）限制。
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向 kubeconfig 文件的路径。该文件中包含主控节点位置以及鉴权凭据信息。
</td>
</tr>
<tr>
<td colspan=2>--large-cluster-size-threshold int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：50</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
节点控制器在执行 Pod 逐出操作逻辑时，基于此标志所设置的节点个数阈值来判断
所在集群是否为大规模集群。当集群规模小于等于此规模时，
<code>--secondary-node-eviction-rate</code> 会被隐式重设为 0。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在执行主循环之前，启动领导选举（Leader Election）客户端，并尝试获得领导者身份。
在运行多副本组件时启用此标志有助于提高可用性。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-lease-duration duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：15s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于未获得领导者身份的节点，在探测到领导者身份需要更迭时需要等待
此标志所设置的时长，才能尝试去获得曾经是领导者但尚未续约的席位。
本质上，这个时长也是现有领导者节点在被其他候选节点替代之前可以停止
的最长时长。只有集群启用了领导者选举机制时，此标志才起作用。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-renew-deadline duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当前执行领导者角色的节点在被停止履行领导职责之前可多次尝试续约领导者身份；
此标志给出相邻两次尝试之间的间歇时长。
此值必须小于或等于租期时长（Lease Duration）。
仅在集群启用了领导者选举时有效。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-resource-lock string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："leases"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在领导者选举期间用于锁定的资源对象的类型。 支持的选项为 "endpoints"、
"configmaps"、"leases"、"endpointsleases" 和 "configmapsleases"。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-resource-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kube-controller-manager"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在领导者选举期间，用来执行锁操作的资源对象名称。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-resource-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kube-system"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在领导者选举期间，用来执行锁操作的资源对象的名字空间。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-retry-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：2s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
尝试获得领导者身份时，客户端在相邻两次尝试之间要等待的时长。
此标志仅在启用了领导者选举的集群中起作用。
</td>
</tr>
<tr>
<td colspan=2>--leader-migration-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
控制器领导者迁移所用的配置文件路径。
此值为空意味着使用控制器管理器的默认配置。
配置文件应该是 <code>controllermanager.config.k8s.io</code> 组、
<code>v1alpha1</code> 版本的 <code>LeaderMigrationConfiguration</code> 结构。
</p></td>
</tr>
<tr>
<td colspan=2>--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>:0</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当执行到 <code>file:N</code> 所给的文件和代码行时，日志机制会生成一个调用栈快照。
</td>
</tr>
<tr>
<td colspan=2>--log-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志为非空字符串时，日志文件会写入到所给的目录中。
</td>
</tr>
<tr>
<td colspan=2>--log-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志为非空字符串时，意味着日志会写入到所给的文件中。
</td>
</tr>
<tr>
<td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
定义日志文件大小的上限。单位是兆字节（MB）。
若此值为 0，则不对日志文件尺寸进行约束。
</td>
</tr>
<tr>
<td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将内存中日志数据清除到日志文件中时，相邻两次清除操作之间最大间隔秒数。
</td>
</tr>
<tr>
<td colspan=2>--logging-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："text"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置日志格式。允许的格式："text"。
<br>非默认格式不支持以下标志：<code>--add-dir-header</code>、
<code>--alsologtostderr</code>》、<code>--log-backtrace-at</code>、
<code>--log-dir</code>、<code>--log-file</code>、<code>--log-file-max-size</code>、
<code>--logtostderr</code>、<code>--one-output</code>、<code>--skip-headers</code>、
<code>--skip-log-headers</code>、<code>--stderrthreshold</code>、
<code>--vmodule</code>、<code>--log-flush-frequency</code>。
<br>当前非默认选项为 Alpha 阶段，如有更改，恕不另行通知。
</td>
</tr>
<tr>
<td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
将日志写出到标准错误输出（stderr）而不是写入到日志文件。
</td>
</tr>
<tr>
<td colspan=2>--master string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
Kubernetes API 服务器的地址。此值会覆盖 kubeconfig 文件中所给的地址。
</td>
</tr>
<tr>
<td colspan=2>--max-endpoints-per-slice int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：100</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
每个 EndpointSlice 中可以添加的端点个数上限。每个片段中端点个数越多，
得到的片段个数越少，但是片段的规模会变得更大。默认值为 100。
</td>
</tr>
<tr>
<td colspan=2>--min-resync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：12h0m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
自省程序的重新同步时隔下限。实际时隔长度会在 <code>min-resync-period</code> 和
<code>2 * min-resync-period</code> 之间。
</td>
</tr>
<tr>
<td colspan=2>--mirroring-concurrent-service-endpoint-syncs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
EndpointSliceMirroring 控制器将同时执行的服务端点同步操作数。
较大的数量 = 更快的端点切片更新，但 CPU（和网络）负载更多。 默认为 5。
</td>
</tr>
<tr>
<td colspan=2>--mirroring-endpointslice-updates-batch-period duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
EndpointSlice 的长度更新了 EndpointSliceMirroring 控制器的批处理周期。
EndpointSlice 更改的处理将延迟此持续时间，
以使它们与潜在的即将进行的更新结合在一起，并减少 EndpointSlice 更新的总数。
较大的数量 = 较高的端点编程延迟，但是生成的端点修订版本数量较少
</td>
</tr>
<tr>
<td colspan=2>--mirroring-max-endpoints-per-subset int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1000</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
EndpointSliceMirroring 控制器将添加到 EndpointSlice 的最大端点数。
每个分片的端点越多，端点分片越少，但资源越大。
</td>
</tr>
<tr>
<td colspan=2>--namespace-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对名字空间对象进行同步的周期。
</td>
</tr>
<tr>
<td colspan=2>--node-cidr-mask-size int32</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
集群中节点 CIDR 的掩码长度。对 IPv4 而言默认为 24；对 IPv6 而言默认为 64。
</td>
</tr>
<tr>
<td colspan=2>--node-cidr-mask-size-ipv4 int32</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在双堆栈（同时支持 IPv4 和 IPv6）的集群中，节点 IPV4 CIDR 掩码长度。默认为 24。
</td>
</tr>
<tr>
<td colspan=2>--node-cidr-mask-size-ipv6 int32</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在双堆栈（同时支持 IPv4 和 IPv6）的集群中，节点 IPv6 CIDR 掩码长度。默认为 64。
</td>
</tr>
<tr>
<td colspan=2>--node-eviction-rate float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当某区域变得不健康，节点失效时，每秒钟可以从此标志所设定的节点
个数上删除 Pods。请参阅 <code>--unhealthy-zone-threshold</code>
以了解“健康”的判定标准。这里的区域（zone）在集群并不跨多个区域时
指的是整个集群。
</td>
</tr>
<tr>
<td colspan=2>--node-monitor-grace-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：40s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在将一个 Node 标记为不健康之前允许其无响应的时长上限。
必须比 kubelet 的 nodeStatusUpdateFrequency 大 N 倍；
这里 N 指的是 kubelet 发送节点状态的重试次数。
</td>
</tr>
<tr>
<td colspan=2>--node-monitor-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
节点控制器对节点状态进行同步的重复周期。
</td>
</tr>
<tr>
<td colspan=2>--node-startup-grace-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在节点启动期间，节点可以处于无响应状态；
但超出此标志所设置的时长仍然无响应则该节点被标记为不健康。
</td>
</tr>
<tr>
<td colspan=2>--one-output</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果此标志为 true，则仅将日志写入其自身的严重性级别（而不是同时写入更低的严重性级别中）。
</td>
</tr>
<tr>
<td colspan=2>--permit-address-sharing</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果此标志为 true，则在绑定端口时使用 <code>SO_REUSEADDR</code>。
这就意味着可以同时绑定到 <code>0.0.0.0</code> 和特定的 IP 地址，
并且避免等待内核释放处于 <code>TIME_WAITE</code> 状态的套接字。
</p></td>
</tr>
<tr>
<td colspan=2>--permit-port-sharing</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则在绑定端口时将使用 <code>SO_REUSEPORT</code>，
这允许多个实例在同一地址和端口上进行绑定。
</td>
</tr>
<tr>
<td colspan=2>--pod-eviction-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在失效的节点上删除 Pods 时为其预留的宽限期。
</td>
</tr>
<tr>
<td colspan=2>--profiling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
通过位于 <code>host:port/debug/pprof/</code> 的 Web 接口启用性能分析。
</td>
</tr>
<tr>
<td colspan=2>--pv-recycler-increment-timeout-nfs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
NFS 清洗 Pod 在清洗用过的卷时，根据此标志所设置的秒数，为每清洗 1 GiB 数据
增加对应超时时长，作为 activeDeadlineSeconds。
</td>
</tr>
<tr>
<td colspan=2>--pv-recycler-minimum-timeout-hostpath int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：60</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对于 HostPath 回收器 Pod，设置其 activeDeadlineSeconds 参数下限。
此参数仅用于开发和测试目的，不适合在多节点集群中使用。
</td>
</tr>
<tr>
<td colspan=2>--pv-recycler-minimum-timeout-nfs int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：300</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
NFS 回收器 Pod 要使用的 activeDeadlineSeconds 参数下限。
</td>
</tr>
<tr>
<td colspan=2>--pv-recycler-pod-template-filepath-hostpath string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 HostPath 持久卷进行回收利用时，用作模版的 Pod 定义文件所在路径。
此标志仅用于开发和测试目的，不适合多节点集群中使用。
</td>
</tr>
<tr>
<td colspan=2>--pv-recycler-pod-template-filepath-nfs string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对 NFS 卷执行回收利用时，用作模版的 Pod 定义文件所在路径。
</td>
</tr>
<tr>
<td colspan=2>--pv-recycler-timeout-increment-hostpath int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
HostPath 清洗器 Pod 在清洗对应类型持久卷时，为每 GiB 数据增加此标志所设置的秒数，
作为其 activeDeadlineSeconds 参数。此标志仅用于开发和测试环境，不适合多节点集群环境。
</td>
</tr>
<tr>
<td colspan=2>--pvclaimbinder-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：15s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
持久卷（PV）和持久卷申领（PVC）对象的同步周期。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-allowed-names strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
标志值是客户端证书中的 Common Names 列表。其中所列的名称可以通过
<code>--requestheader-username-headers</code> 所设置的 HTTP 头部来提供用户名。
如果此标志值为空表，则被 <code>--requestheader-client-ca-file</code>
中机构所验证过的所有客户端证书都是允许的。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-client-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
根证书包文件名。在信任通过 <code>--requestheader-username-headers</code>
所指定的任何用户名之前，要使用这里的证书来检查请求中的客户证书。
警告：一般不要依赖对请求所作的鉴权结果。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-extra-headers-prefix strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>"x-remote-extra-"</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要插入的请求头部前缀。建议使用 <code>X-Remote-Exra-</code>。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-group-headers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>"x-remote-group"</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用来检查用户组名的请求头部名称列表。建议使用 <code>X-Remote-Group</code>。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-username-headers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>"x-remote-user"</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用来检查用户名的请求头部名称列表。建议使用 <code>X-Remote-User</code>。
</td>
</tr>
<tr>
<td colspan=2>--resource-quota-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对系统中配额用量信息进行同步的周期。
</td>
</tr>
<tr>
<td colspan=2>--root-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果此标志非空，则在服务账号的令牌 Secret 中会包含此根证书机构。
所指定标志值必须是一个合法的 PEM 编码的 CA 证书包。
</td>
</tr>
<tr>
<td colspan=2>--route-reconciliation-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
对云驱动为节点所创建的路由信息进行调解的周期。
</td>
</tr>
<tr>
<td colspan=2>--secondary-node-eviction-rate float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.01</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当区域不健康，节点失效时，每秒钟从此标志所给的节点个数上删除 Pods。
参见 <code>--unhealthy-zone-threshold</code> 以了解“健康与否”的判定标准。
在只有一个区域的集群中，区域指的是整个集群。如果集群规模小于
<code>--large-cluster-size-threshold</code> 所设置的节点个数时，
此值被隐式地重设为 0。
</td>
</tr>
<tr>
<td colspan=2>--secure-port int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10257</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在此端口上提供 HTTPS 身份认证和鉴权操作。若此标志值为 0，则不提供 HTTPS 服务。
</td>
</tr>
<tr>
<td colspan=2>--service-account-private-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 PEM 编码的 RSA 或 ECDSA 私钥数据的文件名，这些私钥用来对服务账号令牌签名。
</td>
</tr>
<tr>
<td colspan=2>--service-cluster-ip-range string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
集群中 Service 对象的 CIDR 范围。要求 <code>--allocate-node-cidrs</code> 标志为 true。
</td>
</tr>
<tr>
<td colspan=2>--show-hidden-metrics-for-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
你希望展示隐藏度量值的上一个版本。只有上一个次版本号有意义，其他值都是不允许的。
字符串格式为 "&lt;major>.&lt;minor>"。例如："1.16"。
此格式的目的是确保你能够有机会注意到下一个版本隐藏了一些额外的度量值，
而不是在更新版本中某些度量值被彻底删除时措手不及。
</td>
</tr>
<tr>
<td colspan=2>--skip-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
若此标志为 true，则在日志消息中避免写入头部前缀信息。
</td>
</tr>
<tr>
<td colspan=2>--skip-log-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
若此标志为 true，则在写入日志文件时避免写入头部信息。
</td>
</tr>
<tr>
<td colspan=2>--stderrthreshold severity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：2</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
等于或大于此阈值的日志信息会被写入到标准错误输出（stderr）。
</td>
</tr>
<tr>
<td colspan=2>--terminated-pod-gc-threshold int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：12500</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在已终止 Pods 垃圾收集器删除已终止 Pods 之前，可以保留的已删除
Pods 的个数上限。若此值小于等于 0，则相当于禁止垃圾回收已终止的 Pods。
</td>
</tr>
<tr>
<td colspan=2>--tls-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 HTTPS 所用的默认 X509 证书的文件。如果有 CA 证书，会被串接在服务器证书之后。
若启用了 HTTPS 服务且 <code>--tls-cert-file</code> 和 <code>--tls-private-key-file</code>
标志未设置，
则为节点的公开地址生成自签名的证书和密钥，并保存到 <code>--cert-dir</code>
所给的目录中。
</td>
</tr>
<tr>
<td colspan=2>--tls-cipher-suites strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
供服务器使用的加密包的逗号分隔列表。若忽略此标志，则使用 Go 语言默认的加密包。<br>
可选值包括：TLS_AES_128_GCM_SHA256、TLS_AES_256_GCM_SHA384、TLS_CHACHA20_POLY1305_SHA256、TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256、TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA、TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384、TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305、TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256、TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256、TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384、TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305、TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256、TLS_RSA_WITH_3DES_EDE_CBC_SHA、TLS_RSA_WITH_AES_128_CBC_SHA、TLS_RSA_WITH_AES_128_GCM_SHA256、TLS_RSA_WITH_AES_256_CBC_SHA、TLS_RSA_WITH_AES_256_GCM_SHA384.
<br>不安全的值: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256、TLS_ECDHE_ECDSA_WITH_RC4_128_SHA、TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256、TLS_ECDHE_RSA_WITH_RC4_128_SHA、TLS_RSA_WITH_AES_128_CBC_SHA256、TLS_RSA_WITH_RC4_128_SHA
</td>
</tr>
<tr>
<td colspan=2>--tls-min-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
可支持的最低 TLS 版本。可选值包括：
“VersionTLS10”、“VersionTLS11”、“VersionTLS12”、“VersionTLS13”。
</td>
</tr>
<tr>
<td colspan=2>--tls-private-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含与 <code>--tls-cert-file</code> 对应的默认 X509 私钥的文件。
</td>
</tr>
<tr>
<td colspan=2>--tls-sni-cert-key namedCertKey&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：[]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
X509 证书和私钥文件路径的耦对。作为可选项，可以添加域名模式的列表，
其中每个域名模式都是可以带通配片段前缀的全限定域名（FQDN）。
域名模式也可以使用 IP 地址字符串，不过只有 API 服务器在所给 IP 地址上
对客户端可见时才可以使用 IP 地址。在未提供域名模式时，从证书中提取域名。
如果有非通配方式的匹配，则优先于通配方式的匹配；显式的域名模式优先于提取的域名。
当存在多个密钥/证书耦对时，可以多次使用 <code>--tls-sni-cert-key</code> 标志。
例如：<code>example.crt,example.key</code> 或 <code>foo.crt,foo.key:\*.foo.com,foo.com</code>。
</td>
</tr>
<tr>
<td colspan=2>--unhealthy-zone-threshold float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.55</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
仅当给定区域中处于非就绪状态的节点（最少 3 个）的占比高于此值时，
才将该区域视为不健康。
</td>
</tr>
<tr>
<td colspan=2>--use-service-account-credentials</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当此标志为 true 时，为每个控制器单独使用服务账号凭据。
</td>
</tr>
<tr>
<td colspan=2>-v, --v int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
日志级别详细程度取值。
</td>
</tr>
<tr>
<td colspan=2>--version version[=true]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
打印版本信息之后退出。
</td>
</tr>
<tr>
<td colspan=2>--vmodule &lt;逗号分隔的 'pattern=N' 配置值></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
由逗号分隔的列表，每一项都是 pattern=N 格式，用来执行根据文件过滤的日志行为。
</td>
</tr>
<tr>
<td colspan=2>--volume-host-allow-local-loopback&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
此标志为 false 时，禁止本地回路 IP 地址和 <code>--volume-host-cidr-denylist</code>
中所指定的 CIDR 范围。
</td>
</tr>
<tr>
<td colspan=2>--volume-host-cidr-denylist strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用逗号分隔的一个 CIDR 范围列表，禁止使用这些地址上的卷插件。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a727de6cb5a090d5f115f88a8606c438>10.5 - kube-proxy</h1>
<h2 id=简介>简介</h2>
<p>Kubernetes 网络代理在每个节点上运行。网络代理反映了每个节点上 Kubernetes API
中定义的服务，并且可以执行简单的 TCP、UDP 和 SCTP 流转发，或者在一组后端进行
循环 TCP、UDP 和 SCTP 转发。
当前可通过 Docker-links-compatible 环境变量找到服务集群 IP 和端口，
这些环境变量指定了服务代理打开的端口。
有一个可选的插件，可以为这些集群 IP 提供集群 DNS。
用户必须使用 apiserver API 创建服务才能配置代理。</p>
<pre><code>kube-proxy [flags]
</code></pre><h2 id=选项>选项</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--add-dir-header</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
若此标志为 true，则将文件目录添加到日志消息的头部。
</p></td>
</tr>
<tr>
<td colspan=2>--alsologtostderr</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
将日志输出到文件时也输出到标准错误输出（stderr）。
</p></td>
</tr>
<tr>
<td colspan=2>--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
包含 Azure 容器仓库配置信息的文件的路径。
</p>
</td>
</tr>
<tr>
<td colspan=2>--bind-address 0.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.0.0.0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
代理服务器要使用的 IP 地址（设置为 '0.0.0.0' 表示要使用所有 IPv4 接口；
设置为 '::' 表示使用所有 IPv6 接口）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--bind-address-hard-fail</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
若此标志为 true，kube-proxy 会将无法绑定端口的失败操作视为致命错误并退出。
</p></td>
</tr>
<tr>
<td colspan=2>--boot-id-file string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/proc/sys/kernel/random/boot_id"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
用来检查 Boot-ID 的文件名，用逗号隔开。
第一个存在的文件会被使用。
</p></td>
</tr>
<tr>
<td colspan=2>--cleanup</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果为 true，清理 iptables 和 ipvs 规则并退出。
</p>
</td>
</tr>
<tr>
<td colspan=2>--cluster-cidr string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
集群中 Pod 的 CIDR 范围。配置后，将从该范围之外发送到服务集群 IP
的流量被伪装，从 Pod 发送到外部 LoadBalancer IP 的流量将被重定向
到相应的集群 IP。
</p>
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
配置文件的路径。
</p>
</td>
</tr>
<tr>
<td colspan=2>--config-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：15m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
来自 apiserver 的配置的刷新频率。必须大于 0。
</p>
</td>
</tr>
<tr>
<td colspan=2>--conntrack-max-per-core int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：32768</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
每个 CPU 核跟踪的最大 NAT 连接数（0 表示保留当前限制并忽略 conntrack-min 设置）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--conntrack-min int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：131072</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
无论 <code>conntrack-max-per-core</code> 多少，要分配的 conntrack
条目的最小数量（将 <code>conntrack-max-per-core</code> 设置为 0 即可
保持当前的限制）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--conntrack-tcp-timeout-close-wait duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1h0m0s
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
处于 <code>CLOSE_WAIT</code> 状态的 TCP 连接的 NAT 超时。
</p>
</td>
</tr>
<tr>
<td colspan=2>--conntrack-tcp-timeout-established duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：24h0m0s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
已建立的 TCP 连接的空闲超时（0 保持当前设置）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--detect-local-mode LocalMode</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
用于检测本地流量的模式。
</p>
</td>
</tr>
<tr>
<td colspan=2>--feature-gates &lt;逗号分隔的 'key=True|False' 对’></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
一组键=值（key=value）对，描述了 alpha/experimental 的特征。可选项有：
APIListChunking=true|false (BETA - 默认值=true)<br>
APIPriorityAndFairness=true|false (BETA - 默认值=true)<br>
APIResponseCompression=true|false (BETA - 默认值=true)<br>
APIServerIdentity=true|false (ALPHA - 默认值=false)<br>
APIServerTracing=true|false (ALPHA - 默认值=false)<br>
AllAlpha=true|false (ALPHA - 默认值=false)<br>
AllBeta=true|false (BETA - 默认值=false)<br>
AnyVolumeDataSource=true|false (ALPHA - 默认值=false)<br>
AppArmor=true|false (BETA - 默认值=true)<br>
CPUManager=true|false (BETA - 默认值=true)<br>
CPUManagerPolicyOptions=true|false (ALPHA - 默认值=false)<br>
CSIInlineVolume=true|false (BETA - 默认值=true)<br>
CSIMigration=true|false (BETA - 默认值=true)<br>
CSIMigrationAWS=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureDisk=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureFile=true|false (BETA - 默认值=false)<br>
CSIMigrationGCE=true|false (BETA - 默认值=false)<br>
CSIMigrationOpenStack=true|false (BETA - 默认值=true)<br>
CSIMigrationvSphere=true|false (BETA - 默认值=false)<br>
CSIStorageCapacity=true|false (BETA - 默认值=true)<br>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值=true)<br>
CSIVolumeHealth=true|false (ALPHA - 默认值=false)<br>
CSRDuration=true|false (BETA - 默认值=true)<br>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值=true)<br>
ControllerManagerLeaderMigration=true|false (BETA - 默认值=true)<br>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值=false)<br>
DaemonSetUpdateSurge=true|false (BETA - 默认值=true)<br>
DefaultPodTopologySpread=true|false (BETA - 默认值=true)<br>
DelegateFSGroupToCSIDriver=true|false (ALPHA - 默认值=false)<br>
DevicePlugins=true|false (BETA - 默认值=true)<br>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值=true)<br>
DisableCloudProviders=true|false (ALPHA - 默认值=false)<br>
DownwardAPIHugePages=true|false (BETA - 默认值=false)<br>
EfficientWatchResumption=true|false (BETA - 默认值=true)<br>
EndpointSliceTerminatingCondition=true|false (BETA - 默认值=true)<br>
EphemeralContainers=true|false (ALPHA - 默认值=false)<br>
ExpandCSIVolumes=true|false (BETA - 默认值=true)<br>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值=true)<br>
ExpandPersistentVolumes=true|false (BETA - 默认值=true)<br>
ExpandedDNSConfig=true|false (ALPHA - 默认值=false)<br>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - 默认值=false)<br>
GenericEphemeralVolume=true|false (BETA - 默认值=true)<br>
GracefulNodeShutdown=true|false (BETA - 默认值=true)<br>
HPAContainerMetrics=true|false (ALPHA - 默认值=false)<br>
HPAScaleToZero=true|false (ALPHA - 默认值=false)<br>
IPv6DualStack=true|false (BETA - 默认值=true)<br>
InTreePluginAWSUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureDiskUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureFileUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginGCEUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginOpenStackUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginvSphereUnregister=true|false (ALPHA - 默认值=false)<br>
IndexedJob=true|false (BETA - 默认值=true)<br>
IngressClassNamespacedParams=true|false (BETA - 默认值=true)<br>
JobTrackingWithFinalizers=true|false (ALPHA - 默认值=false)<br>
KubeletCredentialProviders=true|false (ALPHA - 默认值=false)<br>
KubeletInUserNamespace=true|false (ALPHA - 默认值=false)<br>
KubeletPodResources=true|false (BETA - 默认值=true)<br>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - 默认值=false)<br>
LocalStorageCapacityIsolation=true|false (BETA - 默认值=true)<br>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值=false)<br>
LogarithmicScaleDown=true|false (BETA - 默认值=true)<br>
MemoryManager=true|false (BETA - 默认值=true)<br>
MemoryQoS=true|false (ALPHA - 默认值=false)<br>
MixedProtocolLBService=true|false (ALPHA - 默认值=false)<br>
NetworkPolicyEndPort=true|false (BETA - 默认值=true)<br>
NodeSwap=true|false (ALPHA - 默认值=false)<br>
NonPreemptingPriority=true|false (BETA - 默认值=true)<br>
PodAffinityNamespaceSelector=true|false (BETA - 默认值=true)<br>
PodDeletionCost=true|false (BETA - 默认值=true)<br>
PodOverhead=true|false (BETA - 默认值=true)<br>
PodSecurity=true|false (ALPHA - 默认值=false)<br>
PreferNominatedNode=true|false (BETA - 默认值=true)<br>
ProbeTerminationGracePeriod=true|false (BETA - 默认值=false)<br>
ProcMountType=true|false (ALPHA - 默认值=false)<br>
ProxyTerminatingEndpoints=true|false (ALPHA - 默认值=false)<br>
QOSReserved=true|false (ALPHA - 默认值=false)<br>
ReadWriteOncePod=true|false (ALPHA - 默认值=false)<br>
RemainingItemCount=true|false (BETA - 默认值=true)<br>
RemoveSelfLink=true|false (BETA - 默认值=true)<br>
RotateKubeletServerCertificate=true|false (BETA - 默认值=true)<br>
SeccompDefault=true|false (ALPHA - 默认值=false)<br>
ServiceInternalTrafficPolicy=true|false (BETA - 默认值=true)<br>
ServiceLBNodePortControl=true|false (BETA - 默认值=true)<br>
ServiceLoadBalancerClass=true|false (BETA - 默认值=true)<br>
SizeMemoryBackedVolumes=true|false (BETA - 默认值=true)<br>
StatefulSetMinReadySeconds=true|false (ALPHA - 默认值=false)<br>
StorageVersionAPI=true|false (ALPHA - 默认值=false)<br>
StorageVersionHash=true|false (BETA - 默认值=true)<br>
SuspendJob=true|false (BETA - 默认值=true)<br>
TTLAfterFinished=true|false (BETA - 默认值=true)<br>
TopologyAwareHints=true|false (ALPHA - 默认值=false)<br>
TopologyManager=true|false (BETA - 默认值=true)<br>
VolumeCapacityPriority=true|false (ALPHA - 默认值=false)<br>
WinDSR=true|false (ALPHA - 默认值=false)<br>
WinOverlay=true|false (BETA - 默认值=true)<br>
WindowsHostProcessContainers=true|false (ALPHA - 默认值=false)
</p>
</td>
</tr>
<tr>
<td colspan=2>--healthz-bind-address 0.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>0.0.0.0:10256</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
服务健康状态检查的 IP 地址和端口（设置为 '0.0.0.0:10256' 表示使用所有
IPv4 接口，设置为 '[::]:10256' 表示使用所有 IPv6 接口）；
设置为空则禁用。
</p>
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
kube-proxy 操作的帮助命令。
</p>
</td>
</tr>
<tr>
<td colspan=2>--hostname-override string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果非空，将使用此字符串而不是实际的主机名作为标识。
</p>
</td>
</tr>
<tr>
<td colspan=2>--iptables-masquerade-bit int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：14</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
在使用纯 iptables 代理时，用来设置 fwmark 空间的 bit，标记需要
SNAT 的数据包。必须在 [0,31] 范围内。
</p>
</td>
</tr>
<tr>
<td colspan=2>--iptables-min-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
iptables 规则可以随着端点和服务的更改而刷新的最小间隔（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--iptables-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
刷新 iptables 规则的最大间隔（例如 '5s'、'1m'、'2h22m'）。必须大于 0。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-exclude-cidrs strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
逗号分隔的 CIDR 列表，ipvs 代理在清理 IPVS 规则时不会此列表中的地址范围。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-min-sync-period duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
ipvs 规则可以随着端点和服务的更改而刷新的最小间隔（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-scheduler string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
代理模式为 ipvs 时所选的 ipvs 调度器类型。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-strict-arp</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
通过将 <code>arp_ignore</code> 设置为 1 并将 <code>arp_announce</code>
设置为 2 启用严格的 ARP。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-sync-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：30s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
刷新 ipvs 规则的最大间隔（例如 '5s'、'1m'、'2h22m'）。必须大于 0。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-tcp-timeout duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
空闲 IPVS TCP 连接的超时时间，0 保持连接（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-tcpfin-timeout duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
收到 FIN 数据包后，IPVS TCP 连接的超时，0 保持当前设置不变。（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--ipvs-udp-timeout duration</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
IPVS UDP 数据包的超时，0 保持当前设置不变。（例如 '5s'、'1m'、'2h22m'）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--kube-api-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
与 kubernetes apiserver 通信的突发数量。
</p>
</td>
</tr>
<tr>
<td colspan=2>--kube-api-content-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："application/vnd.kubernetes.protobuf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
发送到 apiserver 的请求的内容类型。
</p>
</td>
</tr>
<tr>
<td colspan=2>--kube-api-qps float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
与 kubernetes apiserver 交互时使用的 QPS。
</p>
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
包含鉴权信息的 kubeconfig 文件的路径（主控节点位置由 master 标志设置）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--log-backtrace-at &lt;形式为 'file:N' 的字符串>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: :0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
当日志逻辑执行到文件 file 的第 N 行时，输出调用堆栈跟踪。
</p></td>
</tr>
<tr>
<td colspan=2>--log-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
若此标志费控，则将日志文件写入到此标志所给的目录下。
</p>
</td>
</tr>
<tr>
<td colspan=2>--log-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
若此标志非空，则该字符串作为日志文件名。
</p></td>
</tr>
<tr>
<td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
定义日志文件可增长到的最大尺寸。单位是兆字节（MB）。
如果此值为 0，则最大文件大小无限制。
</p></td>
</tr>
<tr>
<td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5s
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
两次日志刷新之间的最大秒数。
</td>
</tr>
<tr>
<td colspan=2>--machine-id-file string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/etc/machine-id,/var/lib/dbus/machine-id"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
用来检查 Machine-ID 的文件列表，用逗号分隔。
使用找到的第一个文件。
</p></td>
</tr>
<tr>
<td colspan=2>--masquerade-all</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果使用纯 iptables 代理，则对通过服务集群 IP 发送的所有流量
进行 SNAT（通常不需要）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--master string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
Kubernetes API 服务器的地址（覆盖 kubeconfig 中的相关值）。
</p>
</td>
</tr>
<tr>
<td colspan=2>--metrics-bind-address ipport&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：<code>127.0.0.1:10249</code></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
metrics 服务器要使用的 IP 地址和端口
（设置为 '0.0.0.0:10249' 则使用所有 IPv4 接口，设置为 '[::]:10249' 则使用所有 IPv6 接口）
设置为空则禁用。
</p>
</td>
</tr>
<tr>
<td colspan=2>--nodeport-addresses strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
一个字符串值，指定用于 NodePort 服务的地址。
值可以是有效的 IP 块（例如 1.2.3.0/24, 1.2.3.4/32）。
默认的空字符串切片（[]）表示使用所有本地地址。
</p>
</td>
</tr>
<tr>
<td colspan=2>--one-output</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
若此标志为 true，则仅将日志写入到其原本的严重性级别之下
（而不是将其写入到所有更低严重性级别中）。
</p></td>
</tr>
<tr>
<td colspan=2>--oom-score-adj int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：-999</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
kube-proxy 进程中的 oom-score-adj 值，必须在 [-1000,1000] 范围内。
</p>
</td>
</tr>
<tr>
<td colspan=2>--profiling</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果为 true，则通过 Web 接口 <code>/debug/pprof</code> 启用性能分析。
</p>
</td>
</tr>
<tr>
<td colspan=2>--proxy-mode string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
使用哪种代理模式：'userspace'（较旧）或 'iptables'（较快）或 'ipvs'。
如果为空，使用最佳可用代理（当前为 iptables）。
如果选择了 iptables 代理（无论是否为显式设置），但系统的内核或
iptables 版本较低，总是会回退到 userspace 代理。
</p>
</td>
</tr>
<tr>
<td colspan=2>--proxy-port-range port-range</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
可以用来代理服务流量的主机端口范围（包括'起始端口-结束端口'、
'单个端口'、'起始端口+偏移'几种形式）。
如果未指定或者设置为 0（或 0-0），则随机选择端口。
</p>
</td>
</tr>
<tr>
<td colspan=2>--show-hidden-metrics-for-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
要显示隐藏指标的先前版本。
仅先前的次要版本有意义，不允许其他值。
格式为 &lt;major>.&lt;minor> ，例如：'1.16'。
这种格式的目的是确保你有机会注意到下一个发行版是否隐藏了其他指标，
而不是在之后将其永久删除时感到惊讶。
</p>
</td>
</tr>
<tr>
<td colspan=2>--skip-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
若此标志为 true，则避免在日志消息中包含头部前缀。
</p></td>
</tr>
<tr>
<td colspan=2>--skip-log-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果此标志为 true，则避免在打开日志文件时使用头部。
</p></td>
</tr>
<tr>
<td colspan=2>--stderrthreshold int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：2</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果日志消息处于或者高于此阈值所设置的级别，则将其输出到标准错误输出（stderr）。
</p></td>
</tr>
<tr>
<td colspan=2>--udp-timeout duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：250ms</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
空闲 UDP 连接将保持打开的时长（例如 '250ms'，'2s'）。必须大于 0。
仅适用于 proxy-mode=userspace。
</p>
</td>
</tr>
<tr>
<td colspan=2>-v, --v int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
用来设置日志详细程度的数值。
</p></td>
</tr>
<tr>
<td colspan=2>--version version[=true]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
打印版本信息并退出。
</p>
</td>
</tr>
<tr>
<td colspan=2>--vmodule &lt;逗号分隔的 'pattern=N' 设置’></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
用逗号分隔的列表，其中每一项为 'pattern=N' 格式。
用来支持基于文件过滤的日志机制。
</p></td>
</tr>
<tr>
<td colspan=2>--write-config-to string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word><p>
如果设置，将默认配置信息写入此文件并退出。
</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-57e59e5ddd9db63da6c9d27cc0e2f254>10.6 - kube-scheduler</h1>
<h2 id=简介>简介</h2>
<p>Kubernetes 调度器是一个控制面进程，负责将 Pods 指派到节点上。
调度器基于约束和可用资源为调度队列中每个 Pod 确定其可合法放置的节点。
调度器之后对所有合法的节点进行排序，将 Pod 绑定到一个合适的节点。
在同一个集群中可以使用多个不同的调度器；kube-scheduler 是其参考实现。
参阅<a href=/zh/docs/concepts/scheduling-eviction/>调度</a>
以获得关于调度和 kube-scheduler 组件的更多信息。</p>
<pre><code>kube-scheduler [flags]
</code></pre><h2 id=选项>选项</h2>
<table style=width:100%;table-layout:fixed>
<col span=1 style=width:10px>
<col span=1>
<tbody>
<tr>
<td colspan=2>--add-dir-header</td>
</tr>
<tr><td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则将文件目录添加到日志消息的头部
</td>
</tr>
<tr><td colspan=2>--address string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："0.0.0.0"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用： 要监听 --port 端口的 IP 地址（将其设置为 0.0.0.0 或者 :: 用于监听所有接口和 IP族）。
请参阅 --bind-address。
如果在 --config 中指定了一个配置文件，这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--algorithm-provider string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用： 要使用的调度算法驱动，此标志设置组件配置框架的默认插件。
可选值：ClusterAutoscalerProvider | DefaultProvider
</td>
</tr>
<tr>
<td colspan=2>--allow-metric-labels stringToString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
默认值： []</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
这个键值映射表设置 度量标签 所允许设置的值。
其中键的格式是 &lt;MetricName>,&lt;LabelName>。
值的格式是 &lt;allowed_value>,&lt;allowed_value>。
例如：metric1,label1='v1,v2,v3', metric1,label2='v1,v2,v3' metric2,label1='v1,v2,v3'。
</td>
</tr>
<tr>
<td colspan=2>--alsologtostderr</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
日志记录到标准错误以及文件
</td>
</tr>
<tr>
<td colspan=2>--authentication-kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向具有足够权限以创建 <code>tokenaccessreviews.authentication.k8s.io</code> 的
Kubernetes 核心服务器的 kubeconfig 文件。
这是可选的。如果为空，则所有令牌请求均被视为匿名请求，并且不会在集群中查找任何客户端 CA。
</td>
</tr>
<tr>
<td colspan=2>--authentication-skip-lookup</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 false，则 authentication-kubeconfig 将用于从集群中查找缺少的身份验证配置。
</td>
</tr>
<tr>
<td colspan=2>--authentication-token-webhook-cache-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
缓存来自 Webhook 令牌身份验证器的响应的持续时间。
</td>
</tr>
<tr>
<td colspan=2>--authentication-tolerate-lookup-failure&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则无法从集群中查找缺少的身份验证配置是致命的。
请注意，这可能导致身份验证将所有请求视为匿名。
</td>
</tr>
<tr>
<td colspan=2>--authorization-always-allow-paths strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："/healthz,/readyz,/livez"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在授权过程中跳过的 HTTP 路径列表，即在不联系 'core' kubernetes 服务器的情况下被授权的 HTTP 路径。
</td>
</tr>
<tr>
<td colspan=2>--authorization-kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
指向具有足够权限以创建 subjectaccessreviews.authorization.k8s.io 的
Kubernetes 核心服务器的 kubeconfig 文件。这是可选的。
如果为空，则所有未被鉴权机制略过的请求都会被禁止。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-authorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
缓存来自 Webhook 授权者的 'authorized' 响应的持续时间。
</td>
</tr>
<tr>
<td colspan=2>--authorization-webhook-cache-unauthorized-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
缓存来自 Webhook 授权者的 'unauthorized' 响应的持续时间。
</td>
</tr>
<tr>
<td colspan=2>--azure-container-registry-config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含 Azure 容器仓库配置信息的文件的路径。
</td>
</tr>
<tr>
<td colspan=2>--bind-address string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：0.0.0.0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
监听 --secure-port 端口的 IP 地址。
集群的其余部分以及 CLI/ Web 客户端必须可以访问关联的接口。
如果为空，将使用所有接口（0.0.0.0 表示使用所有 IPv4 接口，"::" 表示使用所有 IPv6 接口）。
如果为空或未指定地址 (0.0.0.0 或 ::)，所有接口将被使用。
</td>
</tr>
<tr>
<td colspan=2>--cert-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
TLS 证书所在的目录。如果提供了--tls-cert-file 和 --tls private-key-file，
则将忽略此参数。
</td>
</tr>
<tr>
<td colspan=2>--client-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果已设置，由 client-ca-file 中的证书机构签名的客户端证书的任何请求都将使用
与客户端证书的 CommonName 对应的身份进行身份验证。
</td>
</tr>
<tr>
<td colspan=2>--config string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
配置文件的路径。以下标志会覆盖此文件中的值：<br>
--algorithm-provider<br>
--policy-config-file<br>
--policy-configmap<br>
--policy-configmap-namespace
</td>
</tr>
<tr>
<td colspan=2>--contention-profiling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 如果启用了性能分析，则启用锁竞争分析。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--disabled-metrics strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
这个标志提供了一个规避不良指标的选项。你必须提供完整的指标名称才能禁用它。
免责声明：禁用指标的优先级比显示隐藏的指标更高。
</td>
</tr>
<tr>
<td colspan=2>--experimental-logging-sanitization</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
[试验性功能] 当启用此标志时，标记为敏感的字段（密码、密钥、令牌）等不会被日志
输出。<br>
运行时的日志清理操作可能引入相当程度的计算开销，因此不应在生产环境中启用。
</td>
</tr>
<tr>
<td colspan=2>--feature-gates &lt;逗号分隔的 'key=True|False' 对></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一组 key=value 对，描述了 alpha/experimental 特征开关。选项包括：<br>
A set of key=value pairs that describe feature gates for alpha/experimental features. Options are:<br>
APIListChunking=true|false (BETA - 默认值=true)<br>
APIPriorityAndFairness=true|false (BETA - 默认值=true)<br>
APIResponseCompression=true|false (BETA - 默认值=true)<br>
APIServerIdentity=true|false (ALPHA - 默认值=false)<br>
AllAlpha=true|false (ALPHA - 默认值=false)<br>
AllBeta=true|false (BETA - 默认值=false)<br>
AnyVolumeDataSource=true|false (ALPHA - 默认值=false)<br>
AppArmor=true|false (BETA - 默认值=true)<br>
BalanceAttachedNodeVolumes=true|false (ALPHA - 默认值=false)<br>
BoundServiceAccountTokenVolume=true|false (BETA - 默认值=true)<br>
CPUManager=true|false (BETA - 默认值=true)<br>
CSIInlineVolume=true|false (BETA - 默认值=true)<br>
CSIMigration=true|false (BETA - 默认值=true)<br>
CSIMigrationAWS=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureDisk=true|false (BETA - 默认值=false)<br>
CSIMigrationAzureFile=true|false (BETA - 默认值=false)<br>
CSIMigrationGCE=true|false (BETA - 默认值=false)<br>
CSIMigrationOpenStack=true|false (BETA - 默认值=true)<br>
CSIMigrationvSphere=true|false (BETA - 默认值=false)<br>
CSIMigrationvSphereComplete=true|false (BETA - 默认值=false)<br>
CSIServiceAccountToken=true|false (BETA - 默认值=true)<br>
CSIStorageCapacity=true|false (BETA - 默认值=true)<br>
CSIVolumeFSGroupPolicy=true|false (BETA - 默认值=true)<br>
CSIVolumeHealth=true|false (ALPHA - 默认值=false)<br>
ConfigurableFSGroupPolicy=true|false (BETA - 默认值=true)<br>
ControllerManagerLeaderMigration=true|false (ALPHA - 默认值=false)<br>
CronJobControllerV2=true|false (BETA - 默认值=true)<br>
CustomCPUCFSQuotaPeriod=true|false (ALPHA - 默认值=false)<br>
DaemonSetUpdateSurge=true|false (ALPHA - 默认值=false)<br>
DefaultPodTopologySpread=true|false (BETA - 默认值=true)<br>
DevicePlugins=true|false (BETA - 默认值=true)<br>
DisableAcceleratorUsageMetrics=true|false (BETA - 默认值=true)<br>
DownwardAPIHugePages=true|false (BETA - 默认值=false)<br>
DynamicKubeletConfig=true|false (BETA - 默认值=true)<br>
EfficientWatchResumption=true|false (BETA - 默认值=true)<br>
EndpointSliceProxying=true|false (BETA - 默认值=true)<br>
EndpointSliceTerminatingCondition=true|false (ALPHA - 默认值=false)<br>
EphemeralContainers=true|false (ALPHA - 默认值=false)<br>
ExpandCSIVolumes=true|false (BETA - 默认值=true)<br>
ExpandInUsePersistentVolumes=true|false (BETA - 默认值=true)<br>
ExpandPersistentVolumes=true|false (BETA - 默认值=true)<br>
ExperimentalHostUserNamespaceDefaulting=true|false (BETA - 默认值=false)<br>
GenericEphemeralVolume=true|false (BETA - 默认值=true)<br>
GracefulNodeShutdown=true|false (BETA - 默认值=true)<br>
HPAContainerMetrics=true|false (ALPHA - 默认值=false)<br>
HPAScaleToZero=true|false (ALPHA - 默认值=false)<br>
HugePageStorageMediumSize=true|false (BETA - 默认值=true)<br>
IPv6DualStack=true|false (BETA - 默认值=true)<br>
InTreePluginAWSUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureDiskUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginAzureFileUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginGCEUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginOpenStackUnregister=true|false (ALPHA - 默认值=false)<br>
InTreePluginvSphereUnregister=true|false (ALPHA - 默认值=false)<br>
IndexedJob=true|false (ALPHA - 默认值=false)<br>
IngressClassNamespacedParams=true|false (ALPHA - 默认值=false)<br>
KubeletCredentialProviders=true|false (ALPHA - 默认值=false)<br>
KubeletPodResources=true|false (BETA - 默认值=true)<br>
KubeletPodResourcesGetAllocatable=true|false (ALPHA - 默认值=false)<br>
LocalStorageCapacityIsolation=true|false (BETA - 默认值=true)<br>
LocalStorageCapacityIsolationFSQuotaMonitoring=true|false (ALPHA - 默认值=false)<br>
LogarithmicScaleDown=true|false (ALPHA - 默认值=false)<br>
MemoryManager=true|false (ALPHA - 默认值=false)<br>
MixedProtocolLBService=true|false (ALPHA - 默认值=false)<br>
NamespaceDefaultLabelName=true|false (BETA - 默认值=true)<br>
NetworkPolicyEndPort=true|false (ALPHA - 默认值=false)<br>
NonPreemptingPriority=true|false (BETA - 默认值=true)<br>
PodAffinityNamespaceSelector=true|false (ALPHA - 默认值=false)<br>
PodDeletionCost=true|false (ALPHA - 默认值=false)<br>
PodOverhead=true|false (BETA - 默认值=true)<br>
PreferNominatedNode=true|false (ALPHA - 默认值=false)<br>
ProbeTerminationGracePeriod=true|false (ALPHA - 默认值=false)<br>
ProcMountType=true|false (ALPHA - 默认值=false)<br>
QOSReserved=true|false (ALPHA - 默认值=false)<br>
RemainingItemCount=true|false (BETA - 默认值=true)<br>
RemoveSelfLink=true|false (BETA - 默认值=true)<br>
RotateKubeletServerCertificate=true|false (BETA - 默认值=true)<br>
ServerSideApply=true|false (BETA - 默认值=true)<br>
ServiceInternalTrafficPolicy=true|false (ALPHA - 默认值=false)<br>
ServiceLBNodePortControl=true|false (ALPHA - 默认值=false)<br>
ServiceLoadBalancerClass=true|false (ALPHA - 默认值=false)<br>
ServiceTopology=true|false (ALPHA - 默认值=false)<br>
SetHostnameAsFQDN=true|false (BETA - 默认值=true)<br>
SizeMemoryBackedVolumes=true|false (ALPHA - 默认值=false)<br>
StorageVersionAPI=true|false (ALPHA - 默认值=false)<br>
StorageVersionHash=true|false (BETA - 默认值=true)<br>
SuspendJob=true|false (ALPHA - 默认值=false)<br>
TTLAfterFinished=true|false (BETA - 默认值=true)<br>
TopologyAwareHints=true|false (ALPHA - 默认值=false)<br>
TopologyManager=true|false (BETA - 默认值=true)<br>
ValidateProxyRedirects=true|false (BETA - 默认值=true)<br>
VolumeCapacityPriority=true|false (ALPHA - 默认值=false)<br>
WarningHeaders=true|false (BETA - 默认值=true)<br>
WinDSR=true|false (ALPHA - 默认值=false)<br>
WinOverlay=true|false (BETA - 默认值=true)<br>
WindowsEndpointSliceProxying=true|false (BETA - 默认值=true)
</td>
</tr>
<tr>
<td colspan=2>--hard-pod-affinity-symmetric-weight int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: RequiredDuringScheduling 亲和性是不对称的，但是存在与每个
RequiredDuringScheduling 关联性规则相对应的隐式 PreferredDuringScheduling 关联性规则。
<code>--hard-pod-affinity-symmetric-weight</code> 代表隐式 PreferredDuringScheduling
关联性规则的权重。权重必须在 0-100 范围内。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>-h, --help</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
kube-scheduler 帮助命令
</td>
</tr>
<tr>
<td colspan=2>--http2-max-streams-per-connection int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务器为客户端提供的 HTTP/2 连接最大限制。零表示使用 Golang 的默认值。
</td>
</tr>
<tr>
<td colspan=2>--kube-api-burst int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：100</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 与 kubernetes API 通信时使用的突发请求个数限值。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--kube-api-content-type string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："application/vnd.kubernetes.protobuf"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 发送到 API 服务器的请求的内容类型。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--kube-api-qps float32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：50</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 与 kubernetes apiserver 通信时要使用的 QPS
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--kubeconfig string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 包含鉴权和主节点位置信息的 kubeconfig 文件的路径。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在执行主循环之前，开始领导者选举并选出领导者。
使用多副本来实现高可用性时，可启用此标志。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-lease-duration duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：15s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
非领导者候选人在观察到领导者更新后将等待直到试图获得领导但未更新的领导者职位的等待时间。
这实际上是领导者在被另一位候选人替代之前可以停止的最大持续时间。
该情况仅在启用了领导者选举的情况下才适用。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-renew-deadline duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
领导者尝试在停止领导之前更新领导职位的间隔时间。该时间必须小于或等于租赁期限。
仅在启用了领导者选举的情况下才适用。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-resource-lock string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："leases"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在领导者选举期间用于锁定的资源对象的类型。支持的选项是 `endpoints`、
`configmaps`、`leases`、`endpointleases` 和 `configmapsleases`。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-resource-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kube-scheduler"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在领导者选举期间用于锁定的资源对象的名称。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-resource-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kube-system"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在领导者选举期间用于锁定的资源对象的命名空间。
</td>
</tr>
<tr>
<td colspan=2>--leader-elect-retry-period duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：2s
</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
客户应在尝试获取和更新领导之间等待的时间。仅在启用了领导者选举的情况下才适用。
</td>
</tr>
<tr>
<td colspan=2>--lock-object-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kube-scheduler"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 定义锁对象的名称。将被删除以便使用 <code>--leader-elect-resource-name</code>。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--lock-object-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kube-system"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 定义锁对象的命名空间。将被删除以便使用 <code>leader-elect-resource-namespace</code>。
如果 --config 指定了一个配置文件，那么这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--log-backtrace-at &lt;a string in the form 'file:N'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
默认值: 0</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
当记录命中行文件 <code>file</code> 的第 <code>N</code> 行时输出堆栈跟踪。
</td>
</tr>
<tr>
<td colspan=2>--log-dir string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为非空，则在此目录中写入日志文件。
</td>
</tr>
<tr>
<td colspan=2>--log-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为非空，则使用此文件作为日志文件。
</td>
</tr>
<tr>
<td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：1800</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
定义日志文件可以增长到的最大值。单位为兆字节。
如果值为 0，则最大文件大小为无限制。
</td>
</tr>
<tr>
<td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：5s</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
两次日志刷新之间的最大秒数。
</td>
</tr>
<tr>
<td colspan=2>--logging-format string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：“text”</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置日志格式。可选格式：“json”，“text”。<br>
采用非默认格式时，以下标识不会生效：
--add-dir-header, --alsologtostderr, --log-backtrace-at,
--log-dir, --log-file, --log-file-max-size,
--logtostderr, --one-output, --skip-headers, --skip-log-headers,
--stderrthreshold, --vmodule, --log-flush-frequency.<br>
非默认选项目前处于 Alpha 阶段，有可能会出现变更且无事先警告。
</td>
</tr>
<tr>
<td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
日志记录到标准错误输出而不是文件。
</td>
</tr>
<tr>
<td colspan=2>--master string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
Kubernetes API 服务器的地址（覆盖 kubeconfig 中的任何值）。
</td>
</tr>
<tr>
<td colspan=2>--one-output</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
若此标志为 true，则日志仅写入其自身的严重性级别，而不会写入所有较低严重性级别。
</td>
</tr>
<tr>
<td colspan=2>--permit-address-sharing</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，在绑定端口时将使用 SO_REUSEADDR。
这将允许同时绑定诸如 0.0.0.0 这类通配符 IP和特定 IP，
并且它避免等待内核释放处于 TIME_WAIT 状态的套接字。
默认值： false
</td>
</tr>
<tr>
<td colspan=2>--permit-port-sharing</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果此标志为 true，在绑定端口时会使用 SO_REUSEPORT，从而允许不止一个
实例绑定到同一地址和端口。
默认值：false
</td>
</tr>
<tr>
<td colspan=2>--policy-config-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用：包含调度器策略配置的文件。
当策略 ConfigMap 为提供时，或者 <code>--use-legacy-policy-config=true</code> 时使用此文件。
注意：当此标志与插件配置一起使用时，调度器会失败。
</td>
</tr>
<tr>
<td colspan=2>--policy-configmap string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 包含调度器策略配置的 ConfigMap 对象的名称。
如果 --use-legacy-policy-config=false，则它必须在调度器初始化之前存在于
系统命名空间中。配置数据必须对应 'data' 映射中键名为 'policy.cfg' 的元素的值。
注意：如果与插件配置一起使用，调度器会失败。
</td>
</tr>
<tr>
<td colspan=2>--policy-configmap-namespace string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值："kube-system"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 策略 ConfigMap 所在的名字空间。如果未提供或为空，则将使用 kube-system 名字空间。
注意：如果与插件配置一起使用，调度器会失败。
</td>
</tr>
<tr>
<td colspan=2>--port int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10251</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用： 在没有身份验证和鉴权的情况下不安全地为 HTTP 服务的端口。
如果为 0，则根本不提供 HTTP。请参见 --secure-port。
如果 --config 指定了一个配置文件，这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--profiling&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值： true</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 通过 Web 界面主机启用配置文件：<code>host:port/debug/pprof/</code>。
如果 --config 指定了一个配置文件，这个参数将被忽略。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-allowed-names stringSlice</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
客户端证书通用名称列表，允许在 <code>--requestheader-username-headers</code>
指定的头部中提供用户名。如果为空，则允许任何由
<code>--requestheader-client-ca-file</code> 中证书机构验证的客户端证书。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-client-ca-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
在信任 <code>--requestheader-username-headers</code> 指定的头部中的用户名之前
用于验证传入请求上的客户端证书的根证书包。
警告：通常不应假定传入请求已经完成鉴权。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-extra-headers-prefix strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
默认值: "x-remote-extra-"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
要检查请求头部前缀列表。建议使用 <code>X-Remote-Extra-</code>。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-group-headers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
默认值: "x-remote-group"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于检查组的请求头部列表。建议使用 <code>X-Remote-Group</code>。
</td>
</tr>
<tr>
<td colspan=2>--requestheader-username-headers strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
默认值: "x-remote-user"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
用于检查用户名的请求头部列表。<code>X-Remote-User</code> 很常用。
</td>
</tr>
<tr>
<td colspan=2>--scheduler-name string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
默认值："default-scheduler"</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用: 调度器名称，用于根据 Pod 的 “spec.schedulerName” 选择此
调度器将处理的 Pod。
如果 --config 指定了一个配置文件，那么这个参数将被忽略
</td>
</tr>
<tr>
<td colspan=2>--secure-port int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：10259</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
通过身份验证和授权为 HTTPS 服务的端口。如果为 0，则根本不提供 HTTPS。
</td>
</tr>
<tr>
<td colspan=2>--show-hidden-metrics-for-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
你希望显式隐藏指标的老版本号。只有较早的此版本号有意义，其它值都是不允许的。
格式为 &lt;主版本>.&lt;此版本>，例如：'1.16'。
此格式的目的是确保你有机会注意到是否下一个发行版本中隐藏了一些额外的指标，
而不是当某些指标在该版本之后被彻底移除时感到震惊。
</td>
</tr>
<tr>
<td colspan=2>--skip-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，日志消息中不再写入头部前缀。
</td>
</tr>
<tr>
<td colspan=2>--skip-log-headers</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果为 true，则在打开日志文件时忽略其头部。
</td>
</tr>
<tr>
<td colspan=2>--stderrthreshold int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值：2</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
达到或超过此阈值的日志会被写入到标准错误输出。
</td>
</tr>
<tr>
<td colspan=2>--tls-cert-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含默认的 HTTPS x509 证书的文件。（CA证书（如果有）在服务器证书之后并置）。
如果启用了 HTTPS 服务，并且未提供 <code>--tls-cert-file</code> 和
<code>--tls-private-key-file</code>，则会为公共地址生成一个自签名证书和密钥，
并将其保存到 <code>--cert-dir</code> 指定的目录中。
</td>
</tr>
<tr>
<td colspan=2>--tls-cipher-suites strings</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
服务器的密码套件列表，以逗号分隔。如果省略，将使用默认的 Go 密码套件。
优先考虑的值：
TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256, TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305, TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256, TLS_RSA_WITH_3DES_EDE_CBC_SHA, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_256_GCM_SHA384.<br>
不安全的值：
TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, TLS_ECDHE_RSA_WITH_RC4_128_SHA, TLS_RSA_WITH_AES_128_CBC_SHA256, TLS_RSA_WITH_RC4_128_SHA.
</td>
</tr>
<tr>
<td colspan=2>--tls-min-version string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
支持的最低 TLS 版本。可能的值：VersionTLS10, VersionTLS11, VersionTLS12, VersionTLS13
</td>
</tr>
<tr>
<td colspan=2>--tls-private-key-file string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
包含与 --tls-cert-file 匹配的默认 x509 私钥的文件。
</td>
</tr>
<tr>
<td colspan=2>--tls-sni-cert-key string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
一对 x509 证书和私钥文件路径，也可以包含由全限定域名构成的域名模式列表作为后缀，
并可能带有前缀的通配符段。域名匹配还允许是 IP 地址，
但是只有当 apiserver 对客户端请求的 IP 地址可见时，才能使用 IP。
如果未提供域名匹配模式，则提取证书名称。
非通配符匹配优先于通配符匹配，显式域名匹配优先于提取而来的名称。
若有多个密钥/证书对，可多次使用 <code>--tls-sni-cert-key</code>。
例子: "example.crt,example.key" 或者 "foo.crt,foo.key:*.foo.com,foo.com"。
</td>
</tr>
<tr>
<td colspan=2>--use-legacy-policy-config</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
已弃用：设置为 true 时，调度程序将忽略策略 ConfigMap 并使用策略配置文件。
注意：当此标志与插件配置一起使用时，调度器会失败。
</td>
</tr>
<tr>
<td colspan=2>-v, --v int</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
设置日志级别详细程度的数字
</td>
</tr>
<tr>
<td colspan=2>--version version[=true]</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
打印版本信息并退出。
</td>
</tr>
<tr>
<td colspan=2>--vmodule &lt;逗号分隔的 ‘模式=N’ 配置列表></td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
以逗号分隔的 ‘模式=N’ 设置列表，用于文件过滤的日志记录。
</td>
</tr>
<tr>
<td colspan=2>--write-config-to string</td>
</tr>
<tr>
<td></td><td style=line-height:130%;word-wrap:break-word>
如果已设置，将配置值写入此文件并退出。
</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1715b765e2ff39feffd103d59ec0ef07>10.7 - Kubelet 认证/鉴权</h1>
<h2 id=概述>概述</h2>
<p>kubelet 的 HTTPS 端点公开了 API，
这些 API 可以访问敏感度不同的数据，
并允许你在节点上和容器内以不同级别的权限执行操作。</p>
<p>本文档介绍了如何对 kubelet 的 HTTPS 端点的访问进行认证和鉴权。</p>
<h2 id=kubelet-身份认证>Kubelet 身份认证</h2>
<p>默认情况下，未被已配置的其他身份认证方法拒绝的对 kubelet 的 HTTPS 端点的请求会被视为匿名请求，
并被赋予 <code>system:anonymous</code> 用户名和 <code>system:unauthenticated</code> 组。</p>
<p>要禁用匿名访问并向未经身份认证的请求发送 <code>401 Unauthorized</code> 响应，请执行以下操作：</p>
<ul>
<li>带 <code>--anonymous-auth=false</code> 标志启动 kubelet</li>
</ul>
<p>要对 kubelet 的 HTTPS 端点启用 X509 客户端证书认证：</p>
<ul>
<li>带 <code>--client-ca-file</code> 标志启动 kubelet，提供一个 CA 证书包以供验证客户端证书</li>
<li>带 <code>--kubelet-client-certificate</code> 和 <code>--kubelet-client-key</code> 标志启动 apiserver</li>
<li>有关更多详细信息，请参见
<a href=/zh/docs/reference/access-authn-authz/authentication/#x509-client-certs>apiserver 身份验证文档</a></li>
</ul>
<p>要启用 API 持有者令牌（包括服务帐户令牌）以对 kubelet 的 HTTPS 端点进行身份验证，请执行以下操作：</p>
<ul>
<li>确保在 API 服务器中启用了 <code>authentication.k8s.io/v1beta1</code> API 组</li>
<li>带 <code>--authentication-token-webhook</code> 和 <code>--kubeconfig</code> 标志启动 kubelet</li>
<li>kubelet 调用已配置的 API 服务器上的 <code>TokenReview</code> API，以根据持有者令牌确定用户信息</li>
</ul>
<h2 id=kubelet-鉴权>Kubelet 鉴权</h2>
<p>任何成功通过身份验证的请求（包括匿名请求）之后都会被鉴权。
默认的鉴权模式为 <code>AlwaysAllow</code>，它允许所有请求。</p>
<p>细分对 kubelet API 的访问权限可能有多种原因：</p>
<ul>
<li>启用了匿名身份验证，但是应限制匿名用户调用 kubelet API 的能力</li>
<li>启用了持有者令牌认证，但应限制任意 API 用户（如服务帐户）调用 kubelet API 的能力</li>
<li>启用了客户端证书身份验证，但仅应允许已配置的 CA 签名的某些客户端证书使用 kubelet API</li>
</ul>
<p>要细分对 kubelet API 的访问权限，请将鉴权委派给 API 服务器：</p>
<ul>
<li>确保在 API 服务器中启用了 <code>authorization.k8s.io/v1beta1</code> API 组</li>
<li>带 <code>--authorization-mode=Webhook</code> 和 <code>--kubeconfig</code> 标志启动 kubelet</li>
<li>kubelet 调用已配置的 API 服务器上的 <code>SubjectAccessReview</code> API，
以确定每个请求是否得到鉴权</li>
</ul>
<p>kubelet 使用与 apiserver 相同的
<a href=/zh/docs/reference/access-authn-authz/authorization/#review-your-request-attributes>请求属性</a>
方法对 API 请求执行鉴权。</p>
<p>请求的动词根据传入请求的 HTTP 动词确定：</p>
<table>
<thead>
<tr>
<th>HTTP 动词</th>
<th>请求动词</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>create</td>
</tr>
<tr>
<td>GET, HEAD</td>
<td>get</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
</tr>
<tr>
<td>PATCH</td>
<td>patch</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete</td>
</tr>
</tbody>
</table>
<p>资源和子资源是根据传入请求的路径确定的：</p>
<table>
<thead>
<tr>
<th>Kubelet API</th>
<th>资源</th>
<th>子资源</th>
</tr>
</thead>
<tbody>
<tr>
<td>/stats/*</td>
<td>nodes</td>
<td>stats</td>
</tr>
<tr>
<td>/metrics/*</td>
<td>nodes</td>
<td>metrics</td>
</tr>
<tr>
<td>/logs/*</td>
<td>nodes</td>
<td>log</td>
</tr>
<tr>
<td>/spec/*</td>
<td>nodes</td>
<td>spec</td>
</tr>
<tr>
<td><em>其它所有</em></td>
<td>nodes</td>
<td>proxy</td>
</tr>
</tbody>
</table>
<p>名字空间和 API 组属性始终是空字符串，
资源名称始终是 kubelet 的 <code>Node</code> API 对象的名称。</p>
<p>在此模式下运行时，请确保传递给 apiserver 的由 <code>--kubelet-client-certificate</code> 和
<code>--kubelet-client-key</code> 标志标识的用户具有以下属性的鉴权：</p>
<ul>
<li>verb=*, resource=nodes, subresource=proxy</li>
<li>verb=*, resource=nodes, subresource=stats</li>
<li>verb=*, resource=nodes, subresource=log</li>
<li>verb=*, resource=nodes, subresource=spec</li>
<li>verb=*, resource=nodes, subresource=metrics</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bdd3803a4bb6efcc44a7ab03590ce93c>10.8 - TLS 启动引导</h1>
<p>在一个 Kubernetes 集群中，工作节点上的组件（kubelet 和 kube-proxy）需要与
Kubernetes 主控组件通信，尤其是 kube-apiserver。
为了确保通信本身是私密的、不被干扰，并且确保集群的每个组件都在与另一个
可信的组件通信，我们强烈建议使用节点上的客户端 TLS 证书。</p>
<p>启动引导这些组件的正常过程，尤其是需要证书来与 kube-apiserver 安全通信的
工作节点，可能会是一个具有挑战性的过程，因为这一过程通常不受 Kubernetes 控制，
需要不少额外工作。
这也使得初始化或者扩缩一个集群的操作变得具有挑战性。</p>
<p>为了简化这一过程，从 1.4 版本开始，Kubernetes 引入了一个证书请求和签名
API 以便简化此过程。该提案可在
<a href=https://github.com/kubernetes/kubernetes/pull/20439>这里</a>看到。</p>
<p>本文档描述节点初始化的过程，如何为 kubelet 配置 TLS 客户端证书启动引导，
以及其背后的工作原理。</p>
<h2 id=initialization-process>初始化过程 </h2>
<p>当工作节点启动时，kubelet 执行以下操作：</p>
<ol>
<li>寻找自己的 <code>kubeconfig</code> 文件</li>
<li>检索 API 服务器的 URL 和凭据，通常是来自 <code>kubeconfig</code> 文件中的
TLS 密钥和已签名证书</li>
<li>尝试使用这些凭据来与 API 服务器通信</li>
</ol>
<p>假定 kube-apiserver 成功地认证了 kubelet 的凭据数据，它会将 kubelet 视为
一个合法的节点并开始将 Pods 分派给该节点。</p>
<p>注意，签名的过程依赖于：</p>
<ul>
<li><code>kubeconfig</code> 中包含密钥和本地主机的证书</li>
<li>证书被 kube-apiserver 所信任的一个证书机构（CA）所签名</li>
</ul>
<p>负责部署和管理集群的人有以下责任：</p>
<ol>
<li>创建 CA 密钥和证书</li>
<li>将 CA 证书发布到 kube-apiserver 运行所在的主控节点上</li>
<li>为每个 kubelet 创建密钥和证书；强烈建议为每个 kubelet 使用独一无二的、
CN 取值与众不同的密钥和证书</li>
<li>使用 CA 密钥对 kubelet 证书签名</li>
<li>将 kubelet 密钥和签名的证书发布到 kubelet 运行所在的特定节点上</li>
</ol>
<p>本文中描述的 TLS 启动引导过程有意简化甚至完全自动化上述过程，尤其是
第三步之后的操作，因为这些步骤是初始化或者扩缩集群时最常见的操作。</p>
<h3 id=bootstrap-initialization>启动引导初始化 </h3>
<p>在启动引导初始化过程中，会发生以下事情：</p>
<ol>
<li>kubelet 启动</li>
<li>kubelet 看到自己 <em>没有</em> 对应的 <code>kubeconfig</code> 文件</li>
<li>kubelet 搜索并发现 <code>bootstrap-kubeconfig</code> 文件</li>
<li>kubelet 读取该启动引导文件，从中获得 API 服务器的 URL 和用途有限的
一个“令牌（Token）”</li>
<li>kubelet 建立与 API 服务器的连接，使用上述令牌执行身份认证</li>
<li>kubelet 现在拥有受限制的凭据来创建和取回证书签名请求（CSR）</li>
<li>kubelet 为自己创建一个 CSR，并将其 signerName 设置为 <code>kubernetes.io/kube-apiserver-client-kubelet</code></li>
<li>CSR 被以如下两种方式之一批复：</li>
</ol>
<ul>
<li>如果配置了，kube-controller-manager 会自动批复该 CSR</li>
<li>如果配置了，一个外部进程，或者是人，使用 Kubernetes API 或者使用 <code>kubectl</code>
来批复该 CSR</li>
</ul>
<ol start=9>
<li>kubelet 所需要的证书被创建</li>
</ol>
<ol start=10>
<li>证书被发放给 kubelet</li>
<li>kubelet 取回该证书</li>
<li>kubelet 创建一个合适的 <code>kubeconfig</code>，其中包含密钥和已签名的证书</li>
<li>kubelet 开始正常操作</li>
<li>可选地，如果配置了，kubelet 在证书接近于过期时自动请求更新证书</li>
<li>更新的证书被批复并发放；取决于配置，这一过程可能是自动的或者手动完成</li>
</ol>
<p>本文的其余部分描述配置 TLS 启动引导的必要步骤及其局限性。</p>
<h2 id=configuration>配置 </h2>
<p>要配置 TLS 启动引导及可选的自动批复，你必须配置以下组件的选项：</p>
<ul>
<li>kube-apiserver</li>
<li>kube-controller-manager</li>
<li>kubelet</li>
<li>集群内的资源：<code>ClusterRoleBinding</code> 以及可能需要的 <code>ClusterRole</code></li>
</ul>
<p>此外，你需要有 Kubernetes 证书机构（Certificate Authority，CA）。</p>
<h2 id=certificate-authority>证书机构 </h2>
<p>就像在没有启动引导的情况下，你会需要证书机构（CA）密钥和证书。
这些数据会被用来对 kubelet 证书进行签名。
如前所述，将证书机构密钥和证书发布到主控节点是你的责任。</p>
<p>就本文而言，我们假定这些数据被发布到主控节点上的
<code>/var/lib/kubernetes/ca.pem</code>（证书）和
<code>/var/lib/kubernetes/ca-key.pem</code>（密钥）文件中。
我们将这两个文件称作“Kubernetes CA 证书和密钥”。
所有 Kubernetes 组件（kubelet、kube-apiserver、kube-controller-manager）都使用
这些凭据，并假定这里的密钥和证书都是 PEM 编码的。</p>
<h2 id=kube-apiserver-configuration>kube-apiserver 配置 </h2>
<p>启用 TLS 启动引导对 kube-apiserver 有若干需求：</p>
<ul>
<li>能够识别对客户端证书进行签名的 CA</li>
<li>能够对启动引导的 kubelet 执行身份认证，并将其置入 <code>system:bootstrappers</code> 组</li>
<li>能够对启动引导的 kubelet 执行鉴权操作，允许其创建证书签名请求（CSR）</li>
</ul>
<h3 id=recognizing-client-certificates>识别客户证书 </h3>
<p>对于所有客户端证书的认证操作而言，这是很常见的。
如果还没有设置，要为 kube-apiserver 命令添加 <code>--client-ca-file=FILENAME</code>
标志来启用客户端证书认证，在标志中引用一个包含用来签名的证书的证书机构包，
例如：<code>--client-ca-file=/var/lib/kubernetes/ca.pem</code>。</p>
<h3 id=initial-bootstrap-authentication>初始启动引导认证 </h3>
<p>为了让启动引导的 kubelet 能够连接到 kube-apiserver 并请求证书，
它必须首先在服务器上认证自身身份。你可以使用任何一种能够对 kubelet 执行身份认证的
<a href=/zh/docs/reference/access-authn-authz/authentication/>身份认证组件</a>。</p>
<p>尽管所有身份认证策略都可以用来对 kubelet 的初始启动凭据来执行认证，
出于容易准备的因素，建议使用如下两个身份认证组件：</p>
<ol>
<li><a href=#bootstrap-tokens>启动引导令牌（Bootstrap Token）</a></li>
<li><a href=#token-authentication-file>令牌认证文件</a></li>
</ol>
<p>启动引导令牌是一种对 kubelet 进行身份认证的方法，相对简单且容易管理，
且不需要在启动 kube-apiserver 时设置额外的标志。
启动引导令牌从 Kubernetes 1.12 开始是一种 <strong>Beta</strong> 功能特性。</p>
<p>无论选择哪种方法，这里的需求是 kubelet 能够被身份认证为某个具有如下权限的用户：</p>
<ol>
<li>创建和读取 CSR</li>
<li>在启用了自动批复时，能够在请求节点客户端证书时得到自动批复</li>
</ol>
<p>使用启动引导令牌执行身份认证的 kubelet 会被认证为 <code>system:bootstrappers</code>
组中的用户。这是使用启动引导令牌的一种标准方法。</p>
<p>随着这个功能特性的逐渐成熟，你需要确保令牌绑定到某基于角色的的访问控制（RBAC）
策略上，从而严格限制请求（使用<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>启动引导令牌</a>）
仅限于客户端申请提供证书。当 RBAC 被配置启用时，可以将令牌限制到某个组，从而
提高灵活性。例如，你可以在准备节点期间禁止某特定启动引导组的访问。</p>
<h4 id=bootstrap-tokens>启动引导令牌 </h4>
<p>启动引导令牌的细节在<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>这里</a>
详述。启动引导令牌在 Kubernetes 集群中存储为 Secret 对象，被发放给各个 kubelet。
你可以在整个集群中使用同一个令牌，也可以为每个节点发放单独的令牌。</p>
<p>这一过程有两个方面：</p>
<ol>
<li>基于令牌 ID、机密数据和范畴信息创建 Kubernetes Secret</li>
<li>将令牌发放给 kubelet</li>
</ol>
<p>从 kubelet 的角度，所有令牌看起来都很像，没有特别的含义。
从 kube-apiserver 服务器的角度，启动引导令牌是很特殊的。
根据其 <code>type</code>、<code>namespace</code> 和 <code>name</code>，kube-apiserver 能够将认作特殊的令牌，
并授予携带该令牌的任何人特殊的启动引导权限，换言之，将其视为
<code>system:bootstrappers</code> 组的成员。这就满足了 TLS 启动引导的基本需求。</p>
<p>关于创建 Secret 的进一步细节可访问<a href=/zh/docs/reference/access-authn-authz/bootstrap-tokens/>这里</a>。</p>
<p>如果你希望使用启动引导令牌，你必须在 kube-apiserver 上使用下面的标志启用之：</p>
<pre><code class=language-console data-lang=console>--enable-bootstrap-token-auth=true
</code></pre>
<h4 id=token-authentication-file>令牌认证文件 </h4>
<p>kube-apiserver 能够将令牌视作身份认证依据。
这些令牌可以是任意数据，但必须表示为基于某安全的随机数生成器而得到的
至少 128 位混沌数据。这里的随机数生成器可以是现代 Linux 系统上的
<code>/dev/urandom</code>。生成令牌的方式有很多种。例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>head -c <span style=color:#666>16</span> /dev/urandom | od -An -t x | tr -d <span style=color:#b44>&#39; &#39;</span>
</code></pre></div>
<p>上面的命令会生成类似于 <code>02b50b05283e98dd0fd71db496ef01e8</code> 这样的令牌。</p>
<p>令牌文件看起来是下面的例子这样，其中前面三个值可以是任何值，用引号括起来
的组名称则只能用例子中给的值。</p>
<pre><code class=language-console data-lang=console>02b50b05283e98dd0fd71db496ef01e8,kubelet-bootstrap,10001,&quot;system:bootstrappers&quot;
</code></pre>
<p>向 kube-apiserver 添加 <code>--token-auth-file=FILENAME</code> 标志（或许这要对 systemd
的单元文件作修改）以启用令牌文件。参见
<a href=/zh/docs/reference/access-authn-authz/authentication/#static-token-file>这里</a>
的文档以了解进一步的细节。</p>
<h3 id=authorize-kubelet-to-create-csr>授权 kubelet 创建 CSR </h3>
<p>现在启动引导节点被身份认证为 <code>system:bootstrapping</code> 组的成员，它需要被 <em>授权</em>
创建证书签名请求（CSR）并在证书被签名之后将其取回。
幸运的是，Kubernetes 提供了一个 <code>ClusterRole</code>，其中精确地封装了这些许可，
<code>system:node-bootstrapper</code>。</p>
<p>为了实现这一点，你只需要创建 <code>ClusterRoleBinding</code>，将 <code>system:bootstrappers</code>
组绑定到集群角色 <code>system:node-bootstrapper</code>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 允许启动引导节点创建 CSR</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>create-csrs-for-bootstrapping<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:bootstrappers<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:node-bootstrapper<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<h2 id=kube-controller-manager-configuration>kube-controller-manager 配置 </h2>
<p>API 服务器从 kubelet 收到证书请求并对这些请求执行身份认证，但真正负责发放
签名证书的是控制器管理器。</p>
<p>控制器管理器通过一个证书发放的控制回路来执行此操作。该操作的执行方式是使用磁盘上
的文件用 <a href=https://blog.cloudflare.com/introducing-cfssl/>cfssl</a> 本地签名组件
来完成。目前，所发放的所有证书都有一年的有效期，并设定了默认的一组密钥用法。</p>
<p>为了让控制器管理器对证书签名，它需要：</p>
<ul>
<li>能够访问你之前所创建并分发的“Kubernetes CA 密钥和证书”</li>
<li>启用 CSR 签名</li>
</ul>
<h3 id=access-to-key-and-certificate>访问密钥和证书 </h3>
<p>如前所述，你需要创建一个 Kubernetes CA 密钥和证书，并将其发布到主控节点。
这些数据会被控制器管理器来对 kubelet 证书进行签名。</p>
<p>由于这些被签名的证书反过来会被 kubelet 用来在 kube-apiserver 执行普通的
kubelet 身份认证，很重要的一点是为控制器管理器所提供的 CA 也被 kube-apiserver
信任用来执行身份认证。CA 密钥和证书是通过 kube-apiserver 的标志
<code>--client-ca-file=FILENAME</code>（例如，<code>--client-ca-file=/var/lib/kubernetes/ca.pem</code>)，
来设定的，正如 kube-apiserver 配置节所述。</p>
<p>要将 Kubernetes CA 密钥和证书提供给 kube-controller-manager，可使用以下标志：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--cluster-signing-cert-file<span style=color:#666>=</span><span style=color:#b44>&#34;/etc/path/to/kubernetes/ca/ca.crt&#34;</span> --cluster-signing-key-file<span style=color:#666>=</span><span style=color:#b44>&#34;/etc/path/to/kubernetes/ca/ca.key&#34;</span>
</code></pre></div>
<p>例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--cluster-signing-cert-file<span style=color:#666>=</span><span style=color:#b44>&#34;/var/lib/kubernetes/ca.pem&#34;</span> --cluster-signing-key-file<span style=color:#666>=</span><span style=color:#b44>&#34;/var/lib/kubernetes/ca-key.pem&#34;</span>
</code></pre></div>
<p>所签名的证书的合法期限可以通过下面的标志来配置：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--cluster-signing-duration
</code></pre></div>
<h3 id=approval>批复 </h3>
<p>为了对 CSR 进行批复，你需要告诉控制器管理器批复这些 CSR 是可接受的。
这是通过将 RBAC 访问权限授予正确的组来实现的。</p>
<p>许可权限有两组：</p>
<ul>
<li><code>nodeclient</code>：如果节点在为节点创建新的证书，则该节点还没有证书。该节点
使用前文所列的令牌之一来执行身份认证，因此是组 <code>system:bootstrappers</code> 组
的成员。</li>
<li><code>selfnodeclient</code>：如果节点在对证书执行续期操作，则该节点已经拥有一个证书。
节点持续使用现有的证书将自己认证为 <code>system:nodes</code> 组的成员。</li>
</ul>
<p>要允许 kubelet 请求并接收新的证书，可以创建一个 <code>ClusterRoleBinding</code> 将启动
引导节点所处的组 <code>system:bootstrappers</code> 绑定到为其赋予访问权限的
<code>ClusterRole</code> <code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 批复 &#34;system:bootstrappers&#34; 组的所有 CSR</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>auto-approve-csrs-for-group<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:bootstrappers<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:certificates.k8s.io:certificatesigningrequests:nodeclient<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>要允许 kubelet 对其客户端证书执行续期操作，可以创建一个 <code>ClusterRoleBinding</code>
将正常工作的节点所处的组 <code>system:nodes</code> 绑定到为其授予访问许可的 <code>ClusterRole</code>
<code>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># 批复 &#34;system:nodes&#34; 组的 CSR 续约请求</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>auto-approve-renewals-for-nodes<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:nodes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div>
<p>作为 <a href=/zh/docs/reference/generated/kube-controller-manager/>kube-controller-manager</a>
的一部分的 <code>csrapproving</code> 控制器是自动被启用的。
该控制器使用 <a href=/zh/docs/reference/access-authn-authz/authorization/#checking-api-access><code>SubjectAccessReview</code> API</a>
来确定是否某给定用户被授权请求 CSR，之后基于鉴权结果执行批复操作。
为了避免与其它批复组件发生冲突，内置的批复组件不会显式地拒绝任何 CSRs。
该组件仅是忽略未被授权的请求。
控制器也会作为垃圾收集的一部分清除已过期的证书。</p>
<h2 id=kubelet-configuration>kubelet 配置 </h2>
<p>最后，当主控节点被正确配置并且所有必要的身份认证和鉴权机制都就绪时，
我们可以配置 kubelet。</p>
<p>kubelet 需要以下配置来执行启动引导：</p>
<ul>
<li>一个用来存储所生成的密钥和证书的路径（可选，可以使用默认配置）</li>
<li>一个用来指向尚不存在的 <code>kubeconfig</code> 文件的路径；kubelet 会将启动引导
配置文件放到这个位置</li>
<li>一个指向启动引导 <code>kubeconfig</code> 文件的路径，用来提供 API 服务器的 URL
和启动引导凭据，例如，启动引导令牌</li>
<li>可选的：轮换证书的指令</li>
</ul>
<p>启动引导 <code>kubeconfig</code> 文件应该放在一个 kubelet 可访问的路径下，例如
<code>/var/lib/kubelet/bootstrap-kubeconfig</code>。</p>
<p>其格式与普通的 <code>kubeconfig</code> 文件完全相同。实例文件可能看起来像这样：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/var/lib/kubernetes/ca.pem<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://my.server.example.com:6443<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>bootstrap<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>kubelet-bootstrap<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>bootstrap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubelet-bootstrap<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>token</span>:<span style=color:#bbb> </span>07401b.f395accd246ae52d<span style=color:#bbb>
</span></code></pre></div>
<p>需要额外注意的一些因素有：</p>
<ul>
<li><code>certificate-authority</code>：指向 CA 文件的路径，用来对 kube-apiserver 所出示
的服务器证书进行验证</li>
<li><code>server</code>： 用来访问 kube-apiserver 的 URL</li>
<li><code>token</code>：要使用的令牌</li>
</ul>
<p>令牌的格式并不重要，只要它与 kube-apiserver 的期望匹配即可。
在上面的例子中，我们使用的是启动引导令牌。
如前所述，任何合法的身份认证方法都可以使用，不限于令牌。</p>
<p>因为启动引导 <code>kubeconfig</code> 文件是一个标准的 <code>kubeconfig</code> 文件，你可以使用
<code>kubectl</code> 来生成该文件。要生成上面的示例文件：</p>
<pre><code>kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-cluster bootstrap --server='https://my.server.example.com:6443' --certificate-authority=/var/lib/kubernetes/ca.pem
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-credentials kubelet-bootstrap --token=07401b.f395accd246ae52d
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-context bootstrap --user=kubelet-bootstrap --cluster=bootstrap
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig use-context bootstrap
</code></pre>
<p>要指示 kubelet 使用启动引导 <code>kubeconfig</code> 文件，可以使用下面的 kubelet 标志：</p>
<pre><code>--bootstrap-kubeconfig=&quot;/var/lib/kubelet/bootstrap-kubeconfig&quot; --kubeconfig=&quot;/var/lib/kubelet/kubeconfig&quot;
</code></pre>
<p>在启动 kubelet 时，如果 <code>--kubeconfig</code> 标志所指定的文件并不存在，会使用通过标志
<code>--bootstrap-kubeconfig</code> 所指定的启动引导 kubeconfig 配置来向 API 服务器请求
客户端证书。在证书请求被批复并被 kubelet 收回时，一个引用所生成的密钥和所获得
证书的 kubeconfig 文件会被写入到通过 <code>--kubeconfig</code> 所指定的文件路径下。
证书和密钥文件会被放到 <code>--cert-dir</code> 所指定的目录中。</p>
<h3 id=client-and-serving-certificates>客户和服务证书 </h3>
<p>前文所述的内容都与 kubelet <em>客户端</em> 证书相关，尤其是 kubelet 用来向
kube-apiserver 认证自身身份的证书。</p>
<p>kubelet 也可以使用 <em>服务（Serving）</em> 证书。kubelet 自身向外提供一个
HTTPS 末端，包含若干功能特性。要保证这些末端的安全性，kubelet 可以执行以下操作
之一：</p>
<ul>
<li>使用通过 <code>--tls-private-key-file</code> 和 <code>--tls-cert-file</code> 所设置的密钥和证书</li>
<li>如果没有提供密钥和证书，则创建自签名的密钥和证书</li>
<li>通过 CSR API 从集群服务器请求服务证书</li>
</ul>
<p>TLS 启动引导所提供的客户端证书默认被签名为仅用于 <code>client auth</code>（客户端认证），
因此不能作为提供服务的证书，或者 <code>server auth</code>。</p>
<p>不过，你可以启用服务器证书，至少可以部分地通过证书轮换来实现这点。</p>
<h3 id=certificate-rotation>证书轮换 </h3>
<p>Kubernetes v1.8 和更高版本的 kubelet 实现了对客户端证书与/或服务证书进行轮换
这一 Beta 特性。这一特性通过 kubelet 对应的 <code>RotateKubeletClientCertificate</code> 和
<code>RotateKubeletServerCertificate</code> 特性门控标志来控制，并且是默认启用的。</p>
<p><code>RotateKubeletClientCertificate</code> 会导致 kubelet 在其现有凭据即将过期时通过
创建新的 CSR 来轮换其客户端证书。要启用此功能特性，可将下面的标志传递给
kubelet：</p>
<pre><code>--rotate-certificates
</code></pre>
<p><code>RotateKubeletServerCertificate</code> 会让 kubelet 在启动引导其客户端凭据之后请求
一个服务证书 <strong>且</strong> 对该服务证书执行轮换操作。要启用此功能特性，将下面的标志
传递给 kubelet：</p>
<pre><code>--rotate-server-certificates
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>Kubernetes 核心中所实现的 CSR 批复控制器出于
<a href=https://github.com/kubernetes/community/pull/1982>安全原因</a>
并不会自动批复节点的 <em>服务</em> 证书。
要使用 <code>RotateKubeletServerCertificate</code> 功能特性，集群运维人员需要运行一个
定制的控制器或者手动批复服务证书的请求。</p>
<p>对 kubelet 服务证书的批复过程因集群部署而异，通常应该仅批复如下 CSR：</p>
<ol>
<li>由节点发出的请求（确保 <code>spec.username</code> 字段形式为 <code>system:node:&lt;nodeName></code>
且 <code>spec.groups</code> 包含 <code>system:nodes</code>）</li>
<li>请求中包含服务证书用法（确保 <code>spec.usages</code> 中包含 <code>server auth</code>，可选地也可
包含 <code>digital signature</code> 和 <code>key encipherment</code>，且不包含其它用法）</li>
<li>仅包含隶属于请求节点的 IP 和 DNS 的 <code>subjectAltNames</code>，没有 URI 和 Email
形式的 <code>subjectAltNames</code>（解析 <code>spec.request</code> 中的 x509 证书签名请求可以
检查 <code>subjectAltNames</code>）</li>
</ol>
</div>
<h2 id=other-authenticating-components>其它身份认证组件 </h2>
<p>本文所描述的所有 TLS 启动引导内容都与 kubelet 相关。不过，其它组件也可能需要
直接与 kube-apiserver 直接通信。容易想到的是 kube-proxy，同样隶属于
Kubernetes 的控制面并且运行在所有节点之上，不过也可能包含一些其它负责
监控或者联网的组件。</p>
<p>与 kubelet 类似，这些其它组件也需要一种向 kube-apiserver 认证身份的方法。
你可以用几种方法来生成这类凭据：</p>
<ul>
<li>较老的方式：和 kubelet 在 TLS 启动引导之前所做的一样，用类似的方式
创建和分发证书</li>
<li>DaemonSet：由于 kubelet 自身被加载到所有节点之上，并且有足够能力来启动基本服务，
你可以运行将 kube-proxy 和其它特定节点的服务作为 <code>kube-system</code> 名字空间中的
DaemonSet 来执行，而不是独立的进程。由于 DaemonSet 位于集群内部，你可以为其
指派一个合适的服务账户，使之具有适当的访问权限来完成其使命。这也许是配置此类
服务的最简单的方法。</li>
</ul>
<h2 id=kubectl-approval>kubectl 批复 </h2>
<p>CSRs 可以在控制器管理其内置的批复工作流之外被批复。</p>
<p>签名控制器并不会立即对所有证书请求执行签名操作。相反，它会等待这些请求被某
具有适当特权的用户标记为 “Approved（已批准）”状态。
这一流程有意允许由外部批复控制器来自动执行的批复，或者由控制器管理器内置的
批复控制器来自动批复。
不过，集群管理员也可以使用 <code>kubectl</code> 来手动批准证书请求。
管理员可以通过 <code>kubectl get csr</code> 来列举所有的 CSR，使用
<code>kubectl descsribe csr &lt;name></code> 来描述某个 CSR 的细节。
管理员可以使用 <code>kubectl certificate approve &lt;name</code> 来批准某 CSR，或者
<code>kubectl certificate deny &lt;name></code> 来拒绝某 CSR。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a6ae13190e147ef3922315c2091fc258>11 - 配置 API</h1>
</div>
<div class=td-content>
<h1 id=pg-2896357fe4f62fe85522254410e0be7d>11.1 - Client Authentication (v1beta1)</h1>
<h2 id=resource-types>Resource Types</h2>
<ul>
<li><a href=#client-authentication-k8s-io-v1beta1-ExecCredential>ExecCredential</a></li>
</ul>
<h2 id=client-authentication-k8s-io-v1beta1-ExecCredential><code>ExecCredential</code> </h2>
<p>ExecCredential is used by exec-based plugins to communicate credentials to
HTTP transports.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>client.authentication.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>ExecCredential</code></td></tr>
<tr><td><code>spec</code> <b>[Required]</b><br>
<a href=#client-authentication-k8s-io-v1beta1-ExecCredentialSpec><code>ExecCredentialSpec</code></a>
</td>
<td>
Spec holds information passed to the plugin by the transport.</td>
</tr>
<tr><td><code>status</code><br>
<a href=#client-authentication-k8s-io-v1beta1-ExecCredentialStatus><code>ExecCredentialStatus</code></a>
</td>
<td>
Status is filled in by the plugin and holds the credentials that the transport
should use to contact the API.</td>
</tr>
</tbody>
</table>
<h2 id=client-authentication-k8s-io-v1beta1-Cluster><code>Cluster</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#client-authentication-k8s-io-v1beta1-ExecCredentialSpec>ExecCredentialSpec</a></li>
</ul>
<p>Cluster contains information to allow an exec plugin to communicate
with the kubernetes cluster being authenticated to.</p>
<p>To ensure that this struct contains everything someone would need to communicate
with a kubernetes cluster (just like they would via a kubeconfig), the fields
should shadow "k8s.io/client-go/tools/clientcmd/api/v1".Cluster, with the exception
of CertificateAuthority, since CA data will always be passed to the plugin as bytes.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>server</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Server is the address of the kubernetes cluster (https://hostname:port).</td>
</tr>
<tr><td><code>tls-server-name</code><br>
<code>string</code>
</td>
<td>
TLSServerName is passed to the server for SNI and is used in the client to
check server certificates against. If ServerName is empty, the hostname
used to contact the server is used.</td>
</tr>
<tr><td><code>insecure-skip-tls-verify</code><br>
<code>bool</code>
</td>
<td>
InsecureSkipTLSVerify skips the validity check for the server's certificate.
This will make your HTTPS connections insecure.</td>
</tr>
<tr><td><code>certificate-authority-data</code><br>
<code>[]byte</code>
</td>
<td>
CAData contains PEM-encoded certificate authority certificates.
If empty, system roots should be used.</td>
</tr>
<tr><td><code>proxy-url</code><br>
<code>string</code>
</td>
<td>
ProxyURL is the URL to the proxy to be used for all requests to this
cluster.</td>
</tr>
<tr><td><code>config</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime/#RawExtension><code>k8s.io/apimachinery/pkg/runtime.RawExtension</code></a>
</td>
<td>
Config holds additional config data that is specific to the exec
plugin with regards to the cluster being authenticated to.
<p>This data is sourced from the clientcmd Cluster object's
extensions[client.authentication.k8s.io/exec] field:</p>
<p>clusters:</p>
<ul>
<li>name: my-cluster
cluster:
...
extensions:
<ul>
<li>name: client.authentication.k8s.io/exec # reserved extension name for per cluster exec config
extension:
audience: 06e3fbd18de8 # arbitrary config</li>
</ul>
</li>
</ul>
<p>In some environments, the user config may be exactly the same across many clusters
(i.e. call this exec plugin) minus some details that are specific to each cluster
such as the audience. This field allows the per cluster config to be directly
specified with the cluster info. Using this field to store secret data is not
recommended as one of the prime benefits of exec plugins is that no secrets need
to be stored directly in the kubeconfig.</td></p>
</tr>
</tbody>
</table>
<h2 id=client-authentication-k8s-io-v1beta1-ExecCredentialSpec><code>ExecCredentialSpec</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#client-authentication-k8s-io-v1beta1-ExecCredential>ExecCredential</a></li>
</ul>
<p>ExecCredentialSpec holds request and runtime specific information provided by
the transport.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>cluster</code><br>
<a href=#client-authentication-k8s-io-v1beta1-Cluster><code>Cluster</code></a>
</td>
<td>
Cluster contains information to allow an exec plugin to communicate with the
kubernetes cluster being authenticated to. Note that Cluster is non-nil only
when provideClusterInfo is set to true in the exec provider config (i.e.,
ExecConfig.ProvideClusterInfo).</td>
</tr>
</tbody>
</table>
<h2 id=client-authentication-k8s-io-v1beta1-ExecCredentialStatus><code>ExecCredentialStatus</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#client-authentication-k8s-io-v1beta1-ExecCredential>ExecCredential</a></li>
</ul>
<p>ExecCredentialStatus holds credentials for the transport to use.</p>
<p>Token and ClientKeyData are sensitive fields. This data should only be
transmitted in-memory between client and exec plugin process. Exec plugin
itself should at least be protected via file permissions.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>expirationTimestamp</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#time-v1-meta><code>meta/v1.Time</code></a>
</td>
<td>
ExpirationTimestamp indicates a time when the provided credentials expire.</td>
</tr>
<tr><td><code>token</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Token is a bearer token used by the client for request authentication.</td>
</tr>
<tr><td><code>clientCertificateData</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
PEM-encoded client TLS certificates (including intermediates, if any).</td>
</tr>
<tr><td><code>clientKeyData</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
PEM-encoded private key for the above certificate.</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8f61883225b6bed85530d1904e148392>11.2 - kube-apiserver Audit Configuration (v1)</h1>
<h2 id=resource-types>Resource Types</h2>
<ul>
<li><a href=#audit-k8s-io-v1-Event>Event</a></li>
<li><a href=#audit-k8s-io-v1-EventList>EventList</a></li>
<li><a href=#audit-k8s-io-v1-Policy>Policy</a></li>
<li><a href=#audit-k8s-io-v1-PolicyList>PolicyList</a></li>
</ul>
<h2 id=audit-k8s-io-v1-Event><code>Event</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#audit-k8s-io-v1-EventList>EventList</a></li>
</ul>
<p>Event captures all the information that can be included in an API audit log.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>audit.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>Event</code></td></tr>
<tr><td><code>level</code> <b>[Required]</b><br>
<a href=#audit-k8s-io-v1-Level><code>Level</code></a>
</td>
<td>
AuditLevel at which event was generated</td>
</tr>
<tr><td><code>auditID</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/types#UID><code>k8s.io/apimachinery/pkg/types.UID</code></a>
</td>
<td>
Unique audit ID, generated for each request.</td>
</tr>
<tr><td><code>stage</code> <b>[Required]</b><br>
<a href=#audit-k8s-io-v1-Stage><code>Stage</code></a>
</td>
<td>
Stage of the request handling when this event instance was generated.</td>
</tr>
<tr><td><code>requestURI</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
RequestURI is the request URI as sent by the client to a server.</td>
</tr>
<tr><td><code>verb</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Verb is the kubernetes verb associated with the request.
For non-resource requests, this is the lower-cased HTTP method.</td>
</tr>
<tr><td><code>user</code> <b>[Required]</b><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#userinfo-v1-authentication><code>authentication/v1.UserInfo</code></a>
</td>
<td>
Authenticated user information.</td>
</tr>
<tr><td><code>impersonatedUser</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#userinfo-v1-authentication><code>authentication/v1.UserInfo</code></a>
</td>
<td>
Impersonated user information.</td>
</tr>
<tr><td><code>sourceIPs</code><br>
<code>[]string</code>
</td>
<td>
Source IPs, from where the request originated and intermediate proxies.</td>
</tr>
<tr><td><code>userAgent</code><br>
<code>string</code>
</td>
<td>
UserAgent records the user agent string reported by the client.
Note that the UserAgent is provided by the client, and must not be trusted.</td>
</tr>
<tr><td><code>objectRef</code><br>
<a href=#audit-k8s-io-v1-ObjectReference><code>ObjectReference</code></a>
</td>
<td>
Object reference this request is targeted at.
Does not apply for List-type requests, or non-resource requests.</td>
</tr>
<tr><td><code>responseStatus</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#status-v1-meta><code>meta/v1.Status</code></a>
</td>
<td>
The response status, populated even when the ResponseObject is not a Status type.
For successful responses, this will only include the Code and StatusSuccess.
For non-status type error responses, this will be auto-populated with the error Message.</td>
</tr>
<tr><td><code>requestObject</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#Unknown><code>k8s.io/apimachinery/pkg/runtime.Unknown</code></a>
</td>
<td>
API object from the request, in JSON format. The RequestObject is recorded as-is in the request
(possibly re-encoded as JSON), prior to version conversion, defaulting, admission or
merging. It is an external versioned object type, and may not be a valid object on its own.
Omitted for non-resource requests. Only logged at Request Level and higher.</td>
</tr>
<tr><td><code>responseObject</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime#Unknown><code>k8s.io/apimachinery/pkg/runtime.Unknown</code></a>
</td>
<td>
API object returned in the response, in JSON. The ResponseObject is recorded after conversion
to the external type, and serialized as JSON. Omitted for non-resource requests. Only logged
at Response Level.</td>
</tr>
<tr><td><code>requestReceivedTimestamp</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#microtime-v1-meta><code>meta/v1.MicroTime</code></a>
</td>
<td>
Time the request reached the apiserver.</td>
</tr>
<tr><td><code>stageTimestamp</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#microtime-v1-meta><code>meta/v1.MicroTime</code></a>
</td>
<td>
Time the request reached current audit stage.</td>
</tr>
<tr><td><code>annotations</code><br>
<code>map[string]string</code>
</td>
<td>
Annotations is an unstructured key value map stored with an audit event that may be set by
plugins invoked in the request serving chain, including authentication, authorization and
admission plugins. Note that these annotations are for the audit event, and do not correspond
to the metadata.annotations of the submitted object. Keys should uniquely identify the informing
component to avoid name collisions (e.g. podsecuritypolicy.admission.k8s.io/policy). Values
should be short. Annotations are included in the Metadata level.</td>
</tr>
</tbody>
</table>
<h2 id=audit-k8s-io-v1-EventList><code>EventList</code> </h2>
<p>EventList is a list of audit Events.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>audit.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>EventList</code></td></tr>
<tr><td><code>metadata</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#listmeta-v1-meta><code>meta/v1.ListMeta</code></a>
</td>
<td>
<span class=text-muted>No description provided.</span>
</td>
</tr>
<tr><td><code>items</code> <b>[Required]</b><br>
<a href=#audit-k8s-io-v1-Event><code>[]Event</code></a>
</td>
<td>
<span class=text-muted>No description provided.</span>
</td>
</tr>
</tbody>
</table>
<h2 id=audit-k8s-io-v1-Policy><code>Policy</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#audit-k8s-io-v1-PolicyList>PolicyList</a></li>
</ul>
<p>Policy defines the configuration of audit logging, and the rules for how different request
categories are logged.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>audit.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>Policy</code></td></tr>
<tr><td><code>metadata</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#objectmeta-v1-meta><code>meta/v1.ObjectMeta</code></a>
</td>
<td>
ObjectMeta is included for interoperability with API infrastructure.Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.</td>
</tr>
<tr><td><code>rules</code> <b>[Required]</b><br>
<a href=#audit-k8s-io-v1-PolicyRule><code>[]PolicyRule</code></a>
</td>
<td>
Rules specify the audit Level a request should be recorded at.
A request may match multiple rules, in which case the FIRST matching rule is used.
The default audit level is None, but can be overridden by a catch-all rule at the end of the list.
PolicyRules are strictly ordered.</td>
</tr>
<tr><td><code>omitStages</code><br>
<a href=#audit-k8s-io-v1-Stage><code>[]Stage</code></a>
</td>
<td>
OmitStages is a list of stages for which no events are created. Note that this can also
be specified per rule in which case the union of both are omitted.</td>
</tr>
</tbody>
</table>
<h2 id=audit-k8s-io-v1-PolicyList><code>PolicyList</code> </h2>
<p>PolicyList is a list of audit Policies.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>audit.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>PolicyList</code></td></tr>
<tr><td><code>metadata</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#listmeta-v1-meta><code>meta/v1.ListMeta</code></a>
</td>
<td>
<span class=text-muted>No description provided.</span>
</td>
</tr>
<tr><td><code>items</code> <b>[Required]</b><br>
<a href=#audit-k8s-io-v1-Policy><code>[]Policy</code></a>
</td>
<td>
<span class=text-muted>No description provided.</span>
</td>
</tr>
</tbody>
</table>
<h2 id=audit-k8s-io-v1-GroupResources><code>GroupResources</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#audit-k8s-io-v1-PolicyRule>PolicyRule</a></li>
</ul>
<p>GroupResources represents resource kinds in an API group.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>group</code><br>
<code>string</code>
</td>
<td>
Group is the name of the API group that contains the resources.
The empty string represents the core API group.</td>
</tr>
<tr><td><code>resources</code><br>
<code>[]string</code>
</td>
<td>
Resources is a list of resources this rule applies to.
<p>For example:
'pods' matches pods.
'pods/log' matches the log subresource of pods.
'∗' matches all resources and their subresources.
'pods/∗' matches all subresources of pods.
'∗/scale' matches all scale subresources.</p>
<p>If wildcard is present, the validation rule will ensure resources do not
overlap with each other.</p>
<p>An empty list implies all resources and subresources in this API groups apply.</td></p>
</tr>
<tr><td><code>resourceNames</code><br>
<code>[]string</code>
</td>
<td>
ResourceNames is a list of resource instance names that the policy matches.
Using this field requires Resources to be specified.
An empty list implies that every instance of the resource is matched.</td>
</tr>
</tbody>
</table>
<h2 id=audit-k8s-io-v1-Level><code>Level</code> </h2>
<p>(Alias of <code>string</code>)</p>
<p><strong>Appears in:</strong></p>
<ul>
<li>
<p><a href=#audit-k8s-io-v1-Event>Event</a></p>
</li>
<li>
<p><a href=#audit-k8s-io-v1-PolicyRule>PolicyRule</a></p>
</li>
</ul>
<p>Level defines the amount of information logged during auditing</p>
<h2 id=audit-k8s-io-v1-ObjectReference><code>ObjectReference</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#audit-k8s-io-v1-Event>Event</a></li>
</ul>
<p>ObjectReference contains enough information to let you inspect or modify the referred object.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>resource</code><br>
<code>string</code>
</td>
<td>
<span class=text-muted>No description provided.</span>
</td>
</tr>
<tr><td><code>namespace</code><br>
<code>string</code>
</td>
<td>
<span class=text-muted>No description provided.</span>
</td>
</tr>
<tr><td><code>name</code><br>
<code>string</code>
</td>
<td>
<span class=text-muted>No description provided.</span>
</td>
</tr>
<tr><td><code>uid</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/types#UID><code>k8s.io/apimachinery/pkg/types.UID</code></a>
</td>
<td>
<span class=text-muted>No description provided.</span>
</td>
</tr>
<tr><td><code>apiGroup</code><br>
<code>string</code>
</td>
<td>
APIGroup is the name of the API group that contains the referred object.
The empty string represents the core API group.</td>
</tr>
<tr><td><code>apiVersion</code><br>
<code>string</code>
</td>
<td>
APIVersion is the version of the API group that contains the referred object.</td>
</tr>
<tr><td><code>resourceVersion</code><br>
<code>string</code>
</td>
<td>
<span class=text-muted>No description provided.</span>
</td>
</tr>
<tr><td><code>subresource</code><br>
<code>string</code>
</td>
<td>
<span class=text-muted>No description provided.</span>
</td>
</tr>
</tbody>
</table>
<h2 id=audit-k8s-io-v1-PolicyRule><code>PolicyRule</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#audit-k8s-io-v1-Policy>Policy</a></li>
</ul>
<p>PolicyRule maps requests based off metadata to an audit Level.
Requests must match the rules of every field (an intersection of rules).</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>level</code> <b>[Required]</b><br>
<a href=#audit-k8s-io-v1-Level><code>Level</code></a>
</td>
<td>
The Level that requests matching this rule are recorded at.</td>
</tr>
<tr><td><code>users</code><br>
<code>[]string</code>
</td>
<td>
The users (by authenticated user name) this rule applies to.
An empty list implies every user.</td>
</tr>
<tr><td><code>userGroups</code><br>
<code>[]string</code>
</td>
<td>
The user groups this rule applies to. A user is considered matching
if it is a member of any of the UserGroups.
An empty list implies every user group.</td>
</tr>
<tr><td><code>verbs</code><br>
<code>[]string</code>
</td>
<td>
The verbs that match this rule.
An empty list implies every verb.</td>
</tr>
<tr><td><code>resources</code><br>
<a href=#audit-k8s-io-v1-GroupResources><code>[]GroupResources</code></a>
</td>
<td>
Resources that this rule matches. An empty list implies all kinds in all API groups.</td>
</tr>
<tr><td><code>namespaces</code><br>
<code>[]string</code>
</td>
<td>
Namespaces that this rule matches.
The empty string "" matches non-namespaced resources.
An empty list implies every namespace.</td>
</tr>
<tr><td><code>nonResourceURLs</code><br>
<code>[]string</code>
</td>
<td>
NonResourceURLs is a set of URL paths that should be audited.
&#8727;s are allowed, but only as the full, final step in the path.
Examples:
"/metrics" - Log requests for apiserver metrics
"/healthz&#8727;" - Log all health checks</td>
</tr>
<tr><td><code>omitStages</code><br>
<a href=#audit-k8s-io-v1-Stage><code>[]Stage</code></a>
</td>
<td>
OmitStages is a list of stages for which no events are created. Note that this can also
be specified policy wide in which case the union of both are omitted.
An empty list means no restrictions will apply.</td>
</tr>
</tbody>
</table>
<h2 id=audit-k8s-io-v1-Stage><code>Stage</code> </h2>
<p>(Alias of <code>string</code>)</p>
<p><strong>Appears in:</strong></p>
<ul>
<li>
<p><a href=#audit-k8s-io-v1-Event>Event</a></p>
</li>
<li>
<p><a href=#audit-k8s-io-v1-Policy>Policy</a></p>
</li>
<li>
<p><a href=#audit-k8s-io-v1-PolicyRule>PolicyRule</a></p>
</li>
</ul>
<p>Stage defines the stages in request handling that audit events may be generated.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d8644f8d8b33ff33a31c8b55065eaf37>11.3 - kube-proxy Configuration (v1alpha1)</h1>
<h2 id=resource-types>Resource Types</h2>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<h2 id=kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration><code>KubeProxyConfiguration</code> </h2>
<p>KubeProxyConfiguration contains everything necessary to configure the
Kubernetes proxy server.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubeproxy.config.k8s.io/v1alpha1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>KubeProxyConfiguration</code></td></tr>
<tr><td><code>featureGates</code> <b>[Required]</b><br>
<code>map[string]bool</code>
</td>
<td>
featureGates is a map of feature names to bools that enable or disable alpha/experimental features.</td>
</tr>
<tr><td><code>bindAddress</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
bindAddress is the IP address for the proxy server to serve on (set to 0.0.0.0
for all interfaces)</td>
</tr>
<tr><td><code>healthzBindAddress</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
healthzBindAddress is the IP address and port for the health check server to serve on,
defaulting to 0.0.0.0:10256</td>
</tr>
<tr><td><code>metricsBindAddress</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
metricsBindAddress is the IP address and port for the metrics server to serve on,
defaulting to 127.0.0.1:10249 (set to 0.0.0.0 for all interfaces)</td>
</tr>
<tr><td><code>bindAddressHardFail</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
bindAddressHardFail, if true, kube-proxy will treat failure to bind to a port as fatal and exit</td>
</tr>
<tr><td><code>enableProfiling</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
enableProfiling enables profiling via web interface on /debug/pprof handler.
Profiling handlers will be handled by metrics server.</td>
</tr>
<tr><td><code>clusterCIDR</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
clusterCIDR is the CIDR range of the pods in the cluster. It is used to
bridge traffic coming from outside of the cluster. If not provided,
no off-cluster bridging will be performed.</td>
</tr>
<tr><td><code>hostnameOverride</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
hostnameOverride, if non-empty, will be used as the identity instead of the actual hostname.</td>
</tr>
<tr><td><code>clientConnection</code> <b>[Required]</b><br>
<a href=#ClientConnectionConfiguration><code>ClientConnectionConfiguration</code></a>
</td>
<td>
clientConnection specifies the kubeconfig file and client connection settings for the proxy
server to use when communicating with the apiserver.</td>
</tr>
<tr><td><code>iptables</code> <b>[Required]</b><br>
<a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyIPTablesConfiguration><code>KubeProxyIPTablesConfiguration</code></a>
</td>
<td>
iptables contains iptables-related configuration options.</td>
</tr>
<tr><td><code>ipvs</code> <b>[Required]</b><br>
<a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyIPVSConfiguration><code>KubeProxyIPVSConfiguration</code></a>
</td>
<td>
ipvs contains ipvs-related configuration options.</td>
</tr>
<tr><td><code>oomScoreAdj</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
oomScoreAdj is the oom-score-adj value for kube-proxy process. Values must be within
the range [-1000, 1000]</td>
</tr>
<tr><td><code>mode</code> <b>[Required]</b><br>
<a href=#kubeproxy-config-k8s-io-v1alpha1-ProxyMode><code>ProxyMode</code></a>
</td>
<td>
mode specifies which proxy mode to use.</td>
</tr>
<tr><td><code>portRange</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
portRange is the range of host ports (beginPort-endPort, inclusive) that may be consumed
in order to proxy service traffic. If unspecified (0-0) then ports will be randomly chosen.</td>
</tr>
<tr><td><code>udpIdleTimeout</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
udpIdleTimeout is how long an idle UDP connection will be kept open (e.g. '250ms', '2s').
Must be greater than 0. Only applicable for proxyMode=userspace.</td>
</tr>
<tr><td><code>conntrack</code> <b>[Required]</b><br>
<a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConntrackConfiguration><code>KubeProxyConntrackConfiguration</code></a>
</td>
<td>
conntrack contains conntrack-related configuration options.</td>
</tr>
<tr><td><code>configSyncPeriod</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
configSyncPeriod is how often configuration from the apiserver is refreshed. Must be greater
than 0.</td>
</tr>
<tr><td><code>nodePortAddresses</code> <b>[Required]</b><br>
<code>[]string</code>
</td>
<td>
nodePortAddresses is the --nodeport-addresses value for kube-proxy process. Values must be valid
IP blocks. These values are as a parameter to select the interfaces where nodeport works.
In case someone would like to expose a service on localhost for local visit and some other interfaces for
particular purpose, a list of IP blocks would do that.
If set it to "127.0.0.0/8", kube-proxy will only select the loopback interface for NodePort.
If set it to a non-zero IP block, kube-proxy will filter that down to just the IPs that applied to the node.
An empty string slice is meant to select all network interfaces.</td>
</tr>
<tr><td><code>winkernel</code> <b>[Required]</b><br>
<a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyWinkernelConfiguration><code>KubeProxyWinkernelConfiguration</code></a>
</td>
<td>
winkernel contains winkernel-related configuration options.</td>
</tr>
<tr><td><code>showHiddenMetricsForVersion</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
ShowHiddenMetricsForVersion is the version for which you want to show hidden metrics.</td>
</tr>
<tr><td><code>detectLocalMode</code> <b>[Required]</b><br>
<a href=#kubeproxy-config-k8s-io-v1alpha1-LocalMode><code>LocalMode</code></a>
</td>
<td>
DetectLocalMode determines mode to use for detecting local traffic, defaults to LocalModeClusterCIDR</td>
</tr>
</tbody>
</table>
<h2 id=kubeproxy-config-k8s-io-v1alpha1-KubeProxyConntrackConfiguration><code>KubeProxyConntrackConfiguration</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<p>KubeProxyConntrackConfiguration contains conntrack settings for
the Kubernetes proxy server.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>maxPerCore</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
maxPerCore is the maximum number of NAT connections to track
per CPU core (0 to leave the limit as-is and ignore min).</td>
</tr>
<tr><td><code>min</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
min is the minimum value of connect-tracking records to allocate,
regardless of conntrackMaxPerCore (set maxPerCore=0 to leave the limit as-is).</td>
</tr>
<tr><td><code>tcpEstablishedTimeout</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
tcpEstablishedTimeout is how long an idle TCP connection will be kept open
(e.g. '2s'). Must be greater than 0 to set.</td>
</tr>
<tr><td><code>tcpCloseWaitTimeout</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
tcpCloseWaitTimeout is how long an idle conntrack entry
in CLOSE_WAIT state will remain in the conntrack
table. (e.g. '60s'). Must be greater than 0 to set.</td>
</tr>
</tbody>
</table>
<h2 id=kubeproxy-config-k8s-io-v1alpha1-KubeProxyIPTablesConfiguration><code>KubeProxyIPTablesConfiguration</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<p>KubeProxyIPTablesConfiguration contains iptables-related configuration
details for the Kubernetes proxy server.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>masqueradeBit</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
masqueradeBit is the bit of the iptables fwmark space to use for SNAT if using
the pure iptables proxy mode. Values must be within the range [0, 31].</td>
</tr>
<tr><td><code>masqueradeAll</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
masqueradeAll tells kube-proxy to SNAT everything if using the pure iptables proxy mode.</td>
</tr>
<tr><td><code>syncPeriod</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
syncPeriod is the period that iptables rules are refreshed (e.g. '5s', '1m',
'2h22m'). Must be greater than 0.</td>
</tr>
<tr><td><code>minSyncPeriod</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
minSyncPeriod is the minimum period that iptables rules are refreshed (e.g. '5s', '1m',
'2h22m').</td>
</tr>
</tbody>
</table>
<h2 id=kubeproxy-config-k8s-io-v1alpha1-KubeProxyIPVSConfiguration><code>KubeProxyIPVSConfiguration</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<p>KubeProxyIPVSConfiguration contains ipvs-related configuration
details for the Kubernetes proxy server.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>syncPeriod</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
syncPeriod is the period that ipvs rules are refreshed (e.g. '5s', '1m',
'2h22m'). Must be greater than 0.</td>
</tr>
<tr><td><code>minSyncPeriod</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
minSyncPeriod is the minimum period that ipvs rules are refreshed (e.g. '5s', '1m',
'2h22m').</td>
</tr>
<tr><td><code>scheduler</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
ipvs scheduler</td>
</tr>
<tr><td><code>excludeCIDRs</code> <b>[Required]</b><br>
<code>[]string</code>
</td>
<td>
excludeCIDRs is a list of CIDR's which the ipvs proxier should not touch
when cleaning up ipvs services.</td>
</tr>
<tr><td><code>strictARP</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
strict ARP configure arp_ignore and arp_announce to avoid answering ARP queries
from kube-ipvs0 interface</td>
</tr>
<tr><td><code>tcpTimeout</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
tcpTimeout is the timeout value used for idle IPVS TCP sessions.
The default value is 0, which preserves the current timeout value on the system.</td>
</tr>
<tr><td><code>tcpFinTimeout</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
tcpFinTimeout is the timeout value used for IPVS TCP sessions after receiving a FIN.
The default value is 0, which preserves the current timeout value on the system.</td>
</tr>
<tr><td><code>udpTimeout</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
udpTimeout is the timeout value used for IPVS UDP packets.
The default value is 0, which preserves the current timeout value on the system.</td>
</tr>
</tbody>
</table>
<h2 id=kubeproxy-config-k8s-io-v1alpha1-KubeProxyWinkernelConfiguration><code>KubeProxyWinkernelConfiguration</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<p>KubeProxyWinkernelConfiguration contains Windows/HNS settings for
the Kubernetes proxy server.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>networkName</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
networkName is the name of the network kube-proxy will use
to create endpoints and policies</td>
</tr>
<tr><td><code>sourceVip</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
sourceVip is the IP address of the source VIP endoint used for
NAT when loadbalancing</td>
</tr>
<tr><td><code>enableDSR</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
enableDSR tells kube-proxy whether HNS policies should be created
with DSR</td>
</tr>
</tbody>
</table>
<h2 id=kubeproxy-config-k8s-io-v1alpha1-LocalMode><code>LocalMode</code> </h2>
<p>(Alias of <code>string</code>)</p>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<p>LocalMode represents modes to detect local traffic from the node</p>
<h2 id=kubeproxy-config-k8s-io-v1alpha1-ProxyMode><code>ProxyMode</code> </h2>
<p>(Alias of <code>string</code>)</p>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<p>ProxyMode represents modes used by the Kubernetes proxy server.</p>
<p>Currently, three modes of proxy are available in Linux platform: 'userspace' (older, going to be EOL), 'iptables'
(newer, faster), 'ipvs'(newest, better in performance and scalability).</p>
<p>Two modes of proxy are available in Windows platform: 'userspace'(older, stable) and 'kernelspace' (newer, faster).</p>
<p>In Linux platform, if proxy mode is blank, use the best-available proxy (currently iptables, but may change in the
future). If the iptables proxy is selected, regardless of how, but the system's kernel or iptables versions are
insufficient, this always falls back to the userspace proxy. IPVS mode will be enabled when proxy mode is set to 'ipvs',
and the fall back path is firstly iptables and then userspace.</p>
<p>In Windows platform, if proxy mode is blank, use the best-available proxy (currently userspace, but may change in the
future). If winkernel proxy is selected, regardless of how, but the Windows kernel can't support this mode of proxy,
this always falls back to the userspace proxy.</p>
<h2 id=ClientConnectionConfiguration><code>ClientConnectionConfiguration</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubeproxy-config-k8s-io-v1alpha1-KubeProxyConfiguration>KubeProxyConfiguration</a></li>
</ul>
<p>ClientConnectionConfiguration contains details for constructing a client.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>kubeconfig</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
kubeconfig is the path to a KubeConfig file.</td>
</tr>
<tr><td><code>acceptContentTypes</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
acceptContentTypes defines the Accept header sent by clients when connecting to a server, overriding the
default value of 'application/json'. This field will control all connections to the server used by a particular
client.</td>
</tr>
<tr><td><code>contentType</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
contentType is the content type used when sending data to the server from this client.</td>
</tr>
<tr><td><code>qps</code> <b>[Required]</b><br>
<code>float32</code>
</td>
<td>
qps controls the number of queries per second allowed for this connection.</td>
</tr>
<tr><td><code>burst</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
burst allows extra queries to accumulate when a client is exceeding its rate.</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d673af4d710babea20cd6b317502afb8>11.4 - kube-scheduler Configuration (v1beta1)</h1>
<h2 id=resource-types>Resource Types</h2>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-Policy>Policy</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-DefaultPreemptionArgs>DefaultPreemptionArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-InterPodAffinityArgs>InterPodAffinityArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-NodeAffinityArgs>NodeAffinityArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-NodeLabelArgs>NodeLabelArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-NodeResourcesFitArgs>NodeResourcesFitArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-NodeResourcesLeastAllocatedArgs>NodeResourcesLeastAllocatedArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-NodeResourcesMostAllocatedArgs>NodeResourcesMostAllocatedArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-PodTopologySpreadArgs>PodTopologySpreadArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-RequestedToCapacityRatioArgs>RequestedToCapacityRatioArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-ServiceAffinityArgs>ServiceAffinityArgs</a></li>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-VolumeBindingArgs>VolumeBindingArgs</a></li>
</ul>
<h2 id=kubescheduler-config-k8s-io-v1-Policy><code>Policy</code> </h2>
<p>Policy describes a struct for a policy resource used in api.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>Policy</code></td></tr>
<tr><td><code>predicates</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-PredicatePolicy><code>[]PredicatePolicy</code></a>
</td>
<td>
Holds the information to configure the fit predicate functions</td>
</tr>
<tr><td><code>priorities</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-PriorityPolicy><code>[]PriorityPolicy</code></a>
</td>
<td>
Holds the information to configure the priority functions</td>
</tr>
<tr><td><code>extenders</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-LegacyExtender><code>[]LegacyExtender</code></a>
</td>
<td>
Holds the information to communicate with the extender(s)</td>
</tr>
<tr><td><code>hardPodAffinitySymmetricWeight</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
RequiredDuringScheduling affinity is not symmetric, but there is an implicit PreferredDuringScheduling affinity rule
corresponding to every RequiredDuringScheduling affinity rule.
HardPodAffinitySymmetricWeight represents the weight of implicit PreferredDuringScheduling affinity rule, in the range 1-100.</td>
</tr>
<tr><td><code>alwaysCheckAllPredicates</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
When AlwaysCheckAllPredicates is set to true, scheduler checks all
the configured predicates even after one or more of them fails.
When the flag is set to false, scheduler skips checking the rest
of the predicates after it finds one predicate that failed.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-ExtenderManagedResource><code>ExtenderManagedResource</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li>
<p><a href=#kubescheduler-config-k8s-io-v1beta1-Extender>Extender</a></p>
</li>
<li>
<p><a href=#kubescheduler-config-k8s-io-v1-LegacyExtender>LegacyExtender</a></p>
</li>
</ul>
<p>ExtenderManagedResource describes the arguments of extended resources
managed by an extender.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Name is the extended resource name.</td>
</tr>
<tr><td><code>ignoredByScheduler</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
IgnoredByScheduler indicates whether kube-scheduler should ignore this
resource when applying predicates.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-ExtenderTLSConfig><code>ExtenderTLSConfig</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li>
<p><a href=#kubescheduler-config-k8s-io-v1beta1-Extender>Extender</a></p>
</li>
<li>
<p><a href=#kubescheduler-config-k8s-io-v1-LegacyExtender>LegacyExtender</a></p>
</li>
</ul>
<p>ExtenderTLSConfig contains settings to enable TLS with extender</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>insecure</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
Server should be accessed without verifying the TLS certificate. For testing only.</td>
</tr>
<tr><td><code>serverName</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
ServerName is passed to the server for SNI and is used in the client to check server
certificates against. If ServerName is empty, the hostname used to contact the
server is used.</td>
</tr>
<tr><td><code>certFile</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Server requires TLS client certificate authentication</td>
</tr>
<tr><td><code>keyFile</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Server requires TLS client certificate authentication</td>
</tr>
<tr><td><code>caFile</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Trusted root certificates for server</td>
</tr>
<tr><td><code>certData</code> <b>[Required]</b><br>
<code>[]byte</code>
</td>
<td>
CertData holds PEM-encoded bytes (typically read from a client certificate file).
CertData takes precedence over CertFile</td>
</tr>
<tr><td><code>keyData</code> <b>[Required]</b><br>
<code>[]byte</code>
</td>
<td>
KeyData holds PEM-encoded bytes (typically read from a client certificate key file).
KeyData takes precedence over KeyFile</td>
</tr>
<tr><td><code>caData</code> <b>[Required]</b><br>
<code>[]byte</code>
</td>
<td>
CAData holds PEM-encoded bytes (typically read from a root certificates bundle).
CAData takes precedence over CAFile</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-LabelPreference><code>LabelPreference</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-PriorityArgument>PriorityArgument</a></li>
</ul>
<p>LabelPreference holds the parameters that are used to configure the corresponding priority function</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>label</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Used to identify node "groups"</td>
</tr>
<tr><td><code>presence</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
This is a boolean flag
If true, higher priority is given to nodes that have the label
If false, higher priority is given to nodes that do not have the label</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-LabelsPresence><code>LabelsPresence</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-PredicateArgument>PredicateArgument</a></li>
</ul>
<p>LabelsPresence holds the parameters that are used to configure the corresponding predicate in scheduler policy configuration.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>labels</code> <b>[Required]</b><br>
<code>[]string</code>
</td>
<td>
The list of labels that identify node "groups"
All of the labels should be either present (or absent) for the node to be considered a fit for hosting the pod</td>
</tr>
<tr><td><code>presence</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
The boolean flag that indicates whether the labels should be present or absent from the node</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-LegacyExtender><code>LegacyExtender</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-Policy>Policy</a></li>
</ul>
<p>LegacyExtender holds the parameters used to communicate with the extender. If a verb is unspecified/empty,
it is assumed that the extender chose not to provide that extension.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>urlPrefix</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
URLPrefix at which the extender is available</td>
</tr>
<tr><td><code>filterVerb</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Verb for the filter call, empty if not supported. This verb is appended to the URLPrefix when issuing the filter call to extender.</td>
</tr>
<tr><td><code>preemptVerb</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Verb for the preempt call, empty if not supported. This verb is appended to the URLPrefix when issuing the preempt call to extender.</td>
</tr>
<tr><td><code>prioritizeVerb</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Verb for the prioritize call, empty if not supported. This verb is appended to the URLPrefix when issuing the prioritize call to extender.</td>
</tr>
<tr><td><code>weight</code> <b>[Required]</b><br>
<code>int64</code>
</td>
<td>
The numeric multiplier for the node scores that the prioritize call generates.
The weight should be a positive integer</td>
</tr>
<tr><td><code>bindVerb</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Verb for the bind call, empty if not supported. This verb is appended to the URLPrefix when issuing the bind call to extender.
If this method is implemented by the extender, it is the extender's responsibility to bind the pod to apiserver. Only one extender
can implement this function.</td>
</tr>
<tr><td><code>enableHttps</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
EnableHTTPS specifies whether https should be used to communicate with the extender</td>
</tr>
<tr><td><code>tlsConfig</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-ExtenderTLSConfig><code>ExtenderTLSConfig</code></a>
</td>
<td>
TLSConfig specifies the transport layer security config</td>
</tr>
<tr><td><code>httpTimeout</code> <b>[Required]</b><br>
<a href=https://godoc.org/time#Duration><code>time.Duration</code></a>
</td>
<td>
HTTPTimeout specifies the timeout duration for a call to the extender. Filter timeout fails the scheduling of the pod. Prioritize
timeout is ignored, k8s/other extenders priorities are used to select the node.</td>
</tr>
<tr><td><code>nodeCacheCapable</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
NodeCacheCapable specifies that the extender is capable of caching node information,
so the scheduler should only send minimal information about the eligible nodes
assuming that the extender already cached full details of all nodes in the cluster</td>
</tr>
<tr><td><code>managedResources</code><br>
<a href=#kubescheduler-config-k8s-io-v1-ExtenderManagedResource><code>[]ExtenderManagedResource</code></a>
</td>
<td>
ManagedResources is a list of extended resources that are managed by
this extender.
- A pod will be sent to the extender on the Filter, Prioritize and Bind
(if the extender is the binder) phases iff the pod requests at least
one of the extended resources in this list. If empty or unspecified,
all pods will be sent to this extender.
- If IgnoredByScheduler is set to true for a resource, kube-scheduler
will skip checking the resource in predicates.</td>
</tr>
<tr><td><code>ignorable</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
Ignorable specifies if the extender is ignorable, i.e. scheduling should not
fail when the extender returns an error or is not reachable.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-PredicateArgument><code>PredicateArgument</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-PredicatePolicy>PredicatePolicy</a></li>
</ul>
<p>PredicateArgument represents the arguments to configure predicate functions in scheduler policy configuration.
Only one of its members may be specified</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>serviceAffinity</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-ServiceAffinity><code>ServiceAffinity</code></a>
</td>
<td>
The predicate that provides affinity for pods belonging to a service
It uses a label to identify nodes that belong to the same "group"</td>
</tr>
<tr><td><code>labelsPresence</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-LabelsPresence><code>LabelsPresence</code></a>
</td>
<td>
The predicate that checks whether a particular node has a certain label
defined or not, regardless of value</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-PredicatePolicy><code>PredicatePolicy</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-Policy>Policy</a></li>
</ul>
<p>PredicatePolicy describes a struct of a predicate policy.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Identifier of the predicate policy
For a custom predicate, the name can be user-defined
For the Kubernetes provided predicates, the name is the identifier of the pre-defined predicate</td>
</tr>
<tr><td><code>argument</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-PredicateArgument><code>PredicateArgument</code></a>
</td>
<td>
Holds the parameters to configure the given predicate</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-PriorityArgument><code>PriorityArgument</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-PriorityPolicy>PriorityPolicy</a></li>
</ul>
<p>PriorityArgument represents the arguments to configure priority functions in scheduler policy configuration.
Only one of its members may be specified</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>serviceAntiAffinity</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-ServiceAntiAffinity><code>ServiceAntiAffinity</code></a>
</td>
<td>
The priority function that ensures a good spread (anti-affinity) for pods belonging to a service
It uses a label to identify nodes that belong to the same "group"</td>
</tr>
<tr><td><code>labelPreference</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-LabelPreference><code>LabelPreference</code></a>
</td>
<td>
The priority function that checks whether a particular node has a certain label
defined or not, regardless of value</td>
</tr>
<tr><td><code>requestedToCapacityRatioArguments</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments><code>RequestedToCapacityRatioArguments</code></a>
</td>
<td>
The RequestedToCapacityRatio priority function is parametrized with function shape.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-PriorityPolicy><code>PriorityPolicy</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-Policy>Policy</a></li>
</ul>
<p>PriorityPolicy describes a struct of a priority policy.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Identifier of the priority policy
For a custom priority, the name can be user-defined
For the Kubernetes provided priority functions, the name is the identifier of the pre-defined priority function</td>
</tr>
<tr><td><code>weight</code> <b>[Required]</b><br>
<code>int64</code>
</td>
<td>
The numeric multiplier for the node scores that the priority function generates
The weight should be non-zero and can be a positive or a negative integer</td>
</tr>
<tr><td><code>argument</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-PriorityArgument><code>PriorityArgument</code></a>
</td>
<td>
Holds the parameters to configure the given priority function</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments><code>RequestedToCapacityRatioArguments</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-PriorityArgument>PriorityArgument</a></li>
</ul>
<p>RequestedToCapacityRatioArguments holds arguments specific to RequestedToCapacityRatio priority function.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>shape</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-UtilizationShapePoint><code>[]UtilizationShapePoint</code></a>
</td>
<td>
Array of point defining priority function shape.</td>
</tr>
<tr><td><code>resources</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-ResourceSpec><code>[]ResourceSpec</code></a>
</td>
<td>
<span class=text-muted>No description provided.</span>
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-ResourceSpec><code>ResourceSpec</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments>RequestedToCapacityRatioArguments</a></li>
</ul>
<p>ResourceSpec represents single resource and weight for bin packing of priority RequestedToCapacityRatioArguments.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Name of the resource to be managed by RequestedToCapacityRatio function.</td>
</tr>
<tr><td><code>weight</code> <b>[Required]</b><br>
<code>int64</code>
</td>
<td>
Weight of the resource.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-ServiceAffinity><code>ServiceAffinity</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-PredicateArgument>PredicateArgument</a></li>
</ul>
<p>ServiceAffinity holds the parameters that are used to configure the corresponding predicate in scheduler policy configuration.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>labels</code> <b>[Required]</b><br>
<code>[]string</code>
</td>
<td>
The list of labels that identify node "groups"
All of the labels should match for the node to be considered a fit for hosting the pod</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-ServiceAntiAffinity><code>ServiceAntiAffinity</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-PriorityArgument>PriorityArgument</a></li>
</ul>
<p>ServiceAntiAffinity holds the parameters that are used to configure the corresponding priority function</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>label</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Used to identify node "groups"</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-UtilizationShapePoint><code>UtilizationShapePoint</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments>RequestedToCapacityRatioArguments</a></li>
</ul>
<p>UtilizationShapePoint represents single point of priority function shape.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>utilization</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
Utilization (x axis). Valid values are 0 to 100. Fully utilized node maps to 100.</td>
</tr>
<tr><td><code>score</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
Score assigned to given utilization (y axis). Valid values are 0 to 10.</td>
</tr>
</tbody>
</table>
<h2 id=ClientConnectionConfiguration><code>ClientConnectionConfiguration</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>ClientConnectionConfiguration contains details for constructing a client.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>kubeconfig</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
kubeconfig is the path to a KubeConfig file.</td>
</tr>
<tr><td><code>acceptContentTypes</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
acceptContentTypes defines the Accept header sent by clients when connecting to a server, overriding the
default value of 'application/json'. This field will control all connections to the server used by a particular
client.</td>
</tr>
<tr><td><code>contentType</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
contentType is the content type used when sending data to the server from this client.</td>
</tr>
<tr><td><code>qps</code> <b>[Required]</b><br>
<code>float32</code>
</td>
<td>
qps controls the number of queries per second allowed for this connection.</td>
</tr>
<tr><td><code>burst</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
burst allows extra queries to accumulate when a client is exceeding its rate.</td>
</tr>
</tbody>
</table>
<h2 id=DebuggingConfiguration><code>DebuggingConfiguration</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>DebuggingConfiguration holds configuration for Debugging related features.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>enableProfiling</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
enableProfiling enables profiling via web interface host:port/debug/pprof/</td>
</tr>
<tr><td><code>enableContentionProfiling</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
enableContentionProfiling enables lock contention profiling, if
enableProfiling is true.</td>
</tr>
</tbody>
</table>
<h2 id=LeaderElectionConfiguration><code>LeaderElectionConfiguration</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>LeaderElectionConfiguration defines the configuration of leader election
clients for components that can run with leader election enabled.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>leaderElect</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
leaderElect enables a leader election client to gain leadership
before executing the main loop. Enable this when running replicated
components for high availability.</td>
</tr>
<tr><td><code>leaseDuration</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
leaseDuration is the duration that non-leader candidates will wait
after observing a leadership renewal until attempting to acquire
leadership of a led but unrenewed leader slot. This is effectively the
maximum duration that a leader can be stopped before it is replaced
by another candidate. This is only applicable if leader election is
enabled.</td>
</tr>
<tr><td><code>renewDeadline</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
renewDeadline is the interval between attempts by the acting master to
renew a leadership slot before it stops leading. This must be less
than or equal to the lease duration. This is only applicable if leader
election is enabled.</td>
</tr>
<tr><td><code>retryPeriod</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
retryPeriod is the duration the clients should wait between attempting
acquisition and renewal of a leadership. This is only applicable if
leader election is enabled.</td>
</tr>
<tr><td><code>resourceLock</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
resourceLock indicates the resource object type that will be used to lock
during leader election cycles.</td>
</tr>
<tr><td><code>resourceName</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
resourceName indicates the name of resource object that will be used to lock
during leader election cycles.</td>
</tr>
<tr><td><code>resourceNamespace</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
resourceName indicates the namespace of resource object that will be used to lock
during leader election cycles.</td>
</tr>
</tbody>
</table>
<h2 id=LoggingConfiguration><code>LoggingConfiguration</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a></li>
</ul>
<p>LoggingConfiguration contains logging options
Refer <a href=https://github.com/kubernetes/component-base/blob/master/logs/options.go>Logs Options</a> for more information.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>format</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Format Flag specifies the structure of log messages.
default value of format is `text`</td>
</tr>
<tr><td><code>sanitization</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
[Experimental] When enabled prevents logging of fields tagged as sensitive (passwords, keys, tokens).
Runtime log sanitization may introduce significant computation overhead and therefore should not be enabled in production.`)</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-DefaultPreemptionArgs><code>DefaultPreemptionArgs</code> </h2>
<p>DefaultPreemptionArgs holds arguments used to configure the
DefaultPreemption plugin.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>DefaultPreemptionArgs</code></td></tr>
<tr><td><code>minCandidateNodesPercentage</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
MinCandidateNodesPercentage is the minimum number of candidates to
shortlist when dry running preemption as a percentage of number of nodes.
Must be in the range [0, 100]. Defaults to 10% of the cluster size if
unspecified.</td>
</tr>
<tr><td><code>minCandidateNodesAbsolute</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
MinCandidateNodesAbsolute is the absolute minimum number of candidates to
shortlist. The likely number of candidates enumerated for dry running
preemption is given by the formula:
numCandidates = max(numNodes &#8727; minCandidateNodesPercentage, minCandidateNodesAbsolute)
We say "likely" because there are other factors such as PDB violations
that play a role in the number of candidates shortlisted. Must be at least
0 nodes. Defaults to 100 nodes if unspecified.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-InterPodAffinityArgs><code>InterPodAffinityArgs</code> </h2>
<p>InterPodAffinityArgs holds arguments used to configure the InterPodAffinity plugin.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>InterPodAffinityArgs</code></td></tr>
<tr><td><code>hardPodAffinityWeight</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
HardPodAffinityWeight is the scoring weight for existing pods with a
matching hard affinity to the incoming pod.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-KubeSchedulerConfiguration><code>KubeSchedulerConfiguration</code> </h2>
<p>KubeSchedulerConfiguration configures a scheduler</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>KubeSchedulerConfiguration</code></td></tr>
<tr><td><code>parallelism</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
Parallelism defines the amount of parallelism in algorithms for scheduling a Pods. Must be greater than 0. Defaults to 16</td>
</tr>
<tr><td><code>leaderElection</code> <b>[Required]</b><br>
<a href=#LeaderElectionConfiguration><code>LeaderElectionConfiguration</code></a>
</td>
<td>
LeaderElection defines the configuration of leader election client.</td>
</tr>
<tr><td><code>clientConnection</code> <b>[Required]</b><br>
<a href=#ClientConnectionConfiguration><code>ClientConnectionConfiguration</code></a>
</td>
<td>
ClientConnection specifies the kubeconfig file and client connection
settings for the proxy server to use when communicating with the apiserver.</td>
</tr>
<tr><td><code>healthzBindAddress</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
HealthzBindAddress is the IP address and port for the health check server to serve on,
defaulting to 0.0.0.0:10251</td>
</tr>
<tr><td><code>metricsBindAddress</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
MetricsBindAddress is the IP address and port for the metrics server to
serve on, defaulting to 0.0.0.0:10251.</td>
</tr>
<tr><td><code>DebuggingConfiguration</code> <b>[Required]</b><br>
<a href=#DebuggingConfiguration><code>DebuggingConfiguration</code></a>
</td>
<td>(Members of <code>DebuggingConfiguration</code> are embedded into this type.)
DebuggingConfiguration holds configuration for Debugging related features
TODO: We might wanna make this a substruct like Debugging componentbaseconfigv1alpha1.DebuggingConfiguration</td>
</tr>
<tr><td><code>percentageOfNodesToScore</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
PercentageOfNodesToScore is the percentage of all nodes that once found feasible
for running a pod, the scheduler stops its search for more feasible nodes in
the cluster. This helps improve scheduler's performance. Scheduler always tries to find
at least "minFeasibleNodesToFind" feasible nodes no matter what the value of this flag is.
Example: if the cluster size is 500 nodes and the value of this flag is 30,
then scheduler stops finding further feasible nodes once it finds 150 feasible ones.
When the value is 0, default percentage (5%--50% based on the size of the cluster) of the
nodes will be scored.</td>
</tr>
<tr><td><code>podInitialBackoffSeconds</code> <b>[Required]</b><br>
<code>int64</code>
</td>
<td>
PodInitialBackoffSeconds is the initial backoff for unschedulable pods.
If specified, it must be greater than 0. If this value is null, the default value (1s)
will be used.</td>
</tr>
<tr><td><code>podMaxBackoffSeconds</code> <b>[Required]</b><br>
<code>int64</code>
</td>
<td>
PodMaxBackoffSeconds is the max backoff for unschedulable pods.
If specified, it must be greater than podInitialBackoffSeconds. If this value is null,
the default value (10s) will be used.</td>
</tr>
<tr><td><code>profiles</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerProfile><code>[]KubeSchedulerProfile</code></a>
</td>
<td>
Profiles are scheduling profiles that kube-scheduler supports. Pods can
choose to be scheduled under a particular profile by setting its associated
scheduler name. Pods that don't specify any scheduler name are scheduled
with the "default-scheduler" profile, if present here.</td>
</tr>
<tr><td><code>extenders</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-Extender><code>[]Extender</code></a>
</td>
<td>
Extenders are the list of scheduler extenders, each holding the values of how to communicate
with the extender. These extenders are shared by all scheduler profiles.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-NodeAffinityArgs><code>NodeAffinityArgs</code> </h2>
<p>NodeAffinityArgs holds arguments to configure the NodeAffinity plugin.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>NodeAffinityArgs</code></td></tr>
<tr><td><code>addedAffinity</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#nodeaffinity-v1-core><code>core/v1.NodeAffinity</code></a>
</td>
<td>
AddedAffinity is applied to all Pods additionally to the NodeAffinity
specified in the PodSpec. That is, Nodes need to satisfy AddedAffinity
AND .spec.NodeAffinity. AddedAffinity is empty by default (all Nodes
match).
When AddedAffinity is used, some Pods with affinity requirements that match
a specific Node (such as Daemonset Pods) might remain unschedulable.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-NodeLabelArgs><code>NodeLabelArgs</code> </h2>
<p>NodeLabelArgs holds arguments used to configure the NodeLabel plugin.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>NodeLabelArgs</code></td></tr>
<tr><td><code>presentLabels</code> <b>[Required]</b><br>
<code>[]string</code>
</td>
<td>
PresentLabels should be present for the node to be considered a fit for hosting the pod</td>
</tr>
<tr><td><code>absentLabels</code> <b>[Required]</b><br>
<code>[]string</code>
</td>
<td>
AbsentLabels should be absent for the node to be considered a fit for hosting the pod</td>
</tr>
<tr><td><code>presentLabelsPreference</code> <b>[Required]</b><br>
<code>[]string</code>
</td>
<td>
Nodes that have labels in the list will get a higher score.</td>
</tr>
<tr><td><code>absentLabelsPreference</code> <b>[Required]</b><br>
<code>[]string</code>
</td>
<td>
Nodes that don't have labels in the list will get a higher score.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-NodeResourcesFitArgs><code>NodeResourcesFitArgs</code> </h2>
<p>NodeResourcesFitArgs holds arguments used to configure the NodeResourcesFit plugin.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>NodeResourcesFitArgs</code></td></tr>
<tr><td><code>ignoredResources</code> <b>[Required]</b><br>
<code>[]string</code>
</td>
<td>
IgnoredResources is the list of resources that NodeResources fit filter
should ignore.</td>
</tr>
<tr><td><code>ignoredResourceGroups</code> <b>[Required]</b><br>
<code>[]string</code>
</td>
<td>
IgnoredResourceGroups defines the list of resource groups that NodeResources fit filter should ignore.
e.g. if group is ["example.com"], it will ignore all resource names that begin
with "example.com", such as "example.com/aaa" and "example.com/bbb".
A resource group name can't contain '/'.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-NodeResourcesLeastAllocatedArgs><code>NodeResourcesLeastAllocatedArgs</code> </h2>
<p>NodeResourcesLeastAllocatedArgs holds arguments used to configure NodeResourcesLeastAllocated plugin.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>NodeResourcesLeastAllocatedArgs</code></td></tr>
<tr><td><code>resources</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-ResourceSpec><code>[]ResourceSpec</code></a>
</td>
<td>
Resources to be managed, if no resource is provided, default resource set with both
the weight of "cpu" and "memory" set to "1" will be applied.
Resource with "0" weight will not accountable for the final score.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-NodeResourcesMostAllocatedArgs><code>NodeResourcesMostAllocatedArgs</code> </h2>
<p>NodeResourcesMostAllocatedArgs holds arguments used to configure NodeResourcesMostAllocated plugin.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>NodeResourcesMostAllocatedArgs</code></td></tr>
<tr><td><code>resources</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-ResourceSpec><code>[]ResourceSpec</code></a>
</td>
<td>
Resources to be managed, if no resource is provided, default resource set with both
the weight of "cpu" and "memory" set to "1" will be applied.
Resource with "0" weight will not accountable for the final score.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-PodTopologySpreadArgs><code>PodTopologySpreadArgs</code> </h2>
<p>PodTopologySpreadArgs holds arguments used to configure the PodTopologySpread plugin.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>PodTopologySpreadArgs</code></td></tr>
<tr><td><code>defaultConstraints</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#topologyspreadconstraint-v1-core><code>[]core/v1.TopologySpreadConstraint</code></a>
</td>
<td>
DefaultConstraints defines topology spread constraints to be applied to
Pods that don't define any in `pod.spec.topologySpreadConstraints`.
`.defaultConstraints[&#8727;].labelSelectors` must be empty, as they are
deduced from the Pod's membership to Services, ReplicationControllers,
ReplicaSets or StatefulSets.
When not empty, .defaultingType must be "List".</td>
</tr>
<tr><td><code>defaultingType</code><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-PodTopologySpreadConstraintsDefaulting><code>PodTopologySpreadConstraintsDefaulting</code></a>
</td>
<td>
DefaultingType determines how .defaultConstraints are deduced. Can be one
of "System" or "List".
<ul>
<li>"System": Use kubernetes defined constraints that spread Pods among
Nodes and Zones.</li>
<li>"List": Use constraints defined in .defaultConstraints.</li>
</ul>
<p>Defaults to "List" if feature gate DefaultPodTopologySpread is disabled
and to "System" if enabled.</td></p>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-RequestedToCapacityRatioArgs><code>RequestedToCapacityRatioArgs</code> </h2>
<p>RequestedToCapacityRatioArgs holds arguments used to configure RequestedToCapacityRatio plugin.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>RequestedToCapacityRatioArgs</code></td></tr>
<tr><td><code>shape</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-UtilizationShapePoint><code>[]UtilizationShapePoint</code></a>
</td>
<td>
Points defining priority function shape</td>
</tr>
<tr><td><code>resources</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-ResourceSpec><code>[]ResourceSpec</code></a>
</td>
<td>
Resources to be managed</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-ServiceAffinityArgs><code>ServiceAffinityArgs</code> </h2>
<p>ServiceAffinityArgs holds arguments used to configure the ServiceAffinity plugin.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>ServiceAffinityArgs</code></td></tr>
<tr><td><code>affinityLabels</code> <b>[Required]</b><br>
<code>[]string</code>
</td>
<td>
AffinityLabels are homogeneous for pods that are scheduled to a node.
(i.e. it returns true IFF this pod can be added to this node such that all other pods in
the same service are running on nodes with the exact same values for Labels).</td>
</tr>
<tr><td><code>antiAffinityLabelsPreference</code> <b>[Required]</b><br>
<code>[]string</code>
</td>
<td>
AntiAffinityLabelsPreference are the labels to consider for service anti affinity scoring.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-VolumeBindingArgs><code>VolumeBindingArgs</code> </h2>
<p>VolumeBindingArgs holds arguments used to configure the VolumeBinding plugin.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>VolumeBindingArgs</code></td></tr>
<tr><td><code>bindTimeoutSeconds</code> <b>[Required]</b><br>
<code>int64</code>
</td>
<td>
BindTimeoutSeconds is the timeout in seconds in volume binding operation.
Value must be non-negative integer. The value zero indicates no waiting.
If this value is nil, the default value (600) will be used.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-Extender><code>Extender</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>Extender holds the parameters used to communicate with the extender. If a verb is unspecified/empty,
it is assumed that the extender chose not to provide that extension.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>urlPrefix</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
URLPrefix at which the extender is available</td>
</tr>
<tr><td><code>filterVerb</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Verb for the filter call, empty if not supported. This verb is appended to the URLPrefix when issuing the filter call to extender.</td>
</tr>
<tr><td><code>preemptVerb</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Verb for the preempt call, empty if not supported. This verb is appended to the URLPrefix when issuing the preempt call to extender.</td>
</tr>
<tr><td><code>prioritizeVerb</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Verb for the prioritize call, empty if not supported. This verb is appended to the URLPrefix when issuing the prioritize call to extender.</td>
</tr>
<tr><td><code>weight</code> <b>[Required]</b><br>
<code>int64</code>
</td>
<td>
The numeric multiplier for the node scores that the prioritize call generates.
The weight should be a positive integer</td>
</tr>
<tr><td><code>bindVerb</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Verb for the bind call, empty if not supported. This verb is appended to the URLPrefix when issuing the bind call to extender.
If this method is implemented by the extender, it is the extender's responsibility to bind the pod to apiserver. Only one extender
can implement this function.</td>
</tr>
<tr><td><code>enableHTTPS</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
EnableHTTPS specifies whether https should be used to communicate with the extender</td>
</tr>
<tr><td><code>tlsConfig</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-ExtenderTLSConfig><code>ExtenderTLSConfig</code></a>
</td>
<td>
TLSConfig specifies the transport layer security config</td>
</tr>
<tr><td><code>httpTimeout</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
HTTPTimeout specifies the timeout duration for a call to the extender. Filter timeout fails the scheduling of the pod. Prioritize
timeout is ignored, k8s/other extenders priorities are used to select the node.</td>
</tr>
<tr><td><code>nodeCacheCapable</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
NodeCacheCapable specifies that the extender is capable of caching node information,
so the scheduler should only send minimal information about the eligible nodes
assuming that the extender already cached full details of all nodes in the cluster</td>
</tr>
<tr><td><code>managedResources</code><br>
<a href=#kubescheduler-config-k8s-io-v1-ExtenderManagedResource><code>[]ExtenderManagedResource</code></a>
</td>
<td>
ManagedResources is a list of extended resources that are managed by
this extender.
- A pod will be sent to the extender on the Filter, Prioritize and Bind
(if the extender is the binder) phases iff the pod requests at least
one of the extended resources in this list. If empty or unspecified,
all pods will be sent to this extender.
- If IgnoredByScheduler is set to true for a resource, kube-scheduler
will skip checking the resource in predicates.</td>
</tr>
<tr><td><code>ignorable</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
Ignorable specifies if the extender is ignorable, i.e. scheduling should not
fail when the extender returns an error or is not reachable.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-KubeSchedulerProfile><code>KubeSchedulerProfile</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerConfiguration>KubeSchedulerConfiguration</a></li>
</ul>
<p>KubeSchedulerProfile is a scheduling profile.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>schedulerName</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
SchedulerName is the name of the scheduler associated to this profile.
If SchedulerName matches with the pod's "spec.schedulerName", then the pod
is scheduled with this profile.</td>
</tr>
<tr><td><code>plugins</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-Plugins><code>Plugins</code></a>
</td>
<td>
Plugins specify the set of plugins that should be enabled or disabled.
Enabled plugins are the ones that should be enabled in addition to the
default plugins. Disabled plugins are any of the default plugins that
should be disabled.
When no enabled or disabled plugin is specified for an extension point,
default plugins for that extension point will be used if there is any.
If a QueueSort plugin is specified, the same QueueSort Plugin and
PluginConfig must be specified for all profiles.</td>
</tr>
<tr><td><code>pluginConfig</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-PluginConfig><code>[]PluginConfig</code></a>
</td>
<td>
PluginConfig is an optional set of custom plugin arguments for each plugin.
Omitting config args for a plugin is equivalent to using the default config
for that plugin.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-Plugin><code>Plugin</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-PluginSet>PluginSet</a></li>
</ul>
<p>Plugin specifies a plugin name and its weight when applicable. Weight is used only for Score plugins.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Name defines the name of plugin</td>
</tr>
<tr><td><code>weight</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
Weight defines the weight of plugin, only used for Score plugins.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-PluginConfig><code>PluginConfig</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerProfile>KubeSchedulerProfile</a></li>
</ul>
<p>PluginConfig specifies arguments that should be passed to a plugin at the time of initialization.
A plugin that is invoked at multiple extension points is initialized once. Args can have arbitrary structure.
It is up to the plugin to process these Args.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Name defines the name of plugin being configured</td>
</tr>
<tr><td><code>args</code> <b>[Required]</b><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/runtime/#RawExtension><code>k8s.io/apimachinery/pkg/runtime.RawExtension</code></a>
</td>
<td>
Args defines the arguments passed to the plugins at the time of initialization. Args can have arbitrary structure.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-PluginSet><code>PluginSet</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-Plugins>Plugins</a></li>
</ul>
<p>PluginSet specifies enabled and disabled plugins for an extension point.
If an array is empty, missing, or nil, default plugins at that extension point will be used.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>enabled</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-Plugin><code>[]Plugin</code></a>
</td>
<td>
Enabled specifies plugins that should be enabled in addition to default plugins.
These are called after default plugins and in the same order specified here.</td>
</tr>
<tr><td><code>disabled</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-Plugin><code>[]Plugin</code></a>
</td>
<td>
Disabled specifies default plugins that should be disabled.
When all default plugins need to be disabled, an array containing only one "&#8727;" should be provided.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-Plugins><code>Plugins</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-KubeSchedulerProfile>KubeSchedulerProfile</a></li>
</ul>
<p>Plugins include multiple extension points. When specified, the list of plugins for
a particular extension point are the only ones enabled. If an extension point is
omitted from the config, then the default set of plugins is used for that extension point.
Enabled plugins are called in the order specified here, after default plugins. If they need to
be invoked before default plugins, default plugins must be disabled and re-enabled here in desired order.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>queueSort</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-PluginSet><code>PluginSet</code></a>
</td>
<td>
QueueSort is a list of plugins that should be invoked when sorting pods in the scheduling queue.</td>
</tr>
<tr><td><code>preFilter</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-PluginSet><code>PluginSet</code></a>
</td>
<td>
PreFilter is a list of plugins that should be invoked at "PreFilter" extension point of the scheduling framework.</td>
</tr>
<tr><td><code>filter</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-PluginSet><code>PluginSet</code></a>
</td>
<td>
Filter is a list of plugins that should be invoked when filtering out nodes that cannot run the Pod.</td>
</tr>
<tr><td><code>postFilter</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-PluginSet><code>PluginSet</code></a>
</td>
<td>
PostFilter is a list of plugins that are invoked after filtering phase, no matter whether filtering succeeds or not.</td>
</tr>
<tr><td><code>preScore</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-PluginSet><code>PluginSet</code></a>
</td>
<td>
PreScore is a list of plugins that are invoked before scoring.</td>
</tr>
<tr><td><code>score</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-PluginSet><code>PluginSet</code></a>
</td>
<td>
Score is a list of plugins that should be invoked when ranking nodes that have passed the filtering phase.</td>
</tr>
<tr><td><code>reserve</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-PluginSet><code>PluginSet</code></a>
</td>
<td>
Reserve is a list of plugins invoked when reserving/unreserving resources
after a node is assigned to run the pod.</td>
</tr>
<tr><td><code>permit</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-PluginSet><code>PluginSet</code></a>
</td>
<td>
Permit is a list of plugins that control binding of a Pod. These plugins can prevent or delay binding of a Pod.</td>
</tr>
<tr><td><code>preBind</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-PluginSet><code>PluginSet</code></a>
</td>
<td>
PreBind is a list of plugins that should be invoked before a pod is bound.</td>
</tr>
<tr><td><code>bind</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-PluginSet><code>PluginSet</code></a>
</td>
<td>
Bind is a list of plugins that should be invoked at "Bind" extension point of the scheduling framework.
The scheduler call these plugins in order. Scheduler skips the rest of these plugins as soon as one returns success.</td>
</tr>
<tr><td><code>postBind</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1beta1-PluginSet><code>PluginSet</code></a>
</td>
<td>
PostBind is a list of plugins that should be invoked after a pod is successfully bound.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-PodTopologySpreadConstraintsDefaulting><code>PodTopologySpreadConstraintsDefaulting</code> </h2>
<p>(Alias of <code>string</code>)</p>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-PodTopologySpreadArgs>PodTopologySpreadArgs</a></li>
</ul>
<p>PodTopologySpreadConstraintsDefaulting defines how to set default constraints
for the PodTopologySpread plugin.</p>
<h2 id=kubescheduler-config-k8s-io-v1beta1-ResourceSpec><code>ResourceSpec</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li>
<p><a href=#kubescheduler-config-k8s-io-v1beta1-NodeResourcesLeastAllocatedArgs>NodeResourcesLeastAllocatedArgs</a></p>
</li>
<li>
<p><a href=#kubescheduler-config-k8s-io-v1beta1-NodeResourcesMostAllocatedArgs>NodeResourcesMostAllocatedArgs</a></p>
</li>
<li>
<p><a href=#kubescheduler-config-k8s-io-v1beta1-RequestedToCapacityRatioArgs>RequestedToCapacityRatioArgs</a></p>
</li>
</ul>
<p>ResourceSpec represents single resource and weight for bin packing of priority RequestedToCapacityRatioArguments.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Name of the resource to be managed by RequestedToCapacityRatio function.</td>
</tr>
<tr><td><code>weight</code> <b>[Required]</b><br>
<code>int64</code>
</td>
<td>
Weight of the resource.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1beta1-UtilizationShapePoint><code>UtilizationShapePoint</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1beta1-RequestedToCapacityRatioArgs>RequestedToCapacityRatioArgs</a></li>
</ul>
<p>UtilizationShapePoint represents single point of priority function shape.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>utilization</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
Utilization (x axis). Valid values are 0 to 100. Fully utilized node maps to 100.</td>
</tr>
<tr><td><code>score</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
Score assigned to given utilization (y axis). Valid values are 0 to 10.</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-699f28965d0a72527ebd04826dda8901>11.5 - kube-scheduler Policy Configuration (v1)</h1>
<h2 id=resource-types>Resource Types</h2>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-Policy>Policy</a></li>
</ul>
<h2 id=kubescheduler-config-k8s-io-v1-Policy><code>Policy</code> </h2>
<p>Policy describes a struct for a policy resource used in api.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubescheduler.config.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>Policy</code></td></tr>
<tr><td><code>predicates</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-PredicatePolicy><code>[]PredicatePolicy</code></a>
</td>
<td>
Holds the information to configure the fit predicate functions</td>
</tr>
<tr><td><code>priorities</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-PriorityPolicy><code>[]PriorityPolicy</code></a>
</td>
<td>
Holds the information to configure the priority functions</td>
</tr>
<tr><td><code>extenders</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-LegacyExtender><code>[]LegacyExtender</code></a>
</td>
<td>
Holds the information to communicate with the extender(s)</td>
</tr>
<tr><td><code>hardPodAffinitySymmetricWeight</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
RequiredDuringScheduling affinity is not symmetric, but there is an implicit PreferredDuringScheduling affinity rule
corresponding to every RequiredDuringScheduling affinity rule.
HardPodAffinitySymmetricWeight represents the weight of implicit PreferredDuringScheduling affinity rule, in the range 1-100.</td>
</tr>
<tr><td><code>alwaysCheckAllPredicates</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
When AlwaysCheckAllPredicates is set to true, scheduler checks all
the configured predicates even after one or more of them fails.
When the flag is set to false, scheduler skips checking the rest
of the predicates after it finds one predicate that failed.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-ExtenderManagedResource><code>ExtenderManagedResource</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li>
<p><a href=#kubescheduler-config-k8s-io-v1beta1-Extender>Extender</a></p>
</li>
<li>
<p><a href=#kubescheduler-config-k8s-io-v1-LegacyExtender>LegacyExtender</a></p>
</li>
</ul>
<p>ExtenderManagedResource describes the arguments of extended resources
managed by an extender.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Name is the extended resource name.</td>
</tr>
<tr><td><code>ignoredByScheduler</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
IgnoredByScheduler indicates whether kube-scheduler should ignore this
resource when applying predicates.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-ExtenderTLSConfig><code>ExtenderTLSConfig</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li>
<p><a href=#kubescheduler-config-k8s-io-v1beta1-Extender>Extender</a></p>
</li>
<li>
<p><a href=#kubescheduler-config-k8s-io-v1-LegacyExtender>LegacyExtender</a></p>
</li>
</ul>
<p>ExtenderTLSConfig contains settings to enable TLS with extender</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>insecure</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
Server should be accessed without verifying the TLS certificate. For testing only.</td>
</tr>
<tr><td><code>serverName</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
ServerName is passed to the server for SNI and is used in the client to check server
certificates against. If ServerName is empty, the hostname used to contact the
server is used.</td>
</tr>
<tr><td><code>certFile</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Server requires TLS client certificate authentication</td>
</tr>
<tr><td><code>keyFile</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Server requires TLS client certificate authentication</td>
</tr>
<tr><td><code>caFile</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Trusted root certificates for server</td>
</tr>
<tr><td><code>certData</code> <b>[Required]</b><br>
<code>[]byte</code>
</td>
<td>
CertData holds PEM-encoded bytes (typically read from a client certificate file).
CertData takes precedence over CertFile</td>
</tr>
<tr><td><code>keyData</code> <b>[Required]</b><br>
<code>[]byte</code>
</td>
<td>
KeyData holds PEM-encoded bytes (typically read from a client certificate key file).
KeyData takes precedence over KeyFile</td>
</tr>
<tr><td><code>caData</code> <b>[Required]</b><br>
<code>[]byte</code>
</td>
<td>
CAData holds PEM-encoded bytes (typically read from a root certificates bundle).
CAData takes precedence over CAFile</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-LabelPreference><code>LabelPreference</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-PriorityArgument>PriorityArgument</a></li>
</ul>
<p>LabelPreference holds the parameters that are used to configure the corresponding priority function</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>label</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Used to identify node "groups"</td>
</tr>
<tr><td><code>presence</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
This is a boolean flag
If true, higher priority is given to nodes that have the label
If false, higher priority is given to nodes that do not have the label</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-LabelsPresence><code>LabelsPresence</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-PredicateArgument>PredicateArgument</a></li>
</ul>
<p>LabelsPresence holds the parameters that are used to configure the corresponding predicate in scheduler policy configuration.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>labels</code> <b>[Required]</b><br>
<code>[]string</code>
</td>
<td>
The list of labels that identify node "groups"
All of the labels should be either present (or absent) for the node to be considered a fit for hosting the pod</td>
</tr>
<tr><td><code>presence</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
The boolean flag that indicates whether the labels should be present or absent from the node</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-LegacyExtender><code>LegacyExtender</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-Policy>Policy</a></li>
</ul>
<p>LegacyExtender holds the parameters used to communicate with the extender. If a verb is unspecified/empty,
it is assumed that the extender chose not to provide that extension.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>urlPrefix</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
URLPrefix at which the extender is available</td>
</tr>
<tr><td><code>filterVerb</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Verb for the filter call, empty if not supported. This verb is appended to the URLPrefix when issuing the filter call to extender.</td>
</tr>
<tr><td><code>preemptVerb</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Verb for the preempt call, empty if not supported. This verb is appended to the URLPrefix when issuing the preempt call to extender.</td>
</tr>
<tr><td><code>prioritizeVerb</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Verb for the prioritize call, empty if not supported. This verb is appended to the URLPrefix when issuing the prioritize call to extender.</td>
</tr>
<tr><td><code>weight</code> <b>[Required]</b><br>
<code>int64</code>
</td>
<td>
The numeric multiplier for the node scores that the prioritize call generates.
The weight should be a positive integer</td>
</tr>
<tr><td><code>bindVerb</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Verb for the bind call, empty if not supported. This verb is appended to the URLPrefix when issuing the bind call to extender.
If this method is implemented by the extender, it is the extender's responsibility to bind the pod to apiserver. Only one extender
can implement this function.</td>
</tr>
<tr><td><code>enableHttps</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
EnableHTTPS specifies whether https should be used to communicate with the extender</td>
</tr>
<tr><td><code>tlsConfig</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-ExtenderTLSConfig><code>ExtenderTLSConfig</code></a>
</td>
<td>
TLSConfig specifies the transport layer security config</td>
</tr>
<tr><td><code>httpTimeout</code> <b>[Required]</b><br>
<a href=https://godoc.org/time#Duration><code>time.Duration</code></a>
</td>
<td>
HTTPTimeout specifies the timeout duration for a call to the extender. Filter timeout fails the scheduling of the pod. Prioritize
timeout is ignored, k8s/other extenders priorities are used to select the node.</td>
</tr>
<tr><td><code>nodeCacheCapable</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
NodeCacheCapable specifies that the extender is capable of caching node information,
so the scheduler should only send minimal information about the eligible nodes
assuming that the extender already cached full details of all nodes in the cluster</td>
</tr>
<tr><td><code>managedResources</code><br>
<a href=#kubescheduler-config-k8s-io-v1-ExtenderManagedResource><code>[]ExtenderManagedResource</code></a>
</td>
<td>
ManagedResources is a list of extended resources that are managed by
this extender.
- A pod will be sent to the extender on the Filter, Prioritize and Bind
(if the extender is the binder) phases iff the pod requests at least
one of the extended resources in this list. If empty or unspecified,
all pods will be sent to this extender.
- If IgnoredByScheduler is set to true for a resource, kube-scheduler
will skip checking the resource in predicates.</td>
</tr>
<tr><td><code>ignorable</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
Ignorable specifies if the extender is ignorable, i.e. scheduling should not
fail when the extender returns an error or is not reachable.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-PredicateArgument><code>PredicateArgument</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-PredicatePolicy>PredicatePolicy</a></li>
</ul>
<p>PredicateArgument represents the arguments to configure predicate functions in scheduler policy configuration.
Only one of its members may be specified</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>serviceAffinity</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-ServiceAffinity><code>ServiceAffinity</code></a>
</td>
<td>
The predicate that provides affinity for pods belonging to a service
It uses a label to identify nodes that belong to the same "group"</td>
</tr>
<tr><td><code>labelsPresence</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-LabelsPresence><code>LabelsPresence</code></a>
</td>
<td>
The predicate that checks whether a particular node has a certain label
defined or not, regardless of value</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-PredicatePolicy><code>PredicatePolicy</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-Policy>Policy</a></li>
</ul>
<p>PredicatePolicy describes a struct of a predicate policy.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Identifier of the predicate policy
For a custom predicate, the name can be user-defined
For the Kubernetes provided predicates, the name is the identifier of the pre-defined predicate</td>
</tr>
<tr><td><code>argument</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-PredicateArgument><code>PredicateArgument</code></a>
</td>
<td>
Holds the parameters to configure the given predicate</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-PriorityArgument><code>PriorityArgument</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-PriorityPolicy>PriorityPolicy</a></li>
</ul>
<p>PriorityArgument represents the arguments to configure priority functions in scheduler policy configuration.
Only one of its members may be specified</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>serviceAntiAffinity</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-ServiceAntiAffinity><code>ServiceAntiAffinity</code></a>
</td>
<td>
The priority function that ensures a good spread (anti-affinity) for pods belonging to a service
It uses a label to identify nodes that belong to the same "group"</td>
</tr>
<tr><td><code>labelPreference</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-LabelPreference><code>LabelPreference</code></a>
</td>
<td>
The priority function that checks whether a particular node has a certain label
defined or not, regardless of value</td>
</tr>
<tr><td><code>requestedToCapacityRatioArguments</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments><code>RequestedToCapacityRatioArguments</code></a>
</td>
<td>
The RequestedToCapacityRatio priority function is parametrized with function shape.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-PriorityPolicy><code>PriorityPolicy</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-Policy>Policy</a></li>
</ul>
<p>PriorityPolicy describes a struct of a priority policy.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Identifier of the priority policy
For a custom priority, the name can be user-defined
For the Kubernetes provided priority functions, the name is the identifier of the pre-defined priority function</td>
</tr>
<tr><td><code>weight</code> <b>[Required]</b><br>
<code>int64</code>
</td>
<td>
The numeric multiplier for the node scores that the priority function generates
The weight should be non-zero and can be a positive or a negative integer</td>
</tr>
<tr><td><code>argument</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-PriorityArgument><code>PriorityArgument</code></a>
</td>
<td>
Holds the parameters to configure the given priority function</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments><code>RequestedToCapacityRatioArguments</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-PriorityArgument>PriorityArgument</a></li>
</ul>
<p>RequestedToCapacityRatioArguments holds arguments specific to RequestedToCapacityRatio priority function.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>shape</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-UtilizationShapePoint><code>[]UtilizationShapePoint</code></a>
</td>
<td>
Array of point defining priority function shape.</td>
</tr>
<tr><td><code>resources</code> <b>[Required]</b><br>
<a href=#kubescheduler-config-k8s-io-v1-ResourceSpec><code>[]ResourceSpec</code></a>
</td>
<td>
<span class=text-muted>No description provided.</span>
</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-ResourceSpec><code>ResourceSpec</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments>RequestedToCapacityRatioArguments</a></li>
</ul>
<p>ResourceSpec represents single resource and weight for bin packing of priority RequestedToCapacityRatioArguments.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>name</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Name of the resource to be managed by RequestedToCapacityRatio function.</td>
</tr>
<tr><td><code>weight</code> <b>[Required]</b><br>
<code>int64</code>
</td>
<td>
Weight of the resource.</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-ServiceAffinity><code>ServiceAffinity</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-PredicateArgument>PredicateArgument</a></li>
</ul>
<p>ServiceAffinity holds the parameters that are used to configure the corresponding predicate in scheduler policy configuration.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>labels</code> <b>[Required]</b><br>
<code>[]string</code>
</td>
<td>
The list of labels that identify node "groups"
All of the labels should match for the node to be considered a fit for hosting the pod</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-ServiceAntiAffinity><code>ServiceAntiAffinity</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-PriorityArgument>PriorityArgument</a></li>
</ul>
<p>ServiceAntiAffinity holds the parameters that are used to configure the corresponding priority function</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>label</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Used to identify node "groups"</td>
</tr>
</tbody>
</table>
<h2 id=kubescheduler-config-k8s-io-v1-UtilizationShapePoint><code>UtilizationShapePoint</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubescheduler-config-k8s-io-v1-RequestedToCapacityRatioArguments>RequestedToCapacityRatioArguments</a></li>
</ul>
<p>UtilizationShapePoint represents single point of priority function shape.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>utilization</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
Utilization (x axis). Valid values are 0 to 100. Fully utilized node maps to 100.</td>
</tr>
<tr><td><code>score</code> <b>[Required]</b><br>
<code>int32</code>
</td>
<td>
Score assigned to given utilization (y axis). Valid values are 0 to 10.</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-aaa2b8b78fe84a05914c155652d10956>11.6 - Kubelet Configuration (v1beta1)</h1>
<h2 id=resource-types>Resource Types</h2>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a></li>
<li><a href=#kubelet-config-k8s-io-v1beta1-SerializedNodeConfigSource>SerializedNodeConfigSource</a></li>
</ul>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletConfiguration><code>KubeletConfiguration</code> </h2>
<p>KubeletConfiguration contains the configuration for the Kubelet</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubelet.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>KubeletConfiguration</code></td></tr>
<tr><td><code>enableServer</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
enableServer enables Kubelet's secured server.
Note: Kubelet's insecure port is controlled by the readOnlyPort option.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: true</td>
</tr>
<tr><td><code>staticPodPath</code><br>
<code>string</code>
</td>
<td>
staticPodPath is the path to the directory containing local (static) pods to
run, or the path to a single static pod file.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
the set of static pods specified at the new path may be different than the
ones the Kubelet initially started with, and this may disrupt your node.
Default: ""</td>
</tr>
<tr><td><code>syncFrequency</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
syncFrequency is the max period between synchronizing running
containers and config.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
shortening this duration may have a negative performance impact, especially
as the number of Pods on the node increases. Alternatively, increasing this
duration will result in longer refresh times for ConfigMaps and Secrets.
Default: "1m"</td>
</tr>
<tr><td><code>fileCheckFrequency</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
fileCheckFrequency is the duration between checking config files for
new data
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
shortening the duration will cause the Kubelet to reload local Static Pod
configurations more frequently, which may have a negative performance impact.
Default: "20s"</td>
</tr>
<tr><td><code>httpCheckFrequency</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
httpCheckFrequency is the duration between checking http for new data
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
shortening the duration will cause the Kubelet to poll staticPodURL more
frequently, which may have a negative performance impact.
Default: "20s"</td>
</tr>
<tr><td><code>staticPodURL</code><br>
<code>string</code>
</td>
<td>
staticPodURL is the URL for accessing static pods to run
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
the set of static pods specified at the new URL may be different than the
ones the Kubelet initially started with, and this may disrupt your node.
Default: ""</td>
</tr>
<tr><td><code>staticPodURLHeader</code><br>
<code>map[string][]string</code>
</td>
<td>
staticPodURLHeader is a map of slices with HTTP headers to use when accessing the podURL
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt the ability to read the latest set of static pods from StaticPodURL.
Default: nil</td>
</tr>
<tr><td><code>address</code><br>
<code>string</code>
</td>
<td>
address is the IP address for the Kubelet to serve on (set to 0.0.0.0
for all interfaces).
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: "0.0.0.0"</td>
</tr>
<tr><td><code>port</code><br>
<code>int32</code>
</td>
<td>
port is the port for the Kubelet to serve on.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: 10250</td>
</tr>
<tr><td><code>readOnlyPort</code><br>
<code>int32</code>
</td>
<td>
readOnlyPort is the read-only port for the Kubelet to serve on with
no authentication/authorization.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: 0 (disabled)</td>
</tr>
<tr><td><code>tlsCertFile</code><br>
<code>string</code>
</td>
<td>
tlsCertFile is the file containing x509 Certificate for HTTPS. (CA cert,
if any, concatenated after server cert). If tlsCertFile and
tlsPrivateKeyFile are not provided, a self-signed certificate
and key are generated for the public address and saved to the directory
passed to the Kubelet's --cert-dir flag.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: ""</td>
</tr>
<tr><td><code>tlsPrivateKeyFile</code><br>
<code>string</code>
</td>
<td>
tlsPrivateKeyFile is the file containing x509 private key matching tlsCertFile
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: ""</td>
</tr>
<tr><td><code>tlsCipherSuites</code><br>
<code>[]string</code>
</td>
<td>
TLSCipherSuites is the list of allowed cipher suites for the server.
Values are from tls package constants (https://golang.org/pkg/crypto/tls/#pkg-constants).
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: nil</td>
</tr>
<tr><td><code>tlsMinVersion</code><br>
<code>string</code>
</td>
<td>
TLSMinVersion is the minimum TLS version supported.
Values are from tls package constants (https://golang.org/pkg/crypto/tls/#pkg-constants).
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: ""</td>
</tr>
<tr><td><code>rotateCertificates</code><br>
<code>bool</code>
</td>
<td>
rotateCertificates enables client certificate rotation. The Kubelet will request a
new certificate from the certificates.k8s.io API. This requires an approver to approve the
certificate signing requests.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
disabling it may disrupt the Kubelet's ability to authenticate with the API server
after the current certificate expires.
Default: false</td>
</tr>
<tr><td><code>serverTLSBootstrap</code><br>
<code>bool</code>
</td>
<td>
serverTLSBootstrap enables server certificate bootstrap. Instead of self
signing a serving certificate, the Kubelet will request a certificate from
the certificates.k8s.io API. This requires an approver to approve the
certificate signing requests. The RotateKubeletServerCertificate feature
must be enabled.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
disabling it will stop the renewal of Kubelet server certificates, which can
disrupt components that interact with the Kubelet server in the long term,
due to certificate expiration.
Default: false</td>
</tr>
<tr><td><code>authentication</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthentication><code>KubeletAuthentication</code></a>
</td>
<td>
authentication specifies how requests to the Kubelet's server are authenticated
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Defaults:
anonymous:
enabled: false
webhook:
enabled: true
cacheTTL: "2m"</td>
</tr>
<tr><td><code>authorization</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthorization><code>KubeletAuthorization</code></a>
</td>
<td>
authorization specifies how requests to the Kubelet's server are authorized
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Defaults:
mode: Webhook
webhook:
cacheAuthorizedTTL: "5m"
cacheUnauthorizedTTL: "30s"</td>
</tr>
<tr><td><code>registryPullQPS</code><br>
<code>int32</code>
</td>
<td>
registryPullQPS is the limit of registry pulls per second.
Set to 0 for no limit.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact scalability by changing the amount of traffic produced
by image pulls.
Default: 5</td>
</tr>
<tr><td><code>registryBurst</code><br>
<code>int32</code>
</td>
<td>
registryBurst is the maximum size of bursty pulls, temporarily allows
pulls to burst to this number, while still not exceeding registryPullQPS.
Only used if registryPullQPS > 0.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact scalability by changing the amount of traffic produced
by image pulls.
Default: 10</td>
</tr>
<tr><td><code>eventRecordQPS</code><br>
<code>int32</code>
</td>
<td>
eventRecordQPS is the maximum event creations per second. If 0, there
is no limit enforced.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact scalability by changing the amount of traffic produced by
event creations.
Default: 5</td>
</tr>
<tr><td><code>eventBurst</code><br>
<code>int32</code>
</td>
<td>
eventBurst is the maximum size of a burst of event creations, temporarily
allows event creations to burst to this number, while still not exceeding
eventRecordQPS. Only used if eventRecordQPS > 0.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact scalability by changing the amount of traffic produced by
event creations.
Default: 10</td>
</tr>
<tr><td><code>enableDebuggingHandlers</code><br>
<code>bool</code>
</td>
<td>
enableDebuggingHandlers enables server endpoints for log access
and local running of containers and commands, including the exec,
attach, logs, and portforward features.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
disabling it may disrupt components that interact with the Kubelet server.
Default: true</td>
</tr>
<tr><td><code>enableContentionProfiling</code><br>
<code>bool</code>
</td>
<td>
enableContentionProfiling enables lock contention profiling, if enableDebuggingHandlers is true.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
enabling it may carry a performance impact.
Default: false</td>
</tr>
<tr><td><code>healthzPort</code><br>
<code>int32</code>
</td>
<td>
healthzPort is the port of the localhost healthz endpoint (set to 0 to disable)
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that monitor Kubelet health.
Default: 10248</td>
</tr>
<tr><td><code>healthzBindAddress</code><br>
<code>string</code>
</td>
<td>
healthzBindAddress is the IP address for the healthz server to serve on
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that monitor Kubelet health.
Default: "127.0.0.1"</td>
</tr>
<tr><td><code>oomScoreAdj</code><br>
<code>int32</code>
</td>
<td>
oomScoreAdj is The oom-score-adj value for kubelet process. Values
must be within the range [-1000, 1000].
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact the stability of nodes under memory pressure.
Default: -999</td>
</tr>
<tr><td><code>clusterDomain</code><br>
<code>string</code>
</td>
<td>
clusterDomain is the DNS domain for this cluster. If set, kubelet will
configure all containers to search this domain in addition to the
host's search domains.
Dynamic Kubelet Config (beta): Dynamically updating this field is not recommended,
as it should be kept in sync with the rest of the cluster.
Default: ""</td>
</tr>
<tr><td><code>clusterDNS</code><br>
<code>[]string</code>
</td>
<td>
clusterDNS is a list of IP addresses for the cluster DNS server. If set,
kubelet will configure all containers to use this for DNS resolution
instead of the host's DNS servers.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
changes will only take effect on Pods created after the update. Draining
the node is recommended before changing this field.
Default: nil</td>
</tr>
<tr><td><code>streamingConnectionIdleTimeout</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
streamingConnectionIdleTimeout is the maximum time a streaming connection
can be idle before the connection is automatically closed.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact components that rely on infrequent updates over streaming
connections to the Kubelet server.
Default: "4h"</td>
</tr>
<tr><td><code>nodeStatusUpdateFrequency</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
nodeStatusUpdateFrequency is the frequency that kubelet computes node
status. If node lease feature is not enabled, it is also the frequency that
kubelet posts node status to master.
Note: When node lease feature is not enabled, be cautious when changing the
constant, it must work with nodeMonitorGracePeriod in nodecontroller.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact node scalability, and also that the node controller's
nodeMonitorGracePeriod must be set to N&#8727;NodeStatusUpdateFrequency,
where N is the number of retries before the node controller marks
the node unhealthy.
Default: "10s"</td>
</tr>
<tr><td><code>nodeStatusReportFrequency</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
nodeStatusReportFrequency is the frequency that kubelet posts node
status to master if node status does not change. Kubelet will ignore this
frequency and post node status immediately if any change is detected. It is
only used when node lease feature is enabled. nodeStatusReportFrequency's
default value is 1m. But if nodeStatusUpdateFrequency is set explicitly,
nodeStatusReportFrequency's default value will be set to
nodeStatusUpdateFrequency for backward compatibility.
Default: "1m"</td>
</tr>
<tr><td><code>nodeLeaseDurationSeconds</code><br>
<code>int32</code>
</td>
<td>
nodeLeaseDurationSeconds is the duration the Kubelet will set on its corresponding Lease,
when the NodeLease feature is enabled. This feature provides an indicator of node
health by having the Kubelet create and periodically renew a lease, named after the node,
in the kube-node-lease namespace. If the lease expires, the node can be considered unhealthy.
The lease is currently renewed every 10s, per KEP-0009. In the future, the lease renewal interval
may be set based on the lease duration.
Requires the NodeLease feature gate to be enabled.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
decreasing the duration may reduce tolerance for issues that temporarily prevent
the Kubelet from renewing the lease (e.g. a short-lived network issue).
Default: 40</td>
</tr>
<tr><td><code>imageMinimumGCAge</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
imageMinimumGCAge is the minimum age for an unused image before it is
garbage collected.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may trigger or delay garbage collection, and may change the image overhead
on the node.
Default: "2m"</td>
</tr>
<tr><td><code>imageGCHighThresholdPercent</code><br>
<code>int32</code>
</td>
<td>
imageGCHighThresholdPercent is the percent of disk usage after which
image garbage collection is always run. The percent is calculated as
this field value out of 100.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may trigger or delay garbage collection, and may change the image overhead
on the node.
Default: 85</td>
</tr>
<tr><td><code>imageGCLowThresholdPercent</code><br>
<code>int32</code>
</td>
<td>
imageGCLowThresholdPercent is the percent of disk usage before which
image garbage collection is never run. Lowest disk usage to garbage
collect to. The percent is calculated as this field value out of 100.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may trigger or delay garbage collection, and may change the image overhead
on the node.
Default: 80</td>
</tr>
<tr><td><code>volumeStatsAggPeriod</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
How frequently to calculate and cache volume disk usage for all pods
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
shortening the period may carry a performance impact.
Default: "1m"</td>
</tr>
<tr><td><code>kubeletCgroups</code><br>
<code>string</code>
</td>
<td>
kubeletCgroups is the absolute name of cgroups to isolate the kubelet in
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: ""</td>
</tr>
<tr><td><code>systemCgroups</code><br>
<code>string</code>
</td>
<td>
systemCgroups is absolute name of cgroups in which to place
all non-kernel processes that are not already in a container. Empty
for no container. Rolling back the flag requires a reboot.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: ""</td>
</tr>
<tr><td><code>cgroupRoot</code><br>
<code>string</code>
</td>
<td>
cgroupRoot is the root cgroup to use for pods. This is handled by the
container runtime on a best effort basis.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: ""</td>
</tr>
<tr><td><code>cgroupsPerQOS</code><br>
<code>bool</code>
</td>
<td>
Enable QoS based Cgroup hierarchy: top level cgroups for QoS Classes
And all Burstable and BestEffort pods are brought up under their
specific top level QoS cgroup.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: true</td>
</tr>
<tr><td><code>cgroupDriver</code><br>
<code>string</code>
</td>
<td>
driver that the kubelet uses to manipulate cgroups on the host (cgroupfs or systemd)
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: "cgroupfs"</td>
</tr>
<tr><td><code>cpuManagerPolicy</code><br>
<code>string</code>
</td>
<td>
CPUManagerPolicy is the name of the policy to use.
Requires the CPUManager feature gate to be enabled.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: "none"</td>
</tr>
<tr><td><code>cpuManagerReconcilePeriod</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
CPU Manager reconciliation period.
Requires the CPUManager feature gate to be enabled.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
shortening the period may carry a performance impact.
Default: "10s"</td>
</tr>
<tr><td><code>topologyManagerPolicy</code><br>
<code>string</code>
</td>
<td>
TopologyManagerPolicy is the name of the policy to use.
Policies other than "none" require the TopologyManager feature gate to be enabled.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: "none"</td>
</tr>
<tr><td><code>topologyManagerScope</code><br>
<code>string</code>
</td>
<td>
TopologyManagerScope represents the scope of topology hint generation
that topology manager requests and hint providers generate.
"pod" scope requires the TopologyManager feature gate to be enabled.
Default: "container"</td>
</tr>
<tr><td><code>qosReserved</code><br>
<code>map[string]string</code>
</td>
<td>
qosReserved is a set of resource name to percentage pairs that specify
the minimum percentage of a resource reserved for exclusive use by the
guaranteed QoS tier.
Currently supported resources: "memory"
Requires the QOSReserved feature gate to be enabled.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: nil</td>
</tr>
<tr><td><code>runtimeRequestTimeout</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
runtimeRequestTimeout is the timeout for all runtime requests except long running
requests - pull, logs, exec and attach.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may disrupt components that interact with the Kubelet server.
Default: "2m"</td>
</tr>
<tr><td><code>hairpinMode</code><br>
<code>string</code>
</td>
<td>
hairpinMode specifies how the Kubelet should configure the container
bridge for hairpin packets.
Setting this flag allows endpoints in a Service to loadbalance back to
themselves if they should try to access their own Service. Values:
"promiscuous-bridge": make the container bridge promiscuous.
"hairpin-veth": set the hairpin flag on container veth interfaces.
"none": do nothing.
Generally, one must set --hairpin-mode=hairpin-veth to achieve hairpin NAT,
because promiscuous-bridge assumes the existence of a container bridge named cbr0.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may require a node reboot, depending on the network plugin.
Default: "promiscuous-bridge"</td>
</tr>
<tr><td><code>maxPods</code><br>
<code>int32</code>
</td>
<td>
maxPods is the number of pods that can run on this Kubelet.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
changes may cause Pods to fail admission on Kubelet restart, and may change
the value reported in Node.Status.Capacity[v1.ResourcePods], thus affecting
future scheduling decisions. Increasing this value may also decrease performance,
as more Pods can be packed into a single node.
Default: 110</td>
</tr>
<tr><td><code>podCIDR</code><br>
<code>string</code>
</td>
<td>
The CIDR to use for pod IP addresses, only used in standalone mode.
In cluster mode, this is obtained from the master.
Dynamic Kubelet Config (beta): This field should always be set to the empty default.
It should only set for standalone Kubelets, which cannot use Dynamic Kubelet Config.
Default: ""</td>
</tr>
<tr><td><code>podPidsLimit</code><br>
<code>int64</code>
</td>
<td>
PodPidsLimit is the maximum number of pids in any pod.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
lowering it may prevent container processes from forking after the change.
Default: -1</td>
</tr>
<tr><td><code>resolvConf</code><br>
<code>string</code>
</td>
<td>
ResolverConfig is the resolver configuration file used as the basis
for the container DNS resolution configuration.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
changes will only take effect on Pods created after the update. Draining
the node is recommended before changing this field.
Default: "/etc/resolv.conf"</td>
</tr>
<tr><td><code>runOnce</code><br>
<code>bool</code>
</td>
<td>
RunOnce causes the Kubelet to check the API server once for pods,
run those in addition to the pods specified by static pod files, and exit.
Default: false</td>
</tr>
<tr><td><code>cpuCFSQuota</code><br>
<code>bool</code>
</td>
<td>
cpuCFSQuota enables CPU CFS quota enforcement for containers that
specify CPU limits.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
disabling it may reduce node stability.
Default: true</td>
</tr>
<tr><td><code>cpuCFSQuotaPeriod</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
CPUCFSQuotaPeriod is the CPU CFS quota period value, cpu.cfs_period_us.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
limits set for containers will result in different cpu.cfs_quota settings. This
will trigger container restarts on the node being reconfigured.
Default: "100ms"</td>
</tr>
<tr><td><code>nodeStatusMaxImages</code><br>
<code>int32</code>
</td>
<td>
nodeStatusMaxImages caps the number of images reported in Node.Status.Images.
Note: If -1 is specified, no cap will be applied. If 0 is specified, no image is returned.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
different values can be reported on node status.
Default: 50</td>
</tr>
<tr><td><code>maxOpenFiles</code><br>
<code>int64</code>
</td>
<td>
maxOpenFiles is Number of files that can be opened by Kubelet process.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact the ability of the Kubelet to interact with the node's filesystem.
Default: 1000000</td>
</tr>
<tr><td><code>contentType</code><br>
<code>string</code>
</td>
<td>
contentType is contentType of requests sent to apiserver.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact the ability for the Kubelet to communicate with the API server.
If the Kubelet loses contact with the API server due to a change to this field,
the change cannot be reverted via dynamic Kubelet config.
Default: "application/vnd.kubernetes.protobuf"</td>
</tr>
<tr><td><code>kubeAPIQPS</code><br>
<code>int32</code>
</td>
<td>
kubeAPIQPS is the QPS to use while talking with kubernetes apiserver
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact scalability by changing the amount of traffic the Kubelet
sends to the API server.
Default: 5</td>
</tr>
<tr><td><code>kubeAPIBurst</code><br>
<code>int32</code>
</td>
<td>
kubeAPIBurst is the burst to allow while talking with kubernetes apiserver
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact scalability by changing the amount of traffic the Kubelet
sends to the API server.
Default: 10</td>
</tr>
<tr><td><code>serializeImagePulls</code><br>
<code>bool</code>
</td>
<td>
serializeImagePulls when enabled, tells the Kubelet to pull images one
at a time. We recommend &#8727;not&#8727; changing the default value on nodes that
run docker daemon with version < 1.9 or an Aufs storage backend.
Issue #10959 has more details.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact the performance of image pulls.
Default: true</td>
</tr>
<tr><td><code>evictionHard</code><br>
<code>map[string]string</code>
</td>
<td>
Map of signal names to quantities that defines hard eviction thresholds. For example: {"memory.available": "300Mi"}.
To explicitly disable, pass a 0% or 100% threshold on an arbitrary resource.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may trigger or delay Pod evictions.
Default:
memory.available: "100Mi"
nodefs.available: "10%"
nodefs.inodesFree: "5%"
imagefs.available: "15%"</td>
</tr>
<tr><td><code>evictionSoft</code><br>
<code>map[string]string</code>
</td>
<td>
Map of signal names to quantities that defines soft eviction thresholds.
For example: {"memory.available": "300Mi"}.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may trigger or delay Pod evictions, and may change the allocatable reported
by the node.
Default: nil</td>
</tr>
<tr><td><code>evictionSoftGracePeriod</code><br>
<code>map[string]string</code>
</td>
<td>
Map of signal names to quantities that defines grace periods for each soft eviction signal.
For example: {"memory.available": "30s"}.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may trigger or delay Pod evictions.
Default: nil</td>
</tr>
<tr><td><code>evictionPressureTransitionPeriod</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
Duration for which the kubelet has to wait before transitioning out of an eviction pressure condition.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
lowering it may decrease the stability of the node when the node is overcommitted.
Default: "5m"</td>
</tr>
<tr><td><code>evictionMaxPodGracePeriod</code><br>
<code>int32</code>
</td>
<td>
Maximum allowed grace period (in seconds) to use when terminating pods in
response to a soft eviction threshold being met. This value effectively caps
the Pod's TerminationGracePeriodSeconds value during soft evictions.
Note: Due to issue #64530, the behavior has a bug where this value currently just
overrides the grace period during soft eviction, which can increase the grace
period from what is set on the Pod. This bug will be fixed in a future release.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
lowering it decreases the amount of time Pods will have to gracefully clean
up before being killed during a soft eviction.
Default: 0</td>
</tr>
<tr><td><code>evictionMinimumReclaim</code><br>
<code>map[string]string</code>
</td>
<td>
Map of signal names to quantities that defines minimum reclaims, which describe the minimum
amount of a given resource the kubelet will reclaim when performing a pod eviction while
that resource is under pressure. For example: {"imagefs.available": "2Gi"}
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may change how well eviction can manage resource pressure.
Default: nil</td>
</tr>
<tr><td><code>podsPerCore</code><br>
<code>int32</code>
</td>
<td>
podsPerCore is the maximum number of pods per core. Cannot exceed MaxPods.
If 0, this field is ignored.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
changes may cause Pods to fail admission on Kubelet restart, and may change
the value reported in Node.Status.Capacity[v1.ResourcePods], thus affecting
future scheduling decisions. Increasing this value may also decrease performance,
as more Pods can be packed into a single node.
Default: 0</td>
</tr>
<tr><td><code>enableControllerAttachDetach</code><br>
<code>bool</code>
</td>
<td>
enableControllerAttachDetach enables the Attach/Detach controller to
manage attachment/detachment of volumes scheduled to this node, and
disables kubelet from executing any attach/detach operations
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
changing which component is responsible for volume management on a live node
may result in volumes refusing to detach if the node is not drained prior to
the update, and if Pods are scheduled to the node before the
volumes.kubernetes.io/controller-managed-attach-detach annotation is updated by the
Kubelet. In general, it is safest to leave this value set the same as local config.
Default: true</td>
</tr>
<tr><td><code>protectKernelDefaults</code><br>
<code>bool</code>
</td>
<td>
protectKernelDefaults, if true, causes the Kubelet to error if kernel
flags are not as it expects. Otherwise the Kubelet will attempt to modify
kernel flags to match its expectation.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
enabling it may cause the Kubelet to crash-loop if the Kernel is not configured as
Kubelet expects.
Default: false</td>
</tr>
<tr><td><code>makeIPTablesUtilChains</code><br>
<code>bool</code>
</td>
<td>
If true, Kubelet ensures a set of iptables rules are present on host.
These rules will serve as utility rules for various components, e.g. KubeProxy.
The rules will be created based on IPTablesMasqueradeBit and IPTablesDropBit.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
disabling it will prevent the Kubelet from healing locally misconfigured iptables rules.
Default: true</td>
</tr>
<tr><td><code>iptablesMasqueradeBit</code><br>
<code>int32</code>
</td>
<td>
iptablesMasqueradeBit is the bit of the iptables fwmark space to mark for SNAT
Values must be within the range [0, 31]. Must be different from other mark bits.
Warning: Please match the value of the corresponding parameter in kube-proxy.
TODO: clean up IPTablesMasqueradeBit in kube-proxy
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it needs to be coordinated with other components, like kube-proxy, and the update
will only be effective if MakeIPTablesUtilChains is enabled.
Default: 14</td>
</tr>
<tr><td><code>iptablesDropBit</code><br>
<code>int32</code>
</td>
<td>
iptablesDropBit is the bit of the iptables fwmark space to mark for dropping packets.
Values must be within the range [0, 31]. Must be different from other mark bits.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it needs to be coordinated with other components, like kube-proxy, and the update
will only be effective if MakeIPTablesUtilChains is enabled.
Default: 15</td>
</tr>
<tr><td><code>featureGates</code><br>
<code>map[string]bool</code>
</td>
<td>
featureGates is a map of feature names to bools that enable or disable alpha/experimental
features. This field modifies piecemeal the built-in default values from
"k8s.io/kubernetes/pkg/features/kube_features.go".
Dynamic Kubelet Config (beta): If dynamically updating this field, consider the
documentation for the features you are enabling or disabling. While we
encourage feature developers to make it possible to dynamically enable
and disable features, some changes may require node reboots, and some
features may require careful coordination to retroactively disable.
Default: nil</td>
</tr>
<tr><td><code>failSwapOn</code><br>
<code>bool</code>
</td>
<td>
failSwapOn tells the Kubelet to fail to start if swap is enabled on the node.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
setting it to true will cause the Kubelet to crash-loop if swap is enabled.
Default: true</td>
</tr>
<tr><td><code>containerLogMaxSize</code><br>
<code>string</code>
</td>
<td>
A quantity defines the maximum size of the container log file before it is rotated.
For example: "5Mi" or "256Ki".
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may trigger log rotation.
Default: "10Mi"</td>
</tr>
<tr><td><code>containerLogMaxFiles</code><br>
<code>int32</code>
</td>
<td>
Maximum number of container log files that can be present for a container.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
lowering it may cause log files to be deleted.
Default: 5</td>
</tr>
<tr><td><code>configMapAndSecretChangeDetectionStrategy</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-ResourceChangeDetectionStrategy><code>ResourceChangeDetectionStrategy</code></a>
</td>
<td>
ConfigMapAndSecretChangeDetectionStrategy is a mode in which
config map and secret managers are running.
Default: "Watch"</td>
</tr>
<tr><td><code>systemReserved</code><br>
<code>map[string]string</code>
</td>
<td>
systemReserved is a set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G)
pairs that describe resources reserved for non-kubernetes components.
Currently only cpu and memory are supported.
See http://kubernetes.io/docs/user-guide/compute-resources for more detail.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may not be possible to increase the reserved resources, because this
requires resizing cgroups. Always look for a NodeAllocatableEnforced event
after updating this field to ensure that the update was successful.
Default: nil</td>
</tr>
<tr><td><code>kubeReserved</code><br>
<code>map[string]string</code>
</td>
<td>
A set of ResourceName=ResourceQuantity (e.g. cpu=200m,memory=150G) pairs
that describe resources reserved for kubernetes system components.
Currently cpu, memory and local storage for root file system are supported.
See http://kubernetes.io/docs/user-guide/compute-resources for more detail.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may not be possible to increase the reserved resources, because this
requires resizing cgroups. Always look for a NodeAllocatableEnforced event
after updating this field to ensure that the update was successful.
Default: nil</td>
</tr>
<tr><td><code>reservedSystemCPUs</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
This ReservedSystemCPUs option specifies the cpu list reserved for the host level system threads and kubernetes related threads.
This provide a "static" CPU list rather than the "dynamic" list by system-reserved and kube-reserved.
This option overwrites CPUs provided by system-reserved and kube-reserved.</td>
</tr>
<tr><td><code>showHiddenMetricsForVersion</code><br>
<code>string</code>
</td>
<td>
The previous version for which you want to show hidden metrics.
Only the previous minor version is meaningful, other values will not be allowed.
The format is <major>.<minor>, e.g.: '1.16'.
The purpose of this format is make sure you have the opportunity to notice if the next release hides additional metrics,
rather than being surprised when they are permanently removed in the release after that.
Default: ""</td>
</tr>
<tr><td><code>systemReservedCgroup</code><br>
<code>string</code>
</td>
<td>
This flag helps kubelet identify absolute name of top level cgroup used to enforce `SystemReserved` compute resource reservation for OS system daemons.
Refer to [Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md) doc for more information.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: ""</td>
</tr>
<tr><td><code>kubeReservedCgroup</code><br>
<code>string</code>
</td>
<td>
This flag helps kubelet identify absolute name of top level cgroup used to enforce `KubeReserved` compute resource reservation for Kubernetes node system daemons.
Refer to [Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md) doc for more information.
Dynamic Kubelet Config (beta): This field should not be updated without a full node
reboot. It is safest to keep this value the same as the local config.
Default: ""</td>
</tr>
<tr><td><code>enforceNodeAllocatable</code><br>
<code>[]string</code>
</td>
<td>
This flag specifies the various Node Allocatable enforcements that Kubelet needs to perform.
This flag accepts a list of options. Acceptable options are `none`, `pods`, `system-reserved` & `kube-reserved`.
If `none` is specified, no other options may be specified.
Refer to [Node Allocatable](https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md) doc for more information.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
removing enforcements may reduce the stability of the node. Alternatively, adding
enforcements may reduce the stability of components which were using more than
the reserved amount of resources; for example, enforcing kube-reserved may cause
Kubelets to OOM if it uses more than the reserved resources, and enforcing system-reserved
may cause system daemons to OOM if they use more than the reserved resources.
Default: ["pods"]</td>
</tr>
<tr><td><code>allowedUnsafeSysctls</code><br>
<code>[]string</code>
</td>
<td>
A comma separated whitelist of unsafe sysctls or sysctl patterns (ending in &#8727;).
Unsafe sysctl groups are kernel.shm&#8727;, kernel.msg&#8727;, kernel.sem, fs.mqueue.&#8727;, and net.&#8727;.
These sysctls are namespaced but not allowed by default. For example: "kernel.msg&#8727;,net.ipv4.route.min_pmtu"
Default: []</td>
</tr>
<tr><td><code>volumePluginDir</code><br>
<code>string</code>
</td>
<td>
volumePluginDir is the full path of the directory in which to search
for additional third party volume plugins.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that changing
the volumePluginDir may disrupt workloads relying on third party volume plugins.
Default: "/usr/libexec/kubernetes/kubelet-plugins/volume/exec/"</td>
</tr>
<tr><td><code>providerID</code><br>
<code>string</code>
</td>
<td>
providerID, if set, sets the unique id of the instance that an external provider (i.e. cloudprovider)
can use to identify a specific node.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact the ability of the Kubelet to interact with cloud providers.
Default: ""</td>
</tr>
<tr><td><code>kernelMemcgNotification</code><br>
<code>bool</code>
</td>
<td>
kernelMemcgNotification, if set, the kubelet will integrate with the kernel memcg notification
to determine if memory eviction thresholds are crossed rather than polling.
Dynamic Kubelet Config (beta): If dynamically updating this field, consider that
it may impact the way Kubelet interacts with the kernel.
Default: false</td>
</tr>
<tr><td><code>logging</code> <b>[Required]</b><br>
<a href=#LoggingConfiguration><code>LoggingConfiguration</code></a>
</td>
<td>
Logging specifies the options of logging.
Refer [Logs Options](https://github.com/kubernetes/component-base/blob/master/logs/options.go) for more information.
Defaults:
Format: text</td>
</tr>
<tr><td><code>enableSystemLogHandler</code><br>
<code>bool</code>
</td>
<td>
enableSystemLogHandler enables system logs via web interface host:port/logs/
Default: true</td>
</tr>
<tr><td><code>shutdownGracePeriod</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
ShutdownGracePeriod specifies the total duration that the node should delay the shutdown and total grace period for pod termination during a node shutdown.
Default: "30s"</td>
</tr>
<tr><td><code>shutdownGracePeriodCriticalPods</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
ShutdownGracePeriodCriticalPods specifies the duration used to terminate critical pods during a node shutdown. This should be less than ShutdownGracePeriod.
For example, if ShutdownGracePeriod=30s, and ShutdownGracePeriodCriticalPods=10s, during a node shutdown the first 20 seconds would be reserved for gracefully terminating normal pods, and the last 10 seconds would be reserved for terminating critical pods.
Default: "10s"</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-SerializedNodeConfigSource><code>SerializedNodeConfigSource</code> </h2>
<p>SerializedNodeConfigSource allows us to serialize v1.NodeConfigSource.
This type is used internally by the Kubelet for tracking checkpointed dynamic configs.
It exists in the kubeletconfig API group because it is classified as a versioned input to the Kubelet.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>kubelet.config.k8s.io/v1beta1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>SerializedNodeConfigSource</code></td></tr>
<tr><td><code>source</code><br>
<a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#nodeconfigsource-v1-core><code>core/v1.NodeConfigSource</code></a>
</td>
<td>
Source is the source that we are serializing</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-HairpinMode><code>HairpinMode</code> </h2>
<p>(Alias of <code>string</code>)</p>
<p>HairpinMode denotes how the kubelet should configure networking to handle
hairpin packets.</p>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletAnonymousAuthentication><code>KubeletAnonymousAuthentication</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthentication>KubeletAuthentication</a></li>
</ul>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>enabled</code><br>
<code>bool</code>
</td>
<td>
enabled allows anonymous requests to the kubelet server.
Requests that are not rejected by another authentication method are treated as anonymous requests.
Anonymous requests have a username of system:anonymous, and a group name of system:unauthenticated.</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletAuthentication><code>KubeletAuthentication</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a></li>
</ul>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>x509</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-KubeletX509Authentication><code>KubeletX509Authentication</code></a>
</td>
<td>
x509 contains settings related to x509 client certificate authentication</td>
</tr>
<tr><td><code>webhook</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-KubeletWebhookAuthentication><code>KubeletWebhookAuthentication</code></a>
</td>
<td>
webhook contains settings related to webhook bearer token authentication</td>
</tr>
<tr><td><code>anonymous</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-KubeletAnonymousAuthentication><code>KubeletAnonymousAuthentication</code></a>
</td>
<td>
anonymous contains settings related to anonymous authentication</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletAuthorization><code>KubeletAuthorization</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a></li>
</ul>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>mode</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthorizationMode><code>KubeletAuthorizationMode</code></a>
</td>
<td>
mode is the authorization mode to apply to requests to the kubelet server.
Valid values are AlwaysAllow and Webhook.
Webhook mode uses the SubjectAccessReview API to determine authorization.</td>
</tr>
<tr><td><code>webhook</code><br>
<a href=#kubelet-config-k8s-io-v1beta1-KubeletWebhookAuthorization><code>KubeletWebhookAuthorization</code></a>
</td>
<td>
webhook contains settings related to Webhook authorization.</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletAuthorizationMode><code>KubeletAuthorizationMode</code> </h2>
<p>(Alias of <code>string</code>)</p>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthorization>KubeletAuthorization</a></li>
</ul>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletWebhookAuthentication><code>KubeletWebhookAuthentication</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthentication>KubeletAuthentication</a></li>
</ul>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>enabled</code><br>
<code>bool</code>
</td>
<td>
enabled allows bearer token authentication backed by the tokenreviews.authentication.k8s.io API</td>
</tr>
<tr><td><code>cacheTTL</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
cacheTTL enables caching of authentication results</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletWebhookAuthorization><code>KubeletWebhookAuthorization</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthorization>KubeletAuthorization</a></li>
</ul>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>cacheAuthorizedTTL</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
cacheAuthorizedTTL is the duration to cache 'authorized' responses from the webhook authorizer.</td>
</tr>
<tr><td><code>cacheUnauthorizedTTL</code><br>
<a href=https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Duration><code>meta/v1.Duration</code></a>
</td>
<td>
cacheUnauthorizedTTL is the duration to cache 'unauthorized' responses from the webhook authorizer.</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-KubeletX509Authentication><code>KubeletX509Authentication</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletAuthentication>KubeletAuthentication</a></li>
</ul>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>clientCAFile</code><br>
<code>string</code>
</td>
<td>
clientCAFile is the path to a PEM-encoded certificate bundle. If set, any request presenting a client certificate
signed by one of the authorities in the bundle is authenticated with a username corresponding to the CommonName,
and groups corresponding to the Organization in the client certificate.</td>
</tr>
</tbody>
</table>
<h2 id=kubelet-config-k8s-io-v1beta1-ResourceChangeDetectionStrategy><code>ResourceChangeDetectionStrategy</code> </h2>
<p>(Alias of <code>string</code>)</p>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a></li>
</ul>
<p>ResourceChangeDetectionStrategy denotes a mode in which internal
managers (secret, configmap) are discovering object changes.</p>
<h2 id=LoggingConfiguration><code>LoggingConfiguration</code> </h2>
<p><strong>Appears in:</strong></p>
<ul>
<li><a href=#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>KubeletConfiguration</a></li>
</ul>
<p>LoggingConfiguration contains logging options
Refer <a href=https://github.com/kubernetes/component-base/blob/master/logs/options.go>Logs Options</a> for more information.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>format</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
Format Flag specifies the structure of log messages.
default value of format is `text`</td>
</tr>
<tr><td><code>sanitization</code> <b>[Required]</b><br>
<code>bool</code>
</td>
<td>
[Experimental] When enabled prevents logging of fields tagged as sensitive (passwords, keys, tokens).
Runtime log sanitization may introduce significant computation overhead and therefore should not be enabled in production.`)</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-74f43b2a33c21414f1ed8c359b37d326>11.7 - WebhookAdmission Configuration (v1)</h1>
<p>Package v1 is the v1 version of the API.</p>
<h2 id=resource-types>Resource Types</h2>
<ul>
<li><a href=#apiserver-config-k8s-io-v1-WebhookAdmission>WebhookAdmission</a></li>
</ul>
<h2 id=apiserver-config-k8s-io-v1-WebhookAdmission><code>WebhookAdmission</code> </h2>
<p>WebhookAdmission provides configuration for the webhook admission controller.</p>
<table class=table>
<thead><tr><th width=30%>Field</th><th>Description</th></tr></thead>
<tbody>
<tr><td><code>apiVersion</code><br>string</td><td><code>apiserver.config.k8s.io/v1</code></td></tr>
<tr><td><code>kind</code><br>string</td><td><code>WebhookAdmission</code></td></tr>
<tr><td><code>kubeConfigFile</code> <b>[Required]</b><br>
<code>string</code>
</td>
<td>
KubeConfigFile is the path to the kubeconfig file.</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f8b023454daa9497b7eea35b7d35c075>12 - 调度</h1>
</div>
<div class=td-content>
<h1 id=pg-5a0a68fb6a7ffefb6d5f861100fa0ae3>12.1 - 调度策略</h1>
<p><a class=glossary-tooltip title="控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。" data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a>
根据调度策略指定的<em>断言（predicates）<em>和</em>优先级（priorities）</em>
分别对节点进行<a href=/zh/docs/concepts/scheduling-eviction/kube-scheduler/#kube-scheduler-implementation>过滤和打分</a>。</p>
<p>你可以通过执行 <code>kube-scheduler --policy-config-file &lt;filename></code> 或
<code>kube-scheduler --policy-configmap &lt;ConfigMap></code>
设置并使用<a href=/zh/docs/reference/config-api/kube-scheduler-policy-config.v1/>调度策略</a>。</p>
<h2 id=predicates>断言 </h2>
<p>以下<em>断言</em>实现了过滤接口：</p>
<ul>
<li><code>PodFitsHostPorts</code>：检查 Pod 请求的端口（网络协议类型）在节点上是否可用。</li>
</ul>
<ul>
<li><code>PodFitsHost</code>：检查 Pod 是否通过主机名指定了 Node。</li>
</ul>
<ul>
<li><code>PodFitsResources</code>：检查节点的空闲资源（例如，CPU和内存）是否满足 Pod 的要求。</li>
</ul>
<ul>
<li><code>MatchNodeSelector</code>：检查 Pod 的节点<a class=glossary-tooltip title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=选择算符>选择算符</a>
和节点的 <a class=glossary-tooltip title=用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=标签>标签</a> 是否匹配。</li>
</ul>
<ul>
<li><code>NoVolumeZoneConflict</code>：给定该存储的故障区域限制，
评估 Pod 请求的<a class=glossary-tooltip title="包含可被 Pod 中容器访问的数据的目录。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/storage/volumes/ target=_blank aria-label=卷>卷</a>在节点上是否可用。</li>
</ul>
<ul>
<li><code>NoDiskConflict</code>：根据 Pod 请求的卷是否在节点上已经挂载，评估 Pod 和节点是否匹配。</li>
</ul>
<ul>
<li><code>MaxCSIVolumeCount</code>：决定附加 <a class=glossary-tooltip title="容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 卷的数量，判断是否超过配置的限制。</li>
</ul>
<ul>
<li><code>PodToleratesNodeTaints</code>：检查 Pod 的<a class=glossary-tooltip title="一个核心对象，由三个必需的属性组成：key、value 和 effect。 容忍度允许将 Pod 调度到具有对应污点的节点或节点组上。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=容忍>容忍</a>
是否能容忍节点的<a class=glossary-tooltip title="污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=污点>污点</a>。</li>
</ul>
<ul>
<li><code>CheckVolumeBinding</code>：基于 Pod 的卷请求，评估 Pod 是否适合节点，这里的卷包括绑定的和未绑定的
<a class=glossary-tooltip title=声明在持久卷中定义的存储资源，以便可以将其挂载为容器中的卷。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PVCs>PVCs</a> 都适用。</li>
</ul>
<h2 id=priorities>优先级 </h2>
<p>以下<em>优先级</em>实现了打分接口：</p>
<ul>
<li><code>SelectorSpreadPriority</code>：属于同一 <a class=glossary-tooltip title="将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>、
<a class=glossary-tooltip title="StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a> 或
<a class=glossary-tooltip title="ReplicaSet 是下一代副本控制器。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSet>ReplicaSet</a> 的 Pod，跨主机部署。</li>
</ul>
<ul>
<li><code>InterPodAffinityPriority</code>：实现了 <a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity>Pod 间亲和性与反亲和性</a>的优先级。</li>
</ul>
<ul>
<li><code>LeastRequestedPriority</code>：偏向最少请求资源的节点。
换句话说，节点上的 Pod 越多，使用的资源就越多，此策略给出的排名就越低。</li>
</ul>
<ul>
<li><code>MostRequestedPriority</code>：支持最多请求资源的节点。
该策略将 Pod 调度到整体工作负载所需的最少的一组节点上。</li>
</ul>
<ul>
<li><code>RequestedToCapacityRatioPriority</code>：使用默认的打分方法模型，创建基于 ResourceAllocationPriority 的 requestedToCapacity。</li>
</ul>
<ul>
<li><code>BalancedResourceAllocation</code>：偏向平衡资源使用的节点。</li>
</ul>
<ul>
<li><code>NodePreferAvoidPodsPriority</code>：根据节点的注解 <code>scheduler.alpha.kubernetes.io/preferAvoidPods</code> 对节点进行优先级排序。
你可以使用它来暗示两个不同的 Pod 不应在同一节点上运行。</li>
</ul>
<ul>
<li><code>NodeAffinityPriority</code>：根据节点亲和中 PreferredDuringSchedulingIgnoredDuringExecution 字段对节点进行优先级排序。
你可以在<a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/>将 Pod 分配给节点</a>中了解更多。</li>
</ul>
<ul>
<li><code>TaintTolerationPriority</code>：根据节点上无法忍受的污点数量，给所有节点进行优先级排序。
此策略会根据排序结果调整节点的等级。</li>
</ul>
<ul>
<li><code>ImageLocalityPriority</code>：偏向已在本地缓存 Pod 所需容器镜像的节点。</li>
</ul>
<ul>
<li><code>ServiceSpreadingPriority</code>：对于给定的 Service，此策略旨在确保该 Service 关联的 Pod 在不同的节点上运行。
它偏向把 Pod 调度到没有该服务的节点。
整体来看，Service 对于单个节点故障变得更具弹性。</li>
</ul>
<ul>
<li><code>EqualPriority</code>：给予所有节点相等的权重。</li>
</ul>
<ul>
<li><code>EvenPodsSpreadPriority</code>：实现了 <a href=/zh/docs/concepts/workloads/pods/pod-topology-spread-constraints/>Pod 拓扑扩展约束</a>的优先级排序。</li>
</ul>
<h2 id=接下来>接下来</h2>
<ul>
<li>了解<a href=/zh/docs/concepts/scheduling-eviction/kube-scheduler/>调度</a></li>
<li>了解 <a href=/zh/docs/reference/scheduling/config/>kube-scheduler 配置</a></li>
<li>阅读 <a href=/zh/docs/reference/config-api/kube-scheduler-config.v1beta2>kube-scheduler 配置参考 (v1beta1)</a></li>
<li>阅读 <a href=/zh/docs/reference/config-api/kube-scheduler-policy-config.v1/>kube-scheduler 策略参考 (v1)</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ef4fb938b6b63c95f5f26f9b1cec3054>12.2 - 调度器配置</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code>
</div>
<p>你可以通过编写配置文件，并将其路径传给 <code>kube-scheduler</code> 的命令行参数，定制 <code>kube-scheduler</code> 的行为。</p>
<p>调度模板（Profile）允许你配置 <a class=glossary-tooltip title="控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。" data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a>
中的不同调度阶段。每个阶段都暴露于某个扩展点中。插件通过实现一个或多个扩展点来提供调度行为。</p>
<p>你可以通过运行 <code>kube-scheduler --config &lt;filename></code> 来设置调度模板，
使用 <a href=/docs/reference/config-api/kube-scheduler-config.v1beta1/>KubeSchedulerConfiguration (v1beta1)</a> 结构体。</p>
<p>最简单的配置如下：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clientConnection</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubeconfig</span>:<span style=color:#bbb> </span>/etc/srv/kubernetes/kube-scheduler/kubeconfig<span style=color:#bbb>
</span></code></pre></div>
<h2 id=profiles>配置文件 </h2>
<p>通过调度配置文件，你可以配置 <a class=glossary-tooltip title="控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。" data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a> 在不同阶段的调度行为。
每个阶段都在一个<a href=#extension-points>扩展点</a>中公开。
<a href=#scheduling-plugins>调度插件</a>通过实现一个或多个扩展点，来提供调度行为。</p>
<p>你可以配置同一 <code>kube-scheduler</code> 实例使用<a href=#multiple-profiles>多个配置文件</a>。</p>
<h3 id=extensions-points>扩展点 </h3>
<p>调度行为发生在一系列阶段中，这些阶段是通过以下扩展点公开的：</p>
<ol>
<li><code>QueueSort</code>：这些插件对调度队列中的悬决的 Pod 排序。
一次只能启用一个队列排序插件。</li>
</ol>
<ol start=2>
<li><code>PreFilter</code>：这些插件用于在过滤之前预处理或检查 Pod 或集群的信息。
它们可以将 Pod 标记为不可调度。</li>
</ol>
<ol start=3>
<li><code>Filter</code>：这些插件相当于调度策略中的断言（Predicates），用于过滤不能运行 Pod 的节点。
过滤器的调用顺序是可配置的。
如果没有一个节点通过所有过滤器的筛选，Pod 将会被标记为不可调度。</li>
</ol>
<ol start=4>
<li><code>PreScore</code>：这是一个信息扩展点，可用于预打分工作。</li>
</ol>
<ol start=5>
<li><code>Score</code>：这些插件给通过筛选阶段的节点打分。调度器会选择得分最高的节点。</li>
</ol>
<ol start=6>
<li><code>Reserve</code>：这是一个信息扩展点，当资源已经预留给 Pod 时，会通知插件。
这些插件还实现了 <code>Unreserve</code> 接口，在 <code>Reserve</code> 期间或之后出现故障时调用。</li>
</ol>
<ol start=7>
<li><code>Permit</code>：这些插件可以阻止或延迟 Pod 绑定。</li>
</ol>
<ol start=8>
<li><code>PreBind</code>：这些插件在 Pod 绑定节点之前执行。</li>
</ol>
<ol start=9>
<li><code>Bind</code>：这个插件将 Pod 与节点绑定。绑定插件是按顺序调用的，只要有一个插件完成了绑定，其余插件都会跳过。绑定插件至少需要一个。</li>
</ol>
<ol start=10>
<li><code>PostBind</code>：这是一个信息扩展点，在 Pod 绑定了节点之后调用。</li>
</ol>
<p>对每个扩展点，你可以禁用<a href=#scheduling-plugins>默认插件</a>或者是启用自己的插件，例如：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>NodeResourcesLeastAllocated<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyCustomPluginA<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MyCustomPluginB<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></code></pre></div>
<p>你可以在 <code>disabled</code> 数组中使用 <code>*</code> 禁用该扩展点的所有默认插件。
如果需要，这个字段也可以用来对插件重新顺序。</p>
<h3 id=scheduling-plugin>调度插件 </h3>
<ol>
<li><code>UnReserve</code>：这是一个信息扩展点，如果一个 Pod 在预留后被拒绝，并且被 <code>Permit</code> 插件搁置，它就会被调用。</li>
</ol>
<h2 id=scheduling-plugins>调度插件 </h2>
<p>下面默认启用的插件实现了一个或多个扩展点：</p>
<ul>
<li>
<p><code>SelectorSpread</code>：对于属于 <a class=glossary-tooltip title="将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/services-networking/service/ target=_blank aria-label=Services>Services</a>、
<a class=glossary-tooltip title="ReplicaSet 是下一代副本控制器。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSets>ReplicaSets</a> 和
<a class=glossary-tooltip title="StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSets>StatefulSets</a> 的 Pod，偏好跨多个节点部署。</p>
<p>实现的扩展点：<code>PreScore</code>，<code>Score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>ImageLocality</code>：选择已经存在 Pod 运行所需容器镜像的节点。</p>
<p>实现的扩展点：<code>Score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>TaintToleration</code>：实现了<a href=/zh/docs/concepts/scheduling-eviction/taint-and-toleration/>污点和容忍</a>。</p>
<p>实现的扩展点：<code>Filter</code>，<code>Prescore</code>，<code>Score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodeName</code>：检查 Pod 指定的节点名称与当前节点是否匹配。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodePorts</code>：检查 Pod 请求的端口在节点上是否可用。</p>
<p>实现的扩展点：<code>PreFilter</code>，<code>Filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodePreferAvoidPods</code>：基于节点的 <a class=glossary-tooltip title=注解是以键值对的形式给资源对象附加随机的无法标识的元数据。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/annotations/ target=_blank aria-label=注解>注解</a>
<code>scheduler.alpha.kubernetes.io/preferAvoidPods</code> 打分。</p>
<p>实现的扩展点：<code>Score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodeAffinity</code>：实现了<a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector>节点选择器</a>
和<a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity>节点亲和性</a>。</p>
<p>实现的扩展点：<code>Filter</code>，<code>Score</code>.</p>
</li>
</ul>
<ul>
<li>
<p><code>PodTopologySpread</code>：实现了 <a href=/zh/docs/concepts/workloads/pods/pod-topology-spread-constraints/>Pod 拓扑分布</a>。</p>
<p>实现的扩展点：<code>PreFilter</code>，<code>Filter</code>，<code>PreScore</code>，<code>Score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodeUnschedulable</code>：过滤 <code>.spec.unschedulable</code> 值为 true 的节点。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodeResourcesFit</code>：检查节点是否拥有 Pod 请求的所有资源。</p>
<p>实现的扩展点：<code>PreFilter</code>，<code>Filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodeResourcesBalancedAllocation</code>：调度 Pod 时，选择资源使用更为均衡的节点。</p>
<p>实现的扩展点：<code>Score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodeResourcesLeastAllocated</code>：选择资源分配较少的节点。</p>
<p>实现的扩展点：<code>Score</code>。</p>
</li>
</ul>
<ul>
<li><code>VolumeBinding</code>：检查节点是否有请求的卷，或是否可以绑定请求的卷。
实现的扩展点: <code>PreFilter</code>、<code>Filter</code>、<code>Reserve</code>、<code>PreBind</code> 和 <code>Score</code>。
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong> 当 <code>VolumeCapacityPriority</code> 特性被启用时，<code>Score</code> 扩展点也被启用。
它优先考虑可以满足所需卷大小的最小 PV。
</div></li>
</ul>
<ul>
<li>
<p><code>VolumeRestrictions</code>：检查挂载到节点上的卷是否满足卷提供程序的限制。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>VolumeZone</code>：检查请求的卷是否在任何区域都满足。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodeVolumeLimits</code>：检查该节点是否满足 CSI 卷限制。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>EBSLimits</code>：检查节点是否满足 AWS EBS 卷限制。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>GCEPDLimits</code>：检查该节点是否满足 GCP-PD 卷限制。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>AzureDiskLimits</code>：检查该节点是否满足 Azure 卷限制。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>InterPodAffinity</code>：实现 <a href=/zh/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity>Pod 间亲和性与反亲和性</a>。</p>
<p>实现的扩展点：<code>PreFilter</code>，<code>Filter</code>，<code>PreScore</code>，<code>Score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>PrioritySort</code>：提供默认的基于优先级的排序。</p>
<p>实现的扩展点：<code>QueueSort</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>DefaultBinder</code>：提供默认的绑定机制。</p>
<p>实现的扩展点：<code>Bind</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>DefaultPreemption</code>：提供默认的抢占机制。</p>
<p>实现的扩展点：<code>PostFilter</code>。</p>
</li>
</ul>
<p>你也可以通过组件配置 API 启用以下插件（默认不启用）:</p>
<ul>
<li>
<p><code>NodeResourcesMostAllocated</code>：选择已分配资源多的节点。</p>
<p>实现的扩展点：<code>Score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>RequestedToCapacityRatio</code>：根据已分配资源的某函数设置选择节点。</p>
<p>实现的扩展点：<code>Score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>CinderVolume</code>：检查该节点是否满足 OpenStack Cinder 卷限制。</p>
<p>实现的扩展点：<code>Filter</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>NodeLabel</code>：根据配置的 <a class=glossary-tooltip title=用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 data-toggle=tooltip data-placement=top href=/zh/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=标签>标签</a>
过滤节点和/或给节点打分。</p>
<p>实现的扩展点：<code>Filter</code>，<code>Score</code>。</p>
</li>
</ul>
<ul>
<li>
<p><code>ServiceAffinity</code>：检查属于某个 <a class=glossary-tooltip title="将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。" data-toggle=tooltip data-placement=top href=/zh/docs/concepts/services-networking/service/ target=_blank aria-label=服务（Service）>服务（Service）</a> 的 Pod
与配置的标签所定义的节点集是否适配。
这个插件还支持将属于某个 Service 的 Pod 分散到各个节点。</p>
<p>实现的扩展点：<code>PreFilter</code>，<code>Filter</code>，<code>Score</code>。</p>
</li>
</ul>
<h3 id=multiple-profiles>多配置文件 </h3>
<p>你可以配置 <code>kube-scheduler</code> 运行多个配置文件。
每个配置文件都有一个关联的调度器名称，并且可以在其扩展点中配置一组不同的插件。</p>
<p>使用下面的配置样例，调度器将运行两个配置文件：一个使用默认插件，另一个禁用所有打分插件。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>default-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>no</span>-scoring-scheduler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preScore</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>score</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>disabled</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></code></pre></div>
<p>对于那些希望根据特定配置文件来进行调度的 Pod，可以在 <code>.spec.schedulerName</code> 字段指定相应的调度器名称。</p>
<p>默认情况下，将创建一个调度器名为 <code>default-scheduler</code> 的配置文件。
这个配置文件包括上面描述的所有默认插件。
声明多个配置文件时，每个配置文件中调度器名称必须唯一。</p>
<p>如果 Pod 未指定调度器名称，kube-apiserver 将会把调度器名设置为 <code>default-scheduler</code>。
因此，应该存在一个调度器名为 <code>default-scheduler</code> 的配置文件来调度这些 Pod。</p>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>Pod 的调度事件把 <code>.spec.schedulerName</code> 字段值作为 ReportingController。
领导者选举事件使用列表中第一个配置文件的调度器名称。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>说明：</strong>
<p>所有配置文件必须在 QueueSort 扩展点使用相同的插件，并具有相同的配置参数（如果适用）。
这是因为调度器只有一个保存 pending 状态 Pod 的队列。
</div>
<h2 id=接下来>接下来</h2>
<ul>
<li>阅读 <a href=/zh/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler 参考</a></li>
<li>了解<a href=/zh/docs/concepts/scheduling-eviction/kube-scheduler/>调度</a></li>
<li>阅读 <a href=/zh/docs/reference/config-api/kube-scheduler-config.v1beta1/>kube-scheduler 配置 (v1beta1)</a> 参考</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c808ce38575e73f72835d7ed02b03780>13 - 其他工具</h1>
<p>Kubernetes 包含多个内置工具来帮助你使用 Kubernetes 系统。</p>
<h2 id=minikube>Minikube</h2>
<p><a href=https://minikube.sigs.k8s.io/docs/><code>minikube</code></a>
是一种在你的工作站上本地运行单节点 Kubernetes 集群的工具，用于开发和测试。</p>
<h2 id=仪表盘>仪表盘</h2>
<p><a href=/zh/docs/tasks/access-application-cluster/web-ui-dashboard/><code>Dashboard</code></a>，
基于 Web 的 Kubernetes 用户界面，
允许你将容器化的应用程序部署到 Kubernetes 集群，
对它们进行故障排查，并管理集群及其资源本身。</p>
<h2 id=helm>Helm</h2>
<p><a href=https://github.com/kubernetes/helm><code>Kubernetes Helm</code></a>
是一个用于管理预配置 Kubernetes 资源包的工具，也就是 Kubernetes 图表。</p>
<p>使用 Helm 来：</p>
<ul>
<li>查找和使用打包为 Kubernetes 图表的流行软件</li>
<li>将你自己的应用程序共享为 Kubernetes 图表</li>
<li>为你的 Kubernetes 应用程序创建可重现的构建</li>
<li>智能管理你的 Kubernetes 清单文件</li>
<li>管理 Helm 包的发布</li>
</ul>
<h2 id=kompose>Kompose</h2>
<p><a href=https://github.com/kubernetes/kompose><code>Kompose</code></a>
是一个帮助 Docker Compose 用户迁移到 Kubernetes 的工具。</p>
<p>使用 Kompose：</p>
<ul>
<li>将 Docker Compose 文件翻译成 Kubernetes 对象</li>
<li>从本地 Docker 开发转到通过 Kubernetes 管理你的应用程序</li>
<li>转换 Docker Compose v1 或 v2 版本的 <code>yaml</code> 文件或<a href=https://docs.docker.com/compose/bundles/>分布式应用程序包</a></li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/zh/docs/home/>主页</a>
<a class=text-white href=/zh/blog/>博客</a>
<a class=text-white href=/zh/training/>培训</a>
<a class=text-white href=/zh/partners/>合作伙伴</a>
<a class=text-white href=/zh/community/>社区</a>
<a class=text-white href=/zh/case-studies/>案例分析</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small>
<br>
<small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>