<!doctype html><html lang=ja class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/>
<link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/>
<link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/>
<link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/>
<link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/>
<link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>ドキュメント | Kubernetes</title><meta property="og:title" content="ドキュメント">
<meta property="og:description" content="プロダクショングレードのコンテナ管理基盤">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/ja/docs/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="ドキュメント">
<meta itemprop=description content="プロダクショングレードのコンテナ管理基盤"><meta name=twitter:card content="summary">
<meta name=twitter:title content="ドキュメント">
<meta name=twitter:description content="プロダクショングレードのコンテナ管理基盤">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content>
<meta property="og:description" content>
<meta name=twitter:description content>
<meta property="og:url" content="https://kubernetes.io/ja/docs/">
<meta property="og:title" content="ドキュメント">
<meta name=twitter:title content="ドキュメント">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/ja/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/ja/docs/>ドキュメント</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/training/>トレーニング</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/partners/>パートナー</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/community/>コミュニティ</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/case-studies/>ケーススタディ</span></a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
バージョン
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/ja/docs/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/>v1.22</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
日本語 Japanese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/>English</a>
<a class=dropdown-item href=/zh/docs/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/>한국어 Korean</a>
<a class=dropdown-item href=/fr/docs/>Français</a>
<a class=dropdown-item href=/it/docs/>Italiano</a>
<a class=dropdown-item href=/de/docs/>Deutsch</a>
<a class=dropdown-item href=/es/docs/>Español</a>
<a class=dropdown-item href=/pt-br/docs/>Português</a>
<a class=dropdown-item href=/id/docs/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/>Tiếng Việt</a>
<a class=dropdown-item href=/ru/docs/>Русский</a>
<a class=dropdown-item href=/pl/docs/>Polski</a>
<a class=dropdown-item href=/uk/docs/>Українська</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.
</p><p>
<a href=/ja/docs/>このページの通常のビューに戻る</a>.
</p>
</div>
<h1 class=title>ドキュメント</h1>
<ul>
<li>1: <a href=#pg-e735cee7e913aa88bc0aa10594d12966>Kubernetesドキュメント</a></li>
<ul>
<li>1.1: <a href=#pg-92dfff0ca612d0bff40171aa9df6c4ae>利用可能なドキュメントバージョン</a></li>
</ul>
<li>2: <a href=#pg-66b565805ca1061be35ff2c0165f13c1>はじめに</a></li>
<ul>
<li>2.1: <a href=#pg-d33663ac044e1981b406949f9124cc04>リリースノートおよびバージョンスキュー</a></li>
<ul>
<li>2.1.1: <a href=#pg-85b7e96ac42e5e28ec570ad43f0ef5cd>Kubernetesバージョンとバージョンスキューサポートポリシー</a></li>
</ul>
<li>2.2: <a href=#pg-0b597086a9d1382f86abadcfeab657d6>学習環境</a></li>
<ul>
<li>2.2.1: <a href=#pg-8b996bf57bd8e67340235da1a1fb8e95>Minikubeを使用してローカル環境でKubernetesを動かす</a></li>
<li>2.2.2: <a href=#pg-861dedab439fb9a133b35009a34655ec>Kindを使用してKubernetesをインストールする</a></li>
</ul>
<li>2.3: <a href=#pg-4e14853fdaa3bd273f31a60112b9b5ac>プロダクション環境</a></li>
<ul>
<li>2.3.1: <a href=#pg-a77d3feb6e6d9978f32fa14622642e9a>CRIのインストール</a></li>
<li>2.3.2: <a href=#pg-00e1646f68aeb89f9722cf6f6cfcad94>Kubernetesをデプロイツールでインストールする</a></li>
<ul>
<li>2.3.2.1: <a href=#pg-a16f59f325a17cdeed324d5c889f7f73>kubeadmを使ってクラスターを構築する</a></li>
<ul>
<li>2.3.2.1.1: <a href=#pg-29e59491dd6118b23072dfe9ebb93323>kubeadmのインストール</a></li>
<li>2.3.2.1.2: <a href=#pg-c3689df4b0c61a998e79d91a865aa244>kubeadmのトラブルシューティング</a></li>
<li>2.3.2.1.3: <a href=#pg-134ed1f6142a98e6ac681a1ba4920e53>kubeadmを使用したクラスターの作成</a></li>
<li>2.3.2.1.4: <a href=#pg-4c656c5eda3e1c06ad1aedebdc04a211>kubeadmを使ったコントロールプレーンの設定のカスタマイズ</a></li>
<li>2.3.2.1.5: <a href=#pg-015edbc7cc688d31b1d1edce7c186135>高可用性トポロジーのためのオプション</a></li>
<li>2.3.2.1.6: <a href=#pg-3941d5c3409342219bf7e03128b8ecb6>kubeadmを使用した高可用性クラスターの作成</a></li>
<li>2.3.2.1.7: <a href=#pg-8160424c22d24f7d2d63c521e107dbf8>kubeadmを使用した高可用性etcdクラスターの作成</a></li>
<li>2.3.2.1.8: <a href=#pg-07709e71de6b4ac2573041c31213dbeb>kubeadmを使用したクラスター内の各kubeletの設定</a></li>
<li>2.3.2.1.9: <a href=#pg-ed857e09999827b013ee9062dc9c59bb>コントロールプレーンをセルフホストするようにkubernetesクラスターを構成する</a></li>
</ul>
<li>2.3.2.2: <a href=#pg-478acca1934b6d89a0bc00fb25bfe5b6>kopsを使ったAWS上でのKubernetesのインストール</a></li>
<li>2.3.2.3: <a href=#pg-f8b4964187fe973644e06ee629eff1de>kubesprayを使ったオンプレミス/クラウドプロバイダへのKubernetesのインストール</a></li>
</ul>
<li>2.3.3: <a href=#pg-e2eb3029b668b1713d0dc8bea296ba9c>ターンキークラウドソリューション</a></li>
<ul>
<li>2.3.3.1: <a href=#pg-20c20ee4c93be1062165131aff27cff5>Alibaba CloudでKubernetesを動かす</a></li>
<li>2.3.3.2: <a href=#pg-4db51d554f14646b6af380916c827aa0>AWS EC2上でKubernetesを動かす</a></li>
<li>2.3.3.3: <a href=#pg-66b96ad245efc180060593fa01df4dde>Azure 上で Kubernetes を動かす</a></li>
<li>2.3.3.4: <a href=#pg-bed0528b13f56089ee19400212edf55d>Google Compute Engine上でKubernetesを動かす</a></li>
<li>2.3.3.5: <a href=#pg-ba2691e5872ead2141b1e8fd7d29ee21>IBM Cloud Privateを使ってマルチクラウドでKubernetesを動かす</a></li>
</ul>
<li>2.3.4: <a href=#pg-1b751cdddc397a65edb7bcf703bc0414>オンプレミスVM</a></li>
<ul>
<li>2.3.4.1: <a href=#pg-83a1f15a6fa96fcdca228c4a70f392b3>Cloudstack</a></li>
<li>2.3.4.2: <a href=#pg-89a44f01ba43ac7fda5e20024b9d6cea>DC/OS上のKubernetes</a></li>
<li>2.3.4.3: <a href=#pg-7f608a89334fa86add74d0d6ba0beedf>oVirt</a></li>
</ul>
<li>2.3.5: <a href=#pg-acce7e24090fea04715a7a516ba3e69b>Windows in Kubernetes</a></li>
<ul>
<li>2.3.5.1: <a href=#pg-a307d413f1f7430fced233023087e2a1>KubernetesのWindowsサポート概要</a></li>
<li>2.3.5.2: <a href=#pg-3a51e66c5de55f9093a8dc55742006d3>KubernetesでWindowsコンテナをスケジュールするためのガイド</a></li>
</ul>
</ul>
<li>2.4: <a href=#pg-84b6491601d6a2b3da4cd5a105c866ba>ベストプラクティス</a></li>
<ul>
<li>2.4.1: <a href=#pg-970615c97499e3651fd3a98e0387cefc>複数のゾーンで動かす</a></li>
<li>2.4.2: <a href=#pg-c797ee17120176c685455db89ae091a9>大規模クラスタの構築</a></li>
<li>2.4.3: <a href=#pg-f89867de1d34943f1524f67a241f5cc9>ノードのセットアップの検証</a></li>
<li>2.4.4: <a href=#pg-0394f813094b7a35058dffe5b8bacd20>PKI証明書とその要件</a></li>
</ul>
</ul>
<li>3: <a href=#pg-dd948255948d6b59b32c471abcb62997>コンセプト</a></li>
<ul>
<li>3.1: <a href=#pg-0554ac387412eaf4e6e89b2f847dacde>概要</a></li>
<ul>
<li>3.1.1: <a href=#pg-45bdca6129cf540121623e903c18ba46>Kubernetesとは何か？</a></li>
<li>3.1.2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Kubernetesのコンポーネント</a></li>
<li>3.1.3: <a href=#pg-0c745f42e623d2b70a53bc0e6db73d95>Kubernetes API</a></li>
<li>3.1.4: <a href=#pg-110f33530cf761140cb1dab536baef04>Kubernetesオブジェクトを利用する</a></li>
<ul>
<li>3.1.4.1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>Kubernetesオブジェクトを理解する</a></li>
<li>3.1.4.2: <a href=#pg-6751db8ff5409476de8225d17d6c42dd>Kubernetesオブジェクト管理</a></li>
<li>3.1.4.3: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>オブジェクトの名前とID</a></li>
<li>3.1.4.4: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>Namespace(名前空間)</a></li>
<li>3.1.4.5: <a href=#pg-f1dec4557fb8ffbac9f11390aaaf9fa4>ラベル(Labels)とセレクター(Selectors)</a></li>
<li>3.1.4.6: <a href=#pg-93cd7a1d4e1623e2bf01afc49a5af69c>アノテーション(Annotations)</a></li>
<li>3.1.4.7: <a href=#pg-046c03090d47bc4b89b818dc645c3865>フィールドセレクター(Field Selectors)</a></li>
<li>3.1.4.8: <a href=#pg-5dd62c6a4a481b4cf1ac50f6799eb581>推奨ラベル(Recommended Labels)</a></li>
</ul>
</ul>
<li>3.2: <a href=#pg-2bf36ccd6b3dbeafecf87c39761b07c7>クラスターのアーキテクチャ</a></li>
<ul>
<li>3.2.1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>ノード</a></li>
<li>3.2.2: <a href=#pg-63e7fdf87ba61eb2586bb8c625c23506>マスターとノード間の通信</a></li>
<li>3.2.3: <a href=#pg-ca8819042a505291540e831283da66df>コントローラー</a></li>
<li>3.2.4: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>クラウドコントローラーマネージャー</a></li>
</ul>
<li>3.3: <a href=#pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>コンテナ</a></li>
<ul>
<li>3.3.1: <a href=#pg-8fda96dc403731ceba5e0ddd0ab3ad15>コンテナの概要</a></li>
<li>3.3.2: <a href=#pg-16042b4652ad19e565c7263824029a43>イメージ</a></li>
<li>3.3.3: <a href=#pg-643212488f778acf04bebed65ba34441>コンテナ環境</a></li>
<li>3.3.4: <a href=#pg-a858027489648786a3b16264e451272b>ランタイムクラス(Runtime Class)</a></li>
<li>3.3.5: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>コンテナライフサイクルフック</a></li>
</ul>
<li>3.4: <a href=#pg-d52aadda80edd9f8c514cfe2321363c2>ワークロード</a></li>
<ul>
<li>3.4.1: <a href=#pg-4d68b0ccf9c683e6368ffdcc40c838d4>Pod</a></li>
<ul>
<li>3.4.1.1: <a href=#pg-37afa6c66c74400d1579f10faf55e5b6>Podの概観</a></li>
<li>3.4.1.2: <a href=#pg-c3c2b9cf30915ec9d46c147201da3332>Podのライフサイクル</a></li>
<li>3.4.1.3: <a href=#pg-1ccbd4eeded6ab138d98b59175bd557e>Initコンテナ</a></li>
<li>3.4.1.4: <a href=#pg-4e9b9cbc9776b12e7335c53da377c9c8>Pod Preset</a></li>
<li>3.4.1.5: <a href=#pg-53a1005011e1bda2ce81819aad7c8b32>エフェメラルコンテナ</a></li>
</ul>
<li>3.4.2: <a href=#pg-89637410cacae45a36ab1cc278c482eb>ワークロードリソース</a></li>
<ul>
<li>3.4.2.1: <a href=#pg-a2dc0393e0c4079e1c504b6429844e86>Deployment</a></li>
<li>3.4.2.2: <a href=#pg-d459b930218774655fa7fd1620625539>ReplicaSet</a></li>
<li>3.4.2.3: <a href=#pg-6d72299952c37ca8cc61b416e5bdbcd4>StatefulSet</a></li>
<li>3.4.2.4: <a href=#pg-41600eb8b6631c88848156f381e9d588>DaemonSet</a></li>
<li>3.4.2.5: <a href=#pg-9add0d2120634b63073ad08dc8683bd6>ガベージコレクション</a></li>
<li>3.4.2.6: <a href=#pg-4de50a37ebb6f2340484192126cb7a04>終了したリソースのためのTTLコントローラー(TTL Controller for Finished Resources)</a></li>
<li>3.4.2.7: <a href=#pg-2e4cec01c525b45eccd6010e21cc76d9>CronJob</a></li>
</ul>
</ul>
<li>3.5: <a href=#pg-0a0a7eca3e302a3c08f8c85e15d337fd>Service、負荷分散とネットワーキング</a></li>
<ul>
<li>3.5.1: <a href=#pg-5701136fd2ce258047b6ddc389112352>Service</a></li>
<li>3.5.2: <a href=#pg-3a38878244d862dfdb8d7adb32f77584>Serviceトポロジー</a></li>
<li>3.5.3: <a href=#pg-91cb8a4438b003df11bc1c426a81b756>ServiceとPodに対するDNS</a></li>
<li>3.5.4: <a href=#pg-f804ac0532fcade3966ea2e3769ca031>サービスとアプリケーションの接続</a></li>
<li>3.5.5: <a href=#pg-f51db1097575de8072afe1f5b156a70c>EndpointSlice</a></li>
<li>3.5.6: <a href=#pg-199bcc92443dbc9bed44819467d7eb75>Ingress</a></li>
<li>3.5.7: <a href=#pg-5a8edeb1f2dc8e38cd6d561bb08b0d78>Ingressコントローラー</a></li>
<li>3.5.8: <a href=#pg-ded1daafdcd293023ee333728007ca61>ネットワークポリシー</a></li>
<li>3.5.9: <a href=#pg-21f8d19c60c33914baab66224c3d46a7>IPv4/IPv6デュアルスタック</a></li>
</ul>
<li>3.6: <a href=#pg-f018f568c6723865753f150c3c59bdda>ストレージ</a></li>
<ul>
<li>3.6.1: <a href=#pg-ffd12528a12882b282e1bd19e29f9e75>永続ボリューム</a></li>
<li>3.6.2: <a href=#pg-707ca81a34eb1ca202f34692e9917d1e>CSI Volume Cloning</a></li>
<li>3.6.3: <a href=#pg-4d00116c86dade62bdd5be7dc2afa1ca>VolumeSnapshotClass</a></li>
<li>3.6.4: <a href=#pg-018f0a7fc6e2f6d16da37702fc39b4f3>ボリュームの動的プロビジョニング(Dynamic Volume Provisioning)</a></li>
<li>3.6.5: <a href=#pg-00cd24f4570b7acaac75c2551c948bc7>ストレージ容量</a></li>
</ul>
<li>3.7: <a href=#pg-275bea454e1cf4c5adeca4058b5af988>設定</a></li>
<ul>
<li>3.7.1: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>設定のベストプラクティス</a></li>
<li>3.7.2: <a href=#pg-6b5ccadd699df0904e8e9917c5450c4b>ConfigMap</a></li>
<li>3.7.3: <a href=#pg-e511ed821ada65d0053341dbd8ad2bb5>Secret</a></li>
<li>3.7.4: <a href=#pg-436057b96151ecb8a4a9a9f456b5d0fc>コンテナのリソース管理</a></li>
<li>3.7.5: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>kubeconfigファイルを使用してクラスターアクセスを組織する</a></li>
<li>3.7.6: <a href=#pg-ed4ae5e4344d619bc6df6e1278efae74>Podの優先度とプリエンプション</a></li>
</ul>
<li>3.8: <a href=#pg-712cb3c03ff14a39e5a83a6d9b71d203>セキュリティ</a></li>
<ul>
<li>3.8.1: <a href=#pg-1fb24c1dd155f43849da490a74c4b8c5>Podセキュリティの標準</a></li>
<li>3.8.2: <a href=#pg-04eeb110d75afc8acb2cf7a3db743985>クラウドネイティブセキュリティの概要</a></li>
</ul>
<li>3.9: <a href=#pg-c21d05f31057c5bcd2ebdd01f4e62a0e>スケジューリングと退避</a></li>
<ul>
<li>3.9.1: <a href=#pg-21169f516071aea5d16734a4c27789a5>Node上へのPodのスケジューリング</a></li>
<li>3.9.2: <a href=#pg-ede4960b56a3529ee0bfe7c8fe2d09a5>TaintとToleration</a></li>
<li>3.9.3: <a href=#pg-598f36d691ab197f9d995784574b0a12>Kubernetesのスケジューラー</a></li>
<li>3.9.4: <a href=#pg-d9574a30fcbc631b0d2a57850e161e89>スケジューラーのパフォーマンスチューニング</a></li>
</ul>
<li>3.10: <a href=#pg-ac9161c6d952925b083ad9602b4e8e7f>ポリシー</a></li>
<ul>
<li>3.10.1: <a href=#pg-a935ff8c59eb116b43494255cc67f69a>Limit Range</a></li>
<li>3.10.2: <a href=#pg-94ddc6e901c30f256138db11d09f05a3>リソースクォータ</a></li>
</ul>
<li>3.11: <a href=#pg-285a3785fd3d20f437c28d87ca4dadca>クラスターの管理</a></li>
<ul>
<li>3.11.1: <a href=#pg-fb494ea3b1874bd753dcd11c3f35c2dc>クラスター管理の概要</a></li>
<li>3.11.2: <a href=#pg-2bf9a93ab5ba014fb6ff70b22c29d432>証明書</a></li>
<li>3.11.3: <a href=#pg-3aeeecf7cdb2a21eb4b31db7a71c81e2>リソースの管理</a></li>
<li>3.11.4: <a href=#pg-d649067a69d8d5c7e71564b42b96909e>クラスターのネットワーク</a></li>
<li>3.11.5: <a href=#pg-5cc31ecfba86467f8884856412cfb6b2>システムログ</a></li>
<li>3.11.6: <a href=#pg-2e05a56491965ae320c2662590b2ca18>コンテナイメージのガベージコレクション</a></li>
<li>3.11.7: <a href=#pg-08e94e6a480e0d6b2de72d84a1b97617>Kubernetesのプロキシー</a></li>
<li>3.11.8: <a href=#pg-85d633ae590aa20ec024f1b7af1d74fc>アドオンのインストール</a></li>
</ul>
<li>3.12: <a href=#pg-7e0d97616b15e2c383c6a0a96ec442cb>Kubernetesを拡張する</a></li>
<ul>
<li>3.12.1: <a href=#pg-5c2b36cd0ddbe006b575d4e54c63d508>Kubernetesクラスターの拡張</a></li>
<li>3.12.2: <a href=#pg-0af41d3bd7c785621b58b7564793396a>Kubernetes APIの拡張</a></li>
<ul>
<li>3.12.2.1: <a href=#pg-342388440304e19ce30c0f8ada1c77ce>カスタムリソース</a></li>
<li>3.12.2.2: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>アグリゲーションレイヤーを使ったKubernetes APIの拡張</a></li>
</ul>
<li>3.12.3: <a href=#pg-3131452556176159fb269593c1a52012>オペレーターパターン</a></li>
</ul>
</ul>
<li>4: <a href=#pg-f8918f697450c2009b75913f9e9317a5>タスク</a></li>
<ul>
<li>4.1: <a href=#pg-57bf66f59d9a642b82eebeabbc66470b>ツールのインストール</a></li>
<ul>
<li>4.1.1: <a href=#pg-bbdc530b292ab4074d1dfe69feafb3e7>kubectlのインストールおよびセットアップ</a></li>
</ul>
<li>4.2: <a href=#pg-f5da33b976758a9183018c421eb83f58>Podとコンテナの設定</a></li>
<ul>
<li>4.2.1: <a href=#pg-e6dd9300cf3a955f7cdfe77fb5d15292>コンテナおよびPodへのメモリーリソースの割り当て</a></li>
<li>4.2.2: <a href=#pg-8555af270ae7122cc0464bab3f5d1609>コンテナおよびPodへのCPUリソースの割り当て</a></li>
<li>4.2.3: <a href=#pg-904cea8c8efd5c0d33adbfe579ec2dd2>PodにQuality of Serviceを設定する</a></li>
<li>4.2.4: <a href=#pg-4219ac6ab56a3b88d20305083d57d03c>拡張リソースをコンテナに割り当てる</a></li>
<li>4.2.5: <a href=#pg-484833fb880d1e179cc2965d15f84da5>ストレージにボリュームを使用するPodを構成する</a></li>
<li>4.2.6: <a href=#pg-4621938ba53c04a77f51b5938a583439>ストレージにProjectedボリュームを使用するようPodを設定する</a></li>
<li>4.2.7: <a href=#pg-eb54daf87df373096b5e830680194dfc>Liveness Probe、Readiness ProbeおよびStartup Probeを使用する</a></li>
<li>4.2.8: <a href=#pg-fc3f4777ae8ea685d2b54e175277ac01>Node Affinityを利用してPodをノードに割り当てる</a></li>
<li>4.2.9: <a href=#pg-bbc17480da6d051c696489654c64064a>Podをノードに割り当てる</a></li>
<li>4.2.10: <a href=#pg-efbc43486296f0439d1a89c12d944d94>コンテナライフサイクルイベントへのハンドラー紐付け</a></li>
<li>4.2.11: <a href=#pg-ed34e761c3dbd00fa79577fa78e30020>Podを構成してConfigMapを使用する</a></li>
<li>4.2.12: <a href=#pg-3d7b9cb24a647c36ba63f7a02ec49010>Pod内のコンテナ間でプロセス名前空間を共有する</a></li>
<li>4.2.13: <a href=#pg-42a59b878d4c58e5c6f4bb87483dda93>static Podを作成する</a></li>
</ul>
<li>4.3: <a href=#pg-34a810f1516ad9d99b2697e36e9b0d0f>クラスターの管理</a></li>
<ul>
<li>4.3.1: <a href=#pg-adb489b1ab985c9215657b0d4c6ae92b>Namespaceに対する最小および最大メモリー制約の構成</a></li>
<li>4.3.2: <a href=#pg-9133578f1e75663bb031e5a377ca896d>Windowsノードの追加</a></li>
<li>4.3.3: <a href=#pg-e805c7d8d4ad6195cb82dbbc843bfc29>Windowsノードのアップグレード</a></li>
<li>4.3.4: <a href=#pg-77351865caa548b0a06694b904dd881c>EndpointSliceの有効化</a></li>
<li>4.3.5: <a href=#pg-9ceed97f912df7289ed8872e290cfbad>KubernetesクラスターでNodeLocal DNSキャッシュを使用する</a></li>
<li>4.3.6: <a href=#pg-00733cc3747eb3f5fe1c9e0439262967>Serviceトポロジーを有効にする</a></li>
<li>4.3.7: <a href=#pg-ce4cd28c8feb9faa783e79b48af37961>クラウドコントローラーマネージャーの運用管理</a></li>
<li>4.3.8: <a href=#pg-9585dc0efb0450fd68728e7511754717>クラウドコントローラーマネージャーの開発</a></li>
<li>4.3.9: <a href=#pg-e1afcdac8d5e8458274b3c481c5ebcda>サービスディスカバリーにCoreDNSを使用する</a></li>
<li>4.3.10: <a href=#pg-a3790dfb57271d13517e549dffa805b9>ネットワークポリシーを宣言する</a></li>
<li>4.3.11: <a href=#pg-8060aed5bf1172fa62199a4c306a4cd1>ノードのトポロジー管理ポリシーを制御する</a></li>
<li>4.3.12: <a href=#pg-a8f6511197efcd7d0db80ade49620f9d>拡張リソースをNodeにアドバタイズする</a></li>
</ul>
<li>4.4: <a href=#pg-aa0731e8aa8e2f6cc9e3c1a5e9895863>Kubernetesオブジェクトの管理</a></li>
<ul>
</ul>
<li>4.5: <a href=#pg-94f49ece137035764368f22a98942872>Secretの管理</a></li>
<ul>
<li>4.5.1: <a href=#pg-0ed63ce3c9665aed7ff5a560ff1da843>kubectlを使用してSecretを管理する</a></li>
<li>4.5.2: <a href=#pg-e841cf91fd3566db1e86143ed7a9e13c>設定ファイルを使用してSecretを管理する</a></li>
<li>4.5.3: <a href=#pg-a0ff2e3ba8af5670d5dc3d94c4bd0a68>Kustomizeを使用してSecretを管理する</a></li>
</ul>
<li>4.6: <a href=#pg-866924fa095f897ede8dfdcab9e97942>アプリケーションへのデータ注入</a></li>
<ul>
<li>4.6.1: <a href=#pg-82c93897176489678232542102daea40>コンテナの環境変数の定義</a></li>
<li>4.6.2: <a href=#pg-66c0456fdbef5e5116dd606d1e6f73cc>環境変数によりコンテナにPod情報を共有する</a></li>
</ul>
<li>4.7: <a href=#pg-a78a5e7e765fd8c49c8f7c0d72499f72>アプリケーションの実行</a></li>
<ul>
<li>4.7.1: <a href=#pg-790ea02857492b3a822e981e93e3a98b>Deploymentを使用してステートレスアプリケーションを実行する</a></li>
<li>4.7.2: <a href=#pg-43398a6f5dc7ce19df59f5f4c2e7922d>単一レプリカのステートフルアプリケーションを実行する</a></li>
<li>4.7.3: <a href=#pg-95b3d561509c573e53bec2368264cf6a>レプリカを持つステートフルアプリケーションを実行する</a></li>
<li>4.7.4: <a href=#pg-7a9b5779e228083ba3fdeaf414fe704e>StatefulSetのスケール</a></li>
<li>4.7.5: <a href=#pg-c43537b0ee1da992ecb7488f87e6c934>StatefulSetの削除</a></li>
<li>4.7.6: <a href=#pg-f5f2f7a74377a9d45325c5253353fa8f>StatefulSet Podの強制削除</a></li>
<li>4.7.7: <a href=#pg-8138226ce9660ac8e3e82ff86fff8ad2>Horizontal Pod Autoscalerウォークスルー</a></li>
</ul>
<li>4.8: <a href=#pg-ca3bc4e31dfe46d5044a3b93eb804ee9>Jobの実行</a></li>
<ul>
<li>4.8.1: <a href=#pg-964bdff888520740e5e221695245678d>CronJobを使用して自動化タスクを実行する</a></li>
<li>4.8.2: <a href=#pg-9e63850014876afaebd1561f70bb8f6b>静的な処理の割り当てを使用した並列処理のためのインデックス付きJob</a></li>
</ul>
<li>4.9: <a href=#pg-b74b959f5a531003dd0653dfbfc2e88b>クラスター内アプリケーションへのアクセス</a></li>
<ul>
<li>4.9.1: <a href=#pg-777447042cd4e81df3fa5beb3357a485>Web UI (Dashboard)</a></li>
<li>4.9.2: <a href=#pg-5a233e14205d77fe1294917d2da6f876>複数のクラスターへのアクセスを設定する</a></li>
<li>4.9.3: <a href=#pg-312f29f850826b74618634cd877aa065>Serviceを利用したクラスター内のアプリケーションへのアクセス</a></li>
<li>4.9.4: <a href=#pg-f3dac629bea950fc026d920306f09fb4>Serviceを使用してフロントエンドをバックエンドに接続する</a></li>
<li>4.9.5: <a href=#pg-1839d8468a083839ed1cc8d18fe1142e>Minikube上でNGINX Ingressコントローラーを使用してIngressをセットアップする</a></li>
<li>4.9.6: <a href=#pg-48e8f306f919c5b81265e265a2b76ab4>クラスターで実行されているすべてのコンテナイメージを一覧表示する</a></li>
<li>4.9.7: <a href=#pg-7c319a9981586e5fbcfa21b392720650>共有ボリュームを使用して同じPod内のコンテナ間で通信する</a></li>
</ul>
<li>4.10: <a href=#pg-f6a755efe831d24956501e4bcd49ff96>監視、ログ、デバッグ</a></li>
<ul>
<li>4.10.1: <a href=#pg-06bb252f25983de12f635c806d180d30>Initコンテナのデバッグ</a></li>
<li>4.10.2: <a href=#pg-858517cd46a1b5a1fd2e650edd785cea>PodとReplicationControllerのデバッグ</a></li>
<li>4.10.3: <a href=#pg-ef360b1f8e65236251826db478cfcab3>Pod障害の原因を特定する</a></li>
<li>4.10.4: <a href=#pg-f79645981e310858111bd5673614cab6>Serviceのデバッグ</a></li>
<li>4.10.5: <a href=#pg-a070b1250ee142402d492b505a56ca83>StatefulSetのデバッグ</a></li>
<li>4.10.6: <a href=#pg-9713ac27b6d9e3034033200d968221f2>実行中のコンテナへのシェルを取得する</a></li>
</ul>
<li>4.11: <a href=#pg-d3c88a8663f58e9ec0bed73faff5b670>TLS</a></li>
<ul>
<li>4.11.1: <a href=#pg-1272b18ac0c008f6ffc2c62a29fa929f>Kubeletの証明書のローテーションを設定する</a></li>
</ul>
<li>4.12: <a href=#pg-5266308e17490aeee8b018316bf47e03>サービスカタログ</a></li>
<ul>
<li>4.12.1: <a href=#pg-f741b6fc36e27a6f79c1c3d02a40d8f9>Helmを使用したサービスカタログのインストール</a></li>
<li>4.12.2: <a href=#pg-d85a30635b5c3578487b9f6f214c07ea>SCを使用したサービスカタログのインストール</a></li>
</ul>
<li>4.13: <a href=#pg-a701e71f3b32dae474c63ae4c596c856>ネットワーク</a></li>
<ul>
<li>4.13.1: <a href=#pg-2edb5b02ea1e646c333c9fe4d5f02ff1>HostAliasesを使用してPodの/etc/hostsにエントリーを追加する</a></li>
<li>4.13.2: <a href=#pg-eebac062766222247063d6513f95c7b2>IPv4/IPv6デュアルスタックの検証</a></li>
</ul>
<li>4.14: <a href=#pg-5ab7bc7f14942c5c4b29d19f4a87271c>GPUのスケジューリング</a></li>
<li>4.15: <a href=#pg-fdfb2a2cba62a1e624897eaebac0168e>huge pageを管理する</a></li>
</ul>
<li>5: <a href=#pg-68ec2370d0409cc27325be36693f9368>チュートリアル</a></li>
<ul>
<li>5.1: <a href=#pg-5e3051fff9e84735871d9fb5e7b93f33>Hello Minikube</a></li>
<li>5.2: <a href=#pg-3c83f53a74233ace9b289ac5e24c3e62>Kubernetesの基本を学ぶ</a></li>
<ul>
<li>5.2.1: <a href=#pg-7df66040311338d6098ebeab43ba9afb>クラスターの作成</a></li>
<ul>
<li>5.2.1.1: <a href=#pg-de49316920e97a82e36763cb66781ada>Minikubeを使ったクラスターの作成</a></li>
<li>5.2.1.2: <a href=#pg-323b75976001e8dfe35d67d61bc74f1a>対話型チュートリアル - クラスターの作成</a></li>
</ul>
<li>5.2.2: <a href=#pg-76d78b3fba507f7ed33cef14a35b631d>アプリケーションのデプロイ</a></li>
<ul>
<li>5.2.2.1: <a href=#pg-2b1bba431989008c7493109a0f049ece>kubectlを使ったDeploymentの作成</a></li>
<li>5.2.2.2: <a href=#pg-f8997ec143b382fa6c9621941ea62ca3>対話型チュートリアル - アプリケーションのデプロイ</a></li>
</ul>
<li>5.2.3: <a href=#pg-250d620a73ec8be7e1f7d835574c4596>アプリケーションの探索</a></li>
<ul>
<li>5.2.3.1: <a href=#pg-2771f4e8c45321b17cb0114a2d266453>Podとノードについて</a></li>
<li>5.2.3.2: <a href=#pg-4b01eab98a9844ad91131079654199dd>対話型チュートリアル - デプロイしたアプリケーションの探索</a></li>
</ul>
<li>5.2.4: <a href=#pg-4b0e31c9e0eae68bbb0a358b4042ada9>アプリケーションの公開</a></li>
<ul>
<li>5.2.4.1: <a href=#pg-8ef4dad8f743b191a9e8c6f891cb191a>Serviceを使ったアプリケーションの公開</a></li>
<li>5.2.4.2: <a href=#pg-352241d22effe0714772d21c7d1b512d>対話型チュートリアル - アプリケーションの公開</a></li>
</ul>
<li>5.2.5: <a href=#pg-be4996c93fb39c459a30b6669569d423>アプリケーションのスケーリング</a></li>
<ul>
<li>5.2.5.1: <a href=#pg-d1c15c9bd4f625adbc13149b1475287c>アプリケーションの複数インスタンスを実行</a></li>
<li>5.2.5.2: <a href=#pg-7bdb3fbaa1177ff5dfa3fe86bd35ef59>対話型チュートリアル - アプリケーションのスケーリング</a></li>
</ul>
<li>5.2.6: <a href=#pg-62b8b17dadfb55f1801cf8439e944e58>アプリケーションのアップデート</a></li>
<ul>
<li>5.2.6.1: <a href=#pg-12e04355145afad615ca3c38335ba019>ローリングアップデートの実行</a></li>
<li>5.2.6.2: <a href=#pg-dddc0cb356c280e0339bcf42776987dc>対話型チュートリアル - アプリケーションのアップデート</a></li>
</ul>
</ul>
<li>5.3: <a href=#pg-a3a0f1c6af19fc89ce24d8cd42c0249f>設定</a></li>
<ul>
<li>5.3.1: <a href=#pg-2efe621cc085b350c8c4574e6f7f1311>ConfigMapを使ったRedisの設定</a></li>
</ul>
<li>5.4: <a href=#pg-1efbbc2c3015389f835b1661d5effb29>ステートレスアプリケーション</a></li>
<ul>
<li>5.4.1: <a href=#pg-62caf420877232190a7404b8d93c6724>クラスター内のアプリケーションにアクセスするために外部IPアドレスを公開する</a></li>
<li>5.4.2: <a href=#pg-8c56795c6614cc5f52434ecc756448ac>例: Redisを使用したPHPのゲストブックアプリケーションのデプロイ</a></li>
<li>5.4.3: <a href=#pg-ed6259076813e1eeeda484708812055b>例: PHP / Redisを使用したゲストブックの例にロギングとメトリクスを追加する</a></li>
</ul>
<li>5.5: <a href=#pg-d6336d9712aa433eb5f0fb8cbed6bef7>ステートフルアプリケーション</a></li>
<ul>
<li>5.5.1: <a href=#pg-42e39658021b706bcc9478c8cc73c4a3>StatefulSetの基本</a></li>
<li>5.5.2: <a href=#pg-27580b3f65f3c2da07fc0f83be69da75>例: Persistent Volumeを使用したWordpressとMySQLをデプロイする</a></li>
<li>5.5.3: <a href=#pg-bf0d8e08fddd6e0282709b9fef8b5f67>例: StatefulSetを使用したCassandraのデプロイ</a></li>
</ul>
<li>5.6: <a href=#pg-1ea281893eade34904c0cbd26b4228cb>クラスター</a></li>
<ul>
<li>5.6.1: <a href=#pg-18353c97948b94e2272afa0f11a58bec>AppArmorを使用してコンテナのリソースへのアクセスを制限する</a></li>
</ul>
<li>5.7: <a href=#pg-97489f0aa8ac2df31a0d6b444a7bde62>Service</a></li>
<ul>
<li>5.7.1: <a href=#pg-5642e8c51749e4fe2e6a2ccc207f1fab>送信元IPを使用する</a></li>
</ul>
</ul>
<li>6: <a href=#pg-b00a88a07ceb21b1a83e5822e0c86c1d>リファレンス</a></li>
<ul>
<li>6.1: <a href=#pg-2b03679960950df772fb4fe7d78427b9>標準化用語集</a></li>
<li>6.2: <a href=#pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b>認証</a></li>
<li>6.3: <a href=#pg-5bbbc5163b35431b3bff029ab9ec57d3>セットアップツールのリファレンス</a></li>
<ul>
<li>6.3.1: <a href=#pg-f351ced098abbb076bc8c4be1053672b>Kubeadm</a></li>
<ul>
</ul>
</ul>
<li>6.4: <a href=#pg-03460a7254c6c73eb2a1bb3dd7d25910>kubectl CLI</a></li>
<ul>
<li>6.4.1: <a href=#pg-f14fe15ecc2d41b5e901ef5e872ca657>kubectlの概要</a></li>
<li>6.4.2: <a href=#pg-a938176c695852fe70362c29cf615f1c>JSONPathのサポート</a></li>
<li>6.4.3: <a href=#pg-8aba901ac13f124e5782b90ddb166ee2>kubectlチートシート</a></li>
</ul>
<li>6.5: <a href=#pg-54e562dd1441d0195970a6526b0055cc>コマンドラインツールのリファレンス</a></li>
<ul>
<li>6.5.1: <a href=#pg-ca5d01a42c486d535539d3038aa67eb9>フィーチャーゲート</a></li>
<li>6.5.2: <a href=#pg-1715b765e2ff39feffd103d59ec0ef07>Kubelet 認証/認可</a></li>
</ul>
<li>6.6: <a href=#pg-954776b47f2d90515f375623a0ce98e1>RBAC認可を使用する</a></li>
<li>6.7: <a href=#pg-4f002b9458521ca7afd32176fd590646>ツール</a></li>
</ul>
<li>7: <a href=#pg-4985cb55ddfb184639d767ec54b9f0f7>K8sのドキュメントに貢献する</a></li>
<ul>
<li>7.1: <a href=#pg-e5340359b8afe1fe409af06178af8886>コンテンツの改善を提案する</a></li>
<li>7.2: <a href=#pg-e937703be4ed0c81ebac5c90d296644f>新しいコンテンツの貢献</a></li>
<ul>
<li>7.2.1: <a href=#pg-15909b651921a0531bcfb705012b0d3e>新しいコンテンツの貢献の概要</a></li>
</ul>
<li>7.3: <a href=#pg-7667825f238ad55850e95e02d21e9772>変更のレビュー</a></li>
<ul>
<li>7.3.1: <a href=#pg-bf4cdc925c4f306d4dc42184255aab58>プルリクエストのレビュー</a></li>
<li>7.3.2: <a href=#pg-5f7b891275b826a0a9dc82836542a607>approverとreviewer向けのレビュー</a></li>
</ul>
<li>7.4: <a href=#pg-8b9b22280711800788333c1a4d129735>SIG Docsへの参加</a></li>
<ul>
</ul>
<li>7.5: <a href=#pg-a2d946282df02cdeb47d9f54dfef198e>ドキュメントスタイルの概要</a></li>
<ul>
<li>7.5.1: <a href=#pg-3b9549b1c8f5ef9d6ae0a841cc99c180>ドキュメントコンテンツガイド</a></li>
<li>7.5.2: <a href=#pg-357f2ddd61035f18c2aa63fe86203f9c>コンテンツの構造化</a></li>
</ul>
<li>7.6: <a href=#pg-849a2fdb87779db1c212fe5a9f88ff0d>Kubernetesのドキュメントを翻訳する</a></li>
</ul>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-e735cee7e913aa88bc0aa10594d12966>1 - Kubernetesドキュメント</h1>
<div class=lead>Kubernetesは、コンテナ化されたアプリケーションの展開、スケーリング、また管理を自動化するためのオープンソースコンテナプラットフォームです。このオープンソースプロジェクトは、Cloud Native Computing Foundationによってホストされています。</div>
</div>
<div class=td-content>
<h1 id=pg-92dfff0ca612d0bff40171aa9df6c4ae>1.1 - 利用可能なドキュメントバージョン</h1>
<p>本ウェブサイトには、現行版とその直前4バージョンのKubernetesドキュメントがあります。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-66b565805ca1061be35ff2c0165f13c1>2 - はじめに</h1>
<p>このセクションではKubernetesをセットアップして動かすための複数のやり方について説明します。
Kubernetesをインストールする際には、メンテナンスの容易さ、セキュリティ、制御、利用可能なリソース、クラスターの運用及び管理に必要な専門知識に基づいてインストレーションタイプを選んでください。</p>
<p>Kubernetesクラスタはローカルマシン、クラウド、オンプレのデータセンターにデプロイすることもできますし、マネージドのKubernetesクラスターを選択することもできます。複数のクラウドプロバイダーやベアメタルの環境に跨ったカスタムソリューションもあります。</p>
<h2 id=環境について学ぶ>環境について学ぶ</h2>
<p>Kubernetesについて学んでいる場合、Kubernetesコミュニティにサポートされているツールや、Kubernetesクラスターをローカルマシンにセットアップするエコシステム内のツールを使いましょう。</p>
<h2 id=本番環境>本番環境</h2>
<p>本番環境用のソリューションを評価する際には、Kubernetesクラスター(または抽象レイヤ)の運用においてどの部分を自分で管理し、どの部分をプロバイダーに任せるのかを考慮してください。</p>
<p><a href=https://github.com/cncf/k8s-conformance/#certified-kubernetes>Certified Kubernetes</a>プロバイダーの一覧については、<a href=https://kubernetes.io/ja/partners/#conformance>Kubernetes パートナー</a>を参照してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d33663ac044e1981b406949f9124cc04>2.1 - リリースノートおよびバージョンスキュー</h1>
</div>
<div class=td-content>
<h1 id=pg-85b7e96ac42e5e28ec570ad43f0ef5cd>2.1.1 - Kubernetesバージョンとバージョンスキューサポートポリシー</h1>
<p>このドキュメントでは、さまざまなKubernetesコンポーネント間でサポートされる最大のバージョンの差異(バージョンスキュー)について説明します。特定のクラスターデプロイツールは、バージョンの差異に追加の制限を加える場合があります。</p>
<h2 id=supported-versions>サポートされるバージョン</h2>
<p>Kubernetesのバージョンは<strong>x.y.z</strong>の形式で表現され、<strong>x</strong>はメジャーバージョン、<strong>y</strong>はマイナーバージョン、<strong>z</strong>はパッチバージョンを指します。これは<a href=https://semver.org/>セマンティック バージョニング</a>に従っています。詳細は、<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/release/versioning.md#kubernetes-release-versioning>Kubernetesのリリースバージョニング</a>を参照してください。</p>
<p>Kubernetesプロジェクトでは、最新の3つのマイナーリリースについてリリースブランチを管理しています (1.26, 1.25, 1.24)。</p>
<p>セキュリティフィックスを含む適用可能な修正は、重大度や実行可能性によってはこれら3つのリリースブランチにバックポートされることもあります。パッチリリースは、これらのブランチから <a href=https://git.k8s.io/sig-release/releases/patch-releases.md#cadence>定期的に</a> 切り出され、必要に応じて追加の緊急リリースも行われます。</p>
<p><a href=https://git.k8s.io/sig-release/release-managers.md>リリースマネージャー</a>グループがこれを決定しています。</p>
<p>詳細は、<a href=https://github.com/kubernetes/sig-release/blob/master/releases/patch-releases.md>Kubernetesパッチリリース</a>ページを参照してください。</p>
<h2 id=サポートされるバージョンの差異>サポートされるバージョンの差異</h2>
<h3 id=kube-apiserver>kube-apiserver</h3>
<p><a href=/ja/docs/setup/production-environment/tools/independent/high-availability/>高可用性 (HA) クラスター</a>では、最新および最古の<code>kube-apiserver</code>インスタンスがそれぞれ1つのマイナーバージョン内でなければなりません。</p>
<p>例:</p>
<ul>
<li>最新の<code>kube-apiserver</code>が<strong>1.26</strong>であるとします</li>
<li>ほかの<code>kube-apiserver</code>インスタンスは<strong>1.26</strong>および<strong>1.25</strong>がサポートされます</li>
</ul>
<h3 id=kubelet>kubelet</h3>
<p><code>kubelet</code>は<code>kube-apiserver</code>より新しいものであってはならず、2つの古いマイナーバージョンまで有効です。</p>
<p>例:</p>
<ul>
<li><code>kube-apiserver</code>が<strong>1.26</strong>であるとします</li>
<li><code>kubelet</code>は<strong>1.26</strong>、<strong>1.25</strong>および<strong>1.24</strong>がサポートされます</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> HAクラスター内の<code>kube-apiserver</code>間にバージョンの差異がある場合、有効な<code>kubelet</code>のバージョンは少なくなります。
</div>
<p>例:</p>
<ul>
<li><code>kube-apiserver</code>インスタンスが<strong>1.26</strong>および<strong>1.12</strong>であるとします</li>
<li><code>kubelet</code>は<strong>1.25</strong>および<strong>1.24</strong>がサポートされます（<strong>1.26</strong>はバージョン<strong>1.25</strong>の<code>kube-apiserver</code>よりも新しくなるためサポートされません)</li>
</ul>
<h3 id=kube-controller-manager-kube-scheduler-およびcloud-controller-manager>kube-controller-manager、kube-scheduler、およびcloud-controller-manager</h3>
<p><code>kube-controller-manager</code>、<code>kube-scheduler</code>および<code>cloud-controller-manager</code>は、通信する<code>kube-apiserver</code>インスタンスよりも新しいバージョンであってはなりません。<code>kube-apiserver</code>のマイナーバージョンと一致することが期待されますが、1つ古いマイナーバージョンでも可能です(ライブアップグレードを可能にするため)。</p>
<p>例:</p>
<ul>
<li><code>kube-apiserver</code>が<strong>1.26</strong>であるとします</li>
<li><code>kube-controller-manager</code>、<code>kube-scheduler</code>および<code>cloud-controller-manager</code>は<strong>1.26</strong>および<strong>1.25</strong>がサポートされます</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> HAクラスター内の<code>kube-apiserver</code>間にバージョンの差異があり、これらのコンポーネントがクラスター内のいずれかの<code>kube-apiserver</code>と通信する場合(たとえばロードバランサーを経由して)、コンポーネントの有効なバージョンは少なくなります。
</div>
<p>例:</p>
<ul>
<li><code>kube-apiserver</code>インスタンスが<strong>1.26</strong>および<strong>1.25</strong>であるとします</li>
<li>いずれかの<code>kube-apiserver</code>インスタンスへ配信するロードバランサーと通信する<code>kube-controller-manager</code>、<code>kube-scheduler</code>および<code>cloud-controller-manager</code>は<strong>1.25</strong>がサポートされます(<strong>1.26</strong>はバージョン<strong>1.25</strong>の<code>kube-apiserver</code>よりも新しくなるためサポートされません)</li>
</ul>
<h3 id=kubectl>kubectl</h3>
<p><code>kubectl</code>は<code>kube-apiserver</code>の1つ以内のバージョン(古い、または新しいもの)をサポートします。</p>
<p>例:</p>
<ul>
<li><code>kube-apiserver</code>が<strong>1.26</strong>であるとします</li>
<li><code>kubectl</code>は<strong>1.27</strong>、<strong>1.26</strong>および<strong>1.25</strong>がサポートされます</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> HAクラスター内の<code>kube-apiserver</code>間にバージョンの差異がある場合、有効な<code>kubectl</code>バージョンは少なくなります。
</div>
<p>例:</p>
<ul>
<li><code>kube-apiserver</code>インスタンスが<strong>1.26</strong>および<strong>1.25</strong>であるとします</li>
<li><code>kubectl</code>は<strong>1.26</strong>および<strong>1.25</strong>がサポートされます(ほかのバージョンでは、ある<code>kube-apiserver</code>コンポーネントからマイナーバージョンが2つ以上離れる可能性があります)</li>
</ul>
<h2 id=サポートされるコンポーネントのアップグレード順序>サポートされるコンポーネントのアップグレード順序</h2>
<p>コンポーネント間でサポートされるバージョンの差異は、コンポーネントをアップグレードする順序に影響されます。このセクションでは、既存のクラスターをバージョン<strong>1.25</strong>から<strong>1.26</strong> へ移行するために、コンポーネントをアップグレードする順序を説明します。</p>
<h3 id=kube-apiserver-1>kube-apiserver</h3>
<p>前提条件:</p>
<ul>
<li>シングルインスタンスのクラスターにおいて、既存の<code>kube-apiserver</code>インスタンスは<strong>1.25</strong>とします</li>
<li>HAクラスターにおいて、既存の<code>kube-apiserver</code>は<strong>1.25</strong>または<strong>1.26</strong> とします(最新と最古の間で、最大で1つのマイナーバージョンの差異となります)</li>
<li>サーバーと通信する<code>kube-controller-manager</code>、<code>kube-scheduler</code>および<code>cloud-controller-manager</code>はバージョン<strong>1.25</strong>とします(必ず既存のAPIサーバーのバージョンよりも新しいものでなく、かつ新しいAPIサーバーのバージョンの1つ以内のマイナーバージョンとなります)</li>
<li>すべてのノードの<code>kubelet</code>インスタンスはバージョン<strong>1.25</strong>または<strong>1.24</strong> とします(必ず既存のAPIサーバーよりも新しいバージョンでなく、かつ新しいAPIサーバーのバージョンの2つ以内のマイナーバージョンとなります)</li>
<li>登録されたAdmission webhookは、新しい<code>kube-apiserver</code>インスタンスが送信するこれらのデータを扱うことができます:
<ul>
<li><code>ValidatingWebhookConfiguration</code>および<code>MutatingWebhookConfiguration</code>オブジェクトは、<strong>1.26</strong> で追加されたRESTリソースの新しいバージョンを含んで更新されます(または、v1.15から利用可能な<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#matching-requests-matchpolicy><code>matchPolicy: Equivalent</code>オプション</a>を使用してください)</li>
<li>Webhookは送信されたRESTリソースの新しいバージョン、および<strong>1.26</strong> のバージョンで追加された新しいフィールドを扱うことができます</li>
</ul>
</li>
</ul>
<p><code>kube-apiserver</code>を<strong>1.26</strong> にアップグレードしてください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <a href=/docs/reference/using-api/deprecation-policy/>非推奨API</a>および<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api_changes.md>APIの変更ガイドライン</a>のプロジェクトポリシーにおいては、シングルインスタンスの場合でも<code>kube-apiserver</code>のアップグレードの際にマイナーバージョンをスキップしてはなりません。
</div>
<h3 id=kube-controller-manager-kube-scheduler-およびcloud-controller-manager-1>kube-controller-manager、kube-scheduler、およびcloud-controller-manager</h3>
<p>前提条件:</p>
<ul>
<li>これらのコンポーネントと通信する<code>kube-apiserver</code>インスタンスが<strong>1.26</strong> であること(これらのコントロールプレーンコンポーネントが、クラスター内の<code>kube-apiserver</code>インスタンスと通信できるHAクラスターでは、これらのコンポーネントをアップグレードする前にすべての<code>kube-apiserver</code>インスタンスをアップグレードしなければなりません)</li>
</ul>
<p><code>kube-controller-manager</code>、<code>kube-scheduler</code>および<code>cloud-controller-manager</code>を<strong>1.26</strong> にアップグレードしてください。</p>
<h3 id=kubelet-1>kubelet</h3>
<p>前提条件:</p>
<ul>
<li><code>kubelet</code>と通信する<code>kube-apiserver</code>が<strong>1.26</strong> であること</li>
</ul>
<p>必要に応じて、<code>kubelet</code>インスタンスを<strong>1.26</strong> にアップグレードしてください(<strong>1.25</strong>や<strong>1.24</strong> のままにすることもできます)。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> <p><code>kube-apiserver</code>と2つのマイナーバージョンの<code>kubelet</code>インスタンスを使用してクラスターを実行させることは推奨されません:</p>
<ul>
<li>コントロールプレーンをアップグレードする前に、インスタンスを<code>kube-apiserver</code>の1つのマイナーバージョン内にアップグレードさせる必要があります</li>
<li>メンテナンスされている3つのマイナーリリースよりも古いバージョンの<code>kubelet</code>を実行する可能性が高まります</li>
</ul>
</div>
<h3 id=kube-proxy>kube-proxy</h3>
<ul>
<li><code>kube-proxy</code>のマイナーバージョンはノード上の<code>kubelet</code>と同じマイナーバージョンでなければなりません</li>
<li><code>kube-proxy</code>は<code>kube-apiserver</code>よりも新しいものであってはなりません</li>
<li><code>kube-proxy</code>のマイナーバージョンは<code>kube-apiserver</code>のマイナーバージョンよりも2つ以上古いものでなければなりません</li>
</ul>
<p>例:</p>
<p><code>kube-proxy</code>のバージョンが<strong>1.24</strong>の場合:</p>
<ul>
<li><code>kubelet</code>のバージョンは<strong>1.24</strong>でなければなりません</li>
<li><code>kube-apiserver</code>のバージョンは<strong>1.24</strong>と<strong>1.26</strong>の間でなければなりません</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0b597086a9d1382f86abadcfeab657d6>2.2 - 学習環境</h1>
</div>
<div class=td-content>
<h1 id=pg-8b996bf57bd8e67340235da1a1fb8e95>2.2.1 - Minikubeを使用してローカル環境でKubernetesを動かす</h1>
<p>Minikubeはローカル環境でKubernetesを簡単に実行するためのツールです。Kubernetesを試したり日々の開発への使用を検討するユーザー向けに、PC上のVM内でシングルノードのKubernetesクラスタを実行することができます。</p>
<h2 id=minikubeの機能>Minikubeの機能</h2>
<p>MinikubeのサポートするKubernetesの機能:</p>
<ul>
<li>DNS</li>
<li>NodePort</li>
<li>ConfigMapとSecret</li>
<li>ダッシュボード</li>
<li>コンテナランタイム: Docker、<a href=https://cri-o.io/>CRI-O</a>および<a href=https://github.com/containerd/containerd>containerd</a></li>
<li>CNI (Container Network Interface) の有効化</li>
<li>Ingress</li>
</ul>
<h2 id=インストール>インストール</h2>
<p>ツールのインストールについて知りたい場合は、公式の<a href=https://minikube.sigs.k8s.io/docs/start/>Get Started!</a>のガイドに従ってください。</p>
<h2 id=クイックスタート>クイックスタート</h2>
<p>これはMinikubeの起動、使用、削除をローカルで実施する簡単なデモです。下記の手順に従って、Minikubeを起動し試してください。</p>
<ol>
<li>
<p>Minikubeを起動し、クラスターを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube start
</code></pre></div><p>出力はこのようになります:</p>
<pre><code>Starting local Kubernetes cluster...
Running pre-create checks...
Creating machine...
Starting local Kubernetes cluster...
</code></pre><p>特定のKubernetesのバージョン、VM、コンテナランタイム上でクラスターを起動するための詳細は、<a href=#starting-a-cluster>クラスターの起動</a>を参照してください。</p>
</li>
<li>
<p>kubectlを使用してクラスターと対話できるようになります。詳細は<a href=#interacting-with-your-cluster>クラスターに触れてみよう</a>を参照してください。</p>
<p>単純なHTTPサーバーである<code>echoserver</code>という既存のイメージを使用して、Kubernetes Deploymentを作りましょう。そして<code>--port</code>を使用して8080番ポートで公開しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment hello-minikube --image<span style=color:#666>=</span>k8s.gcr.io/echoserver:1.10
</code></pre></div><p>出力はこのようになります:</p>
<pre><code>deployment.apps/hello-minikube created
</code></pre></li>
<li>
<p><code>hello-minikube</code>Deploymentに接続するために、Serviceとして公開します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment hello-minikube --type<span style=color:#666>=</span>NodePort --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</code></pre></div><p><code>--type=NodePort</code>オプションで、Serviceのタイプを指定します。</p>
<p>出力はこのようになります:</p>
<pre><code>service/hello-minikube exposed
</code></pre></li>
<li>
<p><code>hello-minikube</code>Podが起動開始されましたが、公開したService経由で接続する前にPodが起動完了になるまで待つ必要があります。</p>
<p>Podが稼働しているか確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod
</code></pre></div><p><code>STATUS</code>に<code>ContainerCreating</code>と表示されている場合、Podはまだ作成中です:</p>
<pre><code>NAME                              READY     STATUS              RESTARTS   AGE
hello-minikube-3383150820-vctvh   0/1       ContainerCreating   0          3s
</code></pre><p><code>STATUS</code>に<code>Running</code>と表示されている場合、Podは稼働中です:</p>
<pre><code>NAME                              READY     STATUS    RESTARTS   AGE
hello-minikube-3383150820-vctvh   1/1       Running   0          13s
</code></pre></li>
<li>
<p>Serviceの詳細を確認するため、公開したServiceのURLを取得します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube service hello-minikube --url
</code></pre></div></li>
<li>
<p>ローカル環境のクラスターについて詳細を確認するには、出力から得たURLをブラウザー上でコピーアンドペーストしてください。</p>
<p>出力はこのようになります:</p>
<pre><code>Hostname: hello-minikube-7c77b68cff-8wdzq

Pod Information:
 -no pod information available-

Server values:
 server_version=nginx: 1.13.3 - lua: 10008

Request Information:
 client_address=172.17.0.1
 method=GET
 real path=/
 query=
 request_version=1.1
 request_scheme=http
 request_uri=http://192.168.99.100:8080/

Request Headers:
	accept=*/*
	host=192.168.99.100:30674
	user-agent=curl/7.47.0

Request Body:
	-no body in request-
</code></pre><p>Serviceやクラスターをこれ以上稼働させない場合、削除する事ができます。</p>
</li>
<li>
<p><code>hello-minikube</code>Serviceを削除します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete services hello-minikube
</code></pre></div><p>出力はこのようになります:</p>
<pre><code>service &quot;hello-minikube&quot; deleted
</code></pre></li>
<li>
<p><code>hello-minikube</code>Deploymentを削除します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment hello-minikube
</code></pre></div><p>出力はこのようになります:</p>
<pre><code>deployment.extensions &quot;hello-minikube&quot; deleted
</code></pre></li>
<li>
<p>ローカル環境のMinikubeクラスターを停止します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube stop
</code></pre></div><p>出力はこのようになります:</p>
<pre><code>Stopping &quot;minikube&quot;...
&quot;minikube&quot; stopped.
</code></pre><p>詳細は<a href=#stopping-a-cluster>クラスターの停止</a>を参照ください。</p>
</li>
<li>
<p>ローカルのMinikubeクラスターを削除します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube delete
</code></pre></div><p>出力はこのようになります:</p>
<pre><code>Deleting &quot;minikube&quot; ...
The &quot;minikube&quot; cluster has been deleted.
</code></pre><p>詳細は<a href=#deleting-a-cluster>クラスターの削除</a>を参照ください。</p>
</li>
</ol>
<h2 id=クラスターの管理>クラスターの管理</h2>
<h3 id=starting-a-cluster>クラスターの起動</h3>
<p><code>minikube start</code>コマンドを使用してクラスターを起動することができます。
このコマンドはシングルノードのKubernetesクラスターを実行する仮想マシンを作成・設定します。
また、このクラスターと通信する<a href=/ja/docs/reference/kubectl/overview/>kubectl</a>のインストールも設定します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>もしWebプロキシーを通している場合、そのプロキシー情報を<code>minikube start</code>コマンドに渡す必要があります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>https_proxy</span><span style=color:#666>=</span>&lt;my proxy&gt; minikube start --docker-env <span style=color:#b8860b>http_proxy</span><span style=color:#666>=</span>&lt;my proxy&gt; --docker-env <span style=color:#b8860b>https_proxy</span><span style=color:#666>=</span>&lt;my proxy&gt; --docker-env <span style=color:#b8860b>no_proxy</span><span style=color:#666>=</span>192.168.99.0/24
</code></pre></div><p>残念なことに、ただ環境変数を設定するだけではうまく動作しません。</p>
<p>Minikubeは"minikube"コンテキストも作成し、そのコンテキストをデフォルト設定としてkubectlに設定します。
あとでコンテキストを切り戻すには、このコマンドを実行してください: <code>kubectl config use-context minikube</code></p>
</div>
<h4 id=kubernetesバージョンの指定>Kubernetesバージョンの指定</h4>
<p><code>minikube start</code>コマンドに<code>--kubernetes-version</code>文字列を追加することで、
MinikubeにKubernetesの特定のバージョンを指定することができます。
例えば、v1.22.16のバージョンを実行するには以下を実行します:</p>
<pre><code>minikube start --kubernetes-version v1.22.16
</code></pre><h4 id=vmドライバーの指定>VMドライバーの指定</h4>
<p>もしVMドライバーを変更したい場合は、<code>--driver=&lt;enter_driver_name></code>フラグを<code>minikube start</code>に設定してください。例えば、コマンドは以下のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube start --driver<span style=color:#666>=</span>&lt;driver_name&gt;
</code></pre></div><p>Minikubeは以下のドライバーをサポートしています:
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> サポートされているドライバーとプラグインのインストールの詳細については<a href=https://minikube.sigs.k8s.io/docs/reference/drivers/>DRIVERS</a>を参照してください。
</div></p>
<ul>
<li>docker (<a href=https://minikube.sigs.k8s.io/docs/drivers/docker/>driver installation</a>)</li>
<li>virtualbox (<a href=https://minikube.sigs.k8s.io/docs/drivers/virtualbox/>driver installation</a>)</li>
<li>podman (<a href=https://minikube.sigs.k8s.io/docs/drivers/podman/>driver installation</a>) (実験的)</li>
<li>vmwarefusion</li>
<li>kvm2 (<a href=https://minikube.sigs.k8s.io/docs/reference/drivers/kvm2/>driver installation</a>)</li>
<li>hyperkit (<a href=https://minikube.sigs.k8s.io/docs/reference/drivers/hyperkit/>driver installation</a>)</li>
<li>hyperv (<a href=https://minikube.sigs.k8s.io/docs/reference/drivers/hyperv/>driver installation</a>)
注意: 以下のIPは動的であり、変更される可能性があります。IPは<code>minikube ip</code>で取得することができます。</li>
<li>vmware (<a href=https://minikube.sigs.k8s.io/docs/reference/drivers/vmware/>driver installation</a>) (VMware unified driver)</li>
<li>parallels (<a href=https://minikube.sigs.k8s.io/docs/reference/drivers/parallels/>driver installation</a>)</li>
<li>none (VMではなくホスト上でKubernetesコンポーネントを起動。このドライバーを使用するには<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>とLinux環境を必要とします)</li>
</ul>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <code>none</code>ドライバーを使用する場合、一部のKubernetesのコンポーネントは特権付きのコンテナとして稼働するため、Minikube環境外に副作用をもたらします。
この副作用から、<code>none</code>ドライバーは、個人の作業環境では推奨されません。
</div>
<h3 id=コンテナランタイムの代替>コンテナランタイムの代替</h3>
<p>下記のコンテナランタイム上でMinikubeを起動できます。</p>
<ul class="nav nav-tabs" id=container-runtimes role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#container-runtimes-0 role=tab aria-controls=container-runtimes-0 aria-selected=true>containerd</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#container-runtimes-1 role=tab aria-controls=container-runtimes-1>CRI-O</a></li></ul>
<div class=tab-content id=container-runtimes><div id=container-runtimes-0 class="tab-pane show active" role=tabpanel aria-labelledby=container-runtimes-0>
<p><p><a href=https://github.com/containerd/containerd>containerd</a> をコンテナランタイムとして使用するには以下を実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>minikube start <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --network-plugin<span style=color:#666>=</span>cni <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --enable-default-cni <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --container-runtime<span style=color:#666>=</span>containerd <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --bootstrapper<span style=color:#666>=</span>kubeadm
</code></pre></div><p>もしくは拡張バージョンを使用することもできます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>minikube start <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --network-plugin<span style=color:#666>=</span>cni <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --enable-default-cni <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --extra-config<span style=color:#666>=</span>kubelet.container-runtime<span style=color:#666>=</span>remote <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --extra-config<span style=color:#666>=</span>kubelet.container-runtime-endpoint<span style=color:#666>=</span>unix:///run/containerd/containerd.sock <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --extra-config<span style=color:#666>=</span>kubelet.image-service-endpoint<span style=color:#666>=</span>unix:///run/containerd/containerd.sock <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --bootstrapper<span style=color:#666>=</span>kubeadm
</code></pre></div></div>
<div id=container-runtimes-1 class=tab-pane role=tabpanel aria-labelledby=container-runtimes-1>
<p><p><a href=https://cri-o.io/>CRI-O</a>をコンテナランタイムとして使用するには以下を実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>minikube start <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --network-plugin<span style=color:#666>=</span>cni <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --enable-default-cni <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --container-runtime<span style=color:#666>=</span>cri-o <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --bootstrapper<span style=color:#666>=</span>kubeadm
</code></pre></div><p>もしくは拡張バージョンを使用することもできます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>minikube start <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --network-plugin<span style=color:#666>=</span>cni <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --enable-default-cni <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --extra-config<span style=color:#666>=</span>kubelet.container-runtime<span style=color:#666>=</span>remote <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --extra-config<span style=color:#666>=</span>kubelet.container-runtime-endpoint<span style=color:#666>=</span>/var/run/crio.sock <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --extra-config<span style=color:#666>=</span>kubelet.image-service-endpoint<span style=color:#666>=</span>/var/run/crio.sock <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --bootstrapper<span style=color:#666>=</span>kubeadm
</code></pre></div></div></div>
<h3 id=dockerデーモンの再利用によるローカルイメージの使用>Dockerデーモンの再利用によるローカルイメージの使用</h3>
<p>Kubernetesの単一のVMを使用する場合、Minikube組み込みのDockerデーモンの再利用がおすすめです。ホストマシン上にDockerレジストリを構築してイメージをプッシュする必要がなく、ローカルでの実験を加速させるMinikubeと同じDockerデーモンの中に構築することができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Dockerイメージに'latest'以外のタグを付け、そのタグを使用してイメージをプルしてください。イメージのバージョンを指定しなければ<code>Always</code>のプルイメージポリシーにより<code>:latest</code>と仮定され、もしデフォルトのDockerレジストリ(通常はDockerHub)にどのバージョンのDockerイメージもまだ存在しない場合には、<code>ErrImagePull</code>になる恐れがあります。
</div>
<p>Mac/LinuxのホストでDockerデーモンを操作できるようにするには、<code>minikube docker-env</code>を実行します。</p>
<p>これにより、MinikubeのVM内のDockerデーモンと通信しているホストのMac/LinuxマシンのコマンドラインでDockerを使用できるようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>docker ps
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>CentOS 7では、Dockerが以下のエラーを出力することがあります:</p>
<pre><code>Could not read CA certificate &quot;/etc/docker/ca.pem&quot;: open /etc/docker/ca.pem: no such file or directory
</code></pre><p>修正方法としては、/etc/sysconfig/dockerを更新してMinikube環境の変更が確実に反映されるようにすることです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&lt; <span style=color:#b8860b>DOCKER_CERT_PATH</span><span style=color:#666>=</span>/etc/docker
---
&gt; <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>[</span> -z <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>DOCKER_CERT_PATH</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span> <span style=color:#666>]</span>; <span style=color:#a2f;font-weight:700>then</span>
&gt;   <span style=color:#b8860b>DOCKER_CERT_PATH</span><span style=color:#666>=</span>/etc/docker
&gt; <span style=color:#a2f;font-weight:700>fi</span>
</code></pre></div>
</div>
<h3 id=kubernetesの設定>Kubernetesの設定</h3>
<p>Minikubeにはユーザーが任意の値でKubernetesコンポーネントを設定することを可能にする "configurator" 機能があります。
この機能を使うには、<code>minikube start</code> コマンドに <code>--extra-config</code> フラグを使うことができます。</p>
<p>このフラグは繰り返されるので、複数のオプションを設定するためにいくつかの異なる値を使って何度も渡すことができます。</p>
<p>このフラグは <code>component.key=value</code> 形式の文字列を取ります。<code>component</code> は下記のリストの文字列の1つです。
<code>key</code>は設定構造体上の値で、 <code>value</code> は設定する値です。</p>
<p>各コンポーネントのKubernetes <code>componentconfigs</code> のドキュメントを調べることで有効なキーを見つけることができます。
サポートされている各設定のドキュメントは次のとおりです:</p>
<ul>
<li><a href=https://godoc.org/k8s.io/kubernetes/pkg/kubelet/apis/config#KubeletConfiguration>kubelet</a></li>
<li><a href=https://godoc.org/k8s.io/kubernetes/cmd/kube-apiserver/app/options#ServerRunOptions>apiserver</a></li>
<li><a href=https://godoc.org/k8s.io/kubernetes/pkg/proxy/apis/config#KubeProxyConfiguration>proxy</a></li>
<li><a href=https://godoc.org/k8s.io/kubernetes/pkg/controller/apis/config#KubeControllerManagerConfiguration>controller-manager</a></li>
<li><a href=https://godoc.org/github.com/coreos/etcd/etcdserver#ServerConfig>etcd</a></li>
<li><a href=https://godoc.org/k8s.io/kubernetes/pkg/scheduler/apis/config#KubeSchedulerConfiguration>scheduler</a></li>
</ul>
<h4 id=例>例</h4>
<p>Kubeletの <code>MaxPods</code> 設定を5に変更するには、このフラグを渡します: <code>--extra-config=kubelet.MaxPods=5</code></p>
<p>この機能はネストした構造体もサポートします。スケジューラーの <code>LeaderElection.LeaderElect</code> を <code>true</code> に設定するには、このフラグを渡します: <code>--extra-config=scheduler.LeaderElection.LeaderElect=true</code></p>
<p><code>apiserver</code> の <code>AuthorizationMode</code> を <code>RABC</code> に設定するには、このフラグを使います: <code>--extra-config=apiserver.authorization-mode=RBAC</code>.</p>
<h3 id=stopping-a-cluster>クラスターの停止</h3>
<p><code>minikube stop</code> コマンドを使ってクラスターを停止することができます。
このコマンドはMinikube仮想マシンをシャットダウンしますが、すべてのクラスターの状態とデータを保存します。
クラスターを再起動すると、以前の状態に復元されます。</p>
<h3 id=deleting-a-cluster>クラスターの削除</h3>
<p><code>minikube delete</code> コマンドを使ってクラスターを削除することができます。
このコマンドはMinikube仮想マシンをシャットダウンして削除します。データや状態は保存されません。</p>
<h3 id=upgrading-minikube>minikubeのアップグレード</h3>
<p>macOSを使用し<a href=https://brew.sh/>Brew Package Manager</a>がインストールされている場合、以下を実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>brew update
brew upgrade minikube
</code></pre></div><h2 id=interacting-with-your-cluster>クラスターに触れてみよう</h2>
<h3 id=kubectl>Kubectl</h3>
<p><code>minikube start</code> コマンドは "minikube" という<a href=/docs/reference/generated/kubectl/kubectl-commands#-em-set-context-em->kubectl context</a>を作成します。
このコンテキストはMinikubeクラスターと通信するための設定が含まれています。</p>
<p>Minikubeはこのコンテキストを自動的にデフォルトに設定しますが、将来的に設定を切り戻す場合には次のコマンドを実行してください:</p>
<p><code>kubectl config use-context minikube</code></p>
<p>もしくは各コマンドにコンテキストを次のように渡します:</p>
<p><code>kubectl get pods --context=minikube</code></p>
<h3 id=ダッシュボード>ダッシュボード</h3>
<p><a href=/ja/docs/tasks/access-application-cluster/web-ui-dashboard/>Kubernetes Dashboard</a>にアクセスするには、Minikubeを起動してアドレスを取得した後、シェルでこのコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube dashboard
</code></pre></div><h3 id=サービス>サービス</h3>
<p>ノードポート経由で公開されているサービスにアクセスするには、Minikubeを起動してアドレスを取得した後、シェルでこのコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube service <span style=color:#666>[</span>-n NAMESPACE<span style=color:#666>]</span> <span style=color:#666>[</span>--url<span style=color:#666>]</span> NAME
</code></pre></div><h2 id=ネットワーク>ネットワーク</h2>
<p>MinikubeのVMは <code>minikube ip</code>コマンドで取得できるホストオンリーIPアドレスを介してホストシステムに公開されます。
NodePort上では、 <code>NodePort</code> タイプのどのサービスもそのIPアドレスを介してアクセスできます。</p>
<p>サービスのNodePortを決定するには、<code>kubectl</code> コマンドを次のように使用します:</p>
<p><code>kubectl get service $SERVICE --output='jsonpath="{.spec.ports[0].nodePort}"'</code></p>
<h2 id=永続ボリューム>永続ボリューム</h2>
<p>Minikubeは <code>hostPath</code> タイプの<a href=/docs/concepts/storage/persistent-volumes/>PersistentVolumes</a>をサポートします。
このPersistentVolumesはMinikubeのVM内のディレクトリーにマッピングされます。</p>
<p>MinikubeのVMはtmpfsで起動するため、ほとんどのディレクトリーは再起動しても持続しません (<code>minikube stop</code>)。
しかし、Minikubeは以下のホストディレクトリーに保存されているファイルを保持するように設定されています:</p>
<ul>
<li><code>/data</code></li>
<li><code>/var/lib/minikube</code></li>
<li><code>/var/lib/docker</code></li>
</ul>
<p>以下は <code>/data</code> ディレクトリのデータを永続化するPersistentVolumeの設定例です:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv0001<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/data/pv0001/<span style=color:#bbb>
</span></code></pre></div><h2 id=ホストフォルダーのマウント>ホストフォルダーのマウント</h2>
<p>一部のドライバーはVM内にホストフォルダーをマウントするため、VMとホストの間でファイルを簡単に共有できます。これらは現時点では設定可能ではなく、使用しているドライバーとOSによって異なります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ホストフォルダーの共有はKVMドライバーにはまだ実装されていません。
</div>
<table>
<thead>
<tr>
<th>Driver</th>
<th>OS</th>
<th>HostFolder</th>
<th>VM</th>
</tr>
</thead>
<tbody>
<tr>
<td>VirtualBox</td>
<td>Linux</td>
<td>/home</td>
<td>/hosthome</td>
</tr>
<tr>
<td>VirtualBox</td>
<td>macOS</td>
<td>/Users</td>
<td>/Users</td>
</tr>
<tr>
<td>VirtualBox</td>
<td>Windows</td>
<td>C://Users</td>
<td>/c/Users</td>
</tr>
<tr>
<td>VMware Fusion</td>
<td>macOS</td>
<td>/Users</td>
<td>/mnt/hgfs/Users</td>
</tr>
<tr>
<td>Xhyve</td>
<td>macOS</td>
<td>/Users</td>
<td>/Users</td>
</tr>
</tbody>
</table>
<h2 id=プライベートコンテナレジストリ>プライベートコンテナレジストリ</h2>
<p>プライベートコンテナレジストリにアクセスするには、<a href=/docs/concepts/containers/images/>このページ</a>の手順に従ってください。</p>
<p><code>ImagePullSecrets</code> を使用することをおすすめしますが、MinikubeのVM内でアクセス設定したい場合には、<code>/home/docker</code> ディレクトリに <code>.dockercfg</code> を置くか、または <code>/home/docker/.docker</code> ディレクトリに <code>config.json</code> を置いてください。</p>
<h2 id=アドオン>アドオン</h2>
<p>カスタムアドオンを正しく起動または再起動させるには、
Minikubeで起動したいアドオンを <code>~/.minikube/addons</code> ディレクトリに置きます。
このフォルダ内のアドオンはMinikubeのVMに移動され、Minikubeが起動または再起動されるたびにアドオンが起動されます。</p>
<h2 id=httpプロキシ経由のminikube利用>HTTPプロキシ経由のMinikube利用</h2>
<p>MinikubeはKubernetesとDockerデーモンを含む仮想マシンを作成します。
KubernetesがDockerを使用してコンテナをスケジュールしようとする際、Dockerデーモンはコンテナをプルするために外部ネットワークを必要とする場合があります。</p>
<p>HTTPプロキシーを通している場合には、プロキシー設定をDockerに提供する必要があります。
これを行うには、<code>minikube start</code> に必要な環境変数をフラグとして渡します。</p>
<p>例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube start --docker-env <span style=color:#b8860b>http_proxy</span><span style=color:#666>=</span>http://<span style=color:#b8860b>$YOURPROXY</span>:PORT <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>               --docker-env <span style=color:#b8860b>https_proxy</span><span style=color:#666>=</span>https://<span style=color:#b8860b>$YOURPROXY</span>:PORT
</code></pre></div><p>仮想マシンのアドレスが192.168.99.100の場合、プロキシーの設定により <code>kubectl</code> が直接アクセスできない可能性があります。
このIPアドレスのプロキシー設定を迂回するには、以下のようにno_proxy設定を変更する必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span> <span style=color:#b8860b>no_proxy</span><span style=color:#666>=</span><span style=color:#b8860b>$no_proxy</span>,<span style=color:#a2f;font-weight:700>$(</span>minikube ip<span style=color:#a2f;font-weight:700>)</span>
</code></pre></div><h2 id=既知の問題>既知の問題</h2>
<p>複数ノードを必要とする機能はMinikubeでは動作しません。</p>
<h2 id=設計>設計</h2>
<p>MinikubeはVMのプロビジョニングに<a href=https://github.com/docker/machine/tree/master/libmachine>libmachine</a>を使用し、<a href=https://github.com/kubernetes/kubeadm>kubeadm</a>をKubernetesクラスターのプロビジョニングに使用します。</p>
<p>Minikubeの詳細については、<a href=https://git.k8s.io/community/contributors/design-proposals/cluster-lifecycle/local-cluster-ux.md>proposal</a>を参照してください。</p>
<h2 id=追加リンク集>追加リンク集</h2>
<ul>
<li><strong>目標と非目標</strong>: Minikubeプロジェクトの目標と非目標については、<a href=https://minikube.sigs.k8s.io/docs/contrib/roadmap/>ロードマップ</a>を参照してください。</li>
<li><strong>開発ガイド</strong>: プルリクエストを送る方法の概要については、<a href=https://minikube.sigs.k8s.io/docs/contrib/>コントリビュートする</a>を参照してください。</li>
<li><strong>Minikubeのビルド</strong>: Minikubeをソースからビルド/テストする方法については、<a href=https://minikube.sigs.k8s.io/docs/contrib/building/>ビルドガイド</a>を参照してください。</li>
<li><strong>新しい依存性の追加</strong>: Minikubeに新しい依存性を追加する方法については、<a href=https://minikube.sigs.k8s.io/docs/contrib/drivers/>依存性追加ガイド</a>を参照してください。</li>
<li><strong>新しいアドオンの追加</strong>: Minikubeに新しいアドオンを追加する方法については、<a href=https://minikube.sigs.k8s.io/docs/contrib/addons/>アドオン追加ガイド</a>を参照してください。</li>
<li><strong>MicroK8s</strong>: 仮想マシンを実行したくないLinuxユーザーは代わりに<a href=https://microk8s.io/>MicroK8s</a>を検討してみてください。</li>
</ul>
<h2 id=コミュニティ>コミュニティ</h2>
<p>コントリビューションや質問、コメントは歓迎・奨励されています! Minikubeの開発者は<a href=https://kubernetes.slack.com>Slack</a>の<code>#minikube</code>チャンネルにいます(Slackへの招待状は<a href=http://slack.kubernetes.io/>こちら</a>)。<a href=https://groups.google.com/forum/#!forum/kubernetes-dev>kubernetes-dev Google Groupsメーリングリスト</a>もあります。メーリングリストに投稿する際は件名の最初に "minikube: " をつけてください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-861dedab439fb9a133b35009a34655ec>2.2.2 - Kindを使用してKubernetesをインストールする</h1>
<p>Kindは、Dockerコンテナをノードとして使用して、ローカルのKubernetesクラスターを実行するためのツールです。</p>
<h2 id=インストール>インストール</h2>
<p><a href=https://kind.sigs.k8s.io/docs/user/quick-start/>Kindをインストールする</a>を参照してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4e14853fdaa3bd273f31a60112b9b5ac>2.3 - プロダクション環境</h1>
</div>
<div class=td-content>
<h1 id=pg-a77d3feb6e6d9978f32fa14622642e9a>2.3.1 - CRIのインストール</h1>
<p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.6 [stable]</code>
</div>
Podのコンテナを実行するために、Kubernetesはコンテナランタイムを使用します。
様々なランタイムのインストール手順は次のとおりです。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <p>コンテナ実行時にruncがシステムファイルディスクリプターを扱える脆弱性が見つかりました。
悪意のあるコンテナがこの脆弱性を利用してruncのバイナリを上書きし、
コンテナホストシステム上で任意のコマンドを実行する可能性があります。</p>
<p>この問題の更なる情報は<a href=https://access.redhat.com/security/cve/cve-2019-5736>CVE-2019-5736</a>を参照してください。</p>
</div>
<h3 id=適用性>適用性</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このドキュメントはLinuxにCRIをインストールするユーザーのために書かれています。
他のオペレーティングシステムの場合、プラットフォーム固有のドキュメントを見つけてください。
</div>
<p>このガイドでは全てのコマンドを <code>root</code> で実行します。
例として、コマンドに <code>sudo</code> を付けたり、 <code>root</code> になってそのユーザーでコマンドを実行します。</p>
<h3 id=cgroupドライバー>Cgroupドライバー</h3>
<p>systemdがLinuxのディストリビューションのinitシステムとして選択されている場合、
initプロセスが作成され、rootコントロールグループ(<code>cgroup</code>)を使い、cgroupマネージャーとして行動します。
systemdはcgroupと密接に統合されており、プロセスごとにcgroupを割り当てます。
<code>cgroupfs</code> を使うように、あなたのコンテナランライムとkubeletを設定することができます。
systemdと一緒に <code>cgroupfs</code> を使用するということは、2つの異なるcgroupマネージャーがあることを意味します。</p>
<p>コントロールグループはプロセスに割り当てられるリソースを制御するために使用されます。
単一のcgroupマネージャーは、割り当てられているリソースのビューを単純化し、
デフォルトでは使用可能なリソースと使用中のリソースについてより一貫性のあるビューになります。
2つのマネージャーがある場合、それらのリソースについて2つのビューが得られます。
kubeletとDockerに <code>cgroupfs</code> を使用し、ノード上で実行されている残りのプロセスに <code>systemd</code> を使用するように設定されたノードが、
リソース圧迫下で不安定になる場合があります。</p>
<p>コンテナランタイムとkubeletがcgroupドライバーとしてsystemdを使用するように設定を変更することでシステムは安定します。
以下のDocker設定の <code>native.cgroupdriver=systemd</code> オプションに注意してください。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> すでにクラスターに組み込まれているノードのcgroupドライバーを変更することは非常におすすめしません。
kubeletが一方のcgroupドライバーを使用してPodを作成した場合、コンテナランタイムを別のもう一方のcgroupドライバーに変更すると、そのような既存のPodのPodサンドボックスを再作成しようとするとエラーが発生する可能性があります。
kubeletを再起動しても問題は解決しないでしょう。
ワークロードからノードを縮退させ、クラスターから削除して再び組み込むことを推奨します。
</div>
<h2 id=docker>Docker</h2>
<p>それぞれのマシンに対してDockerをインストールします。
バージョン19.03.11が推奨されていますが、1.13.1、17.03、17.06、17.09、18.06、18.09についても動作が確認されています。
Kubernetesのリリースノートにある、Dockerの動作確認済み最新バージョンについてもご確認ください。</p>
<p>システムへDockerをインストールするには、次のコマンドを実行します。</p>
<ul class="nav nav-tabs" id=tab-cri-docker-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-cri-docker-installation-0 role=tab aria-controls=tab-cri-docker-installation-0 aria-selected=true>Ubuntu 16.04+</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-docker-installation-1 role=tab aria-controls=tab-cri-docker-installation-1>CentOS/RHEL 7.4+</a></li></ul>
<div class=tab-content id=tab-cri-docker-installation><div id=tab-cri-docker-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-cri-docker-installation-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># (Install Docker CE)</span>
<span style=color:#080;font-style:italic>## リポジトリをセットアップ</span>
<span style=color:#080;font-style:italic>### HTTPS越しのリポジトリの使用をaptに許可するために、パッケージをインストール</span>
apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  apt-transport-https ca-certificates curl software-properties-common gnupg2
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Docker公式のGPG鍵を追加:</span>
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Dockerのaptレポジトリを追加:</span>
add-apt-repository <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#b44>&#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
</span><span style=color:#b44>  </span><span style=color:#a2f;font-weight:700>$(</span>lsb_release -cs<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44> \
</span><span style=color:#b44>  stable&#34;</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Docker CEのインストール</span>
apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>containerd.io<span style=color:#666>=</span>1.2.13-2 <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>docker-ce<span style=color:#666>=</span>5:19.03.11~3-0~ubuntu-<span style=color:#a2f;font-weight:700>$(</span>lsb_release -cs<span style=color:#a2f;font-weight:700>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>docker-ce-cli<span style=color:#666>=</span>5:19.03.11~3-0~ubuntu-<span style=color:#a2f;font-weight:700>$(</span>lsb_release -cs<span style=color:#a2f;font-weight:700>)</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># デーモンをセットアップ</span>
cat &gt; /etc/docker/daemon.json <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>{
</span><span style=color:#b44>  &#34;exec-opts&#34;: [&#34;native.cgroupdriver=systemd&#34;],
</span><span style=color:#b44>  &#34;log-driver&#34;: &#34;json-file&#34;,
</span><span style=color:#b44>  &#34;log-opts&#34;: {
</span><span style=color:#b44>    &#34;max-size&#34;: &#34;100m&#34;
</span><span style=color:#b44>  },
</span><span style=color:#b44>  &#34;storage-driver&#34;: &#34;overlay2&#34;
</span><span style=color:#b44>}
</span><span style=color:#b44>EOF</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>mkdir -p /etc/systemd/system/docker.service.d
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># dockerを再起動</span>
systemctl daemon-reload
systemctl restart docker
</code></pre></div></div>
<div id=tab-cri-docker-installation-1 class=tab-pane role=tabpanel aria-labelledby=tab-cri-docker-installation-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># (Docker CEのインストール)</span>
<span style=color:#080;font-style:italic>## リポジトリをセットアップ</span>
<span style=color:#080;font-style:italic>### 必要なパッケージのインストール</span>
yum install -y yum-utils device-mapper-persistent-data lvm2
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic>## Dockerリポジトリの追加</span>
yum-config-manager --add-repo <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  https://download.docker.com/linux/centos/docker-ce.repo
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic>## Docker CEのインストール</span>
yum update -y <span style=color:#666>&amp;&amp;</span> yum install -y <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  containerd.io-1.2.13 <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  docker-ce-19.03.11 <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  docker-ce-cli-19.03.11
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic>## /etc/docker ディレクトリを作成</span>
mkdir /etc/docker
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># デーモンをセットアップ</span>
cat &gt; /etc/docker/daemon.json <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>{
</span><span style=color:#b44>  &#34;exec-opts&#34;: [&#34;native.cgroupdriver=systemd&#34;],
</span><span style=color:#b44>  &#34;log-driver&#34;: &#34;json-file&#34;,
</span><span style=color:#b44>  &#34;log-opts&#34;: {
</span><span style=color:#b44>    &#34;max-size&#34;: &#34;100m&#34;
</span><span style=color:#b44>  },
</span><span style=color:#b44>  &#34;storage-driver&#34;: &#34;overlay2&#34;,
</span><span style=color:#b44>  &#34;storage-opts&#34;: [
</span><span style=color:#b44>    &#34;overlay2.override_kernel_check=true&#34;
</span><span style=color:#b44>  ]
</span><span style=color:#b44>}
</span><span style=color:#b44>EOF</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>mkdir -p /etc/systemd/system/docker.service.d
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># dockerを再起動</span>
systemctl daemon-reload
systemctl restart docker
</code></pre></div></div></div>
<p>ブート時にDockerサービスを開始させたい場合は、以下のコマンドを入力してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo systemctl <span style=color:#a2f>enable</span> docker
</code></pre></div><p>詳細については、<a href=https://docs.docker.com/engine/installation/>Dockerの公式インストールガイド</a>を参照してください。</p>
<h2 id=cri-o>CRI-O</h2>
<p>このセクションでは、CRIランタイムとして<code>CRI-O</code>を利用するために必要な手順について説明します。</p>
<p>システムへCRI-Oをインストールするためには以下のコマンドを利用します:</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> CRI-OのメジャーとマイナーバージョンはKubernetesのメジャーとマイナーバージョンと一致しなければなりません。
詳細は<a href=https://github.com/cri-o/cri-o>CRI-O互換性表</a>を参照してください。
</div>
<h3 id=事前準備>事前準備</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>modprobe overlay
modprobe br_netfilter

<span style=color:#080;font-style:italic># 必要なカーネルパラメータの設定をします。これらの設定値は再起動後も永続化されます。</span>
cat &gt; /etc/sysctl.d/99-kubernetes-cri.conf <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>net.bridge.bridge-nf-call-iptables  = 1
</span><span style=color:#b44>net.ipv4.ip_forward                 = 1
</span><span style=color:#b44>net.bridge.bridge-nf-call-ip6tables = 1
</span><span style=color:#b44>EOF</span>

sysctl --system
</code></pre></div><ul class="nav nav-tabs" id=tab-cri-cri-o-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-cri-cri-o-installation-0 role=tab aria-controls=tab-cri-cri-o-installation-0 aria-selected=true>Debian</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-cri-o-installation-1 role=tab aria-controls=tab-cri-cri-o-installation-1>Ubuntu</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-cri-o-installation-2 role=tab aria-controls=tab-cri-cri-o-installation-2>CentOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-cri-o-installation-3 role=tab aria-controls=tab-cri-cri-o-installation-3>openSUSE Tumbleweed</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-cri-o-installation-4 role=tab aria-controls=tab-cri-cri-o-installation-4>Fedora</a></li></ul>
<div class=tab-content id=tab-cri-cri-o-installation><div id=tab-cri-cri-o-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-cri-cri-o-installation-0>
<p><p>CRI-Oを以下のOSにインストールするには、環境変数$OSを以下の表の適切なフィールドに設定します。</p>
<table>
<thead>
<tr>
<th>Operating system</th>
<th>$OS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian Unstable</td>
<td><code>Debian_Unstable</code></td>
</tr>
<tr>
<td>Debian Testing</td>
<td><code>Debian_Testing</code></td>
</tr>
</tbody>
</table>
<p><br>
そして、<code>$VERSION</code>にKubernetesのバージョンに合わせたCRI-Oのバージョンを設定します。例えば、CRI-O 1.18をインストールしたい場合は、<code>VERSION=1.18</code> を設定します。インストールを特定のリリースに固定することができます。バージョン 1.18.3をインストールするには、<code>VERSION=1.18:1.18.3</code> を設定します。
<br></p>
<p>以下を実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/</span><span style=color:#b8860b>$OS</span><span style=color:#b44>/ /&#34;</span> &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/</span><span style=color:#b8860b>$VERSION</span><span style=color:#b44>/</span><span style=color:#b8860b>$OS</span><span style=color:#b44>/ /&#34;</span> &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:<span style=color:#b8860b>$VERSION</span>.list

curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:<span style=color:#b8860b>$VERSION</span>/<span style=color:#b8860b>$OS</span>/Release.key | apt-key add -
curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/<span style=color:#b8860b>$OS</span>/Release.key | apt-key add -

apt-get update
apt-get install cri-o cri-o-runc
</code></pre></div></div>
<div id=tab-cri-cri-o-installation-1 class=tab-pane role=tabpanel aria-labelledby=tab-cri-cri-o-installation-1>
<p><p>CRI-Oを以下のOSにインストールするには、環境変数$OSを以下の表の適切なフィールドに設定します。</p>
<table>
<thead>
<tr>
<th>Operating system</th>
<th>$OS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ubuntu 20.04</td>
<td><code>xUbuntu_20.04</code></td>
</tr>
<tr>
<td>Ubuntu 19.10</td>
<td><code>xUbuntu_19.10</code></td>
</tr>
<tr>
<td>Ubuntu 19.04</td>
<td><code>xUbuntu_19.04</code></td>
</tr>
<tr>
<td>Ubuntu 18.04</td>
<td><code>xUbuntu_18.04</code></td>
</tr>
</tbody>
</table>
<p><br>
次に、<code>$VERSION</code>をKubernetesのバージョンと一致するCRI-Oのバージョンに設定します。例えば、CRI-O 1.18をインストールしたい場合は、<code>VERSION=1.18</code> を設定します。インストールを特定のリリースに固定することができます。バージョン 1.18.3 をインストールするには、<code>VERSION=1.18:1.18.3</code> を設定します。
<br></p>
<p>以下を実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/</span><span style=color:#b8860b>$OS</span><span style=color:#b44>/ /&#34;</span> &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/</span><span style=color:#b8860b>$VERSION</span><span style=color:#b44>/</span><span style=color:#b8860b>$OS</span><span style=color:#b44>/ /&#34;</span> &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:<span style=color:#b8860b>$VERSION</span>.list

curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:<span style=color:#b8860b>$VERSION</span>/<span style=color:#b8860b>$OS</span>/Release.key | apt-key add -
curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/<span style=color:#b8860b>$OS</span>/Release.key | apt-key add -

apt-get update
apt-get install cri-o cri-o-runc
</code></pre></div></div>
<div id=tab-cri-cri-o-installation-2 class=tab-pane role=tabpanel aria-labelledby=tab-cri-cri-o-installation-2>
<p><p>CRI-Oを以下のOSにインストールするには、環境変数$OSを以下の表の適切なフィールドに設定します。</p>
<table>
<thead>
<tr>
<th>Operating system</th>
<th>$OS</th>
</tr>
</thead>
<tbody>
<tr>
<td>Centos 8</td>
<td><code>CentOS_8</code></td>
</tr>
<tr>
<td>Centos 8 Stream</td>
<td><code>CentOS_8_Stream</code></td>
</tr>
<tr>
<td>Centos 7</td>
<td><code>CentOS_7</code></td>
</tr>
</tbody>
</table>
<p><br>
次に、<code>$VERSION</code>をKubernetesのバージョンと一致するCRI-Oのバージョンに設定します。例えば、CRI-O 1.18 をインストールしたい場合は、<code>VERSION=1.18</code> を設定します。インストールを特定のリリースに固定することができます。バージョン 1.18.3 をインストールするには、<code>VERSION=1.18:1.18.3</code> を設定します。
<br></p>
<p>以下を実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -L -o /etc/yum.repos.d/devel:kubic:libcontainers:stable.repo https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/<span style=color:#b8860b>$OS</span>/devel:kubic:libcontainers:stable.repo
curl -L -o /etc/yum.repos.d/devel:kubic:libcontainers:stable:cri-o:<span style=color:#b8860b>$VERSION</span>.repo https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:<span style=color:#b8860b>$VERSION</span>/<span style=color:#b8860b>$OS</span>/devel:kubic:libcontainers:stable:cri-o:<span style=color:#b8860b>$VERSION</span>.repo
yum install cri-o
</code></pre></div></div>
<div id=tab-cri-cri-o-installation-3 class=tab-pane role=tabpanel aria-labelledby=tab-cri-cri-o-installation-3>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell> sudo zypper install cri-o
</code></pre></div></div>
<div id=tab-cri-cri-o-installation-4 class=tab-pane role=tabpanel aria-labelledby=tab-cri-cri-o-installation-4>
<p><p>$VERSIONには、Kubernetesのバージョンと一致するCRI-Oのバージョンを設定します。例えば、CRI-O 1.18をインストールしたい場合は、$VERSION=1.18を設定します。
以下のコマンドで、利用可能なバージョンを見つけることができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>dnf module list cri-o
</code></pre></div><p>CRI-OはFedoraの特定のリリースにピン留めすることをサポートしていません。</p>
<p>以下を実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>dnf module <span style=color:#a2f>enable</span> cri-o:<span style=color:#b8860b>$VERSION</span>
dnf install cri-o
</code></pre></div></div></div>
<h3 id=cri-oの起動>CRI-Oの起動</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>systemctl daemon-reload
systemctl start crio
</code></pre></div><p>詳細については、<a href=https://github.com/kubernetes-sigs/cri-o#getting-started>CRI-Oインストールガイド</a>を参照してください。</p>
<h2 id=containerd>Containerd</h2>
<p>このセクションでは、CRIランタイムとして<code>containerd</code>を利用するために必要な手順について説明します。</p>
<p>システムへContainerdをインストールするためには次のコマンドを実行します。</p>
<h3 id=必要な設定の追加>必要な設定の追加</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat &gt; /etc/modules-load.d/containerd.conf <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>overlay
</span><span style=color:#b44>br_netfilter
</span><span style=color:#b44>EOF</span>

modprobe overlay
modprobe br_netfilter

<span style=color:#080;font-style:italic># 必要なカーネルパラメータの設定をします。これらの設定値は再起動後も永続化されます。</span>
cat &gt; /etc/sysctl.d/99-kubernetes-cri.conf <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>net.bridge.bridge-nf-call-iptables  = 1
</span><span style=color:#b44>net.ipv4.ip_forward                 = 1
</span><span style=color:#b44>net.bridge.bridge-nf-call-ip6tables = 1
</span><span style=color:#b44>EOF</span>

sysctl --system
</code></pre></div><h3 id=containerdのインストール>containerdのインストール</h3>
<ul class="nav nav-tabs" id=tab-cri-containerd-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-cri-containerd-installation-0 role=tab aria-controls=tab-cri-containerd-installation-0 aria-selected=true>Ubuntu 16.04</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-containerd-installation-1 role=tab aria-controls=tab-cri-containerd-installation-1>CentOS/RHEL 7.4+</a></li></ul>
<div class=tab-content id=tab-cri-containerd-installation><div id=tab-cri-containerd-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-cri-containerd-installation-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># (containerdのインストール)</span>
<span style=color:#080;font-style:italic>## リポジトリの設定</span>
<span style=color:#080;font-style:italic>### HTTPS越しのリポジトリの使用をaptに許可するために、パッケージをインストール</span>
apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y apt-transport-https ca-certificates curl software-properties-common
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic>## Docker公式のGPG鍵を追加</span>
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic>## Dockerのaptリポジトリの追加</span>
add-apt-repository <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    <span style=color:#b44>&#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
</span><span style=color:#b44>    </span><span style=color:#a2f;font-weight:700>$(</span>lsb_release -cs<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44> \
</span><span style=color:#b44>    stable&#34;</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic>## containerdのインストール</span>
apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y containerd.io
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># containerdの設定</span>
mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># containerdの再起動</span>
systemctl restart containerd
</code></pre></div></div>
<div id=tab-cri-containerd-installation-1 class=tab-pane role=tabpanel aria-labelledby=tab-cri-containerd-installation-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># (containerdのインストール)</span>
<span style=color:#080;font-style:italic>## リポジトリの設定</span>
<span style=color:#080;font-style:italic>### 必要なパッケージのインストール</span>
yum install -y yum-utils device-mapper-persistent-data lvm2
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic>## Dockerのリポジトリの追加</span>
yum-config-manager <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --add-repo <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    https://download.docker.com/linux/centos/docker-ce.repo
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic>## containerdのインストール</span>
yum update -y <span style=color:#666>&amp;&amp;</span> yum install -y containerd.io
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic>## containerdの設定</span>
mkdir -p /etc/containerd
containerd config default | sudo tee /etc/containerd/config.toml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># containerdの再起動</span>
systemctl restart containerd
</code></pre></div></div></div>
<h3 id=systemd>systemd</h3>
<p><code>systemd</code>のcgroupドライバーを使うには、<code>/etc/containerd/config.toml</code>内で<code>plugins.cri.systemd_cgroup = true</code>を設定してください。
kubeadmを使う場合は<a href=/ja/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%E3%83%9E%E3%82%B9%E3%82%BF%E3%83%BC%E3%83%8E%E3%83%BC%E3%83%89%E3%81%AEkubelet%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%82%8Bcgroup%E3%83%89%E3%83%A9%E3%82%A4%E3%83%90%E3%83%BC%E3%81%AE%E8%A8%AD%E5%AE%9A>kubeletのためのcgroupドライバー</a>を手動で設定してください。</p>
<h2 id=その他のcriランタイム-frakti>その他のCRIランタイム: frakti</h2>
<p>詳細については<a href=https://github.com/kubernetes/frakti#quickstart>Fraktiのクイックスタートガイド</a>を参照してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-00e1646f68aeb89f9722cf6f6cfcad94>2.3.2 - Kubernetesをデプロイツールでインストールする</h1>
</div>
<div class=td-content>
<h1 id=pg-a16f59f325a17cdeed324d5c889f7f73>2.3.2.1 - kubeadmを使ってクラスターを構築する</h1>
</div>
<div class=td-content>
<h1 id=pg-29e59491dd6118b23072dfe9ebb93323>2.3.2.1.1 - kubeadmのインストール</h1>
<img src=/images/kubeadm-stacked-color.png align=right width=150px>
<p>このページでは<code>kubeadm</code>コマンドをインストールする方法を示します。このインストール処理実行後にkubeadmを使用してクラスターを作成する方法については、<a href=/ja/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>kubeadmを使用したシングルマスタークラスターの作成</a>を参照してください。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>次のいずれかが動作しているマシンが必要です
<ul>
<li>Ubuntu 16.04+</li>
<li>Debian 9+</li>
<li>CentOS 7</li>
<li>Red Hat Enterprise Linux (RHEL) 7</li>
<li>Fedora 25+</li>
<li>HypriotOS v1.0.1+</li>
<li>Container Linux (tested with 1800.6.0)</li>
</ul>
</li>
<li>1台あたり2GB以上のメモリ(2GBの場合、アプリ用のスペースはほとんどありません)</li>
<li>2コア以上のCPU</li>
<li>クラスター内のすべてのマシン間で通信可能なネットワーク(パブリックネットワークでもプライベートネットワークでも構いません)</li>
<li>ユニークなhostname、MACアドレス、とproduct_uuidが各ノードに必要です。詳細は<a href=#MAC%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%81%A8product_uuid%E3%81%8C%E5%85%A8%E3%81%A6%E3%81%AE%E3%83%8E%E3%83%BC%E3%83%89%E3%81%A7%E3%83%A6%E3%83%8B%E3%83%BC%E3%82%AF%E3%81%A7%E3%81%82%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AE%E6%A4%9C%E8%A8%BC>ここ</a>を参照してください。</li>
<li>マシン内の特定のポートが開いていること。詳細は<a href=#%E5%BF%85%E9%A0%88%E3%83%9D%E3%83%BC%E3%83%88%E3%81%AE%E7%A2%BA%E8%AA%8D>ここ</a>を参照してください。</li>
<li>Swapがオフであること。kubeletが正常に動作するためにはswapは<strong>必ず</strong>オフでなければなりません。</li>
</ul>
<h2 id=macアドレスとproduct-uuidが全てのノードでユニークであることの検証>MACアドレスとproduct_uuidが全てのノードでユニークであることの検証</h2>
<ul>
<li>ネットワークインターフェースのMACアドレスは<code>ip link</code>もしくは<code>ifconfig -a</code>コマンドで取得できます。</li>
<li>product_uuidは<code>sudo cat /sys/class/dmi/id/product_uuid</code>コマンドで確認できます。</li>
</ul>
<p>ハードウェアデバイスではユニークなアドレスが割り当てられる可能性が非常に高いですが、VMでは同じになることがあります。Kubernetesはこれらの値を使用して、クラスター内のノードを一意に識別します。これらの値が各ノードに固有ではない場合、インストール処理が<a href=https://github.com/kubernetes/kubeadm/issues/31>失敗</a>することもあります。</p>
<h2 id=ネットワークアダプタの確認>ネットワークアダプタの確認</h2>
<p>複数のネットワークアダプターがあり、Kubernetesコンポーネントにデフォルトで到達できない場合、IPルートを追加して、Kubernetesクラスターのアドレスが適切なアダプターを経由するように設定することをお勧めします。</p>
<h2 id=iptablesがブリッジを通過するトラフィックを処理できるようにする>iptablesがブリッジを通過するトラフィックを処理できるようにする</h2>
<p>Linuxノードのiptablesがブリッジを通過するトラフィックを正確に処理する要件として、<code>net.bridge.bridge-nf-call-iptables</code>を<code>sysctl</code>の設定ファイルで1に設定してください。例えば以下のようにします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#b44>&lt;&lt;EOF &gt; /etc/sysctl.d/k8s.conf
</span><span style=color:#b44>net.bridge.bridge-nf-call-ip6tables = 1
</span><span style=color:#b44>net.bridge.bridge-nf-call-iptables = 1
</span><span style=color:#b44>EOF</span>
sysctl --system
</code></pre></div><p>この手順の前に<code>br_netfilter</code>モジュールがロードされていることを確認してください。<code>lsmod | grep br_netfilter</code>を実行することで確認できます。明示的にロードするには<code>modprobe br_netfilter</code>を実行してください。</p>
<p>詳細は<a href=https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#network-plugin-requirements>ネットワークプラグインの要件</a>を参照してください。</p>
<h2 id=iptablesがnftablesバックエンドを使用しないようにする>iptablesがnftablesバックエンドを使用しないようにする</h2>
<p>Linuxでは、カーネルのiptablesサブシステムの最新の代替品としてnftablesが利用できます。<code>iptables</code>ツールは互換性レイヤーとして機能し、iptablesのように動作しますが、実際にはnftablesを設定します。このnftablesバックエンドは現在のkubeadmパッケージと互換性がありません。(ファイアウォールルールが重複し、<code>kube-proxy</code>を破壊するためです。)</p>
<p>もしあなたのシステムの<code>iptables</code>ツールがnftablesバックエンドを使用している場合、これらの問題を避けるために<code>iptables</code>ツールをレガシーモードに切り替える必要があります。これは、少なくともDebian 10(Buster)、Ubuntu 19.04、Fedora 29、およびこれらのディストリビューションの新しいリリースでのデフォルトです。RHEL 8はレガシーモードへの切り替えをサポートしていないため、現在のkubeadmパッケージと互換性がありません。</p>
<ul class="nav nav-tabs" id=iptables-legacy role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#iptables-legacy-0 role=tab aria-controls=iptables-legacy-0 aria-selected=true>DebianまたはUbuntu</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#iptables-legacy-1 role=tab aria-controls=iptables-legacy-1>Fedora</a></li></ul>
<div class=tab-content id=iptables-legacy><div id=iptables-legacy-0 class="tab-pane show active" role=tabpanel aria-labelledby=iptables-legacy-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># レガシーバイナリがインストールされていることを確認してください</span>
sudo apt-get install -y iptables arptables ebtables

<span style=color:#080;font-style:italic># レガシーバージョンに切り替えてください。</span>
sudo update-alternatives --set iptables /usr/sbin/iptables-legacy
sudo update-alternatives --set ip6tables /usr/sbin/ip6tables-legacy
sudo update-alternatives --set arptables /usr/sbin/arptables-legacy
sudo update-alternatives --set ebtables /usr/sbin/ebtables-legacy
</code></pre></div></div>
<div id=iptables-legacy-1 class=tab-pane role=tabpanel aria-labelledby=iptables-legacy-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>update-alternatives --set iptables /usr/sbin/iptables-legacy
</code></pre></div></div></div>
<h2 id=必須ポートの確認>必須ポートの確認</h2>
<h3 id=コントロールプレーンノード>コントロールプレーンノード</h3>
<table>
<thead>
<tr>
<th>プロトコル</th>
<th>通信の向き</th>
<th>ポート範囲</th>
<th>目的</th>
<th>使用者</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>6443*</td>
<td>Kubernetes API server</td>
<td>全て</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>2379-2380</td>
<td>etcd server client API</td>
<td>kube-apiserver、etcd</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10250</td>
<td>Kubelet API</td>
<td>自身、コントロールプレーン</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10251</td>
<td>kube-scheduler</td>
<td>自身</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10252</td>
<td>kube-controller-manager</td>
<td>自身</td>
</tr>
</tbody>
</table>
<h3 id=ワーカーノード>ワーカーノード</h3>
<table>
<thead>
<tr>
<th>プロトコル</th>
<th>通信の向き</th>
<th>ポート範囲</th>
<th>目的</th>
<th>使用者</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>10250</td>
<td>Kubelet API</td>
<td>自身、コントロールプレーン</td>
</tr>
<tr>
<td>TCP</td>
<td>Inbound</td>
<td>30000-32767</td>
<td>NodePort Service†</td>
<td>全て</td>
</tr>
</tbody>
</table>
<p>† <a href=/ja/docs/concepts/services-networking/service/>NodePort Service</a>のデフォルトのポートの範囲</p>
<p>*の項目は書き換え可能です。そのため、あなたが指定したカスタムポートも開いていることを確認する必要があります。</p>
<p>etcdポートはコントロールプレーンノードに含まれていますが、独自のetcdクラスターを外部またはカスタムポートでホストすることもできます。</p>
<p>使用するPodネットワークプラグイン(以下を参照)のポートも開く必要があります。これは各Podネットワークプラグインによって異なるため、必要なポートについてはプラグインのドキュメントを参照してください。</p>
<h2 id=installing-runtime>ランタイムのインストール</h2>
<p>Podのコンテナを実行するために、Kubernetesは<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>を使用します。</p>
<ul class="nav nav-tabs" id=container-runtime role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#container-runtime-0 role=tab aria-controls=container-runtime-0 aria-selected=true>Linuxノード</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#container-runtime-1 role=tab aria-controls=container-runtime-1>その他のOS</a></li></ul>
<div class=tab-content id=container-runtime><div id=container-runtime-0 class="tab-pane show active" role=tabpanel aria-labelledby=container-runtime-0>
<p><p>デフォルトでは、Kubernetesは選択されたコンテナランタイムと通信するために<a class=glossary-tooltip title="An API for container runtimes to integrate with kubelet" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#container-runtime target=_blank aria-label="Container Runtime Interface">Container Runtime Interface</a> (CRI)を使用します。</p>
<p>ランタイムを指定しない場合、kubeadmはよく知られたUnixドメインソケットのリストをスキャンすることで、インストールされたコンテナランタイムの検出を試みます。
次の表がコンテナランタイムと関連するソケットのパスリストです。</p>
<table><caption style=display:none>コンテナランタイムとソケットパス</caption>
<thead>
<tr>
<th>ランタイム</th>
<th>Unixドメインソケットのパス</th>
</tr>
</thead>
<tbody>
<tr>
<td>Docker</td>
<td><code>/var/run/docker.sock</code></td>
</tr>
<tr>
<td>containerd</td>
<td><code>/run/containerd/containerd.sock</code></td>
</tr>
<tr>
<td>CRI-O</td>
<td><code>/var/run/crio/crio.sock</code></td>
</tr>
</tbody>
</table>
<p><br>
Dockerとcontainerdの両方が同時に検出された場合、Dockerが優先されます。Docker 18.09にはcontainerdが同梱されており、両方が検出可能であるため、この仕様が必要です。他の2つ以上のランタイムが検出された場合、kubeadmは適切なエラーメッセージで終了します。</p>
<p>kubeletは、組み込まれた<code>dockershim</code>CRIを通してDockerと連携します。</p>
<p>詳細は、<a href=/ja/docs/setup/production-environment/container-runtimes/>コンテナランタイム</a>を参照してください。</p>
</div>
<div id=container-runtime-1 class=tab-pane role=tabpanel aria-labelledby=container-runtime-1>
<p><p>デフォルトでは、kubeadmは<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>をコンテナランタイムとして使用します。
kubeletは、組み込まれた<code>dockershim</code>CRIを通してDockerと連携します。</p>
<p>詳細は、<a href=/ja/docs/setup/production-environment/container-runtimes/>コンテナランタイム</a>を参照してください。</p>
</div></div>
<h2 id=kubeadm-kubelet-kubectlのインストール>kubeadm、kubelet、kubectlのインストール</h2>
<p>以下のパッケージをマシン上にインストールしてください</p>
<ul>
<li>
<p><code>kubeadm</code>: クラスターを起動するコマンドです。</p>
</li>
<li>
<p><code>kubelet</code>: クラスター内のすべてのマシンで実行されるコンポーネントです。
Podやコンテナの起動などを行います。</p>
</li>
<li>
<p><code>kubectl</code>: クラスターにアクセスするためのコマンドラインツールです。</p>
</li>
</ul>
<p>kubeadmは<code>kubelet</code>や<code>kubectl</code>をインストールまたは管理<strong>しない</strong>ため、kubeadmにインストールするKubernetesコントロールプレーンのバージョンと一致させる必要があります。そうしないと、予期しないバグのある動作につながる可能性のあるバージョン差異(version skew)が発生するリスクがあります。ただし、kubeletとコントロールプレーン間のマイナーバージョン差異(minor version skew)は_1つ_サポートされていますが、kubeletバージョンがAPIサーバーのバージョンを超えることはできません。たとえば、1.7.0を実行するkubeletは1.8.0 APIサーバーと完全に互換性がありますが、その逆はできません。</p>
<p><code>kubectl</code>のインストールに関する詳細情報は、<a href=/ja/docs/tasks/tools/install-kubectl/>kubectlのインストールおよびセットアップ</a>を参照してください。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> これらの手順はシステムアップグレードによるすべてのKubernetesパッケージの更新を除きます。これはkubeadmとKubernetesが<a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>アップグレードにおける特別な注意</a>を必要とするからです。
</div>
<p>バージョン差異(version skew)に関しては下記を参照してください。</p>
<ul>
<li>Kubernetes <a href=/ja/docs/setup/release/version-skew-policy/>Kubernetesバージョンとバージョンスキューサポートポリシー</a></li>
<li>Kubeadm-specific <a href=/ja/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#version-skew-policy>バージョン互換ポリシー</a></li>
</ul>
<ul class="nav nav-tabs" id=k8s-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-0 role=tab aria-controls=k8s-install-0 aria-selected=true>Ubuntu、Debian、またはHypriotOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-1 role=tab aria-controls=k8s-install-1>CentOS、RHEL、またはFedora</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-2 role=tab aria-controls=k8s-install-2>Container Linux</a></li></ul>
<div class=tab-content id=k8s-install><div id=k8s-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo apt-get update <span style=color:#666>&amp;&amp;</span> sudo apt-get install -y apt-transport-https curl
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list
</span><span style=color:#b44>deb https://apt.kubernetes.io/ kubernetes-xenial main
</span><span style=color:#b44>EOF</span>
sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
</code></pre></div></div>
<div id=k8s-install-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#b44>&lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
</span><span style=color:#b44>[kubernetes]
</span><span style=color:#b44>name=Kubernetes
</span><span style=color:#b44>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
</span><span style=color:#b44>enabled=1
</span><span style=color:#b44>gpgcheck=1
</span><span style=color:#b44>repo_gpgcheck=1
</span><span style=color:#b44>gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># SELinuxをpermissiveモードに設定する(効果的に無効化する)</span>
setenforce <span style=color:#666>0</span>
sed -i <span style=color:#b44>&#39;s/^SELINUX=enforcing$/SELINUX=permissive/&#39;</span> /etc/selinux/config

yum install -y kubelet kubeadm kubectl --disableexcludes<span style=color:#666>=</span>kubernetes

systemctl <span style=color:#a2f>enable</span> --now kubelet
</code></pre></div><p><strong>Note:</strong></p>
<ul>
<li><code>setenforce 0</code>および<code>sed ...</code>を実行することによりSELinuxをpermissiveモードに設定し、効果的に無効化できます。
これはコンテナがホストのファイルシステムにアクセスするために必要です。例えば、Podのネットワークに必要とされます。
kubeletにおけるSELinuxのサポートが改善されるまでは、これを実行しなければなりません。</li>
</ul>
</div>
<div id=k8s-install-2 class=tab-pane role=tabpanel aria-labelledby=k8s-install-2>
<p><p>CNIプラグインをインストールする(ほとんどのPodのネットワークに必要です):</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#b8860b>CNI_VERSION</span><span style=color:#666>=</span><span style=color:#b44>&#34;v0.8.2&#34;</span>
<span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
mkdir -p /opt/cni/bin
curl -L <span style=color:#b44>&#34;https://github.com/containernetworking/plugins/releases/download/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CNI_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/cni-plugins-linux-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CNI_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>.tgz&#34;</span> | tar -C /opt/cni/bin -xz
</code></pre></div><p>crictlをインストールする (kubeadm / Kubelet Container Runtime Interface (CRI)に必要です)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#666>=</span><span style=color:#b44>&#34;v1.17.0&#34;</span>
<span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
curl -L <span style=color:#b44>&#34;https://github.com/kubernetes-sigs/cri-tools/releases/download/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/crictl-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>-linux-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>.tar.gz&#34;</span> | sudo tar -C <span style=color:#b8860b>$DOWNLOAD_DIR</span> -xz
</code></pre></div><p><code>kubeadm</code>、<code>kubelet</code>、<code>kubectl</code>をインストールし<code>kubelet</code>をsystemd serviceに登録します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#b8860b>RELEASE</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>curl -sSL https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
<span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
mkdir -p /opt/bin
<span style=color:#a2f>cd</span> /opt/bin
curl -L --remote-name-all https://storage.googleapis.com/kubernetes-release/release/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE</span><span style=color:#b68;font-weight:700>}</span>/bin/linux/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span>/<span style=color:#666>{</span>kubeadm,kubelet,kubectl<span style=color:#666>}</span>
chmod +x <span style=color:#666>{</span>kubeadm,kubelet,kubectl<span style=color:#666>}</span>

curl -sSL <span style=color:#b44>&#34;https://raw.githubusercontent.com/kubernetes/kubernetes/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/build/debs/kubelet.service&#34;</span> | sed <span style=color:#b44>&#34;s:/usr/bin:/opt/bin:g&#34;</span> &gt; /etc/systemd/system/kubelet.service
mkdir -p /etc/systemd/system/kubelet.service.d
curl -sSL <span style=color:#b44>&#34;https://raw.githubusercontent.com/kubernetes/kubernetes/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/build/debs/10-kubeadm.conf&#34;</span> | sed <span style=color:#b44>&#34;s:/usr/bin:/opt/bin:g&#34;</span> &gt; /etc/systemd/system/kubelet.service.d/10-kubeadm.conf
</code></pre></div><p><code>kubelet</code>を有効化し起動します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>systemctl <span style=color:#a2f>enable</span> --now kubelet
</code></pre></div></div></div>
<p>kubeadmが何をすべきか指示するまで、kubeletはクラッシュループで数秒ごとに再起動します。</p>
<h2 id=コントロールプレーンノードのkubeletによって使用されるcgroupドライバーの設定>コントロールプレーンノードのkubeletによって使用されるcgroupドライバーの設定</h2>
<p>Dockerを使用した場合、kubeadmは自動的にkubelet向けのcgroupドライバーを検出し、それを実行時に<code>/var/lib/kubelet/kubeadm-flags.env</code>ファイルに設定します。</p>
<p>もしあなたが異なるCRIを使用している場合、<code>/etc/default/kubelet</code>(CentOS、RHEL、Fedoraでは<code>/etc/sysconfig/kubelet</code>)ファイル内の<code>cgroup-driver</code>の値を以下のように変更する必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#b8860b>KUBELET_EXTRA_ARGS</span><span style=color:#666>=</span>--cgroup-driver<span style=color:#666>=</span>&lt;value&gt;
</code></pre></div><p>このファイルは、kubeletの追加のユーザー定義引数を取得するために、<code>kubeadm init</code>および<code>kubeadm join</code>によって使用されます。</p>
<p>CRIのcgroupドライバーが<code>cgroupfs</code>でない場合に<strong>のみ</strong>それを行う必要があることに注意してください。なぜなら、これはすでにkubeletのデフォルト値であるためです。</p>
<p>kubeletをリスタートする方法:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>systemctl daemon-reload
systemctl restart kubelet
</code></pre></div><p>CRI-Oやcontainerdといった他のコンテナランタイムのcgroup driverは実行中に自動的に検出されます。</p>
<h2 id=トラブルシュート>トラブルシュート</h2>
<p>kubeadmで問題が発生した場合は、<a href=/ja/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/>トラブルシューティング</a>を参照してください。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>kubeadmを使用したシングルコントロールプレーンクラスターの作成</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c3689df4b0c61a998e79d91a865aa244>2.3.2.1.2 - kubeadmのトラブルシューティング</h1>
<p>どのプログラムでもそうですが、kubeadmのインストールや実行でエラーが発生することがあります。このページでは、一般的な失敗例をいくつか挙げ、問題を理解して解決するための手順を示しています。</p>
<p>本ページに問題が記載されていない場合は、以下の手順を行ってください:</p>
<ul>
<li>
<p>問題がkubeadmのバグによるものと思った場合:</p>
<ul>
<li><a href=https://github.com/kubernetes/kubeadm/issues>github.com/kubernetes/kubeadm</a>にアクセスして、既存のIssueを探してください。</li>
<li>Issueがない場合は、テンプレートにしたがって<a href=https://github.com/kubernetes/kubeadm/issues/new>新しくIssueを立ててください</a>。</li>
</ul>
</li>
<li>
<p>kubeadmがどのように動作するかわからない場合は、<a href=http://slack.k8s.io/>Slack</a>の#kubeadmチャンネルで質問するか、<a href=https://stackoverflow.com/questions/tagged/kubernetes>StackOverflow</a>で質問をあげてください。その際は、他の方が助けを出しやすいように<code>#kubernetes</code>や<code>#kubeadm</code>といったタグをつけてください。</p>
</li>
</ul>
<h2 id=rbacがないため-v1-18ノードをv1-17クラスタに結合できない>RBACがないため、v1.18ノードをv1.17クラスタに結合できない</h2>
<p>v1.18では、同名のノードが既に存在する場合にクラスタ内のノードに参加しないようにする機能を追加しました。これには、ブートストラップトークンユーザがNodeオブジェクトをGETできるようにRBACを追加する必要がありました。</p>
<p>しかし、これによりv1.18の<code>kubeadm join</code>がkubeadm v1.17で作成したクラスタに参加できないという問題が発生します。</p>
<p>この問題を回避するには、次の2つの方法があります。</p>
<ul>
<li>
<p>kubeadm v1.18を用いて、コントロールプレーンノード上で<code>kubeadm init phase bootstrap-token</code>を実行します。
これには、ブートストラップトークンの残りのパーミッションも同様に有効にすることに注意してください。</p>
</li>
<li>
<p><code>kubectl apply -f ...</code>を使って以下のRBACを手動で適用します。</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubeadm:get-nodes<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubeadm:get-nodes<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubeadm:get-nodes<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:bootstrappers:kubeadm:default-node-token<span style=color:#bbb>
</span></code></pre></div><h2 id=インストール中に-ebtables-もしくは他の似たような実行プログラムが見つからない>インストール中に<code>ebtables</code>もしくは他の似たような実行プログラムが見つからない</h2>
<p><code>kubeadm init</code>の実行中に以下のような警告が表示された場合は、以降に記載するやり方を行ってください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#666>[</span>preflight<span style=color:#666>]</span> WARNING: ebtables not found in system path
<span style=color:#666>[</span>preflight<span style=color:#666>]</span> WARNING: ethtool not found in system path
</code></pre></div><p>このような場合、ノード上に<code>ebtables</code>, <code>ethtool</code>などの実行ファイルがない可能性があります。これらをインストールするには、以下のコマンドを実行します。</p>
<ul>
<li>Ubuntu/Debianユーザーは、<code>apt install ebtables ethtool</code>を実行してください。</li>
<li>CentOS/Fedoraユーザーは、<code>yum install ebtables ethtool</code>を実行してください。</li>
</ul>
<h2 id=インストール中にkubeadmがコントロールプレーンを待ち続けて止まる>インストール中にkubeadmがコントロールプレーンを待ち続けて止まる</h2>
<p>以下のを出力した後に<code>kubeadm init</code>が止まる場合は、<code>kubeadm init</code>を実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#666>[</span>apiclient<span style=color:#666>]</span> Created API client, waiting <span style=color:#a2f;font-weight:700>for</span> the control plane to become ready
</code></pre></div><p>これはいくつかの問題が原因となっている可能性があります。最も一般的なのは:</p>
<ul>
<li>
<p>ネットワーク接続の問題が挙げられます。続行する前に、お使いのマシンがネットワークに完全に接続されていることを確認してください。</p>
</li>
<li>
<p>kubeletのデフォルトのcgroupドライバの設定がDockerで使用されているものとは異なっている場合も考えられます。
システムログファイル(例: <code>/var/log/message</code>)をチェックするか、<code>journalctl -u kubelet</code>の出力を調べてください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>error: failed to run Kubelet: failed to create kubelet:
misconfiguration: kubelet cgroup driver: <span style=color:#b44>&#34;systemd&#34;</span> is different from docker cgroup driver: <span style=color:#b44>&#34;cgroupfs&#34;</span>
</code></pre></div><p>以上のようなエラーが現れていた場合、cgroupドライバの問題を解決するには、以下の2つの方法があります:</p>
</li>
</ul>
<ol>
<li>
<p><a href=/ja/docs/setup/independent/install-kubeadm/#installing-docker>ここ</a>の指示に従ってDockerを再度インストールします。</p>
</li>
<li>
<p>Dockerのcgroupドライバに合わせてkubeletの設定を手動で変更します。その際は、<a href=/ja/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#configure-cgroup-driver-used-by-kubelet-on-master-node>マスターノード上でkubeletが使用するcgroupドライバを設定する</a>を参照してください。</p>
</li>
</ol>
<ul>
<li>control plane Dockerコンテナがクラッシュループしたり、ハングしたりしています。これは<code>docker ps</code>を実行し、<code>docker logs</code>を実行して各コンテナを調査することで確認できます。</li>
</ul>
<h2 id=管理コンテナを削除する時にkubeadmが止まる>管理コンテナを削除する時にkubeadmが止まる</h2>
<p>Dockerが停止して、Kubernetesで管理されているコンテナを削除しないと、以下のようなことが起こる可能性があります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo kubeadm reset
<span style=color:#666>[</span>preflight<span style=color:#666>]</span> Running pre-flight checks
<span style=color:#666>[</span>reset<span style=color:#666>]</span> Stopping the kubelet service
<span style=color:#666>[</span>reset<span style=color:#666>]</span> Unmounting mounted directories in <span style=color:#b44>&#34;/var/lib/kubelet&#34;</span>
<span style=color:#666>[</span>reset<span style=color:#666>]</span> Removing kubernetes-managed containers
<span style=color:#666>(</span>block<span style=color:#666>)</span>
</code></pre></div><p>考えられる解決策は、Dockerサービスを再起動してから<code>kubeadm reset</code>を再実行することです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo systemctl restart docker.service
sudo kubeadm reset
</code></pre></div><p>dockerのログを調べるのも有効な場合があります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>journalctl -u docker
</code></pre></div><h2 id=podの状態が-runcontainererror-crashloopbackoff-または-error-となる>Podの状態が<code>RunContainerError</code>、<code>CrashLoopBackOff</code>、または<code>Error</code>となる</h2>
<p><code>kubeadm init</code>の直後には、これらの状態ではPodは存在しないはずです。</p>
<ul>
<li><code>kubeadm init</code>の <em>直後</em> にこれらの状態のいずれかにPodがある場合は、kubeadmのリポジトリにIssueを立ててください。ネットワークソリューションをデプロイするまでは<code>coredns</code>(または<code>kube-dns</code>)は<code>Pending</code>状態でなければなりません。</li>
<li>ネットワークソリューションをデプロイしても<code>coredns</code>(または<code>kube-dns</code>)に何も起こらない場合にRunContainerError<code>、</code>CrashLoopBackOff<code>、</code>Error`の状態でPodが表示された場合は、インストールしたPodネットワークソリューションが壊れている可能性が高いです。より多くのRBACの特権を付与するか、新しいバージョンを使用する必要があるかもしれません。PodネットワークプロバイダのイシュートラッカーにIssueを出して、そこで問題をトリアージしてください。</li>
<li>1.12.1よりも古いバージョンのDockerをインストールした場合は、<code>systemd</code>で<code>dockerd</code>を起動する際に<code>MountFlags=slave</code>オプションを削除して<code>docker</code>を再起動してください。マウントフラグは<code>/usr/lib/systemd/system/docker.service</code>で確認できます。MountFlagsはKubernetesがマウントしたボリュームに干渉し、Podsを<code>CrashLoopBackOff</code>状態にすることがあります。このエラーは、Kubernetesが<code>var/run/secrets/kubernetes.io/serviceaccount</code>ファイルを見つけられない場合に発生します。</li>
</ul>
<h2 id=coredns-もしくは-kube-dns-が-pending-状態でスタックする><code>coredns</code>(もしくは<code>kube-dns</code>)が<code>Pending</code>状態でスタックする</h2>
<p>kubeadmはネットワークプロバイダに依存しないため、管理者は選択した<a href=/docs/concepts/cluster-administration/addons/>Podネットワークソリューションをインストール</a>をする必要があります。CoreDNSを完全にデプロイする前にPodネットワークをインストールする必要があります。したがって、ネットワークがセットアップされる前の <code>Pending</code>状態になります。</p>
<h2 id=hostport-サービスが動かない><code>HostPort</code>サービスが動かない</h2>
<p><code>HostPort</code>と<code>HostIP</code>の機能は、ご使用のPodネットワークプロバイダによって利用可能です。Podネットワークソリューションの作者に連絡して、<code>HostPort</code>と<code>HostIP</code>機能が利用可能かどうかを確認してください。</p>
<p>Calico、Canal、FlannelのCNIプロバイダは、HostPortをサポートしていることが確認されています。</p>
<p>詳細については、[CNI portmap documentation] (<a href=https://github.com/containernetworking/plugins/blob/master/plugins/meta/portmap/README.md>https://github.com/containernetworking/plugins/blob/master/plugins/meta/portmap/README.md</a>) を参照してください。</p>
<p>ネットワークプロバイダが portmap CNI プラグインをサポートしていない場合は、<a href=/ja/docs/concepts/services-networking/service/#nodeport>NodePortサービス</a>を使用するか、<code>HostNetwork=true</code>を使用してください。</p>
<h2 id=サービスip経由でpodにアクセスすることができない>サービスIP経由でPodにアクセスすることができない</h2>
<ul>
<li>
<p>多くのネットワークアドオンは、PodがサービスIPを介して自分自身にアクセスできるようにする<a href=/docs/tasks/debug-application-cluster/debug-service/#a-pod-cannot-reach-itself-via-service-ip>ヘアピンモード</a>を有効にしていません。これは<a href=https://github.com/containernetworking/cni/issues/476>CNI</a>に関連する問題です。ヘアピンモードのサポート状況については、ネットワークアドオンプロバイダにお問い合わせください。</p>
</li>
<li>
<p>VirtualBoxを使用している場合(直接またはVagrant経由)は、<code>hostname -i</code>がルーティング可能なIPアドレスを返すことを確認する必要があります。デフォルトでは、最初のインターフェースはルーティング可能でないホスト専用のネットワークに接続されています。これを回避するには<code>/etc/hosts</code>を修正する必要があります。例としてはこの<a href=https://github.com/errordeveloper/k8s-playground/blob/22dd39dfc06111235620e6c4404a96ae146f26fd/Vagrantfile#L11>Vagrantfile</a>を参照してください。</p>
</li>
</ul>
<h2 id=tls証明書のエラー>TLS証明書のエラー</h2>
<p>以下のエラーは、証明書の不一致の可能性を示しています。</p>
<pre><code class=language-none data-lang=none># kubectl get pods
Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of &quot;crypto/rsa: verification error&quot; while trying to verify candidate authority certificate &quot;kubernetes&quot;)
</code></pre><ul>
<li>
<p><code>HOME/.kube/config</code>ファイルに有効な証明書が含まれていることを確認し、必要に応じて証明書を再生成します。kubeconfigファイル内の証明書はbase64でエンコードされています。証明書をデコードするには<code>base64 --decode</code>コマンドを、証明書情報を表示するには<code>openssl x509 -text -noout</code>コマンドを用いてください。</p>
</li>
<li>
<p>環境変数<code>KUBECONFIG</code>の設定を解除するには以下のコマンドを実行するか:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#a2f>unset</span> KUBECONFIG
</code></pre></div><p>設定をデフォルトの<code>KUBECONFIG</code>の場所に設定します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>/etc/kubernetes/admin.conf
</code></pre></div></li>
<li>
<p>もう一つの回避策は、既存の<code>kubeconfig</code>を"admin"ユーザに上書きすることです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>mv  <span style=color:#b8860b>$HOME</span>/.kube <span style=color:#b8860b>$HOME</span>/.kube.bak
mkdir <span style=color:#b8860b>$HOME</span>/.kube
sudo cp -i /etc/kubernetes/admin.conf <span style=color:#b8860b>$HOME</span>/.kube/config
sudo chown <span style=color:#a2f;font-weight:700>$(</span>id -u<span style=color:#a2f;font-weight:700>)</span>:<span style=color:#a2f;font-weight:700>$(</span>id -g<span style=color:#a2f;font-weight:700>)</span> <span style=color:#b8860b>$HOME</span>/.kube/config
</code></pre></div></li>
</ul>
<h2 id=vagrant内でpodネットワークとしてflannelを使用する時のデフォルトnic>Vagrant内でPodネットワークとしてflannelを使用する時のデフォルトNIC</h2>
<p>以下のエラーは、Podネットワークに何か問題があったことを示している可能性を示しています:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>Error from server <span style=color:#666>(</span>NotFound<span style=color:#666>)</span>: the server could not find the requested resource
</code></pre></div><ul>
<li>
<p>Vagrant内のPodネットワークとしてflannelを使用している場合は、flannelのデフォルトのインターフェース名を指定する必要があります。</p>
<p>Vagrantは通常、2つのインターフェースを全てのVMに割り当てます。1つ目は全てのホストにIPアドレス<code>10.0.2.15</code>が割り当てられており、NATされる外部トラフィックのためのものです。</p>
<p>これは、ホストの最初のインターフェイスをデフォルトにしているflannelの問題につながるかもしれません。これは、すべてのホストが同じパブリックIPアドレスを持っていると考えます。これを防ぐには、2番目のインターフェイスが選択されるように <code>--iface eth1</code>フラグをflannelに渡してください。</p>
</li>
</ul>
<h2 id=公開されていないipがコンテナに使われている>公開されていないIPがコンテナに使われている</h2>
<p>状況によっては、<code>kubectl logs</code>や<code>kubectl run</code>コマンドが以下のようなエラーを返すことがあります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>Error from server: Get https://10.19.0.41:10250/containerLogs/default/mysql-ddc65b868-glc5m/mysql: dial tcp 10.19.0.41:10250: getsockopt: no route to host
</code></pre></div><ul>
<li>
<p>これには、おそらくマシンプロバイダのポリシーによって、一見同じサブネット上の他のIPと通信できないIPをKubernetesが使用している可能性があります。</p>
</li>
<li>
<p>DigitalOceanはパブリックIPとプライベートIPを<code>eth0</code>に割り当てていますが、<code>kubelet</code>はパブリックIPではなく、ノードの<code>InternalIP</code>として後者を選択します。</p>
<p><code>ifconfig</code>ではエイリアスIPアドレスが表示されないため、<code>ifconfig</code>の代わりに<code>ip addr show</code>を使用してこのシナリオをチェックしてください。あるいは、DigitalOcean専用のAPIエンドポイントを使用して、ドロップレットからアンカーIPを取得することもできます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>curl http://169.254.169.254/metadata/v1/interfaces/public/0/anchor_ipv4/address
</code></pre></div><p>回避策としては、<code>--node-ip</code>を使ってどのIPを使うかを<code>kubelet</code>に伝えることです。DigitalOceanを使用する場合、オプションのプライベートネットワークを使用したい場合は、パブリックIP（<code>eth0</code>に割り当てられている）かプライベートIP（<code>eth1</code>に割り当てられている）のどちらかを指定します。これにはkubeadm <code>NodeRegistrationOptions</code>構造体の <a href=https://github.com/kubernetes/kubernetes/blob/release-1.13/cmd/kubeadm/app/apis/kubeadm/v1beta1/types.go><code>KubeletExtraArgs</code>セクション</a> が利用できます。</p>
<p><code>kubelet</code>を再起動してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>systemctl daemon-reload
systemctl restart kubelet
</code></pre></div></li>
</ul>
<h2 id=coredns-のpodが-crashloopbackoff-もしくは-error-状態になる><code>coredns</code>のPodが<code>CrashLoopBackOff</code>もしくは<code>Error</code>状態になる</h2>
<p>SELinuxを実行しているノードで古いバージョンのDockerを使用している場合、<code>coredns</code> Podが起動しないということが起きるかもしれません。この問題を解決するには、以下のオプションのいずれかを試してみてください:</p>
<ul>
<li>
<p><a href=/ja/docs/setup/independent/install-kubeadm/#installing-docker>新しいDockerのバージョン</a>にアップグレードする。</p>
</li>
<li>
<p><a href=https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security-enhanced_linux/sect-security-enhanced_linux-enabling_and_disabling_selinux-disabling_selinux>SELinuxを無効化する</a>。</p>
</li>
<li>
<p><code>coredns</code>を変更して、<code>allowPrivilegeEscalation</code>を<code>true</code>に設定:</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl -n kube-system get deployment coredns -o yaml | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  sed <span style=color:#b44>&#39;s/allowPrivilegeEscalation: false/allowPrivilegeEscalation: true/g&#39;</span> | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  kubectl apply -f -
</code></pre></div><p>CoreDNSに<code>CrashLoopBackOff</code>が発生する別の原因は、KubernetesにデプロイされたCoreDNS Podがループを検出したときに発生します。CoreDNSがループを検出して終了するたびに、KubernetesがCoreDNS Podを再起動しようとするのを避けるために、<a href=https://github.com/coredns/coredns/tree/master/plugin/loop#troubleshooting-loops-in-kubernetes-clusters>いくつかの回避策</a>が用意されています。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> SELinuxを無効にするか<code>allowPrivilegeEscalation</code>を<code>true</code>に設定すると、クラスタのセキュリティが損なわれる可能性があります。
</div>
<h2 id=etcdのpodが継続的に再起動する>etcdのpodが継続的に再起動する</h2>
<p>以下のエラーが発生した場合は:</p>
<pre><code>rpc error: code = 2 desc = oci runtime error: exec failed: container_linux.go:247: starting container process caused &quot;process_linux.go:110: decoding init error from pipe caused \&quot;read parent: connection reset by peer\&quot;&quot;
</code></pre><p>この問題は、CentOS 7をDocker 1.13.1.84で実行した場合に表示されます。このバージョンのDockerでは、kubeletがetcdコンテナに実行されないようにすることができます。</p>
<p>この問題を回避するには、以下のいずれかのオプションを選択します:</p>
<ul>
<li>1.13.1-75のような以前のバージョンのDockerにロールバックする</li>
</ul>
<pre><code>yum downgrade docker-1.13.1-75.git8633870.el7.centos.x86_64 docker-client-1.13.1-75.git8633870.el7.centos.x86_64 docker-common-1.13.1-75.git8633870.el7.centos.x86_64
</code></pre><ul>
<li>18.06のような最新の推奨バージョンをインストールする:</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
yum install docker-ce-18.06.1.ce-3.el7.x86_64
</code></pre></div><h2 id=コンマで区切られた値のリストを-component-extra-args-フラグ内の引数に渡すことができない>コンマで区切られた値のリストを<code>--component-extra-args</code>フラグ内の引数に渡すことができない</h2>
<p><code>-component-extra-args</code>のような<code>kubeadm init</code>フラグを使うと、kube-apiserverのようなコントロールプレーンコンポーネントにカスタム引数を渡すことができます。しかし、このメカニズムは値の解析に使われる基本的な型 (<code>mapStringString</code>) のために制限されています。</p>
<p>もし、<code>--apiserver-extra-args "enable-admission plugins=LimitRanger,NamespaceExists"</code>のようにカンマで区切られた複数の値をサポートする引数を渡した場合、このフラグは<code>flag: malformed pair, expect string=string</code>で失敗します。これは<code>--apiserver-extra-args</code>の引数リストが<code>key=value</code>のペアを期待しており、この場合<code>NamespacesExists</code>は値を欠いたキーとみなされるためです。</p>
<p>別の方法として、<code>key=value</code>のペアを以下のように分離してみることもできます:
<code>--apiserver-extra-args "enable-admission-plugins=LimitRanger,enable-admission-plugins=NamespaceExists"</code>しかし、この場合は、キー<code>enable-admission-plugins</code>は<code>NamespaceExists</code>の値しか持ちません。既知の回避策としては、kubeadm<a href=/ja/docs/setup/production-environment/tools/kubeadm/control-plane-flags/#apiserver-flags>設定ファイル</a>を使用することが挙げられます。</p>
<h2 id=cloud-controller-managerによってノードが初期化される前にkube-proxyがスケジューリングされる>cloud-controller-managerによってノードが初期化される前にkube-proxyがスケジューリングされる</h2>
<p>クラウドプロバイダのシナリオでは、クラウドコントローラマネージャがノードアドレスを初期化する前に、kube-proxyが新しいワーカーノードでスケジューリングされてしまうことがあります。これにより、kube-proxyがノードのIPアドレスを正しく拾えず、ロードバランサを管理するプロキシ機能に悪影響を及ぼします。</p>
<p>kube-proxy Podsでは以下のようなエラーが発生します:</p>
<pre><code>server.go:610] Failed to retrieve node IP: host IP unknown; known addresses: []
proxier.go:340] invalid nodeIP, initializing kube-proxy with 127.0.0.1 as nodeIP
</code></pre><p>既知の解決策は、初期のガード条件が緩和されるまで他のノードから離しておき、条件に関係なくコントロールプレーンノード上でスケジューリングできるように、キューブプロキシDaemonSetにパッチを当てることです:</p>
<pre><code>kubectl -n kube-system patch ds kube-proxy -p='{ &quot;spec&quot;: { &quot;template&quot;: { &quot;spec&quot;: { &quot;tolerations&quot;: [ { &quot;key&quot;: &quot;CriticalAddonsOnly&quot;, &quot;operator&quot;: &quot;Exists&quot; }, { &quot;effect&quot;: &quot;NoSchedule&quot;, &quot;key&quot;: &quot;node-role.kubernetes.io/master&quot; } ] } } } }'
</code></pre><p>Tこの問題のトラッキング問題は<a href=https://github.com/kubernetes/kubeadm/issues/1027>こちら</a>。</p>
<h2 id=kubeadmの設定をマーシャリングする際-noderegistration-taintsフィールドが省略される>kubeadmの設定をマーシャリングする際、NodeRegistration.Taintsフィールドが省略される</h2>
<p><em>注意: この<a href=https://github.com/kubernetes/kubeadm/issues/1358>Issue</a>は、kubeadmタイプをマーシャルするツール(YAML設定ファイルなど)にのみ適用されます。これはkubeadm API v1beta2で修正される予定です。</em></p>
<p>デフォルトでは、kubeadmはコントロールプレーンノードに<code>node-role.kubernetes.io/master:NoSchedule</code>のテイントを適用します。kubeadmがコントロールプレーンノードに影響を与えないようにし、<code>InitConfiguration.NodeRegistration.Taints</code>を空のスライスに設定すると、マーシャリング時にこのフィールドは省略されます。フィールドが省略された場合、kubeadmはデフォルトのテイントを適用します。</p>
<p>少なくとも2つの回避策があります:</p>
<ol>
<li>
<p>空のスライスの代わりに<code>node-role.kubernetes.io/master:PreferNoSchedule</code>テイントを使用します。他のノードに容量がない限り、<a href=/docs/concepts/scheduling-eviction/taint-and-toleration/>Podsはマスター上でスケジュールされます</a>。</p>
</li>
<li>
<p>kubeadm init終了後のテイントの除去:</p>
</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl taint nodes NODE_NAME node-role.kubernetes.io/master:NoSchedule-
</code></pre></div><h2 id=ノード-usr-mounted-read-only-に-usr-が読み取り専用でマウントされる>ノード{#usr-mounted-read-only}に<code>/usr</code>が読み取り専用でマウントされる</h2>
<p>Fedora CoreOSなどのLinuxディストリビューションでは、ディレクトリ<code>/usr</code>が読み取り専用のファイルシステムとしてマウントされます。 <a href=https://github.com/kubernetes/community/blob/ab55d85/contributors/devel/sig-storage/flexvolume.md>flex-volumeサポート</a>では、kubeletやkube-controller-managerのようなKubernetesコンポーネントはデフォルトで<code>/usr/libexec/kubernetes/kubelet-plugins/volume/exec/</code>のパスを使用していますが、この機能を動作させるためにはflex-volumeディレクトリは <em>書き込み可能</em> な状態でなければなりません。</p>
<p>この問題を回避するには、kubeadm<a href=https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2>設定ファイル</a>を使用してflex-volumeディレクトリを設定します。</p>
<p>プライマリコントロールプレーンノード（<code>kubeadm init</code>で作成されたもの）上で、<code>--config</code>で以下のファイルを渡します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>InitConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>nodeRegistration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubeletExtraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volume-plugin-dir</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/opt/libexec/kubernetes/kubelet-plugins/volume/exec/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>controllerManager</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>flex-volume-plugin-dir</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/opt/libexec/kubernetes/kubelet-plugins/volume/exec/&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>ノードをジョインするには:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>JoinConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>nodeRegistration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubeletExtraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volume-plugin-dir</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/opt/libexec/kubernetes/kubelet-plugins/volume/exec/&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>あるいは、<code>/usr</code>マウントを書き込み可能にするために <code>/etc/fstab</code>を変更することもできますが、これはLinuxディストリビューションの設計原理を変更していることに注意してください。</p>
<h2 id=kubeadm-upgrade-plan-が-context-deadline-exceeded-エラーメッセージを表示する><code>kubeadm upgrade plan</code>が<code>context deadline exceeded</code>エラーメッセージを表示する</h2>
<p>このエラーメッセージは、外部etcdを実行している場合に<code>kubeadm</code>でKubernetesクラスタをアップグレードする際に表示されます。これは致命的なバグではなく、古いバージョンのkubeadmが外部etcdクラスタのバージョンチェックを行うために発生します。<code>kubeadm upgrade apply ...</code>で進めることができます。</p>
<p>この問題はバージョン1.19で修正されます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-134ed1f6142a98e6ac681a1ba4920e53>2.3.2.1.3 - kubeadmを使用したクラスターの作成</h1>
<p><img src=/images/kubeadm-stacked-color.png align=right width=150px>ベストプラクティスに準拠した実用最小限のKubernetesクラスターを作成します。実際、<code>kubeadm</code>を使用すれば、<a href=https://kubernetes.io/blog/2017/10/software-conformance-certification>Kubernetes Conformance tests</a>に通るクラスターをセットアップすることができます。<code>kubeadm</code>は、<a href=/docs/reference/access-authn-authz/bootstrap-tokens/>ブートストラップトークン</a>やクラスターのアップグレードなどのその他のクラスターのライフサイクルの機能もサポートします。</p>
<p><code>kubeadm</code>ツールは、次のようなときに適しています。</p>
<ul>
<li>新しいユーザーが初めてKubernetesを試すためのシンプルな方法が必要なとき。</li>
<li>既存のユーザーがクラスターのセットアップを自動化し、アプリケーションをテストする方法が必要なとき。</li>
<li>より大きなスコープで、他のエコシステムやインストーラーツールのビルディングブロックが必要なとき。</li>
</ul>
<p><code>kubeadm</code>は、ラップトップ、クラウドのサーバー群、Raspberry Piなどの様々なマシンにインストールして使えます。クラウドとオンプレミスのどちらにデプロイする場合でも、<code>kubeadm</code>はAnsibleやTerraformなどのプロビジョニングシステムに統合できます。</p>
<h2 id=始める前に>始める前に</h2>
<p>このガイドを進めるには、以下の環境が必要です。</p>
<ul>
<li>UbuntuやCentOSなど、deb/rpmパッケージと互換性のあるLinux OSが動作している1台以上のマシンがあること。</li>
<li>マシンごとに2GiB以上のRAMが搭載されていること。それ以下の場合、アプリ実行用のメモリーがほとんど残りません。</li>
<li>コントロールプレーンノードとして使用するマシンには、最低でも2CPU以上あること。</li>
<li>クラスター内の全マシン間に完全なネットワーク接続があること。パブリックネットワークとプライベートネットワークのいずれでも使えます。</li>
</ul>
<p>また、新しいクラスターで使いたいKubernetesのバージョンをデプロイできるバージョンの<code>kubeadm</code>を使用する必要もあります。</p>
<p><a href=/ja/docs/setup/release/version-skew-policy/#supported-versions>Kubernetesのバージョンとバージョンスキューポリシー</a>は、<code>kubeadm</code>にもKubernetes全体と同じように当てはまります。Kubernetesと<code>kubeadm</code>がサポートするバージョンを理解するには、上記のポリシーを確認してください。このページは、Kubernetes v1.22向けに書かれています。</p>
<p>kubeadmツールの全体の機能の状態は、一般利用可能(GA)です。一部のサブ機能はまだ活発に開発が行われています。クラスター作成の実装は、ツールの進化に伴ってわずかに変わるかもしれませんが、全体の実装は非常に安定しているはずです。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>kubeadm alpha</code>以下のすべてのコマンドは、定義通り、アルファレベルでサポートされています。
</div>
<h2 id=目的>目的</h2>
<ul>
<li>シングルコントロールプレーンのKubernetesクラスターをインストールする</li>
<li>クラスター上にPodネットワークをインストールして、Podがお互いに通信できるようにする</li>
</ul>
<h2 id=手順>手順</h2>
<h3 id=ホストへのkubeadmのインストール>ホストへのkubeadmのインストール</h3>
<p>「<a href=/ja/docs/setup/production-environment/tools/kubeadm/install-kubeadm/>kubeadmのインストール</a>」を読んでください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>すでにkubeadmがインストール済みである場合は、最新バージョンのkubeadmを取得するために<code>apt-get update && apt-get upgrade</code>や<code>yum update</code>を実行してください。</p>
<p>アップグレード中、kubeletが数秒ごとに再起動します。これは、kubeadmがkubeletにするべきことを伝えるまで、crashloopの状態で待機するためです。このcrashloopは期待通りの通常の動作です。コントロールプレーンの初期化が完了すれば、kubeletは正常に動作します。</p>
</div>
<h3 id=コントロールプレーンノードの初期化>コントロールプレーンノードの初期化</h3>
<p>コントロールプレーンノードとは、<a class=glossary-tooltip title=一貫性、高可用性を持ったキーバリューストアで、Kubernetesの全てのクラスター情報の保存場所として利用されています。 data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>(クラスターのデータベース)や<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>(<a class=glossary-tooltip title="A command line tool for communicating with a Kubernetes API server." data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>コマンドラインツールが通信する相手)などのコントロールプレーンのコンポーネントが実行されるマシンです。</p>
<ol>
<li>(推奨)シングルコントロールプレーンの<code>kubeadm</code>クラスターを高可用性クラスターにアップグレードする予定がある場合、<code>--control-plane-endpoint</code>を指定して、すべてのコントロールプレーンノードとエンドポイントを共有する必要があります。エンドポイントにはDNSネームやロードバランサーのIPアドレスが使用できます。</li>
<li>Podネットワークアドオンを選んで、<code>kubeadm init</code>に引数を渡す必要があるかどうか確認してください。選んだサードパーティーのプロバイダーによっては、<code>--pod-network-cidr</code>をプロバイダー固有の値に設定する必要がある場合があります。詳しくは、<a href=#pod-network>Podネットワークアドオンのインストール</a>を参照してください。</li>
<li>(オプション)バージョン1.14から、<code>kubeadm</code>はよく知られたドメインソケットのパスリストを用いて、Linux上のコンテナランタイムの検出を試みます。異なるコンテナランタイムを使用する場合やプロビジョニングするノードに2つ以上のランタイムがインストールされている場合、<code>kubeadm init</code>に<code>--cri-socket</code>引数を指定してください。詳しくは、<a href=/ja/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#installing-runtime>ランタイムのインストール</a>を読んでください。</li>
<li>(オプション)明示的に指定しない限り、<code>kubeadm</code>はデフォルトゲートウェイに関連付けられたネットワークインターフェイスを使用して、この特定のコントロールプレーンノードのAPIサーバーのadvertise addressを設定します。異なるネットワークインターフェイスを使用するには、<code>kubeadm init</code>に<code>--apiserver-advertise-address=&lt;ip-address></code>引数を指定してください。IPv6アドレスを使用するIPv6 Kubernetesクラスターをデプロイするには、たとえば<code>--apiserver-advertise-address=fd00::101</code>のように、IPv6アドレスを指定する必要があります。</li>
<li>(オプション)<code>kubeadm init</code>を実行する前に<code>kubeadm config images pull</code>を実行して、gcr.ioコンテナイメージレジストリに接続できるかどうかを確認します。</li>
</ol>
<p>コントロールプレーンノードを初期化するには、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubeadm init &lt;args&gt;
</code></pre></div><h3 id=apiserver-advertise-addressとcontrolplaneendpointに関する検討>apiserver-advertise-addressとControlPlaneEndpointに関する検討</h3>
<p><code>--apiserver-advertise-address</code>は、この特定のコントロールプレーンノードのAPIサーバーへのadvertise addressを設定するために使えますが、<code>--control-plane-endpoint</code>は、すべてのコントロールプレーンノード共有のエンドポイントを設定するために使えます。</p>
<p><code>--control-plane-endpoint</code>はIPアドレスと、IPアドレスへマッピングできるDNS名を使用できます。利用可能なソリューションをそうしたマッピングの観点から評価するには、ネットワーク管理者に相談してください。</p>
<p>以下にマッピングの例を示します。</p>
<pre><code>192.168.0.102 cluster-endpoint
</code></pre><p>ここでは、<code>192.168.0.102</code>がこのノードのIPアドレスであり、<code>cluster-endpoint</code>がこのIPアドレスへとマッピングされるカスタムDNSネームです。このように設定することで、<code>--control-plane-endpoint=cluster-endpoint</code>を<code>kubeadm init</code>に渡せるようになり、<code>kubeadm join</code>にも同じDNSネームを渡せます。後で<code>cluster-endpoint</code>を修正して、高可用性が必要なシナリオでロードバランサーのアドレスを指すようにすることができます。</p>
<p>kubeadmでは、<code>--control-plane-endpoint</code>を渡さずに構築したシングルコントロールプレーンのクラスターを高可用性クラスターに切り替えることはサポートされていません。</p>
<h3 id=詳細な情報>詳細な情報</h3>
<p><code>kubeadm init</code>の引数のより詳細な情報は、<a href=/docs/reference/setup-tools/kubeadm/kubeadm/>kubeadmリファレンスガイド</a>を参照してください。</p>
<p>設定オプションの全リストは、<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file>設定ファイルのドキュメント</a>で確認できます。</p>
<p>コントロールプレーンコンポーネントやetcdサーバーのliveness probeへのオプションのIPv6の割り当てなど、コントロールプレーンのコンポーネントをカスタマイズしたい場合は、<a href=/ja/docs/setup/production-environment/tools/kubeadm/control-plane-flags/>カスタムの引数</a>に示されている方法で各コンポーネントに追加の引数を与えてください。</p>
<p><code>kubeadm init</code>を再び実行する場合は、初めに<a href=#tear-down>クラスターの破壊</a>を行う必要があります。</p>
<p>もし異なるアーキテクチャのノードをクラスターにjoinさせたい場合は、デプロイしたDaemonSetがそのアーキテクチャ向けのコンテナイメージをサポートしているか確認してください。</p>
<p>初めに<code>kubeadm init</code>は、マシンがKubernetesを実行する準備ができているかを確認する、一連の事前チェックを行います。これらの事前チェックはエラー発生時には警告を表示して終了します。次に、<code>kubeadm init</code>はクラスターのコントロールプレーンのコンポーネントをダウンロードしてインストールします。これには数分掛かるかもしれません。出力は次のようになります。</p>
<pre><code class=language-none data-lang=none>[init] Using Kubernetes version: vX.Y.Z
[preflight] Running pre-flight checks
[preflight] Pulling images required for setting up a Kubernetes cluster
[preflight] This might take a minute or two, depending on the speed of your internet connection
[preflight] You can also perform this action in beforehand using 'kubeadm config images pull'
[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;
[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;
[kubelet-start] Activating the kubelet service
[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;
[certs] Generating &quot;etcd/ca&quot; certificate and key
[certs] Generating &quot;etcd/server&quot; certificate and key
[certs] etcd/server serving cert is signed for DNS names [kubeadm-cp localhost] and IPs [10.138.0.4 127.0.0.1 ::1]
[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key
[certs] Generating &quot;etcd/peer&quot; certificate and key
[certs] etcd/peer serving cert is signed for DNS names [kubeadm-cp localhost] and IPs [10.138.0.4 127.0.0.1 ::1]
[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key
[certs] Generating &quot;ca&quot; certificate and key
[certs] Generating &quot;apiserver&quot; certificate and key
[certs] apiserver serving cert is signed for DNS names [kubeadm-cp kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.138.0.4]
[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key
[certs] Generating &quot;front-proxy-ca&quot; certificate and key
[certs] Generating &quot;front-proxy-client&quot; certificate and key
[certs] Generating &quot;sa&quot; key and public key
[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;
[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file
[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file
[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file
[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file
[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;
[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;
[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;
[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;
[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;
[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s
[apiclient] All control plane components are healthy after 31.501735 seconds
[uploadconfig] storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace
[kubelet] Creating a ConfigMap &quot;kubelet-config-X.Y&quot; in namespace kube-system with the configuration for the kubelets in the cluster
[patchnode] Uploading the CRI Socket information &quot;/var/run/dockershim.sock&quot; to the Node API object &quot;kubeadm-cp&quot; as an annotation
[mark-control-plane] Marking the node kubeadm-cp as control-plane by adding the label &quot;node-role.kubernetes.io/master=''&quot;
[mark-control-plane] Marking the node kubeadm-cp as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]
[bootstrap-token] Using token: &lt;token&gt;
[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles
[bootstraptoken] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials
[bootstraptoken] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token
[bootstraptoken] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster
[bootstraptoken] creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace
[addons] Applied essential addon: CoreDNS
[addons] Applied essential addon: kube-proxy

Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a Pod network to the cluster.
Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:
  /docs/concepts/cluster-administration/addons/

You can now join any number of machines by running the following on each node
as root:

  kubeadm join &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;
</code></pre><p>kubectlをroot以外のユーザーでも実行できるようにするには、次のコマンドを実行します。これらのコマンドは、<code>kubectl init</code>の出力の中にも書かれています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>mkdir -p <span style=color:#b8860b>$HOME</span>/.kube
sudo cp -i /etc/kubernetes/admin.conf <span style=color:#b8860b>$HOME</span>/.kube/config
sudo chown <span style=color:#a2f;font-weight:700>$(</span>id -u<span style=color:#a2f;font-weight:700>)</span>:<span style=color:#a2f;font-weight:700>$(</span>id -g<span style=color:#a2f;font-weight:700>)</span> <span style=color:#b8860b>$HOME</span>/.kube/config
</code></pre></div><p>あなたが<code>root</code>ユーザーである場合は、代わりに次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>/etc/kubernetes/admin.conf
</code></pre></div><p><code>kubeadm init</code>が出力した<code>kubeadm join</code>コマンドをメモしておいてください。<a href=#join-nodes>クラスターにノードを追加する</a>ために、このコマンドが必要になります。</p>
<p>トークンは、コントロールプレーンノードと追加ノードの間の相互認証に使用します。ここに含まれるトークンには秘密の情報が含まれます。このトークンを知っていれば、誰でもクラスターに認証済みノードを追加できてしまうため、取り扱いには注意してください。<code>kubeadm token</code>コマンドを使用すると、これらのトークンの一覧、作成、削除ができます。詳しくは<a href=/docs/reference/setup-tools/kubeadm/kubeadm-token/>kubeadmリファレンスガイド</a>を読んでください。</p>
<h3 id=pod-network>Podネットワークアドオンのインストール</h3>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <p>このセクションには、ネットワークのセットアップとデプロイの順序に関する重要な情報が書かれています。先に進む前に以下のすべてのアドバイスを熟読してください。</p>
<p><strong>Pod同士が通信できるようにするには、<a class=glossary-tooltip title="Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification." data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni target=_blank aria-label="Container Network Interface">Container Network Interface</a>(CNI)をベースとするPodネットワークアドオンをデプロイしなければなりません。ネットワークアドオンをインストールする前には、Cluster DNS(CoreDNS)は起動しません。</strong></p>
<ul>
<li>
<p>Podネットワークがホストネットワークと決して重ならないように気をつけてください。もし重なると、様々な問題が起こってしまう可能性があります。(ネットワークプラグインが優先するPodネットワークとホストのネットワークの一部が衝突することが分かった場合、適切な代わりのCIDRを考える必要があります。そして、<code>kubeadm init</code>の実行時に<code>--pod-network-cidr</code>にそのCIDRを指定し、ネットワークプラグインのYAMLでは代わりにそのCIDRを使用してください)</p>
</li>
<li>
<p>デフォルトでは、<code>kubeadm</code>は<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>(role based access control)の使用を強制します。PodネットワークプラグインがRBACをサポートしていて、またそのデプロイに使用するマニフェストもRBACをサポートしていることを確認してください。</p>
</li>
<li>
<p>クラスターでIPv6を使用したい場合、デュアルスタック、IPv6のみのシングルスタックのネットワークのいずれであっても、PodネットワークプラグインがIPv6をサポートしていることを確認してください。IPv6のサポートは、CNIの<a href=https://github.com/containernetworking/cni/releases/tag/v0.6.0>v0.6.0</a>で追加されました。</p>
</li>
</ul>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 現在、Calicoはkubeadmプロジェクトがe2eテストを実施している唯一のCNIプラグインです。
もしCNIプラグインに関する問題を見つけた場合、kubeadmやkubernetesではなく、そのCNIプラグインの課題管理システムへ問題を報告してください。
</div>
<p>CNIを使用するKubernetes Podネットワークを提供する外部のプロジェクトがいくつかあります。一部のプロジェクトでは、<a href=/ja/docs/concepts/services-networking/network-policies/>ネットワークポリシー</a>もサポートしています。</p>
<p><a href=/ja/docs/concepts/cluster-administration/networking/#how-to-implement-the-kubernetes-networking-model>Kubernetesのネットワークモデル</a>を実装したアドオンの一覧も確認してください。</p>
<p>Podネットワークアドオンをインストールするには、コントロールプレーンノード上またはkubeconfigクレデンシャルを持っているノード上で、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f &lt;add-on.yaml&gt;
</code></pre></div><p>インストールできるPodネットワークは、クラスターごとに1つだけです。</p>
<p>Podネットワークがインストールされたら、<code>kubectl get pods --all-namespaces</code>の出力結果でCoreDNS Podが<code>Running</code>状態であることをチェックすることで、ネットワークが動作していることを確認できます。そして、一度CoreDNS Podが動作すれば、続けてノードを追加できます。</p>
<p>もしネットワークやCoreDNSが<code>Running</code>状態にならない場合は、<code>kubeadm</code>の<a href=/ja/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/>トラブルシューティングガイド</a>をチェックしてください。</p>
<h3 id=コントロールプレーンノードの隔離>コントロールプレーンノードの隔離</h3>
<p>デフォルトでは、セキュリティ上の理由により、クラスターはコントロールプレーンノードにPodをスケジューリングしません。たとえば、開発用のKubernetesシングルマシンのクラスターなどで、Podをコントロールプレーンノードにスケジューリングしたい場合は、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl taint nodes --all node-role.kubernetes.io/master-
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>node &quot;test-01&quot; untainted
taint &quot;node-role.kubernetes.io/master:&quot; not found
taint &quot;node-role.kubernetes.io/master:&quot; not found
</code></pre><p>このコマンドは、コントロールプレーンノードを含むすべてのノードから<code>node-role.kubernetes.io/master</code>taintを削除します。その結果、スケジューラーはどこにでもPodをスケジューリングできるようになります。</p>
<h3 id=join-nodes>ノードの追加</h3>
<p>ノードは、ワークロード(コンテナやPodなど)が実行される場所です。新しいノードをクラスターに追加するためには、各マシンに対して、以下の手順を実行してください。</p>
<ul>
<li>マシンへSSHする</li>
<li>rootになる(例: <code>sudo su -</code>)</li>
<li><code>kubeadm init</code>実行時に出力されたコマンドを実行する。たとえば、次のようなコマンドです。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubeadm join --token &lt;token&gt; &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;
</code></pre></div><p>トークンがわからない場合は、コントロールプレーンノードで次のコマンドを実行すると取得できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubeadm token list
</code></pre></div><p>出力は次のようになります。</p>
<pre><code class=language-console data-lang=console>TOKEN                    TTL  EXPIRES              USAGES           DESCRIPTION            EXTRA GROUPS
8ewj1p.9r9hcjoqgajrj4gi  23h  2018-06-12T02:51:28Z authentication,  The default bootstrap  system:
                                                   signing          token generated by     bootstrappers:
                                                                    'kubeadm init'.        kubeadm:
                                                                                           default-node-token
</code></pre><p>デフォルトでは、トークンは24時間後に有効期限が切れます。もし現在のトークンの有効期限が切れた後にクラスターにノードを参加させたい場合は、コントロールプレーンノードで次のコマンドを実行することで、新しいトークンを生成できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubeadm token create
</code></pre></div><p>このコマンドの出力は次のようになります。</p>
<pre><code class=language-console data-lang=console>5didvk.d09sbcov8ph2amjw
</code></pre><p>もし<code>--discovery-token-ca-cert-hash</code>の値がわからない場合は、コントロールプレーンノード上で次のコマンドチェーンを実行することで取得できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   openssl dgst -sha256 -hex | sed <span style=color:#b44>&#39;s/^.* //&#39;</span>
</code></pre></div><p>出力は次のようになります。</p>
<pre><code class=language-console data-lang=console>8cb2de97839780a412b93877f8507ad6c94f73add17d5d7058e91741c9d5ec78
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> IPv6タプルを<code>&lt;control-plane-host>:&lt;control-plane-port></code>と指定するためには、IPv6アドレスを角括弧で囲みます。たとえば、<code>[fd00::101]:2073</code>のように書きます。
</div>
<p>出力は次のようになります。</p>
<pre><code>[preflight] Running pre-flight checks

... (joinワークフローのログ出力) ...

Node join complete:
* Certificate signing request sent to control-plane and response
  received.
* Kubelet informed of new secure connection details.

Run 'kubectl get nodes' on control-plane to see this machine join.
</code></pre><p>数秒後、コントロールプレーンノード上で<code>kubectl get nodes</code>を実行すると、出力内にこのノードが表示されるはずです。</p>
<h3 id=オプション-コントロールプレーンノード以外のマシンからのクラスター操作>(オプション)コントロールプレーンノード以外のマシンからのクラスター操作</h3>
<p>他のコンピューター(例: ラップトップ)上のkubectlがクラスターと通信できるようにするためには、次のようにして、administratorのkubeconfigファイルをコントロールプレーンノードからそのコンピューター上にコピーする必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>scp root@&lt;control-plane-host&gt;:/etc/kubernetes/admin.conf .
kubectl --kubeconfig ./admin.conf get nodes
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>上の例では、rootユーザーに対するSSH接続が有効であることを仮定しています。もしそうでない場合は、<code>admin.conf</code>ファイルを誰か他のユーザーからアクセスできるようにコピーした上で、代わりにそのユーザーを使って<code>scp</code>してください。</p>
<p><code>admin.conf</code>ファイルはユーザーにクラスターに対する <em>特権ユーザー</em> の権限を与えます。そのため、このファイルを使うのは控えめにしなければなりません。通常のユーザーには、明示的に許可した権限を持つユニークなクレデンシャルを生成することを推奨します。これには、<code>kubeadm alpha kubeconfig user --client-name &lt;CN></code>コマンドが使えます。このコマンドを実行すると、KubeConfigファイルがSTDOUTに出力されるので、ファイルに保存してユーザーに配布します。その後、<code>kubectl create (cluster)rolebinding</code>コマンドを使って権限を付与します。</p>
</div>
<h3 id=オプション-apiサーバーをlocalhostへプロキシする>(オプション)APIサーバーをlocalhostへプロキシする</h3>
<p>クラスターの外部からAPIサーバーに接続したいときは、次のように<code>kubectl proxy</code>コマンドが使えます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>scp root@&lt;control-plane-host&gt;:/etc/kubernetes/admin.conf .
kubectl --kubeconfig ./admin.conf proxy
</code></pre></div><p>これで、ローカルの<code>http://localhost:8001/api/v1</code>からAPIサーバーにアクセスできるようになります。</p>
<h2 id=tear-down>クリーンアップ</h2>
<p>テストのためにクラスターに破棄可能なサーバーを使用した場合、サーバーのスイッチをオフにすれば、以降のクリーンアップの作業は必要ありません。クラスターのローカルの設定を削除するには、<code>kubectl config delete-cluster</code>を実行します。</p>
<p>しかし、もしよりきれいにクラスターのプロビジョンをもとに戻したい場合は、初めに<a href=/docs/reference/generated/kubectl/kubectl-commands#drain>ノードのdrain</a>を行い、ノードが空になっていることを確認した後、ノードの設定を削除する必要があります。</p>
<h3 id=ノードの削除>ノードの削除</h3>
<p>適切なクレデンシャルを使用してコントロールプレーンノードに削除することを伝えます。次のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl drain &lt;node name&gt; --delete-local-data --force --ignore-daemonsets
</code></pre></div><p>ノードが削除される前に、<code>kubeadm</code>によってインストールされた状態をリセットします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubeadm reset
</code></pre></div><p>リセットプロセスでは、iptablesのルールやIPVS tablesのリセットやクリーンアップは行われません。iptablesをリセットしたい場合は、次のように手動でコマンドを実行する必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>iptables -F <span style=color:#666>&amp;&amp;</span> iptables -t nat -F <span style=color:#666>&amp;&amp;</span> iptables -t mangle -F <span style=color:#666>&amp;&amp;</span> iptables -X
</code></pre></div><p>IPVS tablesをリセットしたい場合は、次のコマンドを実行する必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>ipvsadm -C
</code></pre></div><p>ノードを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl delete node &lt;node name&gt;
</code></pre></div><p>クラスターのセットアップを最初から始めたいときは、<code>kubeadm init</code>や<code>kubeadm join</code>を適切な引数を付けて実行すればいいだけです。</p>
<h3 id=コントロールプレーンのクリーンアップ>コントロールプレーンのクリーンアップ</h3>
<p>コントロールホスト上で<code>kubeadm reset</code>を実行すると、ベストエフォートでのクリーンアップが実行できます。</p>
<p>このサブコマンドとオプションに関するより詳しい情報は、<a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset/><code>kubeadm reset</code></a>リファレンスドキュメントを読んでください。</p>
<h2 id=whats-next>次の手順</h2>
<ul>
<li><a href=https://github.com/heptio/sonobuoy>Sonobuoy</a>を使用してクラスターが適切に動作しているか検証する。</li>
<li><a id=lifecycle><code>kubeadm</code>を使用したクラスターをアップグレードする方法について、<a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>kubeadmクラスターをアップグレードする</a>を読む。</li>
<li><code>kubeadm</code>の高度な利用方法について<a href=/docs/reference/setup-tools/kubeadm/kubeadm>kubeadmリファレンスドキュメント</a>で学ぶ。</li>
<li>Kubernetesの<a href=/ja/docs/concepts/>コンセプト</a>や<a href=/ja/docs/reference/kubectl/overview/><code>kubectl</code></a>についてもっと学ぶ。</li>
<li>Podネットワークアドオンのより完全なリストを<a href=/docs/concepts/cluster-administration/networking/>クラスターのネットワーク</a>で確認する。</li>
<li><a id=other-addons>ロギング、モニタリング、ネットワークポリシー、仮想化、Kubernetesクラスターの制御のためのツールなど、その他のアドオンについて、<a href=/docs/concepts/cluster-administration/addons/>アドオンのリスト</a>で確認する。</li>
<li>クラスターイベントやPod内で実行中のアプリケーションから送られるログをクラスターがハンドリングする方法を設定する。関係する要素の概要を理解するために、<a href=/docs/concepts/cluster-administration/logging/>ロギングのアーキテクチャ</a>を読んでください。</li>
</ul>
<h3 id=feedback>フィードバック</h3>
<ul>
<li>バグを見つけた場合は、<a href=https://github.com/kubernetes/kubeadm/issues>kubeadm GitHub issue tracker</a>で報告してください。</li>
<li>サポートを受けたい場合は、<a href=https://kubernetes.slack.com/messages/kubeadm/>#kubeadm</a>Slackチャンネルを訪ねてください。</li>
<li>General SIG Cluster Lifecycle development Slackチャンネル:
<a href=https://kubernetes.slack.com/messages/sig-cluster-lifecycle/>#sig-cluster-lifecycle</a></li>
<li>SIG Cluster Lifecycle <a href=https://github.com/kubernetes/community/tree/master/sig-cluster-lifecycle#readme>SIG information</a></li>
<li>SIG Cluster Lifecycleメーリングリスト:
<a href=https://groups.google.com/forum/#!forum/kubernetes-sig-cluster-lifecycle>kubernetes-sig-cluster-lifecycle</a></li>
</ul>
<h2 id=version-skew-policy>バージョン互換ポリシー</h2>
<p>バージョンv1.26の<code>kubeadm</code>ツールは、バージョンv1.26またはv1.25のコントロールプレーンを持つクラスターをデプロイできます。また、バージョンv1.26の<code>kubeadm</code>は、バージョンv1.25のkubeadmで構築されたクラスターをアップグレートできます。</p>
<p>未来を見ることはできないため、kubeadm CLI v1.26はv1.27をデプロイできないかもしれません。</p>
<p>例: <code>kubeadm</code> v1.8は、v1.7とv1.8のクラスターをデプロイでき、v1.7のkubeadmで構築されたクラスターをv1.8にアップグレートできます。</p>
<p>kubeletとコントロールプレーンの間や、他のKubernetesコンポーネント間のバージョンの差異に関する詳しい情報は、以下の資料を確認してください。</p>
<ul>
<li>Kubernetes<a href=/ja/docs/setup/release/version-skew-policy/>バージョンスキューサポートポリシー</a></li>
<li>Kubeadm特有の<a href=/ja/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#installing-kubeadm-kubelet-and-kubectl>インストールガイド</a></li>
</ul>
<h2 id=limitations>制限事項</h2>
<h3 id=resilience>クラスターのレジリエンス</h3>
<p>ここで作られたクラスターは、1つのコントロールプレーンノードと、その上で動作する1つのetcdデータベースしか持ちません。つまり、コントロールプレーンノードが故障した場合、クラスターのデータは失われ、クラスターを最初から作り直す必要があるかもしれないということです。</p>
<p>対処方法:</p>
<ul>
<li>
<p>定期的に<a href=https://coreos.com/etcd/docs/latest/admin_guide.html>etcdをバックアップ</a>する。kubeadmが設定するetcdのデータディレクトリは、コントロールプレーンノードの<code>/var/lib/etcd</code>にあります。</p>
</li>
<li>
<p>複数のコントロールプレーンノードを使用する。<a href=/ja/docs/setup/production-environment/tools/kubeadm/ha-topology/>高可用性トポロジーのオプション</a>では、<a href=/ja/docs/setup/production-environment/tools/kubeadm/high-availability/>より高い可用性</a>を提供するクラスターのトポロジーの選択について説明してます。</p>
</li>
</ul>
<h3 id=multi-platform>プラットフォームの互換性</h3>
<p>kubeadmのdeb/rpmパッケージおよびバイナリは、<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/multi-platform.md>multi-platform proposal</a>に従い、amd64、arm(32ビット)、arm64、ppc64le、およびs390x向けにビルドされています。</p>
<p>マルチプラットフォームのコントロールプレーンおよびアドオン用のコンテナイメージも、v1.12からサポートされています。</p>
<p>すべてのプラットフォーム向けのソリューションを提供しているネットワークプロバイダーは一部のみです。それぞれのプロバイダーが選択したプラットフォームをサポートしているかどうかを確認するには、前述のネットワークプロバイダーのリストを参照してください。</p>
<h2 id=troubleshooting>トラブルシューティング</h2>
<p>kubeadmに関する問題が起きたときは、<a href=/ja/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/>トラブルシューティングドキュメント</a>を確認してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4c656c5eda3e1c06ad1aedebdc04a211>2.3.2.1.4 - kubeadmを使ったコントロールプレーンの設定のカスタマイズ</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes 1.12 [stable]</code>
</div>
<p>kubeadmの<code>ClusterConfiguration</code>オブジェクトはAPIServer、ControllerManager、およびSchedulerのようなコントロールプレーンの構成要素に渡されたデフォルトのフラグを上書きすることができる <code>extraArgs</code>の項目があります。
その構成要素は次の項目で定義されています。</p>
<ul>
<li><code>apiServer</code></li>
<li><code>controllerManager</code></li>
<li><code>scheduler</code></li>
</ul>
<p><code>extraArgs</code> の項目は <code>キー: 値</code> のペアです。コントロールプレーンの構成要素のフラグを上書きするには:</p>
<ol>
<li>設定内容に適切な項目を追加</li>
<li>フラグを追加して項目を上書き</li>
<li><code>--config &lt;任意の設定YAMLファイル></code>で<code>kubeadm init</code>を実行</li>
</ol>
<p>各設定項目のより詳細な情報は<a href=https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#ClusterConfiguration>APIリファレンスのページ</a>を参照してください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>kubeadm config print init-defaults</code>を実行し、選択したファイルに出力を保存することで、デフォルト値で<code>ClusterConfiguration</code>オブジェクトを生成できます。
</div>
<h2 id=apiserverフラグ>APIServerフラグ</h2>
<p>詳細は<a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserverのリファレンスドキュメント</a>を参照してください。</p>
<p>使用例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kubernetesVersion</span>:<span style=color:#bbb> </span>v1.16.0<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiServer</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>advertise-address</span>:<span style=color:#bbb> </span><span style=color:#666>192.168.0.103</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>anonymous-auth</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;false&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>enable-admission-plugins</span>:<span style=color:#bbb> </span>AlwaysPullImages,DefaultStorageClass<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>audit-log-path</span>:<span style=color:#bbb> </span>/home/johndoe/audit.log<span style=color:#bbb>
</span></code></pre></div><h2 id=controllermanagerフラグ>ControllerManagerフラグ</h2>
<p>詳細は<a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-managerのリファレンスドキュメント</a>を参照してください。</p>
<p>使用例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kubernetesVersion</span>:<span style=color:#bbb> </span>v1.16.0<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>controllerManager</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster-signing-key-file</span>:<span style=color:#bbb> </span>/home/johndoe/keys/ca.key<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>bind-address</span>:<span style=color:#bbb> </span><span style=color:#666>0.0.0.0</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>deployment-controller-sync-period</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=schedulerフラグ>Schedulerフラグ</h2>
<p>詳細は<a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-schedulerのリファレンスドキュメント</a>を参照してください。</p>
<p>使用例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kubernetesVersion</span>:<span style=color:#bbb> </span>v1.16.0<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>scheduler</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>bind-address</span>:<span style=color:#bbb> </span><span style=color:#666>0.0.0.0</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>config</span>:<span style=color:#bbb> </span>/home/johndoe/schedconfig.yaml<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeconfig</span>:<span style=color:#bbb> </span>/home/johndoe/kubeconfig.yaml<span style=color:#bbb>
</span></code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-015edbc7cc688d31b1d1edce7c186135>2.3.2.1.5 - 高可用性トポロジーのためのオプション</h1>
<p>このページでは、高可用性(HA)Kubernetesクラスターのトポロジーを設定するための2つのオプションについて説明します。</p>
<p>HAクラスターは次の方法で設定できます。</p>
<ul>
<li>積層コントロールプレーンノードを使用する方法。こちらの場合、etcdノードはコントロールプレーンノードと同じ場所で動作します。</li>
<li>外部のetcdノードを使用する方法。こちらの場合、etcdがコントロールプレーンとは分離されたノードで動作します。</li>
</ul>
<p>HAクラスターをセットアップする前に、各トポロジーの利点と欠点について注意深く考慮する必要があります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> kubeadmは、etcdクラスターを静的にブートストラップします。
詳細については、etcd<a href=https://github.com/etcd-io/etcd/blob/release-3.4/Documentation/op-guide/clustering.md#static>クラスタリングガイド</a>をご覧ください。
</div>
<h2 id=積層etcdトポロジー>積層etcdトポロジー</h2>
<p>積層HAクラスターは、コントロールプレーンのコンポーネントを実行する、kubeadmで管理されたノードで構成されるクラスターの上に、etcdにより提供される分散データストレージクラスターがあるような<a href=https://en.wikipedia.org/wiki/Network_topology>トポロジー</a>です。</p>
<p>各コントロールプレーンノードは、<code>kube-apiserver</code>、<code>kube-scheduler</code>、および<code>kube-controller-manager</code>を実行します。<code>kube-apiserver</code> はロードバランサーを用いてワーカーノードに公開されます。</p>
<p>各コントロールプレーンノードはローカルのetcdメンバーを作り、このetcdメンバーはそのノードの<code>kube-apiserver</code>とだけ通信します。ローカルの<code>kube-controller-manager</code>と<code>kube-scheduler</code>のインスタンスも同様です。</p>
<p>このトポロジーは、同じノード上のコントロールプレーンとetcdのメンバーを結合します。外部のetcdノードを使用するクラスターよりはセットアップがシンプルで、レプリケーションの管理もシンプルです。</p>
<p>しかし、積層クラスターには、結合による故障のリスクがあります。1つのノードがダウンすると、etcdメンバーとコントロールプレーンのインスタンスの両方が失われ、冗長性が損なわれます。より多くのコントロールプレーンノードを追加することで、このリスクは緩和できます。</p>
<p>そのため、HAクラスターのためには、最低でも3台の積層コントロールプレーンノードを実行しなければなりません。</p>
<p>これがkubeadmのデフォルトのトポロジーです。<code>kubeadm init</code>や<code>kubeadm join --control-place</code>を実行すると、ローカルのetcdメンバーがコントロールプレーンノード上に自動的に作成されます。</p>
<p><img src=/images/kubeadm/kubeadm-ha-topology-stacked-etcd.svg alt=積層etcdトポロジー></p>
<h2 id=外部のetcdトポロジー>外部のetcdトポロジー</h2>
<p>外部のetcdを持つHAクラスターは、コントロールプレーンコンポーネントを実行するノードで構成されるクラスターの外部に、etcdにより提供される分散データストレージクラスターがあるような<a href=https://en.wikipedia.org/wiki/Network_topology>トポロジー</a>です。</p>
<p>積層etcdトポロジーと同様に、外部のetcdトポロジーにおける各コントロールプレーンノードは、<code>kube-apiserver</code>、<code>kube-scheduler</code>、および<code>kube-controller-manager</code>のインスタンスを実行します。そして、<code>kube-apiserver</code>は、ロードバランサーを使用してワーカーノードに公開されます。しかし、etcdメンバーは異なるホスト上で動作しており、各etcdホストは各コントロールプレーンノードの<code>kube-api-server</code>と通信します。</p>
<p>このトポロジーは、コントロールプレーンとetcdメンバーを疎結合にします。そのため、コントロールプレーンインスタンスまたはetcdメンバーを失うことによる影響は少なく、積層HAトポロジーほどクラスターの冗長性に影響しないHAセットアップが実現します。</p>
<p>しかし、このトポロジーでは積層HAトポロジーの2倍の数のホストを必要とします。このトポロジーのHAクラスターのためには、最低でもコントロールプレーンのために3台のホストが、etcdノードのために3台のホストがそれぞれ必要です。</p>
<p><img src=/images/kubeadm/kubeadm-ha-topology-external-etcd.svg alt=外部のetcdトポロジー></p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/setup/production-environment/tools/kubeadm/high-availability/>kubeadmを使用した高可用性クラスターの作成</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3941d5c3409342219bf7e03128b8ecb6>2.3.2.1.6 - kubeadmを使用した高可用性クラスターの作成</h1>
<p>このページでは、kubeadmを使用して、高可用性クラスターを作成する、2つの異なるアプローチを説明します:</p>
<ul>
<li>積層コントロールプレーンノードを使う方法。こちらのアプローチは、必要なインフラストラクチャーが少ないです。etcdのメンバーと、コントロールプレーンノードは同じ場所に置かれます。</li>
<li>外部のetcdクラスターを使う方法。こちらのアプローチには、より多くのインフラストラクチャーが必要です。コントロールプレーンノードと、etcdのメンバーは分離されます。</li>
</ul>
<p>先へ進む前に、どちらのアプローチがアプリケーションの要件と、環境に適合するか、慎重に検討してください。<a href=/ja/docs/setup/production-environment/tools/kubeadm/ha-topology/>こちらの比較</a>が、それぞれの利点/欠点について概説しています。</p>
<p>高可用性クラスターの作成で問題が発生した場合は、kueadmの<a href=https://github.com/kubernetes/kubeadm/issues/new>issue tracker</a>でフィードバックを提供してください。</p>
<p><a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>高可用性クラスターのアップグレード</a>も参照してください。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> このページはクラウド上でクラスターを構築することには対応していません。ここで説明されているどちらのアプローチも、クラウド上で、LoadBalancerタイプのServiceオブジェクトや、動的なPersistentVolumeを利用して動かすことはできません。
</div>
<h2 id=始める前に>始める前に</h2>
<p>どちらの方法でも、以下のインフラストラクチャーが必要です:</p>
<ul>
<li>master用に、<a href=/ja/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%E5%A7%8B%E3%82%81%E3%82%8B%E5%89%8D%E3%81%AB>kubeadmの最小要件</a>を満たす3台のマシン</li>
<li>worker用に、<a href=/ja/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%E5%A7%8B%E3%82%81%E3%82%8B%E5%89%8D%E3%81%AB>kubeadmの最小要件</a>を満たす3台のマシン</li>
<li>クラスター内のすべてのマシン間がフルにネットワーク接続可能であること(パブリック、もしくはプライベートネットワーク)</li>
<li>すべてのマシンにおいて、sudo権限</li>
<li>あるデバイスから、システム内のすべてのノードに対しSSH接続できること</li>
<li><code>kubeadm</code>と<code>kubelet</code>がすべてのマシンにインストールされていること。 <code>kubectl</code>は任意です。</li>
</ul>
<p>外部etcdクラスターには、以下も必要です:</p>
<ul>
<li>etcdメンバー用に、追加で3台のマシン</li>
</ul>
<h2 id=両手順における最初のステップ>両手順における最初のステップ</h2>
<h3 id=kube-apiserver用にロードバランサーを作成>kube-apiserver用にロードバランサーを作成</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ロードバランサーには多くの設定項目があります。以下の例は、一選択肢に過ぎません。あなたのクラスター要件には、異なった設定が必要かもしれません。
</div>
<ol>
<li>
<p>DNSで解決される名前で、kube-apiserver用ロードバランサーを作成する。</p>
<ul>
<li>
<p>クラウド環境では、コントロールプレーンノードをTCPフォワーディングロードバランサーの後ろに置かなければなりません。このロードバランサーはターゲットリストに含まれる、すべての健全なコントロールプレーンノードにトラフィックを分配します。apiserverへのヘルスチェックはkube-apiserverがリッスンするポート(デフォルト値: <code>:6443</code>)に対する、TCPチェックです。</p>
</li>
<li>
<p>クラウド環境では、IPアドレスを直接使うことは推奨されません。</p>
</li>
<li>
<p>ロードバランサーは、apiserverポートで、全てのコントロールプレーンノードと通信できなければなりません。また、リスニングポートに対する流入トラフィックも許可されていなければなりません。</p>
</li>
<li>
<p>ロードバランサーのアドレスは、常にkubeadmの<code>ControlPlaneEndpoint</code>のアドレスと一致することを確認してください。</p>
</li>
<li>
<p>詳細は<a href=https://github.com/kubernetes/kubeadm/blob/master/docs/ha-considerations.md#options-for-software-load-balancing>Options for Software Load Balancing</a>をご覧ください。</p>
</li>
</ul>
</li>
<li>
<p>ロードバランサーに、最初のコントロールプレーンノードを追加し、接続をテストする:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>nc -v LOAD_BALANCER_IP PORT
</code></pre></div><ul>
<li>apiserverはまだ動いていないので、接続の拒否は想定通りです。しかし、タイムアウトしたのであれば、ロードバランサーはコントロールプレーンノードと通信できなかったことを意味します。もし、タイムアウトが起きたら、コントロールプレーンノードと通信できるように、ロードバランサーを再設定してください。</li>
</ul>
</li>
<li>
<p>残りのコントロールプレーンノードを、ロードバランサーのターゲットグループに追加します。</p>
</li>
</ol>
<h2 id=積層コントロールプレーンとetcdノード>積層コントロールプレーンとetcdノード</h2>
<h3 id=最初のコントロールプレーンノードの手順>最初のコントロールプレーンノードの手順</h3>
<ol>
<li>
<p>最初のコントロールプレーンノードを初期化します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>sudo kubeadm init --control-plane-endpoint <span style=color:#b44>&#34;LOAD_BALANCER_DNS:LOAD_BALANCER_PORT&#34;</span> --upload-certs
</code></pre></div><ul>
<li><code>--kubernetes-version</code>フラグで使用するKubernetesのバージョンを設定できます。kubeadm、kubelet、kubectl、Kubernetesのバージョンを一致させることが推奨されます。</li>
<li><code>--control-plane-endpoint</code>フラグは、ロードバランサーのIPアドレスまたはDNS名と、ポートが設定される必要があります。</li>
<li><code>--upload-certs</code>フラグは全てのコントロールプレーンノードで共有する必要がある証明書をクラスターにアップロードするために使用されます。代わりに、コントロールプレーンノード間で手動あるいは自動化ツールを使用して証明書をコピーしたい場合は、このフラグを削除し、以下の<a href=#manual-certs>証明書の手動配布</a>のセクションを参照してください。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>kubeadm init</code>の<code>--config</code>フラグと<code>--certificate-key</code>フラグは混在させることはできないため、<a href=https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2>kubeadm configuration</a>を使用する場合は<code>certificateKey</code>フィールドを適切な場所に追加する必要があります(<code>InitConfiguration</code>と<code>JoinConfiguration: controlPlane</code>の配下)。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> いくつかのCNIネットワークプラグインはPodのIPのCIDRの指定など追加の設定を必要としますが、必要としないプラグインもあります。<a href=/ja/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network>CNIネットワークドキュメント</a>を参照してください。PodにCIDRを設定するには、<code>ClusterConfiguration</code>の<code>networking</code>オブジェクトに<code>podSubnet: 192.168.0.0/16</code>フィールドを設定してください。
</div>
<ul>
<li>このような出力がされます:</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>...
You can now join any number of control-plane node by running the following <span style=color:#a2f>command</span> on each as a root:
    kubeadm join 192.168.0.200:6443 --token 9vr73a.a8uxyaju799qwdjv --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866 --control-plane --certificate-key f8902e114ef118304e561c3ecd4d0b543adc226b7a07f675f56564185ffe0c07

Please note that the certificate-key gives access to cluster sensitive data, keep it secret!
As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use kubeadm init phase upload-certs to reload certs afterward.

Then you can join any number of worker nodes by running the following on each as root:
    kubeadm join 192.168.0.200:6443 --token 9vr73a.a8uxyaju799qwdjv --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866
</code></pre></div><ul>
<li>
<p>この出力をテキストファイルにコピーします。あとで、他のコントロールプレーンノードとワーカーノードをクラスターに参加させる際に必要です。</p>
</li>
<li>
<p><code>--upload-certs</code>フラグを<code>kubeadm init</code>で使用すると、プライマリコントロールプレーンの証明書が暗号化されて、<code>kubeadm-certs</code> Secretにアップロードされます。</p>
</li>
<li>
<p>証明書を再アップロードして新しい復号キーを生成するには、すでにクラスターに参加しているコントロールプレーンノードで次のコマンドを使用します:</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>sudo kubeadm init phase upload-certs --upload-certs
</code></pre></div><ul>
<li>また、後で<code>join</code>で使用できるように、<code>init</code>中にカスタムした<code>--certificate-key</code>を指定することもできます。このようなキーを生成するには、次のコマンドを使用します:</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubeadm alpha certs certificate-key
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>kubeadm-certs</code>のSecretと復号キーは2時間で期限切れとなります。
</div>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> コマンド出力に記載されているように、証明書キーはクラスターの機密データへのアクセスを提供します。秘密にしてください！
</div>
</li>
<li>
<p>使用するCNIプラグインを適用します:<br>
<a href=/ja/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network>こちらの手順に従い</a>CNIプロバイダーをインストールします。該当する場合は、kubeadmの設定で指定されたPodのCIDRに対応していることを確認してください。</p>
<p>Weave Netを使用する場合の例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl apply -f <span style=color:#b44>&#34;https://cloud.weave.works/k8s/net?k8s-version=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl version | base64 | tr -d <span style=color:#b44>&#39;\n&#39;</span><span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</code></pre></div></li>
<li>
<p>以下のコマンドを入力し、コンポーネントのPodが起動するのを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl get pod -n kube-system -w
</code></pre></div></li>
</ol>
<h3 id=残りのコントロールプレーンノードの手順>残りのコントロールプレーンノードの手順</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> kubeadmバージョン1.15以降、複数のコントロールプレーンノードを並行してクラスターに参加させることができます。
このバージョンの前は、最初のノードの初期化が完了した後でのみ、新しいコントロールプレーンノードを順番にクラスターに参加させる必要があります。
</div>
<p>追加のコントロールプレーンノード毎に、以下の手順を行います。</p>
<ol>
<li>
<p><code>kubeadm init</code>を最初のノードで実行した際に取得したjoinコマンドを使って、新しく追加するコントロールプレーンノードで<code>kubeadm join</code>を開始します。このようなコマンドになるはずです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>sudo kubeadm join 192.168.0.200:6443 --token 9vr73a.a8uxyaju799qwdjv --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866 --control-plane --certificate-key f8902e114ef118304e561c3ecd4d0b543adc226b7a07f675f56564185ffe0c07
</code></pre></div><ul>
<li><code>--control-plane</code>フラグによって、<code>kubeadm join</code>の実行は新しいコントロールプレーンを作成します。</li>
<li><code>-certificate-key ...</code>を指定したキーを使って、クラスターの<code>kubeadm-certs</code> Secretからダウンロードされたコントロールプレーンの証明書が復号されます。</li>
</ul>
</li>
</ol>
<h2 id=外部のetcdノード>外部のetcdノード</h2>
<p>外部のetcdノードを使ったクラスターの設定は、積層etcdの場合と似ていますが、最初にetcdを設定し、kubeadmの設定ファイルにetcdの情報を渡す必要があります。</p>
<h3 id=etcdクラスターの構築>etcdクラスターの構築</h3>
<ol>
<li>
<p><a href=/ja/docs/setup/production-environment/tools/kubeadm/setup-ha-etcd-with-kubeadm/>こちらの手順</a>にしたがって、etcdクラスターを構築してください。</p>
</li>
<li>
<p><a href=#manual-certs>こちらの手順</a>にしたがって、SSHを構築してください。</p>
</li>
<li>
<p>以下のファイルをクラスター内の任意のetcdノードから最初のコントロールプレーンノードにコピーしてください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#a2f>export</span> <span style=color:#b8860b>CONTROL_PLANE</span><span style=color:#666>=</span><span style=color:#b44>&#34;ubuntu@10.0.0.7&#34;</span>
scp /etc/kubernetes/pki/etcd/ca.crt <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTROL_PLANE</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>:
scp /etc/kubernetes/pki/apiserver-etcd-client.crt <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTROL_PLANE</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>:
scp /etc/kubernetes/pki/apiserver-etcd-client.key <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTROL_PLANE</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>:
</code></pre></div><ul>
<li><code>CONTROL_PLANE</code>の値を、最初のコントロールプレーンノードの<code>user@host</code>で置き換えます。</li>
</ul>
</li>
</ol>
<h3 id=最初のコントロールプレーンノードの構築>最初のコントロールプレーンノードの構築</h3>
<ol>
<li>
<p>以下の内容で、<code>kubeadm-config.yaml</code>という名前の設定ファイルを作成します:</p>
<pre><code>apiVersion: kubeadm.k8s.io/v1beta2
kind: ClusterConfiguration
kubernetesVersion: stable
controlPlaneEndpoint: &quot;LOAD_BALANCER_DNS:LOAD_BALANCER_PORT&quot;
etcd:
    external:
        endpoints:
        - https://ETCD_0_IP:2379
        - https://ETCD_1_IP:2379
        - https://ETCD_2_IP:2379
        caFile: /etc/kubernetes/pki/etcd/ca.crt
        certFile: /etc/kubernetes/pki/apiserver-etcd-client.crt
        keyFile: /etc/kubernetes/pki/apiserver-etcd-client.key
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ここで、積層etcdと外部etcdの違いは、外部etcdの構成では<code>etcd</code>の<code>external</code>オブジェクトにetcdのエンドポイントが記述された設定ファイルが必要です。積層etcdトポロジーの場合、これは自動で管理されます。
</div>
<ul>
<li>
<p>テンプレート内の以下の変数を、クラスターに合わせて適切な値に置き換えます:</p>
<ul>
<li><code>LOAD_BALANCER_DNS</code></li>
<li><code>LOAD_BALANCER_PORT</code></li>
<li><code>ETCD_0_IP</code></li>
<li><code>ETCD_1_IP</code></li>
<li><code>ETCD_2_IP</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>以下の手順は、積層etcdの構築と同様です。</p>
<ol>
<li>
<p><code>sudo kubeadm init --config kubeadm-config.yaml --upload-certs</code>をこのノードで実行します。</p>
</li>
<li>
<p>表示されたjoinコマンドを、あとで使うためにテキストファイルに書き込みます。</p>
</li>
<li>
<p>使用するCNIプラグインを適用します。以下はWeave CNIの場合です:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl apply -f <span style=color:#b44>&#34;https://cloud.weave.works/k8s/net?k8s-version=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl version | base64 | tr -d <span style=color:#b44>&#39;\n&#39;</span><span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</code></pre></div></li>
</ol>
<h3 id=残りのコントロールプレーンノードの手順-1>残りのコントロールプレーンノードの手順</h3>
<p>手順は、積層etcd構築の場合と同じです:</p>
<ul>
<li>最初のコントロールプレーンノードが完全に初期化されているのを確認します。</li>
<li>テキストファイルに保存したjoinコマンドを使って、それぞれのコントロールプレーンノードをクラスターへ参加させます。コントロールプレーンノードは1台ずつクラスターへ参加させるのを推奨します。</li>
<li><code>--certificate-key</code>で指定する復号キーは、デフォルトで2時間で期限切れになることを忘れないでください。</li>
</ul>
<h2 id=コントロールプレーン起動後の共通タスク>コントロールプレーン起動後の共通タスク</h2>
<h3 id=workerのインストール>workerのインストール</h3>
<p><code>kubeadm init</code>コマンドから返されたコマンドを利用して、workerノードをクラスターに参加させることが可能です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>sudo kubeadm join 192.168.0.200:6443 --token 9vr73a.a8uxyaju799qwdjv --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866
</code></pre></div><h2 id=manual-certs>証明書の手動配布</h2>
<p><code>--upload-certs</code>フラグを指定して<code>kubeadm init</code>を実行しない場合、プライマリコントロールプレーンノードから他のコントロールプレーンノードへ証明書を手動でコピーする必要があります。</p>
<p>コピーを行うには多くの方法があります。次の例では<code>ssh</code>と<code>scp</code>を使用しています。</p>
<p>1台のマシンから全てのノードをコントロールしたいのであれば、SSHが必要です。</p>
<ol>
<li>
<p>システム内の全ての他のノードにアクセスできるメインデバイスで、ssh-agentを有効にします</p>
<pre><code>eval $(ssh-agent)
</code></pre></li>
<li>
<p>SSHの秘密鍵を、セッションに追加します:</p>
<pre><code>ssh-add ~/.ssh/path_to_private_key
</code></pre></li>
<li>
<p>正常に接続できることを確認するために、ノード間でSSHします。</p>
<ul>
<li>
<p>ノードにSSHする際は、必ず<code>-A</code>フラグをつけます:</p>
<pre><code>ssh -A 10.0.0.7
</code></pre></li>
<li>
<p>ノードでsudoするときは、SSHフォワーディングが動くように、環境変数を引き継ぎます:</p>
<pre><code>sudo -E -s
</code></pre></li>
</ul>
</li>
<li>
<p>全てのノードでSSHを設定したら、<code>kubeadm init</code>を実行した後、最初のコントロールノードプレーンノードで次のスクリプトを実行します。このスクリプトは、最初のコントロールプレーンノードから残りのコントロールプレーンノードへ証明書ファイルをコピーします:</p>
<p>次の例の、<code>CONTROL_PLANE_IPS</code>を他のコントロールプレーンノードのIPアドレスに置き換えます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#b8860b>USER</span><span style=color:#666>=</span>ubuntu <span style=color:#080;font-style:italic># 環境に合わせる</span>
<span style=color:#b8860b>CONTROL_PLANE_IPS</span><span style=color:#666>=</span><span style=color:#b44>&#34;10.0.0.7 10.0.0.8&#34;</span>
<span style=color:#a2f;font-weight:700>for</span> host in <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTROL_PLANE_IPS</span><span style=color:#b68;font-weight:700>}</span>; <span style=color:#a2f;font-weight:700>do</span>
    scp /etc/kubernetes/pki/ca.crt <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:
    scp /etc/kubernetes/pki/ca.key <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:
    scp /etc/kubernetes/pki/sa.key <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:
    scp /etc/kubernetes/pki/sa.pub <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:
    scp /etc/kubernetes/pki/front-proxy-ca.crt <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:
    scp /etc/kubernetes/pki/front-proxy-ca.key <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:
    scp /etc/kubernetes/pki/etcd/ca.crt <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:etcd-ca.crt
    <span style=color:#080;font-style:italic># 外部のetcdノード使用時はこちらのコマンドを実行</span>
    scp /etc/kubernetes/pki/etcd/ca.key <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:etcd-ca.key
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> 上のリストにある証明書だけをコピーしてください。kubeadmが、参加するコントロールプレーンノード用に、残りの証明書と必要なSANの生成を行います。間違って全ての証明書をコピーしてしまったら、必要なSANがないため、追加ノードの作成は失敗するかもしれません。
</div>
</li>
<li>
<p>次に、クラスターに参加させる残りの各コントロールプレーンノードで<code>kubeadm join</code>を実行する前に次のスクリプトを実行する必要があります。このスクリプトは、前の手順でコピーした証明書をホームディレクトリから<code>/etc/kubernetes/pki</code>へ移動します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#b8860b>USER</span><span style=color:#666>=</span>ubuntu <span style=color:#080;font-style:italic># 環境に合わせる</span>
mkdir -p /etc/kubernetes/pki/etcd
mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/ca.crt /etc/kubernetes/pki/
mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/ca.key /etc/kubernetes/pki/
mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/sa.pub /etc/kubernetes/pki/
mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/sa.key /etc/kubernetes/pki/
mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/front-proxy-ca.crt /etc/kubernetes/pki/
mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/front-proxy-ca.key /etc/kubernetes/pki/
mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/etcd-ca.crt /etc/kubernetes/pki/etcd/ca.crt
<span style=color:#080;font-style:italic># 外部のetcdノード使用時はこちらのコマンドを実行</span>
mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/etcd-ca.key /etc/kubernetes/pki/etcd/ca.key
</code></pre></div></li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8160424c22d24f7d2d63c521e107dbf8>2.3.2.1.7 - kubeadmを使用した高可用性etcdクラスターの作成</h1>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> While kubeadm is being used as the management tool for external etcd nodes
in this guide, please note that kubeadm does not plan to support certificate rotation
or upgrades for such nodes. The long term plan is to empower the tool
<a href=https://github.com/kubernetes-sigs/etcdadm>etcdadm</a> to manage these
aspects.
</div>
<p>Kubeadm defaults to running a single member etcd cluster in a static pod managed
by the kubelet on the control plane node. This is not a high availability setup
as the etcd cluster contains only one member and cannot sustain any members
becoming unavailable. This task walks through the process of creating a high
availability etcd cluster of three members that can be used as an external etcd
when using kubeadm to set up a kubernetes cluster.</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>Three hosts that can talk to each other over ports 2379 and 2380. This
document assumes these default ports. However, they are configurable through
the kubeadm config file.</li>
<li>Each host must <a href=/docs/setup/production-environment/tools/kubeadm/install-kubeadm/>have docker, kubelet, and kubeadm installed</a>.</li>
<li>Each host should have access to the Kubernetes container image registry (<code>k8s.gcr.io</code>) or list/pull the required etcd image using <code>kubeadm config images list/pull</code>. This guide will setup etcd instances as <a href=/docs/tasks/configure-pod-container/static-pod/>static pods</a> managed by a kubelet.</li>
<li>Some infrastructure to copy files between hosts. For example <code>ssh</code> and <code>scp</code>
can satisfy this requirement.</li>
</ul>
<h2 id=クラスターの構築>クラスターの構築</h2>
<p>The general approach is to generate all certs on one node and only distribute
the <em>necessary</em> files to the other nodes.</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> kubeadm contains all the necessary crytographic machinery to generate
the certificates described below; no other cryptographic tooling is required for
this example.
</div>
<ol>
<li>
<p>Configure the kubelet to be a service manager for etcd.</p>
<p>Since etcd was created first, you must override the service priority by creating a new unit file
that has higher precedence than the kubeadm-provided kubelet unit file.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>cat <span style=color:#b44>&lt;&lt; EOF &gt; /etc/systemd/system/kubelet.service.d/20-etcd-service-manager.conf
</span><span style=color:#b44>[Service]
</span><span style=color:#b44>ExecStart=
</span><span style=color:#b44>#  Replace &#34;systemd&#34; with the cgroup driver of your container runtime. The default value in the kubelet is &#34;cgroupfs&#34;.
</span><span style=color:#b44>ExecStart=/usr/bin/kubelet --address=127.0.0.1 --pod-manifest-path=/etc/kubernetes/manifests --cgroup-driver=systemd
</span><span style=color:#b44>Restart=always
</span><span style=color:#b44>EOF</span>

systemctl daemon-reload
systemctl restart kubelet
</code></pre></div></li>
<li>
<p>Create configuration files for kubeadm.</p>
<p>Generate one kubeadm configuration file for each host that will have an etcd
member running on it using the following script.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#080;font-style:italic># Update HOST0, HOST1, and HOST2 with the IPs or resolvable names of your hosts</span>
<span style=color:#a2f>export</span> <span style=color:#b8860b>HOST0</span><span style=color:#666>=</span>10.0.0.6
<span style=color:#a2f>export</span> <span style=color:#b8860b>HOST1</span><span style=color:#666>=</span>10.0.0.7
<span style=color:#a2f>export</span> <span style=color:#b8860b>HOST2</span><span style=color:#666>=</span>10.0.0.8

<span style=color:#080;font-style:italic># Create temp directories to store files that will end up on other hosts.</span>
mkdir -p /tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST0</span><span style=color:#b68;font-weight:700>}</span>/ /tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST1</span><span style=color:#b68;font-weight:700>}</span>/ /tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST2</span><span style=color:#b68;font-weight:700>}</span>/

<span style=color:#b8860b>ETCDHOSTS</span><span style=color:#666>=(</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST0</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST1</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST2</span><span style=color:#b68;font-weight:700>}</span><span style=color:#666>)</span>
<span style=color:#b8860b>NAMES</span><span style=color:#666>=(</span><span style=color:#b44>&#34;infra0&#34;</span> <span style=color:#b44>&#34;infra1&#34;</span> <span style=color:#b44>&#34;infra2&#34;</span><span style=color:#666>)</span>

<span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span>!ETCDHOSTS[@]<span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>; <span style=color:#a2f;font-weight:700>do</span>
<span style=color:#b8860b>HOST</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ETCDHOSTS</span>[<span style=color:#b8860b>$i</span>]<span style=color:#b68;font-weight:700>}</span>
<span style=color:#b8860b>NAME</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>NAMES</span>[<span style=color:#b8860b>$i</span>]<span style=color:#b68;font-weight:700>}</span>
cat <span style=color:#b44>&lt;&lt; EOF &gt; /tmp/${HOST}/kubeadmcfg.yaml
</span><span style=color:#b44>apiVersion: &#34;kubeadm.k8s.io/v1beta2&#34;
</span><span style=color:#b44>kind: ClusterConfiguration
</span><span style=color:#b44>etcd:
</span><span style=color:#b44>    local:
</span><span style=color:#b44>        serverCertSANs:
</span><span style=color:#b44>        - &#34;${HOST}&#34;
</span><span style=color:#b44>        peerCertSANs:
</span><span style=color:#b44>        - &#34;${HOST}&#34;
</span><span style=color:#b44>        extraArgs:
</span><span style=color:#b44>            initial-cluster: ${NAMES[0]}=https://${ETCDHOSTS[0]}:2380,${NAMES[1]}=https://${ETCDHOSTS[1]}:2380,${NAMES[2]}=https://${ETCDHOSTS[2]}:2380
</span><span style=color:#b44>            initial-cluster-state: new
</span><span style=color:#b44>            name: ${NAME}
</span><span style=color:#b44>            listen-peer-urls: https://${HOST}:2380
</span><span style=color:#b44>            listen-client-urls: https://${HOST}:2379
</span><span style=color:#b44>            advertise-client-urls: https://${HOST}:2379
</span><span style=color:#b44>            initial-advertise-peer-urls: https://${HOST}:2380
</span><span style=color:#b44>EOF</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div></li>
<li>
<p>Generate the certificate authority</p>
<p>If you already have a CA then the only action that is copying the CA's <code>crt</code> and
<code>key</code> file to <code>/etc/kubernetes/pki/etcd/ca.crt</code> and
<code>/etc/kubernetes/pki/etcd/ca.key</code>. After those files have been copied,
proceed to the next step, "Create certificates for each member".</p>
<p>If you do not already have a CA then run this command on <code>$HOST0</code> (where you
generated the configuration files for kubeadm).</p>
<pre><code>kubeadm init phase certs etcd-ca
</code></pre><p>This creates two files</p>
<ul>
<li><code>/etc/kubernetes/pki/etcd/ca.crt</code></li>
<li><code>/etc/kubernetes/pki/etcd/ca.key</code></li>
</ul>
</li>
<li>
<p>Create certificates for each member</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubeadm init phase certs etcd-server --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST2</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
kubeadm init phase certs etcd-peer --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST2</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
kubeadm init phase certs etcd-healthcheck-client --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST2</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
kubeadm init phase certs apiserver-etcd-client --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST2</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
cp -R /etc/kubernetes/pki /tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST2</span><span style=color:#b68;font-weight:700>}</span>/
<span style=color:#080;font-style:italic># cleanup non-reusable certificates</span>
find /etc/kubernetes/pki -not -name ca.crt -not -name ca.key -type f -delete

kubeadm init phase certs etcd-server --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST1</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
kubeadm init phase certs etcd-peer --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST1</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
kubeadm init phase certs etcd-healthcheck-client --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST1</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
kubeadm init phase certs apiserver-etcd-client --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST1</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
cp -R /etc/kubernetes/pki /tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST1</span><span style=color:#b68;font-weight:700>}</span>/
find /etc/kubernetes/pki -not -name ca.crt -not -name ca.key -type f -delete

kubeadm init phase certs etcd-server --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST0</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
kubeadm init phase certs etcd-peer --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST0</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
kubeadm init phase certs etcd-healthcheck-client --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST0</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
kubeadm init phase certs apiserver-etcd-client --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST0</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
<span style=color:#080;font-style:italic># No need to move the certs because they are for HOST0</span>

<span style=color:#080;font-style:italic># clean up certs that should not be copied off this host</span>
find /tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST2</span><span style=color:#b68;font-weight:700>}</span> -name ca.key -type f -delete
find /tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST1</span><span style=color:#b68;font-weight:700>}</span> -name ca.key -type f -delete
</code></pre></div></li>
<li>
<p>Copy certificates and kubeadm configs</p>
<p>The certificates have been generated and now they must be moved to their
respective hosts.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#b8860b>USER</span><span style=color:#666>=</span>ubuntu
<span style=color:#b8860b>HOST</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST1</span><span style=color:#b68;font-weight:700>}</span>
scp -r /tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST</span><span style=color:#b68;font-weight:700>}</span>/* <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>@<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST</span><span style=color:#b68;font-weight:700>}</span>:
ssh <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>@<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST</span><span style=color:#b68;font-weight:700>}</span>
USER@HOST $ sudo -Es
root@HOST $ chown -R root:root pki
root@HOST $ mv pki /etc/kubernetes/
</code></pre></div></li>
<li>
<p>Ensure all expected files exist</p>
<p>The complete list of required files on <code>$HOST0</code> is:</p>
<pre><code>/tmp/${HOST0}
└── kubeadmcfg.yaml
---
/etc/kubernetes/pki
├── apiserver-etcd-client.crt
├── apiserver-etcd-client.key
└── etcd
    ├── ca.crt
    ├── ca.key
    ├── healthcheck-client.crt
    ├── healthcheck-client.key
    ├── peer.crt
    ├── peer.key
    ├── server.crt
    └── server.key
</code></pre><p>On <code>$HOST1</code>:</p>
<pre><code>$HOME
└── kubeadmcfg.yaml
---
/etc/kubernetes/pki
├── apiserver-etcd-client.crt
├── apiserver-etcd-client.key
└── etcd
    ├── ca.crt
    ├── healthcheck-client.crt
    ├── healthcheck-client.key
    ├── peer.crt
    ├── peer.key
    ├── server.crt
    └── server.key
</code></pre><p>On <code>$HOST2</code></p>
<pre><code>$HOME
└── kubeadmcfg.yaml
---
/etc/kubernetes/pki
├── apiserver-etcd-client.crt
├── apiserver-etcd-client.key
└── etcd
    ├── ca.crt
    ├── healthcheck-client.crt
    ├── healthcheck-client.key
    ├── peer.crt
    ├── peer.key
    ├── server.crt
    └── server.key
</code></pre></li>
<li>
<p>Create the static pod manifests</p>
<p>Now that the certificates and configs are in place it's time to create the
manifests. On each host run the <code>kubeadm</code> command to generate a static manifest
for etcd.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>root@HOST0 $ kubeadm init phase etcd <span style=color:#a2f>local</span> --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST0</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
root@HOST1 $ kubeadm init phase etcd <span style=color:#a2f>local</span> --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST1</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
root@HOST2 $ kubeadm init phase etcd <span style=color:#a2f>local</span> --config<span style=color:#666>=</span>/tmp/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST2</span><span style=color:#b68;font-weight:700>}</span>/kubeadmcfg.yaml
</code></pre></div></li>
<li>
<p>Optional: Check the cluster health</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>docker run --rm -it <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--net host <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>-v /etc/kubernetes:/etc/kubernetes k8s.gcr.io/etcd:<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ETCD_TAG</span><span style=color:#b68;font-weight:700>}</span> etcdctl <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--cert /etc/kubernetes/pki/etcd/peer.crt <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--key /etc/kubernetes/pki/etcd/peer.key <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--cacert /etc/kubernetes/pki/etcd/ca.crt <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--endpoints https://<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOST0</span><span style=color:#b68;font-weight:700>}</span>:2379 endpoint health --cluster
...
https://<span style=color:#666>[</span>HOST0 IP<span style=color:#666>]</span>:2379 is healthy: successfully committed proposal: <span style=color:#b8860b>took</span> <span style=color:#666>=</span> 16.283339ms
https://<span style=color:#666>[</span>HOST1 IP<span style=color:#666>]</span>:2379 is healthy: successfully committed proposal: <span style=color:#b8860b>took</span> <span style=color:#666>=</span> 19.44402ms
https://<span style=color:#666>[</span>HOST2 IP<span style=color:#666>]</span>:2379 is healthy: successfully committed proposal: <span style=color:#b8860b>took</span> <span style=color:#666>=</span> 35.926451ms
</code></pre></div><ul>
<li>Set <code>${ETCD_TAG}</code> to the version tag of your etcd image. For example <code>3.4.3-0</code>. To see the etcd image and tag that kubeadm uses execute <code>kubeadm config images list --kubernetes-version ${K8S_VERSION}</code>, where <code>${K8S_VERSION}</code> is for example <code>v1.17.0</code></li>
<li>Set <code>${HOST0}</code>to the IP address of the host you are testing.</li>
</ul>
</li>
</ol>
<h2 id=次の項目>次の項目</h2>
<p>Once you have a working 3 member etcd cluster, you can continue setting up a
highly available control plane using the <a href=/ja/docs/setup/production-environment/tools/kubeadm/high-availability/>external etcd method with
kubeadm</a>.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-07709e71de6b4ac2573041c31213dbeb>2.3.2.1.8 - kubeadmを使用したクラスター内の各kubeletの設定</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes 1.11 [stable]</code>
</div>
<p>kubeadm CLIツールのライフサイクルは、Kubernetesクラスター内の各ノード上で稼働するデーモンである<a href=/docs/reference/command-line-tools-reference/kubelet>kubelet</a>から分離しています。kubeadm CLIツールはKubernetesを初期化またはアップグレードする際にユーザーによって実行されます。一方で、kubeletは常にバックグラウンドで稼働しています。</p>
<p>kubeletはデーモンのため、何らかのinitシステムやサービスマネージャーで管理する必要があります。DEBパッケージやRPMパッケージからkubeletをインストールすると、systemdはkubeletを管理するように設定されます。代わりに別のサービスマネージャーを使用することもできますが、手動で設定する必要があります。</p>
<p>いくつかのkubeletの設定は、クラスターに含まれる全てのkubeletで同一である必要があります。一方で、特定のマシンの異なる特性(OS、ストレージ、ネットワークなど)に対応するために、kubeletごとに設定が必要なものもあります。手動で設定を管理することも可能ですが、kubeadmは<a href=#configure-kubelets-using-kubeadm>一元的な設定管理</a>のための<code>KubeletConfiguration</code>APIを提供しています。</p>
<h2 id=kubeletの設定パターン>Kubeletの設定パターン</h2>
<p>以下のセクションでは、kubeadmを使用したkubeletの設定パターンについて説明します。これは手動で各Nodeの設定を管理するよりも簡易に行うことができます。</p>
<h3 id=propagating-cluster-level-configuration-to-each-kubelet>各kubeletにクラスターレベルの設定を配布</h3>
<p><code>kubeadm init</code>および<code>kubeadm join</code>コマンドを使用すると、kubeletにデフォルト値を設定することができます。興味深い例として、異なるCRIランタイムを使用したり、Serviceが使用するデフォルトのサブネットを設定したりすることができます。</p>
<p>Serviceが使用するデフォルトのサブネットとして<code>10.96.0.0/12</code>を設定する必要がある場合は、<code>--service-cidr</code>パラメーターを渡します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubeadm init --service-cidr 10.96.0.0/12
</code></pre></div><p>これによってServiceの仮想IPはこのサブネットから割り当てられるようになりました。また、<code>--cluster-dns</code>フラグを使用し、kubeletが用いるDNSアドレスを設定する必要もあります。この設定はクラスター内の全てのマネージャーとNode上で同一である必要があります。kubeletは、<strong>kubeletのComponentConfig</strong>と呼ばれる、バージョン管理と構造化されたAPIオブジェクトを提供します。これはkubelet内のほとんどのパラメーターを設定し、その設定をクラスター内で稼働中の各kubeletへ適用することを可能にします。以下の例のように、キャメルケースのキーに値のリストとしてクラスターDNS IPアドレスなどのフラグを指定することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusterDNS</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:#666>10.96.0.10</span><span style=color:#bbb>
</span></code></pre></div><p>ComponentConfigの詳細については、<a href=#configure-kubelets-using-kubeadm>このセクション</a>をご覧ください</p>
<h3 id=providing-instance-specific-configuration-details>インスタンス固有の設定内容を適用</h3>
<p>いくつかのホストでは、ハードウェア、オペレーティングシステム、ネットワーク、その他ホスト固有のパラメータの違いのため、特定のkubeletの設定を必要とします。以下にいくつかの例を示します。</p>
<ul>
<li>DNS解決ファイルへのパスは<code>--resolv-conf</code>フラグで指定することができますが、オペレーティングシステムや<code>systemd-resolved</code>を使用するかどうかによって異なる場合があります。このパスに誤りがある場合、そのNode上でのDNS解決は失敗します。</li>
<li>クラウドプロバイダーを使用していない場合、Node APIオブジェクト<code>.metadata.name</code>はデフォルトでマシンのホスト名に設定されます。異なるNode名を指定する必要がある場合には、<code>--hostname-override</code>フラグによってこの挙動を書き換えることができます。</li>
<li>現在のところ、kubletはCRIランタイムが使用するcgroupドライバを自動で検知することができませんが、kubeletの稼働を保証するためには、<code>--cgroup-driver</code>の値はCRIランタイムが使用するcgroupドライバに一致していなければなりません。</li>
<li>クラスターが使用するCRIランタイムによっては、異なるフラグを指定する必要があるかもしれません。例えば、Dockerを使用している場合には、<code>--network-plugin=cni</code>のようなフラグを指定する必要があります。外部のランタイムを使用している場合には、<code>--container-runtime=remote</code>と指定し、<code>--container-runtime-endpoint=&lt;path></code>のようにCRIエンドポイントを指定する必要があります。</li>
</ul>
<p>これらのフラグは、systemdなどのサービスマネージャー内のkubeletの設定によって指定することができます。</p>
<h2 id=configure-kubelets-using-kubeadm>kubeadmを使用したkubeletの設定</h2>
<p><code>kubeadm ... --config some-config-file.yaml</code>のように、カスタムの<code>KubeletConfiguration</code>APIオブジェクトを設定ファイルを介して渡すことで、kubeadmによって起動されるkubeletに設定を反映することができます。</p>
<p><code>kubeadm config print init-defaults --component-configs KubeletConfiguration</code>を実行することによって、この構造体の全てのデフォルト値を確認することができます。</p>
<p>また、各フィールドの詳細については、<a href=https://godoc.org/k8s.io/kubernetes/pkg/kubelet/apis/config#KubeletConfiguration>kubelet ComponentConfigに関するAPIリファレンス</a>を参照してください。</p>
<h3 id=kubeadm-init-実行時の流れ><code>kubeadm init</code>実行時の流れ</h3>
<p><code>kubeadm init</code>を実行した場合、kubeletの設定は<code>/var/lib/kubelet/config.yaml</code>に格納され、クラスターのConfigMapにもアップロードされます。ConfigMapは<code>kubelet-config-1.X</code>という名前で、<code>X</code>は初期化するKubernetesのマイナーバージョンを表します。またこの設定ファイルは、クラスタ内の全てのkubeletのために、クラスター全体設定の基準と共に<code>/etc/kubernetes/kubelet.conf</code>にも書き込まれます。この設定ファイルは、kubeletがAPIサーバと通信するためのクライアント証明書を指し示します。これは、<a href=#propagating-cluster-level-configuration-to-each-kubelet>各kubeletにクラスターレベルの設定を配布</a>することの必要性を示しています。</p>
<p>二つ目のパターンである、<a href=#providing-instance-specific-configuration-details>インスタンス固有の設定内容を適用</a>するために、kubeadmは環境ファイルを<code>/var/lib/kubelet/kubeadm-flags.env</code>へ書き出します。このファイルは以下のように、kubelet起動時に渡されるフラグのリストを含んでいます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#b8860b>KUBELET_KUBEADM_ARGS</span><span style=color:#666>=</span><span style=color:#b44>&#34;--flag1=value1 --flag2=value2 ...&#34;</span>
</code></pre></div><p>kubelet起動時に渡されるフラグに加えて、このファイルはcgroupドライバーや異なるCRIランタイムソケットを使用するかどうか(<code>--cri-socket</code>)といった動的なパラメータも含みます。</p>
<p>これら二つのファイルがディスク上に格納されると、systemdを使用している場合、kubeadmは以下の二つのコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>systemctl daemon-reload <span style=color:#666>&amp;&amp;</span> systemctl restart kubelet
</code></pre></div><p>リロードと再起動に成功すると、通常の<code>kubeadm init</code>のワークフローが続きます。</p>
<h3 id=kubeadm-join-実行時の流れ><code>kubeadm join</code>実行時の流れ</h3>
<p><code>kubeadm join</code>を実行した場合、kubeadmはBootstrap Token証明書を使用してTLS bootstrapを行い、ConfigMap<code>kubelet-config-1.X</code>をダウンロードするために必要なクレデンシャルを取得し、<code>/var/lib/kubelet/config.yaml</code>へ書き込みます。動的な環境ファイルは、<code>kubeadm init</code>の場合と全く同様の方法で生成されます。</p>
<p>次に、<code>kubeadm</code>は、kubeletに新たな設定を読み込むために、以下の二つのコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>systemctl daemon-reload <span style=color:#666>&amp;&amp;</span> systemctl restart kubelet
</code></pre></div><p>kubeletが新たな設定を読み込むと、kubeadmは、KubeConfigファイル<code>/etc/kubernetes/bootstrap-kubelet.conf</code>を書き込みます。これは、CA証明書とBootstrap Tokenを含みます。これらはkubeletがTLS Bootstrapを行い<code>/etc/kubernetes/kubelet.conf</code>に格納されるユニークなクレデンシャルを取得するために使用されます。ファイルが書き込まれると、kubeletはTLS Bootstrapを終了します。</p>
<h2 id=the-kubelet-drop-in-file-for-systemd>kubelet用のsystemdファイル</h2>
<p><code>kubeadm</code>には、systemdがどのようにkubeletを実行するかを指定した設定ファイルが同梱されています。
kubeadm CLIコマンドは決してこのsystemdファイルには触れないことに注意してください。</p>
<p>kubeadmの<a href=https://github.com/kubernetes/release/blob/master/cmd/kubepkg/templates/latest/deb/kubeadm/10-kubeadm.conf>DEBパッケージ</a>または<a href=https://github.com/kubernetes/release/blob/master/cmd/kubepkg/templates/latest/rpm/kubeadm/10-kubeadm.conf>RPMパッケージ</a>によってインストールされたこの設定ファイルは、<code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code>に書き込まれ、systemdで使用されます。基本的な<code>kubelet.service</code>(<a href=https://github.com/kubernetes/release/blob/master/cmd/kubepkg/templates/latest/rpm/kubelet/kubelet.service>RPM用</a>または、 <a href=https://github.com/kubernetes/release/blob/master/cmd/kubepkg/templates/latest/deb/kubelet/lib/systemd/system/kubelet.service>DEB用</a>)を拡張します。</p>
<pre><code class=language-none data-lang=none>[Service]
Environment=&quot;KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf
--kubeconfig=/etc/kubernetes/kubelet.conf&quot;
Environment=&quot;KUBELET_CONFIG_ARGS=--config=/var/lib/kubelet/config.yaml&quot;
# This is a file that &quot;kubeadm init&quot; and &quot;kubeadm join&quot; generate at runtime, populating
the KUBELET_KUBEADM_ARGS variable dynamically
EnvironmentFile=-/var/lib/kubelet/kubeadm-flags.env
# This is a file that the user can use for overrides of the kubelet args as a last resort. Preferably,
# the user should use the .NodeRegistration.KubeletExtraArgs object in the configuration files instead.
# KUBELET_EXTRA_ARGS should be sourced from this file.
EnvironmentFile=-/etc/default/kubelet
ExecStart=
ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS
</code></pre><p>このファイルは、kubeadmがkubelet用に管理する全ファイルが置かれるデフォルトの場所を指定します。</p>
<ul>
<li>TLS Bootstrapに使用するKubeConfigファイルは<code>/etc/kubernetes/bootstrap-kubelet.conf</code>ですが、<code>/etc/kubernetes/kubelet.conf</code>が存在しない場合にのみ使用します。</li>
<li>ユニークなkublet識別子を含むKubeConfigファイルは<code>/etc/kubernetes/kubelet.conf</code>です。</li>
<li>kubeletのComponentConfigを含むファイルは<code>/var/lib/kubelet/config.yaml</code>です。</li>
<li><code>KUBELET_KUBEADM_ARGS</code>を含む動的な環境ファイルは<code>/var/lib/kubelet/kubeadm-flags.env</code>から取得します。</li>
<li><code>KUBELET_EXTRA_ARGS</code>によるユーザー定義のフラグの上書きを格納できるファイルは<code>/etc/default/kubelet</code>(DEBの場合)、または<code>/etc/sysconfig/kubelet</code>(RPMの場合)から取得します。<code>KUBELET_EXTRA_ARGS</code>はフラグの連なりの最後に位置し、優先度が最も高いです。</li>
</ul>
<h2 id=kubernetesバイナリとパッケージの内容>Kubernetesバイナリとパッケージの内容</h2>
<p>Kubernetesに同梱されるDEB、RPMのパッケージは以下の通りです。</p>
<table>
<thead>
<tr>
<th>パッケージ名</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>kubeadm</code></td>
<td><code>/usr/bin/kubeadm</code>CLIツールと、<a href=#the-kubelet-drop-in-file-for-systemd>kubelet用のsystemdファイル</a>をインストールします。</td>
</tr>
<tr>
<td><code>kubelet</code></td>
<td>kubeletバイナリを<code>/usr/bin</code>に、CNIバイナリを<code>/opt/cni/bin</code>にインストールします。</td>
</tr>
<tr>
<td><code>kubectl</code></td>
<td><code>/usr/bin/kubectl</code>バイナリをインストールします。</td>
</tr>
<tr>
<td><code>cri-tools</code></td>
<td><code>/usr/bin/crictl</code>バイナリを<a href=https://github.com/kubernetes-incubator/cri-tools>cri-tools gitリポジトリ</a>からインストールします。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ed857e09999827b013ee9062dc9c59bb>2.3.2.1.9 - コントロールプレーンをセルフホストするようにkubernetesクラスターを構成する</h1>
<h3 id=self-hosting>コントロールプレーンのセルフホスティング</h3>
<p>kubeadmを使用すると、セルフホスト型のKubernetesコントロールプレーンを実験的に作成できます。これはAPIサーバー、コントローラーマネージャー、スケジューラーなどの主要コンポーネントは、静的ファイルを介してkubeletで構成された<a href=/docs/tasks/configure-pod-container/static-pod/>static pods</a>ではなく、Kubernetes APIを介して構成された<a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet pods</a>として実行されることを意味します。</p>
<p>セルフホスト型クラスターを作成する場合は<a href=/docs/reference/setup-tools/kubeadm/kubeadm-alpha/#cmd-selfhosting>kubeadm alpha selfhosting pivot</a>を参照してください。</p>
<h4 id=警告>警告</h4>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> この機能により、クラスターがサポートされていない状態になり、kubeadmがクラスターを管理できなくなります。これには<code>kubeadm upgrade</code>が含まれます。
</div>
<ol>
<li>
<p>1.8以降のセルフホスティングには、いくつかの重要な制限があります。特に、セルフホスト型クラスターは、手動の介入なしにコントロールプレーンのNode再起動から回復することはできません。</p>
</li>
<li>
<p>デフォルトでは、セルフホスト型のコントロールプレーンのPodは、<a href=/docs/concepts/storage/volumes/#hostpath><code>hostPath</code></a>ボリュームからロードされた資格情報に依存しています。最初の作成を除いて、これらの資格情報はkubeadmによって管理されません。</p>
</li>
<li>
<p>コントロールプレーンのセルフホストされた部分にはetcdが含まれていませんが、etcdは静的Podとして実行されます。</p>
</li>
</ol>
<h4 id=プロセス>プロセス</h4>
<p>セルフホスティングのブートストラッププロセスは、<a href=https://github.com/kubernetes/kubeadm/blob/master/docs/design/design_v1.9.md#optional-self-hosting>kubeadm design
document</a>に記載されています。</p>
<p>要約すると、<code>kubeadm alpha selfhosting</code>は次のように機能します。</p>
<ol>
<li>
<p>静的コントロールプレーンのブートストラップが起動し、正常になるのを待ちます。これは<code>kubeadm init</code>のセルフホスティングを使用しないプロセスと同じです。</p>
</li>
<li>
<p>静的コントロールプレーンのPodのマニフェストを使用して、セルフホスト型コントロールプレーンを実行する一連のDaemonSetのマニフェストを構築します。また、必要に応じてこれらのマニフェストを変更します。たとえば、シークレット用の新しいボリュームを追加します。</p>
</li>
<li>
<p><code>kube-system</code>のネームスペースにDaemonSetを作成し、Podの結果が起動されるのを待ちます。</p>
</li>
<li>
<p>セルフホスト型のPodが操作可能になると、関連する静的Podが削除され、kubeadmは次のコンポーネントのインストールに進みます。これによりkubeletがトリガーされて静的Podが停止します。</p>
</li>
<li>
<p>元の静的なコントロールプレーンが停止すると、新しいセルフホスト型コントロールプレーンはリスニングポートにバインドしてアクティブになります。</p>
</li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-478acca1934b6d89a0bc00fb25bfe5b6>2.3.2.2 - kopsを使ったAWS上でのKubernetesのインストール</h1>
<p>This quickstart shows you how to easily install a Kubernetes cluster on AWS.
It uses a tool called <a href=https://github.com/kubernetes/kops><code>kops</code></a>.</p>
<p>kops is an automated provisioning system:</p>
<ul>
<li>Fully automated installation</li>
<li>Uses DNS to identify clusters</li>
<li>Self-healing: everything runs in Auto-Scaling Groups</li>
<li>Multiple OS support (Debian, Ubuntu 16.04 supported, CentOS & RHEL, Amazon Linux and CoreOS) - see the <a href=https://github.com/kubernetes/kops/blob/master/docs/operations/images.md>images.md</a></li>
<li>High-Availability support - see the <a href=https://github.com/kubernetes/kops/blob/master/docs/operations/high_availability.md>high_availability.md</a></li>
<li>Can directly provision, or generate terraform manifests - see the <a href=https://github.com/kubernetes/kops/blob/master/docs/terraform.md>terraform.md</a></li>
</ul>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>
<p>You must have <a href=/docs/tasks/tools/install-kubectl/>kubectl</a> installed.</p>
</li>
<li>
<p>You must <a href=https://github.com/kubernetes/kops#installing>install</a> <code>kops</code> on a 64-bit (AMD64 and Intel 64) device architecture.</p>
</li>
<li>
<p>You must have an <a href=https://docs.aws.amazon.com/polly/latest/dg/setting-up.html>AWS account</a>, generate <a href=https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys>IAM keys</a> and <a href=https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html#cli-quick-configuration>configure</a> them. The IAM user will need <a href=https://github.com/kubernetes/kops/blob/master/docs/getting_started/aws.md#setup-iam-user>adequate permissions</a>.</p>
</li>
</ul>
<h2 id=クラスタの作成>クラスタの作成</h2>
<h3 id=1-5-kopsのインストール>(1/5) kopsのインストール</h3>
<h4 id=インストール>インストール</h4>
<p>Download kops from the <a href=https://github.com/kubernetes/kops/releases>releases page</a> (it is also easy to build from source):</p>
<ul class="nav nav-tabs" id=kops-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kops-installation-0 role=tab aria-controls=kops-installation-0 aria-selected=true>macOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kops-installation-1 role=tab aria-controls=kops-installation-1>Linux</a></li></ul>
<div class=tab-content id=kops-installation><div id=kops-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=kops-installation-0>
<p><p>Download the latest release with the command:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -LO https://github.com/kubernetes/kops/releases/download/<span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>/kops-darwin-amd64
</code></pre></div><p>To download a specific version, replace the following portion of the command with the specific kops version.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>
</code></pre></div><p>For example, to download kops version v1.20.0 type:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -LO https://github.com/kubernetes/kops/releases/download/v1.20.0/kops-darwin-amd64
</code></pre></div><p>Make the kops binary executable.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>chmod +x kops-darwin-amd64
</code></pre></div><p>Move the kops binary in to your PATH.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo mv kops-darwin-amd64 /usr/local/bin/kops
</code></pre></div><p>You can also install kops using <a href=https://brew.sh/>Homebrew</a>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>brew update <span style=color:#666>&amp;&amp;</span> brew install kops
</code></pre></div></div>
<div id=kops-installation-1 class=tab-pane role=tabpanel aria-labelledby=kops-installation-1>
<p><p>Download the latest release with the command:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -LO https://github.com/kubernetes/kops/releases/download/<span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>/kops-linux-amd64
</code></pre></div><p>To download a specific version of kops, replace the following portion of the command with the specific kops version.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>
</code></pre></div><p>For example, to download kops version v1.20.0 type:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -LO https://github.com/kubernetes/kops/releases/download/v1.20.0/kops-linux-amd64
</code></pre></div><p>Make the kops binary executable</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>chmod +x kops-linux-amd64
</code></pre></div><p>Move the kops binary in to your PATH.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo mv kops-linux-amd64 /usr/local/bin/kops
</code></pre></div><p>You can also install kops using <a href=https://docs.brew.sh/Homebrew-on-Linux>Homebrew</a>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>brew update <span style=color:#666>&amp;&amp;</span> brew install kops
</code></pre></div></div></div>
<h3 id=2-5-クラスタ用のroute53ドメインの作成>(2/5) クラスタ用のroute53ドメインの作成</h3>
<p>kops uses DNS for discovery, both inside the cluster and outside, so that you can reach the kubernetes API server
from clients.</p>
<p>kops has a strong opinion on the cluster name: it should be a valid DNS name. By doing so you will
no longer get your clusters confused, you can share clusters with your colleagues unambiguously,
and you can reach them without relying on remembering an IP address.</p>
<p>You can, and probably should, use subdomains to divide your clusters. As our example we will use
<code>useast1.dev.example.com</code>. The API server endpoint will then be <code>api.useast1.dev.example.com</code>.</p>
<p>A Route53 hosted zone can serve subdomains. Your hosted zone could be <code>useast1.dev.example.com</code>,
but also <code>dev.example.com</code> or even <code>example.com</code>. kops works with any of these, so typically
you choose for organization reasons (e.g. you are allowed to create records under <code>dev.example.com</code>,
but not under <code>example.com</code>).</p>
<p>Let's assume you're using <code>dev.example.com</code> as your hosted zone. You create that hosted zone using
the <a href=https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/CreatingNewSubdomain.html>normal process</a>, or
with a command such as <code>aws route53 create-hosted-zone --name dev.example.com --caller-reference 1</code>.</p>
<p>You must then set up your NS records in the parent domain, so that records in the domain will resolve. Here,
you would create NS records in <code>example.com</code> for <code>dev</code>. If it is a root domain name you would configure the NS
records at your domain registrar (e.g. <code>example.com</code> would need to be configured where you bought <code>example.com</code>).</p>
<p>This step is easy to mess up (it is the #1 cause of problems!) You can double-check that
your cluster is configured correctly if you have the dig tool by running:</p>
<p><code>dig NS dev.example.com</code></p>
<p>You should see the 4 NS records that Route53 assigned your hosted zone.</p>
<h3 id=3-5-クラスタの状態を保存するs3バケットの作成>(3/5) クラスタの状態を保存するS3バケットの作成</h3>
<p>kops lets you manage your clusters even after installation. To do this, it must keep track of the clusters
that you have created, along with their configuration, the keys they are using etc. This information is stored
in an S3 bucket. S3 permissions are used to control access to the bucket.</p>
<p>Multiple clusters can use the same S3 bucket, and you can share an S3 bucket between your colleagues that
administer the same clusters - this is much easier than passing around kubecfg files. But anyone with access
to the S3 bucket will have administrative access to all your clusters, so you don't want to share it beyond
the operations team.</p>
<p>So typically you have one S3 bucket for each ops team (and often the name will correspond
to the name of the hosted zone above!)</p>
<p>In our example, we chose <code>dev.example.com</code> as our hosted zone, so let's pick <code>clusters.dev.example.com</code> as
the S3 bucket name.</p>
<ul>
<li>
<p>Export <code>AWS_PROFILE</code> (if you need to select a profile for the AWS CLI to work)</p>
</li>
<li>
<p>Create the S3 bucket using <code>aws s3 mb s3://clusters.dev.example.com</code></p>
</li>
<li>
<p>You can <code>export KOPS_STATE_STORE=s3://clusters.dev.example.com</code> and then kops will use this location by default.
We suggest putting this in your bash profile or similar.</p>
</li>
</ul>
<h3 id=4-5-クラスタ設定の構築>(4/5) クラスタ設定の構築</h3>
<p>Run <code>kops create cluster</code> to create your cluster configuration:</p>
<p><code>kops create cluster --zones=us-east-1c useast1.dev.example.com</code></p>
<p>kops will create the configuration for your cluster. Note that it <em>only</em> creates the configuration, it does
not actually create the cloud resources - you'll do that in the next step with a <code>kops update cluster</code>. This
give you an opportunity to review the configuration or change it.</p>
<p>It prints commands you can use to explore further:</p>
<ul>
<li>List your clusters with: <code>kops get cluster</code></li>
<li>Edit this cluster with: <code>kops edit cluster useast1.dev.example.com</code></li>
<li>Edit your node instance group: <code>kops edit ig --name=useast1.dev.example.com nodes</code></li>
<li>Edit your master instance group: <code>kops edit ig --name=useast1.dev.example.com master-us-east-1c</code></li>
</ul>
<p>If this is your first time using kops, do spend a few minutes to try those out! An instance group is a
set of instances, which will be registered as kubernetes nodes. On AWS this is implemented via auto-scaling-groups.
You can have several instance groups, for example if you wanted nodes that are a mix of spot and on-demand instances, or
GPU and non-GPU instances.</p>
<h3 id=5-5-awsにクラスタを作成>(5/5) AWSにクラスタを作成</h3>
<p>Run "kops update cluster" to create your cluster in AWS:</p>
<p><code>kops update cluster useast1.dev.example.com --yes</code></p>
<p>That takes a few seconds to run, but then your cluster will likely take a few minutes to actually be ready.
<code>kops update cluster</code> will be the tool you'll use whenever you change the configuration of your cluster; it
applies the changes you have made to the configuration to your cluster - reconfiguring AWS or kubernetes as needed.</p>
<p>For example, after you <code>kops edit ig nodes</code>, then <code>kops update cluster --yes</code> to apply your configuration, and
sometimes you will also have to <code>kops rolling-update cluster</code> to roll out the configuration immediately.</p>
<p>Without <code>--yes</code>, <code>kops update cluster</code> will show you a preview of what it is going to do. This is handy
for production clusters!</p>
<h3 id=他のアドオンの参照>他のアドオンの参照</h3>
<p>See the <a href=/docs/concepts/cluster-administration/addons/>list of add-ons</a> to explore other add-ons, including tools for logging, monitoring, network policy, visualization, and control of your Kubernetes cluster.</p>
<h2 id=クリーンアップ>クリーンアップ</h2>
<ul>
<li>To delete your cluster: <code>kops delete cluster useast1.dev.example.com --yes</code></li>
</ul>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>Learn more about Kubernetes <a href=/docs/concepts/>concepts</a> and <a href=/docs/reference/kubectl/overview/><code>kubectl</code></a>.</li>
<li>Learn more about <code>kops</code> <a href=https://kops.sigs.k8s.io/>advanced usage</a> for tutorials, best practices and advanced configuration options.</li>
<li>Follow <code>kops</code> community discussions on Slack: <a href=https://github.com/kubernetes/kops#other-ways-to-communicate-with-the-contributors>community discussions</a></li>
<li>Contribute to <code>kops</code> by addressing or raising an issue <a href=https://github.com/kubernetes/kops/issues>GitHub Issues</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f8b4964187fe973644e06ee629eff1de>2.3.2.3 - kubesprayを使ったオンプレミス/クラウドプロバイダへのKubernetesのインストール</h1>
<p>This quickstart helps to install a Kubernetes cluster hosted on GCE, Azure, OpenStack, AWS, vSphere, Packet (bare metal), Oracle Cloud Infrastructure (Experimental) or Baremetal with <a href=https://github.com/kubernetes-sigs/kubespray>Kubespray</a>.</p>
<p>Kubespray is a composition of <a href=https://docs.ansible.com/>Ansible</a> playbooks, <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/ansible.md>inventory</a>, provisioning tools, and domain knowledge for generic OS/Kubernetes clusters configuration management tasks. Kubespray provides:</p>
<ul>
<li>a highly available cluster</li>
<li>composable attributes</li>
<li>support for most popular Linux distributions
<ul>
<li>Container Linux by CoreOS</li>
<li>Debian Buster, Jessie, Stretch, Wheezy</li>
<li>Ubuntu 16.04, 18.04</li>
<li>CentOS/RHEL/Oracle Linux 7</li>
<li>Fedora 28</li>
<li>openSUSE Leap 15</li>
</ul>
</li>
<li>continuous integration tests</li>
</ul>
<p>To choose a tool which best fits your use case, read <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/comparisons.md>this comparison</a> to
<a href=/docs/reference/setup-tools/kubeadm/kubeadm/>kubeadm</a> and <a href=/docs/setup/production-environment/tools/kops/>kops</a>.</p>
<h2 id=クラスタの作成>クラスタの作成</h2>
<h3 id=1-5-下地の要件の確認>(1/5) 下地の要件の確認</h3>
<p>Provision servers with the following <a href=https://github.com/kubernetes-sigs/kubespray#requirements>requirements</a>:</p>
<ul>
<li><strong>Ansible v2.7.8 and python-netaddr is installed on the machine that will run Ansible commands</strong></li>
<li><strong>Jinja 2.9 (or newer) is required to run the Ansible Playbooks</strong></li>
<li>The target servers must have access to the Internet in order to pull docker images. Otherwise, additional configuration is required (<a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/offline-environment.md>See Offline Environment</a>)</li>
<li>The target servers are configured to allow <strong>IPv4 forwarding</strong></li>
<li><strong>Your ssh key must be copied</strong> to all the servers part of your inventory</li>
<li>The <strong>firewalls are not managed</strong>, you'll need to implement your own rules the way you used to. in order to avoid any issue during deployment you should disable your firewall</li>
<li>If kubespray is ran from non-root user account, correct privilege escalation method should be configured in the target servers. Then the <code>ansible_become</code> flag or command parameters <code>--become</code> or <code>-b</code> should be specified</li>
</ul>
<p>Kubespray provides the following utilities to help provision your environment:</p>
<ul>
<li><a href=https://www.terraform.io/>Terraform</a> scripts for the following cloud providers:
<ul>
<li><a href=https://github.com/kubernetes-sigs/kubespray/tree/master/contrib/terraform/aws>AWS</a></li>
<li><a href=https://github.com/kubernetes-sigs/kubespray/tree/master/contrib/terraform/openstack>OpenStack</a></li>
<li><a href=https://github.com/kubernetes-sigs/kubespray/tree/master/contrib/terraform/packet>Packet</a></li>
</ul>
</li>
</ul>
<h3 id=2-5-インベントリファイルの用意>(2/5) インベントリファイルの用意</h3>
<p>After you provision your servers, create an <a href=https://docs.ansible.com/ansible/latest/network/getting_started/first_inventory.html>inventory file for Ansible</a>. You can do this manually or via a dynamic inventory script. For more information, see "<a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md#building-your-own-inventory>Building your own inventory</a>".</p>
<h3 id=3-5-クラスタ作成の計画>(3/5) クラスタ作成の計画</h3>
<p>Kubespray provides the ability to customize many aspects of the deployment:</p>
<ul>
<li>Choice deployment mode: kubeadm or non-kubeadm</li>
<li>CNI (networking) plugins</li>
<li>DNS configuration</li>
<li>Choice of control plane: native/binary or containerized</li>
<li>Component versions</li>
<li>Calico route reflectors</li>
<li>Component runtime options
<ul>
<li><a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a></li>
<li><a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a></li>
<li><a class=glossary-tooltip title="A lightweight container runtime specifically for Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a></li>
</ul>
</li>
<li>Certificate generation methods</li>
</ul>
<p>Kubespray customizations can be made to a <a href=https://docs.ansible.com/ansible/playbooks_variables.html>variable file</a>. If you are just getting started with Kubespray, consider using the Kubespray defaults to deploy your cluster and explore Kubernetes.</p>
<h3 id=4-5-クラスタのデプロイ>(4/5) クラスタのデプロイ</h3>
<p>Next, deploy your cluster:</p>
<p>Cluster deployment using <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md#starting-custom-deployment>ansible-playbook</a>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ansible-playbook -i your/inventory/inventory.ini cluster.yml -b -v <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --private-key<span style=color:#666>=</span>~/.ssh/private_key
</code></pre></div><p>Large deployments (100+ nodes) may require <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/large-deployments.md>specific adjustments</a> for best results.</p>
<h3 id=5-5-デプロイの確認>(5/5) デプロイの確認</h3>
<p>Kubespray provides a way to verify inter-pod connectivity and DNS resolve with <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/netcheck.md>Netchecker</a>. Netchecker ensures the netchecker-agents pods can resolve DNS requests and ping each over within the default namespace. Those pods mimic similar behavior of the rest of the workloads and serve as cluster health indicators.</p>
<h2 id=クラスタの操作>クラスタの操作</h2>
<p>Kubespray provides additional playbooks to manage your cluster: <em>scale</em> and <em>upgrade</em>.</p>
<h3 id=クラスタのスケール>クラスタのスケール</h3>
<p>You can add worker nodes from your cluster by running the scale playbook. For more information, see "<a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md#adding-nodes>Adding nodes</a>".
You can remove worker nodes from your cluster by running the remove-node playbook. For more information, see "<a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/getting-started.md#remove-nodes>Remove nodes</a>".</p>
<h3 id=クラスタのアップグレード>クラスタのアップグレード</h3>
<p>You can upgrade your cluster by running the upgrade-cluster playbook. For more information, see "<a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/upgrades.md>Upgrades</a>".</p>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>You can reset your nodes and wipe out all components installed with Kubespray via the <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/reset.yml>reset playbook</a>.</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> When running the reset playbook, be sure not to accidentally target your production cluster!
</div>
<h2 id=フィードバック>フィードバック</h2>
<ul>
<li>Slack Channel: <a href=https://kubernetes.slack.com/messages/kubespray/>#kubespray</a> (You can get your invite <a href=https://slack.k8s.io/>here</a>)</li>
<li><a href=https://github.com/kubernetes-sigs/kubespray/issues>GitHub Issues</a></li>
</ul>
<h2 id=次の項目>次の項目</h2>
<p>Check out planned work on Kubespray's <a href=https://github.com/kubernetes-sigs/kubespray/blob/master/docs/roadmap.md>roadmap</a>.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e2eb3029b668b1713d0dc8bea296ba9c>2.3.3 - ターンキークラウドソリューション</h1>
</div>
<div class=td-content>
<h1 id=pg-20c20ee4c93be1062165131aff27cff5>2.3.3.1 - Alibaba CloudでKubernetesを動かす</h1>
<h2 id=alibaba-cloud-container-service>Alibaba Cloud Container Service</h2>
<p><a href=https://www.alibabacloud.com/product/container-service>Alibaba Cloud Container Service</a>はAlibaba Cloud ECSインスタンスのクラスター上もしくはサーバーレスの形態でDockerアプリケーションを起動して管理します。著名なオープンソースのコンテナオーケストレーターであるDocker SwarmおよびKubernetesをサポートしています。</p>
<p>クラスターの構築と管理を簡素化するために、<a href=https://www.alibabacloud.com/product/kubernetes>Alibaba Cloud Container ServiceのためのKubernetesサポート</a>を使用します。<a href=https://www.alibabacloud.com/help/doc-detail/86737.htm>Kubernetes walk-through</a>に従ってすぐに始めることができ、中国語の<a href=https://yq.aliyun.com/teams/11/type_blog-cid_200-page_1>Alibaba CloudにおけるKubernetesサポートのためのチュートリアル</a>もあります。</p>
<p>カスタムバイナリもしくはオープンソースKubernetesを使用する場合は、以下の手順に従って下さい。</p>
<h2 id=構築のカスタム>構築のカスタム</h2>
<p><a href=https://github.com/AliyunContainerService/kubernetes>Alibaba Cloudプロバイダーが実装されたKubernetesのソースコード</a>はオープンソースであり、GitHubから入手可能です。</p>
<p>さらなる情報は英語の<a href=https://www.alibabacloud.com/forum/read-830>Kubernetesのクイックデプロイメント - Alibaba CloudのVPC環境</a>をご覧下さい。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4db51d554f14646b6af380916c827aa0>2.3.3.2 - AWS EC2上でKubernetesを動かす</h1>
<p>このページでは、AWS上でKubernetesクラスターをインストールする方法について説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p>AWS上でKubernetesクラスターを作成するには、AWSからアクセスキーIDおよびシークレットアクセスキーを入手する必要があります。</p>
<h3 id=サポートされているプロダクショングレードのツール>サポートされているプロダクショングレードのツール</h3>
<ul>
<li>
<p><a href=https://docs.conjure-up.io/stable/en/cni/k8s-and-aws>conjure-up</a>はUbuntu上でネイティブなAWSインテグレーションを用いてKubernetesクラスターを作成するオープンソースのインストーラーです。</p>
</li>
<li>
<p><a href=https://github.com/kubernetes/kops>Kubernetes Operations</a> - プロダクショングレードなKubernetesのインストール、アップグレード、管理が可能です。AWS上のDebian、Ubuntu、CentOS、RHELをサポートしています。</p>
</li>
<li>
<p><a href=https://github.com/kubernetes-incubator/kube-aws>kube-aws</a> EC2、CloudFormation、Auto Scalingを使用して、<a href=https://www.flatcar-linux.org/>Flatcar Linux</a>ノードでKubernetesクラスターを作成および管理します。</p>
</li>
<li>
<p><a href=https://github.com/kubermatic/kubeone>KubeOne</a>は可用性の高いKubernetesクラスターを作成、アップグレード、管理するための、オープンソースのライフサイクル管理ツールです。</p>
</li>
</ul>
<h2 id=クラスターの始まり>クラスターの始まり</h2>
<h3 id=コマンドライン管理ツール-kubectl>コマンドライン管理ツール: kubectl</h3>
<p>クラスターの起動スクリプトによってワークステーション上に<code>kubernetes</code>ディレクトリが作成されます。もしくは、Kubernetesの最新リリースを<a href=https://github.com/kubernetes/kubernetes/releases>こちら</a>からダウンロードすることも可能です。</p>
<p>次に、kubectlにアクセスするために適切なバイナリフォルダーを<code>PATH</code>へ追加します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># macOS</span>
<span style=color:#a2f>export</span> <span style=color:#b8860b>PATH</span><span style=color:#666>=</span>&lt;path/to/kubernetes-directory&gt;/platforms/darwin/amd64:<span style=color:#b8860b>$PATH</span>

<span style=color:#080;font-style:italic># Linux</span>
<span style=color:#a2f>export</span> <span style=color:#b8860b>PATH</span><span style=color:#666>=</span>&lt;path/to/kubernetes-directory&gt;/platforms/linux/amd64:<span style=color:#b8860b>$PATH</span>
</code></pre></div><p>ツールに関する最新のドキュメントページはこちらです: <a href=/docs/reference/kubectl/kubectl/>kubectl manual</a></p>
<p>デフォルトでは、<code>kubectl</code>はクラスターの起動中に生成された<code>kubeconfig</code>ファイルをAPIに対する認証に使用します。
詳細な情報は、<a href=/ja/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig files</a>を参照してください。</p>
<h3 id=例>例</h3>
<p>新しいクラスターを試すには、<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>簡単なnginxの例</a>を参照してください。</p>
<p>"Guestbook"アプリケーションは、Kubernetesを始めるもう一つのポピュラーな例です: <a href=https://github.com/kubernetes/examples/tree/v1.22.16/guestbook/>guestbookの例</a></p>
<p>より完全なアプリケーションについては、<a href=https://github.com/kubernetes/examples/tree/v1.22.16/>examplesディレクトリ</a>を参照してください。</p>
<h2 id=クラスターのスケーリング>クラスターのスケーリング</h2>
<p><code>kubectl</code>を使用したノードの追加および削除はサポートしていません。インストール中に作成された<a href=https://docs.aws.amazon.com/autoscaling/latest/userguide/as-manual-scaling.html>Auto Scaling Group</a>内の'Desired'および'Max'プロパティを手動で調整することで、ノード数をスケールさせることができます。</p>
<h2 id=クラスターの解体>クラスターの解体</h2>
<p>クラスターのプロビジョニングに使用した環境変数がexportされていることを確認してから、<code>kubernetes</code>ディレクトリ内で以下のスクリプトを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cluster/kube-down.sh
</code></pre></div><h2 id=サポートレベル>サポートレベル</h2>
<table>
<thead>
<tr>
<th>IaaS プロバイダー</th>
<th>構成管理</th>
<th>OS</th>
<th>ネットワーク</th>
<th>ドキュメント</th>
<th>適合</th>
<th>サポートレベル</th>
</tr>
</thead>
<tbody>
<tr>
<td>AWS</td>
<td>kops</td>
<td>Debian</td>
<td>k8s (VPC)</td>
<td><a href=https://github.com/kubernetes/kops>docs</a></td>
<td></td>
<td>Community (<a href=https://github.com/justinsb>@justinsb</a>)</td>
</tr>
<tr>
<td>AWS</td>
<td>CoreOS</td>
<td>CoreOS</td>
<td>flannel</td>
<td>-</td>
<td></td>
<td>Community</td>
</tr>
<tr>
<td>AWS</td>
<td>Juju</td>
<td>Ubuntu</td>
<td>flannel, calico, canal</td>
<td>-</td>
<td>100%</td>
<td>Commercial, Community</td>
</tr>
<tr>
<td>AWS</td>
<td>KubeOne</td>
<td>Ubuntu, CoreOS, CentOS</td>
<td>canal, weavenet</td>
<td><a href=https://github.com/kubermatic/kubeone>docs</a></td>
<td>100%</td>
<td>Commercial, Community</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-66b96ad245efc180060593fa01df4dde>2.3.3.3 - Azure 上で Kubernetes を動かす</h1>
<h2 id=azure-kubernetes-service-aks>Azure Kubernetes Service (AKS)</h2>
<p><a href=https://azure.microsoft.com/ja-jp/services/kubernetes-service/>Azure Kubernetes Service</a>は、Kubernetesクラスターのためのシンプルなデプロイ機能を提供します。</p>
<p>Azure Kubernetes Serviceを利用してAzure上にKubernetesクラスターをデプロイする例:</p>
<p><strong><a href=https://docs.microsoft.com/ja-jp/azure/aks/intro-kubernetes>Microsoft Azure Kubernetes Service</a></strong></p>
<h2 id=デプロイのカスタマイズ-aks-engine>デプロイのカスタマイズ: AKS-Engine</h2>
<p>Azure Kubernetes Serviceのコア部分は<strong>オープンソース</strong>であり、コミュニティのためにGitHub上で公開され、利用およびコントリビュートすることができます: <strong><a href=https://github.com/Azure/aks-engine>AKS-Engine</a></strong>。レガシーな <a href=https://github.com/Azure/acs-engine>ACS-Engine</a> のコードベースはAKS-engineのために廃止となりました。</p>
<p>AKS-Engineは、Azure Kubernetes Serviceが公式にサポートしている機能を超えてデプロイをカスタマイズしたい場合に適した選択肢です。
既存の仮想ネットワークへのデプロイや、複数のagent poolを利用するなどのカスタマイズをすることができます。
コミュニティによるAKS-Engineへのコントリビュートが、Azure Kubernetes Serviceに組み込まれる場合もあります。</p>
<p>AKS-Engineへの入力は、Kubernetesクラスターを記述するapimodelのJSONファイルです。これはAzure Kubernetes Serviceを使用してクラスターを直接デプロイするために使用されるAzure Resource Manager (ARM) のテンプレート構文と似ています。
処理結果はARMテンプレートとして出力され、ソース管理に組み込んだり、AzureにKubernetesクラスターをデプロイするために使うことができます。</p>
<p><strong><a href=https://github.com/Azure/aks-engine/blob/master/docs/tutorials/README.md>AKS-Engine Kubernetes Tutorial</a></strong> を参照して始めることができます。</p>
<h2 id=azure上でcoreos-tectonicを動かす>Azure上でCoreOS Tectonicを動かす</h2>
<p>Azureで利用できるCoreOS Tectonic Installerは<strong>オープンソース</strong>であり、コミュニティのためにGitHub上で公開され、利用およびコントリビュートすることができます: <strong><a href=https://github.com/coreos/tectonic-installer>Tectonic Installer</a></strong>.</p>
<p>Tectonic Installerは、 <a href=https://www.terraform.io/docs/providers/azurerm/>Hashicorp が提供する Terraform</a>のAzure Resource Manager(ARM)プロバイダーを用いてクラスターをカスタマイズしたい場合に適した選択肢です。
これを利用することにより、Terraformと親和性の高いツールを使用してカスタマイズしたり連携したりすることができます。</p>
<p><a href=https://coreos.com/tectonic/docs/latest/install/azure/azure-terraform.html>Tectonic Installer for Azure Guide</a>を参照して、すぐに始めることができます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bed0528b13f56089ee19400212edf55d>2.3.3.4 - Google Compute Engine上でKubernetesを動かす</h1>
<p>The example below creates a Kubernetes cluster with 3 worker node Virtual Machines and a master Virtual Machine (i.e. 4 VMs in your cluster). This cluster is set up and controlled from your workstation (or wherever you find convenient).</p>
<h2 id=始める前に>始める前に</h2>
<p>If you want a simplified getting started experience and GUI for managing clusters, please consider trying <a href=https://cloud.google.com/kubernetes-engine/>Google Kubernetes Engine</a> for hosted cluster installation and management.</p>
<p>For an easy way to experiment with the Kubernetes development environment, click the button below
to open a Google Cloud Shell with an auto-cloned copy of the Kubernetes source repo.</p>
<p><a href="https://console.cloud.google.com/cloudshell/open?git_repo=https://github.com/kubernetes/kubernetes&page=editor&open_in_editor=README.md"><img src=https://gstatic.com/cloudssh/images/open-btn.png alt="Open in Cloud Shell"></a></p>
<p>If you want to use custom binaries or pure open source Kubernetes, please continue with the instructions below.</p>
<h3 id=前提条件>前提条件</h3>
<ol>
<li>You need a Google Cloud Platform account with billing enabled. Visit the <a href=https://console.cloud.google.com>Google Developers Console</a> for more details.</li>
<li>Install <code>gcloud</code> as necessary. <code>gcloud</code> can be installed as a part of the <a href=https://cloud.google.com/sdk/>Google Cloud SDK</a>.</li>
<li>Enable the <a href=https://console.developers.google.com/apis/api/replicapool.googleapis.com/overview>Compute Engine Instance Group Manager API</a> in the <a href=https://console.developers.google.com/apis/library>Google Cloud developers console</a>.</li>
<li>Make sure that gcloud is set to use the Google Cloud Platform project you want. You can check the current project using <code>gcloud config list project</code> and change it via <code>gcloud config set project &lt;project-id></code>.</li>
<li>Make sure you have credentials for GCloud by running <code>gcloud auth login</code>.</li>
<li>(Optional) In order to make API calls against GCE, you must also run <code>gcloud auth application-default login</code>.</li>
<li>Make sure you can start up a GCE VM from the command line. At least make sure you can do the <a href=https://cloud.google.com/compute/docs/instances/#startinstancegcloud>Create an instance</a> part of the GCE Quickstart.</li>
<li>Make sure you can SSH into the VM without interactive prompts. See the <a href=https://cloud.google.com/compute/docs/instances/#sshing>Log in to the instance</a> part of the GCE Quickstart.</li>
</ol>
<h2 id=クラスターの起動>クラスターの起動</h2>
<p>You can install a client and start a cluster with either one of these commands (we list both in case only one is installed on your machine):</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -sS https://get.k8s.io | bash
</code></pre></div><p>or</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget -q -O - https://get.k8s.io | bash
</code></pre></div><p>Once this command completes, you will have a master VM and four worker VMs, running as a Kubernetes cluster.</p>
<p>By default, some containers will already be running on your cluster. Containers like <code>fluentd</code> provide <a href=/docs/concepts/cluster-administration/logging/>logging</a>, while <code>heapster</code> provides <a href=https://releases.k8s.io/master/cluster/addons/cluster-monitoring/README.md>monitoring</a> services.</p>
<p>The script run by the commands above creates a cluster with the name/prefix "kubernetes". It defines one specific cluster config, so you can't run it more than once.</p>
<p>Alternately, you can download and install the latest Kubernetes release from <a href=https://github.com/kubernetes/kubernetes/releases>this page</a>, then run the <code>&lt;kubernetes>/cluster/kube-up.sh</code> script to start the cluster:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>cd</span> kubernetes
cluster/kube-up.sh
</code></pre></div><p>If you want more than one cluster running in your project, want to use a different name, or want a different number of worker nodes, see the <code>&lt;kubernetes>/cluster/gce/config-default.sh</code> file for more fine-grained configuration before you start up your cluster.</p>
<p>If you run into trouble, please see the section on <a href=/ja/docs/setup/production-environment/turnkey/gce/#troubleshooting>troubleshooting</a>, post to the
<a href=https://discuss.kubernetes.io>Kubernetes Forum</a>, or come ask questions on <code>#gke</code> Slack channel.</p>
<p>The next few steps will show you:</p>
<ol>
<li>How to set up the command line client on your workstation to manage the cluster</li>
<li>Examples of how to use the cluster</li>
<li>How to delete the cluster</li>
<li>How to start clusters with non-default options (like larger clusters)</li>
</ol>
<h2 id=ワークステーション上でのkubernetesコマンドラインツールのインストール>ワークステーション上でのKubernetesコマンドラインツールのインストール</h2>
<p>The cluster startup script will leave you with a running cluster and a <code>kubernetes</code> directory on your workstation.</p>
<p>The <a href=/docs/reference/kubectl/kubectl/>kubectl</a> tool controls the Kubernetes cluster
manager. It lets you inspect your cluster resources, create, delete, and update
components, and much more. You will use it to look at your new cluster and bring
up example apps.</p>
<p>You can use <code>gcloud</code> to install the <code>kubectl</code> command-line tool on your workstation:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>gcloud components install kubectl
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> The kubectl version bundled with <code>gcloud</code> may be older than the one
The <a href=/ja/docs/reference/kubectl/kubectl/>kubectl</a> tool controls the Kubernetes cluster
document to see how you can set up the latest <code>kubectl</code> on your workstation.
</div>
<h2 id=クラスターの始まり>クラスターの始まり</h2>
<h3 id=クラスターの様子を見る>クラスターの様子を見る</h3>
<p>Once <code>kubectl</code> is in your path, you can use it to look at your cluster. E.g., running:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get --all-namespaces services
</code></pre></div><p>should show a set of <a href=/docs/concepts/services-networking/service/>services</a> that look something like this:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAMESPACE     NAME          TYPE             CLUSTER_IP       EXTERNAL_IP       PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>        AGE
default       kubernetes    ClusterIP        10.0.0.1         &lt;none&gt;            443/TCP        1d
kube-system   kube-dns      ClusterIP        10.0.0.2         &lt;none&gt;            53/TCP,53/UDP  1d
kube-system   kube-ui       ClusterIP        10.0.0.3         &lt;none&gt;            80/TCP         1d
...
</code></pre></div><p>Similarly, you can take a look at the set of <a href=/ja/docs/concepts/workloads/pods/>pods</a> that were created during cluster startup.
You can do this via the</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get --all-namespaces pods
</code></pre></div><p>command.</p>
<p>You'll see a list of pods that looks something like this (the name specifics will be different):</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAMESPACE     NAME                                           READY     STATUS    RESTARTS   AGE
kube-system   coredns-5f4fbb68df-mc8z8                       1/1       Running   <span style=color:#666>0</span>          15m
kube-system   fluentd-cloud-logging-kubernetes-minion-63uo   1/1       Running   <span style=color:#666>0</span>          14m
kube-system   fluentd-cloud-logging-kubernetes-minion-c1n9   1/1       Running   <span style=color:#666>0</span>          14m
kube-system   fluentd-cloud-logging-kubernetes-minion-c4og   1/1       Running   <span style=color:#666>0</span>          14m
kube-system   fluentd-cloud-logging-kubernetes-minion-ngua   1/1       Running   <span style=color:#666>0</span>          14m
kube-system   kube-ui-v1-curt1                               1/1       Running   <span style=color:#666>0</span>          15m
kube-system   monitoring-heapster-v5-ex4u3                   1/1       Running   <span style=color:#666>1</span>          15m
kube-system   monitoring-influx-grafana-v1-piled             2/2       Running   <span style=color:#666>0</span>          15m
</code></pre></div><p>Some of the pods may take a few seconds to start up (during this time they'll show <code>Pending</code>), but check that they all show as <code>Running</code> after a short period.</p>
<h3 id=いくつかの例の実行>いくつかの例の実行</h3>
<p>Then, see <a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>a simple nginx example</a> to try out your new cluster.</p>
<p>For more complete applications, please look in the <a href=https://github.com/kubernetes/examples/tree/v1.22.16/>examples directory</a>. The <a href=https://github.com/kubernetes/examples/tree/v1.22.16/guestbook/>guestbook example</a> is a good "getting started" walkthrough.</p>
<h2 id=クラスターの解体>クラスターの解体</h2>
<p>To remove/delete/teardown the cluster, use the <code>kube-down.sh</code> script.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>cd</span> kubernetes
cluster/kube-down.sh
</code></pre></div><p>Likewise, the <code>kube-up.sh</code> in the same directory will bring it back up. You do not need to rerun the <code>curl</code> or <code>wget</code> command: everything needed to setup the Kubernetes cluster is now on your workstation.</p>
<h2 id=カスタマイズ>カスタマイズ</h2>
<p>The script above relies on Google Storage to stage the Kubernetes release. It
then will start (by default) a single master VM along with 3 worker VMs. You
can tweak some of these parameters by editing <code>kubernetes/cluster/gce/config-default.sh</code>
You can view a transcript of a successful cluster creation
<a href=https://gist.github.com/satnam6502/fc689d1b46db9772adea>here</a>.</p>
<h2 id=トラブルシューティング>トラブルシューティング</h2>
<h3 id=プロジェクトの設定>プロジェクトの設定</h3>
<p>You need to have the Google Cloud Storage API, and the Google Cloud Storage
JSON API enabled. It is activated by default for new projects. Otherwise, it
can be done in the Google Cloud Console. See the <a href=https://cloud.google.com/storage/docs/json_api/>Google Cloud Storage JSON
API Overview</a> for more
details.</p>
<p>Also ensure that-- as listed in the <a href=#%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6>Prerequisites section</a>-- you've enabled the <code>Compute Engine Instance Group Manager API</code>, and can start up a GCE VM from the command line as in the <a href=https://cloud.google.com/compute/docs/quickstart>GCE Quickstart</a> instructions.</p>
<h3 id=クラスター初期化のハング>クラスター初期化のハング</h3>
<p>If the Kubernetes startup script hangs waiting for the API to be reachable, you can troubleshoot by SSHing into the master and node VMs and looking at logs such as <code>/var/log/startupscript.log</code>.</p>
<p><strong>Once you fix the issue, you should run <code>kube-down.sh</code> to cleanup</strong> after the partial cluster creation, before running <code>kube-up.sh</code> to try again.</p>
<h3 id=ssh>SSH</h3>
<p>If you're having trouble SSHing into your instances, ensure the GCE firewall
isn't blocking port 22 to your VMs. By default, this should work but if you
have edited firewall rules or created a new non-default network, you'll need to
expose it: <code>gcloud compute firewall-rules create default-ssh --network=&lt;network-name> --description "SSH allowed from anywhere" --allow tcp:22</code></p>
<p>Additionally, your GCE SSH key must either have no passcode or you need to be
using <code>ssh-agent</code>.</p>
<h3 id=ネットワーク>ネットワーク</h3>
<p>The instances must be able to connect to each other using their private IP. The
script uses the "default" network which should have a firewall rule called
"default-allow-internal" which allows traffic on any port on the private IPs.
If this rule is missing from the default network or if you change the network
being used in <code>cluster/config-default.sh</code> create a new rule with the following
field values:</p>
<ul>
<li>Source Ranges: <code>10.0.0.0/8</code></li>
<li>Allowed Protocols and Port: <code>tcp:1-65535;udp:1-65535;icmp</code></li>
</ul>
<h2 id=サポートレベル>サポートレベル</h2>
<table>
<thead>
<tr>
<th>IaaS Provider</th>
<th>Config. Mgmt</th>
<th>OS</th>
<th>Networking</th>
<th>Docs</th>
<th>Conforms</th>
<th>Support Level</th>
</tr>
</thead>
<tbody>
<tr>
<td>GCE</td>
<td>Saltstack</td>
<td>Debian</td>
<td>GCE</td>
<td><a href=/ja/docs/setup/production-environment/turnkey/gce/>docs</a></td>
<td></td>
<td>Project</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ba2691e5872ead2141b1e8fd7d29ee21>2.3.3.5 - IBM Cloud Privateを使ってマルチクラウドでKubernetesを動かす</h1>
<p>IBM® Cloud Private is a turnkey cloud solution and an on-premises turnkey cloud solution. IBM Cloud Private delivers pure upstream Kubernetes with the typical management components that are required to run real enterprise workloads. These workloads include health management, log management, audit trails, and metering for tracking usage of workloads on the platform.</p>
<p>IBM Cloud Private is available in a community edition and a fully supported enterprise edition. The community edition is available at no charge from <a href=https://hub.docker.com/r/ibmcom/icp-inception/>Docker Hub</a>. The enterprise edition supports high availability topologies and includes commercial support from IBM for Kubernetes and the IBM Cloud Private management platform. If you want to try IBM Cloud Private, you can use either the hosted trial, the tutorial, or the self-guided demo. You can also try the free community edition. For details, see <a href=https://www.ibm.com/cloud/private/get-started>Get started with IBM Cloud Private</a>.</p>
<p>For more information, explore the following resources:</p>
<ul>
<li><a href=https://www.ibm.com/cloud/private>IBM Cloud Private</a></li>
<li><a href=https://github.com/ibm-cloud-architecture/refarch-privatecloud>Reference architecture for IBM Cloud Private</a></li>
<li><a href=https://www.ibm.com/support/knowledgecenter/SSBS6K/product_welcome_cloud_private.html>IBM Cloud Private documentation</a></li>
</ul>
<h2 id=ibm-cloud-privateとterraform>IBM Cloud PrivateとTerraform</h2>
<p>The following modules are available where you can deploy IBM Cloud Private by using Terraform:</p>
<ul>
<li>AWS: <a href=https://github.com/ibm-cloud-architecture/terraform-icp-aws>Deploy IBM Cloud Private to AWS</a></li>
<li>Azure: <a href=https://github.com/ibm-cloud-architecture/terraform-icp-azure>Deploy IBM Cloud Private to Azure</a></li>
<li>IBM Cloud: <a href=https://github.com/ibm-cloud-architecture/terraform-icp-ibmcloud>Deploy IBM Cloud Private cluster to IBM Cloud</a></li>
<li>OpenStack: <a href=https://github.com/ibm-cloud-architecture/terraform-icp-openstack>Deploy IBM Cloud Private to OpenStack</a></li>
<li>Terraform module: <a href=https://github.com/ibm-cloud-architecture/terraform-module-icp-deploy>Deploy IBM Cloud Private on any supported infrastructure vendor</a></li>
<li>VMware: <a href=https://github.com/ibm-cloud-architecture/terraform-icp-vmware>Deploy IBM Cloud Private to VMware</a></li>
</ul>
<h2 id=aws上でのibm-cloud-private>AWS上でのIBM Cloud Private</h2>
<p>You can deploy an IBM Cloud Private cluster on Amazon Web Services (AWS) using Terraform.</p>
<p>IBM Cloud Private can also run on the AWS cloud platform by using Terraform. To deploy IBM Cloud Private in an AWS EC2 environment, see <a href=https://github.com/ibm-cloud-architecture/terraform-icp-aws>Installing IBM Cloud Private on AWS</a>.</p>
<h2 id=azure上でのibm-cloud-private>Azure上でのIBM Cloud Private</h2>
<p>You can enable Microsoft Azure as a cloud provider for IBM Cloud Private deployment and take advantage of all the IBM Cloud Private features on the Azure public cloud. For more information, see <a href=https://www.ibm.com/support/knowledgecenter/SSBS6K_3.2.0/supported_environments/azure_overview.html>IBM Cloud Private on Azure</a>.</p>
<h2 id=red-hat-openshiftを用いたibm-cloud-private>Red Hat OpenShiftを用いたIBM Cloud Private</h2>
<p>You can deploy IBM certified software containers that are running on IBM Cloud Private onto Red Hat OpenShift.</p>
<p>Integration capabilities:</p>
<ul>
<li>Supports Linux® 64-bit platform in offline-only installation mode</li>
<li>Single-master configuration</li>
<li>Integrated IBM Cloud Private cluster management console and catalog</li>
<li>Integrated core platform services, such as monitoring, metering, and logging</li>
<li>IBM Cloud Private uses the OpenShift image registry</li>
</ul>
<p>For more information see, <a href=https://www.ibm.com/support/knowledgecenter/SSBS6K_3.2.0/supported_environments/openshift/overview.html>IBM Cloud Private on OpenShift</a>.</p>
<h2 id=virtualbox上でのibm-cloud-private>VirtualBox上でのIBM Cloud Private</h2>
<p>To install IBM Cloud Private to a VirtualBox environment, see <a href=https://github.com/ibm-cloud-architecture/refarch-privatecloud-virtualbox>Installing IBM Cloud Private on VirtualBox</a>.</p>
<h2 id=vmware上でのibm-cloud-private>VMware上でのIBM Cloud Private</h2>
<p>You can install IBM Cloud Private on VMware with either Ubuntu or RHEL images. For details, see the following projects:</p>
<ul>
<li><a href=https://github.com/ibm-cloud-architecture/refarch-privatecloud/blob/master/Installing_ICp_on_prem_ubuntu.md>Installing IBM Cloud Private with Ubuntu</a></li>
<li><a href=https://github.com/ibm-cloud-architecture/refarch-privatecloud/tree/master/icp-on-rhel>Installing IBM Cloud Private with Red Hat Enterprise</a></li>
</ul>
<p>The IBM Cloud Private Hosted service automatically deploys IBM Cloud Private Hosted on your VMware vCenter Server instances. This service brings the power of microservices and containers to your VMware environment on IBM Cloud. With this service, you can extend the same familiar VMware and IBM Cloud Private operational model and tools from on-premises into the IBM Cloud.</p>
<p>For more information, see <a href="https://cloud.ibm.com/docs/vmwaresolutions?topic=vmwaresolutions-icp_overview">IBM Cloud Private Hosted service</a>.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1b751cdddc397a65edb7bcf703bc0414>2.3.4 - オンプレミスVM</h1>
</div>
<div class=td-content>
<h1 id=pg-83a1f15a6fa96fcdca228c4a70f392b3>2.3.4.1 - Cloudstack</h1>
<p><a href=https://cloudstack.apache.org/>CloudStack</a> is a software to build public and private clouds based on hardware virtualization principles (traditional IaaS). To deploy Kubernetes on CloudStack there are several possibilities depending on the Cloud being used and what images are made available. CloudStack also has a vagrant plugin available, hence Vagrant could be used to deploy Kubernetes either using the existing shell provisioner or using new Salt based recipes.</p>
<p><a href=https://coreos.com>CoreOS</a> templates for CloudStack are built <a href=https://stable.release.core-os.net/amd64-usr/current/>nightly</a>. CloudStack operators need to <a href=https://docs.cloudstack.apache.org/projects/cloudstack-administration/en/latest/templates.html>register</a> this template in their cloud before proceeding with these Kubernetes deployment instructions.</p>
<p>This guide uses a single <a href=https://github.com/apachecloudstack/k8s>Ansible playbook</a>, which is completely automated and can deploy Kubernetes on a CloudStack based Cloud using CoreOS images. The playbook, creates an ssh key pair, creates a security group and associated rules and finally starts coreOS instances configured via cloud-init.</p>
<h2 id=前提条件>前提条件</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo apt-get install -y python-pip libssl-dev
sudo pip install cs
sudo pip install sshpubkeys
sudo apt-get install software-properties-common
sudo apt-add-repository ppa:ansible/ansible
sudo apt-get update
sudo apt-get install ansible
</code></pre></div><p>On CloudStack server you also have to install libselinux-python :</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>yum install libselinux-python
</code></pre></div><p><a href=https://github.com/exoscale/cs><em>cs</em></a> is a python module for the CloudStack API.</p>
<p>Set your CloudStack endpoint, API keys and HTTP method used.</p>
<p>You can define them as environment variables: <code>CLOUDSTACK_ENDPOINT</code>, <code>CLOUDSTACK_KEY</code>, <code>CLOUDSTACK_SECRET</code> and <code>CLOUDSTACK_METHOD</code>.</p>
<p>Or create a <code>~/.cloudstack.ini</code> file:</p>
<pre><code class=language-none data-lang=none>[cloudstack]
endpoint = &lt;your cloudstack api endpoint&gt;
key = &lt;your api access key&gt;
secret = &lt;your api secret key&gt;
method = post
</code></pre><p>We need to use the http POST method to pass the <em>large</em> userdata to the coreOS instances.</p>
<h3 id=playbookのクローン>playbookのクローン</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>git clone https://github.com/apachecloudstack/k8s
<span style=color:#a2f>cd</span> kubernetes-cloudstack
</code></pre></div><h3 id=kubernetesクラスターの作成>Kubernetesクラスターの作成</h3>
<p>You simply need to run the playbook.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ansible-playbook k8s.yml
</code></pre></div><p>Some variables can be edited in the <code>k8s.yml</code> file.</p>
<pre><code class=language-none data-lang=none>vars:
  ssh_key: k8s
  k8s_num_nodes: 2
  k8s_security_group_name: k8s
  k8s_node_prefix: k8s2
  k8s_template: &lt;templatename&gt;
  k8s_instance_type: &lt;serviceofferingname&gt;
</code></pre><p>This will start a Kubernetes master node and a number of compute nodes (by default 2).
The <code>instance_type</code> and <code>template</code> are specific, edit them to specify your CloudStack cloud specific template and instance type (i.e. service offering).</p>
<p>Check the tasks and templates in <code>roles/k8s</code> if you want to modify anything.</p>
<p>Once the playbook as finished, it will print out the IP of the Kubernetes master:</p>
<pre><code class=language-none data-lang=none>TASK: [k8s | debug msg='k8s master IP is {{ k8s_master.default_ip }}'] ********
</code></pre><p>SSH to it using the key that was created and using the <em>core</em> user.</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ssh -i ~/.ssh/id_rsa_k8s core@&lt;master IP&gt;
</code></pre></div><p>And you can list the machines in your cluster:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>fleetctl list-machines
</code></pre></div><pre><code class=language-none data-lang=none>MACHINE        IP             METADATA
a017c422...    &lt;node #1 IP&gt;   role=node
ad13bf84...    &lt;master IP&gt;    role=master
e9af8293...    &lt;node #2 IP&gt;   role=node
</code></pre><h2 id=サポートレベル>サポートレベル</h2>
<table>
<thead>
<tr>
<th>IaaS Provider</th>
<th>Config. Mgmt</th>
<th>OS</th>
<th>Networking</th>
<th>Docs</th>
<th>Conforms</th>
<th>Support Level</th>
</tr>
</thead>
<tbody>
<tr>
<td>CloudStack</td>
<td>Ansible</td>
<td>CoreOS</td>
<td>flannel</td>
<td><a href=/docs/setup/production-environment/on-premises-vm/cloudstack/>docs</a></td>
<td></td>
<td>Community (<a href=https://github.com/ltupin/>@Guiques</a>)</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-89a44f01ba43ac7fda5e20024b9d6cea>2.3.4.2 - DC/OS上のKubernetes</h1>
<p>Mesosphereは<a href=https://mesosphere.com/product/>DC/OS</a>上にKubernetesを構築するための簡単な選択肢を提供します。それは</p>
<ul>
<li>純粋なアップストリームのKubernetes</li>
<li>シングルクリッククラスター構築</li>
<li>デフォルトで高可用であり安全</li>
<li>Kubernetesが高速なデータプラットフォーム(例えばAkka、Cassandra、Kafka、Spark)と共に稼働</li>
</ul>
<p>です。</p>
<h2 id=公式mesosphereガイド>公式Mesosphereガイド</h2>
<p>DC/OS入門の正規のソースは<a href=https://github.com/mesosphere/dcos-kubernetes-quickstart>クイックスタートリポジトリ</a>にあります。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7f608a89334fa86add74d0d6ba0beedf>2.3.4.3 - oVirt</h1>
<p>oVirt is a virtual datacenter manager that delivers powerful management of multiple virtual machines on multiple hosts. Using KVM and libvirt, oVirt can be installed on Fedora, CentOS, or Red Hat Enterprise Linux hosts to set up and manage your virtual data center.</p>
<h2 id=ovirtクラウドプロバイダーによる構築>oVirtクラウドプロバイダーによる構築</h2>
<p>The oVirt cloud provider allows to easily discover and automatically add new VM instances as nodes to your Kubernetes cluster.
At the moment there are no community-supported or pre-loaded VM images including Kubernetes but it is possible to <a href=https://ovedou.blogspot.it/2014/03/importing-glance-images-as-ovirt.html>import</a> or <a href=https://www.ovirt.org/documentation/quickstart/quickstart-guide/#create-virtual-machines>install</a> Project Atomic (or Fedora) in a VM to <a href=https://www.ovirt.org/documentation/quickstart/quickstart-guide/#using-templates>generate a template</a>. Any other distribution that includes Kubernetes may work as well.</p>
<p>It is mandatory to <a href=https://www.ovirt.org/documentation/how-to/guest-agent/install-the-guest-agent-in-fedora/>install the ovirt-guest-agent</a> in the guests for the VM ip address and hostname to be reported to ovirt-engine and ultimately to Kubernetes.</p>
<p>Once the Kubernetes template is available it is possible to start instantiating VMs that can be discovered by the cloud provider.</p>
<h2 id=ovirtクラウドプロバイダーの使用>oVirtクラウドプロバイダーの使用</h2>
<p>The oVirt Cloud Provider requires access to the oVirt REST-API to gather the proper information, the required credential should be specified in the <code>ovirt-cloud.conf</code> file:</p>
<pre><code class=language-none data-lang=none>[connection]
uri = https://localhost:8443/ovirt-engine/api
username = admin@internal
password = admin
</code></pre><p>In the same file it is possible to specify (using the <code>filters</code> section) what search query to use to identify the VMs to be reported to Kubernetes:</p>
<pre><code class=language-none data-lang=none>[filters]
# Search query used to find nodes
vms = tag=kubernetes
</code></pre><p>In the above example all the VMs tagged with the <code>kubernetes</code> label will be reported as nodes to Kubernetes.</p>
<p>The <code>ovirt-cloud.conf</code> file then must be specified in kube-controller-manager:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kube-controller-manager ... --cloud-provider<span style=color:#666>=</span>ovirt --cloud-config<span style=color:#666>=</span>/path/to/ovirt-cloud.conf ...
</code></pre></div><h2 id=ovirtクラウドプロバイダーのスクリーンキャスト>oVirtクラウドプロバイダーのスクリーンキャスト</h2>
<p>This short screencast demonstrates how the oVirt Cloud Provider can be used to dynamically add VMs to your Kubernetes cluster.</p>
<p><a href="https://www.youtube.com/watch?v=JyyST4ZKne8"><img src=https://img.youtube.com/vi/JyyST4ZKne8/0.jpg alt=Screencast></a></p>
<h2 id=サポートレベル>サポートレベル</h2>
<table>
<thead>
<tr>
<th>IaaS Provider</th>
<th>Config. Mgmt</th>
<th>OS</th>
<th>Networking</th>
<th>Docs</th>
<th>Conforms</th>
<th>Support Level</th>
</tr>
</thead>
<tbody>
<tr>
<td>oVirt</td>
<td></td>
<td></td>
<td></td>
<td><a href=/docs/setup/production-environment/on-premises-vm/ovirt/>docs</a></td>
<td></td>
<td>Community (<a href=https://github.com/simon3z>@simon3z</a>)</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-acce7e24090fea04715a7a516ba3e69b>2.3.5 - Windows in Kubernetes</h1>
</div>
<div class=td-content>
<h1 id=pg-a307d413f1f7430fced233023087e2a1>2.3.5.1 - KubernetesのWindowsサポート概要</h1>
<p>Windowsアプリケーションは、多くの組織で実行されているサービスやアプリケーションの大部分を占めています。<a href=https://aka.ms/windowscontainers>Windowsコンテナ</a>は、プロセスとパッケージの依存関係を一つにまとめる最新の方法を提供し、DevOpsプラクティスの使用とWindowsアプリケーションのクラウドネイティブパターンの追求を容易にします。Kubernetesは事実上、標準的なコンテナオーケストレータになりました。Kubernetes 1.14のリリースでは、Kubernetesクラスター内のWindowsノードでWindowsコンテナをスケジューリングする本番環境サポートが含まれたので、Windowsアプリケーションの広大なエコシステムにおいて、Kubernetesを有効的に活用できます。WindowsベースのアプリケーションとLinuxベースのアプリケーションに投資している組織は、ワークロードを管理する個別のオーケストレーターが不要となるため、オペレーティングシステムに関係なくアプリケーション全体の運用効率が向上します。</p>
<h2 id=kubernetesのwindowsコンテナ>KubernetesのWindowsコンテナ</h2>
<p>KubernetesでWindowsコンテナのオーケストレーションを有効にする方法は、既存のLinuxクラスターにWindowsノードを含めるだけです。Kubernetesの<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>でWindowsコンテナをスケジュールすることは、Linuxベースのコンテナをスケジュールするのと同じくらいシンプルで簡単です。</p>
<p>Windowsコンテナを実行するには、Kubernetesクラスターに複数のオペレーティングシステムを含める必要があります。コントロールプレーンノードはLinux、ワーカーノードはワークロードのニーズに応じてWindowsまたはLinuxで実行します。Windows Server 2019は、サポートされている唯一のWindowsオペレーティングシステムであり、Windows (kubelet、<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/containerd>コンテナランタイム</a>、kube-proxyを含む)で<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>Kubernetesノード</a>を有効にします。Windowsディストリビューションチャンネルの詳細については、<a href=https://docs.microsoft.com/en-us/windows-server/get-started/servicing-channels-comparison>Microsoftのドキュメント</a>を参照してください。</p>
<p><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <a href=/ja/docs/concepts/overview/components/>マスターコンポーネント</a>を含むKubernetesコントロールプレーンは、Linuxで実行し続けます。WindowsのみのKubernetesクラスターを導入する計画はありません。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このドキュメントでは、Windowsコンテナについて説明する場合、プロセス分離のWindowsコンテナを意味します。<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container>Hyper-V分離</a>のWindowsコンテナは、将来リリースが計画されています。
</div></p>
<h2 id=サポートされている機能と制限>サポートされている機能と制限</h2>
<h3 id=サポートされている機能>サポートされている機能</h3>
<h4 id=コンピュート>コンピュート</h4>
<p>APIとkubectlの観点から見ると、WindowsコンテナはLinuxベースのコンテナとほとんど同じように動作します。ただし、制限セクションで概説されている主要な機能には、いくつかの顕著な違いがあります。</p>
<p>オペレーティングシステムのバージョンから始めましょう。KubernetesのWindowsオペレーティングシステムのサポートについては、次の表を参照してください。単一の混成Kubernetesクラスターは、WindowsとLinuxの両方のワーカーノードを持つことができます。WindowsコンテナはWindowsノードで、LinuxコンテナはLinuxノードでスケジュールする必要があります。</p>
<table>
<thead>
<tr>
<th>Kubernetes バージョン</th>
<th>ホストOS バージョン (Kubernetes ノード)</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><em>Windows Server 1709</em></td>
<td><em>Windows Server 1803</em></td>
<td><em>Windows Server 1809/Windows Server 2019</em></td>
</tr>
<tr>
<td><em>Kubernetes v1.14</em></td>
<td>サポートされていません</td>
<td>サポートされていません</td>
<td>Windows Server containers Builds 17763.* と Docker EE-basic 18.09 がサポートされています</td>
</tr>
</tbody>
</table>
<p><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> すべてのWindowsユーザーがアプリのオペレーティングシステムを頻繁に更新することは望んでいません。アプリケーションのアップグレードは、クラスターに新しいノードをアップグレードまたは導入することを要求する必要があります。Kubernetesで実行されているコンテナのオペレーティングシステムをアップグレードすることを選択したユーザーには、新しいオペレーティングシステムバージョンのサポート追加時に、ガイダンスと段階的な指示を提供します。このガイダンスには、クラスターノードと共にアプリケーションをアップグレードするための推奨アップグレード手順が含まれます。Windowsノードは、現在のLinuxノードと同じように、Kubernetes<a href=/ja/docs/setup/release/version-skew-policy/>バージョンスキューポリシー</a>(ノードからコントロールプレーンのバージョン管理)に準拠しています。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Windows Serverホストオペレーティングシステムには、<a href=https://www.microsoft.com/en-us/cloud-platform/windows-server-pricing>Windows Server</a>ライセンスが適用されます。Windowsコンテナイメージには、<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/images-eula>Windowsコンテナの追加ライセンス条項</a>ライセンスが提供されます。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> プロセス分離のWindowsコンテナには、<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/deploy-containers/version-compatibility>ホストOSのバージョンはコンテナのベースイメージのOSバージョンと一致する必要がある</a>という厳格な互換性ルールがあります。KubernetesでHyper-V分離のWindowsコンテナをサポートする際には、制限と互換性ルールが変更されます。
</div></p>
<p>Kubernetesの主要な要素は、WindowsでもLinuxと同じように機能します。このセクションでは、主要なワークロードイネーブラーのいくつかと、それらがWindowsにどのようにマップされるかについて説明します。</p>
<ul>
<li>
<p><a href=/ja/docs/concepts/workloads/pods/>Pods</a></p>
<p>Podは、Kubernetesにおける最も基本的な構成要素です。人間が作成またはデプロイするKubernetesオブジェクトモデルの中で最小かつ最もシンプルな単位です。WindowsとLinuxのコンテナを同じPodにデプロイすることはできません。Pod内のすべてのコンテナは、各ノードが特定のプラットフォームとアーキテクチャを表す単一のノードにスケジュールされます。次のPod機能、プロパティ、およびイベントがWindowsコンテナでサポートされています。:</p>
<ul>
<li>プロセス分離とボリューム共有を備えたPodごとの単一または複数のコンテナ</li>
<li>Podステータスフィールド</li>
<li>ReadinessとLiveness Probe</li>
<li>postStartとpreStopコンテナのライフサイクルイベント</li>
<li>環境変数またはボリュームとしてのConfigMap、 Secrets</li>
<li>EmptyDir</li>
<li>名前付きパイプホストマウント</li>
<li>リソース制限</li>
</ul>
</li>
<li>
<p><a href=/ja/docs/concepts/workloads/controllers/>Controllers</a></p>
<p>Kubernetesコントローラは、Podの望ましい状態を処理します。次のワークロードコントローラーは、Windowsコンテナでサポートされています。:</p>
<ul>
<li>ReplicaSet</li>
<li>ReplicationController</li>
<li>Deployments</li>
<li>StatefulSets</li>
<li>DaemonSet</li>
<li>Job</li>
<li>CronJob</li>
</ul>
</li>
<li>
<p><a href=/ja/docs/concepts/services-networking/service/>Services</a></p>
<p>Kubernetes Serviceは、Podの論理セットとPodにアクセスするためのポリシーを定義する抽象概念です。マイクロサービスと呼ばれることもあります。オペレーティングシステム間の接続にServiceを使用できます。WindowsでのServiceは、次のタイプ、プロパティと機能を利用できます。:</p>
<ul>
<li>サービス環境変数</li>
<li>NodePort</li>
<li>ClusterIP</li>
<li>LoadBalancer</li>
<li>ExternalName</li>
<li>Headless services</li>
</ul>
</li>
</ul>
<p>Pod、Controller、Serviceは、KubernetesでWindowsワークロードを管理するための重要な要素です。ただし、それだけでは、動的なクラウドネイティブ環境でWindowsワークロードの適切なライフサイクル管理を可能にするのに十分ではありません。次の機能のサポートを追加しました：</p>
<ul>
<li>Podとコンテナのメトリクス</li>
<li>Horizontal Pod Autoscalerサポート</li>
<li>kubectl Exec</li>
<li>リソースクォータ</li>
<li>Schedulerのプリエンプション</li>
</ul>
<h4 id=コンテナランタイム>コンテナランタイム</h4>
<h5 id=docker-ee>Docker EE</h5>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code>
</div>
<p>Docker EE-basic 18.09+は、Kubernetesを実行しているWindows Server 2019 / 1809ノードに推奨されるコンテナランタイムです。kubeletに含まれるdockershimコードで動作します。</p>
<h5 id=cri-containerd>CRI-ContainerD</h5>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [alpha]</code>
</div>
<p>ContainerDはLinux上のKubernetesで動作するOCI準拠のランタイムです。Kubernetes v1.18では、Windows上での<a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=ContainerD>ContainerD</a>のサポートが追加されています。Windows上でのContainerDの進捗状況は<a href=https://github.com/kubernetes/enhancements/issues/1001>enhancements#1001</a>で確認できます。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <p>Kubernetes v1.18におけるWindows上でのContainerDは以下の既知の欠点があります:</p>
<ul>
<li>ContainerDは公式リリースではWindowsをサポートしていません。すなわち、Kubernetesでのすべての開発はアクティブなContainerD開発ブランチに対して行われています。本番環境へのデプロイは常に、完全にテストされセキュリティ修正をサポートした公式リリースを利用するべきです。</li>
<li>ContainerDを利用した場合、Group Managed Service Accountsは実装されていません。詳細は<a href=https://github.com/containerd/cri/issues/1276>containerd/cri#1276</a>を参照してください。</li>
</ul>
</div>
<h4 id=永続ストレージ>永続ストレージ</h4>
<p>Kubernetes<a href=/docs/concepts/storage/volumes/>ボリューム</a>を使用すると、データの永続性とPodボリュームの共有要件を備えた複雑なアプリケーションをKubernetesにデプロイできます。特定のストレージバックエンドまたはプロトコルに関連付けられた永続ボリュームの管理には、ボリュームのプロビジョニング/プロビジョニング解除/サイズ変更、Kubernetesノードへのボリュームのアタッチ/デタッチ、およびデータを永続化する必要があるPod内の個別のコンテナへのボリュームのマウント/マウント解除などのアクションが含まれます。特定のストレージバックエンドまたはプロトコルに対してこれらのボリューム管理アクションを実装するコードは、Kubernetesボリューム<a href=/docs/concepts/storage/volumes/#types-of-volumes>プラグイン</a>の形式で出荷されます。次の幅広いクラスのKubernetesボリュームプラグインがWindowsでサポートされています。:</p>
<h5 id=in-treeボリュームプラグイン>In-treeボリュームプラグイン</h5>
<p>In-treeボリュームプラグインに関連付けられたコードは、コアKubernetesコードベースの一部として提供されます。In-treeボリュームプラグインのデプロイでは、追加のスクリプトをインストールしたり、個別のコンテナ化されたプラグインコンポーネントをデプロイしたりする必要はありません。これらのプラグインは、ストレージバックエンドでのボリュームのプロビジョニング/プロビジョニング解除とサイズ変更、Kubernetesノードへのボリュームのアタッチ/アタッチ解除、Pod内の個々のコンテナーへのボリュームのマウント/マウント解除を処理できます。次のIn-treeプラグインは、Windowsノードをサポートしています。:</p>
<ul>
<li><a href=/docs/concepts/storage/volumes/#awselasticblockstore>awsElasticBlockStore</a></li>
<li><a href=/docs/concepts/storage/volumes/#azuredisk>azureDisk</a></li>
<li><a href=/docs/concepts/storage/volumes/#azurefile>azureFile</a></li>
<li><a href=/docs/concepts/storage/volumes/#gcepersistentdisk>gcePersistentDisk</a></li>
<li><a href=/docs/concepts/storage/volumes/#vspherevolume>vsphereVolume</a></li>
</ul>
<h5 id=flexvolume-plugins>FlexVolume Plugins</h5>
<p><a href=/docs/concepts/storage/volumes/#flexVolume>FlexVolume</a>プラグインに関連付けられたコードは、ホストに直接デプロイする必要があるout-of-treeのスクリプトまたはバイナリとして出荷されます。FlexVolumeプラグインは、Kubernetesノードとの間のボリュームのアタッチ/デタッチ、およびPod内の個々のコンテナとの間のボリュームのマウント/マウント解除を処理します。FlexVolumeプラグインに関連付けられた永続ボリュームのプロビジョニング/プロビジョニング解除は、通常FlexVolumeプラグインとは別の外部プロビジョニング担当者を通じて処理できます。次のFlexVolume<a href=https://github.com/Microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows>プラグイン</a>は、Powershellスクリプトとしてホストにデプロイされ、Windowsノードをサポートします:</p>
<ul>
<li><a href=https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~smb.cmd>SMB</a></li>
<li><a href=https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~iscsi.cmd>iSCSI</a></li>
</ul>
<h5 id=csiプラグイン>CSIプラグイン</h5>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code>
</div>
<p><a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>プラグインに関連付けられたコードは、通常、コンテナイメージとして配布され、DaemonSetやStatefulSetなどの標準のKubernetesコンポーネントを使用してデプロイされるout-of-treeのスクリプトおよびバイナリとして出荷されます。CSIプラグインは、ボリュームのプロビジョニング/プロビジョニング解除/サイズ変更、Kubernetesノードへのボリュームのアタッチ/ボリュームからのデタッチ、Pod内の個々のコンテナへのボリュームのマウント/マウント解除、バックアップ/スナップショットとクローニングを使用した永続データのバックアップ/リストアといった、Kubernetesの幅広いボリューム管理アクションを処理します。CSIプラグインは通常、ノードプラグイン（各ノードでDaemonSetとして実行される）とコントローラープラグインで構成されます。</p>
<p>CSIノードプラグイン（特に、ブロックデバイスまたは共有ファイルシステムとして公開された永続ボリュームに関連付けられているプラ​​グイン）は、ディスクデバイスのスキャン、ファイルシステムのマウントなど、さまざまな特権操作を実行する必要があります。これらの操作は、ホストオペレーティングシステムごとに異なります。Linuxワーカーノードの場合、コンテナ化されたCSIノードプラグインは通常、特権コンテナとしてデプロイされます。Windowsワーカーノードの場合、コンテナ化されたCSIノードプラグインの特権操作は、<a href=https://github.com/kubernetes-csi/csi-proxy>csi-proxy</a>を使用してサポートされます。各Windowsノードにプリインストールされている。詳細については、展開するCSIプラグインの展開ガイドを参照してください。</p>
<h4 id=ネットワーキング>ネットワーキング</h4>
<p>Windowsコンテナのネットワークは、<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>CNIプラグイン</a>を通じて公開されます。Windowsコンテナは、ネットワークに関して仮想マシンと同様に機能します。各コンテナには、Hyper-V仮想スイッチ(vSwitch)に接続されている仮想ネットワークアダプター(vNIC)があります。Host Network Service(HNS)とHost Compute Service(HCS)は連携してコンテナを作成し、コンテナvNICをネットワークに接続します。HCSはコンテナの管理を担当するのに対し、HNSは次のようなネットワークリソースの管理を担当します。:</p>
<ul>
<li>仮想ネットワーク(vSwitchの作成を含む)</li>
<li>エンドポイント/vNIC</li>
<li>名前空間</li>
<li>ポリシー(パケットのカプセル化、負荷分散ルール、ACL、NATルールなど)</li>
</ul>
<p>次のServiceタイプがサポートされています。:</p>
<ul>
<li>NodePort</li>
<li>ClusterIP</li>
<li>LoadBalancer</li>
<li>ExternalName</li>
</ul>
<p>Windowsは、L2bridge、L2tunnel、Overlay、Transparent、NATの5つの異なるネットワークドライバー/モードをサポートしています。WindowsとLinuxのワーカーノードを持つ異種クラスターでは、WindowsとLinuxの両方で互換性のあるネットワークソリューションを選択する必要があります。以下のツリー外プラグインがWindowsでサポートされており、各CNIをいつ使用するかに関する推奨事項があります。:</p>
<table>
<thead>
<tr>
<th>ネットワークドライバー</th>
<th>説明</th>
<th>コンテナパケットの変更</th>
<th>ネットワークプラグイン</th>
<th>ネットワークプラグインの特性</th>
</tr>
</thead>
<tbody>
<tr>
<td>L2bridge</td>
<td>コンテナは外部のvSwitchに接続されます。コンテナはアンダーレイネットワークに接続されますが、物理ネットワークはコンテナのMACを上り/下りで書き換えるため、MACを学習する必要はありません。コンテナ間トラフィックは、コンテナホスト内でブリッジされます。</td>
<td>MACはホストのMACに書き換えられ、IPは変わりません。</td>
<td><a href=https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-bridge>win-bridge</a>、<a href=https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md>Azure-CNI</a>、Flannelホストゲートウェイは、win-bridgeを使用します。</td>
<td>win-bridgeはL2bridgeネットワークモードを使用して、コンテナをホストのアンダーレイに接続して、最高のパフォーマンスを提供します。ノード間接続にはユーザー定義ルート(UDR)が必要です。</td>
</tr>
<tr>
<td>L2Tunnel</td>
<td>これはl2bridgeの特殊なケースですが、Azureでのみ使用されます。すべてのパケットは、SDNポリシーが適用されている仮想化ホストに送信されます。</td>
<td>MACが書き換えられ、IPがアンダーレイネットワークで表示されます。</td>
<td><a href=https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md>Azure-CNI</a></td>
<td>Azure-CNIを使用すると、コンテナをAzure vNETと統合し、<a href=https://azure.microsoft.com/en-us/services/virtual-network/>Azure Virtual Networkが提供</a>する一連の機能を活用できます。たとえば、Azureサービスに安全に接続するか、Azure NSGを使用します。<a href=https://docs.microsoft.com/en-us/azure/aks/concepts-network#azure-cni-advanced-networking>azure-cniのいくつかの例</a>を参照してください。</td>
</tr>
<tr>
<td>オーバーレイ(KubernetesのWindows用のオーバーレイネットワークは <em>アルファ</em> 段階です)</td>
<td>コンテナには、外部のvSwitchに接続されたvNICが付与されます。各オーバーレイネットワークは、カスタムIPプレフィックスで定義された独自のIPサブネットを取得します。オーバーレイネットワークドライバーは、VXLANを使用してカプセル化します。</td>
<td>外部ヘッダーでカプセル化されます。</td>
<td><a href=https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-overlay>Win-overlay</a>、Flannel VXLAN (win-overlayを使用)</td>
<td>win-overlayは、仮想コンテナーネットワークをホストのアンダーレイから分離する必要がある場合に使用する必要があります(セキュリティ上の理由など)。データセンター内のIPが制限されている場合に、(異なるVNIDタグを持つ)異なるオーバーレイネットワークでIPを再利用できるようにします。このオプションには、Windows Server 2019で<a href=https://support.microsoft.com/help/4489899>KB4489899</a>が必要です。</td>
</tr>
<tr>
<td>透過的(<a href=https://github.com/openvswitch/ovn-kubernetes>ovn-kubernetes</a>の特別な使用例)</td>
<td>外部のvSwitchが必要です。コンテナは外部のvSwitchに接続され、論理ネットワーク(論理スイッチおよびルーター)を介したPod内通信を可能にします。</td>
<td>パケットは、<a href=https://datatracker.ietf.org/doc/draft-gross-geneve/>GENEVE</a>または<a href=https://datatracker.ietf.org/doc/draft-davie-stt/>STT</a>トンネリングを介してカプセル化され、同じホスト上にないポッドに到達します。パケットは、ovnネットワークコントローラーによって提供されるトンネルメタデータ情報を介して転送またはドロップされます。NATは南北通信のために行われます。</td>
<td><a href=https://github.com/openvswitch/ovn-kubernetes>ovn-kubernetes</a></td>
<td><a href=https://github.com/openvswitch/ovn-kubernetes/tree/master/contrib>ansible経由でデプロイ</a>します。分散ACLは、Kubernetesポリシーを介して適用できます。 IPAMをサポートします。負荷分散は、kube-proxyなしで実現できます。 NATは、ip​​tables/netshを使用せずに行われます。</td>
</tr>
<tr>
<td>NAT(<em>Kubernetesでは使用されません</em>)</td>
<td>コンテナには、内部のvSwitchに接続されたvNICが付与されます。DNS/DHCPは、<a href=https://blogs.technet.microsoft.com/virtualization/2016/05/25/windows-nat-winnat-capabilities-and-limitations/>WinNAT</a>と呼ばれる内部コンポーネントを使用して提供されます。</td>
<td>MACおよびIPはホストMAC/IPに書き換えられます。</td>
<td><a href=https://github.com/Microsoft/windows-container-networking/tree/master/plugins/nat>nat</a></td>
<td>完全を期すためにここに含まれています。</td>
</tr>
</tbody>
</table>
<p>上で概説したように、<a href=https://github.com/coreos/flannel>Flannel</a> CNI<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel>メタプラグイン</a>は、<a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan>VXLANネットワークバックエンド</a>(<strong>アルファサポート</strong>、win-overlayへのデリゲート)および<a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#host-gw>ホストゲートウェイネットワークバックエンド</a>(安定したサポート、win-bridgeへのデリゲート)を介して<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel#windows-support-experimental>Windows</a>でもサポートされます。このプラグインは、参照CNIプラグイン(win-overlay、win-bridge)の1つへの委任をサポートし、WindowsのFlannelデーモン(Flanneld)と連携して、ノードのサブネットリースの自動割り当てとHNSネットワークの作成を行います。このプラグインは、独自の構成ファイル(cni.conf)を読み取り、FlannelDで生成されたsubnet.envファイルからの環境変数と統合します。次に、ネットワークプラミング用の参照CNIプラグインの1つに委任し、ノード割り当てサブネットを含む正しい構成をIPAMプラグイン(ホストローカルなど)に送信します。</p>
<p>Node、Pod、およびServiceオブジェクトの場合、TCP/UDPトラフィックに対して次のネットワークフローがサポートされます。:</p>
<ul>
<li>Pod -> Pod (IP)</li>
<li>Pod -> Pod (Name)</li>
<li>Pod -> Service (Cluster IP)</li>
<li>Pod -> Service (PQDN、ただし、「.」がない場合のみ)</li>
<li>Pod -> Service (FQDN)</li>
<li>Pod -> External (IP)</li>
<li>Pod -> External (DNS)</li>
<li>Node -> Pod</li>
<li>Pod -> Node</li>
</ul>
<p>Windowsでは、次のIPAMオプションがサポートされています。</p>
<ul>
<li><a href=https://github.com/containernetworking/plugins/tree/master/plugins/ipam/host-local>ホストローカル</a></li>
<li>HNS IPAM (受信トレイプラットフォームIPAM、これはIPAMが設定されていない場合のフォールバック)</li>
<li><a href=https://github.com/Azure/azure-container-networking/blob/master/docs/ipam.md>Azure-vnet-ipam</a>(azure-cniのみ)</li>
</ul>
<h3 id=制限>制限</h3>
<h4 id=コントロールプレーン>コントロールプレーン</h4>
<p>Windowsは、Kubernetesアーキテクチャとコンポーネントマトリックスのワーカーノードとしてのみサポートされています。つまり、Kubernetesクラスタには常にLinuxマスターノード、0以上のLinuxワーカーノード、0以上のWindowsワーカーノードが含まれている必要があります。</p>
<h4 id=コンピュート-1>コンピュート</h4>
<h5 id=リソース管理とプロセス分離>リソース管理とプロセス分離</h5>
<p>Linux cgroupsは、Linuxのリソースを制御するPodの境界として使用されます。コンテナは、ネットワーク、プロセス、およびファイルシステムを分離するのために、その境界内に作成されます。cgroups APIを使用して、cpu/io/memoryの統計を収集できます。対照的に、Windowsはシステムネームスペースフィルターを備えたコンテナごとのジョブオブジェクトを使用して、コンテナ内のすべてのプロセスを格納し、ホストからの論理的な分離を提供します。ネームスペースフィルタリングを行わずにWindowsコンテナを実行する方法はありません。これは、ホストの環境ではシステム特権を主張できないため、Windowsでは特権コンテナを使用できないことを意味します。セキュリティアカウントマネージャー(SAM)が独立しているため、コンテナはホストからIDを引き受けることができません。</p>
<h5 id=オペレーティングシステムの制限>オペレーティングシステムの制限</h5>
<p>Windowsには厳密な互換性ルールがあり、ホストOSのバージョンとコンテナのベースイメージOSのバージョンは、一致する必要があります。Windows Server 2019のコンテナオペレーティングシステムを備えたWindowsコンテナのみがサポートされます。Hyper-V分離のコンテナは、Windowsコンテナのイメージバージョンに下位互換性を持たせることは、将来のリリースで計画されています。</p>
<h5 id=機能制限>機能制限</h5>
<ul>
<li>TerminationGracePeriod：実装されていません</li>
<li>単一ファイルのマッピング：CRI-ContainerDで実装されます</li>
<li>終了メッセージ：CRI-ContainerDで実装されます</li>
<li>特権コンテナ：現在Windowsコンテナではサポートされていません</li>
<li>HugePages：現在Windowsコンテナではサポートされていません</li>
<li>既存のノード問題を検出する機能はLinux専用であり、特権コンテナが必要です。一般的に、特権コンテナはサポートされていないため、これがWindowsで使用されることは想定していません。</li>
<li>ネームスペース共有については、すべての機能がサポートされているわけではありません（詳細については、APIセクションを参照してください）</li>
</ul>
<h5 id=メモリ予約と処理>メモリ予約と処理</h5>
<p>Windowsには、Linuxのようなメモリ不足のプロセスキラーはありません。Windowsは常に全ユーザーモードのメモリ割り当てを仮想として扱い、ページファイルは必須です。正味の効果は、WindowsはLinuxのようなメモリ不足の状態にはならず、メモリ不足（OOM）終了の影響を受ける代わりにページをディスクに処理します。メモリが過剰にプロビジョニングされ、物理メモリのすべてが使い果たされると、ページングによってパフォーマンスが低下する可能性があります。</p>
<p>2ステップのプロセスで、メモリ使用量を妥当な範囲内に保つことが可能です。まず、kubeletパラメータ<code>--kubelet-reserve</code>や<code>--system-reserve</code>を使用して、ノード（コンテナ外）でのメモリ使用量を明確にします。これにより、<a href=/ja/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>NodeAllocatable</a>)が削減されます。ワークロードをデプロイするときは、コンテナにリソース制限をかけます（制限のみを設定するか、制限が要求と等しくなければなりません）。これにより、NodeAllocatableも差し引かれ、ノードのリソースがフルな状態になるとSchedulerがPodを追加できなくなります。</p>
<p>過剰なプロビジョニングを回避するためのベストプラクティスは、Windows、Docker、およびKubernetesのプロセスに対応するために、最低2GBのメモリを予約したシステムでkubeletを構成することです。</p>
<p>フラグの振舞いについては、次のような異なる動作をします。:</p>
<ul>
<li><code>--kubelet-reserve</code>、<code>--system-reserve</code>、および<code>--eviction-hard</code>フラグはノードの割り当て可能数を更新します</li>
<li><code>--enforce-node-allocable</code>を使用した排除は実装されていません</li>
<li><code>--eviction-hard</code>および<code>--eviction-soft</code>を使用した排除は実装されていません</li>
<li>MemoryPressureの制約は実装されていません</li>
<li>kubeletによって実行されるOOMを排除することはありません</li>
<li>Windowsノードで実行されているKubeletにはメモリ制限がありません。<code>--kubelet-reserve</code>と<code>--system-reserve</code>は、ホストで実行されているkubeletまたはプロセスに制限を設定しません。これは、ホスト上のkubeletまたはプロセスが、NodeAllocatableとSchedulerの外でメモリリソース不足を引き起こす可能性があることを意味します。</li>
</ul>
<h4 id=ストレージ>ストレージ</h4>
<p>Windowsには、コンテナレイヤーをマウントして、NTFSに基づいて複製されたファイルシステムを作るためのレイヤー構造のファイルシステムドライバーがあります。コンテナ内のすべてのファイルパスは、そのコンテナの環境内だけで決められます。</p>
<ul>
<li>ボリュームマウントは、コンテナ内のディレクトリのみを対象にすることができ、個別のファイルは対象にできません</li>
<li>ボリュームマウントは、ファイルまたはディレクトリをホストファイルシステムに投影することはできません</li>
<li>WindowsレジストリとSAMデータベースには常に書き込みアクセスが必要であるため、読み取り専用ファイルシステムはサポートされていません。ただし、読み取り専用ボリュームはサポートされています</li>
<li>ボリュームのユーザーマスクと権限は使用できません。SAMはホストとコンテナ間で共有されないため、それらの間のマッピングはありません。すべての権限はコンテナの環境内で決められます</li>
</ul>
<p>その結果、次のストレージ機能はWindowsノードではサポートされません。</p>
<ul>
<li>ボリュームサブパスのマウント。Windowsコンテナにマウントできるのはボリューム全体だけです。</li>
<li>シークレットのサブパスボリュームのマウント</li>
<li>ホストマウントプロジェクション</li>
<li>DefaultMode（UID/GID依存関係による）</li>
<li>読み取り専用のルートファイルシステム。マップされたボリュームは引き続き読み取り専用をサポートします</li>
<li>ブロックデバイスマッピング</li>
<li>記憶媒体としてのメモリ</li>
<li>uui/guid、ユーザーごとのLinuxファイルシステム権限などのファイルシステム機能</li>
<li>NFSベースのストレージ/ボリュームのサポート</li>
<li>マウントされたボリュームの拡張（resizefs）</li>
</ul>
<h4 id=ネットワーキング-1>ネットワーキング</h4>
<p>Windowsコンテナネットワーキングは、Linuxネットワーキングとはいくつかの重要な実装方法の違いがあります。<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/container-networking/architecture>Microsoft documentation for Windows Container Networking</a>には、追加の詳細と背景があります。</p>
<p>Windowsホストネットワーキングサービスと仮想スイッチはネームスペースを実装して、Podまたはコンテナの必要に応じて仮想NICを作成できます。ただし、DNS、ルート、メトリックなどの多くの構成は、Linuxのような/etc/...ファイルではなく、Windowsレジストリデータベースに保存されます。コンテナのWindowsレジストリはホストのレジストリとは別であるため、ホストからコンテナへの/etc/resolv.confのマッピングなどの概念は、Linuxの場合と同じ効果をもたらしません。これらは、そのコンテナの環境で実行されるWindows APIを使用して構成する必要があります。したがって、CNIの実装は、ファイルマッピングに依存する代わりにHNSを呼び出して、ネットワークの詳細をPodまたはコンテナに渡す必要があります。</p>
<p>次のネットワーク機能はWindowsノードではサポートされていません</p>
<ul>
<li>ホストネットワーキングモードはWindows Podでは使用できません</li>
<li>ノード自体からのローカルNodePortアクセスは失敗します（他のノードまたは外部クライアントで機能）</li>
<li>ノードからのService VIPへのアクセスは、Windows Serverの将来のリリースで利用可能になる予定です</li>
<li>kube-proxyのオーバーレイネットワーキングサポートはアルファリリースです。さらに、<a href=https://support.microsoft.com/en-us/help/4482887/windows-10-update-kb4482887>KB4482887</a>がWindows Server 2019にインストールされている必要があります</li>
<li>ローカルトラフィックポリシーとDSRモード</li>
<li>l2bridge、l2tunnel、またはオーバーレイネットワークに接続されたWindowsコンテナは、IPv6スタックを介した通信をサポートしていません。これらのネットワークドライバーがIPv6アドレスを使用できるようにするために必要な機能として、優れたWindowsプラットフォームの機能があり、それに続いて、kubelet、kube-proxy、およびCNIプラグインといったKubernetesの機能があります。</li>
<li>win-overlay、win-bridge、およびAzure-CNIプラグインを介したICMPプロトコルを使用したアウトバウンド通信。具体的には、Windowsデータプレーン(<a href=https://www.microsoft.com/en-us/research/project/azure-virtual-filtering-platform/>VFP</a>)は、ICMPパケットの置き換えをサポートしていません。これの意味は：
<ul>
<li>同じネットワーク内の宛先に向けられたICMPパケット（pingを介したPod間通信など）は期待どおりに機能し、制限はありません</li>
<li>TCP/UDPパケットは期待どおりに機能し、制限はありません</li>
<li>リモートネットワーク（Podからping経由の外部インターネット通信など）を通過するように指示されたICMPパケットは置き換えできないため、ソースにルーティングされません。</li>
<li>TCP/UDPパケットは引き続き置き換えできるため、<code>ping &lt;destination></code>を<code>curl &lt;destination></code>に置き換えることで、外部への接続をデバッグできます。</li>
</ul>
</li>
</ul>
<p>これらの機能はKubernetes v1.15で追加されました。</p>
<ul>
<li><code>kubectl port-forward</code></li>
</ul>
<h5 id=cniプラグイン>CNIプラグイン</h5>
<ul>
<li>Windowsリファレンスネットワークプラグインのwin-bridgeとwin-overlayは、<a href=https://github.com/containernetworking/cni/blob/master/SPEC.md>CNI仕様</a>v0.4.0において「CHECK」実装がないため、今のところ実装されていません。</li>
<li>Flannel VXLAN CNIについては、Windowsで次の制限があります。:</li>
</ul>
<ol>
<li>Node-podの直接間接続は設計上不可能です。Flannel<a href=https://github.com/coreos/flannel/pull/1096>PR 1096</a>を使用するローカルPodでのみ可能です</li>
<li>VNI 4096とUDPポート4789の使用に制限されています。VNIの制限は現在取り組んでおり、将来のリリースで解決される予定です（オープンソースのflannelの変更）。これらのパラメーターの詳細については、公式の<a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan>Flannel VXLAN</a>バックエンドのドキュメントをご覧ください。</li>
</ol>
<h5 id=dns-limitations>DNS</h5>
<ul>
<li>ClusterFirstWithHostNetは、DNSでサポートされていません。Windowsでは、FQDNとしてすべての名前を「.」で扱い、PQDNでの名前解決はスキップします。</li>
<li>Linuxでは、PQDNで名前解決しようとするときに使用するDNSサフィックスリストがあります。Windowsでは、1つのDNSサフィックスしかありません。これは、そのPodのNamespaceに関連付けられているDNSサフィックスです（たとえば、mydns.svc.cluster.local）。Windowsでは、そのサフィックスだけで名前解決可能なFQDNおよびServiceまたはNameでの名前解決ができます。たとえば、defaultのNamespaceで生成されたPodには、DNSサフィックス<strong>default.svc.cluster.local</strong>が付けられます。WindowsのPodでは、<strong>kubernetes.default.svc.cluster.local</strong>と<strong>kubernetes</strong>の両方を名前解決できますが、<strong>kubernetes.default</strong>や<strong>kubernetes.default.svc</strong>のような中間での名前解決はできません。</li>
<li>Windowsでは、複数のDNSリゾルバーを使用できます。これらには少し異なる動作が付属しているため、ネームクエリの解決には<code>Resolve-DNSName</code>ユーティリティを使用することをお勧めします。</li>
</ul>
<h5 id=セキュリティ>セキュリティ</h5>
<p>Secretはノードのボリュームに平文テキストで書き込まれます（Linuxのtmpfs/in-memoryの比較として）。これはカスタマーが2つのことを行う必要があります</p>
<ol>
<li>ファイルACLを使用してSecretファイルの場所を保護する</li>
<li><a href=https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-how-to-deploy-on-windows-server>BitLocker</a>を使って、ボリュームレベルの暗号化を使用する</li>
</ol>
<p><a href=/docs/concepts/policy/pod-security-policy/#users-and-groups>RunAsUser</a>は、現在Windowsではサポートされていません。回避策は、コンテナをパッケージ化する前にローカルアカウントを作成することです。RunAsUsername機能は、将来のリリースで追加される可能性があります。</p>
<p>SELinux、AppArmor、Seccomp、特性（POSIX機能）のような、Linux固有のPodセキュリティ環境の権限はサポートされていません。</p>
<p>さらに、既に述べたように特権付きコンテナは、Windowsにおいてサポートされていません。</p>
<h4 id=api>API</h4>
<p>ほとんどのKubernetes APIがWindowsでも機能することに違いはありません。そのわずかな違いはOSとコンテナランタイムの違いによるものです。特定の状況では、PodやコンテナなどのワークロードAPIの一部のプロパティが、Linuxで実装されているが、Windowsでは実行できないことを前提に設計されています。</p>
<p>高いレベルで、これらOSのコンセプトに違いがります。:</p>
<ul>
<li>ID - Linuxでは、Integer型として表されるuserID（UID）とgroupID（GID）を使用します。ユーザー名とグループ名は正規ではありません - それらは、UID+GIDの背後にある<code>/etc/groups</code>または<code>/etc/passwd</code>の単なるエイリアスです。Windowsは、Windows Security Access Manager（SAM）データベースに格納されているより大きなバイナリセキュリティ識別子（SID）を使用します。このデータベースは、ホストとコンテナ間、またはコンテナ間で共有されません。</li>
<li>ファイル権限 - Windowsは、権限とUID+GIDのビットマスクではなく、SIDに基づくアクセス制御リストを使用します</li>
<li>ファイルパス - Windowsの規則では、<code>/</code>ではなく<code>\</code>を使用します。Go IOライブラリは通常両方を受け入れ、それを機能させるだけですが、コンテナ内で解釈されるパスまたはコマンドラインを設定する場合、<code>\</code>が必要になる場合があります。</li>
<li>シグナル - Windowsのインタラクティブなアプリは終了を異なる方法で処理し、次の1つ以上を実装できます。:
<ul>
<li>UIスレッドは、WM_CLOSEを含む明確に定義されたメッセージを処理します</li>
<li>コンソールアプリは、コントロールハンドラーを使用してctrl-cまたはctrl-breakを処理します</li>
<li>サービスは、SERVICE_CONTROL_STOP制御コードを受け入れることができるサービスコントロールハンドラー関数を登録します。</li>
</ul>
</li>
</ul>
<p>終了コードは、0が成功、0以外が失敗の場合と同じ規則に従います。特定のエラーコードは、WindowsとLinuxで異なる場合があります。ただし、Kubernetesのコンポーネント（kubelet、kube-proxy）から渡される終了コードは変更されていません。</p>
<h5 id=v1-container>V1.Container</h5>
<ul>
<li>V1.Container.ResourceRequirements.limits.cpuおよびV1.Container.ResourceRequirements.limits.memory - Windowsは、CPU割り当てにハード制限を使用しません。代わりに、共有システムが使用されます。ミリコアに基づく既存のフィールドは、Windowsスケジューラーによって追従される相対共有にスケーリングされます。<a href=https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/kuberuntime/helpers_windows.go>参照: kuberuntime/helpers_windows.go</a>、<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/resource-controls>参照: resource controls in Microsoft docs</a>
<ul>
<li>Huge Pagesは、Windowsコンテナランタイムには実装されてないので、使用できません。コンテナに対して設定できない<a href=https://docs.microsoft.com/en-us/windows/desktop/Memory/large-page-support>ユーザー特権を主張</a>する必要があります。</li>
</ul>
</li>
<li>V1.Container.ResourceRequirements.requests.cpuおよびV1.Container.ResourceRequirements.requests.memory - リクエストはノードの利用可能なリソースから差し引かれるので、ノードのオーバープロビジョニングを回避するために使用できます。ただし、過剰にプロビジョニングされたノードのリソースを保証するために使用することはできません。オペレーターが完全にプロビジョニングし過ぎないようにする場合は、ベストプラクティスとしてこれらをすべてのコンテナに適用する必要があります。</li>
<li>V1.Container.SecurityContext.allowPrivilegeEscalation - Windowsでは使用できません、接続されている機能はありません</li>
<li>V1.Container.SecurityContext.Capabilities - POSIX機能はWindowsでは実装されていません</li>
<li>V1.Container.SecurityContext.privileged - Windowsでは特権コンテナをサポートしていません</li>
<li>V1.Container.SecurityContext.procMount - Windowsでは/procファイルシステムがありません</li>
<li>V1.Container.SecurityContext.readOnlyRootFilesystem - Windowsでは使用できません、レジストリおよびシステムプロセスがコンテナ内で実行するには、書き込みアクセスが必要です</li>
<li>V1.Container.SecurityContext.runAsGroup - Windowsでは使用できません、GIDのサポートもありません</li>
<li>V1.Container.SecurityContext.runAsNonRoot - Windowsではrootユーザーが存在しません。最も近いものは、ノードに存在しないIDであるContainerAdministratorです。</li>
<li>V1.Container.SecurityContext.runAsUser - Windowsでは使用できません。intとしてのUIDはサポートされていません。</li>
<li>V1.Container.SecurityContext.seLinuxOptions - Windowsでは使用できません、SELinuxがありません</li>
<li>V1.Container.terminationMessagePath - これは、Windowsが単一ファイルのマッピングをサポートしないという点でいくつかの制限があります。デフォルト値は/dev/termination-logであり、デフォルトではWindowsに存在しないため動作します。</li>
</ul>
<h5 id=v1-pod>V1.Pod</h5>
<ul>
<li>V1.Pod.hostIPC、v1.pod.hostpid - Windowsではホストのネームスペースを共有することはできません</li>
<li>V1.Pod.hostNetwork - ホストのネットワークを共有するためのWindows OSサポートはありません</li>
<li>V1.Pod.dnsPolicy - ClusterFirstWithHostNet - Windowsではホストネットワーキングがサポートされていないため、サポートされていません。</li>
<li>V1.Pod.podSecurityContext - 以下のV1.PodSecurityContextを参照</li>
<li>V1.Pod.shareProcessNamespace - これはベータ版の機能であり、Windowsに実装されていないLinuxのNamespace機能に依存しています。Windowsでは、プロセスのネームスペースまたはコンテナのルートファイルシステムを共有できません。共有できるのはネットワークだけです。</li>
<li>V1.Pod.terminationGracePeriodSeconds - これはWindowsのDockerに完全には実装されていません。<a href=https://github.com/moby/moby/issues/25982>リファレンス</a>を参照してください。今日の動作では、ENTRYPOINTプロセスにCTRL_SHUTDOWN_EVENTが送信され、Windowsではデフォルトで5秒待機し、最後に通常のWindowsシャットダウン動作を使用してすべてのプロセスをシャットダウンします。5秒のデフォルトは、実際にはWindowsレジストリー<a href=https://github.com/moby/moby/issues/25982#issuecomment-426441183>コンテナ内</a>にあるため、コンテナ作成時にオーバーライドできます。</li>
<li>V1.Pod.volumeDevices - これはベータ機能であり、Windowsには実装されていません。Windowsでは、rawブロックデバイスをPodに接続できません。</li>
<li>V1.Pod.volumes-EmptyDir、Secret、ConfigMap、HostPath - すべて動作し、TestGridにテストがあります
<ul>
<li>V1.emptyDirVolumeSource - ノードのデフォルトのメディアはWindowsのディスクです。Windowsでは、RAMディスクが組み込まれていないため、メモリはサポートされていません。</li>
</ul>
</li>
<li>V1.VolumeMount.mountPropagation - mount propagationは、Windowsではサポートされていません。</li>
</ul>
<h5 id=v1-podsecuritycontext>V1.PodSecurityContext</h5>
<p>Windowsでは、PodSecurityContextフィールドはどれも機能しません。これらは参照用にここにリストされています。</p>
<ul>
<li>V1.PodSecurityContext.SELinuxOptions - SELinuxは、Windowsでは使用できません</li>
<li>V1.PodSecurityContext.RunAsUser - UIDを提供しますが、Windowsでは使用できません</li>
<li>V1.PodSecurityContext.RunAsGroup - GIDを提供しますが、Windowsでは使用できません</li>
<li>V1.PodSecurityContext.RunAsNonRoot - Windowsにはrootユーザーがありません。最も近いものは、ノードに存在しないIDであるContainerAdministratorです。</li>
<li>V1.PodSecurityContext.SupplementalGroups - GIDを提供しますが、Windowsでは使用できません</li>
<li>V1.PodSecurityContext.Sysctls - これらはLinuxのsysctlインターフェースの一部です。Windowsには同等のものはありません。</li>
</ul>
<h2 id=troubleshooting>ヘルプとトラブルシューティングを学ぶ</h2>
<p>Kubernetesクラスターのトラブルシューティングの主なヘルプソースは、この<a href=/docs/tasks/debug-application-cluster/troubleshooting/>セクション</a>から始める必要があります。このセクションには、いくつか追加的な、Windows固有のトラブルシューティングヘルプが含まれています。ログは、Kubernetesにおけるトラブルシューティング問題の重要な要素です。他のコントリビューターからトラブルシューティングの支援を求めるときは、必ずそれらを含めてください。SIG-Windows<a href=https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#gathering-logs>ログ収集に関するコントリビュートガイド</a>の指示に従ってください。</p>
<ol>
<li>
<p>start.ps1が正常に完了したことをどのように確認できますか？</p>
<p>ノード上でkubelet、kube-proxy、および（ネットワーキングソリューションとしてFlannelを選択した場合）flanneldホストエージェントプロセスが実行され、実行ログが個別のPowerShellウィンドウに表示されます。これに加えて、WindowsノードがKubernetesクラスターで「Ready」として表示されているはずです。</p>
</li>
<li>
<p>Kubernetesノードのプロセスをサービスとしてバックグラウンドで実行するように構成できますか？</p>
<p>Kubeletとkube-proxyは、ネイティブのWindowsサービスとして実行するように既に構成されています、障害（例えば、プロセスのクラッシュ）が発生した場合にサービスを自動的に再起動することにより、復元性を提供します。これらのノードコンポーネントをサービスとして構成するには、2つのオプションがあります。</p>
<ol>
<li>
<p>ネイティブWindowsサービスとして</p>
<p>Kubeletとkube-proxyは、<code>sc.exe</code>を使用してネイティブのWindowsサービスとして実行できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#080;font-style:italic># 2つの個別のコマンドでkubeletおよびkube-proxyのサービスを作成する</span>
sc.exe create &lt;component_name&gt; binPath= <span style=color:#b44>&#34;&lt;path_to_binary&gt; --service &lt;other_args&gt;&#34;</span>

<span style=color:#080;font-style:italic># 引数にスペースが含まれている場合は、エスケープする必要があることに注意してください。</span>
sc.exe create kubelet binPath= <span style=color:#b44>&#34;C:\kubelet.exe --service --hostname-override &#39;minion&#39; &lt;other_args&gt;&#34;</span>

<span style=color:#080;font-style:italic># サービスを開始する</span>
<span style=color:#a2f>Start-Service</span> kubelet
<span style=color:#a2f>Start-Service</span> <span style=color:#a2f>kube-proxy</span>

<span style=color:#080;font-style:italic># サービスを停止する</span>
<span style=color:#a2f>Stop-Service</span> kubelet (-Force)
<span style=color:#a2f>Stop-Service</span> <span style=color:#a2f>kube-proxy</span> (-Force)

<span style=color:#080;font-style:italic># サービスの状態を問い合わせる</span>
<span style=color:#a2f>Get-Service</span> kubelet
<span style=color:#a2f>Get-Service</span> <span style=color:#a2f>kube-proxy</span>
</code></pre></div></li>
<li>
<p>nssm.exeの使用</p>
<p>また、<a href=https://nssm.cc/>nssm.exe</a>などの代替サービスマネージャーを使用して、これらのプロセス（flanneld、kubelet、kube-proxy）をバックグラウンドで実行することもできます。この<a href=https://github.com/Microsoft/SDN/tree/master/Kubernetes/flannel/register-svc.ps1>サンプルスクリプト</a>を使用すると、nssm.exeを利用してkubelet、kube-proxy、flanneld.exeを登録し、Windowsサービスとしてバックグラウンドで実行できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>register-svc</span>.ps1 -NetworkMode &lt;Network mode&gt; -ManagementIP &lt;Windows Node IP&gt; -ClusterCIDR &lt;Cluster subnet&gt; -KubeDnsServiceIP &lt;<span style=color:#a2f>Kube-dns</span> Service IP&gt; -LogDir &lt;Directory to place logs&gt;

<span style=color:#080;font-style:italic># NetworkMode      = ネットワークソリューションとして選択されたネットワークモードl2bridge（flannel host-gw、これもデフォルト値）またはoverlay（flannel vxlan）</span>
<span style=color:#080;font-style:italic># ManagementIP     = Windowsノードに割り当てられたIPアドレス。 ipconfigを使用してこれを見つけることができます</span>
<span style=color:#080;font-style:italic># ClusterCIDR      = クラスターのサブネット範囲。（デフォルト値 10.244.0.0/16）</span>
<span style=color:#080;font-style:italic># KubeDnsServiceIP = Kubernetes DNSサービスIP（デフォルト値 10.96.0.10）</span>
<span style=color:#080;font-style:italic># LogDir           = kubeletおよびkube-proxyログがそれぞれの出力ファイルにリダイレクトされるディレクトリ（デフォルト値 C:\k）</span>
</code></pre></div><p>上記のスクリプトが適切でない場合は、次の例を使用してnssm.exeを手動で構成できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#080;font-style:italic># flanneld.exeを登録する</span>
nssm install flanneld C:\flannel\flanneld.exe
nssm <span style=color:#a2f>set </span>flanneld AppParameters --kubeconfig<span style=color:#666>-file</span>=c:\k\config --iface=&lt;ManagementIP&gt; --ip-masq=1 --kube-subnet-mgr=1
nssm <span style=color:#a2f>set </span>flanneld AppEnvironmentExtra NODE_NAME=&lt;hostname&gt;
nssm <span style=color:#a2f>set </span>flanneld AppDirectory C:\flannel
nssm <span style=color:#a2f>start </span>flanneld

<span style=color:#080;font-style:italic># kubelet.exeを登録</span>
<span style=color:#080;font-style:italic># マイクロソフトは、mcr.microsoft.com/k8s/core/pause:1.2.0としてポーズインフラストラクチャコンテナをリリース</span>
nssm install kubelet C:\k\kubelet.exe
nssm <span style=color:#a2f>set </span>kubelet AppParameters --hostname-override=&lt;hostname&gt; --v=6 --pod-infra-container-image=mcr.microsoft.com/k8s/core/pause<span>:</span>1.2.0 --resolv-conf=<span style=color:#b44>&#34;&#34;</span> --allow-privileged=true --enable-debugging-handlers --cluster-dns=&lt;<span style=color:#a2f>DNS-service</span>-IP&gt; --cluster-domain=cluster.local --kubeconfig=c:\k\config --hairpin-mode=<span style=color:#a2f>promiscuous-bridge</span> --image-pull-progress-deadline=20m --cgroups-per-qos=false  --log-dir=&lt;log directory&gt; --logtostderr=false --enforce-node-allocatable=<span style=color:#b44>&#34;&#34;</span> --network-plugin=cni --cni-bin-dir=c:\k\cni --cni-conf-dir=c:\k\cni\config
nssm <span style=color:#a2f>set </span>kubelet AppDirectory C:\k
nssm <span style=color:#a2f>start </span>kubelet

<span style=color:#080;font-style:italic># kube-proxy.exeを登録する (l2bridge / host-gw)</span>
nssm install <span style=color:#a2f>kube-proxy</span> C:\k\<span style=color:#a2f>kube-proxy</span>.exe
nssm <span style=color:#a2f>set kube-proxy</span> AppDirectory c:\k
nssm <span style=color:#a2f>set kube-proxy</span> AppParameters --v=4 --proxy-mode=kernelspace --hostname-override=&lt;hostname&gt;--kubeconfig=c:\k\config --enable-dsr=false --log-dir=&lt;log directory&gt; --logtostderr=false
nssm.exe <span style=color:#a2f>set kube-proxy</span> AppEnvironmentExtra KUBE_NETWORK=cbr0
nssm <span style=color:#a2f>set kube-proxy</span> DependOnService kubelet
nssm <span style=color:#a2f>start kube-proxy</span>

<span style=color:#080;font-style:italic># kube-proxy.exeを登録する (overlay / vxlan)</span>
nssm install <span style=color:#a2f>kube-proxy</span> C:\k\<span style=color:#a2f>kube-proxy</span>.exe
nssm <span style=color:#a2f>set kube-proxy</span> AppDirectory c:\k
nssm <span style=color:#a2f>set kube-proxy</span> AppParameters --v=4 --proxy-mode=kernelspace --feature-gates=<span style=color:#b44>&#34;WinOverlay=true&#34;</span> --hostname-override=&lt;hostname&gt; --kubeconfig=c:\k\config --network-name=vxlan0 --source-vip=&lt;<span style=color:#a2f>source-vip</span>&gt; --enable-dsr=false --log-dir=&lt;log directory&gt; --logtostderr=false
nssm <span style=color:#a2f>set kube-proxy</span> DependOnService kubelet
nssm <span style=color:#a2f>start kube-proxy</span>
</code></pre></div><p>最初のトラブルシューティングでは、<a href=https://nssm.cc/>nssm.exe</a>で次のフラグを使用して、stdoutおよびstderrを出力ファイルにリダイレクトできます。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>nssm <span style=color:#a2f>set </span>&lt;Service Name&gt; AppStdout C:\k\mysvc.log
nssm <span style=color:#a2f>set </span>&lt;Service Name&gt; AppStderr C:\k\mysvc.log
</code></pre></div><p>詳細については、公式の<a href=https://nssm.cc/usage>nssmの使用法</a>のドキュメントを参照してください。</p>
</li>
</ol>
</li>
<li>
<p>Windows Podにネットワーク接続がありません</p>
<p>仮想マシンを使用している場合は、すべてのVMネットワークアダプターでMACスプーフィングが有効になっていることを確認してください。</p>
</li>
<li>
<p>Windows Podが外部リソースにpingできません</p>
<p>現在、Windows Podには、ICMPプロトコル用にプログラムされた送信ルールはありません。ただし、TCP/UDPはサポートされています。クラスター外のリソースへの接続を実証する場合は、<code>ping &lt;IP></code>に対応する<code>curl &lt;IP></code>コマンドに置き換えてください。</p>
<p>それでも問題が解決しない場合は、<a href=https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf>cni.conf</a>のネットワーク構成に値する可能性があるので、いくつかの特別な注意が必要です。この静的ファイルはいつでも編集できます。構成の更新は、新しく作成されたすべてのKubernetesリソースに適用されます。</p>
<p>Kubernetesのネットワーキング要件の1つ(参照<a href=/ja/docs/concepts/cluster-administration/networking/>Kubernetesモデル</a>)は、内部でNATを使用せずにクラスター通信を行うためのものです。この要件を遵守するために、すべての通信に<a href=https://github.com/Microsoft/SDN/blob/master/Kubernetes/flannel/l2bridge/cni/config/cni.conf#L20>ExceptionList</a>があり、アウトバウンドNATが発生しないようにします。ただし、これは、クエリしようとしている外部IPをExceptionListから除外する必要があることも意味します。そうして初めて、Windows PodからのトラフィックがSNAT処理され、外部からの応答を受信できるようになります。この点で、<code>cni.conf</code>のExceptionListは次のようになります。:</p>
<pre><code class=language-conf data-lang=conf>&quot;ExceptionList&quot;: [
                &quot;10.244.0.0/16&quot;,  # クラスターのサブネット
                &quot;10.96.0.0/12&quot;,   # Serviceのサブネット
                &quot;10.127.130.0/24&quot; # 管理 (ホスト) のサブネット
            ]
</code></pre></li>
<li>
<p>WindowsノードがNodePort Serviceにアクセスできません</p>
<p>ノード自体からのローカルNodePortアクセスは失敗します。これは既知の制限です。NodePortアクセスは、他のノードまたは外部クライアントから行えます。</p>
</li>
<li>
<p>コンテナのvNICとHNSエンドポイントが削除されています</p>
<p>この問題は、<code>hostname-override</code>パラメータが<a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>に渡されない場合に発生する可能性があります。これを解決するには、ユーザーは次のようにホスト名をkube-proxyに渡す必要があります。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>C:\k\<span style=color:#a2f>kube-proxy</span>.exe --hostname-override=$(hostname)
</code></pre></div></li>
<li>
<p>flannelを使用すると、クラスターに再参加した後、ノードに問題が発生します</p>
<p>以前に削除されたノードがクラスターに再参加するときはいつも、flannelDは新しいPodサブネットをノードに割り当てようとします。ユーザーは、次のパスにある古いPodサブネット構成ファイルを削除する必要があります。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>Remove-Item</span> C:\k\SourceVip.json
<span style=color:#a2f>Remove-Item</span> C:\k\SourceVipRequest.json
</code></pre></div></li>
<li>
<p><code>start.ps1</code>を起動した後、flanneldが「ネットワークが作成されるのを待っています」と表示されたままになります</p>
<p>この<a href=https://github.com/coreos/flannel/issues/1066>調査中の問題</a>に関する多数の報告があります。最も可能性が高いのは、flannelネットワークの管理IPが設定されるタイミングの問題です。回避策は、単純にstart.ps1を再起動するか、次のように手動で再起動することです。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>PS </span>C:&gt; <span style=color:#800>[Environment]</span>::SetEnvironmentVariable(<span style=color:#b44>&#34;NODE_NAME&#34;</span>, <span style=color:#b44>&#34;&lt;Windows_Worker_Hostname&gt;&#34;</span>)
<span style=color:#a2f>PS </span>C:&gt; C:\flannel\flanneld.exe --kubeconfig<span style=color:#666>-file</span>=c:\k\config --iface=&lt;Windows_Worker_Node_IP&gt; --ip-masq=1 --kube-subnet-mgr=1
</code></pre></div></li>
<li>
<p><code>/run/flannel/subnet.env</code>がないため、Windows Podを起動できません</p>
<p>これは、Flannelが正しく起動しなかったことを示しています。 flanneld.exeの再起動を試みるか、Kubernetesマスターの<code>/run/flannel/subnet.env</code>からWindowsワーカーノードの<code>C:\run\flannel\subnet.env</code>に手動でファイルをコピーすることができます。「FLANNEL_SUBNET」行を別の番号に変更します。たとえば、ノードサブネット10.244.4.1/24が必要な場合は以下となります。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-env data-lang=env><span style=color:#b8860b>FLANNEL_NETWORK</span><span style=color:#666>=</span>10.244.0.0/16
<span style=color:#b8860b>FLANNEL_SUBNET</span><span style=color:#666>=</span>10.244.4.1/24
<span style=color:#b8860b>FLANNEL_MTU</span><span style=color:#666>=</span><span style=color:#666>1500</span>
<span style=color:#b8860b>FLANNEL_IPMASQ</span><span style=color:#666>=</span><span style=color:#a2f>true</span>
</code></pre></div></li>
<li>
<p>WindowsノードがService IPを使用してServiceにアクセスできない</p>
<p>これは、Windows上の現在のネットワークスタックの既知の制限です。ただし、Windows PodはService IPにアクセスできます。</p>
</li>
<li>
<p>kubeletの起動時にネットワークアダプターが見つかりません</p>
<p>WindowsネットワーキングスタックがKubernetesネットワーキングを動かすには、仮想アダプターが必要です。次のコマンドを実行しても結果が返されない場合（管理シェルで）、仮想ネットワークの作成（Kubeletが機能するために必要な前提条件）に失敗したことになります。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>Get-HnsNetwork</span> | ? Name <span style=color:#666>-ieq</span> <span style=color:#b44>&#34;cbr0&#34;</span>
<span style=color:#a2f>Get-NetAdapter</span> | ? Name <span style=color:#666>-Like</span> <span style=color:#b44>&#34;vEthernet (Ethernet*&#34;</span>
</code></pre></div><p>ホストのネットワークアダプターが「イーサネット」ではない場合、多くの場合、start.ps1スクリプトの<a href=https://github.com/microsoft/SDN/blob/master/Kubernetes/flannel/start.ps1#L6>InterfaceName</a>パラメーターを修正する価値があります。そうでない場合は<code>start-kubelet.ps1</code>スクリプトの出力結果を調べて、仮想ネットワークの作成中にエラーがないか確認します。</p>
</li>
<li>
<p>Podが「Container Creating」と表示されたまま動かなくなったり、何度も再起動を繰り返します</p>
<p>PauseイメージがOSバージョンと互換性があることを確認してください。<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/kubernetes/deploying-resources>説明</a>では、OSとコンテナの両方がバージョン1803であると想定しています。それ以降のバージョンのWindowsを使用している場合は、Insiderビルドなどでは、それに応じてイメージを調整する必要があります。イメージについては、Microsoftの<a href=https://hub.docker.com/u/microsoft/>Dockerレジストリ</a>を参照してください。いずれにしても、PauseイメージのDockerfileとサンプルサービスの両方で、イメージに:latestのタグが付けられていると想定しています。</p>
<p>Kubernetes v1.14以降、MicrosoftはPauseインフラストラクチャコンテナを<code>mcr.microsoft.com/k8s/core/pause:1.2.0</code>でリリースしています。</p>
</li>
<li>
<p>DNS名前解決が正しく機能していない</p>
<p>この<a href=#dns-limitations>セクション</a>でDNSの制限を確認してください。</p>
</li>
<li>
<p><code>kubectl port-forward</code>が「ポート転送を実行できません:wincatが見つかりません」で失敗します</p>
<p>これはKubernetes 1.15、およびPauseインフラストラクチャコンテナ<code>mcr.microsoft.com/k8s/core/pause:1.2.0</code>で実装されました。必ずこれらのバージョン以降を使用してください。
独自のPauseインフラストラクチャコンテナを構築する場合は、必ず<a href=https://github.com/kubernetes-sigs/sig-windows-tools/tree/master/cmd/wincat>wincat</a>を含めてください。</p>
</li>
<li>
<p>Windows Serverノードがプロキシの背後にあるため、Kubernetesのインストールが失敗します</p>
<p>プロキシの背後にある場合は、次のPowerShell環境変数を定義する必要があります。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=color:#800>[Environment]</span>::SetEnvironmentVariable(<span style=color:#b44>&#34;HTTP_PROXY&#34;</span>, <span style=color:#b44>&#34;http://proxy.example.com:80/&#34;</span>, <span style=color:#800>[EnvironmentVariableTarget]</span>::Machine)
<span style=color:#800>[Environment]</span>::SetEnvironmentVariable(<span style=color:#b44>&#34;HTTPS_PROXY&#34;</span>, <span style=color:#b44>&#34;http://proxy.example.com:443/&#34;</span>, <span style=color:#800>[EnvironmentVariableTarget]</span>::Machine)
</code></pre></div></li>
<li>
<p><code>pause</code>コンテナとは何ですか</p>
<p>Kubernetes Podでは、インフラストラクチャまたは「pause」コンテナが最初に作成され、コンテナエンドポイントをホストします。インフラストラクチャやワーカーコンテナなど、同じPodに属するコンテナは、共通のネットワークネームスペースとエンドポイント（同じIPとポートスペース）を共有します。Pauseコンテナは、ネットワーク構成を失うことなくクラッシュまたは再起動するワーカーコンテナに対応するために必要です。</p>
<p>「pause」（インフラストラクチャ）イメージは、Microsoft Container Registry（MCR）でホストされています。<code>docker pull mcr.microsoft.com/k8s/core/pause:1.2.0</code>を使用してアクセスできます。詳細については、<a href=https://github.com/kubernetes-sigs/windows-testing/blob/master/images/pause/Dockerfile>DOCKERFILE</a>をご覧ください。</p>
</li>
</ol>
<h3 id=さらなる調査>さらなる調査</h3>
<p>これらの手順で問題が解決しない場合は、次の方法で、KubernetesのWindowsノードでWindowsコンテナを実行する際のヘルプを利用できます。:</p>
<ul>
<li>StackOverflow <a href=https://stackoverflow.com/questions/tagged/windows-server-container>Windows Server Container</a>トピック</li>
<li>Kubernetesオフィシャルフォーラム <a href=https://discuss.kubernetes.io/>discuss.kubernetes.io</a></li>
<li>Kubernetes Slack <a href=https://kubernetes.slack.com/messages/sig-windows>#SIG-Windows Channel</a></li>
</ul>
<h2 id=issueとfeatureリクエストの報告>IssueとFeatureリクエストの報告</h2>
<p>バグのようなものがある場合、またはFeatureリクエストを行う場合は、<a href=https://github.com/kubernetes/kubernetes/issues>GitHubのIssueシステム</a>を使用してください。<a href=https://github.com/kubernetes/kubernetes/issues/new/choose>GitHub</a>でIssueを開いて、SIG-Windowsに割り当てることができます。以前に報告された場合は、まずIssueリストを検索し、Issueについての経験をコメントして、追加のログを加える必要があります。SIG-Windows Slackは、チケットを作成する前に、初期サポートとトラブルシューティングのアイデアを得るための素晴らしい手段でもあります。</p>
<p>バグを報告する場合は、問題の再現方法に関する次のような詳細情報を含めてください。:</p>
<ul>
<li>Kubernetesのバージョン: kubectlのバージョン</li>
<li>環境の詳細: クラウドプロバイダー、OSのディストリビューション、選択したネットワーキングと構成、およびDockerのバージョン</li>
<li>問題を再現するための詳細な手順</li>
<li><a href=https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#gathering-logs>関連するログ</a></li>
<li><code>/sig windows</code>でIssueにコメントして、Issueにsig/windowsのタグを付けて、SIG-Windowsメンバーが気付くようにします</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<p>ロードマップには多くの機能があります。高レベルの簡略リストを以下に示しますが、<a href=https://github.com/orgs/kubernetes/projects/8>ロードマッププロジェクト</a>を見て、<a href=https://github.com/kubernetes/community/blob/master/sig-windows/>貢献すること</a>によってWindowsサポートを改善することをお勧めします。</p>
<h3 id=hyper-v分離>Hyper-V分離</h3>
<p>Hyper-V分離はKubernetesで以下のWindowsコンテナのユースケースを実現するために必要です。</p>
<ul>
<li>Pod間のハイパーバイザーベースの分離により、セキュリティを強化</li>
<li>下位互換性により、コンテナの再構築を必要とせずにノードで新しいWindows Serverバージョンを実行</li>
<li>Podの特定のCPU/NUMA設定</li>
<li>メモリの分離と予約</li>
</ul>
<p>既存のHyper-V分離サポートは、v1.10の試験的な機能であり、上記のCRI-ContainerD機能とRuntimeClass機能を優先して将来廃止される予定です。現在の機能を使用してHyper-V分離コンテナを作成するには、kubeletのフィーチャーゲートを<code>HyperVContainer=true</code>で開始し、Podにアノテーション<code>experimental.windows.kubernetes.io/isolation-type=hyperv</code>を含める必要があります。実験的リリースでは、この機能はPodごとに1つのコンテナに制限されています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>experimental.windows.kubernetes.io/isolation-type</span>:<span style=color:#bbb> </span>hyperv<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>microsoft/iis<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div><h3 id=kubeadmとクラスターapiを使用したデプロイ>kubeadmとクラスターAPIを使用したデプロイ</h3>
<p>Kubeadmは、ユーザーがKubernetesクラスターをデプロイするための事実上の標準になりつつあります。kubeadmのWindowsノードのサポートは進行中ですが、ガイドはすでに<a href=/ja/docs/tasks/administer-cluster/kubeadm/adding-windows-nodes/>ここ</a>で利用可能です。Windowsノードが適切にプロビジョニングされるように、クラスターAPIにも投資しています。</p>
<h3 id=その他の主な機能>その他の主な機能</h3>
<ul>
<li>グループ管理サービスアカウントのベータサポート</li>
<li>その他のCNI</li>
<li>その他のストレージプラグイン</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3a51e66c5de55f9093a8dc55742006d3>2.3.5.2 - KubernetesでWindowsコンテナをスケジュールするためのガイド</h1>
<p>Windowsアプリケーションは、多くの組織で実行されるサービスとアプリケーションの大部分を占めます。このガイドでは、KubernetesでWindowsコンテナを構成してデプロイする手順について説明します。</p>
<h2 id=目的>目的</h2>
<ul>
<li>WindowsノードでWindowsコンテナを実行するサンプルのDeploymentを構成します</li>
<li>(オプション)Group Managed Service Accounts(GMSA)を使用してPodのActive Directory IDを構成します</li>
</ul>
<h2 id=始める前に>始める前に</h2>
<ul>
<li><a href=/ja/docs/tasks/administer-cluster/kubeadm/adding-windows-nodes>Windows Serverを実行するマスターノードとワーカーノード</a>を含むKubernetesクラスターを作成します</li>
<li>Kubernetes上にServiceとワークロードを作成してデプロイすることは、LinuxコンテナとWindowsコンテナ共に、ほぼ同じように動作することに注意してください。クラスターとのインタフェースとなる<a href=/docs/reference/kubectl/overview/>Kubectlコマンド</a>も同じです。Windowsコンテナをすぐに体験できる例を以下セクションに用意しています。</li>
</ul>
<h2 id=はじめに-windowsコンテナのデプロイ>はじめに:Windowsコンテナのデプロイ</h2>
<p>WindowsコンテナをKubernetesにデプロイするには、最初にサンプルアプリケーションを作成する必要があります。以下のYAMLファイルの例では、簡単なウェブサーバーアプリケーションを作成しています。以下の内容で<code>win-webserver.yaml</code>という名前のサービススペックを作成します。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># このサービスが提供するポート</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>win-webserver<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>windowswebserver<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore:ltsc2019<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- powershell.exe<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- -command<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:#b44>&#34;&lt;#code used from https://gist.github.com/19WAS85/5424431#&gt; ; $$listener = New-Object System.Net.HttpListener ; $$listener.Prefixes.Add(&#39;http://*:80/&#39;) ; $$listener.Start() ; $$callerCounts = @{} ; Write-Host(&#39;Listening at http://*:80/&#39;) ; while ($$listener.IsListening) { ;$$context = $$listener.GetContext() ;$$requestUrl = $$context.Request.Url ;$$clientIP = $$context.Request.RemoteEndPoint.Address ;$$response = $$context.Response ;Write-Host &#39;&#39; ;Write-Host(&#39;&gt; {0}&#39; -f $$requestUrl) ;  ;$$count = 1 ;$$k=$$callerCounts.Get_Item($$clientIP) ;if ($$k -ne $$null) { $$count = $$k } ;$$callerCounts.Set_Item($$clientIP, $$count) ;$$ip=(Get-NetAdapter | Get-NetIpAddress); $$header=&#39;&lt;html&gt;&lt;body&gt;&lt;H1&gt;Windows Container Web Server&lt;/H1&gt;&#39; ;$$callerCountsString=&#39;&#39; ;$$callerCounts.Keys | % { $$callerCountsString=&#39;&lt;p&gt;IP {0} callerCount {1} &#39; -f $$ip[1].IPAddress,$$callerCounts.Item($$_) } ;$$footer=&#39;&lt;/body&gt;&lt;/html&gt;&#39; ;$$content=&#39;{0}{1}{2}&#39; -f $$header,$$callerCountsString,$$footer ;Write-Output $$content ;$$buffer = [System.Text.Encoding]::UTF8.GetBytes($$content) ;$$response.ContentLength64 = $$buffer.Length ;$$response.OutputStream.Write($$buffer, 0, $$buffer.Length) ;$$response.Close() ;$$responseStatus = $$response.StatusCode ;Write-Host(&#39;&lt; {0}&#39; -f $$responseStatus)  } ; &#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ポートマッピングもサポートされていますが、この例では簡単にするために、コンテナポート80がサービスに直接公開されています。
</div>
<ol>
<li>
<p>すべてのノードが正常であることを確認します。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get nodes
</code></pre></div></li>
<li>
<p>Serviceをデプロイして、Podの更新を確認します。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f win-webserver.yaml
kubectl get pods -o wide -w
</code></pre></div><p>Serviceが正しくデプロイされると、両方のPodがReadyとして表示されます。watch状態のコマンドを終了するには、Ctrl + Cを押します。</p>
</li>
<li>
<p>デプロイが成功したことを確認します。検証するために行うこと:</p>
<ul>
<li>WindowsノードのPodごとの2つのコンテナに<code>docker ps</code>します</li>
<li>Linuxマスターからリストされた2つのPodに<code>kubectl get pods</code>します</li>
<li>ネットワークを介したノードとPod間通信、LinuxマスターからのPod IPのポート80に向けて<code>curl</code>して、ウェブサーバーの応答をチェックします</li>
<li>docker execまたはkubectl execを使用したPod間通信、Pod間(および複数のWindowsノードがある場合はホスト間)へのpingします</li>
<li>ServiceからPodへの通信、Linuxマスターおよび個々のPodからの仮想Service IP(<code>kubectl get services</code>で表示される)に<code>curl</code>します</li>
<li>サービスディスカバリ、Kubernetesの<a href=/ja/docs/concepts/services-networking/dns-pod-service/#services>default DNS suffix</a>と共にService名に<code>curl</code>します</li>
<li>Inbound connectivity, <code>curl</code> the NodePort from the Linux master or machines outside of the cluster</li>
<li>インバウンド接続、Linuxマスターまたはクラスター外のマシンからNodePortに<code>curl</code>します</li>
<li>アウトバウンド接続、kubectl execを使用したPod内からの外部IPに<code>curl</code>します</li>
</ul>
</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 今のところ、Windowsネットワークスタックのプラットフォーム制限のため、Windowsコンテナホストは、ホストされているサービスのIPにアクセスできません。Service IPにアクセスできるのは、Windows Podだけです。
</div>
<h2 id=可観測性>可観測性</h2>
<h3 id=ワークロードからのログキャプチャ>ワークロードからのログキャプチャ</h3>
<p>ログは可観測性の重要な要素です。これにより、ユーザーはワークロードの運用面に関する洞察を得ることができ、問題のトラブルシューティングの主要な要素になります。WindowsコンテナとWindowsコンテナ内のワークロードの動作はLinuxコンテナとは異なるため、ユーザーはログの収集に苦労し、運用の可視性が制限されていました。たとえば、Windowsワークロードは通常、ETW(Windowsのイベントトレース)にログを記録するか、アプリケーションイベントログにエントリをプッシュするように構成されます。Microsoftのオープンソースツールである<a href=https://github.com/microsoft/windows-container-tools/tree/master/LogMonitor>LogMonitor</a>は、Windowsコンテナ内の構成されたログソースを監視するための推奨方法です。LogMonitorは、イベントログ、ETWプロバイダー、カスタムアプリケーションログのモニタリングをサポートしており、それらをSTDOUTにパイプして、<code>kubectl logs &lt;pod></code>で使用できます。</p>
<p>LogMonitor GitHubページの指示に従って、バイナリと構成ファイルをすべてのコンテナにコピーして、LogMonitorがログをSTDOUTにプッシュするために必要なエントリーポイントを追加します。</p>
<h2 id=構成可能なコンテナのユーザー名の使用>構成可能なコンテナのユーザー名の使用</h2>
<p>Kubernetes v1.16以降、Windowsコンテナは、イメージのデフォルトとは異なるユーザー名でエントリーポイントとプロセスを実行するように構成できます。これが達成される方法は、Linuxコンテナで行われる方法とは少し異なります。詳しくは<a href=/docs/tasks/configure-pod-container/configure-runasusername/>こちら</a>.</p>
<h2 id=group-managed-service-accountsによるワークロードidの管理>Group Managed Service AccountsによるワークロードIDの管理</h2>
<p>Kubernetes v1.14以降、Windowsコンテナワークロードは、Group Managed Service Accounts(GMSA)を使用するように構成できます。Group Managed Service Accountsは、自動パスワード管理、簡略化されたサービスプリンシパル名（SPN）管理、および複数のサーバー間で他の管理者に管理を委任する機能を提供する特定の種類のActive Directoryアカウントです。GMSAで構成されたコンテナは、GMSAで構成されたIDを保持しながら、外部Active Directoryドメインリソースにアクセスできます。Windowsコンテナ用のGMSAの構成と使用の詳細は<a href=/docs/tasks/configure-pod-container/configure-gmsa/>こちら</a>。</p>
<h2 id=taintsとtolerations>TaintsとTolerations</h2>
<p>今日のユーザーは、LinuxとWindowsのワークロードをそれぞれのOS固有のノードで維持するために、Taintsとノードセレクターのいくつかの組み合わせを使用する必要があります。これはおそらくWindowsユーザーにのみ負担をかけます。推奨されるアプローチの概要を以下に示します。主な目標の1つは、このアプローチによって既存のLinuxワークロードの互換性が損なわれないようにすることです。</p>
<h3 id=os固有のワークロードが適切なコンテナホストに確実に到達するようにする>OS固有のワークロードが適切なコンテナホストに確実に到達するようにする</h3>
<p>ユーザーは、TaintsとTolerationsを使用して、Windowsコンテナを適切なホストでスケジュールできるようにすることができます。現在、すべてのKubernetesノードには次のデフォルトラベルがあります。:</p>
<ul>
<li>kubernetes.io/os = [windows|linux]</li>
<li>kubernetes.io/arch = [amd64|arm64|...]</li>
</ul>
<p>Podの仕様で<code>"kubernetes.io/os": windows</code>のようなnodeSelectorが指定されていない場合、PodをWindowsまたはLinuxの任意のホストでスケジュールすることができます。WindowsコンテナはWindowsでのみ実行でき、LinuxコンテナはLinuxでのみ実行できるため、これは問題になる可能性があります。ベストプラクティスは、nodeSelectorを使用することです。</p>
<p>ただし、多くの場合、ユーザーには既存の多数のLinuxコンテナのdeployment、およびコミュニティHelmチャートのような既成構成のエコシステムやOperatorのようなプログラム的にPodを生成するケースがあることを理解しています。このような状況では、nodeSelectorsを追加するための構成変更をためらう可能性があります。代替策は、Taintsを使用することです。kubeletは登録中にTaintsを設定できるため、Windowsだけで実行する時に自動的にTaintを追加するように簡単に変更できます。</p>
<p>例:<code>--register-with-taints='os=windows:NoSchedule'</code></p>
<p>すべてのWindowsノードにTaintを追加することにより、それらには何もスケジュールされません（既存のLinuxPodを含む）。Windows PodがWindowsノードでスケジュールされるためには、nodeSelectorがWindowsを選択することと、適切にマッチするTolerationが必要です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>node.kubernetes.io/windows-build</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;10.0.17763&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;os&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;windows&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=同じクラスター内の複数windowsバージョンの管理>同じクラスター内の複数Windowsバージョンの管理</h3>
<p>各Podで使用されるWindows Serverのバージョンは、ノードのバージョンと一致している必要があります。
同じクラスター内で複数のWindows Serverバージョンを使用したい場合は、追加のノードラベルとnodeSelectorsを設定する必要があります。</p>
<p>Kubernetes 1.17では、これを簡単するために新しいラベル<code>node.kubernetes.io/windows-build</code>が自動的に追加されます。古いバージョンを実行している場合は、このラベルをWindowsノードに手動で追加することをお勧めします。</p>
<p>このラベルは、互換性のために一致する必要があるWindowsのメジャー、マイナー、およびビルド番号を反映しています。以下は、Windows Serverの各バージョンで現在使用されている値です。</p>
<table>
<thead>
<tr>
<th>製品番号 　　</th>
<th>ビルド番号</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows Server 2019</td>
<td>10.0.17763</td>
</tr>
<tr>
<td>Windows Server version 1809</td>
<td>10.0.17763</td>
</tr>
<tr>
<td>Windows Server version 1903</td>
<td>10.0.18362</td>
</tr>
</tbody>
</table>
<h3 id=runtimeclassによる簡素化>RuntimeClassによる簡素化</h3>
<p><a href=https://kubernetes.io/docs/concepts/containers/runtime-class/>RuntimeClass</a>は、TaintsとTolerationsを使用するプロセスを簡略化するために使用できます。クラスター管理者は、これらのTaintsとTolerationsをカプセル化するために使用する<code>RuntimeClass</code>オブジェクトを作成できます。</p>
<ol>
<li>このファイルを<code>runtimeClasses.yml</code>に保存します。これには、Windows OS、アーキテクチャ、およびバージョンに適切な<code>nodeSelector</code>が含まれています。</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>windows-2019<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>scheduling</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;windows&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/arch</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;amd64&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>node.kubernetes.io/windows-build</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;10.0.17763&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>os<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Equal<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;windows&#34;</span><span style=color:#bbb>
</span></code></pre></div><ol>
<li>クラスター管理者として使用する<code>kubectl create -f runtimeClasses.yml</code>を実行します</li>
<li>Podの仕様に応じて<code>runtimeClassName: windows-2019</code>を追加します</li>
</ol>
<p>例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>windows-2019<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>800Mi<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>.1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>300Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>iis-2019<span style=color:#bbb>
</span></code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-84b6491601d6a2b3da4cd5a105c866ba>2.4 - ベストプラクティス</h1>
</div>
<div class=td-content>
<h1 id=pg-970615c97499e3651fd3a98e0387cefc>2.4.1 - 複数のゾーンで動かす</h1>
<p>This page describes how to run a cluster in multiple zones.</p>
<h2 id=始めに>始めに</h2>
<p>Kubernetes 1.2より、複数のゾーンにおいて単一のクラスターを運用するサポートが追加されました(GCEでは単純に"ゾーン"，AWSは"アベイラビリティゾーン"と呼びますが、ここでは"ゾーン"とします)。
これは、より範囲の広いCluster Federationの軽量バージョンです(以前は<a href=https://github.com/kubernetes/community/blob/v1.22.16/contributors/design-proposals/multicluster/federation.md>"Ubernetes"</a>の愛称で言及されていました)。
完全なCluster Federationでは、異なるリージョンやクラウドプロバイダー(あるいはオンプレミスデータセンター)内の独立したKubernetesクラスターをまとめることが可能になります。しかしながら、多くのユーザーは単に1つのクラウドプロバイダーの複数のゾーンでより可用性の高いKubernetesクラスターを運用したいと考えており、バージョン1.2におけるマルチゾーンサポート(以前は"Ubernetes Lite"の愛称で使用されていました)ではこれが可能になります。</p>
<p>マルチゾーンサポートは故意に限定されています: 1つのKubernetesクラスターは複数のゾーンで運用することができますが、同じリージョン(あるいはクラウドプロバイダー)のみです。現在はGCEとAWSのみが自動的にサポートされています(他のクラウドプロバイダーやベアメタル環境においても、単にノードやボリュームに追加する適切なラベルを用意して同様のサポートを追加することは容易ではありますが)。</p>
<h2 id=機能性>機能性</h2>
<p>ノードが開始された時、kubeletは自動的にそれらにゾーン情報を付したラベルを追加します。</p>
<p>Kubernetesはレプリケーションコントローラーやサービス内のPodをシングルゾーンクラスターにおけるノードにデプロイします(障害の影響を減らすため)。マルチゾーンクラスターでは、このデプロイの挙動はゾーンを跨いで拡張されます(障害の影響を減らすため)(これは<code>SelectorSpreadPriority</code>によって可能になります)。これはベストエフォートな配置であり、つまりもしクラスターのゾーンが異種である(例:異なる数のノード，異なるタイプのノードや異なるPodのリソース要件)場合、これはゾーンを跨いだPodのデプロイを完璧に防ぐことができます。必要であれば、同種のゾーン(同一の数及びタイプのノード)を利用して不平等なデプロイの可能性を減らすことができます。</p>
<p>永続ボリュームが作成されると、<code>PersistentVolumeLabel</code>アドミッションコントローラーがそれらにゾーンラベルを付与します。スケジューラーは<code>VolumeZonePredicate</code>を通じて与えられたボリュームを請求するPodがそのボリュームと同じゾーンにのみ配置されることを保証します、これはボリュームはゾーンを跨いでアタッチすることができないためです。</p>
<h2 id=制限>制限</h2>
<p>マルチゾーンサポートにはいくつか重要な制限があります:</p>
<ul>
<li>
<p>異なるゾーンはネットワーク内においてお互いに近接して位置していることが想定されているため、いかなるzone-aware routingも行われません。特に、トラフィックはゾーンを跨いだサービスを通じて行き来するため(サービスをサポートするいくつかのPodがクライアントと同じゾーンに存在していても)、これは追加のレイテンシやコストを生むかもしれません。</p>
</li>
<li>
<p>Volume zone-affinityは<code>PersistentVolume</code>と共に動作し、例えばPodのスペックにおいてEBSボリュームを直接指定しても動作しません。</p>
</li>
<li>
<p>クラスターはクラウドやリージョンを跨げません(この機能はフルフェデレーションサポートが必要です)。</p>
</li>
</ul>
<p>*ノードは複数のゾーンに存在しますが、kube-upは現在デフォルトではシングルマスターノードでビルドします。サービスは高可用性でありゾーンの障害に耐えることができますが、コントロールプレーンは単一のゾーンに配置されます。高可用性コントロールプレーンを必要とするユーザーは<a href=/ja/docs/setup/production-environment/tools/kubeadm/high-availability/>高可用性</a>の説明を参照してください。</p>
<h3 id=ボリュームの制限>ボリュームの制限</h3>
<p>以下の制限は<a href=/docs/concepts/storage/storage-classes/#volume-binding-mode>topology-aware volume binding</a>に記載されています。</p>
<ul>
<li>
<p>動的なプロビジョニングを使用する際のStatefulSetボリュームゾーンのデプロイは、現在Podのアフィニティあるいはアンチアフィニティと互換性がありません。</p>
</li>
<li>
<p>StatefulSetの名前がダッシュ("-")を含む場合、ボリュームゾーンのデプロイはゾーンを跨いだストレージの均一な分配を提供しない可能性があります。</p>
</li>
<li>
<p>DeploymentやPodのスペックにおいて複数のPVCを指定すると、StorageClassは特定の1つのゾーンに割り当てる必要があります、あるいはPVは特定のゾーンに静的にプロビジョンされる必要があります。もう一つの解決方法として、StatefulSetを使用すると、レプリカに対する全てのボリュームが同じゾーンにプロビジョンされます。</p>
</li>
</ul>
<h2 id=全体の流れ>全体の流れ</h2>
<p>GCEとAWSの両方にマルチゾーンのクラスターをセットアップし使用する手順について説明します。そのために、フルクラスターを用意し(<code>MULTIZONE=true</code>と指定する)、<code>kube-up</code>を再び実行して追加のゾーンにノードを追加します(<code>KUBE_USE_EXISTING_MASTER=true</code>と指定する)。</p>
<h3 id=クラスターの立ち上げ>クラスターの立ち上げ</h3>
<p>通常と同様にクラスターを作成します、しかし複数のゾーンを管理するためにMULTIZONEをクラスターに設定します。ノードをus-central1-aに作成します。</p>
<p>GCE:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -sS https://get.k8s.io | <span style=color:#b8860b>MULTIZONE</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>gce <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>us-central1-a <span style=color:#b8860b>NUM_NODES</span><span style=color:#666>=</span><span style=color:#666>3</span> bash
</code></pre></div><p>AWS:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -sS https://get.k8s.io | <span style=color:#b8860b>MULTIZONE</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>aws <span style=color:#b8860b>KUBE_AWS_ZONE</span><span style=color:#666>=</span>us-west-2a <span style=color:#b8860b>NUM_NODES</span><span style=color:#666>=</span><span style=color:#666>3</span> bash
</code></pre></div><p>このステップは通常と同様にクラスターを立ち上げ、1つのゾーンで動作しています(しかし、<code>MULTIZONE=true</code>によりマルチゾーン能力は有効になっています)。</p>
<h3 id=ノードはラベルが付与される>ノードはラベルが付与される</h3>
<p>ノードを見てください。それらがゾーン情報と共にラベルされているのが分かります。
それら全ては今のところ<code>us-central1-a</code> (GCE)あるいは<code>us-west-2a</code> (AWS)にあります。ラベルは<code>topology.kubernetes.io/region</code>がリージョンに、<code>topology.kubernetes.io/zone</code>はゾーンに付けられています:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div><p>結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                     STATUS                     ROLES    AGE   VERSION          LABELS
kubernetes-master        Ready,SchedulingDisabled   &lt;none&gt;   6m    v1.13.0          beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-1,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-master
kubernetes-minion-87j9   Ready                      &lt;none&gt;   6m    v1.13.0          beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-87j9
kubernetes-minion-9vlv   Ready                      &lt;none&gt;   6m    v1.13.0          beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-9vlv
kubernetes-minion-a12q   Ready                      &lt;none&gt;   6m    v1.13.0          beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-a12q
</code></pre></div><h3 id=2つ目のゾーンにさらにノードを追加>2つ目のゾーンにさらにノードを追加</h3>
<p>それでは、現存のマスターを再利用し、現存のクラスターの異なるゾーン(us-central1-bかus-west-2b)にもう1つのノードのセットを追加しましょう。
kube-upを再び実行します．しかし<code>KUBE_USE_EXISTING_MASTER=true</code>を指定することでkube-upは新しいマスターを作成せず、代わりに以前作成したものを再利用します。</p>
<p>GCE:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>MULTIZONE</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>gce <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>us-central1-b <span style=color:#b8860b>NUM_NODES</span><span style=color:#666>=</span><span style=color:#666>3</span> kubernetes/cluster/kube-up.sh
</code></pre></div><p>AWSではマスターの内部IPアドレスに加えて追加のサブネット用のネットワークCIDRを指定する必要があります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>MULTIZONE</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>aws <span style=color:#b8860b>KUBE_AWS_ZONE</span><span style=color:#666>=</span>us-west-2b <span style=color:#b8860b>NUM_NODES</span><span style=color:#666>=</span><span style=color:#666>3</span> <span style=color:#b8860b>KUBE_SUBNET_CIDR</span><span style=color:#666>=</span>172.20.1.0/24 <span style=color:#b8860b>MASTER_INTERNAL_IP</span><span style=color:#666>=</span>172.20.0.9 kubernetes/cluster/kube-up.sh
</code></pre></div><p>ノードをもう1度見てください。更なる3つのノードがus-central1-bに起動し、タグ付けられているはずです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div><p>結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                     STATUS                     ROLES    AGE   VERSION           LABELS
kubernetes-master        Ready,SchedulingDisabled   &lt;none&gt;   16m   v1.13.0           beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-1,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-master
kubernetes-minion-281d   Ready                      &lt;none&gt;   2m    v1.13.0           beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-b,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-281d
kubernetes-minion-87j9   Ready                      &lt;none&gt;   16m   v1.13.0           beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-87j9
kubernetes-minion-9vlv   Ready                      &lt;none&gt;   16m   v1.13.0           beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-9vlv
kubernetes-minion-a12q   Ready                      &lt;none&gt;   17m   v1.13.0           beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-a12q
kubernetes-minion-pp2f   Ready                      &lt;none&gt;   2m    v1.13.0           beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-b,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-pp2f
kubernetes-minion-wf8i   Ready                      &lt;none&gt;   2m    v1.13.0           beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-b,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-wf8i
</code></pre></div><h3 id=ボリュームのアフィニティ>ボリュームのアフィニティ</h3>
<p>動的ボリュームを使用してボリュームを作成します(PersistentVolumeのみがゾーンアフィニティに対してサポートされています):</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>{
</span><span style=color:#b44>  &#34;apiVersion&#34;: &#34;v1&#34;,
</span><span style=color:#b44>  &#34;kind&#34;: &#34;PersistentVolumeClaim&#34;,
</span><span style=color:#b44>  &#34;metadata&#34;: {
</span><span style=color:#b44>    &#34;name&#34;: &#34;claim1&#34;,
</span><span style=color:#b44>    &#34;annotations&#34;: {
</span><span style=color:#b44>        &#34;volume.alpha.kubernetes.io/storage-class&#34;: &#34;foo&#34;
</span><span style=color:#b44>    }
</span><span style=color:#b44>  },
</span><span style=color:#b44>  &#34;spec&#34;: {
</span><span style=color:#b44>    &#34;accessModes&#34;: [
</span><span style=color:#b44>      &#34;ReadWriteOnce&#34;
</span><span style=color:#b44>    ],
</span><span style=color:#b44>    &#34;resources&#34;: {
</span><span style=color:#b44>      &#34;requests&#34;: {
</span><span style=color:#b44>        &#34;storage&#34;: &#34;5Gi&#34;
</span><span style=color:#b44>      }
</span><span style=color:#b44>    }
</span><span style=color:#b44>  }
</span><span style=color:#b44>}
</span><span style=color:#b44>EOF</span>
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> バージョン1.3以降のKubernetesは設定したゾーンを跨いでPVクレームを分配します。
バージョン1.2では動的永続ボリュームは常にクラスターのマスターがあるゾーンに作成されます。
(ここではus-central1-a / us-west-2a); このイシューは
(<a href=https://github.com/kubernetes/kubernetes/issues/23330>#23330</a>)
にバージョン1.3以降で記載されています。
</div>
<p>それでは、KubernetesがPVが作成されたゾーン及びリージョンを自動的にラベルしているか確認しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pv --show-labels
</code></pre></div><p>結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME           CAPACITY   ACCESSMODES   RECLAIM POLICY   STATUS    CLAIM            STORAGECLASS    REASON    AGE       LABELS
pv-gce-mj4gm   5Gi        RWO           Retain           Bound     default/claim1   manual                    46s       topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a
</code></pre></div><p>では永続ボリュームクレームを使用するPodを作成します。
GCE PD / AWS EBSボリュームはゾーンを跨いでアタッチできないため、これはこのPodがボリュームと同じゾーンにのみ作成されることを意味します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>kubectl apply -f - &lt;&lt;EOF<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfrontend<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/www/html&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>claim1<span style=color:#bbb>
</span><span style=color:#bbb></span>EOF<span style=color:#bbb>
</span></code></pre></div><p>一般的にゾーンを跨いだアタッチはクラウドプロバイダーによって許可されていないため、Podは自動的にボリュームと同じゾーンに作成されることに注意してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod mypod | grep Node
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Node:        kubernetes-minion-9vlv/10.240.0.5
</code></pre></div><p>ノードのラベルをチェックします:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get node kubernetes-minion-9vlv --show-labels
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                     STATUS    AGE    VERSION          LABELS
kubernetes-minion-9vlv   Ready     22m    v1.6.0+fff5156   beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-9vlv
</code></pre></div><h3 id=podがゾーンをまたがって配置される>Podがゾーンをまたがって配置される</h3>
<p>レプリケーションコントローラーやサービス内のPodは自動的にゾーンに跨いでデプロイされます。まず、3つ目のゾーンに更なるノードを立ち上げましょう:</p>
<p>GCE:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>MULTIZONE</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>gce <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>us-central1-f <span style=color:#b8860b>NUM_NODES</span><span style=color:#666>=</span><span style=color:#666>3</span> kubernetes/cluster/kube-up.sh
</code></pre></div><p>AWS:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>MULTIZONE</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>aws <span style=color:#b8860b>KUBE_AWS_ZONE</span><span style=color:#666>=</span>us-west-2c <span style=color:#b8860b>NUM_NODES</span><span style=color:#666>=</span><span style=color:#666>3</span> <span style=color:#b8860b>KUBE_SUBNET_CIDR</span><span style=color:#666>=</span>172.20.2.0/24 <span style=color:#b8860b>MASTER_INTERNAL_IP</span><span style=color:#666>=</span>172.20.0.9 kubernetes/cluster/kube-up.sh
</code></pre></div><p>3つのゾーンにノードがあることを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div><p>シンプルなWebアプリケーションを動作する、3つのRCを持つguestbook-goの例を作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>find kubernetes/examples/guestbook-go/ -name <span style=color:#b44>&#39;*.json&#39;</span> | xargs -I <span style=color:#666>{}</span> kubectl apply -f <span style=color:#666>{}</span>
</code></pre></div><p>Podは3つの全てのゾーンにデプロイされているはずです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook | grep Node
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Node:        kubernetes-minion-9vlv/10.240.0.5
Node:        kubernetes-minion-281d/10.240.0.8
Node:        kubernetes-minion-olsh/10.240.0.11
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get node kubernetes-minion-9vlv kubernetes-minion-281d kubernetes-minion-olsh --show-labels
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                     STATUS    ROLES    AGE    VERSION          LABELS
kubernetes-minion-9vlv   Ready     &lt;none&gt;   34m    v1.13.0          beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-9vlv
kubernetes-minion-281d   Ready     &lt;none&gt;   20m    v1.13.0          beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-b,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-281d
kubernetes-minion-olsh   Ready     &lt;none&gt;   3m     v1.13.0          beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,topology.kubernetes.io/region<span style=color:#666>=</span>us-central1,topology.kubernetes.io/zone<span style=color:#666>=</span>us-central1-f,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-olsh
</code></pre></div><p>ロードバランサーはクラスター内の全てのゾーンにデプロイされています; guestbook-goの例は負荷分散サービスのサンプルを含みます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe service guestbook | grep LoadBalancer.Ingress
</code></pre></div><p>結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>LoadBalancer Ingress:   130.211.126.21
</code></pre></div><p>IPの上に設定します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span> <span style=color:#b8860b>IP</span><span style=color:#666>=</span>130.211.126.21
</code></pre></div><p>IPをcurlを通じて探索します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -s http://<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>IP</span><span style=color:#b68;font-weight:700>}</span>:3000/env | grep HOSTNAME
</code></pre></div><p>結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>  <span style=color:#b44>&#34;HOSTNAME&#34;</span>: <span style=color:#b44>&#34;guestbook-44sep&#34;</span>,
</code></pre></div><p>再び、複数回探索します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#b44>`</span>seq 20<span style=color:#b44>`</span>; <span style=color:#a2f;font-weight:700>do</span> curl -s http://<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>IP</span><span style=color:#b68;font-weight:700>}</span>:3000/env | grep HOSTNAME; <span style=color:#a2f;font-weight:700>done</span><span style=color:#666>)</span>  | sort | uniq
</code></pre></div><p>結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>  <span style=color:#b44>&#34;HOSTNAME&#34;</span>: <span style=color:#b44>&#34;guestbook-44sep&#34;</span>,
  <span style=color:#b44>&#34;HOSTNAME&#34;</span>: <span style=color:#b44>&#34;guestbook-hum5n&#34;</span>,
  <span style=color:#b44>&#34;HOSTNAME&#34;</span>: <span style=color:#b44>&#34;guestbook-ppm40&#34;</span>,
</code></pre></div><p>ロードバランサーは、たとえPodが複数のゾーンに存在していても、全てのPodをターゲットします。</p>
<h3 id=クラスターの停止>クラスターの停止</h3>
<p>終了したら、クリーンアップします:</p>
<p>GCE:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>gce <span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>us-central1-f kubernetes/cluster/kube-down.sh
<span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>gce <span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>us-central1-b kubernetes/cluster/kube-down.sh
<span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>gce <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>us-central1-a kubernetes/cluster/kube-down.sh
</code></pre></div><p>AWS:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>aws <span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBE_AWS_ZONE</span><span style=color:#666>=</span>us-west-2c kubernetes/cluster/kube-down.sh
<span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>aws <span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBE_AWS_ZONE</span><span style=color:#666>=</span>us-west-2b kubernetes/cluster/kube-down.sh
<span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>aws <span style=color:#b8860b>KUBE_AWS_ZONE</span><span style=color:#666>=</span>us-west-2a kubernetes/cluster/kube-down.sh
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c797ee17120176c685455db89ae091a9>2.4.2 - 大規模クラスタの構築</h1>
<h2 id=サポート>サポート</h2>
<p>At v1.22, Kubernetes supports clusters with up to 5000 nodes. More specifically, we support configurations that meet <em>all</em> of the following criteria:</p>
<ul>
<li>No more than 110 pods per node</li>
<li>No more than 5000 nodes</li>
<li>No more than 150000 total pods</li>
<li>No more than 300000 total containers</li>
</ul>
<h2 id=構築>構築</h2>
<p>A cluster is a set of nodes (physical or virtual machines) running Kubernetes agents, managed by a "master" (the cluster-level control plane).</p>
<p>Normally the number of nodes in a cluster is controlled by the value <code>NUM_NODES</code> in the platform-specific <code>config-default.sh</code> file (for example, see <a href=https://releases.k8s.io/v1.22.16/cluster/gce/config-default.sh>GCE's <code>config-default.sh</code></a>).</p>
<p>Simply changing that value to something very large, however, may cause the setup script to fail for many cloud providers. A GCE deployment, for example, will run in to quota issues and fail to bring the cluster up.</p>
<p>When setting up a large Kubernetes cluster, the following issues must be considered.</p>
<h3 id=クォータの問題>クォータの問題</h3>
<p>To avoid running into cloud provider quota issues, when creating a cluster with many nodes, consider:</p>
<ul>
<li>Increase the quota for things like CPU, IPs, etc.
<ul>
<li>In <a href=https://cloud.google.com/compute/docs/resource-quotas>GCE, for example,</a> you'll want to increase the quota for:
<ul>
<li>CPUs</li>
<li>VM instances</li>
<li>Total persistent disk reserved</li>
<li>In-use IP addresses</li>
<li>Firewall Rules</li>
<li>Forwarding rules</li>
<li>Routes</li>
<li>Target pools</li>
</ul>
</li>
</ul>
</li>
<li>Gating the setup script so that it brings up new node VMs in smaller batches with waits in between, because some cloud providers rate limit the creation of VMs.</li>
</ul>
<h3 id=etcdのストレージ>Etcdのストレージ</h3>
<p>To improve performance of large clusters, we store events in a separate dedicated etcd instance.</p>
<p>When creating a cluster, existing salt scripts:</p>
<ul>
<li>start and configure additional etcd instance</li>
<li>configure api-server to use it for storing events</li>
</ul>
<h3 id=マスターのサイズと構成要素>マスターのサイズと構成要素</h3>
<p>On GCE/Google Kubernetes Engine, and AWS, <code>kube-up</code> automatically configures the proper VM size for your master depending on the number of nodes
in your cluster. On other providers, you will need to configure it manually. For reference, the sizes we use on GCE are</p>
<ul>
<li>1-5 nodes: n1-standard-1</li>
<li>6-10 nodes: n1-standard-2</li>
<li>11-100 nodes: n1-standard-4</li>
<li>101-250 nodes: n1-standard-8</li>
<li>251-500 nodes: n1-standard-16</li>
<li>more than 500 nodes: n1-standard-32</li>
</ul>
<p>And the sizes we use on AWS are</p>
<ul>
<li>1-5 nodes: m3.medium</li>
<li>6-10 nodes: m3.large</li>
<li>11-100 nodes: m3.xlarge</li>
<li>101-250 nodes: m3.2xlarge</li>
<li>251-500 nodes: c4.4xlarge</li>
<li>more than 500 nodes: c4.8xlarge</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>On Google Kubernetes Engine, the size of the master node adjusts automatically based on the size of your cluster. For more information, see <a href=https://cloudplatform.googleblog.com/2017/11/Cutting-Cluster-Management-Fees-on-Google-Kubernetes-Engine.html>this blog post</a>.</p>
<p>On AWS, master node sizes are currently set at cluster startup time and do not change, even if you later scale your cluster up or down by manually removing or adding nodes or using a cluster autoscaler.</p>
</div>
<h3 id=アドオンのリソース>アドオンのリソース</h3>
<p>To prevent memory leaks or other resource issues in <a href=https://releases.k8s.io/v1.22.16/cluster/addons>cluster addons</a> from consuming all the resources available on a node, Kubernetes sets resource limits on addon containers to limit the CPU and Memory resources they can consume (See PR <a href=https://pr.k8s.io/10653/files>#10653</a> and <a href=https://pr.k8s.io/10778/files>#10778</a>).</p>
<p>For example:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-cloud-logging<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/fluentd-gcp:1.16<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></code></pre></div><p>Except for Heapster, these limits are static and are based on data we collected from addons running on 4-node clusters (see <a href=https://issue.k8s.io/10335#issuecomment-117861225>#10335</a>). The addons consume a lot more resources when running on large deployment clusters (see <a href=http://issue.k8s.io/5880#issuecomment-113984085>#5880</a>). So, if a large cluster is deployed without adjusting these values, the addons may continuously get killed because they keep hitting the limits.</p>
<p>To avoid running into cluster addon resource issues, when creating a cluster with many nodes, consider the following:</p>
<ul>
<li>Scale memory and CPU limits for each of the following addons, if used, as you scale up the size of cluster (there is one replica of each handling the entire cluster so memory and CPU usage tends to grow proportionally with size/load on cluster):
<ul>
<li><a href=https://releases.k8s.io/v1.22.16/cluster/addons/cluster-monitoring/influxdb/influxdb-grafana-controller.yaml>InfluxDB and Grafana</a></li>
<li><a href=https://releases.k8s.io/v1.22.16/cluster/addons/dns/kube-dns/kube-dns.yaml.in>kubedns, dnsmasq, and sidecar</a></li>
<li><a href=https://releases.k8s.io/v1.22.16/cluster/addons/fluentd-elasticsearch/kibana-deployment.yaml>Kibana</a></li>
</ul>
</li>
<li>Scale number of replicas for the following addons, if used, along with the size of cluster (there are multiple replicas of each so increasing replicas should help handle increased load, but, since load per replica also increases slightly, also consider increasing CPU/memory limits):
<ul>
<li><a href=https://releases.k8s.io/v1.22.16/cluster/addons/fluentd-elasticsearch/es-statefulset.yaml>elasticsearch</a></li>
</ul>
</li>
<li>Increase memory and CPU limits slightly for each of the following addons, if used, along with the size of cluster (there is one replica per node but CPU/memory usage increases slightly along with cluster load/size as well):
<ul>
<li><a href=https://releases.k8s.io/v1.22.16/cluster/addons/fluentd-elasticsearch/fluentd-es-ds.yaml>FluentD with ElasticSearch Plugin</a></li>
<li><a href=https://releases.k8s.io/v1.22.16/cluster/addons/fluentd-gcp/fluentd-gcp-ds.yaml>FluentD with GCP Plugin</a></li>
</ul>
</li>
</ul>
<p>Heapster's resource limits are set dynamically based on the initial size of your cluster (see <a href=http://issue.k8s.io/16185>#16185</a>
and <a href=http://issue.k8s.io/22940>#22940</a>). If you find that Heapster is running
out of resources, you should adjust the formulas that compute heapster memory request (see those PRs for details).</p>
<p>For directions on how to detect if addon containers are hitting resource limits, see the
<a href=/docs/concepts/configuration/manage-resources-containers/#troubleshooting>Troubleshooting section of Compute Resources</a>.</p>
<h3 id=少数のノードの起動の失敗を許容する>少数のノードの起動の失敗を許容する</h3>
<p>For various reasons (see <a href=https://github.com/kubernetes/kubernetes/issues/18969>#18969</a> for more details) running
<code>kube-up.sh</code> with a very large <code>NUM_NODES</code> may fail due to a very small number of nodes not coming up properly.
Currently you have two choices: restart the cluster (<code>kube-down.sh</code> and then <code>kube-up.sh</code> again), or before
running <code>kube-up.sh</code> set the environment variable <code>ALLOWED_NOTREADY_NODES</code> to whatever value you feel comfortable
with. This will allow <code>kube-up.sh</code> to succeed with fewer than <code>NUM_NODES</code> coming up. Depending on the
reason for the failure, those additional nodes may join later or the cluster may remain at a size of
<code>NUM_NODES - ALLOWED_NOTREADY_NODES</code>.</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f89867de1d34943f1524f67a241f5cc9>2.4.3 - ノードのセットアップの検証</h1>
<h2 id=ノード適合テスト>ノード適合テスト</h2>
<p><em>ノード適合テスト</em> は、システムの検証とノードに対する機能テストを提供するコンテナ型のテストフレームワークです。このテストは、ノードがKubernetesの最小要件を満たしているかどうかを検証するもので、テストに合格したノードはKubernetesクラスタに参加する資格があることになります。</p>
<h2 id=制約>制約</h2>
<p>Kubernetesのバージョン1.5ではノード適合テストには以下の制約があります:</p>
<ul>
<li>ノード適合テストはコンテナのランタイムとしてDockerのみをサポートします。</li>
</ul>
<h2 id=ノードの前提条件>ノードの前提条件</h2>
<p>適合テストを実行するにはノードは通常のKubernetesノードと同じ前提条件を満たしている必要があります。 最低でもノードに以下のデーモンがインストールされている必要があります:</p>
<ul>
<li>コンテナランタイム (Docker)</li>
<li>Kubelet</li>
</ul>
<h2 id=ノード適合テストの実行>ノード適合テストの実行</h2>
<p>ノード適合テストを実行するには、以下の手順に従います:</p>
<ol>
<li>Kubeletをlocalhostに指定します(<code>--api-servers="http://localhost:8080"</code>)、
このテストフレームワークはKubeletのテストにローカルマスターを起動するため、Kubeletをローカルホストに設定します(<code>--api-servers="http://localhost:8080"</code>)。他にも配慮するべきKubeletフラグがいくつかあります:</li>
</ol>
<ul>
<li><code>--pod-cidr</code>: <code>kubenet</code>を利用している場合は、Kubeletに任意のCIDR(例: <code>--pod-cidr=10.180.0.0/24</code>)を指定する必要があります。</li>
<li><code>--cloud-provider</code>: <code>--cloud-provider=gce</code>を指定している場合は、テストを実行する前にこのフラグを取り除いてください。</li>
</ul>
<ol start=2>
<li>以下のコマンドでノード適合テストを実行します:</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># $CONFIG_DIRはKubeletのPodのマニフェストパスです。</span>
<span style=color:#080;font-style:italic># $LOG_DIRはテスト出力のパスです。</span>
sudo docker run -it --rm --privileged --net<span style=color:#666>=</span>host <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -v /:/rootfs -v <span style=color:#b8860b>$CONFIG_DIR</span>:<span style=color:#b8860b>$CONFIG_DIR</span> -v <span style=color:#b8860b>$LOG_DIR</span>:/var/result <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  k8s.gcr.io/node-test:0.2
</code></pre></div><h2 id=他アーキテクチャ向けのノード適合テストの実行>他アーキテクチャ向けのノード適合テストの実行</h2>
<p>Kubernetesは他のアーキテクチャ用のノード適合テストのdockerイメージを提供しています:</p>
<table>
<thead>
<tr>
<th>Arch</th>
<th style=text-align:center>Image</th>
</tr>
</thead>
<tbody>
<tr>
<td>amd64</td>
<td style=text-align:center>node-test-amd64</td>
</tr>
<tr>
<td>arm</td>
<td style=text-align:center>node-test-arm</td>
</tr>
<tr>
<td>arm64</td>
<td style=text-align:center>node-test-arm64</td>
</tr>
</tbody>
</table>
<h2 id=選択したテストの実行>選択したテストの実行</h2>
<p>特定のテストを実行するには、環境変数<code>FOCUS</code>を実行したいテストの正規表現で上書きします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo docker run -it --rm --privileged --net<span style=color:#666>=</span>host <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -v /:/rootfs:ro -v <span style=color:#b8860b>$CONFIG_DIR</span>:<span style=color:#b8860b>$CONFIG_DIR</span> -v <span style=color:#b8860b>$LOG_DIR</span>:/var/result <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -e <span style=color:#b8860b>FOCUS</span><span style=color:#666>=</span>MirrorPod <span style=color:#b62;font-weight:700>\ </span><span style=color:#080;font-style:italic># MirrorPodテストのみを実行します</span>
  k8s.gcr.io/node-test:0.2
</code></pre></div><p>特定のテストをスキップするには、環境変数<code>SKIP</code>をスキップしたいテストの正規表現で上書きします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo docker run -it --rm --privileged --net<span style=color:#666>=</span>host <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -v /:/rootfs:ro -v <span style=color:#b8860b>$CONFIG_DIR</span>:<span style=color:#b8860b>$CONFIG_DIR</span> -v <span style=color:#b8860b>$LOG_DIR</span>:/var/result <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -e <span style=color:#b8860b>SKIP</span><span style=color:#666>=</span>MirrorPod <span style=color:#b62;font-weight:700>\ </span><span style=color:#080;font-style:italic># MirrorPodテスト以外のすべてのノード適合テストを実行します</span>
  k8s.gcr.io/node-test:0.2
</code></pre></div><p>ノード適合テストは、<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/e2e-node-tests.md>node e2e test</a>のコンテナ化されたバージョンです。
デフォルトでは、すべての適合テストが実行されます。</p>
<p>理論的には、コンテナを構成し必要なボリュームを適切にマウントすれば、どのノードのe2eテストも実行できます。しかし、不適合テストを実行するためにはより複雑な設定が必要となるため、<strong>適合テストのみを実行することを強く推奨します</strong>。</p>
<h2 id=注意事項>注意事項</h2>
<ul>
<li>このテストでは、ノード適合テストイメージや機能テストで使用されるコンテナのイメージなど、いくつかのdockerイメージがノード上に残ります。</li>
<li>このテストでは、ノード上にデッドコンテナが残ります。これらのコンテナは機能テスト中に作成されます。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0394f813094b7a35058dffe5b8bacd20>2.4.4 - PKI証明書とその要件</h1>
<p>Kubernetesでは、TLS認証のためにPKI証明書が必要です。
<a href=/docs/reference/setup-tools/kubeadm/kubeadm/>kubeadm</a>でKubernetesをインストールする場合、必要な証明書は自動で生成されます。
自身で証明書を作成することも可能です。例えば、秘密鍵をAPIサーバーに保持しないことで、管理をよりセキュアにする場合が挙げられます。
本ページでは、クラスターに必要な証明書について説明します。</p>
<h2 id=クラスタではどのように証明書が使われているのか>クラスタではどのように証明書が使われているのか</h2>
<p>Kubernetesは下記の用途でPKIを必要とします：</p>
<ul>
<li>kubeletがAPIサーバーの認証をするためのクライアント証明書</li>
<li>APIサーバーのエンドポイント用サーバー証明書</li>
<li>クラスターの管理者がAPIサーバーの認証を行うためのクライアント証明書</li>
<li>APIサーバーがkubeletと通信するためのクライアント証明書</li>
<li>APIサーバーがetcdと通信するためのクライアント証明書</li>
<li>controller managerがAPIサーバーと通信するためのクライアント証明書およびkubeconfig</li>
<li>スケジューラーがAPIサーバーと通信するためのクライアント証明書およびkubeconfig</li>
<li><a href=/docs/tasks/extend-kubernetes/configure-aggregation-layer/>front-proxy</a>用のクライアント証明書およびサーバー証明書</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>front-proxy</code>証明書は、<a href=/docs/tasks/extend-kubernetes/setup-extension-api-server/>Kubernetes APIの拡張</a>をサポートするためにkube-proxyを実行する場合のみ必要です。
</div>
<p>さらに、etcdはクライアントおよびピア間の認証に相互TLS通信を実装しています。</p>
<h2 id=証明書の保存場所>証明書の保存場所</h2>
<p>kubeadmを使用してKubernetesをインストールする場合、証明書は<code>/etc/kubernetes/pki</code>に保存されます。このドキュメントの全てのパスは、そのディレクトリの相対パスを表します。</p>
<h2 id=手動で証明書を設定する>手動で証明書を設定する</h2>
<p>kubeadmで証明書を生成したくない場合は、下記の方法のいずれかで手動で生成可能です。</p>
<h3 id=単一ルート認証局>単一ルート認証局</h3>
<p>管理者によりコントロールされた、単一ルート認証局の作成が可能です。このルート認証局は複数の中間認証局を作る事が可能で、作成はKubernetes自身に委ねます。</p>
<p>必要な認証局:</p>
<table>
<thead>
<tr>
<th>パス</th>
<th>デフォルトCN</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ca.crt,key</td>
<td>kubernetes-ca</td>
<td>Kubernetes全体の認証局　　　</td>
</tr>
<tr>
<td>etcd/ca.crt,key</td>
<td>etcd-ca</td>
<td>etcd用　　　　　　　　　　　　　　</td>
</tr>
<tr>
<td>front-proxy-ca.crt,key</td>
<td>kubernetes-front-proxy-ca</td>
<td><a href=/docs/tasks/extend-kubernetes/configure-aggregation-layer/>front-end proxy</a>用　　　</td>
</tr>
</tbody>
</table>
<p>上記の認証局に加えて、サービスアカウント管理用に公開鍵/秘密鍵のペア(<code>sa.key</code>と<code>sa.pub</code>)を取得する事が必要です。</p>
<h3 id=全ての証明書>全ての証明書</h3>
<p>CAの秘密鍵をクラスターにコピーしたくない場合、自身で全ての証明書を作成できます。</p>
<p>必要な証明書:</p>
<table>
<thead>
<tr>
<th>デフォルトCN</th>
<th>親認証局</th>
<th>組織 　　　　　　</th>
<th>種類</th>
<th>ホスト名 (SAN)</th>
</tr>
</thead>
<tbody>
<tr>
<td>kube-etcd</td>
<td>etcd-ca</td>
<td></td>
<td>server, client</td>
<td><code>localhost</code>, <code>127.0.0.1</code></td>
</tr>
<tr>
<td>kube-etcd-peer</td>
<td>etcd-ca</td>
<td></td>
<td>server, client</td>
<td><code>&lt;hostname></code>, <code>&lt;Host_IP></code>, <code>localhost</code>, <code>127.0.0.1</code></td>
</tr>
<tr>
<td>kube-etcd-healthcheck-client</td>
<td>etcd-ca</td>
<td></td>
<td>client</td>
<td></td>
</tr>
<tr>
<td>kube-apiserver-etcd-client</td>
<td>etcd-ca</td>
<td>system:masters</td>
<td>client</td>
<td></td>
</tr>
<tr>
<td>kube-apiserver</td>
<td>kubernetes-ca</td>
<td></td>
<td>server</td>
<td><code>&lt;hostname></code>, <code>&lt;Host_IP></code>, <code>&lt;advertise_IP></code>, <code>[1]</code></td>
</tr>
<tr>
<td>kube-apiserver-kubelet-client</td>
<td>kubernetes-ca</td>
<td>system:masters</td>
<td>client</td>
<td></td>
</tr>
<tr>
<td>front-proxy-client</td>
<td>kubernetes-front-proxy-ca</td>
<td></td>
<td>client</td>
<td></td>
</tr>
</tbody>
</table>
<p>[1]: クラスターに接続するIPおよびDNS名( <a href=/docs/reference/setup-tools/kubeadm/kubeadm/>kubeadm</a>を使用する場合と同様、ロードバランサーのIPおよびDNS名、<code>kubernetes</code>、<code>kubernetes.default</code>、<code>kubernetes.default.svc</code>、<code>kubernetes.default.svc.cluster</code>、<code>kubernetes.default.svc.cluster.local</code>)</p>
<p><code>kind</code>は下記の<a href=https://godoc.org/k8s.io/api/certificates/v1beta1#KeyUsage>x509の鍵用途</a>のタイプにマッピングされます:</p>
<table>
<thead>
<tr>
<th>種類</th>
<th>鍵の用途 　　　</th>
</tr>
</thead>
<tbody>
<tr>
<td>server</td>
<td>digital signature, key encipherment, server auth</td>
</tr>
<tr>
<td>client</td>
<td>digital signature, key encipherment, client auth</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 上記に挙げられたホスト名(SAN)は、クラスターを動作させるために推奨されるものです。
特別なセットアップが求められる場合、全てのサーバー証明書にSANを追加する事ができます。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>kubeadm利用者のみ：</p>
<ul>
<li>秘密鍵なしでCA証明書をクラスターにコピーするシナリオは、kubeadmドキュメントの外部認証局の項目で言及されています。</li>
<li>kubeadmでPKIを生成すると、<code>kube-etcd</code>、<code>kube-etcd-peer</code>および <code>kube-etcd-healthcheck-client</code>証明書は外部etcdを利用するケースでは生成されない事に留意してください。</li>
</ul>
</div>
<h3 id=証明書のパス>証明書のパス</h3>
<p>証明書は推奨パスに配置するべきです(<a href=/docs/reference/setup-tools/kubeadm/kubeadm/>kubeadm</a>を使用する場合と同様)。
パスは場所に関係なく与えられた引数で特定されます。</p>
<table>
<thead>
<tr>
<th>デフォルトCN</th>
<th>鍵の推奨パス 　　　　　　</th>
<th>証明書の推奨パス 　　　　　</th>
<th>コマンド</th>
<th>鍵を指定する引数</th>
<th>証明書を指定する引数</th>
</tr>
</thead>
<tbody>
<tr>
<td>etcd-ca</td>
<td>etcd/ca.key</td>
<td>etcd/ca.crt</td>
<td>kube-apiserver</td>
<td></td>
<td>--etcd-cafile</td>
</tr>
<tr>
<td>kube-apiserver-etcd-client</td>
<td>apiserver-etcd-client.key</td>
<td>apiserver-etcd-client.crt</td>
<td>kube-apiserver</td>
<td>--etcd-keyfile</td>
<td>--etcd-certfile</td>
</tr>
<tr>
<td>kubernetes-ca</td>
<td>ca.key</td>
<td>ca.crt</td>
<td>kube-apiserver</td>
<td></td>
<td>--client-ca-file</td>
</tr>
<tr>
<td>kubernetes-ca</td>
<td>ca.key</td>
<td>ca.crt</td>
<td>kube-controller-manager</td>
<td>--cluster-signing-key-file</td>
<td>--client-ca-file, --root-ca-file, --cluster-signing-cert-file</td>
</tr>
<tr>
<td>kube-apiserver</td>
<td>apiserver.key</td>
<td>apiserver.crt</td>
<td>kube-apiserver</td>
<td>--tls-private-key-file</td>
<td>--tls-cert-file</td>
</tr>
<tr>
<td>kube-apiserver-kubelet-client</td>
<td>apiserver-kubelet-client.key</td>
<td>apiserver-kubelet-client.crt</td>
<td>kube-apiserver</td>
<td>--kubelet-client-key</td>
<td>--kubelet-client-certificate</td>
</tr>
<tr>
<td>front-proxy-ca</td>
<td>front-proxy-ca.key</td>
<td>front-proxy-ca.crt</td>
<td>kube-apiserver</td>
<td></td>
<td>--requestheader-client-ca-file</td>
</tr>
<tr>
<td>front-proxy-ca</td>
<td>front-proxy-ca.key</td>
<td>front-proxy-ca.crt</td>
<td>kube-controller-manager</td>
<td></td>
<td>--requestheader-client-ca-file</td>
</tr>
<tr>
<td>front-proxy-client</td>
<td>front-proxy-client.key</td>
<td>front-proxy-client.crt</td>
<td>kube-apiserver</td>
<td>--proxy-client-key-file</td>
<td>--proxy-client-cert-file</td>
</tr>
<tr>
<td>etcd-ca</td>
<td>etcd/ca.key</td>
<td>etcd/ca.crt</td>
<td>etcd</td>
<td></td>
<td>--trusted-ca-file, --peer-trusted-ca-file</td>
</tr>
<tr>
<td>kube-etcd</td>
<td>etcd/server.key</td>
<td>etcd/server.crt</td>
<td>etcd</td>
<td>--key-file</td>
<td>--cert-file</td>
</tr>
<tr>
<td>kube-etcd-peer</td>
<td>etcd/peer.key</td>
<td>etcd/peer.crt</td>
<td>etcd</td>
<td>--peer-key-file</td>
<td>--peer-cert-file</td>
</tr>
<tr>
<td>etcd-ca</td>
<td></td>
<td>etcd/ca.crt</td>
<td>etcdctl</td>
<td></td>
<td>--cacert</td>
</tr>
<tr>
<td>kube-etcd-healthcheck-client</td>
<td>etcd/healthcheck-client.key</td>
<td>etcd/healthcheck-client.crt</td>
<td>etcdctl</td>
<td>--key</td>
<td>--cert</td>
</tr>
</tbody>
</table>
<p>サービスアカウント用の鍵ペアについても同様です。</p>
<table>
<thead>
<tr>
<th>秘密鍵のパス 　　　　</th>
<th>　公開鍵のパス 　　　</th>
<th>コマンド</th>
<th>引数</th>
</tr>
</thead>
<tbody>
<tr>
<td>sa.key</td>
<td></td>
<td>kube-controller-manager</td>
<td>service-account-private</td>
</tr>
<tr>
<td></td>
<td>sa.pub</td>
<td>kube-apiserver</td>
<td>service-account-key</td>
</tr>
</tbody>
</table>
<h2 id=ユーザアカウント用に証明書を設定する>ユーザアカウント用に証明書を設定する</h2>
<p>管理者アカウントおよびサービスアカウントは手動で設定しなければなりません。</p>
<table>
<thead>
<tr>
<th>ファイル名</th>
<th>クレデンシャル名</th>
<th>デフォルトCN</th>
<th>組織　　　　　　</th>
</tr>
</thead>
<tbody>
<tr>
<td>admin.conf</td>
<td>default-admin</td>
<td>kubernetes-admin</td>
<td>system:masters</td>
</tr>
<tr>
<td>kubelet.conf</td>
<td>default-auth</td>
<td>system:node:<code>&lt;nodeName></code> (see note)</td>
<td>system:nodes</td>
</tr>
<tr>
<td>controller-manager.conf</td>
<td>default-controller-manager</td>
<td>system:kube-controller-manager</td>
<td></td>
</tr>
<tr>
<td>scheduler.conf</td>
<td>default-scheduler</td>
<td>system:kube-scheduler</td>
<td></td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>kubelet.conf</code>における<code>&lt;nodeName></code>の値は<strong>必ず</strong>APIサーバーに登録されたkubeletのノード名と一致しなければなりません。詳細は、<a href=/docs/reference/access-authn-authz/node/>Node Authorization</a>を参照してください。
</div>
<ol>
<li>
<p>各コンフィグ毎に、CN名と組織を指定してx509証明書と鍵ペアを生成してください。</p>
</li>
<li>
<p>以下のように、各コンフィグで<code>kubectl</code>を実行してください。</p>
</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>&lt;filename&gt; kubectl config set-cluster default-cluster --server<span style=color:#666>=</span>https://&lt;host ip&gt;:6443 --certificate-authority &lt;path-to-kubernetes-ca&gt; --embed-certs
<span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>&lt;filename&gt; kubectl config set-credentials &lt;credential-name&gt; --client-key &lt;path-to-key&gt;.pem --client-certificate &lt;path-to-cert&gt;.pem --embed-certs
<span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>&lt;filename&gt; kubectl config set-context default-system --cluster default-cluster --user &lt;credential-name&gt;
<span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>&lt;filename&gt; kubectl config use-context default-system
</code></pre></div><p>これらのファイルは以下のように利用されます:</p>
<table>
<thead>
<tr>
<th>ファイル名</th>
<th>コマンド</th>
<th>コメント</th>
</tr>
</thead>
<tbody>
<tr>
<td>admin.conf</td>
<td>kubectl</td>
<td>クラスターの管理者設定用</td>
</tr>
<tr>
<td>kubelet.conf</td>
<td>kubelet</td>
<td>クラスターの各ノードに1つ必要です。</td>
</tr>
<tr>
<td>controller-manager.conf</td>
<td>kube-controller-manager</td>
<td><code>manifests/kube-controller-manager.yaml</code>のマニフェストファイルに追記する必要があります。</td>
</tr>
<tr>
<td>scheduler.conf</td>
<td>kube-scheduler</td>
<td><code>manifests/kube-scheduler.yaml</code>のマニフェストファイルに追記する必要があります。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-dd948255948d6b59b32c471abcb62997>3 - コンセプト</h1>
<p>本セクションは、Kubernetesシステムの各パートと、<a class=glossary-tooltip title=コンテナ化されたアプリケーションを実行する、ノードと呼ばれるワーカーマシンの集合です。すべてのクラスターには少なくとも1つのワーカーノードがあります。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-cluster" target=_blank aria-label=クラスター>クラスター</a>を表現するためにKubernetesが使用する抽象概念について学習し、Kubernetesの仕組みをより深く理解するのに役立ちます。</p>
<h2 id=概要>概要</h2>
<p>Kubernetesを機能させるには、<em>Kubernetes API オブジェクト</em> を使用して、実行したいアプリケーションやその他のワークロード、使用するコンテナイメージ、レプリカ(複製)の数、どんなネットワークやディスクリソースを利用可能にするかなど、クラスターの <em>desired state</em> (望ましい状態)を記述します。desired state (望ましい状態)をセットするには、Kubernetes APIを使用してオブジェクトを作成します。通常はコマンドラインインターフェイス <code>kubectl</code> を用いてKubernetes APIを操作しますが、Kubernetes APIを直接使用してクラスターと対話し、desired state (望ましい状態)を設定、または変更することもできます。</p>
<p>一旦desired state (望ましい状態)を設定すると、Pod Lifecycle Event Generator(<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md>PLEG</a>)を使用した<em>Kubernetes コントロールプレーン</em>が機能し、クラスターの現在の状態をdesired state (望ましい状態)に一致させます。そのためにKubernetesはさまざまなタスク(たとえば、コンテナの起動または再起動、特定アプリケーションのレプリカ数のスケーリング等)を自動的に実行します。Kubernetesコントロールプレーンは、クラスターで実行されている以下のプロセスで構成されています。</p>
<ul>
<li><strong>Kubernetes Master</strong>: <a href=/docs/admin/kube-apiserver/>kube-apiserver</a>、<a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a>、<a href=/docs/admin/kube-scheduler/>kube-scheduler</a> の3プロセスの集合です。これらのプロセスはクラスター内の一つのノード上で実行されます。実行ノードはマスターノードとして指定します。</li>
<li>クラスター内の個々の非マスターノードは、それぞれ2つのプロセスを実行します。
<ul>
<li><strong><a href=/docs/admin/kubelet/>kubelet</a></strong>: Kubernetes Masterと通信します。</li>
<li><strong><a href=/docs/admin/kube-proxy/>kube-proxy</a></strong>: 各ノードのKubernetesネットワークサービスを反映するネットワークプロキシです。</li>
</ul>
</li>
</ul>
<h2 id=kubernetes-objects>Kubernetesオブジェクト</h2>
<p>Kubernetesには、デプロイ済みのコンテナ化されたアプリケーションやワークロード、関連するネットワークとディスクリソース、クラスターが何をしているかに関するその他の情報といった、システムの状態を表現する抽象が含まれています。これらの抽象は、Kubernetes APIのオブジェクトによって表現されます。詳細については、<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>Kubernetesオブジェクトについて知る</a>をご覧ください。</p>
<p>基本的なKubernetesのオブジェクトは次のとおりです。</p>
<ul>
<li><a href=/ja/docs/concepts/workloads/pods/pod-overview/>Pod</a></li>
<li><a href=/ja/docs/concepts/services-networking/service/>Service</a></li>
<li><a href=/docs/concepts/storage/volumes/>Volume</a></li>
<li><a href=/ja/docs/concepts/overview/working-with-objects/namespaces/>Namespace</a></li>
</ul>
<p>Kubernetesには、<a href=/ja/docs/concepts/architecture/controller/>コントローラー</a>に依存して基本オブジェクトを構築し、追加の機能と便利な機能を提供する高レベルの抽象化も含まれています。これらには以下のものを含みます:</p>
<ul>
<li><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a></li>
<li><a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a></li>
<li><a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li>
<li><a href=/ja/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a></li>
<li><a href=/docs/concepts/workloads/controllers/jobs-run-to-completion/>Job</a></li>
</ul>
<h2 id=kubernetes-control-plane>Kubernetesコントロールプレーン</h2>
<p>Kubernetesマスターや kubeletプロセスといったKubernetesコントロールプレーンのさまざまなパーツは、Kubernetesがクラスターとどのように通信するかを統制します。コントロールプレーンはシステム内のすべてのKubernetesオブジェクトの記録を保持し、それらのオブジェクトの状態を管理するために継続的制御ループを実行します。コントロールプレーンの制御ループは常にクラスターの変更に反応し、システム内のすべてのオブジェクトの実際の状態が、指定した状態に一致するように動作します。</p>
<p>たとえば、Kubernetes APIを使用してDeploymentを作成する場合、システムには新しいdesired state (望ましい状態)が提供されます。Kubernetesコントロールプレーンは、そのオブジェクトの作成を記録します。そして、要求されたアプリケーションの開始、およびクラスターノードへのスケジューリングにより指示を完遂します。このようにしてクラスターの実際の状態を望ましい状態に一致させます。</p>
<h3 id=kubernetesマスター>Kubernetesマスター</h3>
<p>Kubernetesのマスターは、クラスターの望ましい状態を維持する責務を持ちます。<code>kubectl</code> コマンドラインインターフェイスを使用するなどしてKubernetesとやり取りするとき、ユーザーは実際にはクラスターにあるKubernetesのマスターと通信しています。</p>
<p>「マスター」とは、クラスター状態を管理するプロセスの集合を指します。通常これらのプロセスは、すべてクラスター内の単一ノードで実行されます。このノードはマスターとも呼ばれます。マスターは、可用性と冗長性のために複製することもできます。</p>
<h3 id=kubernetesノード>Kubernetesノード</h3>
<p>クラスターのノードは、アプリケーションとクラウドワークフローを実行するマシン(VM、物理サーバーなど)です。Kubernetesのマスターは各ノードを制御します。運用者自身がノードと直接対話することはほとんどありません。</p>
<h2 id=次の項目>次の項目</h2>
<p>コンセプトページを追加したい場合は、
<a href=/docs/home/contribute/page-templates/>ページテンプレートの使用</a>
のコンセプトページタイプとコンセプトテンプレートに関する情報を確認してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0554ac387412eaf4e6e89b2f847dacde>3.1 - 概要</h1>
</div>
<div class=td-content>
<h1 id=pg-45bdca6129cf540121623e903c18ba46>3.1.1 - Kubernetesとは何か？</h1>
<div class=lead>Kubernetesは、宣言的な構成管理と自動化を促進し、コンテナ化されたワークロードやサービスを管理するための、ポータブルで拡張性のあるオープンソースのプラットフォームです。Kubernetesは巨大で急速に成長しているエコシステムを備えており、それらのサービス、サポート、ツールは幅広い形で利用可能です。</div>
<p>このページでは、Kubernetesの概要について説明します。</p>
<p>Kubernetesは、宣言的な構成管理と自動化を促進し、コンテナ化されたワークロードやサービスを管理するための、ポータブルで拡張性のあるオープンソースのプラットフォームです。Kubernetesは巨大で急速に成長しているエコシステムを備えており、それらのサービス、サポート、ツールは幅広い形で利用可能です。</p>
<p>Kubernetesの名称は、ギリシャ語に由来し、操舵手やパイロットを意味しています。Googleは2014年にKubernetesプロジェクトをオープンソース化しました。Kubernetesは、本番環境で大規模なワークロードを稼働させた<a href=/blog/2015/04/borg-predecessor-to-kubernetes/>Googleの15年以上の経験</a>と、コミュニティからの最高のアイディアや実践を組み合わせています。</p>
<h2 id=過去を振り返ってみると>過去を振り返ってみると</h2>
<p>過去を振り返って、Kubernetesがなぜこんなに便利なのかを見てみましょう。</p>
<p><img src=/images/docs/Container_Evolution.svg alt="Deployment evolution"></p>
<p><strong>仮想化ができる前の時代におけるデプロイ (Traditional deployment):</strong> 初期の頃は、組織は物理サーバー上にアプリケーションを実行させていました。物理サーバー上でアプリケーションのリソース制限を設定する方法がなかったため、リソースの割当問題が発生していました。例えば、複数のアプリケーションを実行させた場合、ひとつのアプリケーションがリソースの大半を消費してしまうと、他のアプリケーションのパフォーマンスが低下してしまうことがありました。この解決方法は、それぞれのアプリケーションを別々の物理サーバーで動かすことでした。しかし、リソースが十分に活用できなかったため、拡大しませんでした。また組織にとって多くの物理サーバーを維持することは費用がかかりました。</p>
<p><strong>仮想化を使ったデプロイ (Virtualized deployment):</strong> ひとつの解決方法として、仮想化が導入されました。1台の物理サーバーのCPU上で、複数の仮想マシン(VM)を実行させることができるようになりました。仮想化によりアプリケーションをVM毎に隔離する事ができ、ひとつのアプリケーションの情報が他のアプリケーションから自由にアクセスさせないといったセキュリティレベルを提供することができます。</p>
<p>仮想化により、物理サーバー内のリソース使用率が向上し、アプリケーションの追加や更新が容易になり、ハードウェアコストの削減などスケーラビリティが向上します。仮想化を利用すると、物理リソースのセットを使い捨て可能な仮想マシンのクラスターとして提示することができます。</p>
<p>各VMは、仮想ハードウェア上で各自のOSを含んだ全コンポーネントを実行する完全なマシンです。</p>
<p><strong>コンテナを使ったデプロイ (Container deployment):</strong> コンテナはVMと似ていますが、アプリケーション間でオペレーティング・システム(OS)を共有できる緩和された分離特性を持っています。そのため、コンテナは軽量だといわれます。VMと同じように、コンテナは各自のファイルシステム、CPUの共有、メモリー、プロセス空間等を持っています。基盤のインフラストラクチャから分離されているため、クラウドやOSディストリビューションを越えて移動することが可能です。</p>
<p>コンテナは、その他にも次のようなメリットを提供するため、人気が高まっています。</p>
<ul>
<li>アジャイルアプリケーションの作成とデプロイ: VMイメージの利用時と比較して、コンテナイメージ作成の容易さと効率性が向上します。</li>
<li>継続的な開発、インテグレーションとデプロイ: 信頼できる頻繁なコンテナイメージのビルドと、素早く簡単にロールバックすることが可能なデプロイを提供します。(イメージが不変であれば)</li>
<li>開発者と運用者の関心を分離: アプリケーションコンテナイメージの作成は、デプロイ時ではなく、ビルド/リリース時に行います。それによって、インフラストラクチャとアプリケーションを分離します。</li>
<li>可観測性はOSレベルの情報とメトリクスだけではなく、アプリケーションの稼働状態やその他の警告も表示します。</li>
<li>開発、テスト、本番環境を越えた環境の一貫性: クラウドで実行させるのと同じようにノートPCでも実行させる事ができます。</li>
<li>クラウドとOSディストリビューションの可搬性: Ubuntu、RHEL、CoreOS上でも、オンプレミスも、主要なパブリッククラウドでも、それ以外のどんな環境でも、実行できます。</li>
<li>アプリケーション中心の管理: 仮想マシン上でOSを実行するから、論理リソースを使用してOS上でアプリケーションを実行するへと抽象度のレベルを向上させます。</li>
<li>疎結合、分散化、拡張性、柔軟性のあるマイクロサービス: アプリケーションを小さく、同時にデプロイと管理が可能な独立した部品に分割されます。1台の大きな単一目的のマシン上に実行するモノリシックなスタックではありません。</li>
<li>リソースの分割: アプリケーションのパフォーマンスが予測可能です。</li>
<li>リソースの効率的な利用: 高い効率性と集約性が可能です。</li>
</ul>
<h2 id=why-you-need-kubernetes-and-what-can-it-do>Kubernetesが必要な理由と提供する機能</h2>
<p>コンテナは、アプリケーションを集約して実行する良い方法です。本番環境では、アプリケーションを実行しダウンタイムが発生しないように、コンテナを管理する必要があります。例えば、コンテナがダウンした場合、他のコンテナを起動する必要があります。このような動作がシステムに組込まれていると、管理が簡単になるのではないでしょうか？</p>
<p>そこを助けてくれるのがKubernetesです! Kubernetesは分散システムを弾力的に実行するフレームワークを提供してくれます。あなたのアプリケーションのためにスケーリングとフェイルオーバーの面倒を見てくれて、デプロイのパターンなどを提供します。例えば、Kubernetesはシステムにカナリアデプロイを簡単に管理することができます。</p>
<p>Kubernetesは以下を提供します。</p>
<ul>
<li><strong>サービスディスカバリーと負荷分散</strong>
Kubernetesは、DNS名または独自のIPアドレスを使ってコンテナを公開することができます。コンテナへのトラフィックが多い場合は、Kubernetesは負荷分散し、ネットワークトラフィックを振り分けることができるため、デプロイが安定します。</li>
<li><strong>ストレージ オーケストレーション</strong>
Kubernetesは、ローカルストレージやパブリッククラウドプロバイダーなど、選択したストレージシステムを自動でマウントすることができます。</li>
<li><strong>自動化されたロールアウトとロールバック</strong>
Kubernetesを使うとデプロイしたコンテナのあるべき状態を記述することができ、制御されたスピードで実際の状態をあるべき状態に変更することができます。例えば、アプリケーションのデプロイのために、新しいコンテナの作成や既存コンテナの削除、新しいコンテナにあらゆるリソースを適用する作業を、Kubernetesで自動化できます。</li>
<li><strong>自動ビンパッキング</strong>
コンテナ化されたタスクを実行するノードのクラスターをKubernetesへ提供します。各コンテナがどれくらいCPUやメモリー(RAM)を必要とするのかをKubernetesに宣言することができます。Kubernetesはコンテナをノードにあわせて調整することができ、リソースを最大限に活用してくれます。</li>
<li><strong>自己修復</strong>
Kubernetesは、処理が失敗したコンテナを再起動し、コンテナを入れ替え、定義したヘルスチェックに応答しないコンテナを強制終了します。処理の準備ができるまでは、クライアントに通知しません。</li>
<li><strong>機密情報と構成管理</strong>
Kubernetesは、パスワードやOAuthトークン、SSHキーのよう機密の情報を保持し、管理することができます。機密情報をデプロイし、コンテナイメージを再作成することなくアプリケーションの構成情報を更新することができます。スタック構成の中で機密情報を晒してしまうこともありません。</li>
</ul>
<h2 id=kubernetesにないもの>Kubernetesにないもの</h2>
<p>Kubernetesは、従来型の全部入りなPaaS(Platform as a Service)のシステムではありません。Kubernetesはハードウェアレベルではなく、コンテナレベルで動作するため、デプロイ、スケーリング、負荷分散といったPaaSが提供するのと共通の機能をいくつか提供し、またユーザーはロギングやモニタリング及びアラートを行うソリューションを統合できます。また一方、Kubernetesはモノリシックでなく、標準のソリューションは選択が自由で、追加と削除が容易な構成になっています。Kubernetesは開発プラットフォーム構築のためにビルディングブロックを提供しますが、重要な部分はユーザーの選択と柔軟性を維持しています。</p>
<p>Kubernetesは...</p>
<ul>
<li>サポートするアプリケーションの種類を制限しません。Kubernetesは、ステートレス、ステートフルやデータ処理のワークロードなど、非常に多様なワークロードをサポートすることを目的としています。アプリケーションがコンテナで実行できるのであれば、Kubernetes上で問題なく実行できるはずです。</li>
<li>ソースコードのデプロイやアプリケーションのビルドは行いません。継続的なインテグレーション、デリバリー、デプロイ(CI/CD)のワークフローは、技術的な要件だけでなく組織の文化や好みで決められます。</li>
<li>ミドルウェア(例:メッセージバス)、データ処理フレームワーク(例:Spark)、データベース(例:MySQL)、キャッシュ、クラスターストレージシステム(例:Ceph)といったアプリケーションレベルの機能を組み込んで提供しません。それらのコンポーネントは、Kubernetes上で実行することもできますし、<a href=https://openservicebrokerapi.org/>Open Service Broker</a>のようなポータブルメカニズムを経由してKubernetes上で実行されるアプリケーションからアクセスすることも可能です。</li>
<li>ロギング、モニタリングやアラートを行うソリューションは指定しません。PoCとしていくつかのインテグレーションとメトリクスを収集し出力するメカニズムを提供します。</li>
<li>構成言語/システム(例:Jsonnet)の提供も指示もしません。任意の形式の宣言型仕様の対象となる可能性のある宣言型APIを提供します。</li>
<li>統合的なマシンの構成、メンテナンス、管理、または自己修復を行うシステムは提供も採用も行いません。</li>
<li>さらに、Kubernetesは単なるオーケストレーションシステムではありません。実際には、オーケストレーションの必要性はありません。オーケストレーションの技術的な定義は、「最初にAを実行し、次にB、その次にCを実行」のような定義されたワークフローの実行です。対照的にKubernetesは、現在の状態から提示されたあるべき状態にあわせて継続的に維持するといった、独立していて構成可能な制御プロセスのセットを提供します。AからCへどのように移行するかは問題ではありません。集中管理も必要ありません。これにより、使いやすく、より強力で、堅牢で、弾力性と拡張性があるシステムが実現します。</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/overview/components/>Kubernetesのコンポーネント</a>を御覧ください。</li>
<li><a href=/ja/docs/setup/>はじめる</a>準備はできましたか？</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>3.1.2 - Kubernetesのコンポーネント</h1>
<div class=lead>Kubernetesクラスターはコントロールプレーンやノードと呼ばれるマシン群といったコンポーネントからなります。</div>
<p>Kubernetesをデプロイすると、クラスターが展開されます。
<p><p>Kubernetesクラスターは、 コンテナ化されたアプリケーションを実行する、<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>と呼ばれるワーカーマシンの集合です。すべてのクラスターには少なくとも1つのワーカーノードがあります。</p></p>
<p>ワーカーノードは、アプリケーションのコンポーネントであるPodをホストします。マスターノードは、クラスター内のワーカーノードとPodを管理します。複数のマスターノードを使用して、クラスターにフェイルオーバーと高可用性を提供します。
ワーカーノードは、アプリケーションワークロードのコンポーネントである<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>をホストします。<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>は、クラスター内のワーカーノードとPodを管理します。本番環境では、コントロールプレーンは複数のコンピューターを使用し、クラスターは複数のノードを使用し、耐障害性や高可用性を提供します。</p></p>
<p>このドキュメントでは、Kubernetesクラスターが機能するために必要となるさまざまなコンポーネントの概要を説明します。</p>
<p>すべてのコンポーネントが結び付けられたKubernetesクラスターの図を次に示します。</p>
<p><img src=/images/docs/components-of-kubernetes.svg alt=Kubernetesのコンポーネント></p>
<h2 id=コントロールプレーンコンポーネント>コントロールプレーンコンポーネント</h2>
<p>コントロールプレーンコンポーネントは、クラスターに関する全体的な決定(スケジューリングなど)を行います。また、クラスターイベントの検出および応答を行います(たとえば、deploymentの<code>replicas</code>フィールドが満たされていない場合に、新しい <a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> を起動する等)。</p>
<p>コントロールプレーンコンポーネントはクラスター内のどのマシンでも実行できますが、シンプルにするため、セットアップスクリプトは通常、すべてのコントロールプレーンコンポーネントを同じマシンで起動し、そのマシンではユーザーコンテナを実行しません。
マルチマスター VMセットアップの例については、<a href=/docs/admin/high-availability/>高可用性クラスターの構築</a> を参照してください。</p>
<h3 id=kube-apiserver>kube-apiserver</h3>
<p>APIサーバーは、Kubernetes APIを外部に提供するKubernetes<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>のコンポーネントです。
APIサーバーはKubernetesコントロールプレーンのフロントエンドになります。</p>
<p>Kubernetes APIサーバーの主な実装は<a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a>です。
kube-apiserverは水平方向にスケールするように設計されています—つまり、インスタンスを追加することでスケールが可能です。
複数のkube-apiserverインスタンスを実行することで、インスタンス間でトラフィックを分散させることが可能です。</p>
<h3 id=etcd>etcd</h3>
<p>一貫性、高可用性を持ったキーバリューストアで、Kubernetesの全てのクラスター情報の保存場所として利用されています。</p>
<p>etcdをKubernetesのデータストアとして使用する場合、必ずデータの<a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>バックアップ</a>プランを作成して下さい。</p>
<p>公式<a href=https://etcd.io/docs/>ドキュメント</a>でetcdに関する詳細な情報を見つけることができます。</p>
<h3 id=kube-scheduler>kube-scheduler</h3>
<p>コントロールプレーン上で動作するコンポーネントで、新しく作られた<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>に<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>が割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。</p>
<p>スケジューリングの決定は、PodあるいはPod群のリソース要求量、ハードウェア/ソフトウェア/ポリシーによる制約、アフィニティおよびアンチアフィニティの指定、データの局所性、ワークロード間の干渉、有効期限などを考慮して行われます。</p>
<h3 id=kube-controller-manager>kube-controller-manager</h3>
<p>コントロールプレーン上で動作するコンポーネントで、複数の<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>プロセスを実行します。</p>
<p>論理的には、各<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>は個別のプロセスですが、複雑さを減らすために一つの実行ファイルにまとめてコンパイルされ、単一のプロセスとして動きます。</p>
<p>コントローラーには以下が含まれます。</p>
<ul>
<li>ノードコントローラー：ノードがダウンした場合の通知と対応を担当します。</li>
<li>レプリケーションコントローラー：システム内の全レプリケーションコントローラーオブジェクトについて、Podの数を正しく保つ役割を持ちます。</li>
<li>エンドポイントコントローラー：エンドポイントオブジェクトを注入します(つまり、ServiceとPodを紐付けます)。</li>
<li>サービスアカウントとトークンコントローラー：新規の名前空間に対して、デフォルトアカウントとAPIアクセストークンを作成します。</li>
</ul>
<h3 id=cloud-controller-manager>cloud-controller-manager</h3>
クラウド特有の制御ロジックを組み込むKubernetesの<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="control plane">control plane</a>コンポーネントです。クラウドコントロールマネージャーは、クラスターをクラウドプロバイダーAPIをリンクし、クラスタのみで相互作用するコンポーネントからクラウドプラットフォームで相互作用するコンポーネントを分離します。
<p>cloud-controller-managerは、クラウドプロバイダー固有のコントローラーのみを実行します。
KubernetesをオンプレミスあるいはPC内での学習環境で動かす際には、クラスターにcloud container managerはありません。</p>
<p>kube-controller-managerを使用すると、cloud-controller-managerは複数の論理的に独立したコントロールループをシングルバイナリにまとめ、これが一つのプロセスとして動作します。パフォーマンスを向上させるあるいは障害に耐えるために水平方向にスケールする(一つ以上のコピーを動かす)ことができます。</p>
<p>次のコントローラーには、クラウドプロバイダーへの依存関係を持つ可能性があります。</p>
<ul>
<li>ノードコントローラー：ノードが応答を停止した後、クラウドで削除されたかどうかを判断するため、クラウドプロバイダーをチェックします。</li>
<li>ルーティングコントローラー：基盤であるクラウドインフラでルーティングを設定します。</li>
<li>サービスコントローラー：クラウドプロバイダーのロードバランサーの作成、更新、削除を行います。</li>
</ul>
<h2 id=node-components>ノードコンポーネント</h2>
<p>ノードコンポーネントはすべてのノードで実行され、稼働中のPodの管理やKubernetesの実行環境を提供します。</p>
<h3 id=kubelet>kubelet</h3>
<p>クラスター内の各<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>で実行されるエージェントです。各<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>が<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>で実行されていることを保証します。</p>
<p>kubeletは、さまざまなメカニズムを通じて提供されるPodSpecのセットを取得し、それらのPodSpecに記述されているコンテナが正常に実行されている状態を保証します。kubeletは、Kubernetesが作成したものではないコンテナは管理しません。</p>
<h3 id=kube-proxy>kube-proxy</h3>
<p>kube-proxyはクラスター内の各<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=node>node</a>で動作しているネットワークプロキシで、Kubernetesの<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>コンセプトの一部を実装しています。</p>
<p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>は、Nodeのネットワークルールをメンテナンスします。これらのネットワークルールにより、クラスターの内部または外部のネットワークセッションからPodへのネットワーク通信が可能になります。</p>
<p>kube-proxyは、オペレーティングシステムにパケットフィルタリング層があり、かつ使用可能な場合、パケットフィルタリング層を使用します。それ以外の場合は自身でトラフィックを転送します。</p>
<h3 id=container-runtime>コンテナランタイム</h3>
<p>コンテナランタイムは、コンテナの実行を担当するソフトウェアです。</p>
<p>Kubernetesは次の複数のコンテナランタイムをサポートします。
<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>、<a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>、<a class=glossary-tooltip title="A lightweight container runtime specifically for Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>、
および全ての
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>
実装です。</p>
<h2 id=アドオン>アドオン</h2>
<p>アドオンはクラスター機能を実装するためにKubernetesリソース(<a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>、<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>など)を使用します。
アドオンはクラスターレベルの機能を提供しているため、アドオンのリソースで名前空間が必要なものは<code>kube-system</code>名前空間に属します。</p>
<p>いくつかのアドオンについて以下で説明します。より多くの利用可能なアドオンのリストは、<a href=/ja/docs/concepts/cluster-administration/addons/>アドオン</a> をご覧ください。</p>
<h3 id=dns>DNS</h3>
<p>クラスターDNS以外のアドオンは必須ではありませんが、すべてのKubernetesクラスターは<a href=/ja/docs/concepts/services-networking/dns-pod-service/>クラスターDNS</a>を持つべきです。多くの使用例がクラスターDNSを前提としています。</p>
<p>クラスターDNSは、環境内の他のDNSサーバーに加えて、KubernetesサービスのDNSレコードを提供するDNSサーバーです。</p>
<p>Kubernetesによって開始されたコンテナは、DNS検索にこのDNSサーバーを自動的に含めます。</p>
<h3 id=web-ui-ダッシュボード>Web UI (ダッシュボード)</h3>
<p><a href=/ja/docs/tasks/access-application-cluster/web-ui-dashboard/>ダッシュボード</a>は、Kubernetesクラスター用の汎用WebベースUIです。これによりユーザーはクラスターおよびクラスター内で実行されているアプリケーションについて、管理およびトラブルシューティングを行うことができます。</p>
<h3 id=コンテナリソース監視>コンテナリソース監視</h3>
<p><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>コンテナリソース監視</a>は、コンテナに関する一般的な時系列メトリックを中央データベースに記録します。また、そのデータを閲覧するためのUIを提供します。</p>
<h3 id=クラスターレベルログ>クラスターレベルログ</h3>
<p><a href=/docs/concepts/cluster-administration/logging/>クラスターレベルログ</a>メカニズムは、コンテナのログを、検索／参照インターフェイスを備えた中央ログストアに保存します。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/architecture/nodes/>ノード</a>について学ぶ</li>
<li><a href=/ja/docs/concepts/architecture/controller/>コントローラー</a>について学ぶ</li>
<li><a href=/ja/docs/concepts/scheduling-eviction/kube-scheduler/>kube-scheduler</a>について学ぶ</li>
<li>etcdの公式 <a href=https://etcd.io/docs/>ドキュメント</a>を読む</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0c745f42e623d2b70a53bc0e6db73d95>3.1.3 - Kubernetes API</h1>
<div class=lead>Kubernetes APIを使用すると、Kubernetes内のオブジェクトの状態をクエリで操作できます。 Kubernetesのコントロールプレーンの中核は、APIサーバーとそれが公開するHTTP APIです。ユーザー、クラスターのさまざまな部分、および外部コンポーネントはすべて、APIサーバーを介して互いに通信します。</div>
<p>Kubernetesの中核である <a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="control plane">control plane</a>は<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API server">API server</a> です。
APIサーバーは、エンドユーザー、クラスターのさまざまな部分、および外部コンポーネントが相互に通信できるようにするHTTP APIを公開します。</p>
<p>Kubernetes APIを使用すると、Kubernetes API内のオブジェクトの状態をクエリで操作できます（例：Pod、Namespace、ConfigMap、Events）。</p>
<p>ほとんどの操作は、APIを使用している<a href=/docs/reference/kubectl/overview/>kubectl</a>コマンドラインインターフェースもしくは<a href=/docs/reference/setup-tools/kubeadm/>kubeadm</a>のような別のコマンドラインツールを通して実行できます。
RESTコールを利用して直接APIにアクセスすることも可能です。</p>
<p>Kubernetes APIを利用してアプリケーションを書いているのであれば、<a href=/docs/reference/using-api/client-libraries/>client libraries</a>の利用を考えてみてください。</p>
<h2 id=api-specification>OpenAPI 仕様</h2>
<p>完全なAPIの詳細は、<a href=https://www.openapis.org/>OpenAPI</a>を使用して文書化されています。</p>
<p>Kubernetes APIサーバーは、<code>/openapi/v2</code>エンドポイントを介してOpenAPI仕様を提供します。
次のように要求ヘッダーを使用して、応答フォーマットを要求できます。</p>
<table>
<caption style=display:none>OpenAPI v2クエリの有効なリクエストヘッダー値</caption>
<thead>
<tr>
<th>Header</th>
<th style=min-width:50%>Possible values</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Accept-Encoding</code></td>
<td><code>gzip</code></td>
<td><em>このヘッダーを使わないことも可能</em></td>
</tr>
<tr>
<td rowspan=3><code>Accept</code></td>
<td><code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code></td>
<td><em>主にクラスター内での使用</em></td>
</tr>
<tr>
<td><code>application/json</code></td>
<td><em>デフォルト</em></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>application/json</code>を提供</td>
</tr>
</tbody>
</table>
<p>Kubernetesは、他の手段として主にクラスター間の連携用途向けのAPIに、Protocol buffersをベースにしたシリアライズフォーマットを実装しています。このフォーマットに関しては、[Kubernetes Protobuf serialization](<a href=https://github.com/kubernetes/community/blob/master/contributors/des>https://github.com/kubernetes/community/blob/master/contributors/des</a> ign-proposals/api-machinery/protobuf.md)デザイン提案を参照してください。また、各スキーマのInterface Definition Language（IDL）ファイルは、APIオブジェクトを定義しているGoパッケージ内に配置されています。</p>
<h2 id=永続性>永続性</h2>
<p>KubernetesはAPIリソースの観点からシリアル化された状態を<a class=glossary-tooltip title=一貫性、高可用性を持ったキーバリューストアで、Kubernetesの全てのクラスター情報の保存場所として利用されています。 data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>に書き込むことで保存します。</p>
<h2 id=apiグループとバージョニング>APIグループとバージョニング</h2>
<p>フィールドの削除やリソース表現の再構成を簡単に行えるようにするため、Kubernetesは複数のAPIバージョンをサポートしており、<code>/api/v1</code>や<code>/apis/rbac.authorization.k8s.io/v1alpha1</code>のように、それぞれ異なるAPIのパスが割り当てられています。</p>
<p>APIが、システムリソースと動作について明確かつ一貫したビューを提供し、サポート終了、実験的なAPIへのアクセス制御を有効にするために、リソースまたはフィールドレベルではなく、APIレベルでバージョンが行われます。</p>
<p>APIの発展や拡張を簡易に行えるようにするため、Kubernetesは<a href=/docs/reference/using-api/#enabling-or-disabling>有効もしくは無効</a>を行える<a href=/docs/reference/using-api/#api-groups>APIグループ</a>を実装しました。</p>
<p>APIリソースは、APIグループ、リソースタイプ、ネームスペース（namespacedリソースのための）、名前によって区別されます。APIサーバーは、APIバージョン間の変換を透過的に処理します。すべてのバージョンの違いは、実際のところ同じ永続データとして表現されます。APIサーバーは、同じ基本的なデータを複数のAPIバージョンで提供することができます。</p>
<p>例えば、同じリソースで<code>v1</code>と<code>v1beta1</code>の2つのバージョンが有ることを考えてみます。<code>v1beta1</code>バージョンのAPIを利用しオブジェクトを最初に作成したとして、<code>v1beta1</code>もしくは<code>v1</code>どちらのAPIバージョンを利用してもオブジェクトのread、update、deleteができます。</p>
<h2 id=apiの変更>APIの変更</h2>
<p>成功を収めているシステムはすべて、新しいユースケースの出現や既存の変化に応じて成長し、変化する必要があります。
したがって、Kubernetesには、Kubernetes APIを継続的に変更および拡張できる設計機能があります。
Kubernetesプロジェクトは、既存のクライアントとの互換性を破壊 <em>しないこと</em> 、およびその互換性を一定期間維持して、他のプロジェクトが適応する機会を提供することを目的としています。</p>
<p>基本的に、新しいAPIリソースと新しいリソースフィールドは追加することができます。
リソースまたはフィールドを削除するには、<a href=/docs/reference/using-api/deprecation-policy/>API非推奨ポリシー</a>に従ってください。</p>
<p>Kubernetesは、公式のKubernetes APIが一度一般提供（GA）に達した場合、通常は<code>v1</code>APIバージョンです、互換性を維持することを強い責任があります。さらに、Kubernetesは <em>beta</em> についても可能な限り互換性を維持し続けます。ベータAPIを採用した場合、その機能が安定版になったあとでも、APIを利用してクラスタを操作し続けることができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Kubernetesは、 <em>alpha</em> APIバージョンについても互換性の維持に注力しますが、いくつかの事情により不可である場合もあります。アルファAPIバージョンを使っている場合、クラスタのアップグレードやAPIが変更された場合に備えて、Kubernetesのリリースノートを確認してください。
</div>
<p>APIバージョンレベルの定義に関する詳細は<a href=/docs/reference/using-api/#api-versioning>APIバージョンのリファレンス</a>を参照してください。</p>
<h2 id=apiの拡張>APIの拡張</h2>
<p>Kubernetes APIは2つの方法で拡張できます。</p>
<ol>
<li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>は、APIサーバーが選択したリソースAPIをどのように提供するかを宣言的に定義します。</li>
<li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>アグリゲーションレイヤー</a>を実装することでKubernetes APIを拡張することもできます。</li>
</ol>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>自分自身で<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>カスタムリソース定義</a>を追加してKubernetes APIを拡張する方法について学んでください。</li>
<li><a href=/docs/concepts/security/controlling-access/>Kubernetes APIのアクセス制御</a>では、クラスターがAPIアクセスの認証と承認を管理する方法を説明しています。</li>
<li><a href=/ja/docs/reference/kubernetes-api/>APIリファレンス</a>を読んで、APIエンドポイント、リソースタイプやサンプルについて学んでください。</li>
<li><a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#readme>APIの変更</a>から、互換性のある変更とは何か, どのようにAPIを変更するかについて学んでください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-110f33530cf761140cb1dab536baef04>3.1.4 - Kubernetesオブジェクトを利用する</h1>
<div class=lead>Kubernetesオブジェクトは、Kubernetes上で永続的なエンティティです。Kubernetesはこれらのエンティティを使い、クラスターの状態を表現します。 Kubernetesオブジェクトモデルと、これらのオブジェクトの利用方法について学びます。</div>
</div>
<div class=td-content>
<h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>3.1.4.1 - Kubernetesオブジェクトを理解する</h1>
<p>このページでは、KubernetesオブジェクトがKubernetes APIでどのように表現されているか、またそれらを<code>.yaml</code>フォーマットでどのように表現するかを説明します。</p>
<h2 id=kubernetes-objects>Kubernetesオブジェクトを理解する</h2>
<p><em>Kubernetesオブジェクト</em> は、Kubernetes上で永続的なエンティティです。Kubernetesはこれらのエンティティを使い、クラスターの状態を表現します。具体的に言うと、下記のような内容が表現できます:</p>
<ul>
<li>どのようなコンテナ化されたアプリケーションが稼働しているか(またそれらはどのノード上で動いているか)</li>
<li>それらのアプリケーションから利用可能なリソース</li>
<li>アプリケーションがどのように振る舞うかのポリシー、例えば再起動、アップグレード、耐障害性ポリシーなど</li>
</ul>
<p>Kubernetesオブジェクトは「意図の記録」です。一度オブジェクトを作成すると、Kubernetesは常にそのオブジェクトが存在し続けるように動きます。オブジェクトを作成することで、Kubernetesに対し効果的にあなたのクラスターのワークロードがこのようになっていて欲しいと伝えているのです。これが、あなたのクラスターの<strong>望ましい状態</strong>です。</p>
<p>Kubernetesオブジェクトを操作するには、作成、変更、または削除に関わらず<a href=/ja/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>を使う必要があるでしょう。例えば<code>kubectl</code>コマンドラインインターフェースを使った場合、このCLIが処理に必要なKubernetes API命令を、あなたに代わり発行します。あなたのプログラムから<a href=/docs/reference/using-api/client-libraries/>クライアントライブラリ</a>を利用し、直接Kubernetes APIを利用することも可能です。</p>
<h3 id=オブジェクトのspec-仕様-とstatus-状態>オブジェクトのspec(仕様)とstatus(状態)</h3>
<p>ほとんどのKubernetesオブジェクトは、オブジェクトの設定を管理する２つの入れ子になったオブジェクトのフィールドを持っています。それはオブジェクト <em><code>spec</code></em> とオブジェクト <em><code>status</code></em> です。<code>spec</code>を持っているオブジェクトに関しては、オブジェクト作成時に<code>spec</code>を設定する必要があり、望ましい状態としてオブジェクトに持たせたい特徴を記述する必要があります。</p>
<p><code>status</code> オブジェクトはオブジェクトの <em>現在の状態</em> を示し、その情報はKubernetesシステムとそのコンポーネントにより提供、更新されます。Kubernetes<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>は、あなたから指定された望ましい状態と現在の状態が一致するよう常にかつ積極的に管理をします。</p>
<p>例えば、KubernetesのDeploymentはクラスター上で稼働するアプリケーションを表現するオブジェクトです。Deploymentを作成するとき、アプリケーションの複製を３つ稼働させるようDeploymentのspecで指定するかもしれません。KubernetesはDeploymentのspecを読み取り、指定されたアプリケーションを３つ起動し、現在の状態がspecに一致するようにします。もしこれらのインスタンスでどれかが落ちた場合(statusが変わる)、Kubernetesはspecと、statusの違いに反応し、修正しようとします。この場合は、落ちたインスタンスの代わりのインスタンスを立ち上げます。</p>
<p>spec、status、metadataに関するさらなる情報は、<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>Kubernetes API Conventions</a>をご確認ください。</p>
<h3 id=kubernetesオブジェクトを記述する>Kubernetesオブジェクトを記述する</h3>
<p>Kubernetesでオブジェクトを作成する場合、オブジェクトの基本的な情報(例えば名前)と共に、望ましい状態を記述したオブジェクトのspecを渡さなければいけません。KubernetesAPIを利用しオブジェクトを作成する場合(直接APIを呼ぶか、<code>kubectl</code>を利用するかに関わらず)、APIリクエストはそれらの情報をJSON形式でリクエストのBody部に含んでいなければなりません。</p>
<p>ここで、KubernetesのDeploymentに必要なフィールドとオブジェクトのspecを記載した<code>.yaml</code>ファイルの例を示します:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-deployment-yaml')" title="Copy application/deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>上に示した<code>.yaml</code>ファイルを利用してDeploymentを作成するには、<code>kubectl</code>コマンドラインインターフェースに含まれている<a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>コマンドに<code>.yaml</code>ファイルを引数に指定し、実行します。ここで例を示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record
</code></pre></div><p>出力結果は、下記に似た形になります:</p>
<pre><code>deployment.apps/nginx-deployment created
</code></pre><h3 id=必須フィールド>必須フィールド</h3>
<p>Kubernetesオブジェクトを<code>.yaml</code>ファイルに記載して作成する場合、下記に示すフィールドに値をセットしておく必要があります:</p>
<ul>
<li><code>apiVersion</code> - どのバージョンのKubernetesAPIを利用してオブジェクトを作成するか</li>
<li><code>kind</code> - どの種類のオブジェクトを作成するか</li>
<li><code>metadata</code> - オブジェクトを一意に特定するための情報、文字列の<code>name</code>、<code>UID</code>、また任意の<code>namespace</code>が該当する</li>
<li><code>spec</code> - オブジェクトの望ましい状態</li>
</ul>
<p><code>spec</code>の正確なフォーマットは、Kubernetesオブジェクトごとに異なり、オブジェクトごとに特有な入れ子のフィールドを持っています。<a href=/docs/reference/generated/kubernetes-api/v1.22/>Kubernetes API リファレンス</a>が、Kubernetesで作成できる全てのオブジェクトに関するspecのフォーマットを探すのに役立ちます。
例えば、<code>Pod</code>オブジェクトに関する<code>spec</code>のフォーマットは<a href=/docs/reference/generated/kubernetes-api/v1.22/#podspec-v1-core>PodSpec v1 core</a>を、また<code>Deployment</code>オブジェクトに関する<code>spec</code>のフォーマットは<a href=/docs/reference/generated/kubernetes-api/v1.22/#deploymentspec-v1-apps>DeploymentSpec v1 apps</a>をご確認ください。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>最も重要、かつ基本的なKubernetesオブジェクト群を学びましょう、例えば、<a href=/ja/docs/concepts/workloads/pods/>Pod</a>です。</li>
<li>Kubernetesの<a href=/ja/docs/concepts/architecture/controller/>コントローラー</a>を学びましょう。</li>
<li><a href=/docs/reference/using-api/>Using the Kubernetes API</a>はこのページでは取り上げていない他のAPIについて説明します。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6751db8ff5409476de8225d17d6c42dd>3.1.4.2 - Kubernetesオブジェクト管理</h1>
<p><code>kubectl</code>コマンドラインツールは、Kubernetesオブジェクトを作成、管理するためにいくつかの異なる方法をサポートしています。
このドキュメントでは、それらの異なるアプローチごとの概要を提供します。
Kubectlを使ったオブジェクト管理の詳細は、<a href=https://kubectl.docs.kubernetes.io>Kubectl book</a>を参照してください。</p>
<h2 id=管理手法>管理手法</h2>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> Kubernetesのオブジェクトは、いずれか一つの手法で管理してください。
同じオブジェクトに対して、複数の手法を組み合わせた場合、未定義の挙動をもたらします。
</div>
<table>
<thead>
<tr>
<th>管理手法</th>
<th>何を対象にするか</th>
<th>推奨環境</th>
<th>サポートライター</th>
<th>学習曲線</th>
</tr>
</thead>
<tbody>
<tr>
<td>命令型コマンド</td>
<td>現行のオブジェクト</td>
<td>開発用プロジェクト</td>
<td>1+</td>
<td>緩やか</td>
</tr>
<tr>
<td>命令型オブジェクト設定</td>
<td>個々のファイル</td>
<td>本番用プロジェクト</td>
<td>1</td>
<td>中程度</td>
</tr>
<tr>
<td>宣言型オブジェクト設定</td>
<td>ファイルのディレクトリ</td>
<td>本番用プロジェクト</td>
<td>1+</td>
<td>急</td>
</tr>
</tbody>
</table>
<h2 id=命令型コマンド>命令型コマンド</h2>
<p>命令型コマンドを使う場合、ユーザーはクラスター内の現行のオブジェクトに対して処理を行います。
ユーザーは<code>kubectl</code>コマンドに処理内容を引数、もしくはフラグで指定します。</p>
<p>これはKubernetesの使い始め、またはクラスターに対して一度限りのタスクを行う際の最も簡単な手法です。
なぜなら、この手法は現行のオブジェクトに対して直接操作ができ、以前の設定履歴は提供されないからです。</p>
<h3 id=例>例</h3>
<p>Deploymentオブジェクトを作成し、nginxコンテナの単一インスタンスを起動します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl run nginx --image nginx
</code></pre></div><p>同じことを異なる構文で行います:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl create deployment nginx --image nginx
</code></pre></div><h3 id=トレードオフ>トレードオフ</h3>
<p>オブジェクト設定手法に対する長所:</p>
<ul>
<li>コマンドは簡潔、簡単に学ぶことができ、そして覚えやすいです</li>
<li>コマンドではクラスタの設定を変えるのに、わずか1ステップしか必要としません</li>
</ul>
<p>オブジェクト設定手法に対する短所:</p>
<ul>
<li>コマンドは変更レビュープロセスと連携しません</li>
<li>コマンドは変更に伴う監査証跡を提供しません</li>
<li>コマンドは現行がどうなっているかという情報を除き、レコードのソースを提供しません</li>
<li>コマンドはオブジェクトを作成するためのテンプレートを提供しません</li>
</ul>
<h2 id=命令型オブジェクト設定>命令型オブジェクト設定</h2>
<p>命令型オブジェクト設定では、kubectlコマンドに処理内容(create、replaceなど)、任意のフラグ、そして最低1つのファイル名を指定します。
指定されたファイルは、YAMLまたはJSON形式でオブジェクトの全ての定義情報を含んでいなければいけません。</p>
<p>オブジェクト定義の詳細は、<a href=/docs/reference/generated/kubernetes-api/v1.22/>APIリファレンス</a>を参照してください。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> 命令型の<code>replace</code>コマンドは、既存の構成情報を新しく提供された設定に置き換え、設定ファイルに無いオブジェクトの全ての変更を削除します。
このアプローチは、構成情報が設定ファイルとは無関係に更新されるリソースタイプでは使用しないでください。
例えば、タイプが<code>LoadBalancer</code>のServiceオブジェクトにおける<code>externalIPs</code>フィールドは、設定ファイルとは無関係に、クラスターによって更新されます。
</div>
<h3 id=例-1>例</h3>
<p>設定ファイルに定義されたオブジェクトを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl create -f nginx.yaml
</code></pre></div><p>設定ファイルに定義されたオブジェクトを削除します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl delete -f nginx.yaml -f redis.yaml
</code></pre></div><p>設定ファイルに定義された情報で、現行の設定を上書き更新します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl replace -f nginx.yaml
</code></pre></div><h3 id=トレードオフ-1>トレードオフ</h3>
<p>命令型コマンド手法に対する長所:</p>
<ul>
<li>オブジェクト設定をGitのような、ソースコード管理システムに格納することができます</li>
<li>オブジェクト設定の変更内容をプッシュする前にレビュー、監査証跡を残すようなプロセスと連携することができます</li>
<li>オブジェクト設定は新しいオブジェクトを作る際のテンプレートを提供します</li>
</ul>
<p>命令型コマンド手法に対する短所:</p>
<ul>
<li>オブジェクト設定ではオブジェクトスキーマの基礎的な理解が必要です</li>
<li>オブジェクト設定ではYAMLファイルを書くという、追加のステップが必要です</li>
</ul>
<p>宣言型オブジェクト設定手法に対する長所:</p>
<ul>
<li>命令型オブジェクト設定の振る舞いは、よりシンプルで簡単に理解ができます</li>
<li>Kubernetesバージョン1.5においては、命令型オブジェクト設定の方がより成熟しています</li>
</ul>
<p>宣言型オブジェクト設定手法に対する短所:</p>
<ul>
<li>命令型オブジェクト設定は各ファイルごとに設定を書くには最も適していますが、ディレクトリには適していません</li>
<li>現行オブジェクトの更新は設定ファイルに対して反映しなければなりません。反映されない場合、次の置き換え時に更新内容が失われてしまいます</li>
</ul>
<h2 id=宣言型オブジェクト設定>宣言型オブジェクト設定</h2>
<p>宣言型オブジェクト設定を利用する場合、ユーザーはローカルに置かれている設定ファイルを操作します。
しかし、ユーザーはファイルに対する操作内容を指定しません。作成、更新、そして削除といった操作はオブジェクトごとに<code>kubectl</code>が検出します。
この仕組みが、異なるオブジェクトごとに異なる操作をディレクトリに対して行うことを可能にしています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 宣言型オブジェクト設定は、他の人が行った変更が設定ファイルにマージされなかったとしても、それらの変更を保持します。
これは、<code>replace</code>API操作のように、全てのオブジェクト設定を置き換えるわけではなく、<code>patch</code>API操作による、変更箇所のみの更新が可能にしています。
</div>
<h3 id=例-2>例</h3>
<p><code>config</code>ディレクトリ配下にある全てのオブジェクト設定ファイルを処理し、作成、または現行オブジェクトへのパッチを行います。
まず、<code>diff</code>でどのような変更が行われるかを確認した後に適用します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl diff -f configs/
kubectl apply -f configs/
</code></pre></div><p>再帰的にディレクトリを処理します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl diff -R -f configs/
kubectl apply -R -f configs/
</code></pre></div><h3 id=トレードオフ-2>トレードオフ</h3>
<p>命令型オブジェクト設定手法に対する長所:</p>
<ul>
<li>現行オブジェクトに直接行われた変更が、それらが設定ファイルに反映されていなかったとしても、保持されます</li>
<li>宣言型オブジェクト設定は、ディレクトリごとの処理をより良くサポートしており、自動的にオブジェクトごとに操作のタイプ(作成、パッチ、削除)を検出します</li>
</ul>
<p>命令型オブジェクト設定手法に対する短所:</p>
<ul>
<li>宣言型オブジェクト設定は、デバッグ、そして想定外の結果が出たときに理解するのが困難です</li>
<li>差分を利用した一部のみの更新は、複雑なマージ、パッチの操作が必要です</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/manage-kubernetes-objects/imperative-command/>命令型コマンドを利用したKubernetesオブジェクトの管理</a></li>
<li><a href=/docs/tasks/manage-kubernetes-objects/imperative-config/>オブジェクト設定(命令型)を利用したKubernetesオブジェクトの管理</a></li>
<li><a href=/docs/tasks/manage-kubernetes-objects/declarative-config/>オブジェクト設定(宣言型)を利用したKubernetesオブジェクトの管理</a></li>
<li><a href=/docs/tasks/manage-kubernetes-objects/kustomization/>Kustomize(宣言型)を利用したKubernetesオブジェクトの管理</a></li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Kubectlコマンドリファレンス</a></li>
<li><a href=https://kubectl.docs.kubernetes.io>Kubectl Book</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/>Kubernetes APIリファレンス</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>3.1.4.3 - オブジェクトの名前とID</h1>
<p>クラスター内の各オブジェクトには、そのタイプのリソースに固有の<a href=#names><em>名前</em></a>があります。すべてのKubernetesオブジェクトには、クラスター全体で一意の<a href=#uids><em>UID</em></a>もあります。</p>
<p>たとえば、同じ<a href=/docs/concepts/overview/working-with-objects/namespaces/>名前空間</a>内に<code>myapp-1234</code>という名前のPodは1つしか含められませんが、<code>myapp-1234</code>という名前の1つのPodと1つのDeploymentを含めることができます。</p>
<p>ユーザーが一意ではない属性を付与するために、Kubernetesは<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベル</a>と<a href=/ja/docs/concepts/overview/working-with-objects/annotations/>アノテーション</a>を提供しています。</p>
<h2 id=names>名前</h2>
<p>クライアントから提供され、リソースURL内のオブジェクトを参照する文字列です。例えば<code>/api/v1/pods/何らかの名前</code>のようになります。</p>
<p>同じ種類のオブジェクトは、同じ名前を同時に持つことはできません。しかし、オブジェクトを削除することで、旧オブジェクトと同じ名前で新しいオブジェクトを作成できます。</p>
<p>次の3つの命名規則がよく使われます。</p>
<h3 id=dns-subdomain-names>DNSサブドメイン名</h3>
<p>ほとんどのリソースタイプには、<a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>で定義されているDNSサブドメイン名として使用できる名前が必要です。
つまり、名前は次のとおりでなければなりません:</p>
<ul>
<li>253文字以内</li>
<li>英小文字、数字、「-」または「.」のみを含む</li>
<li>英数字で始まる</li>
<li>英数字で終わる</li>
</ul>
<h3 id=dns-label-names>DNSラベル名</h3>
<p>一部のリソースタイプでは、<a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>で定義されているDNSラベル標準に従う名前が必要です。
つまり、名前は次のとおりでなければなりません:</p>
<ul>
<li>63文字以内</li>
<li>英小文字、数字または「-」のみを含む</li>
<li>英数字で始まる</li>
<li>英数字で終わる</li>
</ul>
<h3 id=path-segment-names>パスセグメント名</h3>
<p>一部のリソースタイプでは、名前をパスセグメントとして安全にエンコードできるようにする必要があります。
つまり、名前を「.」や「..」にすることはできず、名前に「/」または「%」を含めることはできません。</p>
<p>以下は、<code>nginx-demo</code>という名前のPodのマニフェストの例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 一部のリソースタイプには、名前に追加の制限があります。
</div>
<h2 id=uids>UID</h2>
<p>オブジェクトを一意に識別するためのKubernetesが生成する文字列です。</p>
<p>Kubernetesクラスターの生存期間中にわたって生成された全てのオブジェクトは、異なるUIDを持っています。これは類似のエンティティの、同一時間軸での存在を区別するのが目的です。</p>
<p>Kubernetes UIDは、UUIDのことを指します。
UUIDは、ISO/IEC 9834-8およびITU-T X.667として標準化されています。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>Kubernetesの<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベル</a>についてお読みください。</li>
<li><a href=https://git.k8s.io/community/contributors/design-proposals/architecture/identifiers.md>Kubernetesの識別子と名前</a>デザインドキュメントをご覧ください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1127165f472b7181b9c1d5a0b187d620>3.1.4.4 - Namespace(名前空間)</h1>
<p>Kubernetesは、同一の物理クラスター上で複数の仮想クラスターの動作をサポートします。
この仮想クラスターをNamespaceと呼びます。</p>
<h2 id=複数のnamespaceを使う時>複数のNamespaceを使う時</h2>
<p>Namespaceは、複数のチーム・プロジェクトにまたがる多くのユーザーがいる環境での使用を目的としています。
数人から数十人しかユーザーのいないクラスターに対して、あなたはNamespaceを作成したり、考える必要は全くありません。
Kubernetesが提供するNamespaceの機能が必要となった時に、Namespaceの使用を始めてください。</p>
<p>Namespaceは名前空間のスコープを提供します。リソース名は単一のNamespace内ではユニークである必要がありますが、Namespace全体ではその必要はありません。Namespaceは相互にネストすることはできず、各Kubernetesリソースは1つのNamespaceにのみ存在できます。</p>
<p>Namespaceは、複数のユーザーの間でクラスターリソースを分割する方法です。(これは<a href=/docs/concepts/policy/resource-quotas/>リソースクォータ</a>を介して分割します。)</p>
<p>同じアプリケーションの異なるバージョンなど、少し違うリソースをただ分割するだけに、複数のNamespaceを使う必要はありません。
同一のNamespace内でリソースを区別するためには<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベル</a>を使用してください。</p>
<h2 id=namespaceを利用する>Namespaceを利用する</h2>
<p>Namespaceの作成と削除方法は<a href=/docs/tasks/administer-cluster/namespaces/>Namespaceの管理ガイドドキュメント</a>に記載されています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> プレフィックス<code>kube-</code>を持つNamespaceは、KubernetesシステムのNamespaceとして予約されているため利用は避けてください。
</div>
<h3 id=namespaceの表示>Namespaceの表示</h3>
<p>ユーザーは、以下の方法で単一クラスター内の現在のNamespaceの一覧を表示できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get namespace
</code></pre></div><pre><code>NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-system       Active   1d
kube-public       Active   1d
</code></pre><p>Kubernetesの起動時には4つの初期Namespaceが作成されています。</p>
<ul>
<li><code>default</code> 他にNamespaceを持っていないオブジェクトのためのデフォルトNamespace</li>
<li><code>kube-system</code> Kubernetesシステムによって作成されたオブジェクトのためのNamespace</li>
<li><code>kube-public</code> このNamespaceは自動的に作成され、全てのユーザーから読み取り可能です。(認証されていないユーザーも含みます。)
このNamespaceは、リソースをクラスター全体を通じてパブリックに表示・読み取り可能にするため、ほとんどクラスターによって使用される用途で予約されます。 このNamespaceのパブリックな側面は単なる慣例であり、要件ではありません。</li>
<li><code>kube-node-lease</code> クラスターのスケールに応じたノードハートビートのパフォーマンスを向上させる各ノードに関連したLeaseオブジェクトのためのNamespace。</li>
</ul>
<h3 id=namespaceの設定>Namespaceの設定</h3>
<p>現在のリクエストのNamespaceを設定するには、<code>--namespace</code>フラグを使用します。</p>
<p>例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
kubectl get pods --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</code></pre></div><h3 id=namespace設定の永続化>Namespace設定の永続化</h3>
<p>ユーザーはあるコンテキストのその後のコマンドで使うために、コンテキスト内で永続的にNamespaceを保存できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
<span style=color:#080;font-style:italic># Validate it</span>
kubectl config view --minify | grep namespace:
</code></pre></div><h2 id=namespaceとdns>NamespaceとDNS</h2>
<p>ユーザーが<a href=/ja/docs/concepts/services-networking/service/>Service</a>を作成するとき、Serviceは対応する<a href=/ja/docs/concepts/services-networking/dns-pod-service/>DNSエントリ</a>を作成します。
このエントリは<code>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</code>という形式になり、これはもしあるコンテナがただ<code>&lt;service-name></code>を指定していた場合、Namespace内のローカルのServiceに対して名前解決されます。
これはデベロップメント、ステージング、プロダクションといった複数のNamespaceをまたいで同じ設定を使う時に効果的です。
もしユーザーがNamespaceをまたいでアクセスしたい時、 完全修飾ドメイン名(FQDN)を指定する必要があります。</p>
<h2 id=すべてのオブジェクトはnamespaceに属しているとは限らない>すべてのオブジェクトはNamespaceに属しているとは限らない</h2>
<p>ほとんどのKubernetesリソース(例えば、Pod、Service、ReplicationControllerなど)はいくつかのNamespaceにあります。
しかしNamespaceのリソースそれ自体は単一のNamespace内にありません。
そして<a href=/ja/docs/concepts/architecture/nodes/>Node</a>やPersistentVolumeのような低レベルのリソースはどのNamespaceにも属していません。</p>
<p>どのKubernetesリソースがNamespaceに属しているか、属していないかを見るためには、以下のコマンドで確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Namespaceに属しているもの</span>
kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>

<span style=color:#080;font-style:italic># Namespaceに属していないもの</span>
kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace>新しいNamespaceの作成</a>について学習してください。</li>
<li><a href=/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace>Namespaceの削除</a>について学習してください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f1dec4557fb8ffbac9f11390aaaf9fa4>3.1.4.5 - ラベル(Labels)とセレクター(Selectors)</h1>
<p><em>ラベル(Labels)</em> はPodなどのオブジェクトに割り当てられたキーとバリューのペアです。<br>
ラベルはユーザーに関連した意味のあるオブジェクトの属性を指定するために使われることを目的としています。しかしKubernetesのコアシステムに対して直接的にその意味を暗示するものではありません。<br>
ラベルはオブジェクトのサブセットを選択し、グルーピングするために使うことができます。また、ラベルはオブジェクトの作成時に割り当てられ、その後いつでも追加、修正ができます。<br>
各オブジェクトはキーとバリューのラベルのセットを定義できます。各キーは、単一のオブジェクトに対してはユニークである必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
  }
}
</code></pre></div><p>ラベルは効率的な検索・閲覧を可能にし、UIやCLI上での利用に最適です。
識別用途でない情報は、<a href=/ja/docs/concepts/overview/working-with-objects/annotations/>アノテーション</a>を用いて記録されるべきです。</p>
<h2 id=ラベルを使う動機>ラベルを使う動機</h2>
<p>ラベルは、クライアントにそのマッピング情報を保存することを要求することなく、ユーザー独自の組織構造をシステムオブジェクト上で疎結合にマッピングできます。</p>
<p>サービスデプロイメントとバッチ処理のパイプラインは多くの場合、多次元のエンティティとなります(例: 複数のパーティション、Deployment、リリーストラック、ティアー、ティアー毎のマイクロサービスなど)<br>
管理は分野横断的な操作が必要になることが多く、それによって厳密な階層表現、特にユーザーによるものでなく、インフラストラクチャーによって定義された厳格な階層のカプセル化が破られます。</p>
<p>ラベルの例:</p>
<ul>
<li><code>"release" : "stable"</code>, <code>"release" : "canary"</code></li>
<li><code>"environment" : "dev"</code>, <code>"environment" : "qa"</code>, <code>"environment" : "production"</code></li>
<li><code>"tier" : "frontend"</code>, <code>"tier" : "backend"</code>, <code>"tier" : "cache"</code></li>
<li><code>"partition" : "customerA"</code>, <code>"partition" : "customerB"</code></li>
<li><code>"track" : "daily"</code>, <code>"track" : "weekly"</code></li>
</ul>
<p>これらは単によく使われるラベルの例です。ユーザーは自由に規約を決めることができます。
ラベルのキーは、ある1つのオブジェクトに対してユニークである必要があることは覚えておかなくてはなりません。</p>
<h2 id=syntax-and-character-set>構文と文字セット</h2>
<p>ラベルは、キーとバリューのベアです。正しいラベルキーは2つのセグメントを持ちます。<br>
それは<code>/</code>によって分割されたオプショナルなプレフィックスと名前です。<br>
名前セグメントは必須で、63文字以下である必要があり、文字列の最初と最後は英数字(<code>[a-z0-9A-Z]</code>)で、文字列の間ではこれに加えてダッシュ(<code>-</code>)、アンダースコア(<code>_</code>)、ドット(<code>.</code>)を使うことができます。<br>
プレフィックスはオプションです。もしプレフィックスが指定されていた場合、プレフィックスはDNSサブドメイン形式である必要があり、それはドット(<code>.</code>)で区切られたDNSラベルのセットで、253文字以下である必要があり、最後にスラッシュ(<code>/</code>)が続きます。</p>
<p>もしプレフィックスが省略された場合、ラベルキーはそのユーザーに対してプライベートであると推定されます。<br>
エンドユーザーのオブジェクトにラベルを追加するような自動化されたシステムコンポーネント(例: <code>kube-scheduler</code> <code>kube-controller-manager</code> <code>kube-apiserver</code> <code>kubectl</code>やその他のサードパーティツール)は、プレフィックスを指定しなくてはなりません。</p>
<p><code>kubernetes.io/</code>と<code>k8s.io/</code>プレフィックスは、Kubernetesコアコンポーネントのために予約されています。</p>
<p>正しいラベル値は63文字以下の長さで、空文字か、もしくは開始と終了が英数字(<code>[a-z0-9A-Z]</code>)で、文字列の間がダッシュ(<code>-</code>)、アンダースコア(<code>_</code>)、ドット(<code>.</code>)と英数字である文字列を使うことができます。</p>
<p>例えば、<code>environment: production</code>と<code>app: nginx</code>の2つのラベルを持つPodの設定ファイルは下記のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>label-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb> </span>production<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div><h2 id=label-selectors>ラベルセレクター</h2>
<p><a href=/ja/docs/concepts/overview/working-with-objects/names/>名前とUID</a>とは異なり、ラベルはユニーク性を提供しません。通常、多くのオブジェクトが同じラベルを保持することを想定します。</p>
<p><em>ラベルセレクター</em> を介して、クライアントとユーザーはオブジェクトのセットを指定できます。ラベルセレクターはKubernetesにおいてコアなグルーピング機能となります。</p>
<p>Kubernetes APIは現在2タイプのセレクターをサポートしています。<br>
それは<em>等価ベース(equality-based)</em> と<em>集合ベース(set-based)</em> です。<br>
単一のラベルセレクターは、コンマ区切りの複数の<em>要件(requirements)</em> で構成されています。<br>
複数の要件がある場合、コンマセパレーターは論理積 <em>AND</em>(<code>&&</code>)オペレーターと同様にふるまい、全ての要件を満たす必要があります。</p>
<p>空文字の場合や、指定なしのセレクターに関するセマンティクスは、コンテキストに依存します。
そしてセレクターを使うAPIタイプは、それらのセレクターの妥当性とそれらが示す意味をドキュメントに記載するべきです。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ReplicaSetなど、いくつかのAPIタイプにおいて、2つのインスタンスのラベルセレクターは単一の名前空間において重複してはいけません。重複していると、コントローラがそれらのラベルセレクターがコンフリクトした操作とみなし、どれだけの数のレプリカを稼働させるべきか決めることができなくなります。
</div>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> 等価ベース、集合ベースともに、論理OR (<code>||</code>) オペレーターは存在しません。フィルターステートメントが意図した通りになっていることを確認してください。
</div>
<h3 id=等価ベース-equality-based-の要件-requirement><em>等価ベース(Equality-based)</em> の要件(requirement)</h3>
<p><em>等価ベース(Equality-based)</em> もしくは<em>不等ベース(Inequality-based)</em> の要件は、ラベルキーとラベル値によるフィルタリングを可能にします。<br>
要件に一致したオブジェクトは、指定されたラベルの全てを満たさなくてはいけませんが、それらのオブジェクトはさらに追加のラベルも持つことができます。<br>
そして等価ベースの要件においては、3つの種類のオペレーターの利用が許可されています。<code>=</code>、<code>==</code>、<code>!=</code>となります。<br>
最初の2つのオペレーター(<code>=</code>、<code>==</code>)は<em>等価(Equality)</em> を表現し(この2つは単なる同義語)、最後の1つ(<code>!=</code>)は<em>不等(Inequality)</em> を意味します。<br>
例えば</p>
<pre><code>environment = production
tier != frontend
</code></pre><p>最初の例は、キーが<code>environment</code>で、値が<code>production</code>である全てのリソースを対象にします。<br>
次の例は、キーが<code>tier</code>で、値が<code>frontend</code>とは異なるリソースと、<code>tier</code>という名前のキーを持たない全てのリソースを対象にします。<br>
コンマセパレーター<code>,</code>を使って、<code>production</code>の中から、<code>frontend</code>のものを除外するようにフィルターすることもできます。<br>
<code>environment=production,tier!=frontend</code></p>
<p>等価ベースのラベル要件の1つの使用シナリオとして、PodにおけるNodeの選択要件を指定するケースがあります。<br>
例えば、下記のサンプルPodは、ラベル<code>accelerator=nvidia-tesla-p100</code>をもったNodeを選択します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb>
</span></code></pre></div><h3 id=集合ベース-set-based-の要件-requirement><em>集合ベース(Set-based)</em> の要件(requirement)</h3>
<p><em>集合ベース(Set-based)</em> のラベルの要件は値のセットによってキーをフィルタリングします。<br>
<code>in</code>、<code>notin</code>、<code>exists</code>の3つのオペレーターをサポートしています(キーを特定するのみ)。</p>
<p>例えば:</p>
<pre><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><ul>
<li>最初の例では、キーが<code>environment</code>で、値が<code>production</code>か<code>qa</code>に等しいリソースを全て選択します。</li>
<li>第2の例では、キーが<code>tier</code>で、値が<code>frontend</code>と<code>backend</code>以外のもの、そして<code>tier</code>キーを持たないリソースを全て選択します。</li>
<li>第3の例では、<code>partition</code>というキーをもつラベルを全て選択し、値はチェックしません。</li>
<li>第4の例では、<code>partition</code>というキーを持たないラベルを全て選択し、値はチェックしません。</li>
</ul>
<p>同様に、コンマセパレーターは、<em>AND</em> オペレーターと同様にふるまいます。そのため、<code>partition</code>と<code>environment</code>キーの値がともに<code>qa</code>でないラベルを選択するには、<code>partition,environment notin (qa)</code>と記述することで可能です。<br>
<em>集合ベース</em> のラベルセレクターは、<code>environment=production</code>という記述が<code>environment in (production)</code>と等しいため、一般的な等価形式となります。 <code>!=</code>と<code>notin</code>も同様に等価となります。</p>
<p><em>集合ベース</em> の要件は、<em>等価ベース</em> の要件と混在できます。<br>
例えば:<br>
<code>partition in (customerA, customerB),environment!=qa</code>.</p>
<h2 id=api>API</h2>
<h3 id=listとwatchによるフィルタリング>LISTとWATCHによるフィルタリング</h3>
<p>LISTとWATCHオペレーションは、単一のクエリパラメータを使うことによって返されるオブジェクトのセットをフィルターするためのラベルセレクターを指定できます。<br>
<em>集合ベース</em> と<em>等価ベース</em> のどちらの要件も許可されています(ここでは、URLクエリストリング内で出現します)。</p>
<ul>
<li><em>等価ベース</em> での要件: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li>
<li><em>集合ベース</em> での要件: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li>
</ul>
<p>上記の2つの形式のラベルセレクターはRESTクライアントを介してリストにしたり、もしくは確認するために使われます。<br>
例えば、<code>kubectl</code>によって<code>apiserver</code>をターゲットにし、<em>等価ベース</em> の要件でフィルターすると以下のように書けます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>environment</span><span style=color:#666>=</span>production,tier<span style=color:#666>=</span>frontend
</code></pre></div><p>もしくは、<em>集合ベース</em> の要件を指定すると以下のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b44>&#39;environment in (production),tier in (frontend)&#39;</span>
</code></pre></div><p>すでに言及したように、<em>集合ベース</em> の要件は、<em>等価ベース</em> の要件より表現力があります。<br>
例えば、値に対する <em>OR</em> オペレーターを実装して以下のように書けます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b44>&#39;environment in (production, qa)&#39;</span>
</code></pre></div><p>もしくは、<em>exists</em> オペレーターを介して、否定マッチングによる制限もできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b44>&#39;environment,environment notin (frontend)&#39;</span>
</code></pre></div><h3 id=apiオブジェクトに参照を設定する>APIオブジェクトに参照を設定する</h3>
<p><a href=/ja/docs/concepts/services-networking/service/><code>Service</code></a> と <a href=/docs/concepts/workloads/controllers/replicationcontroller/><code>ReplicationController</code></a>のような、いくつかのKubernetesオブジェクトでは、ラベルセレクターを<a href=/ja/docs/concepts/workloads/pods/>Pod</a>のような他のリソースのセットを指定するのにも使われます。</p>
<h4 id=serviceとreplicationcontroller>ServiceとReplicationController</h4>
<p><code>Service</code>が対象とするPodの集合は、ラベルセレクターによって定義されます。<br>
同様に、<code>ReplicationController</code>が管理するべきPod数についてもラベルセレクターを使って定義されます。</p>
<p>それぞれのオブジェクトに対するラベルセレクターはマップを使って<code>json</code>もしくは<code>yaml</code>形式のファイルで定義され、<em>等価ベース</em> のセレクターのみサポートされています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;selector&#34;</span><span>:</span> {
    <span style=color:green;font-weight:700>&#34;component&#34;</span> : <span style=color:#b44>&#34;redis&#34;</span>,
}
</code></pre></div><p>もしくは</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></code></pre></div><p>このセレクター(それぞれ<code>json</code>または<code>yaml</code>形式)は、<code>component=redis</code>または<code>component in (redis)</code>と等価です。</p>
<h4 id=集合ベース-の要件指定をサポートするリソース><em>集合ベース</em> の要件指定をサポートするリソース</h4>
<p><a href=/docs/concepts/workloads/controllers/job/><code>Job</code></a>や<a href=/ja/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>、<a href=/ja/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a>や<a href=/ja/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>などの比較的新しいリソースは、<em>集合ベース</em> での要件指定もサポートしています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[cache]}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: environment, operator: NotIn, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></code></pre></div><p><code>matchLabels</code>は、<code>{key,value}</code>ペアのマップです。<code>matchLabels</code>内の単一の<code>{key,value}</code>は、<code>matchExpressions</code>の要素と等しく、それは、<code>key</code>フィールドがキー名で、<code>operator</code>が"In"で、<code>values</code>配列は単に"値"を保持します。<br>
<code>matchExpressions</code>はPodセレクター要件のリストです。対応しているオペレーターは<code>In</code>、<code>NotIn</code>、<code>Exists</code>と<code>DoesNotExist</code>です。<code>values</code>のセットは、<code>In</code>と<code>NotIn</code>オペレーターにおいては空文字を許容しません。<br>
<code>matchLabels</code>と<code>matchExpressions</code>の両方によって指定された全ての要件指定はANDで判定されます。つまり要件にマッチするには指定された全ての要件を満たす必要があります。</p>
<h4 id=nodeのセットを選択する>Nodeのセットを選択する</h4>
<p>ラベルを選択するための1つのユースケースはPodがスケジュールできるNodeのセットを制限することです。<br>
さらなる情報に関しては、<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>Node選定</a> のドキュメントを参照してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-93cd7a1d4e1623e2bf01afc49a5af69c>3.1.4.6 - アノテーション(Annotations)</h1>
<p>ユーザーは、識別用途でない任意のメタデータをオブジェクトに割り当てるためにアノテーションを使用できます。ツールやライブラリなどのクライアントは、このメタデータを取得できます。</p>
<h2 id=オブジェクトにメタデータを割り当てる>オブジェクトにメタデータを割り当てる</h2>
<p>ユーザーは、Kubernetesオブジェクトに対してラベルやアノテーションの両方またはどちらか一方を割り当てることができます。
ラベルはオブジェクトの選択や、特定の条件を満たしたオブジェクトの集合を探すことに使うことができます。
それと対照的に、アノテーションはオブジェクトを識別、または選択するために使用されません。
アノテーション内のメタデータは大小様々で、構造化されているものや、そうでないものも設定でき、ラベルでは許可されていない文字も含むことができます。</p>
<p>アノテーションは、ラベルと同様に、キーとバリューのマップとなります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
  <span style=color:green;font-weight:700>&#34;annotations&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
  }
}
</code></pre></div><p>下記は、アノテーション内で記録できる情報の例です。</p>
<ul>
<li>
<p>宣言的設定レイヤによって管理されているフィールド。これらのフィールドをアノテーションとして割り当てることで、クライアントもしくはサーバによってセットされたデフォルト値、オートサイジングやオートスケーリングシステムによってセットされたフィールドや、自動生成のフィールドなどと区別することができます。</p>
</li>
<li>
<p>ビルド、リリースやタイムスタンプのようなイメージの情報、リリースID、gitのブランチ、PR番号、イメージハッシュ、レジストリアドレスなど</p>
</li>
<li>
<p>ロギング、監視、分析用のポインタ、もしくは監査用リポジトリ</p>
</li>
<li>
<p>デバッグ目的で使用されるためのクライアントライブラリやツールの情報。例えば、名前、バージョン、ビルド情報など。</p>
</li>
<li>
<p>他のエコシステムのコンポーネントからの関連オブジェクトのURLなど、ユーザーやツール、システムの出所情報。</p>
</li>
<li>
<p>軽量ロールアウトツールのメタデータ。　例えば設定やチェックポイントなど。</p>
</li>
<li>
<p>情報をどこで確認できるかを示すためのもの。例えばチームのウェブサイト、責任者の電話番号や、ページャー番号やディレクトリエンティティなど。</p>
</li>
<li>
<p>システムのふるまいの変更や、標準ではない機能を利用可能にするために、エンドユーザーがシステムに対して指定する値</p>
</li>
</ul>
<p>アノテーションを使用するかわりに、ユーザーはこのようなタイプの情報を外部のデータベースやディレクトリに保存することもできます。しかし、それによりデプロイ、管理、イントロスペクションを行うためのクライアンライブラリやツールの生成が非常に難しくなります。</p>
<h2 id=構文と文字セット>構文と文字セット</h2>
<p><em>アノテーション</em> はキーとバリューのペアです。有効なアノテーションのキーの形式は2つのセグメントがあります。
プレフィックス(オプション)と名前で、それらはスラッシュ<code>/</code>で区切られます。
名前セグメントは必須で、63文字以下である必要があり、文字列の最初と最後は英数字(<code>[a-z0-9A-Z]</code>)と、文字列の間にダッシュ(<code>-</code>)、アンダースコア(<code>_</code>)、ドット(<code>.</code>)を使うことができます。
プレフィックスはオプションです。もしプレフィックスが指定されていた場合、プレフィックスはDNSサブドメイン形式である必要があり、それはドット(<code>.</code>)で区切られたDNSラベルのセットで、253文字以下である必要があり、最後にスラッシュ(<code>/</code>)が続きます。</p>
<p>もしプレフィックスが除外された場合、アノテーションキーはそのユーザーに対してプライベートであると推定されます。
エンドユーザーのオブジェクトにアノテーションを追加するような自動化されたシステムコンポーネント(例: <code>kube-scheduler</code> <code>kube-controller-manager</code> <code>kube-apiserver</code> <code>kubectl</code>やその他のサードパーティツール)は、プレフィックスを指定しなくてはなりません。</p>
<p><code>kubernetes.io/</code>と<code>k8s.io/</code>プレフィックスは、Kubernetesコアコンポーネントのために予約されています。</p>
<p>たとえば、<code>imageregistry: https://hub.docker.com/</code>というアノテーションが付いたPodの構成ファイルは次のとおりです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>annotations-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imageregistry</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://hub.docker.com/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div><h2 id=次の項目>次の項目</h2>
<p><a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベルとセレクター</a>について学習してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-046c03090d47bc4b89b818dc645c3865>3.1.4.7 - フィールドセレクター(Field Selectors)</h1>
<p><em>フィールドセレクター(Field Selectors)</em> は、1つかそれ以上のリソースフィールドの値を元に<a href=/docs/concepts/overview/working-with-objects/kubernetes-objects>Kubernetesリソースを選択</a>するためのものです。<br>
フィールドセレクタークエリの例は以下の通りです。</p>
<ul>
<li><code>metadata.name=my-service</code></li>
<li><code>metadata.namespace!=default</code></li>
<li><code>status.phase=Pending</code></li>
</ul>
<p>下記の<code>kubectl</code>コマンドは、<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase><code>status.phase</code></a>フィールドの値が<code>Running</code>である全てのPodを選択します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> フィールドセレクターは本質的にリソースの <em>フィルター</em> となります。デフォルトでは、セレクター/フィルターが指定されていない場合は、全てのタイプのリソースが取得されます。これは、<code>kubectl</code>クエリの<code>kubectl get pods</code>と<code>kubectl get pods --field-selector ""</code>が同じであることを意味します。
</div>
<h2 id=サポートされているフィールド>サポートされているフィールド</h2>
<p>サポートされているフィールドセレクターはKubernetesリソースタイプによって異なります。全てのリソースタイプは<code>metadata.name</code>と<code>metadata.namespace</code>フィールドをサポートしています。サポートされていないフィールドセレクターの使用をするとエラーとなります。<br>
例えば以下の通りです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</code></pre></div><pre><code>Error from server (BadRequest): Unable to find &quot;ingresses&quot; that match label selector &quot;&quot;, field selector &quot;foo.bar=baz&quot;: &quot;foo.bar&quot; is not a known field selector: only &quot;metadata.name&quot;, &quot;metadata.namespace&quot;
</code></pre><h2 id=サポートされているオペレーター>サポートされているオペレーター</h2>
<p>ユーザーは、<code>=</code>、<code>==</code>や<code>!=</code>といったオペレーターをフィールドセレクターと組み合わせて使用できます。(<code>=</code>と<code>==</code>は同義)<br>
例として、下記の<code>kubectl</code>コマンドは<code>default</code>ネームスペースに属していない全てのKubernetes Serviceを選択します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get services  --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</code></pre></div><h2 id=連結されたセレクター>連結されたセレクター</h2>
<p><a href=/docs/concepts/overview/working-with-objects/labels>ラベル</a>や他のセレクターと同様に、フィールドセレクターはコンマ区切りのリストとして連結することができます。<br>
下記の<code>kubectl</code>コマンドは、<code>status.phase</code>が<code>Runnning</code>でなく、かつ<code>spec.restartPolicy</code>フィールドが<code>Always</code>に等しいような全てのPodを選択します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</code></pre></div><h2 id=複数のリソースタイプ>複数のリソースタイプ</h2>
<p>ユーザーは複数のリソースタイプにまたがったフィールドセレクターを利用できます。<br>
下記の<code>kubectl</code>コマンドは、<code>default</code>ネームスペースに属していない全てのStatefulSetとServiceを選択します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get statefulsets,services --field-selector metadata.namespace!<span style=color:#666>=</span>default
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5dd62c6a4a481b4cf1ac50f6799eb581>3.1.4.8 - 推奨ラベル(Recommended Labels)</h1>
<p>ユーザーはkubectlやダッシュボード以外に、多くのツールでKubernetesオブジェクトの管理と可視化ができます。共通のラベルセットにより、全てのツールにおいて解釈可能な共通のマナーに沿ってオブジェクトを表現することで、ツールの相互運用を可能にします。</p>
<p>ツール化に対するサポートに加えて、推奨ラベルはクエリ可能な方法でアプリケーションを表現します。</p>
<p>メタデータは、<em>アプリケーション</em> のコンセプトを中心に構成されています。KubernetesはPaaS(Platform as a Service)でなく、アプリケーションの公式な概念を持たず、またそれを強制することはありません。
そのかわり、アプリケーションは、非公式で、メタデータによって表現されています。単一のアプリケーションが有する項目に対する定義は厳密に決められていません。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ラベルには推奨ラベルというものがあります。それらのラベルはアプリケーションの管理を容易にします。しかしコア機能のツール化において必須のものではありません。
</div>
<p>共有されたラベルとアノテーションは、<code>app.kubernetes.io</code>という共通のプレフィックスを持ちます。プレフィックスの無いラベルはユーザーに対してプライベートなものになります。その共有されたプレフィックスは、共有ラベルがユーザーのカスタムラベルに干渉しないことを保証します。</p>
<h2 id=ラベル>ラベル</h2>
<p>これらの推奨ラベルの利点を最大限得るためには、全てのリソースオブジェクトに対して推奨ラベルが適用されるべきです。</p>
<table>
<thead>
<tr>
<th>キー</th>
<th>説明</th>
<th>例</th>
<th>型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>app.kubernetes.io/name</code></td>
<td>アプリケーション名</td>
<td><code>mysql</code></td>
<td>文字列</td>
</tr>
<tr>
<td><code>app.kubernetes.io/instance</code></td>
<td>アプリケーションのインスタンスを特定するための固有名</td>
<td><code>mysql-abcxzy</code></td>
<td>文字列</td>
</tr>
<tr>
<td><code>app.kubernetes.io/version</code></td>
<td>アプリケーションの現在のバージョン (例: セマンティックバージョン、リビジョンのハッシュなど)</td>
<td><code>5.7.21</code></td>
<td>文字列</td>
</tr>
<tr>
<td><code>app.kubernetes.io/component</code></td>
<td>アーキテクチャ内のコンポーネント</td>
<td><code>database</code></td>
<td>文字列</td>
</tr>
<tr>
<td><code>app.kubernetes.io/part-of</code></td>
<td>このアプリケーションによって構成される上位レベルのアプリケーション</td>
<td><code>wordpress</code></td>
<td>文字列</td>
</tr>
<tr>
<td><code>app.kubernetes.io/managed-by</code></td>
<td>このアプリケーションの操作を管理するために使われているツール</td>
<td><code>helm</code></td>
<td>文字列</td>
</tr>
</tbody>
</table>
<p>これらのラベルが実際にどう使われているかを表すために、下記のStatefulSetのオブジェクトを考えましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></code></pre></div><h2 id=アプリケーションとアプリケーションのインスタンス>アプリケーションとアプリケーションのインスタンス</h2>
<p>単一のアプリケーションは、Kubernetesクラスタ内で、いくつかのケースでは同一の名前空間に対して1回または複数回インストールされることがあります。
例えば、WordPressは複数のウェブサイトがあれば、それぞれ別のWordPressが複数回インストールされることがあります。</p>
<p>アプリケーション名と、アプリケーションのインスタンス名はそれぞれ別に記録されます。
例えば、WordPressは<code>app.kubernetes.io/name</code>に<code>wordpress</code>と記述され、インスタンス名に関しては<code>app.kubernetes.io/instance</code>に<code>wordpress-abcxzy</code>と記述されます。この仕組みはアプリケーションと、アプリケーションのインスタンスを特定可能にします。全てのアプリケーションインスタンスは固有の名前を持たなければなりません。</p>
<h2 id=ラベルの使用例>ラベルの使用例</h2>
<p>ここでは、ラベルの異なる使用例を示します。これらの例はそれぞれシステムの複雑さが異なります。</p>
<h3 id=シンプルなステートレスサービス>シンプルなステートレスサービス</h3>
<p><code>Deployment</code>と<code>Service</code>オブジェクトを使って、シンプルなステートレスサービスをデプロイするケースを考えます。下記の2つのスニペットはラベルが最もシンプルな形式においてどのように使われるかをあらわします。</p>
<p>下記の<code>Deployment</code>は、アプリケーションを稼働させるポッドを管理するのに使われます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p>下記の<code>Service</code>は、アプリケーションを公開するために使われます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><h3 id=データベースを使ったウェブアプリケーション>データベースを使ったウェブアプリケーション</h3>
<p>次にもう少し複雑なアプリケーションについて考えます。データベース(MySQL)を使ったウェブアプリケーション(WordPress)で、Helmを使ってインストールします。
下記のスニペットは、このアプリケーションをデプロイするために使うオブジェクト設定の出だし部分です。</p>
<p>はじめに下記の<code>Deployment</code>は、WordPressのために使われます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p>下記の<code>Service</code>は、WordPressを公開するために使われます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p>MySQLは<code>StatefulSet</code>として公開され、MySQL自身と、MySQLが属する親アプリケーションのメタデータを持ちます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p>この<code>Service</code>はMySQLをWordPressアプリケーションの一部として公開します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p>MySQLの<code>StatefulSet</code>と<code>Service</code>により、MySQLとWordPressに関するより広範な情報が含まれていることに気づくでしょう。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2bf36ccd6b3dbeafecf87c39761b07c7>3.2 - クラスターのアーキテクチャ</h1>
</div>
<div class=td-content>
<h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>3.2.1 - ノード</h1>
<p>Kubernetesはコンテナを <em>Node</em> 上で実行されるPodに配置することで、ワークロードを実行します。
ノードはクラスターによりますが、1つのVMまたは物理的なマシンです。
各ノードは<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>やそれを制御する<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>を実行するのに必要なサービスを含んでいます。</p>
<p>通常、1つのクラスターで複数のノードを持ちます。学習用途やリソースの制限がある環境では、1ノードかもしれません。</p>
<p>1つのノード上の<a href=/ja/docs/concepts/overview/components/#node-components>コンポーネント</a>には、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>、<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>、<a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>が含まれます。</p>
<h2 id=management>管理</h2>
<p>ノードを<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>に加えるには2つの方法があります:</p>
<ol>
<li>ノード上のkubeletが、コントロールプレーンに自己登録する。</li>
<li>あなた、もしくは他のユーザーが手動でNodeオブジェクトを追加する。</li>
</ol>
<p>Nodeオブジェクトの作成、もしくはノード上のkubeketによる自己登録の後、コントロールプレーンはNodeオブジェクトが有効かチェックします。例えば、下記のjsonマニフェストでノードを作成してみましょう:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
    }
  }
}
</code></pre></div><p>Kubernetesは内部的にNodeオブジェクトを作成します。 APIサーバーに登録したkubeletがノードの<code>metadata.name</code>フィールドが一致しているか検証します。ノードが有効な場合、つまり必要なサービスがすべて実行されている場合は、Podを実行する資格があります。それ以外の場合、該当ノードが有効になるまではいかなるクラスターの活動に対しても無視されます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>Kubernetesは無効なNodeのオブジェクトを保持し、それが有効になるまで検証を続けます。</p>
<p>ヘルスチェックを止めるためには、あなた、もしくは<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>が明示的にNodeを削除する必要があります。</p>
</div>
<p>Nodeオブジェクトの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<h3 id=self-registration-of-nodes>ノードの自己登録</h3>
<p>kubeletのフラグ <code>--register-node</code>がtrue（デフォルト）のとき、kubeletは自分自身をAPIサーバーに登録しようとします。これはほとんどのディストリビューションで使用されている推奨パターンです。</p>
<p>自己登録については、kubeletは以下のオプションを伴って起動されます:</p>
<ul>
<li><code>--kubeconfig</code> - 自分自身をAPIサーバーに対して認証するための資格情報へのパス</li>
<li><code>--cloud-provider</code> - 自身に関するメタデータを読むために<a class=glossary-tooltip title="An organization that offers a cloud computing platform." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-cloud-provider" target=_blank aria-label=クラウドプロバイダー>クラウドプロバイダー</a>と会話する方法</li>
<li><code>--register-node</code> - 自身をAPIサーバーに自動的に登録</li>
<li><code>--register-with-taints</code> - 与えられた<a class=glossary-tooltip title="A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups." data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taint>taint</a>のリストでノードを登録します (カンマ区切りの <code>&lt;key>=&lt;value>:&lt;effect></code>)。</li>
</ul>
<p><code>register-node</code>がfalseの場合、このオプションは機能しません</p>
<ul>
<li><code>--node-ip</code> - ノードのIPアドレス</li>
<li><code>--node-labels</code> - ノードをクラスターに登録するときに追加する<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=Label>Label</a>（<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction許可プラグイン</a>によって適用されるラベルの制限を参照）</li>
<li><code>--node-status-update-frequency</code> - kubeletがノードのステータスをマスターにPOSTする頻度の指定</li>
</ul>
<p><a href=/docs/reference/access-authn-authz/node/>ノード認証モード</a>および<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction許可プラグイン</a>が有効になっている場合、kubeletは自分自身のノードリソースを作成/変更することのみ許可されています。</p>
<h3 id=manual-node-administration>手動によるノード管理</h3>
<p>クラスター管理者は<a class=glossary-tooltip title="A command line tool for communicating with a Kubernetes API server." data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>を使用してNodeオブジェクトを作成および変更できます。</p>
<p>管理者が手動でNodeオブジェクトを作成したい場合は、kubeletフラグ <code>--register-node = false</code>を設定してください。</p>
<p>管理者は<code>--register-node</code>の設定に関係なくNodeオブジェクトを変更することができます。
例えば、ノードにラベルを設定し、それをunschedulableとしてマークすることが含まれます。</p>
<p>ノード上のラベルは、スケジューリングを制御するためにPod上のノードセレクターと組み合わせて使用できます。
例えば、Podをノードのサブセットでのみ実行する資格があるように制限します。</p>
<p>ノードをunschedulableとしてマークすると、新しいPodがそのノードにスケジュールされるのを防ぎますが、ノード上の既存のPodには影響しません。
これは、ノードの再起動などの前の準備ステップとして役立ちます。</p>
<p>ノードにスケジュール不可能のマークを付けるには、次のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cordon $ノード名
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>によって作成されたPodはノード上のunschedulable属性を考慮しません。
これは、再起動の準備中にアプリケーションからアプリケーションが削除されている場合でも、DaemonSetがマシンに属していることを前提としているためです。
</div>
<h2 id=ノードのステータス>ノードのステータス</h2>
<p>ノードのステータスは以下の情報を含みます:</p>
<ul>
<li><a href=#addresses>Addresses</a></li>
<li><a href=#condition>Conditions</a></li>
<li><a href=#capacity>CapacityとAllocatable</a></li>
<li><a href=#info>Info</a></li>
</ul>
<p><code>kubectl</code>を使用し、ノードのステータスや詳細を確認できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe node &lt;ノード名をここに挿入&gt;
</code></pre></div><p>出力情報の各箇所について、以下で説明します。</p>
<h3 id=addresses>Addresses</h3>
<p>これらのフィールドの使い方は、お使いのクラウドプロバイダーやベアメタルの設定内容によって異なります。</p>
<ul>
<li>HostName: ノードのカーネルによって伝えられたホスト名です。kubeletの<code>--hostname-override</code>パラメーターによって上書きすることができます。</li>
<li>ExternalIP: 通常は、外部にルーティング可能(クラスターの外からアクセス可能)なノードのIPアドレスです。</li>
<li>InternalIP: 通常は、クラスター内でのみルーティング可能なノードのIPアドレスです。</li>
</ul>
<h3 id=condition>Conditions</h3>
<p><code>conditions</code>フィールドは全ての<code>Running</code>なノードのステータスを表します。例として、以下のような状態を含みます:</p>
<table><caption style=display:none>ノードのConditionと、各condition適用時の概要</caption>
<thead>
<tr>
<th>ノードのCondition</th>
<th>概要</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ready</code></td>
<td>ノードの状態が有効でPodを配置可能な場合に<code>True</code>になります。ノードの状態に問題があり、Podが配置できない場合に<code>False</code>になります。ノードコントローラーが、<code>node-monitor-grace-period</code>で設定された時間内(デフォルトでは40秒)に該当ノードと疎通できない場合、<code>Unknown</code>になります。</td>
</tr>
<tr>
<td><code>DiskPressure</code></td>
<td>ノードのディスク容量が圧迫されているときに<code>True</code>になります。圧迫とは、ディスクの空き容量が少ないことを指します。それ以外のときは<code>False</code>です。</td>
</tr>
<tr>
<td><code>MemoryPressure</code></td>
<td>ノードのメモリが圧迫されているときに<code>True</code>になります。圧迫とは、メモリの空き容量が少ないことを指します。それ以外のときは<code>False</code>です。</td>
</tr>
<tr>
<td><code>PIDPressure</code></td>
<td>プロセスが圧迫されているときに<code>True</code>になります。圧迫とは、プロセス数が多すぎることを指します。それ以外のときは<code>False</code>です。</td>
</tr>
<tr>
<td><code>NetworkUnavailable</code></td>
<td>ノードのネットワークが適切に設定されていない場合に<code>True</code>になります。それ以外のときは<code>False</code>です。</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> コマンドラインを使用してcordonされたNodeを表示する場合、Conditionは<code>SchedulingDisabled</code>を含みます。
<code>SchedulingDisabled</code>はKubernetesのAPIにおけるConditionではありません;その代わり、cordonされたノードはUnschedulableとしてマークされます。
</div>
<p>ノードのConditionはJSONオブジェクトで表現されます。例えば、正常なノードの場合は以下のような構造体が表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
  {
    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
  }
]
</code></pre></div><p>Ready conditionが<code>pod-eviction-timeout</code>(<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>に渡された引数)に設定された時間を超えても<code>Unknown</code>や<code>False</code>のままになっている場合、該当ノード上にあるPodはノードコントローラーによって削除がスケジュールされます。デフォルトの退役のタイムアウトの時間は<strong>5分</strong>です。ノードが到達不能ないくつかの場合においては、APIサーバーが該当ノードのkubeletと疎通できない状態になっています。その場合、APIサーバーがkubeletと再び通信を確立するまでの間、Podの削除を行うことはできません。削除がスケジュールされるまでの間、削除対象のPodは切り離されたノードの上で稼働を続けることになります。</p>
<p>ノードコントローラーはクラスター内でPodが停止するのを確認するまでは強制的に削除しないようになりました。到達不能なノード上で動いているPodは<code>Terminating</code>または<code>Unknown</code>のステータスになります。Kubernetesが基盤となるインフラストラクチャーを推定できない場合、クラスター管理者は手動でNodeオブジェクトを削除する必要があります。KubernetesからNodeオブジェクトを削除すると、そのノードで実行されているすべてのPodオブジェクトがAPIサーバーから削除され、それらの名前が解放されます。</p>
<p>ノードのライフサイクルコントローラーがconditionを表した<a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>taint</a>を自動的に生成します。
スケジューラーがPodをノードに割り当てる際、ノードのtaintを考慮します。Podが許容するtaintは例外です。</p>
<p>詳細は<a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/#taint-nodes-by-condition>条件によるtaintの付与</a>を参照してください。</p>
<h3 id=capacity>CapacityとAllocatable</h3>
<p>ノードで利用可能なリソース（CPU、メモリ、およびノードでスケジュールできる最大Pod数）について説明します。</p>
<p>capacityブロック内のフィールドは、ノードが持っているリソースの合計量を示します。
allocatableブロックは、通常のPodによって消費されるノード上のリソースの量を示します。</p>
<p>CapacityとAllocatableについて深く知りたい場合は、ノード上でどのように<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>コンピュートリソースが予約されるか</a>を読みながら学ぶことができます。</p>
<h3 id=info>Info</h3>
<p>カーネルのバージョン、Kubernetesのバージョン（kubeletおよびkube-proxyのバージョン）、（使用されている場合）Dockerのバージョン、OS名など、ノードに関する一般的な情報です。
この情報はノードからkubeletを通じて取得されます。</p>
<h2 id=management>管理</h2>
<p><a href=/ja/docs/concepts/workloads/pods/pod/>Pod</a>や<a href=/ja/docs/concepts/services-networking/service/>Service</a>と違い、ノードは本質的にはKubernetesによって作成されません。GCPのようなクラウドプロバイダーによって外的に作成されるか、VMや物理マシンのプールに存在するものです。そのため、Kubernetesがノードを作成すると、そのノードを表すオブジェクトが作成されます。作成後、Kubernetesはそのノードが有効かどうかを確認します。 たとえば、次の内容からノードを作成しようとしたとします:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
    }
  }
}
</code></pre></div><p>Kubernetesは内部的にNodeオブジェクトを作成し、 <code>metadata.name</code>フィールドに基づくヘルスチェックによってノードを検証します。ノードが有効な場合、つまり必要なサービスがすべて実行されている場合は、Podを実行する資格があります。それ以外の場合、該当ノードが有効になるまではいかなるクラスターの活動に対しても無視されます。
Nodeオブジェクトの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Kubernetesは無効なノードのためにオブジェクトを保存し、それをチェックし続けます。
このプロセスを停止するには、Nodeオブジェクトを明示的に削除する必要があります。
</div>
<p>現在、Kubernetesのノードインターフェースと相互作用する3つのコンポーネントがあります。ノードコントローラー、kubelet、およびkubectlです。</p>
<h3 id=ノードコントローラー>ノードコントローラー</h3>
<p>ノード<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>は、ノードのさまざまな側面を管理するKubernetesのコントロールプレーンコンポーネントです。</p>
<p>ノードコントローラーは、ノードの存続期間中に複数の役割を果たします。1つ目は、ノードが登録されたときにCIDRブロックをノードに割り当てることです（CIDR割り当てがオンになっている場合）。</p>
<p>2つ目は、ノードコントローラーの内部ノードリストをクラウドの利用可能なマシンのリストと一致させることです。
クラウド環境で実行している場合、ノードに異常があると、ノードコントローラーはクラウドプロバイダーにそのNodeのVMがまだ使用可能かどうかを問い合わせます。
使用可能でない場合、ノードコントローラーはノードのリストから該当ノードを削除します。</p>
<p>3つ目は、ノードの状態を監視することです。
ノードが到達不能(例えば、ノードがダウンしているなどので理由で、ノードコントローラーがハートビートの受信を停止した場合)になると、ノードコントローラーは、NodeStatusのNodeReady conditionをConditionUnknownに変更する役割があります。その後も該当ノードが到達不能のままであった場合、Graceful Terminationを使って全てのPodを退役させます。デフォルトのタイムアウトは、ConditionUnknownの報告を開始するまで40秒、その後Podの追い出しを開始するまで5分に設定されています。
ノードコントローラーは、<code>--node-monitor-period</code>に設定された秒数ごとに各ノードの状態をチェックします。</p>
<h4 id=ハートビート>ハートビート</h4>
<p>ハートビートは、Kubernetesノードから送信され、ノードが利用可能か判断するのに役立ちます。
２つのハートビートがあります：<code>NodeStatus</code>の更新と<a href=/docs/reference/generated/kubernetes-api/v1.26#lease-v1-coordination-k8s-io>Lease object</a>です。
各ノードは<code>kube-node-lease</code>という<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>に関連したLeaseオブジェクトを持ちます。
Leaseは軽量なリソースで、クラスターのスケールに応じてノードのハートビートにおけるパフォーマンスを改善します。</p>
<p>kubeletが<code>NodeStatus</code>とLeaseオブジェクトの作成および更新を担当します。</p>
<ul>
<li>kubeletは、ステータスに変化があったり、設定した間隔の間に更新がない時に<code>NodeStatus</code>を更新します。<code>NodeStatus</code>更新のデフォルト間隔は５分です。（到達不能の場合のデフォルトタイムアウトである40秒よりもはるかに長いです）</li>
<li>kubeletは10秒間隔(デフォルトの更新間隔)でLeaseオブジェクトの生成と更新を実施します。Leaseの更新は<code>NodeStatus</code>の更新とは独立されて行われます。Leaseの更新が失敗した場合、kubeletは200ミリ秒から始まり7秒を上限とした指数バックオフでリトライします。</li>
</ul>
<h4 id=信頼性>信頼性</h4>
<p>ほとんどの場合、排除の速度は1秒あたり<code>--node-eviction-rate</code>に設定された数値（デフォルトは秒間0.1）です。つまり、10秒間に1つ以上のPodをノードから追い出すことはありません。</p>
<p>特定のアベイラビリティーゾーン内のノードのステータスが異常になると、ノード排除の挙動が変わります。ノードコントローラーは、ゾーン内のノードの何%が異常（NodeReady条件がConditionUnknownまたはConditionFalseである）であるかを同時に確認します。
異常なノードの割合が少なくとも <code>--healthy-zone-threshold</code>に設定した値を下回る場合（デフォルトは0.55）であれば、退役率は低下します。クラスターが小さい場合（すなわち、 <code>--large-cluster-size-threshold</code>の設定値よりもノード数が少ない場合。デフォルトは50）、退役は停止し、そうでない場合、退役率は秒間で<code>--secondary-node-eviction-rate</code>の設定値（デフォルトは0.01）に減少します。
これらのポリシーがアベイラビリティーゾーンごとに実装されているのは、1つのアベイラビリティーゾーンがマスターから分割される一方、他のアベイラビリティーゾーンは接続されたままになる可能性があるためです。
クラスターが複数のクラウドプロバイダーのアベイラビリティーゾーンにまたがっていない場合、アベイラビリティーゾーンは1つだけです（クラスター全体）。</p>
<p>ノードを複数のアベイラビリティゾーンに分散させる主な理由は、1つのゾーン全体が停止したときにワークロードを正常なゾーンに移動できることです。
したがって、ゾーン内のすべてのノードが異常である場合、ノードコントローラーは通常のレート <code>--node-eviction-rate</code>で退役します。
コーナーケースは、すべてのゾーンが完全にUnhealthyである（すなわち、クラスタ内にHealthyなノードがない）場合です。
このような場合、ノードコントローラーはマスター接続に問題があると見なし、接続が回復するまですべての退役を停止します。</p>
<p>ノードコントローラーは、Podがtaintを許容しない場合、 <code>NoExecute</code>のtaintを持つノード上で実行されているPodを排除する責務もあります。
さらに、ノードコントローラーはノードに到達できない、または準備ができていないなどのノードの問題に対応する<a class=glossary-tooltip title="A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups." data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taint>taint</a>を追加する責務があります。これはスケジューラーが、問題のあるノードにPodを配置しない事を意味しています。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <code>kubectl cordon</code>はノードに'unschedulable'としてマークします。それはロードバランサーのターゲットリストからノードを削除するという
サービスコントローラーの副次的な効果をもたらします。これにより、ロードバランサトラフィックの流入をcordonされたノードから効率的に除去する事ができます。
</div>
<h3 id=ノードのキャパシティ>ノードのキャパシティ</h3>
<p>Nodeオブジェクトはノードのリソースキャパシティ（CPUの数とメモリの量）を監視します。
<a href=#self-registration-of-nodes>自己登録</a>したノードは、Nodeオブジェクトを作成するときにキャパシティを報告します。
<a href=#manual-node-administration>手動によるノード管理</a>を実行している場合は、ノードを追加するときにキャパシティを設定する必要があります。</p>
<p>Kubernetes<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=スケジューラー>スケジューラー</a>は、ノード上のすべてのPodに十分なリソースがあることを確認します。スケジューラーは、ノード上のコンテナが要求するリソースの合計がノードキャパシティ以下であることを確認します。
これは、kubeletによって管理されたすべてのコンテナを含みますが、コンテナランタイムによって直接開始されたコンテナやkubeletの制御外で実行されているプロセスは含みません。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Pod以外のプロセス用にリソースを明示的に予約したい場合は、<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>Systemデーモン用にリソースを予約</a>を参照してください。
</div>
<h2 id=ノードのトポロジー>ノードのトポロジー</h2>
<p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code>
</div>
<code>TopologyManager</code>の<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にすると、
kubeletはリソースの割当を決定する際にトポロジーのヒントを利用できます。
詳細は、<a href=/docs/tasks/administer-cluster/topology-manager/>ノードのトポロジー管理ポリシーを制御する</a>を参照してください。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/overview/components/#node-components>ノードコンポーネント</a>について学習する。</li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#node-v1-core>Node APIオブジェクト</a>について読む。</li>
<li>アーキテクチャ設計文書の<a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>Node</a>という章を読む。</li>
<li><a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>TaintとToleration</a>について読む。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-63e7fdf87ba61eb2586bb8c625c23506>3.2.2 - マスターとノード間の通信</h1>
<p>本ドキュメントでは、KubernetesにおけるMaster(実態はAPIサーバー)およびクラスター間のコミュニケーション経路についてまとめます。
この文書の目的は、信頼できないネットワーク上(またはクラウドプロバイダ上の完全にパブリックなIP上)でクラスタを実行できるように、ユーザーがインストールをカスタマイズしてネットワーク構成を強化できるようにすることです。</p>
<h2 id=クラスターからマスターへの通信>クラスターからマスターへの通信</h2>
<p>クラスターからマスターへのすべての通信経路は、APIサーバーで終端します(他のマスターコンポーネントはどれもリモートサービスを公開するように設計されていません)。
一般的には、1つ以上の形式のクライアント<a href=/docs/reference/access-authn-authz/authentication/>認証</a>が有効になっている状態で、APIサーバーはセキュアなHTTPSポート(443)でリモート接続をlistenするように構成されています。
特に<a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>匿名のリクエスト</a>または<a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>サービスアカウントトークン</a>が許可されている場合は、1つまたは複数の<a href=/docs/reference/access-authn-authz/authorization/>認証</a>を有効にする必要があります。</p>
<p>ノードには、有効なクライアント認証情報を使って安全にAPIサーバーに接続できるように、クラスターのパブリックなルート証明書をプロビジョニングする必要があります。
たとえば、GKEのデフォルト設定では、kubeletに提供されるクライアント認証情報はクライアント証明書の形式です。
kubeletのクライアント証明書を自動プロビジョニングする方法については、<a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLSブートストラッピング</a>を参照してください。</p>
<p>APIサーバーに接続したいPodは、サービスアカウントを利用することで接続を安全にすることができます。そうすることで、Podが作成されたときにKubernetesがパブリックなルート証明書と有効なBearer TokenをPodに自動的に挿入します。</p>
<p><code>kubernetes</code>サービスには(すべてのネームスペースで)、APIサーバー上のHTTPSエンドポイントに(kube-proxy経由で)リダイレクトされる仮想IPアドレスが設定されています。</p>
<p>マスターコンポーネントは、セキュアなポートを介してクラスターAPIサーバーとも通信します。</p>
<p>その結果、クラスター(ノードとそのノードで実行されているPod)からマスターへの接続はデフォルトで保護され、信頼できないネットワークやパブリックネットワークを介して実行できます。</p>
<h2 id=マスターからクラスターへの通信>マスターからクラスターへの通信</h2>
<p>マスター(APIサーバー)からクラスターへの通信には、2つの主要な通信経路があります。
1つ目は、APIサーバーからクラスター内の各ノードで実行されるkubeletプロセスへの通信です。
2つ目は、APIサーバーのプロキシ機能を介した、APIサーバーから任意のノード、Pod、またはサービスへのアクセスです。</p>
<h3 id=apiサーバーからkubeletへの通信>APIサーバーからkubeletへの通信</h3>
<p>APIサーバーからkubeletへの接続は以下の目的で使用されます:</p>
<ul>
<li>Podのログを取得する</li>
<li>実行中のPodに(kubectlを通して)接続する</li>
<li>kubeletのポート転送機能を提供する</li>
</ul>
<p>これらの接続は、kubeletのHTTPSエンドポイントで終了します。
デフォルトでは、APIサーバーはkubeletが提供する証明書を検証しないため、接続は中間者攻撃を受けやすく、<strong>安全でない</strong>信頼できないネットワークやパブリックなネットワークを介して実行されることになります。</p>
<p>この接続を検証するには、<code>--kubelet-certificate-authority</code>フラグを使用して、kubeletが提供する証明書を確認するために使用するルート証明書バンドルをAPIサーバーに提供します。</p>
<p>それができない場合は、信頼できないネットワークやパブリックなネットワークを介した接続を回避するために、必要に応じてAPIサーバーとkubeletの間でSSHトンネリングを使用してください。</p>
<p>最後に、kubeletのAPIを保護するために<a href=/docs/admin/kubelet-authentication-authorization/>kubeletの認証認可</a>を有効にする必要があります。</p>
<h3 id=apiサーバーからノード-pod-サービスへの通信>APIサーバーからノード、Pod、サービスへの通信</h3>
<p>APIサーバーからノード、Pod、またはサービスへの接続はデフォルトで平文のHTTP接続になるため、認証も暗号化もされません。
API URL内のノード、Pod、またはサービス名に<code>https:</code>を付けることで安全なHTTPS接続で実行できますが、HTTPSエンドポイントから提供される証明書を検証したりクライアントの資格情報を提供したりすることはありませんし、暗号化されているという完全性を保証するものでもありません。
これらの接続を信頼できないネットワークや公衆ネットワークを介して実行するのは、現時点において安全ではありません。</p>
<h3 id=sshトンネル>SSHトンネル</h3>
<p>Kubernetesはマスターからクラスターへの通信経路を保護するためにSSHトンネルをサポートしています。
この設定では、APIサーバーはクラスター内の各ノード(ポート22でlistenしているsshサーバーに接続)へのSSHトンネルを開始し、トンネルを介してkubelet、ノード、Pod、またはサービス宛てのすべてのトラフィックを渡します。
このトンネルにより、ノードが実行されているネットワークの外部にトラフィックが公開されないようにします。</p>
<p>SSHトンネルは現在非推奨なので、自分がしていることが分からない限り、使用しないでください。この通信チャネルに代わるものが設計されています。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ca8819042a505291540e831283da66df>3.2.3 - コントローラー</h1>
<p>ロボット工学やオートメーションの分野において、 <em>制御ループ</em> とは、あるシステムの状態を制御する終了状態のないループのことです。</p>
<p>ここでは、制御ループの一例として、部屋の中にあるサーモスタットを挙げます。</p>
<p>あなたが温度を設定すると、それはサーモスタットに <em>目的の状態(desired state)</em> を伝えることになります。実際の部屋の温度は <em>現在の状態</em> です。サーモスタットは、装置をオンまたはオフにすることによって、現在の状態を目的の状態に近づけるように動作します。</p>
Kubernetesにおいて、コントローラーは<a class=glossary-tooltip title=コンテナ化されたアプリケーションを実行する、ノードと呼ばれるワーカーマシンの集合です。すべてのクラスターには少なくとも1つのワーカーノードがあります。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-cluster" target=_blank aria-label=クラスター>クラスター</a>の状態を監視し、必要に応じて変更を加えたり要求したりする制御ループです。それぞれのコントローラーは現在のクラスターの状態を望ましい状態に近づけるように動作します。
<h2 id=コントローラーパターン>コントローラーパターン</h2>
<p>コントローラーは少なくとも1種類のKubernetesのリソースを監視します。これらの<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>オブジェクト</a>には目的の状態を表すspecフィールドがあります。リソースのコントローラーは、現在の状態を目的の状態に近づける責務を持ちます。</p>
<p>コントローラーは自分自身でアクションを実行する場合もありますが、Kubernetesではコントローラーが<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>に意味のある副作用を持つメッセージを送信することが一般的です。以下では、このような例を見ていきます。</p>
<h3 id=apiサーバー経由でコントロールする>APIサーバー経由でコントロールする</h3>
<p><a class=glossary-tooltip title="A finite or batch task that runs to completion." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>コントローラーはKubernetesのビルトインのコントローラーの一例です。ビルトインのコントローラーは、クラスターのAPIサーバーとやりとりをして状態を管理します。</p>
<p>Jobは、1つ以上の<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>を起動して、タスクを実行した後に停止する、Kubernetesのリソースです。</p>
<p>(1度<a href=/ja/docs/concepts/scheduling-eviction/>スケジュール</a>されると、Podオブジェクトはkubeletに対する目的の状態の一部になります。)</p>
<p>Jobコントローラーが新しいタスクを見つけると、その処理が完了するように、クラスター上のどこかで、一連のNode上のkubeletが正しい数のPodを実行することを保証します。ただし、Jobコントローラーは、自分自身でPodやコンテナを実行することはありません。代わりに、APIサーバーに対してPodの作成や削除を依頼します。<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>上の他のコンポーネントが(スケジュールして実行するべき新しいPodが存在するという)新しい情報を基に動作することによって、最終的に目的の処理が完了します。</p>
<p>新しいJobが作成されたとき、目的の状態は、そのJobが完了することです。JobコントローラーはそのJobに対する現在の状態を目的の状態に近づけるようにします。つまり、そのJobが行ってほしい処理を実行するPodを作成し、Jobが完了に近づくようにします。</p>
<p>コントローラーは、コントローラーを設定するオブジェクトも更新します。たとえば、あるJobが完了した場合、Jobコントローラーは、Jobオブジェクトに<code>Finished</code>というマークを付けます。</p>
<p>(これは、部屋が設定温度になったことを示すために、サーモスタットがランプを消灯するのに少し似ています。)</p>
<h3 id=直接的なコントロール>直接的なコントロール</h3>
<p>Jobとは対照的に、クラスターの外部に変更を加える必要があるコントローラーもあります。</p>
<p>たとえば、クラスターに十分な数の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>が存在することを保証する制御ループの場合、そのコントローラーは、必要に応じて新しいNodeをセットアップするために、現在のクラスターの外部とやりとりをする必要があります。</p>
<p>外部の状態とやりとりをするコントローラーは、目的の状態をAPIサーバーから取得した後、外部のシステムと直接通信し、現在の状態を目的の状態に近づけます。</p>
<p>(クラスター内のノードを水平にスケールさせる<a href=https://github.com/kubernetes/autoscaler/>コントローラー</a>が実際に存在します。)</p>
<p>ここで重要な点は、コントローラーが目的の状態を実現するために変更を加えてから、現在の状態をクラスターのAPIサーバーに報告することです。他の制御ループは、その報告されたデータを監視し、独自のアクションを実行できます。</p>
<p>サーモスタットの例では、部屋が非常に寒い場合、別のコントローラーが霜防止ヒーターをオンにすることもあります。Kubernetesクラスターを使用すると、コントロールプレーンは、<a href=/ja/docs/concepts/extend-kubernetes/>Kubernetesを拡張して</a>実装することにより、IPアドレス管理ツールやストレージサービス、クラウドプロバイダーAPI、およびその他のサービスと間接的に連携します。</p>
<h2 id=desired-vs-current>目的の状態 vs 現在の状態</h2>
<p>Kubernetesはシステムに対してクラウドネイティブな見方をするため、常に変化し続けるような状態を扱えるように設計されています。</p>
<p>処理を実行したり、制御ループが故障を自動的に修正したりしているどの時点でも、クラスターは変化中である可能性があります。つまり、クラスターは決して安定した状態にならない可能性があるということです。</p>
<p>コントローラーがクラスターのために実行されていて、有用な変更が行われるのであれば、全体的な状態が安定しているかどうかは問題にはなりません。</p>
<h2 id=設計>設計</h2>
<p>設計理念として、Kubernetesは多数のコントローラーを使用しており、各コントローラーはクラスターの状態の特定の側面をそれぞれ管理しています。最もよくあるパターンは、特定の制御ループ(コントローラー)が目的の状態として1種類のリソースを使用し、目的の状態を実現することを管理するために別の種類のリソースを用意するというものです。たとえば、Jobのコントローラーは、Jobオブジェクト(新しい処理を見つけるため)およびPodオブジェクト(Jobを実行し、処理が完了したか確認するため)を監視します。この場合、なにか別のものがJobを作成し、JobコントローラーはPodを作成します。</p>
<p>相互にリンクされた単一のモノリシックな制御ループよりは、複数の単純なコントローラーが存在する方が役に立ちます。コントローラーは故障することがあるため、Kubernetesは故障を許容するように設計されています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>同じ種類のオブジェクトを作成または更新するコントローラーが、複数存在する場合があります。実際には、Kubernetesコントローラーは、自分が制御するリソースに関連するリソースにのみ注意を払うように作られています。</p>
<p>たとえば、DeploymentとJobがありますが、これらは両方ともPodを作成するものです。しかし、JobコントローラーはDeploymentが作成したPodを削除することはありません。各コントローラーが2つのPodを区別できる情報(<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=ラベル>ラベル</a>)が存在するためです。</p>
</div>
<h2 id=running-controllers>コントローラーを実行する方法</h2>
<p>Kubernetesには、<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>内部で動作する一組のビルトインのコントローラーが用意されています。これらビルトインのコントローラーは、コアとなる重要な振る舞いを提供します。</p>
<p>DeploymentコントローラーとJobコントローラーは、Kubernetes自体の一部として同梱されているコントローラーの例です(それゆえ「ビルトイン」のコントローラーと呼ばれます)。Kubernetesは回復性のあるコントロールプレーンを実行できるようにしているため、ビルトインのコントローラーの一部が故障しても、コントロールプレーンの別の部分が作業を引き継いでくれます。</p>
<p>Kubernetesを拡張するためにコントロールプレーンの外で動作するコントローラーもあります。もし望むなら、新しいコントローラーを自分で書くこともできます。自作のコントローラーをPodセットとして動作させたり、Kubernetesの外部で動作させることもできます。どのような動作方法が最も適しているかは、そのコントローラーがどのようなことを行うのかに依存します。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/#kubernetes-control-plane>Kubernetesコントロールプレーン</a>について読む</li>
<li>基本的な<a href=/ja/docs/concepts/#kubernetes-objects>Kubernetesオブジェクト</a>について学ぶ</li>
<li><a href=/ja/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>について学ぶ</li>
<li>自分でコントローラーを書きたい場合は、「Kubernetesを拡張する」の<a href=/ja/docs/concepts/extend-kubernetes/extend-cluster/#extension-patterns>エクステンションパターン</a>を読んでください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>3.2.4 - クラウドコントローラーマネージャー</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p>クラウドインフラストラクチャー技術により、パブリック、プライベート、ハイブリッドクラウド上でKubernetesを動かすことができます。Kubernetesは、コンポーネント間の密なつながりが不要な自動化されたAPI駆動インフラストラクチャーを信条としています。</p>
<p><p>cloud-controller-managerは クラウド特有の制御ロジックを組み込むKubernetesの<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="control plane">control plane</a>コンポーネントです。クラウドコントロールマネージャーは、クラスターをクラウドプロバイダーAPIをリンクし、クラスタのみで相互作用するコンポーネントからクラウドプラットフォームで相互作用するコンポーネントを分離します。</p></p>
<p>Kubernetesと下のクラウドインフラストラクチャー間の相互運用ロジックを分離することで、cloud-controller-managerコンポーネントはクラウドプロバイダを主なKubernetesプロジェクトと比較し異なるペースで機能をリリース可能にします。</p>
<p>cloud-controller-managerは、プラグイン機構を用い、異なるクラウドプロバイダーに対してそれぞれのプラットフォームとKubernetesの結合を可能にする構成になっています。</p>
<h2 id=設計>設計</h2>
<p><img src=/images/docs/components-of-kubernetes.svg alt=Kubernetesのコンポーネント></p>
<p>クラウドコントローラーマネージャーは、複製されたプロセスの集合としてコントロールプレーンで実行されます。（通常、Pod内のコンテナとなります）各cloud-controller-managerは、シングルプロセスで複数の<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a>を実装します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> コントロールプレーンの一部ではなく、Kubernetesの<a class=glossary-tooltip title="Resources that extend the functionality of Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=addon>addon</a>としてクラウドコントローラーマネージャーを実行することもできます。
</div>
<h2 id=functions-of-the-ccm>クラウドコントローラーマネージャーの機能</h2>
<p>クラウドコントローラーマネージャーのコントローラーは以下を含んでいます。</p>
<h4 id=ノードコントローラー>ノードコントローラー</h4>
<p>ノードコントローラーは、クラウドインフラストラクチャーで新しいサーバーが作成された際に、<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>オブジェクトを作成する責務を持ちます。ノードコントローラーは、クラウドプロバイダーのテナント内で動作しているホストの情報を取得します。ノードコントローラーは下記に示す機能を実行します:</p>
<ol>
<li>Nodeオブジェクトを、コントローラーがクラウドプロバイダーAPIを通じて見つけた各サーバーで初期化する</li>
<li>Nodeオブジェクトに、ノードがデプロイされているリージョンや利用可能なリソース（CPU、メモリなど）のようなクラウド特有な情報を注釈付けやラベル付けをする</li>
<li>ノードのホスト名とネットワークアドレスを取得する</li>
<li>ノードの正常性を検証する。ノードが応答しなくなった場合、クラウドプロバイダーのAPIを利用しサーバーがdeactivated / deleted / terminatedであるかを確認する。クラウドからノードが削除されていた場合、KubernetesクラスターからNodeオブジェクトを削除する</li>
</ol>
<p>いくつかのクラウドプロバイダーは、これをノードコントローラーと個別のノードライフサイクルコントローラーに分けて実装しています。</p>
<h4 id=ルートコントローラー>ルートコントローラー</h4>
<p>ルートコントローラーは、クラスタ内の異なるノード上で稼働しているコンテナが相互に通信できるように、クラウド内のルートを適切に設定する責務を持ちます。</p>
<p>クラウドプロバイダーによっては、ルートコントローラーはPodネットワークのIPアドレスのブロックを割り当てることもあります。</p>
<h4 id=サービスコントローラー>サービスコントローラー</h4>
<p><a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Services>Services</a>は、マネージドロードバランサー、IPアドレスネットワークパケットフィルタや対象のヘルスチェックのようなクラウドインフラストラクチャーコンポーネントのインテグレーションを行います。サービスコントローラーは、ロードバランサーや他のインフラストラクチャーコンポーネントを必要とするServiceリソースを宣言する際にそれらのコンポーネントを設定するため、クラウドプロバイダーのAPIと対話します。</p>
<h2 id=認可>認可</h2>
<p>このセクションでは、クラウドコントローラーマネージャーが操作を行うために様々なAPIオブジェクトに必要な権限を分類します。</p>
<h3 id=authorization-node-controller>ノードコントローラー</h3>
<p>ノードコントローラーはNodeオブジェクトのみに対して働きます。Nodeオブジェクトに対して、readとmodifyの全権限が必要です。</p>
<p><code>v1/Node</code>:</p>
<ul>
<li>Get</li>
<li>List</li>
<li>Create</li>
<li>Update</li>
<li>Patch</li>
<li>Watch</li>
<li>Delete</li>
</ul>
<h3 id=authorization-route-controller>ルートコントローラー </h3>
<p>ルートコントローラーは、Nodeオブジェクトの作成を待ち受け、ルートを適切に設定します。Nodeオブジェクトについて、get権限が必要です。</p>
<p><code>v1/Node</code>:</p>
<ul>
<li>Get</li>
</ul>
<h3 id=authorization-service-controller>サービスコントローラー</h3>
<p>サービスコントローラーは、Serviceオブジェクトの作成、更新、削除イベントを待ち受け、その後、サービスのEndpointを適切に設定します。</p>
<p>サービスにアクセスするため、list、watchの権限が必要です。サービスを更新するため、patch、updateの権限が必要です。</p>
<p>サービスのEndpointリソースを設定するため、create、list、get、watchそしてupdateの権限が必要です。</p>
<p><code>v1/Service</code>:</p>
<ul>
<li>List</li>
<li>Get</li>
<li>Watch</li>
<li>Patch</li>
<li>Update</li>
</ul>
<h3 id=authorization-miscellaneous>その他</h3>
<p>クラウドコントローラーマネージャーのコア機能の実装は、Eventオブジェクトのcreate権限と、セキュアな処理を保証するため、ServiceAccountのcreate権限が必要です。</p>
<p><code>v1/Event</code>:</p>
<ul>
<li>Create</li>
<li>Patch</li>
<li>Update</li>
</ul>
<p><code>v1/ServiceAccount</code>:</p>
<ul>
<li>Create</li>
</ul>
<p>クラウドコントローラーマネージャーの<a class=glossary-tooltip title="Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API." data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a> ClusterRoleはこのようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></code></pre></div><h2 id=次の項目>次の項目</h2>
<p><a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>Cloud Controller Manager Administration</a>
はクラウドコントラーマネージャーの実行と管理を説明しています。</p>
<p>どのようにあなた自身のクラウドコントローラーマネージャーが実装されるのか、もしくは既存プロジェクトの拡張について知りたいですか？</p>
<p>クラウドコントローラーマネージャーは、いかなるクラウドからもプラグインとしての実装を許可するためにGoインターフェースを使います。具体的には、<a href=https://github.com/kubernetes/cloud-provider>kubernetes/cloud-provider</a>の <a href=https://github.com/kubernetes/cloud-provider/blob/release-1.21/cloud.go#L42-L69><code>cloud.go</code></a>で定義されている<code>CloudProvider</code>を使います。</p>
<p>本ドキュメントでハイライトした共有コントローラー（Node、Route、Service）の実装と共有クラウドプロバイダーインターフェースに沿ったいくつかの足場は、Kubernetesコアの一部です。クラウドプロバイダに特化した実装は、Kubernetesのコアの外部として、また<code>CloudProvider</code>インターフェースを実装します。</p>
<p>プラグイン開発ついての詳細な情報は、<a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Developing Cloud Controller Manager</a>を見てください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>3.3 - コンテナ</h1>
<div class=lead>アプリケーションとランタイムの依存関係を一緒にパッケージ化するための技術</div>
<p>実行するそれぞれのコンテナは繰り返し使用可能です。依存関係を含めて標準化されており、どこで実行しても同じ動作が得られることを意味しています。</p>
<p>コンテナは基盤となるホストインフラからアプリケーションを切り離します。これにより、さまざまなクラウドやOS環境下でのデプロイが容易になります。</p>
<h2 id=container-images>コンテナイメージ</h2>
<p><a href=/docs/concepts/containers/images/>コンテナイメージ</a>はすぐに実行可能なソフトウェアパッケージで、アプリケーションの実行に必要なものをすべて含んています。コードと必要なランタイム、アプリケーションとシステムのライブラリ、そして必須な設定項目のデフォルト値を含みます。</p>
<p>設計上、コンテナは不変で、既に実行中のコンテナのコードを変更することはできません。コンテナ化されたアプリケーションがあり変更したい場合は、変更を含んだ新しいイメージをビルドし、コンテナを再作成して、更新されたイメージから起動する必要があります。</p>
<h2 id=コンテナランタイム>コンテナランタイム</h2>
<p>コンテナランタイムは、コンテナの実行を担当するソフトウェアです。</p>
<p>Kubernetesは次の複数のコンテナランタイムをサポートします。
<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>、<a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>、<a class=glossary-tooltip title="A lightweight container runtime specifically for Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>、
および全ての
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>
実装です。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/concepts/containers/images/>コンテナイメージ</a>についてお読みください。</li>
<li><a href=/ja/docs/concepts/workloads/pods/>Pod</a>についてお読みください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8fda96dc403731ceba5e0ddd0ab3ad15>3.3.1 - コンテナの概要</h1>
<p>コンテナは、アプリケーションの(コンパイルされた)コードと、実行時に必要な依存関係をパッケージ化するための技術です。実行する各コンテナは再現性があります。依存関係を含めることによる標準化は、どこで実行しても同じ動作が得られることを意味します。</p>
<p>コンテナは、基礎となるホストインフラストラクチャからアプリケーションを切り離します。これにより、さまざまなクラウド環境やOS環境でのデプロイが容易になります。</p>
<h2 id=container-images>コンテナイメージ</h2>
<p><a href=/docs/concepts/containers/images/>コンテナイメージ</a>は、アプリケーションを実行するために必要なすべてのものを含んだ、すぐに実行可能なソフトウェアパッケージです。コードとそれが必要とする任意のランタイム、アプリケーションとシステムのライブラリ、および必須の設定のデフォルト値が含まれています。</p>
<p>設計上、コンテナは不変であるため、すでに実行中のコンテナのコードを変更することはできません。コンテナ化されたアプリケーションがあり、変更を加えたい場合は、変更を含む新しいコンテナをビルドし、コンテナを再作成して更新されたイメージから起動する必要があります。</p>
<h2 id=container-runtimes>コンテナランタイム</h2>
<p>コンテナランタイムは、コンテナの実行を担当するソフトウェアです。</p>
<p>Kubernetesは次の複数のコンテナランタイムをサポートします。
<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>、<a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>、<a class=glossary-tooltip title="A lightweight container runtime specifically for Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>、
および全ての
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>
実装です。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/concepts/containers/images/>コンテナイメージ</a>についてお読みください。</li>
<li><a href=/ja/docs/concepts/workloads/pods/>Pod</a>についてお読みください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-16042b4652ad19e565c7263824029a43>3.3.2 - イメージ</h1>
<p>コンテナイメージはアプリケーションと依存関係のあるすべてソフトウェアをカプセル化したバイナリデータを表します。コンテナイメージはスタンドアロンで実行可能なソフトウェアをひとつにまとめ、ランタイム環境に関する想定を明確に定義しています。</p>
<p>アプリケーションのコンテナイメージを作成し、一般的には<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>で参照する前にレジストリへPushします。</p>
<p>このページではコンテナイメージの概要を説明します。</p>
<h2 id=イメージの名称>イメージの名称</h2>
<p>コンテナイメージは、<code>pause</code>、<code>example/mycontainer</code>、または<code>kube-apiserver</code>のような名前が通常つけられます。
イメージにはレジストリのホスト名も含めることができ（例：<code>fictional.registry.example/imagename</code>）、さらにポート番号も含めることが可能です（例：<code>fictional.registry.example:10443/imagename</code>）。</p>
<p>レジストリのホスト名を指定しない場合は、KubernetesはDockerパブリックレジストリを意味していると見なします。</p>
<p>イメージ名の後に、<em>タグ</em> を追加することができます（<code>docker</code>や<code>podman</code>のようなコマンドを利用した場合と同様）。
タグによって同じイメージの異なるバージョンを識別できます。</p>
<p>イメージタグは大文字と小文字、数値、アンダースコア(<code>_</code>)、ピリオド(<code>.</code>)とマイナス(<code>-</code>)で構成されます。
イメージタグでは区切り記号(<code>_</code>、<code>-</code>、<code>.</code>)を指定できる追加ルールがあります。
タグを指定しない場合は、Kubernetesは<code>latest</code>タグを指定したと見なします。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <p>本番環境でコンテナをデプロイする場合は、<code>latest</code>タグの使用を避けるべきです。
実行中のイメージのバージョンを追跡するのが難しく、機能しているバージョンへのロールバックがより困難になるためです。</p>
<p>かわりに、<code>v1.42.0</code>のような特定できるタグを指定してください。</p>
</div>
<h2 id=イメージの更新>イメージの更新</h2>
<p>デフォルトのpull policyでは、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>はイメージを既に取得済みの場合、イメージのPullをスキップさせる<code>IfNotPresent</code>が設定されています。
常にPullを強制させたい場合は、次のいずれかの方法で実行できます。</p>
<ul>
<li>コンテナの<code>imagePullPolicy</code>に<code>Always</code>を設定する</li>
<li><code>imagePullPolicy</code>を省略し、使用するイメージに<code>:latest</code>タグを使用する</li>
<li><code>imagePullPolicy</code>と使用するイメージのタグを省略する</li>
<li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a>アドミッションコントローラーを有効にする</li>
</ul>
<p><code>imagePullPolicy</code>が値なしで定義された場合、この場合も<code>Always</code>が設定されます。</p>
<h2 id=イメージインデックスを使ったマルチアーキテクチャイメージ>イメージインデックスを使ったマルチアーキテクチャイメージ</h2>
<p>コンテナレジストリはバイナリイメージの提供だけでなく、<a href=https://github.com/opencontainers/image-spec/blob/master/image-index.md>コンテナイメージインデックス</a>も提供する事ができます。イメージインデックスはコンテナのアーキテクチャ固有バージョンに関する複数の<a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>イメージマニフェスト</a>を指すことができます。イメージインデックスの目的はイメージの名前(例:<code>pause</code>、<code>example/mycontainer</code>、<code>kube-apiserver</code>)をもたせ、様々なシステムが使用しているマシンアーキテクチャにあう適切なバイナリイメージを取得できることです。</p>
<p>Kubernetes自身は、通常コンテナイメージに<code>-$(ARCH)</code>のサフィックスを持つ名前をつけます。下位互換の為にサフィックス付きの古い仕様のイメージを生成してください。その目的は、<code>pause</code>のようなすべてのアーキテクチャのマニフェストを持つイメージと、サフィックスのあるイメージをハードコードしていた可能性のある古い仕様の設定やYAMLファイルと下位互換がある<code>pause-amd64</code>のようなイメージを生成することです。</p>
<h2 id=プライベートレジストリを使用する方法>プライベートレジストリを使用する方法</h2>
<p>プライベートレジストリではイメージを読み込む為にキーが必要になる場合があります。<br>
認証情報はいくつかの方法で提供できます。</p>
<ul>
<li>プライベートレジストリへの認証をNodeに設定する
<ul>
<li>すべてのPodがプライベートレジストリを読み取ることができる</li>
<li>クラスター管理者によるNodeの設定が必要</li>
</ul>
</li>
<li>事前にPullされたイメージ
<ul>
<li>すべてのPodがNode上にキャッシュされたイメージを利用できる</li>
<li>セットアップするためにはすべてのNodeに対するrootアクセスが必要</li>
</ul>
</li>
<li>PodでImagePullSecretsを指定する
<ul>
<li>キーを提供したPodのみがプライベートレジストリへアクセスできる</li>
</ul>
</li>
<li>ベンダー固有またはローカルエクステンション
<ul>
<li>カスタムNode構成を使っている場合、あなた(または、あなたのクラウドプロバイダー)はコンテナレジストリへの認証の仕組みを組み込むことができる</li>
</ul>
</li>
</ul>
<p>これらのオプションについて、以下で詳しく説明します。</p>
<h3 id=プライベートレジストリへの認証をnodeに設定する>プライベートレジストリへの認証をNodeに設定する</h3>
<p>Node上でDockerを実行している場合、プライベートコンテナレジストリへの認証をDockerコンテナランタイムに設定できます。</p>
<p>Node構成を制御できる場合は、この方法が適しています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> KubernetesはDocker構成の<code>auths</code>と<code>HttpHeaders</code>セクションのみをサポートしています。
Docker認証情報ヘルパー(<code>credHelpers</code>または<code>credsStore</code>)はサポートされていません。
</div>
<p>Dockerは、<code>$HOME/.dockercfg</code>または<code>$HOME/.docker/config.json</code>ファイルの中に、プライベートレジストリのキーを保持します。
下記リストの検索パスに同じファイルを配置した場合、kubeletはイメージをPullする時に認証情報プロバイダーとして利用します。</p>
<ul>
<li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li>
<li><code>{cwd of kubelet}/config.json</code></li>
<li><code>${HOME}/.docker/config.json</code></li>
<li><code>/.docker/config.json</code></li>
<li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li>
<li><code>{cwd of kubelet}/.dockercfg</code></li>
<li><code>${HOME}/.dockercfg</code></li>
<li><code>/.dockercfg</code></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> kubeletプロセスの環境では、明示的に<code>HOME=/root</code>を設定する必要がある場合があります。
</div>
<p>以下は、プライベートレジストリを使用する為にNodeを構成する推奨の手順です。この例では、デスクトップ/ノートPC上で実行します。</p>
<ol>
<li>使用したい認証情報のセット毎に <code>docker login [server]</code>を実行する。これであなたのPC上の<code>$HOME/.docker/config.json</code>が更新される</li>
<li>使用したい認証情報が含まれているかを確認するため、エディターで<code>$HOME/.docker/config.json</code>を見る</li>
<li>Nodeの一覧を取得 例:
<ul>
<li>名称が必要な場合: <code>nodes=$( kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}' )</code></li>
<li>IPアドレスを取得したい場合: <code>nodes=$( kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}' )</code></li>
</ul>
</li>
<li>ローカルの<code>.docker/config.json</code>を上記の検索パスのいずれかにコピーする
<ul>
<li>例えば、これでテストを実施する: <code>for n in $nodes; do scp ~/.docker/config.json root@"$n":/var/lib/kubelet/config.json; done</code></li>
</ul>
</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 本番環境用クラスターでは、構成管理ツールを使用して必要なすべてのNodeに設定を反映してください。
</div>
<p>プライベートイメージを使用するPodを作成し確認します。
例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: private-image-test-1
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: uses-private-image
</span><span style=color:#b44>      image: $PRIVATE_IMAGE_NAME
</span><span style=color:#b44>      imagePullPolicy: Always
</span><span style=color:#b44>      command: [ &#34;echo&#34;, &#34;SUCCESS&#34; ]
</span><span style=color:#b44>EOF</span>
</code></pre></div><pre><code>pod/private-image-test-1 created
</code></pre><p>すべてが機能している場合は、しばらくしてから以下のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs private-image-test-1
</code></pre></div><p>コマンドの結果を確認してください。</p>
<pre><code>SUCCESS
</code></pre><p>コマンドが失敗したと思われる場合には、以下を実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pods/private-image-test-1 | grep <span style=color:#b44>&#39;Failed&#39;</span>
</code></pre></div><p>失敗している場合、結果が次のようになります。</p>
<pre><code>  Fri, 26 Jun 2015 15:36:13 -0700    Fri, 26 Jun 2015 15:39:13 -0700    19    {kubelet node-i2hq}    spec.containers{uses-private-image}    failed        Failed to pull image &quot;user/privaterepo:v1&quot;: Error: image user/privaterepo:v1 not found
</code></pre><p>クラスターのすべてのNodeが同じ<code>.docker/config.json</code>になっているかを確認する必要があります。
そうでない場合、Podは一部のNodeで実行できますが他のNodeでは実行に失敗します。
例えば、Nodeのオートスケールを使用している場合、各インスタンスのテンプレートに<code>.docker/config.json</code>が含まれている、またはこのファイルが含まれているドライブをマウントする必要があります。</p>
<p>プライベートレジストリキーを<code>.docker/config.json</code>に追加した時点で、すべてのPodがプライベートレジストリのイメージに読み取りアクセス権も持つようになります。</p>
<h3 id=事前にpullしたイメージ>事前にPullしたイメージ</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Node構成を制御できる場合、この方法が適しています。
クラウドプロバイダーがNodeを管理し自動的に設定を置き換える場合は、確実に機能できません。
</div>
<p>デフォルトでは、kubeletは指定されたレジストリからそれぞれのイメージをPullしようとします。
また一方では、コンテナの<code>imagePullPolicy</code>プロパティに<code>IfNotPresent</code>や<code>Never</code>が設定されている場合、ローカルのイメージが使用されます。(それぞれに対して、優先的またはか排他的に)</p>
<p>レジストリ認証の代替として事前にPullしたイメージを利用したい場合、クラスターのすべてのNodeが同じ事前にPullしたイメージを持っていることを確認する必要があります。</p>
<p>特定のイメージをあらかじめロードしておくことは高速化やプライベートレジストリへの認証の代替として利用することができます。</p>
<p>すべてのPodは事前にPullしたイメージへの読み取りアクセス権をもちます。</p>
<h3 id=podでimagepullsecretsを指定する>PodでimagePullSecretsを指定する</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> この方法がプライベートレジストリのイメージに基づいてコンテナを実行するための推奨の方法です。
</div>
<p>KubernetesはPodでのコンテナイメージレジストリキーの指定をサポートしています。</p>
<h4 id=dockerの設定を利用してsecretを作成する>Dockerの設定を利用してSecretを作成する。</h4>
<p>適切な大文字の値を置き換えて、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</code></pre></div><p>既にDocker認証情報ファイルを持っている場合は、上記のコマンドの代わりに、認証情報ファイルをKubernetes <a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secrets>Secrets</a>としてインポートすることができます。
<a href=/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>既存のDocker認証情報に基づいてSecretを作成する</a> で、この設定方法を説明します.</p>
<p>これは複数のプライベートコンテナレジストリを使用している場合に特に有効です。<code>kubectl create secret docker-registry</code>はひとつのプライベートレジストリにのみ機能するSecretを作成するからです。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Podは自分自身のNamespace内にあるimage pull secretsのみが参照可能であるため、この作業はNemespace毎に1回行う必要があります。
</div>
<h4 id=podのimagepullsecretsを参照する方法>PodのimagePullSecretsを参照する方法</h4>
<p>これで、<code>imagePullSecrets</code>セクションをPod定義へ追加することでSecretを参照するPodを作成できます。</p>
<p>例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: foo
</span><span style=color:#b44>  namespace: awesomeapps
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: foo
</span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span><span style=color:#b44>  imagePullSecrets:
</span><span style=color:#b44>    - name: myregistrykey
</span><span style=color:#b44>EOF</span>

cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- pod.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>これは、プライベートレジストリを使用する各Podで行う必要があります。</p>
<p>ただし、この項目の設定は<a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>リソースの中でimagePullSecretsを指定することで自動化することができます。</p>
<p>詳細の手順は、<a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>ImagePullSecretsをService Accountに追加する</a>をクリックしてください。</p>
<p>これを各Nodeの<code>.docker/config.json</code>に組み合わせて利用できます。認証情報はマージされます。</p>
<h2 id=ユースケース>ユースケース</h2>
<p>プライベートレジストリを設定するためのソリューションはいくつかあります。ここでは、いくつかの一般的なユースケースと推奨される解決方法を示します。</p>
<ol>
<li>クラスターに独自仕様でない(例えば、オープンソース)イメージだけを実行する。イメージを非公開にする必要がない
<ul>
<li>Docker hubのパブリックイメージを利用する
<ul>
<li>設定は必要ない</li>
<li>クラウドプロバイダーによっては、可用性の向上とイメージをPullする時間を短くする為に、自動的にキャッシュやミラーされたパプリックイメージが提供される</li>
</ul>
</li>
</ul>
</li>
<li>社外には非公開の必要があるが、すべてのクラスター利用者には見せてよい独自仕様のイメージをクラスターで実行している
<ul>
<li>ホストされたプライペートな <a href=https://docs.docker.com/registry/>Dockerレジストリ</a>を使用
<ul>
<li><a href=https://hub.docker.com/signup>Docker Hub</a>または他の場所の上でホストされている場合がある</li>
<li>上記のように各Node上のdocker/config.jsonを手動で構成する</li>
</ul>
</li>
<li>または、オープンな読み取りアクセスを許可したファイヤーウォールの背後で内部向けプライベートレジストリを実行する
<ul>
<li>Kubernetesの設定は必要ない</li>
</ul>
</li>
<li>イメージへのアクセスを制御できるホストされたコンテナイメージレジストリサービスを利用する
<ul>
<li>Nodeを手動設定するよりもクラスターのオートスケーリングのほうがうまく機能する</li>
</ul>
</li>
<li>また、Node設定変更を自由にできないクラスターでは<code>imagePullSecrets</code>を使用する</li>
</ul>
</li>
<li>独自仕様のイメージを含むクラスターで、いくつかは厳格なアクセス制御が必要である
<ul>
<li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImagesアドミッションコントローラー</a>が有効化かを確認する必要がある。さもないと、全部のPodがすべてのイメージへのアクセスができてしまう可能性がある</li>
<li>機密データはイメージに含めてしまうのではなく、"Secret"リソースに移行する</li>
</ul>
</li>
<li>それぞれのテナントが独自のプライベートレジストリを必要とするマルチテナントのクラスターである
<ul>
<li><a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImagesアドミッションコントローラー</a>が有効化を確認する必要がある。さもないと、すべてのテナントの全Podが全部のイメージにアクセスできてしまう可能性がある</li>
<li>認証が必要なプライベートレジストリを実行する</li>
<li>それぞれのテナントでレジストリ認証を生成し、Secretへ設定し、各テナントのNamespaceに追加する</li>
<li>テナントは、Secretを各NamespaceのimagePullSecretsへ追加する</li>
</ul>
</li>
</ol>
<p>複数のレジストリへのアクセスが必要な場合、それぞれのレジストリ毎にひとつのSecretを作成する事ができます。
Kubeletは複数の<code>imagePullSecrets</code>を単一の仮想的な<code>.docker/config.json</code>にマージします。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>OCI Image Manifest Specification</a>を読みます。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-643212488f778acf04bebed65ba34441>3.3.3 - コンテナ環境</h1>
<p>このページでは、コンテナ環境で利用可能なリソースについて説明します。</p>
<h2 id=コンテナ環境>コンテナ環境</h2>
<p>Kubernetesはコンテナにいくつかの重要なリソースを提供します。</p>
<ul>
<li>イメージと1つ以上のボリュームの組み合わせのファイルシステム</li>
<li>コンテナ自体に関する情報</li>
<li>クラスター内の他のオブジェクトに関する情報</li>
</ul>
<h3 id=コンテナ情報>コンテナ情報</h3>
<p>コンテナの <em>ホスト名</em> は、コンテナが実行されているPodの名前です。
ホスト名は<code>hostname</code>コマンドまたはlibcの<a href=http://man7.org/linux/man-pages/man2/gethostname.2.html><code>gethostname</code></a>関数呼び出しにより利用可能です。</p>
<p>Podの名前と名前空間は<a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>downward API</a>を通じて環境変数として利用可能です。</p>
<p>Pod定義からのユーザー定義の環境変数もコンテナで利用できます。
Dockerイメージで静的に指定されている環境変数も同様です。</p>
<h3 id=クラスター情報>クラスター情報</h3>
<p>コンテナの作成時に実行されていたすべてのサービスのリストは、環境変数として使用できます。
これらの環境変数はDockerリンクの構文と一致します。</p>
<p><em>bar</em> という名前のコンテナに対応する <em>foo</em> という名前のサービスの場合、以下の変数が定義されています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;サービスが実行されているホスト&gt;
<span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;サービスが実行されているポート&gt;
</code></pre></div><p>サービスは専用のIPアドレスを持ち、<a href=http://releases.k8s.io/v1.22.16/cluster/addons/dns/>DNSアドオン</a>が有効の場合、DNSを介してコンテナで利用可能です。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/concepts/containers/container-lifecycle-hooks/>コンテナライフサイクルフック</a>の詳細</li>
<li><a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>コンテナライフサイクルイベントへのハンドラー紐付け</a>のハンズオン</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a858027489648786a3b16264e451272b>3.3.4 - ランタイムクラス(Runtime Class)</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.14 [beta]</code>
</div>
<p>このページではRuntimeClassリソースと、runtimeセクションのメカニズムについて説明します。</p>
<p>RuntimeClassはコンテナランタイムの設定を選択するための機能です。そのコンテナランタイム設定はPodのコンテナを稼働させるために使われます。</p>
<h2 id=runtimeclassを使う動機>RuntimeClassを使う動機</h2>
<p>異なるPodに異なるRuntimeClassを設定することで、パフォーマンスとセキュリティのバランスをとることができます。例えば、ワークロードの一部に高レベルの情報セキュリティ保証が必要な場合、ハードウェア仮想化を使用するコンテナランタイムで実行されるようにそれらのPodをスケジュールすることを選択できます。その後、追加のオーバーヘッドを犠牲にして、代替ランタイムをさらに分離することでメリットが得られます。</p>
<p>RuntimeClassを使用して、コンテナランタイムは同じで設定が異なるPodを実行することもできます。</p>
<h2 id=セットアップ>セットアップ</h2>
<p>RuntimeClass機能のフィーチャーゲートが有効になっていることを確認してください(デフォルトで有効です)。フィーチャーゲートを有効にする方法については、<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を参照してください。
その<code>RuntimeClass</code>のフィーチャーゲートはApiServerとkubeletのどちらも有効になっていなければなりません。</p>
<ol>
<li>ノード上でCRI実装を設定する。(ランタイムに依存)</li>
<li>対応するRuntimeClassリソースを作成する。</li>
</ol>
<h3 id=1-ノード上でcri実装を設定する>1. ノード上でCRI実装を設定する</h3>
<p>RuntimeClassを通じて利用可能な設定はContainer Runtime Interface (CRI)の実装依存となります。
ユーザーの環境のCRI実装の設定方法は、対応するドキュメント(<a href=#cri-configuration>下記</a>)を参照ください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> RuntimeClassは、クラスター全体で同じ種類のノード設定であることを仮定しています。(これは全てのノードがコンテナランタイムに関して同じ方法で構成されていることを意味します)。
設定が異なるノードをサポートするには、<a href=#scheduling>スケジューリング</a>を参照してください。
</div>
<p>RuntimeClassの設定は、RuntimeClassによって参照される<code>ハンドラー</code>名を持ちます。そのハンドラーは正式なDNS-1123に準拠する形式のラベルでなくてはなりません(英数字 + <code>-</code>の文字で構成されます)。</p>
<h3 id=2-対応するruntimeclassリソースを作成する>2. 対応するRuntimeClassリソースを作成する</h3>
<p>ステップ1にて設定する各項目は、関連する<code>ハンドラー</code> 名を持ちます。それはどの設定かを指定するものです。各ハンドラーにおいて、対応するRuntimeClassオブジェクトが作成されます。</p>
<p>そのRuntimeClassリソースは現時点で2つの重要なフィールドを持ちます。それはRuntimeClassの名前(<code>metadata.name</code>)とハンドラー(<code>handler</code>)です。そのオブジェクトの定義は下記のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1beta1 <span style=color:#bbb> </span><span style=color:#080;font-style:italic># RuntimeClassはnode.k8s.ioというAPIグループで定義されます。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclass <span style=color:#bbb> </span><span style=color:#080;font-style:italic># RuntimeClass名</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RuntimeClassはネームスペースなしのリソースです。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>myconfiguration <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 対応するCRI設定</span><span style=color:#bbb>
</span></code></pre></div><p>RuntimeClassオブジェクトの名前は<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>に従う必要があります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> RuntimeClassの書き込み操作(create/update/patch/delete)はクラスター管理者のみに制限されることを推奨します。
これはたいていデフォルトで有効となっています。さらなる詳細に関しては<a href=/docs/reference/access-authn-authz/authorization/>Authorization
Overview</a>を参照してください。
</div>
<h2 id=使用例>使用例</h2>
<p>一度RuntimeClassがクラスターに対して設定されると、それを使用するのは非常に簡単です。PodSpecの<code>runtimeClassName</code>を指定してください。<br>
例えば</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></code></pre></div><p>これは、Kubeletに対してPodを稼働させるためのRuntimeClassを使うように指示します。もし設定されたRuntimeClassが存在しない場合や、CRIが対応するハンドラーを実行できない場合、そのPodは<code>Failed</code>という<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase>フェーズ</a>になります。
エラーメッセージに関しては対応する<a href=/docs/tasks/debug-application-cluster/debug-application-introspection/>イベント</a>を参照して下さい。</p>
<p>もし<code>runtimeClassName</code>が指定されていない場合、デフォルトのRuntimeHandlerが使用され、これはRuntimeClassの機能が無効であるときのふるまいと同じものとなります。</p>
<h3 id=criの設定>CRIの設定</h3>
<p>CRIランタイムのセットアップに関するさらなる詳細は、<a href=/docs/setup/cri/>CRIのインストール</a>を参照してください。</p>
<h4 id=dockershim>dockershim</h4>
<p>Kubernetesのビルトインのdockershim CRIは、ランタイムハンドラーをサポートしていません。</p>
<h4 id=hahahugoshortcode-s3-hbhb><a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a></h4>
<p>ランタイムハンドラーは、<code>/etc/containerd/config.toml</code>にあるcontainerdの設定ファイルにより設定されます。
正しいハンドラーは、その<code>runtime</code>セクションで設定されます。</p>
<pre><code>[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.${HANDLER_NAME}]
</code></pre><p>containerdの設定に関する詳細なドキュメントは下記を参照してください。<br>
<a href=https://github.com/containerd/cri/blob/master/docs/config.md>https://github.com/containerd/cri/blob/master/docs/config.md</a></p>
<h4 id=hahahugoshortcode-s4-hbhb><a class=glossary-tooltip title="A lightweight container runtime specifically for Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a></h4>
<p>ランタイムハンドラーは、<code>/etc/crio/crio.conf</code>にあるCRI-Oの設定ファイルにより設定されます。
正しいハンドラーは<a href=https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md#crioruntime-table>crio.runtime
table</a>で設定されます。</p>
<pre><code>[crio.runtime.runtimes.${HANDLER_NAME}]
  runtime_path = &quot;${PATH_TO_BINARY}&quot;
</code></pre><p>詳細はCRI-Oの<a href=https://raw.githubusercontent.com/cri-o/cri-o/9f11d1d/docs/crio.conf.5.md>設定に関するドキュメント</a>を参照してください。</p>
<h2 id=scheduling>スケジューリング</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code>
</div>
<p>Kubernetes 1.16では、RuntimeClassは<code>scheduling</code>フィールドを使ったクラスター内での異なる設定をサポートしています。
このフィールドによって、設定されたRuntimeClassをサポートするノードに対してPodがスケジュールされることを保証できます。
スケジューリングをサポートするためにはRuntimeClass <a href=/docs/reference/access-authn-authz/admission-controllers/#runtimeclass>アドミッションコントローラー</a>を有効にしなければなりません。(1.16ではデフォルトです)</p>
<p>特定のRuntimeClassをサポートしているノードへPodが配置されることを保証するために、各ノードは<code>runtimeclass.scheduling.nodeSelector</code>フィールドによって選択される共通のラベルを持つべきです。
RuntimeClassのnodeSelectorはアドミッション機能によりPodのnodeSelectorに統合され、効率よくノードを選択します。
もし設定が衝突した場合は、Pod作成は拒否されるでしょう。</p>
<p>もしサポートされているノードが他のRuntimeClassのPodが稼働しないようにtaint付与されていた場合、RuntimeClassに対して<code>tolerations</code>を付与することができます。
<code>nodeSelector</code>と同様に、tolerationsはPodのtolerationsにアドミッション機能によって統合され、効率よく許容されたノードを選択します。</p>
<p>ノードの選択とtolerationsについての詳細は<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>ノード上へのPodのスケジューリング</a>を参照してください。</p>
<h3 id=podオーバーヘッド>Podオーバーヘッド</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>Podが稼働する時に関連する <em>オーバーヘッド</em> リソースを指定できます。オーバーヘッドを宣言すると、クラスター(スケジューラーを含む)がPodとリソースに関する決定を行うときにオーバーヘッドを考慮することができます。
Podオーバーヘッドを使うためには、PodOverhead<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にしなければなりません。(デフォルトではonです)</p>
<p>PodのオーバーヘッドはRuntimeClass内の<code>overhead</code>フィールドによって定義されます。
このフィールドを使用することで、RuntimeClassを使用して稼働するPodのオーバーヘッドを指定することができ、Kubernetes内部で使用されるオーバーヘッドを確保することができます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md>RuntimeClassデザイン</a></li>
<li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md#runtimeclass-scheduling>RuntimeClassスケジューリングデザイン</a></li>
<li><a href=/docs/concepts/scheduling-eviction/pod-overhead/>Podオーバーヘッド</a>のコンセプトを読む</li>
<li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/20190226-pod-overhead.md>PodOverhead機能デザイン</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e6941d969d81540208a3e78bc56f43bc>3.3.5 - コンテナライフサイクルフック</h1>
<p>このページでは、kubeletにより管理されるコンテナがコンテナライフサイクルフックフレームワークを使用して、管理ライフサイクル中にイベントによって引き起こされたコードを実行する方法について説明します。</p>
<h2 id=概要>概要</h2>
<p>Angularなどのコンポーネントライフサイクルフックを持つ多くのプログラミング言語フレームワークと同様に、Kubernetesはコンテナにライフサイクルフックを提供します。
フックにより、コンテナは管理ライフサイクル内のイベントを認識し、対応するライフサイクルフックが実行されたときにハンドラーに実装されたコードを実行できます。</p>
<h2 id=コンテナフック>コンテナフック</h2>
<p>コンテナに公開されている2つのフックがあります。</p>
<p><code>PostStart</code></p>
<p>このフックはコンテナが作成された直後に実行されます。
しかし、フックがコンテナのENTRYPOINTの前に実行されるという保証はありません。
ハンドラーにパラメーターは渡されません。</p>
<p><code>PreStop</code></p>
<p>このフックは、APIからの要求、またはliveness probeの失敗、プリエンプション、リソース競合などの管理イベントが原因でコンテナが終了する直前に呼び出されます。コンテナがすでに終了状態または完了状態にある場合、preStopフックの呼び出しは失敗します。
これはブロッキング、つまり同期的であるため、コンテナを停止する信号が送信される前に完了する必要があります。
ハンドラーにパラメーターは渡されません。</p>
<p>終了動作の詳細な説明は、<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>Termination of Pods</a>にあります。</p>
<h3 id=フックハンドラーの実装>フックハンドラーの実装</h3>
<p>コンテナは、フックのハンドラーを実装して登録することでそのフックにアクセスできます。
コンテナに実装できるフックハンドラーは2種類あります。</p>
<ul>
<li>Exec - コンテナのcgroupsと名前空間の中で、 <code>pre-stop.sh</code>のような特定のコマンドを実行します。
コマンドによって消費されたリソースはコンテナに対してカウントされます。</li>
<li>HTTP - コンテナ上の特定のエンドポイントに対してHTTP要求を実行します。</li>
</ul>
<h3 id=フックハンドラーの実行>フックハンドラーの実行</h3>
<p>コンテナライフサイクル管理フックが呼び出されると、Kubernetes管理システムはフックアクションにしたがってハンドラーを実行します。
<code>exec</code>と<code>tcpSocket</code>はコンテナの中で実行され、<code>httpGet</code>はkubeletプロセスによって実行されます。</p>
<p>フックハンドラーの呼び出しは、コンテナを含むPodのコンテキスト内で同期しています。
これは、<code>PostStart</code>フックの場合、コンテナのENTRYPOINTとフックは非同期に起動することを意味します。
しかし、フックの実行に時間がかかりすぎたりハングしたりすると、コンテナは<code>running</code>状態になることができません。</p>
<p><code>PreStop</code>フックはコンテナを停止する信号から非同期で実行されるのではなく、信号が送られる前に実行を完了する必要があります。
もし<code>PreStop</code>フックが実行中にハングした場合、Podは<code>Terminating</code>状態になり、
<code>terminationGracePeriodSeconds</code>の時間切れで強制終了されるまで続きます。
この猶予時間は、<code>PreStop</code>フックが実行され正常にコンテナを停止できるまでの合計時間に適用されます。
例えば<code>terminationGracePeriodSeconds</code>が60で、フックの終了に55秒かかり、シグナルを受信した後にコンテナを正常に停止させるのに10秒かかる場合、コンテナは正常に停止する前に終了されてしまいます。<code>terminationGracePeriodSeconds</code>が、これら２つの実行にかかる合計時間(55+10)よりも短いからです。</p>
<p><code>PostStart</code>または<code>PreStop</code>フックが失敗した場合、コンテナは強制終了します。</p>
<p>ユーザーはフックハンドラーをできるだけ軽量にするべきです。
ただし、コンテナを停止する前に状態を保存するなどの場合は、長時間のコマンド実行が必要なケースもあります。</p>
<h3 id=フック配信保証>フック配信保証</h3>
<p>フックの配信は <em>少なくとも1回</em> を意図しています。これはフックが<code>PostStart</code>や<code>PreStop</code>のような任意のイベントに対して複数回呼ばれることがあることを意味します。
これを正しく処理するのはフックの実装次第です。</p>
<p>通常、1回の配信のみが行われます。
たとえば、HTTPフックレシーバーがダウンしていてトラフィックを受け取れない場合、再送信は試みられません。
ただし、まれに二重配信が発生することがあります。
たとえば、フックの送信中にkubeletが再起動した場合、kubeletが起動した後にフックが再送信される可能性があります。</p>
<h3 id=フックハンドラーのデバッグ>フックハンドラーのデバッグ</h3>
<p>フックハンドラーのログは、Podのイベントには表示されません。
ハンドラーが何らかの理由で失敗した場合は、イベントをブロードキャストします。
<code>PostStart</code>の場合、これは<code>FailedPostStartHook</code>イベントで、<code>PreStop</code>の場合、これは<code>FailedPreStopHook</code>イベントです。
これらのイベントは <code>kubectl describe pod &lt;pod_name></code>を実行することで見ることができます。
このコマンドの実行によるイベントの出力例をいくつか示します。</p>
<pre><code>Events:
  FirstSeen  LastSeen  Count  From                                                   SubObjectPath          Type      Reason               Message
  ---------  --------  -----  ----                                                   -------------          --------  ------               -------
  1m         1m        1      {default-scheduler }                                                          Normal    Scheduled            Successfully assigned test-1730497541-cq1d2 to gke-test-cluster-default-pool-a07e5d30-siqd
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulling              pulling image &quot;test:1.0&quot;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Created              Created container with docker id 5c6a256a2567; Security:[seccomp=unconfined]
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulled               Successfully pulled image &quot;test:1.0&quot;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Started              Started container with docker id 5c6a256a2567
  38s        38s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 5c6a256a2567: PostStart handler: Error executing in Docker Container: 1
  37s        37s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 8df9fdfd7054: PostStart handler: Error executing in Docker Container: 1
  38s        37s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}                         Warning   FailedSync           Error syncing pod, skipping: failed to &quot;StartContainer&quot; for &quot;main&quot; with RunContainerError: &quot;PostStart handler: Error executing in Docker Container: 1&quot;
  1m         22s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Warning   FailedPostStartHook
</code></pre><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/containers/container-environment/>コンテナ環境</a>の詳細</li>
<li><a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>コンテナライフサイクルイベントへのハンドラー紐付け</a>のハンズオン</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d52aadda80edd9f8c514cfe2321363c2>3.4 - ワークロード</h1>
<div class=lead>Kubernetesにおけるデプロイ可能な最小のオブジェクトであるPodと、高レベルな抽象化がPodの実行を助けることを理解します。</div>
<p>ワークロードとは、Kubernetes上で実行中のアプリケーションです。
ワークロードが1つのコンポーネントからなる場合でも、複数のコンポーネントが協調して動作する場合でも、Kubernetesではそれらは<a href=/ja/docs/concepts/workloads/pods>Pod</a>の集合として実行されます。Kubernetesでは、Podはクラスター上で実行中の<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>の集合として表されます。</p>
<p>Podには定義されたライフサイクルがあります。たとえば、一度Podがクラスター上で実行中になると、そのPodが実行中の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>上で深刻な障害が起こったとき、そのノード上のすべてのPodは停止してしまうことになります。Kubernetesではそのようなレベルの障害を最終的なものとして扱うため、たとえノードが後で復元したとしても、ユーザーは新しいPodを作成し直す必要があります。</p>
<p>しかし、生活をかなり楽にするためには、それぞれのPodを直接管理する必要はありません。<em>ワークロードリソース</em> を利用すれば、あなたの代わりにPodの集合の管理を行ってもらえます。これらのリソースはあなたが指定した状態に一致するように<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>を設定し、正しい種類のPodが正しい数だけ実行中になることを保証してくれます。</p>
<p>ワークロードリソースには、次のような種類があります。</p>
<ul>
<li><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>と<a href=/ja/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>(レガシーなリソース<a class=glossary-tooltip title="A (deprecated) API object that manages a replicated application." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-replication-controller" target=_blank aria-label=ReplicationController>ReplicationController</a>を置き換えるものです)</li>
<li><a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li>
<li><a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a>(ストレージドライバやネットワークプラグインなど、ノードローカルな機能を提供するためのPodを実行するために使われます)</li>
<li><a href=/docs/concepts/workloads/controllers/job/>Job</a>と<a href=/ja/docs/concepts/workloads/controllers/cron-jobs/>CronJob</a>(実行後に完了するようなタスクのために使われます)</li>
</ul>
<p>多少関連のある2種類の補助的な概念もあります。</p>
<ul>
<li><a href=/ja/docs/concepts/workloads/controllers/garbage-collection/>ガベージコレクション</a>は、オブジェクトが <em>所有するリソース</em> が削除された後に、そのオブジェクトをクラスターからクリーンアップします。</li>
<li><a href=/ja/docs/concepts/workloads/controllers/ttlafterfinished/>終了したリソースのためのTTLコントローラー</a>は、Jobの完了後、定義した時間が経過した後にJobを削除します。</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<p>各リソースについて読む以外にも、以下のページでそれぞれのワークロードに関連する特定のタスクについて学ぶことができます。</p>
<ul>
<li><a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>Deploymentを使用してステートレスアプリケーションを実行する</a></li>
<li><a href=/ja/docs/tasks/run-application/run-single-instance-stateful-application/>単一レプリカ</a>または<a href=/ja/docs/tasks/run-application/run-replicated-stateful-application/>レプリカセット</a>のいずれかとしてステートフルなアプリケーションを実行する</li>
<li><a href=/ja/docs/tasks/job/automated-tasks-with-cron-jobs/>CronJobを使用して自動タスクを実行する</a></li>
</ul>
<p>アプリケーションが実行できるようになったら、インターネット上で公開したくなるかもしれません。その場合には、<a href=/ja/docs/concepts/services-networking/service/>Service</a>として公開したり、ウェブアプリケーションだけの場合、<a href=/ja/docs/concepts/services-networking/ingress>Ingress</a>を使用することができます。</p>
<p>コードを設定から分離するKubernetesのしくみについて学ぶには、<a href=/ja/docs/concepts/configuration/>設定</a>を読んでください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4d68b0ccf9c683e6368ffdcc40c838d4>3.4.1 - Pod</h1>
<p><em>Pod</em>は、Kubernetes内で作成・管理できるコンピューティングの最小のデプロイ可能なユニットです(Podという名前は、たとえばクジラの群れ(pod of whales)やえんどう豆のさや(pea pod)などの表現と同じような意味です)。</p>
<p><em>Pod</em>は、1つまたは複数の<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>のグループであり、ストレージやネットワークの共有リソースを持ち、コンテナの実行方法に関する仕様を持っています。同じPodに含まれるリソースは、常に同じ場所で同時にスケジューリングされ、共有されたコンテキストの中で実行されます。Podはアプリケーションに特化した「論理的なホスト」をモデル化します。つまり、1つのPod内には、1つまたは複数の比較的密に結合されたアプリケーションコンテナが含まれます。クラウド外の文脈で説明すると、アプリケーションが同じ物理ホストや同じバーチャルマシンで実行されることが、クラウドアプリケーションの場合には同じ論理ホスト上で実行されることに相当します。</p>
<p>アプリケーションコンテナと同様に、Podでも、Podのスタートアップ時に実行される<a href=/ja/docs/concepts/workloads/pods/init-containers/>initコンテナ</a>を含めることができます。また、クラスターで利用できる場合には、<a href=/ja/docs/concepts/workloads/pods/ephemeral-containers/>エフェメラルコンテナ</a>を注入してデバッグすることもできます。</p>
<h2 id=podとは何か>Podとは何か？</h2>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> KubernetesはDockerだけでなく複数の<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>をサポートしていますが、<a href=https://www.docker.com/>Docker</a>が最も一般的に知られたランタイムであるため、Docker由来の用語を使ってPodを説明するのが理解の助けとなります。
</div>
<p>Podの共有コンテキストは、Dockerコンテナを隔離するのに使われているのと同じ、Linuxのnamespaces、cgroups、場合によっては他の隔離技術の集合を用いて作られます。Podのコンテキスト内では、各アプリケーションが追加の準隔離技術を適用することもあります。</p>
<p>Dockerの概念を使って説明すると、Podは共有の名前空間と共有ファイルシステムのボリュームを持つDockerコンテナのグループに似ています。</p>
<h2 id=podを使用する>Podを使用する</h2>
<p>通常、たとえ単一のコンテナしか持たないシングルトンのPodだとしても、自分でPodを直接作成する必要はありません。その代わりに、<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>や<a class=glossary-tooltip title="A finite or batch task that runs to completion." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>などのワークロードリソースを使用してPodを作成します。もしPodが状態を保持する必要がある場合は、<a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>リソースを使用することを検討してください。</p>
<p>Kubernetesクラスター内のPodは、主に次の2種類の方法で使われます。</p>
<ul>
<li>
<p><strong>単一のコンテナを稼働させるPod</strong>。「1Pod1コンテナ」構成のモデルは、Kubernetesでは最も一般的なユースケースです。このケースでは、ユーザーはPodを単一のコンテナのラッパーとして考えることができます。Kubernetesはコンテナを直接管理するのではなく、Podを管理します。</p>
</li>
<li>
<p><strong>協調して稼働させる必要がある複数のコンテナを稼働させるPod</strong>。単一のPodは、密に結合してリソースを共有する必要があるような、同じ場所で稼働する複数のコンテナからなるアプリケーションをカプセル化することもできます。これらの同じ場所で稼働するコンテナ群は、単一のまとまりのあるサービスのユニットを構成します。たとえば、1つのコンテナが共有ボリュームからファイルをパブリックに配信し、別の<em>サイドカー</em>コンテナがそれらのファイルを更新するという構成が考えられます。Podはこれらの複数のコンテナ、ストレージリソース、一時的なネットワークIDなどを、単一のユニットとしてまとめます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 複数のコンテナを同じ場所で同時に管理するように単一のPod内にグループ化するのは、比較的高度なユースケースです。このパターンを使用するのは、コンテナが密に結合しているような特定のインスタンス内でのみにするべきです。
</div>
</li>
</ul>
<p>各Podは、与えられたアプリケーションの単一のインスタンスを稼働するためのものです。もしユーザーのアプリケーションを水平にスケールさせたい場合(例: 複数インスタンスを稼働させる)、複数のPodを使うべきです。1つのPodは各インスタンスに対応しています。Kubernetesでは、これは一般的に<em>レプリケーション</em>と呼ばれます。レプリケーションされたPodは、通常ワークロードリソースと、それに対応する<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>によって、作成・管理されます。</p>
<p>Kubernetesがワークロードリソースとそのコントローラーを活用して、スケーラブルで自動回復するアプリケーションを実装する方法については、詳しくは<a href=#pods-and-controllers>Podとコントローラー</a>を参照してください。</p>
<h3 id=podが複数のコンテナを管理する方法>Podが複数のコンテナを管理する方法</h3>
<p>Podは、まとまりの強いサービスのユニットを構成する、複数の協調する(コンテナとして実行される)プロセスをサポートするために設計されました。単一のPod内の複数のコンテナは、クラスター内の同じ物理または仮想マシン上で、自動的に同じ場所に配置・スケジューリングされます。コンテナ間では、リソースや依存関係を共有したり、お互いに通信したり、停止するときにはタイミングや方法を協調して実行できます。</p>
<p>たとえば、あるコンテナが共有ボリューム内のファイルを配信するウェブサーバーとして動作し、別の「サイドカー」コンテナがリモートのリソースからファイルをアップデートするような構成が考えられます。この構成を以下のダイアグラムに示します。</p>
<figure>
<img src=/images/docs/pod.svg alt=Podのダイアグラムの例 width=50%>
</figure>
<p>Podによっては、<a class=glossary-tooltip title="A container used to run part of a workload. Compare with init container." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-app-container" target=_blank aria-label=appコンテナ>appコンテナ</a>に加えて<a class=glossary-tooltip title="One or more initialization containers that must run to completion before any app containers run." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-init-container" target=_blank aria-label=initコンテナ>initコンテナ</a>を持っている場合があります。initコンテナはappコンテナが起動する前に実行・完了するコンテナです。</p>
<p>Podは、Podを構成する複数のコンテナに対して、<a href=#pod-networking>ネットワーク</a>と<a href=#pod-storage>ストレージ</a>の2種類の共有リソースを提供します。</p>
<h2 id=podを利用する>Podを利用する</h2>
<p>通常Kubernetesでは、たとえ単一のコンテナしか持たないシングルトンのPodだとしても、個別のPodを直接作成することはめったにありません。その理由は、Podがある程度一時的で使い捨てできる存在として設計されているためです。Podが作成されると(あなたが直接作成した場合でも、<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>が間接的に作成した場合でも)、新しいPodはクラスター内の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>上で実行されるようにスケジューリングされます。Podは、実行が完了するか、Podオブジェクトが削除されるか、リソース不足によって<em>強制退去</em>されるか、ノードが停止するまで、そのノード上にとどまります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Pod内のコンテナの再起動とPodの再起動を混同しないでください。Podはプロセスではなく、コンテナが実行するための環境です。Podは削除されるまでは残り続けます。
</div>
<p>Podオブジェクトのためのマニフェストを作成したときは、指定したPodの名前が有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>であることを確認してください。</p>
<h3 id=pods-and-controllers>Podとコンテナコントローラー</h3>
<p>ワークロードリソースは、複数のPodを作成・管理するために利用できます。リソースに対応するコントローラーが、複製やロールアウトを扱い、Podの障害時には自動回復を行います。たとえば、あるノードに障害が発生した場合、コントローラーはそのノードの動作が停止したことを検知し、代わりのPodを作成します。そして、スケジューラーが代わりのPodを健全なノード上に配置します。</p>
<p>以下に、1つ以上のPodを管理するワークロードリソースの一例をあげます。</p>
<ul>
<li><a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a></li>
<li><a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a></li>
<li><a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a></li>
</ul>
<h3 id=podテンプレート>Podテンプレート</h3>
<p><a class=glossary-tooltip title=ワークロードとは、Kubernetes上で実行中のアプリケーションです。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/ target=_blank aria-label=workload>workload</a>リソース向けのコントローラーは、Podを<em>Podテンプレート</em>を元に作成し、あなたの代わりにPodを管理してくれます。</p>
<p>PodTemplateはPodを作成するための仕様で、<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>、<a href=/ja/docs/concepts/workloads/controllers/job/>Job</a>、<a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a>などのワークロードリソースの中に含まれています。</p>
<p>ワークロードリソースに対応する各コントローラーは、ワークロードオブジェクト内にある<code>PodTemplate</code>を使用して実際のPodを作成します。<code>PodTemplate</code>は、アプリを実行するために使われるワークロードリソースがどんな種類のものであれ、その目的の状態の一部を構成するものです。</p>
<p>以下は、単純なJobのマニフェストの一例で、1つのコンテナを実行する<code>template</code>があります。Pod内のコンテナはメッセージを出力した後、一時停止します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># これがPodテンプレートです</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo &#34;Hello, Kubernetes!&#34; &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Podテンプレートはここまでです</span><span style=color:#bbb>
</span></code></pre></div><p>Podテンプレートを修正するか新しいPodに切り替えたとしても、すでに存在するPodには直接の影響はありません。ワークロードリソース内のPodテンプレートを変更すると、そのリソースは更新されたテンプレートを使用して代わりとなるPodを作成する必要があります。</p>
<p>たとえば、StatefulSetコントローラーは、各StatefulSetごとに、実行中のPodが現在のPodテンプレートに一致することを保証します。Podテンプレートを変更するためにStatefulSetを編集すると、StatefulSetは更新されたテンプレートを元にした新しいPodを作成するようになります。最終的に、すべての古いPodが新しいPodで置き換えられ、更新は完了します。</p>
<p>各ワークロードリソースは、Podテンプレートへの変更を処理するための独自のルールを実装しています。特にStatefulSetについて更に詳しく知りたい場合は、StatefulSetの基本チュートリアル内の<a href=/ja/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets>アップデート戦略</a>を読んでください。</p>
<p>ノード上では、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>はPodテンプレートに関する詳細について監視や管理を直接行うわけではありません。こうした詳細は抽象化されています。こうした抽象化や関心の分離のおかげでシステムのセマンティクスが単純化され、既存のコードを変更せずにクラスターの動作を容易に拡張できるようになっているのです。</p>
<h2 id=リソースの共有と通信>リソースの共有と通信</h2>
<p>Podは、データの共有と構成するコンテナ間での通信を可能にします。</p>
<h3 id=pod-storage>Pod内のストレージ</h3>
<p>Podでは、共有ストレージである<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>の集合を指定できます。Pod内のすべてのコンテナは共有ボリュームにアクセスできるため、それら複数のコンテナでデータを共有できるようになります。また、ボリュームを利用すれば、Pod内のコンテナの1つに再起動が必要になった場合にも、Pod内の永続化データを保持し続けられるようにできます。Kubernetesの共有ストレージの実装方法とPodで利用できるようにする方法に関するさらに詳しい情報は、<a href=/ja/docs/concepts/storage/>ストレージ</a>を読んでください。</p>
<h3 id=podネットワーク>Podネットワーク</h3>
<p>各Podには、各アドレスファミリーごとにユニークなIPアドレスが割り当てられます。Pod内のすべてのコンテナは、IPアドレスとネットワークポートを含むネットワーク名前空間を共有します。Podの中では(かつその場合に<strong>のみ</strong>)、そのPod内のコンテナは<code>localhost</code>を使用して他のコンテナと通信できます。Podの内部にあるコンテナが<em>Podの外部にある</em>エンティティと通信する場合、(ポートなどの)共有ネットワークリソースの使い方をコンテナ間で調整しなければなりません。Pod内では、コンテナはIPアドレスとポートの空間を共有するため、<code>localhost</code>で他のコンテナにアクセスできます。また、Pod内のコンテナは、SystemVのセマフォやPOSIXの共有メモリなど、標準のプロセス間通信を使って他のコンテナと通信することもできます。異なるPod内のコンテナは異なるIPアドレスを持つため、<a href=/docs/concepts/policy/pod-security-policy/>特別な設定</a>をしない限りIPCで通信することはできません。異なるPod上で実行中のコンテナ間でやり取りをしたい場合は、IPネットワークを使用して通信できます。</p>
<p>Pod内のコンテナは、システムのhostnameがPodに設定した<code>name</code>と同一であると考えます。ネットワークについての詳しい情報は、<a href=/ja/docs/concepts/cluster-administration/networking/>ネットワーク</a>で説明しています。</p>
<h2 id=コンテナの特権モード>コンテナの特権モード</h2>
<p>Pod内のどんなコンテナも、<code>privileged</code>フラグをコンテナのspecの<a href=/docs/tasks/configure-pod-container/security-context/>security context</a>に設定することで、特権モード(privileged mode)を有効にできます。これは、ネットワークスタックの操作やハードウェアデバイスへのアクセスなど、オペレーティングシステムの管理者の権限が必要なコンテナの場合に役に立ちます。特権コンテナ内のプロセスはコンテナ外のプロセスが利用できるのとほぼ同等の権限を取得します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> この設定を有効にするには、<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>が特権コンテナの概念をサポートしていなければなりません。
</div>
<h2 id=static-pod>static Pod</h2>
<p><em>static Pod</em>は、<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>には管理されない、特定のノード上でkubeletデーモンによって直接管理されるPodのことです。大部分のPodはコントロープレーン(たとえば<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>)によって管理されますが、static Podの場合はkubeletが各static Podを直接管理します(障害時には再起動します)。</p>
<p>static Podは常に特定のノード上の1つの<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>に紐付けられます。static Podの主な用途は、セルフホストのコントロールプレーンを実行すること、言い換えると、kubeletを使用して個別の<a href=/ja/docs/concepts/overview/components/#control-plane-components>コントロールプレーンコンポーネント</a>を管理することです。</p>
<p>kubeletは自動的にKubernetes APIサーバー上に各static Podに対応する<a class=glossary-tooltip title="kubelet上のstatic Podを追跡するAPIサーバー内のオブジェクトです。" data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-mirror-pod" target=_blank aria-label=ミラーPod>ミラーPod</a>の作成を試みます。つまり、ノード上で実行中のPodはAPIサーバー上でも見えるようになるけれども、APIサーバー上から制御はできないということです。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>について学ぶ。</li>
<li><a href=/ja/docs/concepts/workloads/pods/podpreset/>PodPreset</a>について学ぶ。</li>
<li><a href=/ja/docs/concepts/containers/runtime-class/>RuntimeClass</a>と、それを用いてPodごとに異なるコンテナランタイム設定する方法について学ぶ。</li>
<li><a href=/docs/concepts/workloads/pods/pod-topology-spread-constraints/>Podトポロジー分布制約</a>について読む。</li>
<li><a href=/ja/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>と、それを使用してクラスターの停止(disruption)中にアプリケーションの可用性を管理する方法について読む。</li>
<li>PodはKubernetes REST API内のトップレベルのリソースです。<a href=/ja/docs/reference/generated/kubernetes-api/v1.22/#pod-v1-core>Pod</a>オブジェクトの定義では、オブジェクトの詳細について記述されています。</li>
<li><a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>The Distributed System Toolkit: Patterns for Composite Containers</a>では、2つ以上のコンテナを利用する場合の一般的なレイアウトについて説明しています。</li>
</ul>
<p>Kubernetesが共通のPod APIを他のリソース内(たとえば<a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>や<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>など)にラッピングしている理由の文脈を理解するためには、Kubernetes以前から存在する以下のような既存技術について読むのが助けになります。</p>
<ul>
<li><a href=https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema>Aurora</a></li>
<li><a href=https://research.google.com/pubs/pub43438.html>Borg</a></li>
<li><a href=https://mesosphere.github.io/marathon/docs/rest-api.html>Marathon</a></li>
<li><a href=https://research.google/pubs/pub41684/>Omega</a></li>
<li><a href=https://engineering.fb.com/data-center-engineering/tupperware/>Tupperware</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-37afa6c66c74400d1579f10faf55e5b6>3.4.1.1 - Podの概観</h1>
<p>このページでは、Kubernetesのオブジェクトモデルにおいて、デプロイ可能な最小単位のオブジェクトである<code>Pod</code>に関して説明します。</p>
<h2 id=understanding-pods>Podについて理解する</h2>
<p><em>Pod</em> は、Kubernetesアプリケーションの基本的な実行単位です。これは、作成またはデプロイするKubernetesオブジェクトモデルの中で最小かつ最も単純な単位です。Podは、<a class=glossary-tooltip title=コンテナ化されたアプリケーションを実行する、ノードと呼ばれるワーカーマシンの集合です。すべてのクラスターには少なくとも1つのワーカーノードがあります。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-cluster" target=_blank aria-label=クラスター>クラスター</a>で実行されているプロセスを表します。</p>
<p>Podは、アプリケーションのコンテナ(いくつかの場合においては複数のコンテナ)、ストレージリソース、ユニークなネットワークIP、およびコンテナの実行方法を管理するオプションをカプセル化します。Podはデプロイメントの単位、すなわち<em>Kubernetesのアプリケーションの単一インスタンス</em> で、単一の<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>または密結合なリソースを共有する少数のコンテナで構成される場合があります。</p>
<p><a href=https://www.docker.com>Docker</a>はKubernetesのPod内で使われる最も一般的なコンテナランタイムですが、Podは他の<a href=/ja/docs/setup/production-environment/container-runtimes/>コンテナランタイム</a>も同様にサポートしています。</p>
<p>Kubernetesクラスター内でのPodは2つの主な方法で使うことができます。</p>
<ul>
<li><strong>単一のコンテナを稼働させるPod</strong> : いわゆる*「1Pod1コンテナ」* 構成のモデルは、最も一般的なKubernetesのユースケースです。
このケースでは、ユーザーはPodを単一のコンテナのラッパーとして考えることができ、Kubernetesはコンテナを直接扱うというよりは、Podを管理することになります。</li>
<li><strong>協調して稼働させる必要がある複数のコンテナを稼働させるPod</strong> : 単一のPodは、リソースを共有する必要があるような、密接に連携した複数の同じ環境にあるコンテナからなるアプリケーションをカプセル化することもできます。 これらの同じ環境にあるコンテナ群は、サービスの結合力の強いユニットを構成することができます。
-- 1つのコンテナが、共有されたボリュームからファイルをパブリックな場所に送信し、一方では分割された<em>サイドカー</em> コンテナがそれらのファイルを更新します。そのPodはそれらのコンテナとストレージリソースを、単一の管理可能なエンティティとしてまとめます。</li>
</ul>
<p><a href=https://kubernetes.io/blog>Kubernetes Blog</a>にて、Podのユースケースに関するいくつかの追加情報を見ることができます。さらなる情報を得たい場合は、下記のページを参照ください。</p>
<ul>
<li><a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>The Distributed System Toolkit: Patterns for Composite Containers</a></li>
<li><a href=https://kubernetes.io/blog/2016/06/container-design-patterns>Container Design Patterns</a></li>
</ul>
<p>各Podは、与えられたアプリケーションの単一のインスタンスを稼働するためのものです。もしユーザーのアプリケーションを水平にスケールさせたい場合(例: 複数インスタンスを稼働させる)、複数のPodを使うべきです。1つのPodは各インスタンスに対応しています。
Kubernetesにおいて、これは一般的に <em>レプリケーション</em> と呼ばれます。
レプリケーションされたPodは、通常コントローラーと呼ばれる抽象概念によって単一のグループとして作成、管理されます。
さらなる情報に関しては<a href=#pods-and-controllers>Podとコントローラー</a>を参照して下さい。</p>
<h3 id=podがどのように複数のコンテナを管理しているか>Podがどのように複数のコンテナを管理しているか</h3>
<p>Podは凝集性の高いサービスのユニットを構成するような複数の協調プロセス(コンテナ）をサポートするためにデザインされました。
単一のPod内のコンテナ群は、クラスター内において同一の物理マシンもしくは仮想マシン上において自動で同じ環境に配備され、スケジュールされます。コンテナはリソースや依存関係を共有し、お互いにコミュニケートし、それらがいつ、どのように削除されるかを調整できます。</p>
<p>注意点として、単一のPod内で同じ環境に配備され、同時管理される複数のコンテナをグルーピングするのは、比較的に発展的なユースケースとなります。
ユーザーは、コンテナ群が密接に連携するような、特定のインスタンスにおいてのみこのパターンを使用するべきです。
例えば、ユーザーが共有ボリューム内にあるファイル用のWebサーバとして稼働するコンテナと、下記のダイアグラムにあるような、リモートのソースからファイルを更新するような分離された<em>サイドカー</em> コンテナを持っているような場合です。</p>
<figure>
<img src=/images/docs/pod.svg alt=Podのダイアグラム width=50%>
</figure>
<p>Podは、Podによって構成されたコンテナ群のために2種類の共有リソースを提供します。 <em>ネットワーキング</em> と<em>ストレージ</em> です。</p>
<h4 id=ネットワーキング>ネットワーキング</h4>
<p>各Podは固有のIPアドレスを割り当てられます。単一のPod内の各コンテナは、IPアドレスやネットワークポートを含む、そのネットワークの名前空間を共有します。<em>Pod内の</em> コンテナは<code>localhost</code>を使用してお互いに疎通できます。単一のPod内のコンテナが<em>Pod外</em> のエンティティと疎通する場合、共有されたネットワークリソース(ポートなど）をどのように使うかに関して調整しなければなりません。</p>
<h4 id=ストレージ>ストレージ</h4>
<p>単一のPodは共有されたストレージ<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>のセットを指定できます。Pod内の全てのコンテナは、その共有されたボリュームにアクセスでき、コンテナ間でデータを共有することを可能にします。ボリュームもまた、もしPod内のコンテナの1つが再起動が必要になった場合に備えて、データを永続化できます。
単一のPod内での共有ストレージをKubernetesがどう実装しているかについてのさらなる情報については、<a href=/docs/concepts/storage/volumes/>Volumes</a>を参照してください。</p>
<h2 id=podを利用する>Podを利用する</h2>
<p>ユーザーはまれに、Kubernetes内で独立したPodを直接作成する場合があります(シングルトンPodなど)。
これはPodが比較的、一時的な使い捨てエンティティとしてデザインされているためです。Podが作成された時(ユーザーによって直接的、またはコントローラーによって間接的に作成された場合)、ユーザーのクラスター内の単一の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>上で稼働するようにスケジューリングされます。そのPodはプロセスが停止されたり、Podオブジェクトが削除されたり、Podがリソースの欠如のために<em>追い出され</em> たり、ノードが故障するまでノード上に残り続けます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 単一のPod内でのコンテナを再起動することと、そのPodを再起動することを混同しないでください。Podはそれ自体は実行されませんが、コンテナが実行される環境であり、削除されるまで存在し続けます。
</div>
<p>Podは、Podそれ自体によって自己修復しません。もし、稼働されていないノード上にPodがスケジュールされた場合や、スケジューリング操作自体が失敗した場合、Podが削除されます。同様に、Podはリソースの欠如や、ノードのメンテナンスによる追い出しがあった場合はそこで停止します。Kubernetesは<em>コントローラー</em> と呼ばれる高レベルの抽象概念を使用し、それは比較的使い捨て可能なPodインスタンスの管理を行います。
このように、Podを直接使うのは可能ですが、コントローラーを使用したPodを管理する方がより一般的です。KubernetesがPodのスケーリングと修復機能を実現するためにコントローラーをどのように使うかに関する情報は<a href=#pods-and-controllers>Podとコントローラー</a>を参照してください。</p>
<h3 id=podとコントローラー>Podとコントローラー</h3>
<p>単一のコントローラーは、ユーザーのために複数のPodを作成・管理し、レプリケーションやロールアウト、クラスターのスコープ内で自己修復の機能をハンドリングします。例えば、もしノードが故障した場合、コントローラーは異なるノード上にPodを置き換えるようにスケジューリングすることで、自動的にリプレース可能となります。</p>
<p>1つまたはそれ以上のPodを含むコントローラーの例は下記の通りです。</p>
<ul>
<li><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a></li>
<li><a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li>
<li><a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a></li>
</ul>
<p>通常は、コントローラーはユーザーが作成したPodテンプレートを使用して、担当するPodを作成します。</p>
<h2 id=podテンプレート>Podテンプレート</h2>
<p>Podテンプレートは、<a href=/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>、 <a href=/docs/concepts/jobs/run-to-completion-finite-workloads/>Job</a>や、
<a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a>のような他のオブジェクト内で含まれるPodの仕様となります。
コントローラーは実際のPodを作成するためにPodテンプレートを使用します。
下記のサンプルは、メッセージを表示する単一のコンテナを含んだ、シンプルなPodのマニフェストとなります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>myapp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo Hello Kubernetes! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></code></pre></div><p>全てのレプリカの現在の理想的な状態を指定するというよりも、Podテンプレートはクッキーの抜き型のようなものです。一度クッキーがカットされると、そのクッキーは抜き型から離れて関係が無くなります。そこにはいわゆる”量子もつれ”といったものはありません。テンプレートに対するその後の変更や新しいテンプレートへの切り替えは、すでに作成されたPod上には直接的な影響はありません。
同様に、ReplicationControllerによって作成されたPodは、変更後に直接更新されます。これはPodとの意図的な違いとなり、そのPodに属する全てのコンテナの現在の理想的な状態を指定します。このアプローチは根本的にシステムのセマンティクスを単純化し、機能の柔軟性を高めます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/workloads/pods/pod/>Pod</a>についてさらに学びましょう</li>
<li>Podの振る舞いに関して学ぶには下記を参照してください
<ul>
<li><a href=/ja/docs/concepts/workloads/pods/pod/#termination-of-pods>Podの停止</a></li>
<li><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a></li>
</ul>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c3c2b9cf30915ec9d46c147201da3332>3.4.1.2 - Podのライフサイクル</h1>
<p>このページではPodのライフサイクルについて説明します。Podは定義されたライフサイクルに従い <code>Pending</code><a href=#pod-phase>フェーズ</a>から始まり、少なくとも1つのプライマリーコンテナが正常に開始した場合は<code>Running</code>を経由し、次に失敗により終了したコンテナの有無に応じて、<code>Succeeded</code>または<code>Failed</code>フェーズを経由します。</p>
<p>Podの実行中、kubeletはコンテナを再起動して、ある種の障害を処理できます。Pod内で、Kubernetesはさまざまなコンテナの<a href=#container-states>ステータス</a>を追跡して、回復させるためのアクションを決定します。</p>
<p>Kubernetes APIでは、Podには仕様と実際のステータスの両方があります。Podオブジェクトのステータスは、<a href=#pod-conditions>PodのCondition</a>のセットで構成されます。<a href=#pod-readiness-gate>カスタムのReadiness情報</a>をPodのConditionデータに挿入することもできます。</p>
<p>Podはその生存期間に1回だけ<a href=/docs/concepts/scheduling-eviction/>スケジューリング</a>されます。PodがNodeにスケジュール(割り当て)されると、Podは停止または<a href=#pod-termination>終了</a>するまでそのNode上で実行されます。</p>
<h2 id=podのライフタイム>Podのライフタイム</h2>
<p>個々のアプリケーションコンテナと同様に、Podは(永続的ではなく)比較的短期間の存在と捉えられます。Podが作成されると、一意のID(<a href=/ja/docs/concepts/overview/working-with-objects/names/#uids>UID</a>)が割り当てられ、(再起動ポリシーに従って)終了または削除されるまでNodeで実行されるようにスケジュールされます。<br>
<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>が停止した場合、そのNodeにスケジュールされたPodは、タイムアウト時間の経過後に<a href=#pod-garbage-collection>削除</a>されます。</p>
<p>Pod自体は、自己修復しません。Podが<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=node>node</a>にスケジュールされ、その後に失敗、またはスケジュール操作自体が失敗した場合、Podは削除されます。同様に、リソースの不足またはNodeのメンテナンスによりPodはNodeから立ち退きます。Kubernetesは、比較的使い捨てのPodインスタンスの管理作業を処理する、<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>と呼ばれる上位レベルの抽象化を使用します。</p>
<p>特定のPod(UIDで定義)は新しいNodeに"再スケジュール"されません。代わりに、必要に応じて同じ名前で、新しいUIDを持つ同一のPodに置き換えることができます。</p>
<p><a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a>など、Podと同じ存続期間を持つものがあると言われる場合、それは(そのUIDを持つ)Podが存在する限り存在することを意味します。そのPodが何らかの理由で削除された場合、たとえ同じ代替物が作成されたとしても、関連するもの(例えばボリューム)も同様に破壊されて再作成されます。</p>
<figure>
<img src=/images/docs/pod.svg width=50%> <figcaption>
<h4>Podの図</h4>
</figcaption>
</figure>
<p><em>file puller(ファイル取得コンテナ)とWebサーバーを含むマルチコンテナのPod。コンテナ間の共有ストレージとして永続ボリュームを使用しています。</em></p>
<h2 id=pod-phase>Podのフェーズ</h2>
<p>Podの<code>status</code>項目は<a href=/docs/reference/generated/kubernetes-api/v1.22/#podstatus-v1-core>PodStatus</a>オブジェクトで、それは<code>phase</code>のフィールドがあります。</p>
<p>Podのフェーズは、そのPodがライフサイクルのどの状態にあるかを、簡単かつ高レベルにまとめたものです。このフェーズはコンテナやPodの状態を包括的にまとめることを目的としたものではなく、また包括的なステートマシンでもありません。</p>
<p>Podの各フェーズの値と意味は厳重に守られています。ここに記載されているもの以外に<code>phase</code>の値は存在しないと思ってください。</p>
<p>これらが<code>phase</code>の取りうる値です。</p>
<table>
<thead>
<tr>
<th style=text-align:left>値</th>
<th style=text-align:left>概要</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left><code>Pending</code></td>
<td style=text-align:left>PodがKubernetesクラスターによって承認されましたが、1つ以上のコンテナがセットアップされて稼働する準備ができていません。これには、スケジュールされるまでの時間と、ネットワーク経由でイメージをダウンロードするための時間などが含まれます。</td>
</tr>
<tr>
<td style=text-align:left><code>Running</code></td>
<td style=text-align:left>PodがNodeにバインドされ、すべてのコンテナが作成されました。少なくとも1つのコンテナがまだ実行されているか、開始または再起動中です。</td>
</tr>
<tr>
<td style=text-align:left><code>Succeeded</code></td>
<td style=text-align:left>Pod内のすべてのコンテナが正常に終了し、再起動されません。</td>
</tr>
<tr>
<td style=text-align:left><code>Failed</code></td>
<td style=text-align:left>Pod内のすべてのコンテナが終了し、少なくとも1つのコンテナが異常終了しました。つまり、コンテナはゼロ以外のステータスで終了したか、システムによって終了されました。</td>
</tr>
<tr>
<td style=text-align:left><code>Unknown</code></td>
<td style=text-align:left>何らかの理由によりPodの状態を取得できませんでした。このフェーズは通常はPodのホストとの通信エラーにより発生します。</td>
</tr>
</tbody>
</table>
<p>Nodeが停止するか、クラスタの残りの部分から切断された場合、Kubernetesは失われたNode上のすべてのPodの<code>Phase</code>をFailedに設定するためのポリシーを適用します。</p>
<h2 id=container-states>コンテナのステータス</h2>
<p>Pod全体の<a href=#pod-phase>フェーズ</a>と同様に、KubernetesはPod内の各コンテナの状態を追跡します。<a href=/ja/docs/concepts/containers/container-lifecycle-hooks/>container lifecycle hooks</a>を使用して、コンテナのライフサイクルの特定のポイントで実行するイベントをトリガーできます。</p>
<p>Podが<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=scheduler>scheduler</a>によってNodeに割り当てられると、kubeletは<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label="container runtime">container runtime</a>を使用してコンテナの作成を開始します。コンテナの状態は<code>Waiting</code>、<code>Running</code>または<code>Terminated</code>の3ついずれかです。</p>
<p>Podのコンテナの状態を確認するには<code>kubectl describe pod [POD_NAME]</code>のコマンドを使用します。Pod内のコンテナごとにStateの項目として表示されます。</p>
<p>各状態の意味は次のとおりです。</p>
<h3 id=container-state-waiting><code>Waiting</code></h3>
<p>コンテナが<code>Running</code>または<code>Terminated</code>のいずれの状態でもない場合コンテナは<code>Waiting</code>の状態になります。Waiting状態のコンテナは引き続きコンテナイメージレジストリからイメージを取得したり<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>を適用したりするなど必要な操作を実行します。<code>Waiting</code>状態のコンテナを持つPodに対して<code>kubectl</code>コマンドを使用すると、そのコンテナが<code>Waiting</code>の状態である理由の要約が表示されます。</p>
<h3 id=container-state-running><code>Running</code></h3>
<p><code>Running</code>状態はコンテナが問題なく実行されていることを示します。<code>postStart</code>フックが構成されていた場合、それはすでに実行が完了しています。<code>Running</code>状態のコンテナを持つPodに対して<code>kubectl</code>コマンドを使用すると、そのコンテナが<code>Running</code>状態になった時刻が表示されます。</p>
<h3 id=container-state-terminated><code>Terminated</code></h3>
<p><code>Terminated</code>状態のコンテナは実行されて、完了したときまたは何らかの理由で失敗したことを示します。<code>Terminated</code>状態のコンテナを持つPodに対して<code>kubectl</code>コマンドを使用すると、いずれにせよ理由と終了コード、コンテナの開始時刻と終了時刻が表示されます。</p>
<p>コンテナがTerminatedに入る前に<code>preStop</code>フックがあれば実行されます。</p>
<h2 id=restart-policy>コンテナの再起動ポリシー</h2>
<p>Podの<code>spec</code>には、Always、OnFailure、またはNeverのいずれかの値を持つ<code>restartPolicy</code>フィールドがあります。デフォルト値はAlwaysです。</p>
<p><code>restartPolicy</code>は、Pod内のすべてのコンテナに適用されます。<code>restartPolicy</code>は、同じNode上のkubeletによるコンテナの再起動のみを参照します。Pod内のコンテナが終了した後、kubeletは5分を上限とする指数バックオフ遅延（10秒、20秒、40秒...）でコンテナを再起動します。コンテナが10分間実行されると、kubeletはコンテナの再起動バックオフタイマーをリセットします。</p>
<h2 id=pod-conditions>PodのCondition</h2>
<p>PodにはPodStatusがあります。それはPodが成功したかどうかの情報を持つ<a href=/docs/reference/generated/kubernetes-api/v1.22/#podcondition-v1-core>PodConditions</a>の配列です。</p>
<ul>
<li><code>PodScheduled</code>: PodがNodeにスケジュールされました。</li>
<li><code>ContainersReady</code>: Pod内のすべてのコンテナが準備できた状態です。</li>
<li><code>Initialized</code>: すべての<a href=/docs/concepts/workloads/pods/init-containers>Initコンテナ</a>が正常に実行されました。</li>
<li><code>Ready</code>: Podはリクエストを処理でき、一致するすべてのサービスの負荷分散プールに追加されます。</li>
</ul>
<table>
<thead>
<tr>
<th style=text-align:left>フィールド名</th>
<th style=text-align:left>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left><code>type</code></td>
<td style=text-align:left>このPodの状態の名前です。</td>
</tr>
<tr>
<td style=text-align:left><code>status</code></td>
<td style=text-align:left>その状態が適用可能かどうか示します。可能な値は"<code>True</code>"と"<code>False</code>"、"<code>Unknown</code>"のうちのいずれかです。</td>
</tr>
<tr>
<td style=text-align:left><code>lastProbeTime</code></td>
<td style=text-align:left>Pod Conditionが最後に確認されたときのタイムスタンプが表示されます。</td>
</tr>
<tr>
<td style=text-align:left><code>lastTransitionTime</code></td>
<td style=text-align:left>最後にPodのステータスの遷移があった際のタイムスタンプが表示されます。</td>
</tr>
<tr>
<td style=text-align:left><code>reason</code></td>
<td style=text-align:left>最後の状態遷移の理由を示す、機械可読のアッパーキャメルケースのテキストです。</td>
</tr>
<tr>
<td style=text-align:left><code>message</code></td>
<td style=text-align:left>ステータスの遷移に関する詳細を示す人間向けのメッセージです。</td>
</tr>
</tbody>
</table>
<h2 id=pod-readiness-gate>PodのReadiness</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code>
</div>
<p>追加のフィードバックやシグナルをPodStatus:_Pod readiness_に注入できるようにします。これを使用するには、Podの<code>spec</code>で<code>readinessGates</code>を設定して、kubeletがPodのReadinessを評価する追加の状態のリストを指定します。</p>
<p>ReadinessゲートはPodの<code>status.conditions</code>フィールドの現在の状態によって決まります。Kubernetesが<code>Podのstatus.conditions</code>フィールドでそのような状態を発見できない場合、ステータスはデフォルトで<code>False</code>になります。</p>
<p>以下はその例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readinessGates</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>conditionType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready <span style=color:#bbb> </span><span style=color:#080;font-style:italic># これはビルトインのPodCondition</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># 追加のPodCondition</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://abcd...<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p>PodのConditionは、Kubernetesの<a href=/ja/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set>label key format</a>に準拠している必要があります。</p>
<h3 id=pod-readiness-status>PodのReadinessの状態</h3>
<p><code>kubectl patch</code>コマンドはオブジェクトステータスのパッチ適用をまだサポートしていません。Podにこれらの<code>status.conditions</code>を設定するには、アプリケーションと<a class=glossary-tooltip title="A specialized controller used to manage a custom resource" data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operators>operators</a>は<code>PATCH</code>アクションを使用する必要があります。<a href=/docs/reference/using-api/client-libraries/>Kubernetes client library</a>を使用して、PodのReadinessのためにカスタムのPodのConditionを設定するコードを記述できます。</p>
<p>カスタムのPodのConditionが導入されるとPodは次の両方の条件に当てはまる場合<strong>のみ</strong>準備できていると評価されます:</p>
<ul>
<li>Pod内のすべてのコンテナが準備完了している。</li>
<li><code>ReadinessGates</code>で指定された条件が全て<code>True</code>である。</li>
</ul>
<p>Podのコンテナは準備完了ですが、少なくとも1つのカスタムのConditionが欠落しているか「False」の場合、kubeletはPodの<a href=#pod-condition>Condition</a>を<code>ContainersReady</code>に設定します。</p>
<h2 id=container-probes>コンテナのProbe</h2>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#probe-v1-core>Probe</a> は <a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> により定期的に実行されるコンテナの診断です。診断を行うために、kubeletはコンテナに実装された <a href=/docs/reference/generated/kubernetes-api/v1.22/#handler-v1-core>Handler</a>を呼びます。Handlerには次の3つの種類があります:</p>
<ul>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#execaction-v1-core>ExecAction</a>:
コンテナ内で特定のコマンドを実行します。コマンドがステータス0で終了した場合に診断を成功と見まします。</p>
</li>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#tcpsocketaction-v1-core>TCPSocketAction</a>:
PodのIPの特定のポートにTCPチェックを行います。
そのポートが空いていれば診断を成功とみなします。</p>
</li>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#httpgetaction-v1-core>HTTPGetAction</a>:
PodのIPの特定のポートとパスに対して、HTTP GETのリクエストを送信します。
レスポンスのステータスコードが200以上400未満の際に診断を成功とみなします。</p>
</li>
</ul>
<p>各Probe 次の3つのうちの一つの結果を持ちます:</p>
<ul>
<li><code>Success</code>: コンテナの診断が成功しました。</li>
<li><code>Failure</code>: コンテナの診断が失敗しました。</li>
<li><code>Unknown</code>: コンテナの診断が失敗し、取れるアクションがありません。</li>
</ul>
<p>Kubeletは3種類のProbeを実行中のコンテナで行い、また反応することができます:</p>
<ul>
<li>
<p><code>livenessProbe</code>: コンテナが動いているかを示します。
livenessProbe に失敗すると、kubeletはコンテナを殺します、そしてコンテナは<a href=#restart-policy>restart policy</a>に従います。
コンテナにlivenessProbeが設定されていない場合、デフォルトの状態は<code>Success</code>です。</p>
</li>
<li>
<p><code>readinessProbe</code>: コンテナがリクエスト応答する準備ができているかを示します。
readinessProbeに失敗すると、エンドポイントコントローラーにより、ServiceからそのPodのIPアドレスが削除されます。
initial delay前のデフォルトのreadinessProbeの初期値は<code>Failure</code>です。
コンテナにreadinessProbeが設定されていない場合、デフォルトの状態は<code>Success</code>です。</p>
</li>
<li>
<p><code>startupProbe</code>: コンテナ内のアプリケーションが起動したかどうかを示します。
startupProbeが設定された場合、完了するまでその他のすべてのProbeは無効になります。
startupProbeに失敗すると、kubeletはコンテナを殺します、そしてコンテナは<a href=#restart-policy>restart policy</a>に従います。
コンテナにstartupProbeが設定されていない場合、デフォルトの状態は<code>Success</code>です。</p>
</li>
</ul>
<p>livenessProbe、readinessProbeまたはstartupProbeを設定する方法の詳細については、<a href=/ja/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>Liveness Probe、Readiness ProbeおよびStartup Probeを使用する</a>を参照してください。</p>
<h3 id=when-should-you-use-a-liveness-probe>livenessProbeをいつ使うべきか?</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code>
</div>
<p>コンテナ自体に問題が発生した場合や状態が悪くなった際にクラッシュすることができればlivenessProbeは不要です.
この場合kubeletが自動でPodの<code>restartPolicy</code>に基づいたアクションを実行します。</p>
<p>Probeに失敗したときにコンテナを殺したり再起動させたりするには、livenessProbeを設定し<code>restartPolicy</code>をAlwaysまたはOnFailureにします。</p>
<h3 id=when-should-you-use-a-readiness-probe>readinessProbeをいつ使うべきか?</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code>
</div>
<p>Probeが成功したときにのみPodにトラフィックを送信したい場合は、readinessProbeを指定します。
この場合readinessProbeはlivenessProbeと同じになる可能性がありますが、readinessProbeが存在するということは、Podがトラフィックを受けずに開始され、Probe成功が開始した後でトラフィックを受け始めることになります。コンテナが起動時に大きなデータ、構成ファイル、またはマイグレーションを読み込む必要がある場合は、readinessProbeを指定します。</p>
<p>コンテナがメンテナンスのために停止できるようにするには、livenessProbeとは異なる、特定のエンドポイントを確認するreadinessProbeを指定することができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Podが削除されたときにリクエストを来ないようにするためには必ずしもreadinessProbeが必要というわけではありません。Podの削除時にはreadinessProbeが存在するかどうかに関係なくPodは自動的に自身をunreadyにします。Pod内のコンテナが停止するのを待つ間Podはunreadyのままです。
</div>
<h3 id=when-should-you-use-a-startup-probe>startupProbeをいつ使うべきか?</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>startupProbeは、サービスの開始に時間がかかるコンテナを持つPodに役立ちます。livenessProbeの間隔を長く設定するのではなく、コンテナの起動時に別のProbeを構成して、livenessProbeの間隔よりも長い時間を許可できます。
コンテナの起動時間が、<code>initialDelaySeconds + failureThreshold x periodSeconds</code>よりも長い場合は、livenessProbeと同じエンドポイントをチェックするためにstartupProbeを指定します。<code>periodSeconds</code>のデフォルトは30秒です。次に、<code>failureThreshold</code>をlivenessProbeのデフォルト値を変更せずにコンテナが起動できるように、十分に高い値を設定します。これによりデッドロックを防ぐことができます。</p>
<h2 id=pod-termination>Podの終了</h2>
<p>Podは、クラスター内のNodeで実行中のプロセスを表すため、不要になったときにそれらのプロセスを正常に終了できるようにすることが重要です(対照的なケースは、KILLシグナルで強制終了され、クリーンアップする機会がない場合)。</p>
<p>ユーザーは削除を要求可能であるべきで、プロセスがいつ終了するかを知ることができなければなりませんが、削除が最終的に完了することも保証できるべきです。ユーザーがPodの削除を要求すると、システムはPodが強制終了される前に意図された猶予期間を記録および追跡します。強制削除までの猶予期間がある場合、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>正常な終了を試みます。</p>
<p>通常、コンテナランタイムは各コンテナのメインプロセスにTERMシグナルを送信します。多くのコンテナランタイムは、コンテナイメージで定義されたSTOPSIGNAL値を尊重し、TERMシグナルの代わりにこれを送信します。猶予期間が終了すると、プロセスにKILLシグナルが送信され、Podは<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API server">API server</a>から削除されます。プロセスの終了を待っている間にkubeletかコンテナランタイムの管理サービスが再起動されると、クラスターは元の猶予期間を含めて、最初からリトライされます。</p>
<p>フローの例は下のようになります。</p>
<ol>
<li>ユーザーがデフォルトの猶予期間(30秒)でPodを削除するために<code>kubectl</code>コマンドを送信する。</li>
<li>API server内のPodは、猶予期間を越えるとPodが「死んでいる」と見なされるように更新される。<br>
削除中のPodに対して<code>kubectl describe</code>コマンドを使用すると、Podは「終了中」と表示される。<br>
Podが実行されているNode上で、Podが終了しているとマークされている(正常な終了期間が設定されている)とkubeletが認識するとすぐに、kubeletはローカルでPodの終了プロセスを開始します。
<ol>
<li>Pod内のコンテナの1つが<code>preStop</code><a href=/ja/docs/concepts/containers/container-lifecycle-hooks/#hook-details>フック</a>を定義している場合は、コンテナの内側で呼び出される。猶予期間が終了した後も <code>preStop</code>フックがまだ実行されている場合は、一度だけ猶予期間を延長される(2秒)。
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>preStop</code>フックが完了するまでにより長い時間が必要な場合は、<code>terminationGracePeriodSeconds</code>を変更する必要があります。
</div></li>
<li>kubeletはコンテナランタイムをトリガーして、コンテナ内のプロセス番号1にTERMシグナルを送信する。
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Pod内のすべてのコンテナが同時にTERMシグナルを受信するわけではなく、シャットダウンの順序が問題になる場合はそれぞれに<code>preStop</code>フックを使用して同期することを検討する。
</div></li>
</ol>
</li>
<li>kubeletが正常な終了を開始すると同時に、コントロールプレーンは、終了中のPodをEndpoints(および有効な場合はEndpointSlice)オブジェクトから削除します。これらのオブジェクトは、<a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selector>selector</a>が設定された<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>を表します。<a class=glossary-tooltip title="ReplicaSet ensures that a specified number of Pod replicas are running at one time" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSets>ReplicaSets</a>とその他のワークロードリソースは、終了中のPodを有効なサービス中のReplicaSetとして扱いません。ゆっくりと終了するPodは、(サービスプロキシーのような)ロードバランサーが終了猶予期間が_始まる_とエンドポイントからそれらのPodを削除するので、トラフィックを継続して処理できません。</li>
<li>猶予期間が終了すると、kubeletは強制削除を開始する。コンテナランタイムは、Pod内でまだ実行中のプロセスに<code>SIGKILL</code>を送信する。kubeletは、コンテナランタイムが非表示の<code>pause</code>コンテナを使用している場合、そのコンテナをクリーンアップします。</li>
<li>kubeletは猶予期間を0(即時削除)に設定することでAPI server上のPodの削除を終了する。</li>
<li>API serverはPodのAPIオブジェクトを削除し、クライアントからは見えなくなります。</li>
</ol>
<h3 id=pod-termination-forced>Podの強制削除</h3>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> 強制削除は、Podによっては潜在的に危険な場合があるため、慎重に実行する必要があります。
</div>
<p>デフォルトでは、すべての削除は30秒以内に正常に行われます。<code>kubectl delete</code> コマンドは、ユーザーがデフォルト値を上書きして独自の値を指定できるようにする <code>--grace-period=&lt;seconds></code> オプションをサポートします。</p>
<p><code>--grace-period</code>を<code>0</code>に設定した場合、PodはAPI serverから即座に強制的に削除されます。PodがNode上でまだ実行されている場合、その強制削除によりkubeletがトリガーされ、すぐにクリーンアップが開始されます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 強制削除を実行するために <code>--grace-period=0</code> と共に <code>--force</code> というフラグを追加で指定する必要があります。
</div>
<p>強制削除が実行されると、API serverは、Podが実行されていたNode上でPodが停止されたというkubeletからの確認を待ちません。API内のPodは直ちに削除されるため、新しいPodを同じ名前で作成できるようになります。Node上では、すぐに終了するように設定されるPodは、強制終了される前にわずかな猶予期間が与えられます。</p>
<p>StatefulSetのPodについては、<a href=/ja/docs/tasks/run-application/force-delete-stateful-set-pod/>StatefulSetからPodを削除するためのタスクのドキュメント</a>を参照してください。</p>
<h3 id=pod-garbage-collection>失敗したPodのガベージコレクション</h3>
<p>失敗したPodは人間または<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>が明示的に削除するまで存在します。</p>
<p>コントロールプレーンは終了状態のPod(SucceededまたはFailedの<code>phase</code>を持つ)の数が設定された閾値(kube-controller-manager内の<code>terminated-pod-gc-threshold</code>によって定義される)を超えたとき、それらのPodを削除します。これはPodが作成されて時間とともに終了するため、リソースリークを避けます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>
<p><a href=/ja/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>attaching handlers to Container lifecycle events</a>のハンズオンをやってみる</p>
</li>
<li>
<p><a href=/ja/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>Configure Liveness, Readiness and Startup Probes</a>のハンズオンをやってみる</p>
</li>
<li>
<p><a href=/ja/docs/concepts/containers/container-lifecycle-hooks/>Container lifecycle hooks</a>についてもっと学ぶ</p>
</li>
<li>
<p>APIのPod/コンテナステータスの詳細情報は<a href=/docs/reference/generated/kubernetes-api/v1.22/#podstatus-v1-core>PodStatus</a>および<a href=/docs/reference/generated/kubernetes-api/v1.22/#containerstatus-v1-core>ContainerStatus</a>を参照してください</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1ccbd4eeded6ab138d98b59175bd557e>3.4.1.3 - Initコンテナ</h1>
<p>このページでは、Initコンテナについて概観します。Initコンテナとは、<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>内でアプリケーションコンテナの前に実行される特別なコンテナです。
Initコンテナにはアプリケーションコンテナのイメージに存在しないセットアップスクリプトやユーティリティーを含めることができます。</p>
<p>Initコンテナは、Podの仕様のうち<code>containers</code>という配列(これがアプリケーションコンテナを示します)と並べて指定します。</p>
<h2 id=understanding-init-containers>Initコンテナを理解する</h2>
<p>単一の<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>は、Pod内にアプリケーションを実行している複数のコンテナを持つことができますが、同様に、アプリケーションコンテナが起動する前に実行されるInitコンテナも1つ以上持つことができます。</p>
<p>Initコンテナは下記の項目をのぞいて、通常のコンテナと全く同じものとなります。</p>
<ul>
<li>Initコンテナは常に完了するまで稼働します。</li>
<li>各Initコンテナは、次のInitコンテナが稼働する前に正常に完了しなくてはなりません。</li>
</ul>
<p>もしあるPodの単一のInitコンテナが失敗した場合、Kubeletは成功するまで何度もそのInitコンテナを再起動します。しかし、もしそのPodの<code>restartPolicy</code>がNeverで、そのPodの起動時にInitコンテナが失敗した場合、KubernetesはそのPod全体を失敗として扱います。</p>
<p>PodにInitコンテナを指定するためには、Podの仕様にそのアプリケーションの<code>containers</code>配列と並べて、<code>initContainers</code>フィールドを<a href=/docs/reference/generated/kubernetes-api/v1.22/#container-v1-core>Container</a>型のオブジェクトの配列として指定してください。
Initコンテナのステータスは、<code>.status.initContainerStatuses</code>フィールドにコンテナのステータスの配列として返されます(<code>.status.containerStatuses</code>と同様)。</p>
<h3 id=differences-from-regular-containers>通常のコンテナとの違い</h3>
<p>Initコンテナは、リソースリミット、ボリューム、セキュリティ設定などのアプリケーションコンテナの全てのフィールドと機能をサポートしています。しかし、Initコンテナに対するリソースリクエストやリソースリミットの扱いは異なります。<a href=#resources>リソース</a>にて説明します。</p>
<p>また、InitコンテナはそのPodの準備ができる前に完了しなくてはならないため、<code>lifecycle</code>、<code>livenessProbe</code>、<code>readinessProbe</code>および<code>startupProbe</code>をサポートしていません。</p>
<p>複数のInitコンテナを単一のPodに対して指定した場合、KubeletはそれらのInitコンテナを1つずつ順番に実行します。各Initコンテナは、次のInitコンテナが稼働する前に正常終了しなくてはなりません。全てのInitコンテナの実行が完了すると、KubeletはPodのアプリケーションコンテナを初期化し、通常通り実行します。</p>
<h2 id=using-init-containers>Initコンテナを使用する</h2>
<p>Initコンテナはアプリケーションコンテナのイメージとは分離されているため、コンテナの起動に関連したコードにおいていくつかの利点があります。</p>
<ul>
<li>Initコンテナはアプリケーションのイメージに存在しないセットアップ用のユーティリティーやカスタムコードを含むことができます。例えば、セットアップ中に<code>sed</code>、<code>awk</code>、<code>python</code>や、<code>dig</code>のようなツールを使うためだけに、別のイメージを元にしてアプリケーションイメージを作る必要がなくなります。</li>
<li>アプリケーションイメージをビルドする役割とデプロイする役割は、共同で単一のアプリケーションイメージをビルドする必要がないため、それぞれ独立して実施することができます。</li>
<li>Initコンテナは同一Pod内のアプリケーションコンテナと別のファイルシステムビューで稼働することができます。その結果、アプリケーションコンテナがアクセスできない<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>に対するアクセス権限を得ることができます。</li>
<li>Initコンテナはアプリケーションコンテナが開始する前に完了するまで実行されるため、Initコンテナを使用することで、特定の前提条件が満たされるまでアプリケーションコンテナの起動をブロックしたり遅らせることができます。前提条件が満たされると、Pod内の全てのアプリケーションコンテナを並行して起動することができます。</li>
<li>Initコンテナはアプリケーションコンテナイメージの安全性を低下させるようなユーティリティーやカスタムコードを安全に実行することができます。不必要なツールを分離しておくことで、アプリケーションコンテナイメージのアタックサーフィスを制限することができます。</li>
</ul>
<h3 id=examples>例</h3>
<p>Initコンテナを活用する方法について、いくつかのアイデアを次に示します。</p>
<ul>
<li>
<p>シェルコマンドを使って単一の<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>が作成されるのを待機する。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>{</span>1..100<span style=color:#666>}</span>; <span style=color:#a2f;font-weight:700>do</span> sleep 1; <span style=color:#a2f;font-weight:700>if</span> dig myservice; <span style=color:#a2f;font-weight:700>then</span> <span style=color:#a2f>exit</span> 0; <span style=color:#a2f;font-weight:700>fi</span>; <span style=color:#a2f;font-weight:700>done</span>; <span style=color:#a2f>exit</span> <span style=color:#666>1</span>
</code></pre></div></li>
<li>
<p>以下のようなコマンドを使って下位のAPIからPodの情報をリモートサーバに登録する。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -X POST http://<span style=color:#b8860b>$MANAGEMENT_SERVICE_HOST</span>:<span style=color:#b8860b>$MANAGEMENT_SERVICE_PORT</span>/register -d <span style=color:#b44>&#39;instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)&#39;</span>
</code></pre></div></li>
<li>
<p>以下のようなコマンドを使ってアプリケーションコンテナの起動を待機する。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sleep <span style=color:#666>60</span>
</code></pre></div></li>
<li>
<p>gitリポジトリを<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=Volume>Volume</a>にクローンする。</p>
</li>
<li>
<p>いくつかの値を設定ファイルに配置し、メインのアプリケーションコンテナのための設定ファイルを動的に生成するためのテンプレートツールを実行する。例えば、そのPodの<code>POD_IP</code>の値を設定ファイルに配置し、Jinjaを使ってメインのアプリケーションコンテナの設定ファイルを生成する。</p>
</li>
</ul>
<h4 id=init-containers-in-use>Initコンテナの具体的な使用方法</h4>
<p>下記の例は2つのInitコンテナを含むシンプルなPodを定義しています。
1つ目のInitコンテナは<code>myservies</code>の起動を、2つ目のInitコンテナは<code>mydb</code>の起動をそれぞれ待ちます。両方のInitコンテナの実行が完了すると、Podは<code>spec</code>セクションにあるアプリケーションコンテナを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>myapp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo The app is running! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-myservice<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mydb<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>次のコマンドを実行して、このPodを開始できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f myapp.yaml
</code></pre></div><pre><code>pod/myapp-pod created
</code></pre><p>そして次のコマンドでステータスを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get -f myapp.yaml
</code></pre></div><pre><code>NAME        READY     STATUS     RESTARTS   AGE
myapp-pod   0/1       Init:0/2   0          6m
</code></pre><p>より詳細な情報は次のコマンドで確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe -f myapp.yaml
</code></pre></div><pre><code>Name:          myapp-pod
Namespace:     default
[...]
Labels:        app=myapp
Status:        Pending
[...]
Init Containers:
  init-myservice:
[...]
    State:         Running
[...]
  init-mydb:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Containers:
  myapp-container:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Events:
  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
  ---------    --------    -----    ----                      -------------                           --------      ------        -------
  16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
  16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image &quot;busybox&quot;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image &quot;busybox&quot;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container with docker id 5ced34a04634; Security:[seccomp=unconfined]
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container with docker id 5ced34a04634
</code></pre><p>このPod内のInitコンテナのログを確認するためには、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs myapp-pod -c init-myservice <span style=color:#080;font-style:italic># 1つ目のInitコンテナを調査する</span>
kubectl logs myapp-pod -c init-mydb      <span style=color:#080;font-style:italic># 2つ目のInitコンテナを調査する</span>
</code></pre></div><p>この時点で、これらのInitコンテナは<code>mydb</code>と<code>myservice</code>という名前のServiceの検出を待機しています。</p>
<p>これらのServiceを検出させるための構成は以下の通りです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydb<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></code></pre></div><p><code>mydb</code>および<code>myservice</code>というServiceを作成するために、以下のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f services.yaml
</code></pre></div><pre><code>service/myservice created
service/mydb created
</code></pre><p>Initコンテナが完了し、<code>myapp-pod</code>というPodがRunning状態に移行したことが確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get -f myapp.yaml
NAME        READY     STATUS    RESTARTS   AGE
myapp-pod   1/1       Running   <span style=color:#666>0</span>          9m
</code></pre></div><p>このシンプルな例を独自のInitコンテナを作成する際の参考にしてください。<a href=#whats-next>次の項目</a>にさらに詳細な使用例に関するリンクがあります。</p>
<h2 id=detailed-behavior>Initコンテナのふるまいに関する詳細</h2>
<p>Podの起動時は各Initコンテナが起動状態となるまで、kubeletはネットワーキングおよびストレージを利用可能な状態にしません。また、kubeletはPodのspecに定義された順番に従ってPodのInitコンテナを起動します。各Initコンテナは次のInitコンテナが起動する前に正常に終了しなくてはなりません。もしあるInitコンテナがランタイムもしくはエラーにより起動失敗した場合、そのPodの<code>restartPolicy</code>の値に従ってリトライされます。しかし、もしPodの<code>restartPolicy</code>が<code>Always</code>に設定されていた場合、Initコンテナの<code>restartPolicy</code>は<code>OnFailure</code>が適用されます。</p>
<p>Podは全てのInitコンテナが完了するまで<code>Ready</code>状態となりません。Initコンテナ上のポートはServiceによって集約されません。初期化中のPodのステータスは<code>Pending</code>となりますが、<code>Initialized</code>という値はtrueとなります。</p>
<p>もしそのPodが<a href=#pod-restart-reasons>再起動</a>されたとき、全てのInitコンテナは必ず再度実行されます。</p>
<p>Initコンテナの仕様の変更は、コンテナイメージのフィールドのみに制限されています。
Initコンテナのイメージフィールド値を変更すると、そのPodは再起動されます。</p>
<p>Initコンテナは何度も再起動およびリトライ可能なため、べき等(Idempotent)である必要があります。特に、<code>EmptyDirs</code>にファイルを書き込むコードは、書き込み先のファイルがすでに存在している可能性を考慮に入れる必要があります。</p>
<p>Initコンテナはアプリケーションコンテナの全てのフィールドを持っています。しかしKubernetesは、Initコンテナが完了と異なる状態を定義できないため<code>readinessProbe</code>が使用されることを禁止しています。これはバリデーションの際に適用されます。</p>
<p>Initコンテナがずっと失敗し続けたままの状態を防ぐために、Podに<code>activeDeadlineSeconds</code>を、コンテナに<code>livenessProbe</code>をそれぞれ設定してください。<code>activeDeadlineSeconds</code>の設定はInitコンテナが実行中の時間にも適用されます。</p>
<p>Pod内の各アプリケーションコンテナとInitコンテナの名前はユニークである必要があります。他のコンテナと同じ名前を共有していた場合、バリデーションエラーが返されます。</p>
<h3 id=resources>リソース</h3>
<p>Initコンテナの順序と実行を考えるとき、リソースの使用に関して下記のルールが適用されます。</p>
<ul>
<li>全てのInitコンテナの中で定義された最も高いリソースリクエストとリソースリミットが、<em>有効なinitリクエスト／リミット</em> になります。</li>
<li>Podのリソースの<em>有効なリクエスト／リミット</em> は、下記の2つの中のどちらか高い方となります。
<ul>
<li>リソースに対する全てのアプリケーションコンテナのリクエスト／リミットの合計</li>
<li>リソースに対する有効なinitリクエスト／リミット</li>
</ul>
</li>
<li>スケジューリングは有効なリクエスト／リミットに基づいて実行されます。つまり、InitコンテナはPodの生存中には使用されない初期化用のリソースを確保することができます。</li>
<li>Podの<em>有効なQoS(quality of service)ティアー</em> は、Initコンテナとアプリケーションコンテナで同様です。</li>
</ul>
<p>クォータとリミットは有効なPodリクエストとリミットに基づいて適用されます。</p>
<p>Podレベルのコントロールグループ(cgroups)は、スケジューラーと同様に、有効なPodリクエストとリミットに基づいています。</p>
<h3 id=pod-restart-reasons>Podの再起動の理由</h3>
<p>以下の理由によりPodは再起動し、Initコンテナの再実行も引き起こす可能性があります。</p>
<ul>
<li>ユーザーが、そのPodのInitコンテナのイメージを変更するようにPodの仕様を更新する場合。アプリケーションコンテナのイメージの変更はそのアプリケーションコンテナの再起動のみ行われます。</li>
<li>そのPodのインフラストラクチャーコンテナが再起動された場合。これはあまり起きるものでなく、Nodeに対するルート権限を持ったユーザーにより行われることがあります。</li>
<li><code>restartPolicy</code>が<code>Always</code>と設定されているPod内の全てのコンテナが停止され、再起動が行われた場合。およびガーベージコレクションによりInitコンテナの完了記録が失われた場合。</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/configure-pod-container/configure-pod-initialization/#creating-a-pod-that-has-an-init-container>Initコンテナを含むPodの作成</a>方法について学ぶ。</li>
<li><a href=/ja/docs/tasks/debug-application-cluster/debug-init-containers/>Initコンテナのデバッグ</a>を行う方法について学ぶ。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4e9b9cbc9776b12e7335c53da377c9c8>3.4.1.4 - Pod Preset</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.6 [alpha]</code>
</div>
<p>このページではPodPresetについて概観します。PodPresetは、Podの作成時にそのPodに対して、Secret、Volume、VolumeMountや環境変数など、特定の情報を注入するためのオブジェクトです。</p>
<h2 id=podpresetを理解する>PodPresetを理解する</h2>
<p><code>PodPreset</code>はPodの作成時に追加のランタイム要求を注入するためのAPIリソースです。ユーザーはPodPresetを適用する対象のPodを指定するために、<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルセレクター</a>を使用します。</p>
<p>PodPresetの使用により、Podテンプレートの作者はPodにおいて、全ての情報を明示的に指定する必要がなくなります。この方法により、特定のServiceを使っているPodテンプレートの作者は、そのServiceについて全ての詳細を知る必要がなくなります。</p>
<h2 id=enable-pod-preset>クラスターでPodPresetを有効にする</h2>
<p>ユーザーのクラスター内でPodPresetを使うためには、クラスター内の以下の項目をご確認ください。</p>
<ol>
<li><code>settings.k8s.io/v1alpha1/podpreset</code>というAPIを有効にします。例えば、これはAPI Serverの <code>--runtime-config</code>オプションに<code>settings.k8s.io/v1alpha1=true</code>を含むことで可能になります。Minikubeにおいては、クラスターの起動時に<code>--extra-config=apiserver.runtime-config=settings.k8s.io/v1alpha1=true</code>をつけることで可能です。</li>
<li><code>PodPreset</code>に対する管理コントローラーを有効にします。これを行うための1つの方法として、API Serverの<code>--enable-admission-plugins</code>オプションの値に<code>PodPreset</code>を含む方法があります。例えば、Minikubeにおいては、クラスターの起動時に</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--extra-config<span style=color:#666>=</span>apiserver.enable-admission-plugins<span style=color:#666>=</span>NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodPreset
</code></pre></div><p>を追加することで可能になります。</p>
<h2 id=podpresetはどのように動くか>PodPresetはどのように動くか</h2>
<p>Kubernetesは<code>PodPreset</code>に対する管理用コントローラーを提供し、これが有効になっている時、コントローラーはリクエストされたPod作成要求に対してPodPresetを適用します。Pod作成要求が発生した時、Kubernetesシステムは下記の処理を行います。</p>
<ol>
<li>使用可能な全ての<code>PodPreset</code>を取得する。</li>
<li>それらの<code>PodPreset</code>のラベルセレクターが、作成されたPod上のラベルと一致するかチェックする。</li>
<li><code>PodPreset</code>によって定義された様々なリソースを、作成されたPodにマージしようと試みる。</li>
<li>エラーが起きた時、そのPod上でマージエラーが起きたことを説明するイベントをスローし、<code>PodPreset</code>からリソースを1つも注入されていないPodを作成します。</li>
<li><code>PodPreset</code>によって修正されたことを示すために、マージ後の修正されたPodにアノテーションをつけます。そのアノテーションは<code>podpreset.admission.kubernetes.io/podpreset-&lt;PodPreset名>: "&lt;リソースのバージョン>"</code>という形式になります。</li>
</ol>
<p>各Podは0以上のPodPresetにマッチすることができます。そして各PodPresetは0以上のPodに適用されます。単一のPodPresetが1以上のPodに適用された時、KubernetesはそのPodのSpecを修正します。<code>env</code>、<code>envFrom</code>、<code>volumeMounts</code>への変更があると、KubernetesはそのPod内の全てのコンテナのSpecを修正します。<code>volumes</code>への変更があった場合、KubernetesはそのPodのSpecを修正します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>単一のPodPresetは必要に応じてPodのspec内の以下のフィールドを修正することができます。</p>
<ul>
<li><code>.spec.containers</code>フィールド</li>
<li><code>.spec.initContainers</code>フィールド</li>
</ul>
</div>
<h3 id=特定のpodに対するpodpresetを無効にする>特定のPodに対するPodPresetを無効にする</h3>
<p>PodPresetによるPodの変更を受け付けたくないようなインスタンスがある場合があります。このようなケースでは、ユーザーはそのPodの<code>.spec</code>内に次のような形式のアノテーションを追加できます。<br>
<code>podpreset.admission.kubernetes.io/exclude: "true"</code></p>
<h2 id=次の項目>次の項目</h2>
<p><a href=/docs/tasks/inject-data-application/podpreset/>PodPresetを使ったPodへのデータの注入</a></p>
<p>PodPresetの内部についてのさらなる情報は、<a href=https://git.k8s.io/community/contributors/design-proposals/service-catalog/pod-preset.md>PodPresetのデザインプロポーザル</a>を参照してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-53a1005011e1bda2ce81819aad7c8b32>3.4.1.5 - エフェメラルコンテナ</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code>
</div>
<p>このページでは、特別な種類のコンテナであるエフェメラルコンテナの概要を説明します。エフェメラルコンテナは、トラブルシューティングなどのユーザーが開始するアクションを実行するために、すでに存在する<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>内で一時的に実行するコンテナです。エフェメラルコンテナは、アプリケーションの構築ではなく、serviceの調査のために利用します。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> エフェメラルコンテナは初期のアルファ状態であり、本番クラスタには適しません。<a href=/docs/reference/using-api/deprecation-policy/>Kubernetesの非推奨ポリシー</a>に従って、このアルファ機能は、将来大きく変更されたり、完全に削除される可能性があります。
</div>
<h2 id=エフェメラルコンテナを理解する>エフェメラルコンテナを理解する</h2>
<p><a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>は、Kubernetesのアプリケーションの基本的なビルディングブロックです。Podは破棄可能かつ置き換え可能であることが想定されているため、一度Podが作成されると新しいコンテナを追加することはできません。その代わりに、通常は<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>を使用してPodを削除して置き換えます。</p>
<p>たとえば、再現困難なバグのトラブルシューティングなどのために、すでに存在するPodの状態を調査する必要が出てくることがあります。このような場合、既存のPod内でエフェメラルコンテナを実行することで、Podの状態を調査したり、任意のコマンドを実行したりできます。</p>
<h3 id=エフェメラルコンテナとは何か>エフェメラルコンテナとは何か？</h3>
<p>エフェメラルコンテナは、他のコンテナと異なり、リソースや実行が保証されず、自動的に再起動されることも決してないため、アプリケーションを構築する目的には適しません。エフェメラルコンテナは、通常のコンテナと同じ<code>ContainerSpec</code>で記述されますが、多くのフィールドに互換性がなかったり、使用できなくなっています。</p>
<ul>
<li>エフェメラルコンテナはポートを持つことができないため、<code>ports</code>、<code>livenessProbe</code>、<code>readinessProbe</code>などは使えなくなっています。</li>
<li>Podリソースの割り当てはイミュータブルであるため、<code>resources</code>の設定が禁止されています。</li>
<li>利用が許可されているフィールドの一覧については、<a href=/docs/reference/generated/kubernetes-api/v1.22/#ephemeralcontainer-v1-core>EphemeralContainerのリファレンスドキュメント</a>を参照してください。</li>
</ul>
<p>エフェメラルコンテナは、直接<code>pod.spec</code>に追加するのではなく、API内の特別な<code>ephemeralcontainers</code>ハンドラを使用して作成します。そのため、エフェメラルコンテナを<code>kubectl edit</code>を使用して追加することはできません。</p>
<p>エフェメラルコンテナをPodに追加した後は、通常のコンテナのようにエフェメラルコンテナを変更または削除することはできません。</p>
<h2 id=エフェメラルコンテナの用途>エフェメラルコンテナの用途</h2>
<p>エフェメラルコンテナは、コンテナがクラッシュしてしまったり、コンテナイメージにデバッグ用ユーティリティが同梱されていない場合など、<code>kubectl exec</code>では不十分なときにインタラクティブなトラブルシューティングを行うために役立ちます。</p>
<p>特に、<a href=https://github.com/GoogleContainerTools/distroless>distrolessイメージ</a>を利用すると、攻撃対象領域を減らし、バグや脆弱性を露出する可能性を減らせる最小のコンテナイメージをデプロイできるようになります。distrolessイメージにはシェルもデバッグ用のユーティリティも含まれないため、<code>kubectl exec</code>のみを使用してdistrolessイメージのトラブルシューティングを行うのは困難です。</p>
<p>エフェメラルコンテナを利用する場合には、他のコンテナ内のプロセスにアクセスできるように、<a href=/ja/docs/tasks/configure-pod-container/share-process-namespace/>プロセス名前空間の共有</a>を有効にすると便利です。</p>
<p>エフェメラルコンテナを利用してトラブルシューティングを行う例については、<a href=/docs/tasks/debug-application-cluster/debug-running-pod/#ephemeral-container>デバッグ用のエフェメラルコンテナを使用してデバッグする</a>を参照してください。</p>
<h2 id=ephemeral-containers-api>Ephemeral containers API</h2>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このセクションの例を実行するには、<code>EphemeralContainers</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にして、Kubernetesクライアントとサーバーのバージョンをv1.16以上にする必要があります。
</div>
<p>このセクションの例では、API内でエフェメラルコンテナを表示する方法を示します。通常は、APIを直接呼び出すのではなく、<code>kubectl alpha debug</code>やその他の<code>kubectl</code><a href=/docs/tasks/extend-kubectl/kubectl-plugins/>プラグイン</a>を使用して、これらのステップを自動化します。</p>
<p>エフェメラルコンテナは、Podの<code>ephemeralcontainers</code>サブリソースを使用して作成されます。このサブリソースは、<code>kubectl --raw</code>を使用して確認できます。まずはじめに、以下に<code>EphemeralContainers</code>リストとして追加するためのエフェメラルコンテナを示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example-pod&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>: [{
        <span style=color:green;font-weight:700>&#34;command&#34;</span>: [
            <span style=color:#b44>&#34;sh&#34;</span>
        ],
        <span style=color:green;font-weight:700>&#34;image&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>,
        <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>: <span style=color:#b44>&#34;IfNotPresent&#34;</span>,
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;debugger&#34;</span>,
        <span style=color:green;font-weight:700>&#34;stdin&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
        <span style=color:green;font-weight:700>&#34;tty&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
        <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>: <span style=color:#b44>&#34;File&#34;</span>
    }]
}
</code></pre></div><p>すでに実行中の<code>example-pod</code>のエフェメラルコンテナを更新するには、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl replace --raw /api/v1/namespaces/default/pods/example-pod/ephemeralcontainers -f ec.json
</code></pre></div><p>このコマンドを実行すると、新しいエフェメラルコンテナのリストが返されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
   <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
   <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,
   <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{
      <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;example-pod&#34;</span>,
      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span>,
      <span style=color:green;font-weight:700>&#34;selfLink&#34;</span>:<span style=color:#b44>&#34;/api/v1/namespaces/default/pods/example-pod/ephemeralcontainers&#34;</span>,
      <span style=color:green;font-weight:700>&#34;uid&#34;</span>:<span style=color:#b44>&#34;a14a6d9b-62f2-4119-9d8e-e2ed6bc3a47c&#34;</span>,
      <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>:<span style=color:#b44>&#34;15886&#34;</span>,
      <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>:<span style=color:#b44>&#34;2019-08-29T06:41:42Z&#34;</span>
   },
   <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>:[
      {
         <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;debugger&#34;</span>,
         <span style=color:green;font-weight:700>&#34;image&#34;</span>:<span style=color:#b44>&#34;busybox&#34;</span>,
         <span style=color:green;font-weight:700>&#34;command&#34;</span>:[
            <span style=color:#b44>&#34;sh&#34;</span>
         ],
         <span style=color:green;font-weight:700>&#34;resources&#34;</span>:{

         },
         <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>:<span style=color:#b44>&#34;File&#34;</span>,
         <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>:<span style=color:#b44>&#34;IfNotPresent&#34;</span>,
         <span style=color:green;font-weight:700>&#34;stdin&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>,
         <span style=color:green;font-weight:700>&#34;tty&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>
      }
   ]
}
</code></pre></div><p>新しく作成されたエフェメラルコンテナの状態を確認するには、<code>kubectl describe</code>を使用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod example-pod
</code></pre></div><pre><code>...
Ephemeral Containers:
  debugger:
    Container ID:  docker://cf81908f149e7e9213d3c3644eda55c72efaff67652a2685c1146f0ce151e80f
    Image:         busybox
    Image ID:      docker-pullable://busybox@sha256:9f1003c480699be56815db0f8146ad2e22efea85129b5b5983d0e0fb52d9ab70
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Command:
      sh
    State:          Running
      Started:      Thu, 29 Aug 2019 06:42:21 +0000
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:         &lt;none&gt;
...
</code></pre><p>新しいエフェメラルコンテナとやりとりをするには、他のコンテナと同じように、<code>kubectl attach</code>、<code>kubectl exec</code>、<code>kubectl logs</code>などのコマンドが利用できます。例えば、次のようなコマンドが実行できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl attach -it example-pod -c debugger
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-89637410cacae45a36ab1cc278c482eb>3.4.2 - ワークロードリソース</h1>
</div>
<div class=td-content>
<h1 id=pg-a2dc0393e0c4079e1c504b6429844e86>3.4.2.1 - Deployment</h1>
<p><em>Deployment</em> は<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>と<a class=glossary-tooltip title="ReplicaSet ensures that a specified number of Pod replicas are running at one time" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSet>ReplicaSet</a>の宣言的なアップデート機能を提供します。</p>
<p>Deploymentにおいて <em>理想的な状態</em> を記述すると、Deployment<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>は指定された頻度で現在の状態を理想的な状態に変更します。Deploymentを定義することによって、新しいReplicaSetを作成したり、既存のDeploymentを削除して新しいDeploymentで全てのリソースを適用できます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Deploymentによって作成されたReplicaSetを管理しないでください。ご自身のユースケースが以下の項目に含まれない場合、メインのKubernetesリポジトリーにIssueを作成することを検討してください。
</div>
<h2 id=ユースケース>ユースケース</h2>
<p>以下の項目はDeploymentの典型的なユースケースです。</p>
<ul>
<li>ReplicaSetをロールアウトするために<a href=#creating-a-deployment>Deploymentの作成</a>を行う: ReplicaSetはバックグラウンドでPodを作成します。Podの作成が完了したかどうかは、ロールアウトのステータスを確認してください。</li>
<li>DeploymentのPodTemplateSpecを更新することにより<a href=#updating-a-deployment>Podの新しい状態を宣言する</a>: 新しいReplicaSetが作成され、Deploymentは指定された頻度で古いReplicaSetから新しいReplicaSetへのPodの移行を管理します。新しいReplicaSetはDeploymentのリビジョンを更新します。</li>
<li>Deploymentの現在の状態が不安定な場合、<a href=#rolling-back-a-deployment>Deploymentのロールバック</a>をする: ロールバックによる各更新作業は、Deploymentのリビジョンを更新します。</li>
<li>より多くの負荷をさばけるように、<a href=#scaling-a-deployment>Deploymentをスケールアップ</a>する。</li>
<li>PodTemplateSpecに対する複数の修正を適用するために<a href=#pausing-and-resuming-a-deployment>Deploymentを停止(Pause)し</a>、それを再開して新しいロールアウトを開始します。</li>
<li><a href=#deployment-status>Deploymentのステータス</a> をロールアウトが失敗したサインとして利用する。</li>
<li>今後必要としない<a href=#clean-up-policy>古いReplicaSetのクリーンアップ</a></li>
</ul>
<h2 id=creating-a-deployment>Deploymentの作成</h2>
<p>以下はDeploymentの例です。これは<code>nginx</code>Podのレプリカを3つ持つReplicaSetを作成します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/nginx-deployment.yaml download=controllers/nginx-deployment.yaml><code>controllers/nginx-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-nginx-deployment-yaml')" title="Copy controllers/nginx-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-nginx-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>この例では、</p>
<ul>
<li>
<p><code>.metadata.name</code>フィールドで指定された<code>nginx-deployment</code>という名前のDeploymentが作成されます。</p>
</li>
<li>
<p>このDeploymentは<code>.spec.replicas</code>フィールドで指定された通り、3つのレプリカPodを作成します。</p>
</li>
<li>
<p><code>.spec.selector</code>フィールドは、Deploymentが管理するPodのラベルを定義します。ここでは、Podテンプレートにて定義されたラベル(<code>app: nginx</code>)を選択しています。しかし、PodTemplate自体がそのルールを満たす限り、さらに洗練された方法でセレクターを指定することができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>.spec.selector.matchLabels</code>フィールドはキーバリューペアのマップです。
<code>matchLabels</code>マップにおいて、{key, value}というペアは、keyというフィールドの値が"key"で、その演算子が"In"で、値の配列が"value"のみ含むような<code>matchExpressions</code>の要素と等しくなります。
<code>matchLabels</code>と<code>matchExpressions</code>の両方が設定された場合、条件に一致するには両方とも満たす必要があります。
</div>
</li>
<li>
<p><code>template</code>フィールドは、以下のサブフィールドを持ちます。:</p>
<ul>
<li>Podは<code>.metadata.labels</code>フィールドによって指定された<code>app: nginx</code>というラベルがつけられます。</li>
<li>PodTemplate、または<code>.template.spec</code>フィールドは、Podが<code>nginx</code>という名前で<a href=https://hub.docker.com/>Docker Hub</a>にある<code>nginx</code>のバージョン1.14.2が動くコンテナを1つ動かすことを示します。</li>
<li>1つのコンテナを作成し、<code>.spec.template.spec.containers[0].name</code>フィールドを使って<code>nginx</code>という名前をつけます。</li>
</ul>
</li>
</ul>
<p>作成を始める前に、Kubernetesクラスターが稼働していることを確認してください。
上記のDeploymentを作成するためには以下のステップにしたがってください:</p>
<ol>
<li>以下のコマンドを実行してDeploymentを作成してください。</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 実行したコマンドを<code>kubernetes.io/change-cause</code>というアノテーションに記録するために<code>--record</code>フラグを指定できます。
これは将来的な問題の調査のために有効です。例えば、各Deploymentのリビジョンにおいて実行されたコマンドを見るときに便利です。
</div>
<ol start=2>
<li>Deploymentが作成されたことを確認するために、<code>kubectl get deployments</code>を実行してください。</li>
</ol>
<p>Deploymentがまだ作成中の場合、コマンドの実行結果は以下のとおりです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   0/3     <span style=color:#666>0</span>            <span style=color:#666>0</span>           1s
</code></pre></div><p>クラスターにてDeploymentを調査するとき、以下のフィールドが出力されます。</p>
<ul>
<li><code>NAME</code>は、クラスター内にあるDeploymentの名前一覧です。</li>
<li><code>READY</code>は、ユーザーが使用できるアプリケーションのレプリカの数です。使用可能な数/理想的な数の形式で表示されます。</li>
<li><code>UP-TO-DATE</code>は、理想的な状態を満たすためにアップデートが完了したレプリカの数です。</li>
<li><code>AVAILABLE</code>は、ユーザーが利用可能なレプリカの数です。</li>
<li><code>AGE</code>は、アプリケーションが稼働してからの時間です。</li>
</ul>
<p><code>.spec.replicas</code>フィールドの値によると、理想的なレプリカ数は3であることがわかります。</p>
<ol start=3>
<li>Deploymentのロールアウトステータスを確認するために、<code>kubectl rollout status deployment.v1.apps/nginx-deployment</code>を実行してください。</li>
</ol>
<p>コマンドの実行結果は以下のとおりです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Waiting <span style=color:#a2f;font-weight:700>for</span> rollout to finish: <span style=color:#666>2</span> out of <span style=color:#666>3</span> new replicas have been updated...
deployment <span style=color:#b44>&#34;nginx-deployment&#34;</span> successfully rolled out
</code></pre></div><ol start=4>
<li>数秒後、再度<code>kubectl get deployments</code>を実行してください。
コマンドの実行結果は以下のとおりです。</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     <span style=color:#666>3</span>            <span style=color:#666>3</span>           18s
</code></pre></div><p>Deploymentが3つ全てのレプリカを作成して、全てのレプリカが最新(Podが最新のPodテンプレートを含んでいる)になり、利用可能となっていることを確認してください。</p>
<ol start=5>
<li>Deploymentによって作成されたReplicaSet(<code>rs</code>)を確認するには<code>kubectl get rs</code>を実行してください。コマンドの実行結果は以下のとおりです:</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-75675f5897   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>       18s
</code></pre></div><p>ReplicaSetの出力には次のフィールドが表示されます:</p>
<ul>
<li><code>NAME</code>は、名前空間内にあるReplicaSetの名前の一覧です。</li>
<li><code>DESIRED</code>は、アプリケーションの理想的な <em>レプリカ</em> の値です。これはDeploymentを作成したときに定義したもので、これが <em>理想的な状態</em> と呼ばれるものです。</li>
<li><code>CURRENT</code>は現在実行されているレプリカの数です。</li>
<li><code>READY</code>は、ユーザーが使用できるアプリケーションのレプリカの数です。</li>
<li><code>AGE</code>は、アプリケーションが稼働してからの時間です。</li>
</ul>
<p>ReplicaSetの名前は<code>[Deployment名]-[ランダム文字列]</code>という形式になることに注意してください。ランダム文字列はランダムに生成され、pod-template-hashをシードとして使用します。</p>
<ol start=6>
<li>各Podにラベルが自動的に付けられるのを確認するには<code>kubectl get pods --show-labels</code>を実行してください。
コマンドの実行結果は以下のとおりです:</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                                READY     STATUS    RESTARTS   AGE       LABELS
nginx-deployment-75675f5897-7ci7o   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
nginx-deployment-75675f5897-kzszj   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
nginx-deployment-75675f5897-qqcnn   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
</code></pre></div><p>作成されたReplicaSetは<code>nginx</code>Podを3つ作成することを保証します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>Deploymentに対して適切なセレクターとPodテンプレートのラベルを設定する必要があります(このケースでは<code>app: nginx</code>)。</p>
<p>ラベルやセレクターを他のコントローラーと重複させないでください(他のDeploymentやStatefulSetを含む)。Kubernetesはユーザーがラベルを重複させることを阻止しないため、複数のコントローラーでセレクターの重複が発生すると、コントローラー間で衝突し予期せぬふるまいをすることになります。</p>
</div>
<h3 id=pod-template-hashラベル>pod-template-hashラベル</h3>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> このラベルを変更しないでください。
</div>
<p><code>pod-template-hash</code>ラベルはDeploymentコントローラーによってDeploymentが作成し適用した各ReplicaSetに対して追加されます。</p>
<p>このラベルはDeploymentが管理するReplicaSetが重複しないことを保証します。このラベルはReplicaSetの<code>PodTemplate</code>をハッシュ化することにより生成され、生成されたハッシュ値はラベル値としてReplicaSetセレクター、Podテンプレートラベル、ReplicaSetが作成した全てのPodに対して追加されます。</p>
<h2 id=updating-a-deployment>Deploymentの更新</h2>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Deploymentのロールアウトは、DeploymentのPodテンプレート(この場合<code>.spec.template</code>)が変更された場合にのみトリガーされます。例えばテンプレートのラベルもしくはコンテナーイメージが更新された場合です。Deploymentのスケールのような更新では、ロールアウトはトリガーされません。
</div>
<p>Deploymentを更新するには以下のステップに従ってください。</p>
<ol>
<li>
<p>nginxのPodで、<code>nginx:1.14.2</code>イメージの代わりに<code>nginx:1.16.1</code>を使うように更新します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl --record deployment.apps/nginx-deployment <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</code></pre></div><p>または単に次のコマンドを使用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> image deployment/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1 --record
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment image updated
</code></pre><p>また、Deploymentを<code>編集</code>して、<code>.spec.template.spec.containers[0].image</code>を<code>nginx:1.14.2</code>から<code>nginx:1.16.1</code>に変更することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment edited
</code></pre></li>
<li>
<p>ロールアウトのステータスを確認するには、以下のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout status deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
</code></pre><p>もしくは</p>
<pre><code>deployment &quot;nginx-deployment&quot; successfully rolled out
</code></pre></li>
</ol>
<p>更新されたDeploymentのさらなる情報を取得するには、以下を確認してください。</p>
<ul>
<li>
<p>ロールアウトが成功したあと、<code>kubectl get deployments</code>を実行してDeploymentを確認できます。
実行結果は以下のとおりです。</p>
<pre><code>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           36s
</code></pre></li>
<li>
<p>Deploymentが新しいReplicaSetを作成してPodを更新させたり、新しいReplicaSetのレプリカを3にスケールアップさせたり、古いReplicaSetのレプリカを0にスケールダウンさせるのを確認するには<code>kubectl get rs</code>を実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         3       6s
nginx-deployment-2035384211   0         0         0       36s
</code></pre></li>
<li>
<p><code>get pods</code>を実行させると、新しいPodのみ確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1564180365-khku8   1/1       Running   0          14s
nginx-deployment-1564180365-nacti   1/1       Running   0          14s
nginx-deployment-1564180365-z9gth   1/1       Running   0          14s
</code></pre><p>次にPodを更新させたいときは、DeploymentのPodテンプレートを再度更新するだけです。</p>
<p>Deploymentは、Podが更新されている間に特定の数のPodのみ停止状態になることを保証します。デフォルトでは、目標とするPod数の少なくとも25%が停止状態になることを保証します(25% max unavailable)。</p>
<p>また、DeploymentはPodが更新されている間に、目標とするPod数を特定の数まで超えてPodを稼働させることを保証します。デフォルトでは、目標とするPod数に対して最大でも125%を超えてPodを稼働させることを保証します(25% max surge)。</p>
<p>例えば、上記で説明したDeploymentの状態を注意深く見ると、最初に新しいPodが作成され、次に古いPodが削除されるのを確認できます。十分な数の新しいPodが稼働するまでは、Deploymentは古いPodを削除しません。また十分な数の古いPodが削除しない限り新しいPodは作成されません。少なくとも2つのPodが利用可能で、最大でもトータルで4つのPodが利用可能になっていることを保証します。</p>
</li>
<li>
<p>Deploymentの詳細情報を取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployments
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision=2
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
   Containers:
    nginx:
      Image:        nginx:1.16.1
      Port:         80/TCP
      Environment:  &lt;none&gt;
      Mounts:       &lt;none&gt;
    Volumes:        &lt;none&gt;
  Conditions:
    Type           Status  Reason
    ----           ------  ------
    Available      True    MinimumReplicasAvailable
    Progressing    True    NewReplicaSetAvailable
  OldReplicaSets:  &lt;none&gt;
  NewReplicaSet:   nginx-deployment-1564180365 (3/3 replicas created)
  Events:
    Type    Reason             Age   From                   Message
    ----    ------             ----  ----                   -------
    Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica set nginx-deployment-2035384211 to 3
    Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 1
    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 2
    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 2
    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 1
    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 3
    Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 0
</code></pre><p>最初にDeploymentを作成した時、ReplicaSet(nginx-deployment-2035384211)を作成してすぐにレプリカ数を3にスケールするのを確認できます。Deploymentを更新すると新しいReplicaSet(nginx-deployment-1564180365)を作成してレプリカ数を1にスケールアップし、古いReplicaSeetを2にスケールダウンさせます。これは常に最低でも2つのPodが利用可能で、かつ最大4つのPodが作成されている状態にするためです。Deploymentは同じローリングアップ戦略に従って新しいReplicaSetのスケールアップと古いReplicaSetのスケールダウンを続けます。最終的に新しいReplicaSetを3にスケールアップさせ、古いReplicaSetを0にスケールダウンさせます。</p>
</li>
</ul>
<h3 id=ロールオーバー-リアルタイムでの複数のpodの更新>ロールオーバー (リアルタイムでの複数のPodの更新)</h3>
<p>Deploymentコントローラーにより、新しいDeploymentが観測される度にReplicaSetが作成され、理想とするレプリカ数のPodを作成します。Deploymentが更新されると、既存のReplicaSetが管理するPodのラベルが<code>.spec.selector</code>にマッチするが、テンプレートが<code>.spec.template</code>にマッチしない場合はスケールダウンされます。最終的に、新しいReplicaSetは<code>.spec.replicas</code>の値にスケールアップされ、古いReplicaSetは0にスケールダウンされます。</p>
<p>Deploymentのロールアウトが進行中にDeploymentを更新すると、Deploymentは更新する毎に新しいReplicaSetを作成してスケールアップさせ、以前にスケールアップしたReplicaSetのロールオーバーを行います。Deploymentは更新前のReplicaSetを古いReplicaSetのリストに追加し、スケールダウンを開始します。</p>
<p>例えば、5つのレプリカを持つ<code>nginx:1.14.2</code>のDeploymentを作成し、<code>nginx:1.14.2</code>の3つのレプリカが作成されているときに5つのレプリカを持つ<code>nginx:1.16.1</code>に更新します。このケースではDeploymentは作成済みの<code>nginx:1.14.2</code>の3つのPodをすぐに削除し、<code>nginx:1.16.1</code>のPodの作成を開始します。<code>nginx:1.14.2</code>の5つのレプリカを全て作成するのを待つことはありません。</p>
<h3 id=ラベルセレクターの更新>ラベルセレクターの更新</h3>
<p>通常、ラベルセレクターを更新することは推奨されません。事前にラベルセレクターの使い方を計画しておきましょう。いかなる場合であっても更新が必要なときは十分に注意を払い、変更時の影響範囲を把握しておきましょう。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>apps/v1</code>API バージョンにおいて、Deploymentのラベルセレクターは作成後に不変となります。
</div>
<ul>
<li>セレクターの追加は、Deployment Specのテンプレートラベルも新しいラベルで更新する必要があります。そうでない場合はバリデーションエラーが返されます。この変更は重複がない更新となります。これは新しいセレクターは古いセレクターを持つReplicaSetとPodを選択せず、結果として古い全てのReplicaSetがみなし子状態になり、新しいReplicaSetを作成することを意味します。</li>
<li>セレクターの更新により、セレクターキー内の既存の値が変更されます。これにより、セレクターの追加と同じふるまいをします。</li>
<li>セレクターの削除により、Deploymentのセレクターから存在している値を削除します。これはPodテンプレートのラベルに関する変更を要求しません。既存のReplicaSetはみなし子状態にならず、新しいReplicaSetは作成されませんが、削除されたラベルは既存のPodとReplicaSetでは残り続けます。</li>
</ul>
<h2 id=rolling-back-a-deployment>Deploymentのロールバック</h2>
<p>例えば、クラッシュループ状態などのようにDeploymentが不安定な場合においては、Deploymentをロールバックしたくなることがあります。Deploymentの全てのロールアウト履歴は、いつでもロールバックできるようにデフォルトでシステムに保持されています(リビジョン履歴の上限は設定することで変更可能です)。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Deploymentのリビジョンは、Deploymentのロールアウトがトリガーされた時に作成されます。これはDeploymentのPodテンプレート(<code>.spec.template</code>)が変更されたときのみ新しいリビジョンが作成されることを意味します。Deploymentのスケーリングなど、他の種類の更新においてはDeploymentのリビジョンは作成されません。これは手動もしくはオートスケーリングを同時に行うことができるようにするためです。これは過去のリビジョンにロールバックするとき、DeploymentのPodテンプレートの箇所のみロールバックされることを意味します。
</div>
<ul>
<li>
<p><code>nginx:1.16.1</code>の代わりに<code>nginx:1.161</code>というイメージに更新して、Deploymentの更新中にタイプミスをしたと仮定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.161 --record<span style=color:#666>=</span><span style=color:#a2f>true</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment image updated
</code></pre></li>
<li>
<p>このロールアウトはうまくいきません。ロールアウトのステータスを見るとそれを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout status deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>Waiting for rollout to finish: 1 out of 3 new replicas have been updated...
</code></pre></li>
<li>
<p>ロールアウトのステータスの確認は、Ctrl-Cを押すことで停止できます。ロールアウトがうまく行かないときは、<a href=#deployment-status>Deploymentのステータス</a>を読んでさらなる情報を得てください。</p>
</li>
<li>
<p>古いレプリカ数(<code>nginx-deployment-1564180365</code> and <code>nginx-deployment-2035384211</code>)が2になっていることを確認でき、新しいレプリカ数(nginx-deployment-3066724191)は1になっています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         3       25s
nginx-deployment-2035384211   0         0         0       36s
nginx-deployment-3066724191   1         1         0       6s
</code></pre></li>
<li>
<p>作成されたPodを確認していると、新しいReplicaSetによって作成された1つのPodはコンテナイメージのpullに失敗し続けているのがわかります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                                READY     STATUS             RESTARTS   AGE
nginx-deployment-1564180365-70iae   1/1       Running            0          25s
nginx-deployment-1564180365-jbqqo   1/1       Running            0          25s
nginx-deployment-1564180365-hysrc   1/1       Running            0          25s
nginx-deployment-3066724191-08mng   0/1       ImagePullBackOff   0          6s
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Deploymentコントローラーは、この悪い状態のロールアウトを自動的に停止し、新しいReplicaSetのスケールアップを止めます。これはユーザーが指定したローリングアップデートに関するパラメータ(特に<code>maxUnavailable</code>)に依存します。デフォルトではKubernetesがこの値を25%に設定します。
</div>
</li>
<li>
<p>Deploymentの詳細情報を取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>Name:           nginx-deployment
Namespace:      default
CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700
Labels:         app=nginx
Selector:       app=nginx
Replicas:       3 desired | 1 updated | 4 total | 3 available | 1 unavailable
StrategyType:       RollingUpdate
MinReadySeconds:    0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.161
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    ReplicaSetUpdated
OldReplicaSets:     nginx-deployment-1564180365 (3/3 replicas created)
NewReplicaSet:      nginx-deployment-3066724191 (1/1 replicas created)
Events:
  FirstSeen LastSeen    Count   From                    SubObjectPath   Type        Reason              Message
  --------- --------    -----   ----                    -------------   --------    ------              -------
  1m        1m          1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 1
  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 1
</code></pre><p>これを修正するために、Deploymentを安定した状態の過去のリビジョンに更新する必要があります。</p>
</li>
</ul>
<h3 id=deploymentのロールアウト履歴の確認>Deploymentのロールアウト履歴の確認</h3>
<p>ロールアウトの履歴を確認するには、以下の手順に従って下さい。</p>
<ol>
<li>
<p>最初に、Deploymentのリビジョンを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployments &quot;nginx-deployment&quot;
REVISION    CHANGE-CAUSE
1           kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml --record=true
2           kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1 --record=true
3           kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.161 --record=true
</code></pre><p><code>CHANGE-CAUSE</code>はリビジョンの作成時にDeploymentの<code>kubernetes.io/change-cause</code>アノテーションからリビジョンにコピーされます。以下の方法により<code>CHANGE-CAUSE</code>メッセージを指定できます。</p>
<ul>
<li><code>kubectl annotate deployment.v1.apps/nginx-deployment kubernetes.io/change-cause="image updated to 1.16.1"</code>の実行によりアノテーションを追加します。</li>
<li>リソースの変更時に<code>kubectl</code>コマンドの内容を記録するために<code>--record</code>フラグを追加します。</li>
<li>リソースのマニフェストを手動で編集します。</li>
</ul>
</li>
<li>
<p>各リビジョンの詳細を確認するためには以下のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment --revision<span style=color:#666>=</span><span style=color:#666>2</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployments &quot;nginx-deployment&quot; revision 2
  Labels:       app=nginx
          pod-template-hash=1159050644
  Annotations:  kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1 --record=true
  Containers:
   nginx:
    Image:      nginx:1.16.1
    Port:       80/TCP
     QoS Tier:
        cpu:      BestEffort
        memory:   BestEffort
    Environment Variables:      &lt;none&gt;
  No volumes.
</code></pre></li>
</ol>
<h3 id=rolling-back-to-a-previous-revision>過去のリビジョンにロールバックする</h3>
<p>現在のリビジョンから過去のリビジョン(リビジョン番号2)にロールバックさせるには、以下の手順に従ってください。</p>
<ol>
<li>
<p>現在のリビジョンから過去のリビジョンにロールバックします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout undo deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment rolled back
</code></pre><p>その他に、<code>--to-revision</code>を指定することにより特定のリビジョンにロールバックできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment rolled back
</code></pre><p>ロールアウトに関連したコマンドのさらなる情報は<a href=/docs/reference/generated/kubectl/kubectl-commands#rollout><code>kubectl rollout</code></a>を参照してください。</p>
<p>Deploymentが過去の安定したリビジョンにロールバックされました。Deploymentコントローラーによって、リビジョン番号2にロールバックする<code>DeploymentRollback</code>イベントが作成されたのを確認できます。</p>
</li>
<li>
<p>ロールバックが成功し、Deploymentが正常に稼働していることを確認するために、以下のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3/3     3            3           30m
</code></pre></li>
<li>
<p>Deploymentの詳細情報を取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployment nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision=4
                        kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1 --record=true
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.16.1
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &lt;none&gt;
NewReplicaSet:   nginx-deployment-c4747d96c (3/3 replicas created)
Events:
  Type    Reason              Age   From                   Message
  ----    ------              ----  ----                   -------
  Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica set nginx-deployment-75675f5897 to 3
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 1
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 2
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 2
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 1
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 3
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 0
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-595696685f to 1
  Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment &quot;nginx-deployment&quot; to revision 2
  Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica set nginx-deployment-595696685f to 0
</code></pre></li>
</ol>
<h2 id=scaling-a-deployment>Deploymentのスケーリング</h2>
<p>以下のコマンドを実行させてDeploymentをスケールできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment.v1.apps/nginx-deployment --replicas<span style=color:#666>=</span><span style=color:#666>10</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment scaled
</code></pre><p>クラスター内で<a href=/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>水平Podオートスケーラー</a>が有効になっていると仮定します。ここでDeploymentのオートスケーラーを設定し、稼働しているPodのCPU使用量に基づいて、稼働させたいPodのレプリカ数の最小値と最大値を設定できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl autoscale deployment.v1.apps/nginx-deployment --min<span style=color:#666>=</span><span style=color:#666>10</span> --max<span style=color:#666>=</span><span style=color:#666>15</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>80</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment scaled
</code></pre><h3 id=比例スケーリング>比例スケーリング</h3>
<p>Deploymentのローリングアップデートは、同時に複数のバージョンのアプリケーションの稼働をサポートします。ユーザーやオートスケーラーがローリングアップデートをロールアウト中(更新中もしくは一時停止中)のDeploymentに対して行うと、Deploymentコントローラーはリスクを削減するために既存のアクティブなReplicaSetのレプリカのバランシングを行います。これを<em>比例スケーリング</em> と呼びます。</p>
<p>レプリカ数が10、<a href=#max-surge>maxSurge</a>=3、<a href=#max-unavailable>maxUnavailable</a>=2であるDeploymentが稼働している例です。</p>
<ul>
<li>
<p>Deployment内で10のレプリカが稼働していることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deploy
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment     10        10        10           10          50s
</code></pre></li>
<li>
<p>クラスター内で、解決できない新しいイメージに更新します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:sometag
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment image updated
</code></pre></li>
<li>
<p>イメージの更新は新しいReplicaSet nginx-deployment-1989198191へのロールアウトを開始させます。しかしロールアウトは、上述した<code>maxUnavailable</code>の要求によりブロックされます。ここでロールアウトのステータスを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                          DESIRED   CURRENT   READY     AGE
nginx-deployment-1989198191   5         5         0         9s
nginx-deployment-618515232    8         8         8         1m
</code></pre></li>
<li>
<p>次にDeploymentのスケーリングをするための新しい要求が発生します。オートスケーラーはDeploymentのレプリカ数を15に増やします。Deploymentコントローラーは新しい5つのレプリカをどこに追加するか決める必要がでてきます。比例スケーリングを使用していない場合、5つのレプリカは全て新しいReplicaSetに追加されます。比例スケーリングでは、追加されるレプリカは全てのReplicaSetに分散されます。比例割合が大きいものはレプリカ数の大きいReplicaSetとなり、比例割合が低いときはレプリカ数の小さいReplicaSetとなります。残っているレプリカはもっとも大きいレプリカ数を持つReplicaSetに追加されます。レプリカ数が0のReplicaSetはスケールアップされません。</p>
</li>
</ul>
<p>上記の例では、3つのレプリカが古いReplicaSetに追加され、2つのレプリカが新しいReplicaSetに追加されました。ロールアウトの処理では、新しいレプリカ数のPodが正常になったと仮定すると、最終的に新しいReplicaSetに全てのレプリカを移動させます。これを確認するためには以下のコマンドを実行して下さい。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deploy
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                 DESIRED   CURRENT   UP-TO-DATE  AVAILABLE   AGE
nginx-deployment     15        18        7           8           7m
</code></pre><p>ロールアウトのステータスでレプリカがどのように各ReplicaSetに追加されるか確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME                          DESIRED   CURRENT  READY     AGE
nginx-deployment-1989198191   7         7        0         7m
nginx-deployment-618515232    11        11       11        7m
</code></pre><h2 id=pausing-and-resuming-a-deployment>Deployment更新の一時停止と再開</h2>
<p>ユーザーは1つ以上の更新処理をトリガーする前に更新の一時停止と再開ができます。これにより、不必要なロールアウトを実行することなく一時停止と再開を行う間に複数の修正を反映できます。</p>
<ul>
<li>
<p>例えば、作成直後のDeploymentを考えます。
Deploymentの詳細情報を確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deploy
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx     3         3         3            3           1m
</code></pre><p>ロールアウトのステータスを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   3         3         3         1m
</code></pre></li>
<li>
<p>以下のコマンドを実行して更新処理の一時停止を行います。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout pause deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment paused
</code></pre></li>
<li>
<p>次にDeploymentのイメージを更新します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.16.1
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment image updated
</code></pre></li>
<li>
<p>新しいロールアウトが開始されていないことを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployments &quot;nginx&quot;
REVISION  CHANGE-CAUSE
1   &lt;none&gt;
</code></pre></li>
<li>
<p>Deploymentの更新に成功したことを確認するためにロールアウトのステータスを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   3         3         3         2m
</code></pre></li>
<li>
<p>更新は何度でも実行できます。例えば、Deploymentが使用するリソースを更新します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>set</span> resources deployment.v1.apps/nginx-deployment -c<span style=color:#666>=</span>nginx --limits<span style=color:#666>=</span><span style=color:#b8860b>cpu</span><span style=color:#666>=</span>200m,memory<span style=color:#666>=</span>512Mi
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment resource requirements updated
</code></pre><p>一時停止する前の初期状態では更新処理は機能しますが、Deploymentが一時停止されている間は新しい更新処理は反映されません。</p>
</li>
<li>
<p>最後に、Deploymentの稼働を再開させ、新しいReplicaSetが更新内容を全て反映させているのを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout resume deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment resumed
</code></pre></li>
<li>
<p>更新処理が完了するまでロールアウトのステータスを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs -w
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   2         2         2         2m
nginx-3926361531   2         2         0         6s
nginx-3926361531   2         2         1         18s
nginx-2142116321   1         2         2         2m
nginx-2142116321   1         2         2         2m
nginx-3926361531   3         2         1         18s
nginx-3926361531   3         2         1         18s
nginx-2142116321   1         1         1         2m
nginx-3926361531   3         3         1         18s
nginx-3926361531   3         3         2         19s
nginx-2142116321   0         1         1         2m
nginx-2142116321   0         1         1         2m
nginx-2142116321   0         0         0         2m
nginx-3926361531   3         3         3         20s
</code></pre></li>
<li>
<p>最新のロールアウトのステータスを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   0         0         0         2m
nginx-3926361531   3         3         3         28s
</code></pre></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Deploymentの稼働を再開させない限り、一時停止したDeploymentをロールバックすることはできません。
</div>
<h2 id=deployment-status>Deploymentのステータス</h2>
<p>Deploymentは、そのライフサイクルの間に様々な状態に遷移します。新しいReplicaSetへのロールアウト中は<a href=#progressing-deployment>進行中</a>になり、その後は<a href=#complete-deployment>完了</a>し、また<a href=#failed-deployment>失敗</a>にもなります。</p>
<h3 id=progressing-deployment>Deploymentの更新処理</h3>
<p>以下のタスクが実行中のとき、KubernetesはDeploymentの状態を <em>進行中</em> にします。</p>
<ul>
<li>Deploymentが新しいReplicaSetを作成します。</li>
<li>Deploymentが新しいReplicaSetをスケールアップさせています。</li>
<li>Deploymentが古いReplicaSetをスケールダウンさせています。</li>
<li>新しいPodが準備中もしくは利用可能な状態になります(少なくとも<a href=#min-ready-seconds>MinReadySeconds</a>の間は準備中になります)。</li>
</ul>
<p><code>kubectl rollout status</code>を実行すると、Deploymentの進行状態を確認できます。</p>
<h3 id=complete-deployment>Deploymentの更新処理の完了</h3>
<p>Deploymentが以下の状態になったとき、KubernetesはDeploymentのステータスを <em>完了</em> にします。</p>
<ul>
<li>Deploymentの全てのレプリカが、指定された最新のバージョンに更新されます。これは指定した更新処理が完了したことを意味します。</li>
<li>Deploymentの全てのレプリカが利用可能になります。</li>
<li>Deploymentの古いレプリカが1つも稼働していません。</li>
</ul>
<p><code>kubectl rollout status</code>を実行して、Deploymentの更新が完了したことを確認できます。ロールアウトが正常に完了すると<code>kubectl rollout status</code>の終了コードが0で返されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout status deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>Waiting for rollout to finish: 2 of 3 updated replicas are available...
deployment &quot;nginx-deployment&quot; successfully rolled out
</code></pre><p>そして<code>kubectl rollout</code>の終了ステータスが0となります（成功です）:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b8860b>$?</span>
</code></pre></div><pre><code>0
</code></pre><h3 id=failed-deployment>Deploymentの更新処理の失敗</h3>
<p>新しいReplicaSetのデプロイが完了せず、更新処理が止まる場合があります。これは主に以下の要因によるものです。</p>
<ul>
<li>不十分なリソースの割り当て</li>
<li>ReadinessProbeの失敗</li>
<li>コンテナイメージの取得ができない</li>
<li>不十分なパーミッション</li>
<li>リソースリミットのレンジ</li>
<li>アプリケーションランタイムの設定の不備</li>
</ul>
<p>このような状況を検知する1つの方法として、Deploymentのリソース定義でデッドラインのパラメータを指定します(<a href=#progress-deadline-seconds><code>.spec.progressDeadlineSeconds</code></a>)。<code>.spec.progressDeadlineSeconds</code>はDeploymentの更新が停止したことを示す前にDeploymentコントローラーが待つ秒数を示します。</p>
<p>以下の<code>kubectl</code>コマンドでリソース定義に<code>progressDeadlineSeconds</code>を設定します。これはDeploymentの更新が止まってから10分後に、コントローラーが失敗を通知させるためです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch deployment.v1.apps/nginx-deployment -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;progressDeadlineSeconds&#34;:600}}&#39;</span>
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>deployment.apps/nginx-deployment patched
</code></pre><p>一度デッドラインを超過すると、DeploymentコントローラーはDeploymentの<code>.status.conditions</code>に以下のDeploymentConditionを追加します。</p>
<ul>
<li>Type=Progressing</li>
<li>Status=False</li>
<li>Reason=ProgressDeadlineExceeded</li>
</ul>
<p>ステータスの状態に関するさらなる情報は<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties>Kubernetes APIの規則</a>を参照してください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Kubernetesは停止状態のDeploymentに対して、ステータス状態を報告する以外のアクションを実行しません。高レベルのオーケストレーターはこれを利用して、状態に応じて行動できます。例えば、前のバージョンへのDeploymentのロールバックが挙げられます。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Deploymentを停止すると、Kubernetesは指定したデッドラインを超えたかどうかチェックしません。
ロールアウトの途中でもDeploymentを安全に一時停止でき、デッドラインを超えたイベントをトリガーすることなく再開できます。
</div>
<p>設定したタイムアウトの秒数が小さかったり、一時的なエラーとして扱える他の種類のエラーが原因となり、Deploymentで一時的なエラーが出る場合があります。例えば、リソースの割り当てが不十分な場合を考えます。Deploymentの詳細情報を確認すると、以下のセクションが表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployment nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>&lt;...&gt;
Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     True    ReplicaSetUpdated
  ReplicaFailure  True    FailedCreate
&lt;...&gt;
</code></pre><p><code>kubectl get deployment nginx-deployment -o yaml</code>を実行すると、Deploymentのステータスは以下のようになります。</p>
<pre><code>status:
  availableReplicas: 2
  conditions:
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: Replica set &quot;nginx-deployment-4262182780&quot; is progressing.
    reason: ReplicaSetUpdated
    status: &quot;True&quot;
    type: Progressing
  - lastTransitionTime: 2016-10-04T12:25:42Z
    lastUpdateTime: 2016-10-04T12:25:42Z
    message: Deployment has minimum availability.
    reason: MinimumReplicasAvailable
    status: &quot;True&quot;
    type: Available
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: 'Error creating: pods &quot;nginx-deployment-4262182780-&quot; is forbidden: exceeded quota:
      object-counts, requested: pods=1, used: pods=3, limited: pods=2'
    reason: FailedCreate
    status: &quot;True&quot;
    type: ReplicaFailure
  observedGeneration: 3
  replicas: 2
  unavailableReplicas: 2
</code></pre><p>最後に、一度Deploymentの更新処理のデッドラインを越えると、KubernetesはDeploymentのステータスと進行中の状態を更新します。</p>
<pre><code>Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     False   ProgressDeadlineExceeded
  ReplicaFailure  True    FailedCreate
</code></pre><p>Deploymentか他のリソースコントローラーのスケールダウンを行うか、使用している名前空間内でリソースの割り当てを増やすことで、リソースの割り当て不足の問題に対処できます。割り当て条件を満たすと、DeploymentコントローラーはDeploymentのロールアウトを完了させ、Deploymentのステータスが成功状態になるのを確認できます(<code>Status=True</code>と<code>Reason=NewReplicaSetAvailable</code>)。</p>
<pre><code>Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
</code></pre><p><code>Status=True</code>の<code>Type=Available</code>は、Deploymentが最小可用性の状態であることを意味します。最小可用性は、Deploymentの更新戦略において指定されているパラメータにより決定されます。<code>Status=True</code>の<code>Type=Progressing</code>は、Deploymentのロールアウトの途中で、更新処理が進行中であるか、更新処理が完了し、必要な最小数のレプリカが利用可能であることを意味します(各TypeのReason項目を確認してください。このケースでは、<code>Reason=NewReplicaSetAvailable</code>はDeploymentの更新が完了したことを意味します)。</p>
<p><code>kubectl rollout status</code>を実行してDeploymentが更新に失敗したかどうかを確認できます。<code>kubectl rollout status</code>はDeploymentが更新処理のデッドラインを超えたときに0以外の終了コードを返します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl rollout status deployment.v1.apps/nginx-deployment
</code></pre></div><p>実行結果は以下のとおりです。</p>
<pre><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
error: deployment &quot;nginx&quot; exceeded its progress deadline
</code></pre><p>そして<code>kubectl rollout</code>の終了ステータスが1となります(エラーを示しています):</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b8860b>$?</span>
</code></pre></div><pre><code>1
</code></pre><h3 id=失敗したdeploymentの操作>失敗したDeploymentの操作</h3>
<p>更新完了したDeploymentに適用した全てのアクションは、更新失敗したDeploymentに対しても適用されます。スケールアップ、スケールダウンができ、前のリビジョンへのロールバックや、Deploymentのテンプレートに複数の更新を適用させる必要があるときは一時停止もできます。</p>
<h2 id=clean-up-policy>古いリビジョンのクリーンアップポリシー</h2>
<p>Deploymentが管理する古いReplicaSetをいくつ保持するかを指定するために、<code>.spec.revisionHistoryLimit</code>フィールドを設定できます。この値を超えた古いReplicaSetはバックグラウンドでガーベージコレクションの対象となって削除されます。デフォルトではこの値は10です。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このフィールドを明示的に0に設定すると、Deploymentの全ての履歴を削除します。従って、Deploymentはロールバックできません。
</div>
<h2 id=カナリアパターンによるデプロイ>カナリアパターンによるデプロイ</h2>
<p>Deploymentを使って一部のユーザーやサーバーに対してリリースのロールアウトをしたい場合、<a href=/ja/docs/concepts/cluster-administration/manage-deployment/#canary-deployments-%E3%82%AB%E3%83%8A%E3%83%AA%E3%82%A2%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4>リソースの管理</a>に記載されているカナリアパターンに従って、リリース毎に1つずつ、複数のDeploymentを作成できます。</p>
<h2 id=deployment-specの記述>Deployment Specの記述</h2>
<p>他の全てのKubernetesの設定と同様に、Deploymentは<code>.apiVersion</code>、<code>.kind</code>や<code>.metadata</code>フィールドを必要とします。
設定ファイルの利用に関する情報は<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>アプリケーションのデプロイ</a>を参照してください。コンテナーの設定に関しては<a href=/ja/docs/concepts/overview/working-with-objects/object-management/>リソースを管理するためのkubectlの使用</a>を参照してください。
Deploymentオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>でなければなりません。
Deploymentは<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code>セクション</a>も必要とします。</p>
<h3 id=podテンプレート>Podテンプレート</h3>
<p><code>.spec.template</code>と<code>.spec.selector</code>は<code>.spec</code>における必須のフィールドです。</p>
<p><code>.spec.template</code>は<a href=/docs/concepts/workloads/pods/#pod-templates>Podテンプレート</a>です。これは.spec内でネストされていないことと、<code>apiVersion</code>や<code>kind</code>を持たないことを除いては<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>と同じスキーマとなります。</p>
<p>Podの必須フィールドに加えて、Deployment内のPodテンプレートでは適切なラベルと再起動ポリシーを設定しなくてはなりません。ラベルは他のコントローラーと重複しないようにしてください。ラベルについては、<a href=#selector>セレクター</a>を参照してください。</p>
<p><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>.spec.template.spec.restartPolicy</code></a>が<code>Always</code>に等しいときのみ許可されます。これはテンプレートで指定されていない場合のデフォルト値です。</p>
<h3 id=レプリカ数>レプリカ数</h3>
<p><code>.spec.replias</code>は理想的なPodの数を指定するオプションのフィールドです。デフォルトは1です。</p>
<h3 id=selector>セレクター</h3>
<p><code>.spec.selector</code>は必須フィールドで、Deploymentによって対象とされるPodの<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベルセレクター</a>を指定します。</p>
<p><code>.spec.selector</code>は<code>.spec.template.metadata.labels</code>と一致している必要があり、一致しない場合はAPIによって拒否されます。</p>
<p><code>apps/v1</code>バージョンにおいて、<code>.spec.selector</code>と<code>.metadata.labels</code>が指定されていない場合、<code>.spec.template.metadata.labels</code>の値に初期化されません。そのため<code>.spec.selector</code>と<code>.metadata.labels</code>を明示的に指定する必要があります。また<code>apps/v1</code>のDeploymentにおいて<code>.spec.selector</code>は作成後に不変になります。</p>
<p>Deploymentのテンプレートが<code>.spec.template</code>と異なる場合や、<code>.spec.replicas</code>の値を超えてPodが稼働している場合、Deploymentはセレクターに一致するラベルを持つPodを削除します。Podの数が理想状態より少ない場合Deploymentは<code>.spec.template</code>をもとに新しいPodを作成します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Deploymentのセレクターに一致するラベルを持つPodを直接作成したり、他のDeploymentやReplicaSetやReplicationControllerによって作成するべきではありません。作成してしまうと、最初のDeploymentがラベルに一致する新しいPodを作成したとみなされます。こうなったとしても、Kubernetesは処理を止めません。
</div>
<p>セレクターが重複する複数のコントローラーを持つとき、そのコントローラーは互いに競合状態となり、正しくふるまいません。</p>
<h3 id=更新戦略>更新戦略</h3>
<p><code>.spec.strategy</code>は古いPodから新しいPodに置き換える際の更新戦略を指定します。<code>.spec.strategy.type</code>は"Recreate"もしくは"RollingUpdate"を指定できます。デフォルトは"RollingUpdate"です。</p>
<h4 id=deploymentの再作成>Deploymentの再作成</h4>
<p><code>.spec.strategy.type==Recreate</code>と指定されているとき、既存の全てのPodは新しいPodが作成される前に削除されます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> これは更新のための作成の前にPodを停止する事を保証するだけです。Deploymentを更新する場合、古いリビジョンのPodは全てすぐに停止されます。削除に成功するまでは、新しいリビジョンのPodは作成されません。手動でPodを削除すると、ライフサイクルがReplicaSetに制御されているのですぐに置き換えが実施されます（たとえ古いPodがまだ停止中のステータスでも）。Podに"高々この程度の"保証を求めるならば<a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>の使用を検討してください。
</div>
<h4 id=deploymentのローリングアップデート>Deploymentのローリングアップデート</h4>
<p><code>.spec.strategy.type==RollingUpdate</code>と指定されているとき、DeploymentはローリングアップデートによりPodを更新します。ローリングアップデートの処理をコントロールするために<code>maxUnavailable</code>と<code>maxSurge</code>を指定できます。</p>
<h5 id=max-unavailable>Max Unavailable</h5>
<p><code>.spec.strategy.rollingUpdate.maxUnavailable</code>はオプションのフィールドで、更新処理において利用不可となる最大のPod数を指定します。値は絶対値(例: 5)を指定するか、理想状態のPodのパーセンテージを指定します(例: 10%)。パーセンテージを指定した場合、絶対値は小数切り捨てされて計算されます。<code>.spec.strategy.rollingUpdate.maxSurge</code>が0に指定されている場合、この値を0にできません。デフォルトでは25%です。</p>
<p>例えば、この値が30%と指定されているとき、ローリングアップデートが開始すると古いReplicaSetはすぐに理想状態の70%にスケールダウンされます。一度新しいPodが稼働できる状態になると、古いReplicaSetはさらにスケールダウンされ、続いて新しいReplicaSetがスケールアップされます。この間、利用可能なPodの総数は理想状態のPodの少なくとも70%以上になるように保証されます。</p>
<h5 id=max-surge>Max Surge</h5>
<p><code>.spec.strategy.rollingUpdate.maxSurge</code>はオプションのフィールドで、理想状態のPod数を超えて作成できる最大のPod数を指定します。値は絶対値(例: 5)を指定するか、理想状態のPodのパーセンテージを指定します(例: 10%)。パーセンテージを指定した場合、絶対値は小数切り上げで計算されます。<code>MaxUnavailable</code>が0に指定されている場合、この値を0にできません。デフォルトでは25%です。</p>
<p>例えば、この値が30%と指定されているとき、ローリングアップデートが開始すると新しいReplicaSetはすぐに更新されます。このとき古いPodと新しいPodの総数は理想状態の130%を超えないように更新されます。一度古いPodが削除されると、新しいReplicaSetはさらにスケールアップされます。この間、利用可能なPodの総数は理想状態のPodに対して最大130%になるように保証されます。</p>
<h3 id=progress-deadline-seconds>Progress Deadline Seconds</h3>
<p><code>.spec.progressDeadlineSeconds</code>はオプションのフィールドで、システムがDeploymentの<a href=#failed-deployment>更新に失敗</a>したと判断するまでに待つ秒数を指定します。更新に失敗したと判断されたとき、リソースのステータスは<code>Type=Progressing</code>、<code>Status=False</code>かつ<code>Reason=ProgressDeadlineExceeded</code>となるのを確認できます。DeploymentコントローラーはDeploymentの更新のリトライし続けます。デフォルト値は600です。今後、自動的なロールバックが実装されたとき、更新失敗状態になるとすぐにDeploymentコントローラーがロールバックを行うようになります。</p>
<p>この値が指定されているとき、<code>.spec.minReadySeconds</code>より大きい値を指定する必要があります。</p>
<h3 id=min-ready-seconds>Min Ready Seconds</h3>
<p><code>.spec.minReadySeconds</code>はオプションのフィールドで、新しく作成されたPodが利用可能となるために、最低どれくらいの秒数コンテナーがクラッシュすることなく稼働し続ければよいかを指定するものです。デフォルトでは0です(Podは作成されるとすぐに利用可能と判断されます)。Podが利用可能と判断された場合についてさらに学ぶために<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>Container Probes</a>を参照してください。</p>
<h3 id=リビジョン履歴の保持上限>リビジョン履歴の保持上限</h3>
<p>Deploymentのリビジョン履歴は、Deploymentが管理するReplicaSetに保持されています。</p>
<p><code>.spec.revisionHistoryLimit</code>はオプションのフィールドで、ロールバック可能な古いReplicaSetの数を指定します。この古いReplicaSetは<code>etcd</code>内のリソースを消費し、<code>kubectl get rs</code>の出力結果を見にくくします。Deploymentの各リビジョンの設定はReplicaSetに保持されます。このため一度古いReplicaSetが削除されると、そのリビジョンのDeploymentにロールバックすることができなくなります。デフォルトでは10もの古いReplicaSetが保持されます。しかし、この値の最適値は新しいDeploymentの更新頻度と安定性に依存します。</p>
<p>さらに詳しく言うと、この値を0にすると、0のレプリカを持つ古い全てのReplicaSetが削除されます。このケースでは、リビジョン履歴が完全に削除されているため新しいDeploymentのロールアウトを元に戻すことができません。</p>
<h3 id=paused>paused</h3>
<p><code>.spec.paused</code>はオプションのboolean値で、Deploymentの一時停止と再開のための値です。一時停止されているものと、そうでないものとの違いは、一時停止されているDeploymentはPodTemplateSpecのいかなる変更があってもロールアウトがトリガーされないことです。デフォルトではDeploymentは一時停止していない状態で作成されます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d459b930218774655fa7fd1620625539>3.4.2.2 - ReplicaSet</h1>
<p>ReplicaSetの目的は、どのような時でも安定したレプリカPodのセットを維持することです。これは、理想的なレプリカ数のPodが利用可能であることを保証するものとして使用されます。</p>
<h2 id=replicasetがどのように動くか>ReplicaSetがどのように動くか</h2>
<p>ReplicaSetは、ReplicaSetが対象とするPodをどう特定するかを示すためのセレクターや、稼働させたいPodのレプリカ数、Podテンプレート(理想のレプリカ数の条件を満たすために作成される新しいPodのデータを指定するために用意されるもの)といったフィールドとともに定義されます。ReplicaSetは、指定された理想のレプリカ数にするためにPodの作成と削除を行うことにより、その目的を達成します。ReplicaSetが新しいPodを作成するとき、ReplicaSetはそのPodテンプレートを使用します。</p>
<p>ReplicaSetがそのPod群と連携するためのリンクは、Podの<a href=/ja/docs/concepts/workloads/controllers/garbage-collection/#owners-and-dependents>metadata.ownerReferences</a>というフィールド(現在のオブジェクトが所有されているリソースを指定する)を介して作成されます。ReplicaSetによって所持された全てのPodは、それらの<code>ownerReferences</code>フィールドにReplicaSetを特定する情報を保持します。このリンクを通じて、ReplicaSetは管理しているPodの状態を把握したり、その後の実行計画を立てます。</p>
<p>ReplicaSetは、そのセレクターを使用することにより、所有するための新しいPodを特定します。もし<code>ownerReference</code>フィールドの値を持たないPodか、<code>ownerReference</code>フィールドの値が <a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>でないPodで、そのPodがReplicaSetのセレクターとマッチした場合に、そのPodは即座にそのReplicaSetによって所有されます。</p>
<h2 id=replicasetを使うとき>ReplicaSetを使うとき</h2>
<p>ReplicaSetはどんな時でも指定された数のPodのレプリカが稼働することを保証します。しかし、DeploymentはReplicaSetを管理する、より上位レベルの概念で、Deploymentはその他の多くの有益な機能と共に、宣言的なPodのアップデート機能を提供します。それゆえ、我々はユーザーが独自のアップデートオーケストレーションを必要としたり、アップデートを全く必要としないような場合を除いて、ReplicaSetを直接使うよりも代わりにDeploymentを使うことを推奨します。</p>
<p>これは、ユーザーがReplicaSetのオブジェクトを操作する必要が全く無いことを意味します。
代わりにDeploymentを使用して、<code>spec</code>セクションにユーザーのアプリケーションを定義してください。</p>
<h2 id=replicasetの使用例>ReplicaSetの使用例</h2>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/frontend.yaml download=controllers/frontend.yaml><code>controllers/frontend.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-frontend-yaml')" title="Copy controllers/frontend.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-frontend-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># modify replicas according to your case</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[frontend]}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-redis<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_samples/gb-frontend:v3<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>GET_HOSTS_FROM<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>dns<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># If your cluster config does not include a dns service, then to</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># instead access environment variables to find service host</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># info, comment out the &#39;value: dns&#39; line above, and uncomment the</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># line below.</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># value: env</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>上記のマニフェストを<code>frontend.yaml</code>ファイルに保存しKubernetesクラスターに適用すると、マニフェストに定義されたReplicaSetとそれが管理するPod群を作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f http://k8s.io/examples/controllers/frontend.yaml
</code></pre></div><p>ユーザーはデプロイされた現在のReplicaSetの情報も取得できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get rs
</code></pre></div><p>そして、ユーザーが作成したfrontendリソースについての情報も取得できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME       DESIRED   CURRENT   READY   AGE
frontend   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>       6s
</code></pre></div><p>ユーザーはまたReplicaSetの状態も確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe rs/frontend
</code></pre></div><p>その結果は以下のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Name:		frontend
Namespace:	default
Selector:	<span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
Labels:		<span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook
		<span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
Annotations:	kubectl.kubernetes.io/last-applied-configuration:
                <span style=color:#666>{</span><span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;apps/v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;ReplicaSet&#34;</span>,<span style=color:#b44>&#34;metadata&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;annotations&#34;</span>:<span style=color:#666>{}</span>,<span style=color:#b44>&#34;labels&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;app&#34;</span>:<span style=color:#b44>&#34;guestbook&#34;</span>,<span style=color:#b44>&#34;tier&#34;</span>:<span style=color:#b44>&#34;frontend&#34;</span><span style=color:#666>}</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;frontend&#34;</span>,...
Replicas:	<span style=color:#666>3</span> current / <span style=color:#666>3</span> desired
Pods Status:	<span style=color:#666>3</span> Running / <span style=color:#666>0</span> Waiting / <span style=color:#666>0</span> Succeeded / <span style=color:#666>0</span> Failed
Pod Template:
  Labels:  <span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
  Containers:
   php-redis:
    Image:        gcr.io/google_samples/gb-frontend:v3
    Port:         &lt;none&gt;
    Host Port:    &lt;none&gt;
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Events:
  Type    Reason            Age   From                   Message
  ----    ------            ----  ----                   -------
  Normal  SuccessfulCreate  117s  replicaset-controller  Created pod: frontend-wtsmm
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-b2zdv
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-vcmts
</code></pre></div><p>そして最後に、ユーザーはReplicaSetによって作成されたPodもチェックできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>表示されるPodに関する情報は以下のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME             READY   STATUS    RESTARTS   AGE
frontend-b2zdv   1/1     Running   <span style=color:#666>0</span>          6m36s
frontend-vcmts   1/1     Running   <span style=color:#666>0</span>          6m36s
frontend-wtsmm   1/1     Running   <span style=color:#666>0</span>          6m36s
</code></pre></div><p>ユーザーはまた、それらのPodの<code>ownerReferences</code>が<code>frontend</code>ReplicaSetに設定されていることも確認できます。
これを確認するためには、稼働しているPodの中のどれかのyamlファイルを取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods frontend-b2zdv -o yaml
</code></pre></div><p>その表示結果は、以下のようになります。その<code>frontend</code>ReplicaSetの情報が<code>metadata</code>の<code>ownerReferences</code>フィールドにセットされています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: <span style=color:#b44>&#34;2020-02-12T07:06:16Z&#34;</span>
  generateName: frontend-
  labels:
    tier: frontend
  name: frontend-b2zdv
  namespace: default
  ownerReferences:
  - apiVersion: apps/v1
    blockOwnerDeletion: <span style=color:#a2f>true</span>
    controller: <span style=color:#a2f>true</span>
    kind: ReplicaSet
    name: frontend
    uid: f391f6db-bb9b-4c09-ae74-6a1f77f3d5cf
...
</code></pre></div><h2 id=テンプレートなしのpodの所有>テンプレートなしのPodの所有</h2>
<p>ユーザーが問題なくベアPod(Bare Pod: ここではPodテンプレート無しのPodのこと)を作成しているとき、そのベアPodがユーザーのReplicaSetの中のいずれのセレクターともマッチしないことを確認することを強く推奨します。
この理由として、ReplicaSetは、所有対象のPodがReplicaSetのテンプレートによって指定されたPodのみに限定されていないからです(ReplicaSetは前のセクションで説明した方法によって他のPodも所有できます)。</p>
<p>前のセクションで取り上げた<code>frontend</code>ReplicaSetと、下記のマニフェストのPodをみてみます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-rs.yaml download=pods/pod-rs.yaml><code>pods/pod-rs.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-rs-yaml')" title="Copy pods/pod-rs.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-rs-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:2.0<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:1.0<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>これらのPodは<code>ownerReferences</code>に何のコントローラー(もしくはオブジェクト)も指定されておらず、そして<code>frontend</code>ReplicaSetにマッチするセレクターをもっており、これらのPodは即座に<code>frontend</code>ReplicaSetによって所有されます。</p>
<p>この<code>frontend</code>ReplicaSetがデプロイされ、初期のPodレプリカがレプリカ数の要求を満たすためにセットアップされた後で、ユーザーがそのPodを作成することを考えます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f http://k8s.io/examples/pods/pod-rs.yaml
</code></pre></div><p>新しいPodはそのReplicaSetによって所有され、そのReplicaSetのレプリカ数が、設定された理想のレプリカ数を超えた場合すぐにそれらのPodは削除されます。</p>
<p>下記のコマンドでPodを取得できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>その表示結果で、新しいPodがすでに削除済みか、削除中のステータスになっているのを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME             READY   STATUS        RESTARTS   AGE
frontend-b2zdv   1/1     Running       <span style=color:#666>0</span>          10m
frontend-vcmts   1/1     Running       <span style=color:#666>0</span>          10m
frontend-wtsmm   1/1     Running       <span style=color:#666>0</span>          10m
pod1             0/1     Terminating   <span style=color:#666>0</span>          1s
pod2             0/1     Terminating   <span style=color:#666>0</span>          1s
</code></pre></div><p>もしユーザーがそのPodを最初に作成する場合</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f http://k8s.io/examples/pods/pod-rs.yaml
</code></pre></div><p>そしてその後に<code>frontend</code>ReplicaSetを作成すると、</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f http://k8s.io/examples/controllers/frontend.yaml
</code></pre></div><p>ユーザーはそのReplicaSetが作成したPodを所有し、さらにもともと存在していたPodと今回新たに作成されたPodの数が、理想のレプリカ数になるまでPodを作成するのを確認できます。
ここでまたPodの状態を取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>取得結果は下記のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME             READY   STATUS    RESTARTS   AGE
frontend-hmmj2   1/1     Running   <span style=color:#666>0</span>          9s
pod1             1/1     Running   <span style=color:#666>0</span>          36s
pod2             1/1     Running   <span style=color:#666>0</span>          36s
</code></pre></div><p>この方法で、ReplicaSetはテンプレートで指定されたもの以外のPodを所有することができます。</p>
<h2 id=replicasetのマニフェストを記述する>ReplicaSetのマニフェストを記述する。</h2>
<p>他の全てのKubernetes APIオブジェクトのように、ReplicaSetは<code>apiVersion</code>、<code>kind</code>と<code>metadata</code>フィールドを必要とします。
ReplicaSetでは、<code>kind</code>フィールドの値は<code>ReplicaSet</code>です。
Kubernetes1.9において、ReplicaSetは<code>apps/v1</code>というAPIバージョンが現在のバージョンで、デフォルトで有効です。<code>apps/v1beta2</code>というAPIバージョンは廃止されています。先ほど作成した<code>frontend.yaml</code>ファイルの最初の行を参考にしてください。</p>
<p>ReplicaSetオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<p>また、ReplicaSetは<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code> セクション</a>も必須です。</p>
<h3 id=pod-テンプレート>Pod テンプレート</h3>
<p><code>.spec.template</code>はラベルを持つことが必要な<a href=/ja/docs/concepts/workloads/pods/#pod%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88>Pod テンプレート</a> です。先ほど作成した<code>frontend.yaml</code>の例では、<code>tier: frontend</code>というラベルを1つ持っています。
他のコントローラーがこのPodを所有しようとしないためにも、他のコントローラーのセレクターでラベルを上書きしないように注意してください。</p>
<p>テンプレートの<a href=/docs/concepts/workloads/Pods/pod-lifecycle/#restart-policy>再起動ポリシー</a>のためのフィールドである<code>.spec.template.spec.restartPolicy</code>は<code>Always</code>のみ許可されていて、そしてそれがデフォルト値です。</p>
<h3 id=pod-セレクター>Pod セレクター</h3>
<p><code>.spec.selector</code>フィールドは<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベルセレクター</a>です。
<a href=#how-a-replicaset-works>先ほど</a>議論したように、ReplicaSetが所有するPodを指定するためにそのラベルが使用されます。
先ほどの<code>frontend.yaml</code>の例では、そのセレクターは下記のようになっていました</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></code></pre></div><p>そのReplicaSetにおいて、<code>.spec.template.metadata.labels</code>フィールドの値は<code>spec.selector</code>と一致しなくてはならず、一致しない場合はAPIによって拒否されます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 2つのReplicaSetが同じ<code>.spec.selector</code>の値を設定しているが、それぞれ異なる<code>.spec.template.metadata.labels</code>と<code>.spec.template.spec</code>フィールドの値を持っていたとき、それぞれのReplicaSetはもう一方のReplicaSetによって作成されたPodを無視します。
</div>
<h3 id=レプリカ数について>レプリカ数について</h3>
<p>ユーザーは<code>.spec.replicas</code>フィールドの値を設定することにより、いくつのPodを同時に稼働させるか指定できます。そのときReplicaSetはレプリカ数がこの値に達するまでPodを作成、または削除します。</p>
<p>もしユーザーが<code>.spec.replicas</code>を指定しない場合、デフォルト値として1がセットされます。</p>
<h2 id=replicasetを利用する>ReplicaSetを利用する</h2>
<h3 id=replicasetとpodの削除>ReplicaSetとPodの削除</h3>
<p>ReplicaSetとそれが所有する全てのPod削除したいときは、<a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>コマンドを使ってください。<br>
<a href=/ja/docs/concepts/workloads/controllers/garbage-collection/>ガベージコレクター</a>がデフォルトで自動的に全ての依存するPodを削除します。</p>
<p>REST APIもしくは<code>client-go</code>ライブラリーを使用するとき、ユーザーは<code>-d</code>オプションで<code>propagationPolicy</code>を<code>Background</code>か<code>Foreground</code>と指定しなくてはなりません。
例えば下記のように実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div><h3 id=replicasetのみを削除する>ReplicaSetのみを削除する</h3>
<p>ユーザーは<a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>コマンドで<code>--cascade=false</code>オプションを付けることにより、所有するPodに影響を与えることなくReplicaSetを削除できます。
REST APIもしくは<code>client-go</code>ライブラリーを使用するとき、ユーザーは<code>-d</code>オプションで<code>propagationPolicy</code>を<code>Orphan</code>と指定しなくてはなりません。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div><p>一度元のReplicaSetが削除されると、ユーザーは新しいものに置き換えるため新しいReplicaSetを作ることができます。新旧のReplicaSetの<code>.spec.selector</code>の値が同じである間、新しいReplicaSetは古いReplicaSetで稼働していたPodを取り入れます。
しかし、存在するPodが新しく異なるPodテンプレートとマッチさせようとするとき、この仕組みは機能しません。
ユーザーのコントロール下において新しいspecのPodをアップデートしたい場合は、<a href=#rolling-updates>ローリングアップデート</a>を使用してください。</p>
<h3 id=podをreplicasetから分離させる>PodをReplicaSetから分離させる</h3>
<p>ユーザーはPodのラベルを変更することにより、ReplicaSetからそのPodを削除できます。この手法はデバッグや、データ修復などのためにサービスからPodを削除したいときに使用できます。
この方法で削除されたPodは自動的に新しいものに置き換えられます。(レプリカ数は変更されないものと仮定します。)</p>
<h3 id=replicasetのスケーリング>ReplicaSetのスケーリング</h3>
<p>ReplicaSetは、ただ<code>.spec.replicas</code>フィールドを更新することによって簡単にスケールアップまたはスケールダウンできます。ReplicaSetコントローラーは、ラベルセレクターにマッチするような指定した数のPodが利用可能であり、操作可能であることを保証します。</p>
<h3 id=horizontalpodautoscaler-hpa-のターゲットとしてのreplicaset>HorizontalPodAutoscaler(HPA)のターゲットとしてのReplicaSet</h3>
<p>ReplicaSetはまた、<a href=/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscalers (HPA)</a>のターゲットにもなることができます。
これはつまりReplicaSetがHPAによってオートスケールされうることを意味します。
ここではHPAが、前の例で作成したReplicaSetをターゲットにする例を示します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/hpa-rs.yaml download=controllers/hpa-rs.yaml><code>controllers/hpa-rs.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-hpa-rs-yaml')" title="Copy controllers/hpa-rs.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-hpa-rs-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-scaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>このマニフェストを<code>hpa-rs.yaml</code>に保存し、Kubernetesクラスターに適用すると、レプリケートされたPodのCPU使用量にもとづいてターゲットのReplicaSetをオートスケールするHPAを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/controllers/hpa-rs.yaml
</code></pre></div><p>同様のことを行うための代替案として、<code>kubectl autoscale</code>コマンドも使用できます。(こちらの方がより簡単です。)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl autoscale rs frontend --max<span style=color:#666>=</span><span style=color:#666>10</span> --min<span style=color:#666>=</span><span style=color:#666>3</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span>
</code></pre></div><h2 id=replicasetの代替案>ReplicaSetの代替案</h2>
<h3 id=deployment-推奨>Deployment (推奨)</h3>
<p><a href=/ja/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>はReplicaSetを所有することのできるオブジェクトで、宣言的なサーバサイドのローリングアップデートを介してReplicaSetとPodをアップデートできます。
ReplicaSetは単独で使用可能ですが、現在では、ReplicaSetは主にPodの作成、削除とアップデートを司るためのメカニズムとしてDeploymentによって使用されています。ユーザーがDeploymentを使用するとき、Deploymentによって作成されるReplicaSetの管理について心配する必要はありません。DeploymentはReplicaSetを所有し、管理します。
このため、もしユーザーがReplicaSetを必要とするとき、Deploymentの使用を推奨します。</p>
<h3 id=ベアpod-bare-pods>ベアPod(Bare Pods)</h3>
<p>ユーザーがPodを直接作成するケースとは異なり、ReplicaSetはNodeの故障やカーネルのアップグレードといった破壊的なNodeのメンテナンスなど、どのような理由に限らず削除または停止されたPodを置き換えます。
このため、我々はもしユーザーのアプリケーションが単一のPodのみ必要とする場合でもReplicaSetを使用することを推奨します。プロセスのスーパーバイザーについても同様に考えると、それは単一Node上での独立したプロセスの代わりに複数のNodeにまたがった複数のPodを監視します。
ReplicaSetは、Node上のいくつかのエージェント(例えば、KubeletやDocker）に対して、ローカルのコンテナ再起動を移譲します。</p>
<h3 id=job>Job</h3>
<p>PodをPodそれ自身で停止させたいような場合(例えば、バッチ用のジョブなど)は、ReplicaSetの代わりに<a href=/docs/concepts/workloads/controllers/job/><code>Job</code></a>を使用してください。</p>
<h3 id=daemonset>DaemonSet</h3>
<p>マシンの監視やロギングなど、マシンレベルの機能を提供したい場合は、ReplicaSetの代わりに<a href=/ja/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>を使用してください。
これらのPodはマシン自体のライフタイムに紐づいています: そのPodは他のPodが起動する前に、そのマシン上で稼働される必要があり、マシンが再起動またはシャットダウンされるときには、安全に停止されます。</p>
<h3 id=replicationcontroller>ReplicationController</h3>
<p>ReplicaSetは<a href=/docs/concepts/workloads/controllers/replicationcontroller/><em>ReplicationControllers</em></a>の後継となるものです。
この2つは、ReplicationControllerが<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルについてのユーザーガイド</a>に書かれているように、集合ベース(set-based)のセレクター要求をサポートしていないことを除いては、同じ目的を果たし、同じようにふるまいます。<br>
このように、ReplicaSetはReplicationControllerよりも好まれます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6d72299952c37ca8cc61b416e5bdbcd4>3.4.2.3 - StatefulSet</h1>
<p>StatefulSetはステートフルなアプリケーションを管理するためのワークロードAPIです。</p>
<p>StatefulSetはDeploymentと<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>のセットのスケーリングを管理し、それらのPodの<em>順序と一意性を保証</em> します。</p>
<p><a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>のように、StatefulSetは指定したコンテナのspecに基づいてPodを管理します。Deploymentとは異なり、StatefulSetは各Podにおいて管理が大変な同一性を維持します。これらのPodは同一のspecから作成されますが、それらは交換可能ではなく、リスケジュール処理をまたいで維持される永続的な識別子を持ちます。</p>
<p>ワークロードに永続性を持たせるためにストレージボリュームを使いたい場合は、解決策の1つとしてStatefulSetが利用できます。StatefulSet内の個々のPodは障害の影響を受けやすいですが、永続化したPodの識別子は既存のボリュームと障害によって置換された新しいPodの紐付けを簡単にします。</p>
<h2 id=statefulsetの使用>StatefulSetの使用</h2>
<p>StatefulSetは下記の1つ以上の項目を要求するアプリケーションにおいて最適です。</p>
<ul>
<li>安定した一意のネットワーク識別子</li>
<li>安定した永続ストレージ</li>
<li>規則的で安全なデプロイとスケーリング</li>
<li>規則的で自動化されたローリングアップデート</li>
</ul>
<p>上記において安定とは、Podのスケジュール(または再スケジュール)をまたいでも永続的であることと同義です。
もしアプリケーションが安定したネットワーク識別子と規則的なデプロイや削除、スケーリングを全く要求しない場合、ユーザーはステートレスなレプリカのセットを提供するワークロードを使ってアプリケーションをデプロイするべきです。
<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>や<a href=/ja/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>のようなコントローラーはこのようなステートレスな要求に対して最適です。</p>
<h2 id=制限事項>制限事項</h2>
<ul>
<li>提供されたPodのストレージは、要求された<code>storage class</code>にもとづいて<a href=https://github.com/kubernetes/examples/tree/v1.22.16/staging/persistent-volume-provisioning/README.md>PersistentVolume Provisioner</a>によってプロビジョンされるか、管理者によって事前にプロビジョンされなくてはなりません。</li>
<li>StatefulSetの削除もしくはスケールダウンをすることにより、StatefulSetに関連したボリュームは削除<em>されません</em> 。 これはデータ安全性のためで、関連するStatefulSetのリソース全てを自動的に削除するよりもたいてい有効です。</li>
<li>StatefulSetは現在、Podのネットワークアイデンティティーに責務をもつために<a href=/ja/docs/concepts/services-networking/service/#headless-service>Headless Service</a>を要求します。ユーザーはこのServiceを作成する責任があります。</li>
<li>StatefulSetは、StatefulSetが削除されたときにPodの停止を行うことを保証していません。StatefulSetにおいて、規則的で安全なPodの停止を行う場合、削除のために事前にそのStatefulSetの数を0にスケールダウンさせることが可能です。</li>
<li>デフォルト設定の<a href=#pod-management-policies>Pod管理ポリシー</a> (<code>OrderedReady</code>)によって<a href=#rolling-updates>ローリングアップデート</a>を行う場合、<a href=#forced-rollback>修復のための手動介入</a>を要求するようなブロークンな状態に遷移させることが可能です。</li>
</ul>
<h2 id=コンポーネント>コンポーネント</h2>
<p>下記の例は、StatefulSetのコンポーネントのデモンストレーションとなります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># .spec.template.metadata.labelsの値と一致する必要があります</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginx&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># by default is 1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># .spec.selector.matchLabelsの値と一致する必要があります</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/nginx-slim:0.8<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-storage-class&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></code></pre></div><p>上記の例では、</p>
<ul>
<li>nginxという名前のHeadlessServiceは、ネットワークドメインをコントロールするために使われます。</li>
<li>webという名前のStatefulSetは、specで3つのnginxコンテナのレプリカを持ち、そのコンテナはそれぞれ別のPodで稼働するように設定されています。</li>
<li>volumeClaimTemplatesは、PersistentVolumeプロビジョナーによってプロビジョンされた<a href=/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>を使って安定したストレージを提供します。</li>
</ul>
<p>StatefulSetの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>名前</a>である必要があります。</p>
<h2 id=podセレクター>Podセレクター</h2>
<p>ユーザーは、StatefulSetの<code>.spec.template.metadata.labels</code>のラベルと一致させるため、StatefulSetの<code>.spec.selector</code>フィールドをセットしなくてはなりません。Kubernetes1.8以前では、<code>.spec.selector</code>フィールドは省略された場合デフォルト値になります。Kubernetes1.8とそれ以降のバージョンでは、ラベルに一致するPodセレクターの指定がない場合はStatefulSetの作成時にバリデーションエラーになります。</p>
<h2 id=podアイデンティティー>Podアイデンティティー</h2>
<p>StatefulSetのPodは、順番を示す番号、安定したネットワークアイデンティティー、安定したストレージからなる一意なアイデンティティーを持ちます。
そのアイデンティティーはどのNode上にスケジュール(もしくは再スケジュール)されるかに関わらず、そのPodに紐付きます。</p>
<h3 id=順序インデックス>順序インデックス</h3>
<p>N個のレプリカをもったStatefulSetにおいて、StatefulSet内の各Podは、0からはじまりN-1までの整数値を順番に割り当てられ、そのStatefulSetにおいては一意となります。</p>
<h3 id=安定したネットワークid>安定したネットワークID</h3>
<p>StatefulSet内の各Podは、そのStatefulSet名とPodの順序番号から派生してホストネームが割り当てられます。
作成されたホストネームの形式は<code>$(StatefulSet名)-$(順序番号)</code>となります。先ほどの上記の例では、<code>web-0,web-1,web-2</code>という3つのPodが作成されます。
StatefulSetは、Podのドメインをコントロールするために<a href=/ja/docs/concepts/services-networking/service/#headless-service>Headless Service</a>を使うことができます。
このHeadless Serviceによって管理されたドメインは<code>$(Service名).$(ネームスペース).svc.cluster.local</code>形式となり、"cluster.local"というのはそのクラスターのドメインとなります。
各Podが作成されると、Podは<code>$(Pod名).$(管理するServiceドメイン名)</code>に一致するDNSサブドメインを取得し、管理するServiceはStatefulSetの<code>serviceName</code>で定義されます。</p>
<p>クラスターでのDNSの設定方法によっては、新たに起動されたPodのDNS名をすぐに検索できない場合があります。
この動作は、クラスター内の他のクライアントが、Podが作成される前にそのPodのホスト名に対するクエリーをすでに送信していた場合に発生する可能性があります。
(DNSでは通常)ネガティブキャッシュは、Podの起動後でも、少なくとも数秒間、以前に失敗したルックアップの結果が記憶され、再利用されることを意味します。</p>
<p>Podが作成された後、速やかにPodを検出する必要がある場合は、いくつかのオプションがあります。</p>
<ul>
<li>DNSルックアップに依存するのではなく、Kubernetes APIに直接(例えばwatchを使って)問い合わせる。</li>
<li>Kubernetes DNS プロバイダーのキャッシュ時間を短縮する(これは現在30秒キャッシュされるようになっているCoreDNSのConfigMapを編集することを意味しています。)。</li>
</ul>
<p><a href=#%E5%88%B6%E9%99%90%E4%BA%8B%E9%A0%85>制限事項</a>セクションで言及したように、ユーザーはPodのネットワークアイデンティティーのために<a href=/ja/docs/concepts/services-networking/service/#headless-service>Headless Service</a>を作成する責任があります。</p>
<p>ここで、クラスタードメイン、Service名、StatefulSet名の選択と、それらがStatefulSetのPodのDNS名にどう影響するかの例をあげます。</p>
<table>
<thead>
<tr>
<th>Cluster Domain</th>
<th>Service (ns/name)</th>
<th>StatefulSet (ns/name)</th>
<th>StatefulSet Domain</th>
<th>Pod DNS</th>
<th>Pod Hostname</th>
</tr>
</thead>
<tbody>
<tr>
<td>cluster.local</td>
<td>default/nginx</td>
<td>default/web</td>
<td>nginx.default.svc.cluster.local</td>
<td>web-{0..N-1}.nginx.default.svc.cluster.local</td>
<td>web-{0..N-1}</td>
</tr>
<tr>
<td>cluster.local</td>
<td>foo/nginx</td>
<td>foo/web</td>
<td>nginx.foo.svc.cluster.local</td>
<td>web-{0..N-1}.nginx.foo.svc.cluster.local</td>
<td>web-{0..N-1}</td>
</tr>
<tr>
<td>kube.local</td>
<td>foo/nginx</td>
<td>foo/web</td>
<td>nginx.foo.svc.kube.local</td>
<td>web-{0..N-1}.nginx.foo.svc.kube.local</td>
<td>web-{0..N-1}</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> クラスタードメインは<a href=/ja/docs/concepts/services-networking/dns-pod-service/>その他の設定</a>がされない限り、<code>cluster.local</code>にセットされます。
</div>
<h3 id=安定したストレージ>安定したストレージ</h3>
<p>Kubernetesは各VolumeClaimTemplateに対して、1つの<a href=/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>を作成します。上記のnginxの例において、各Podは<code>my-storage-class</code>というStorageClassをもち、1Gibのストレージ容量を持った単一のPersistentVolumeを受け取ります。もしStorageClassが指定されていない場合、デフォルトのStorageClassが使用されます。PodがNode上にスケジュール(もしくは再スケジュール)されたとき、その<code>volumeMounts</code>はPersistentVolume Claimに関連したPersistentVolumeをマウントします。
注意点として、PodのPersistentVolume Claimと関連したPersistentVolumeは、PodやStatefulSetが削除されたときに削除されません。
削除する場合は手動で行わなければなりません。</p>
<h3 id=podのネームラベル>Podのネームラベル</h3>
<p>StatefulSet <a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a> がPodを作成したとき、Podの名前として、<code>statefulset.kubernetes.io/pod-name</code>にラベルを追加します。このラベルによってユーザーはServiceにStatefulSet内の指定したPodを割り当てることができます。</p>
<h2 id=デプロイとスケーリングの保証>デプロイとスケーリングの保証</h2>
<ul>
<li>N個のレプリカをもつStatefulSetにおいて、Podがデプロイされるとき、それらのPodは{0..N-1}の番号で順番に作成されます。</li>
<li>Podが削除されるとき、それらのPodは{N-1..0}の番号で降順に削除されます。</li>
<li>Podに対してスケーリングオプションが適用される前に、そのPodの前の順番の全てのPodがRunningかつReady状態になっていなくてはなりません。</li>
<li>Podが停止される前に、そのPodの番号より大きい番号を持つの全てのPodは完全にシャットダウンされていなくてはなりません。</li>
</ul>
<p>StatefulSetは<code>pod.Spec.TerminationGracePeriodSeconds</code>を0に指定すべきではありません。これは不安全で、やらないことを強く推奨します。さらなる説明としては、<a href=/ja/docs/tasks/run-application/force-delete-stateful-set-pod/>StatefulSetのPodの強制削除</a>を参照してください。</p>
<p>上記の例のnginxが作成されたとき、3つのPodは<code>web-0</code>、<code>web-1</code>、<code>web-2</code>の順番でデプロイされます。<code>web-1</code>は<code>web-0</code>が<a href=/docs/concepts/workloads/pods/pod-lifecycle/>RunningかつReady状態</a>になるまでは決してデプロイされないのと、同様に<code>web-2</code>は<code>web-1</code>がRunningかつReady状態にならないとデプロイされません。もし<code>web-0</code>が<code>web-1</code>がRunningかつReady状態になった後だが、<code>web-2</code>が起動する前に失敗した場合、<code>web-2</code>は<code>web-0</code>の再起動が成功し、RunningかつReady状態にならないと再起動されません。</p>
<p>もしユーザーが<code>replicas=1</code>といったようにStatefulSetにパッチをあてることにより、デプロイされたものをスケールすることになった場合、<code>web-2</code>は最初に停止されます。<code>web-1</code>は<code>web-2</code>が完全にシャットダウンされ削除されるまでは、停止されません。もし<code>web-0</code>が、<code>web-2</code>が完全に停止され削除された後だが、<code>web-1</code>の停止の前に失敗した場合、<code>web-1</code>は<code>web-0</code>がRunningかつReady状態になるまでは停止されません。</p>
<h3 id=podの管理ポリシー>Podの管理ポリシー</h3>
<p>Kubernetes1.7とそれ以降のバージョンでは、StatefulSetは<code>.spec.podManagementPolicy</code>フィールドを介して、Podの一意性とアイデンティティーを保証します。</p>
<h4 id=orderedreadyなpod管理>OrderedReadyなPod管理</h4>
<p><code>OrderedReady</code>なPod管理はStatefulSetにおいてデフォルトです。これは<a href=#deployment-and-scaling-guarantees>デプロイとスケーリングの保証</a>に記載されている項目の振る舞いを実装します。</p>
<h4 id=並行なpod管理>並行なPod管理</h4>
<p><code>Parallel</code>なPod管理は、StatefulSetコントローラーに対して、他のPodが起動や停止される前にそのPodが完全に起動し準備完了になるか停止するのを待つことなく、Podが並行に起動もしくは停止するように指示します。</p>
<h2 id=アップデートストラテジー>アップデートストラテジー</h2>
<p>Kubernetes1.7とそれ以降のバージョンにおいて、StatefulSetの<code>.spec.updateStrategy</code>フィールドで、コンテナの自動のローリングアップデートの設定やラベル、リソースのリクエストとリミットや、StatefulSet内のPodのアノテーションを指定できます。</p>
<h3 id=ondelete>OnDelete</h3>
<p><code>OnDelete</code>というアップデートストラテジーは、レガシーな(Kubernetes1.6以前)振る舞いとなります。StatefulSetの<code>.spec.updateStrategy.type</code>が<code>OnDelete</code>にセットされていたとき、そのStatefulSetコントローラーはStatefulSet内でPodを自動的に更新しません。StatefulSetの<code>.spec.template</code>項目の修正を反映した新しいPodの作成をコントローラーに支持するためには、ユーザーは手動でPodを削除しなければなりません。</p>
<h3 id=rollingupdate>RollingUpdate</h3>
<p><code>RollingUpdate</code>というアップデートストラテジーは、StatefulSet内のPodに対する自動化されたローリングアップデートの機能を実装します。これは<code>.spec.updateStrategy</code>フィールドが未指定の場合のデフォルトのストラテジーです。StatefulSetの<code>.spec.updateStrategy.type</code>が<code>RollingUpdate</code>にセットされたとき、そのStatefulSetコントローラーは、StatefulSet内のPodを削除し、再作成します。これはPodの停止(Podの番号の降順)と同じ順番で、一度に1つのPodを更新します。コントローラーは、その前のPodの状態がRunningかつReady状態になるまで次のPodの更新を待ちます。</p>
<h4 id=パーティション>パーティション</h4>
<p><code>RollingUpdate</code>というアップデートストラテジーは、<code>.spec.updateStrategy.rollingUpdate.partition</code>を指定することにより、パーティションに分けることができます。もしパーティションが指定されていたとき、そのパーティションの値と等しいか、大きい番号を持つPodが更新されます。パーティションの値より小さい番号を持つPodは更新されず、たとえそれらのPodが削除されたとしても、それらのPodは以前のバージョンで再作成されます。もしStatefulSetの<code>.spec.updateStrategy.rollingUpdate.partition</code>が、<code>.spec.replicas</code>より大きい場合、<code>.spec.template</code>への更新はPodに反映されません。
多くのケースの場合、ユーザーはパーティションを使う必要はありませんが、もし一部の更新を行う場合や、カナリー版のバージョンをロールアウトする場合や、段階的ロールアウトを行う場合に最適です。</p>
<h4 id=強制ロールバック>強制ロールバック</h4>
<p>デフォルトの<a href=#pod-management-policies>Pod管理ポリシー</a>(<code>OrderedReady</code>)による<a href=#rolling-updates>ローリングアップデート</a>を行う際、修復のために手作業が必要な状態にすることが可能です。</p>
<p>もしユーザーが、決してRunningかつReady状態にならないような設定になるようにPodテンプレートを更新した場合(例えば、不正なバイナリや、アプリケーションレベルの設定エラーなど)、StatefulSetはロールアウトを停止し、待機します。</p>
<p>この状態では、Podテンプレートを正常な状態に戻すだけでは不十分です。<a href=https://github.com/kubernetes/kubernetes/issues/67250>既知の問題</a>によって、StatefulSetは元の正常な状態へ戻す前に、壊れたPodがReady状態(決して起こりえない)に戻るのを待ち続けます。</p>
<p>そのテンプレートを戻したあと、ユーザーはまたStatefulSetが異常状態で稼働しようとしていたPodをすべて削除する必要があります。StatefulSetはその戻されたテンプレートを使ってPodの再作成を始めます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tutorials/stateful-application/basic-stateful-set/>ステートフルなアプリケーションのデプロイ</a>の例を参考にしてください。</li>
<li><a href=/docs/tutorials/stateful-application/cassandra/>StatefulSetを使ったCassandraのデプロイ</a>の例を参考にしてください。</li>
<li><a href=/ja/docs/tasks/run-application/run-replicated-stateful-application/>レプリカを持つステートフルアプリケーションを実行する</a>の例を参考にしてください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-41600eb8b6631c88848156f381e9d588>3.4.2.4 - DaemonSet</h1>
<p><em>DaemonSet</em> は全て(またはいくつか)のNodeが単一のPodのコピーを稼働させることを保証します。Nodeがクラスターに追加されるとき、PodがNode上に追加されます。Nodeがクラスターから削除されたとき、それらのPodはガーベージコレクターにより除去されます。DaemonSetの削除により、DaemonSetが作成したPodもクリーンアップします。</p>
<p>DaemonSetのいくつかの典型的な使用例は以下の通りです。</p>
<ul>
<li>クラスターのストレージデーモンを全てのNode上で稼働させる。</li>
<li>ログ集計デーモンを全てのNode上で稼働させる。</li>
<li>Nodeのモニタリングデーモンを全てのNode上で稼働させる。</li>
</ul>
<p>シンプルなケースとして、各タイプのデーモンにおいて、全てのNodeをカバーする1つのDaemonSetが使用されるケースがあります。さらに複雑な設定では、単一のタイプのデーモン用ですが、異なるフラグや、異なるハードウェアタイプに対するメモリー、CPUリクエストを要求する複数のDaemonSetを使用するケースもあります。</p>
<h2 id=daemonset-specの記述>DaemonSet Specの記述</h2>
<h3 id=daemonsetの作成>DaemonSetの作成</h3>
<p>ユーザーはYAMLファイル内でDaemonSetの設定を記述することができます。例えば、下記の<code>daemonset.yaml</code>ファイルでは<code>fluentd-elasticsearch</code>というDockerイメージを稼働させるDaemonSetの設定を記述します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/daemonset.yaml download=controllers/daemonset.yaml><code>controllers/daemonset.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-daemonset-yaml')" title="Copy controllers/daemonset.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-daemonset-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>fluentd-logging<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Exists<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>quay.io/fluentd_elasticsearch/fluentd:v2.5.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>YAMLファイルに基づいてDaemonSetを作成します。</p>
<pre><code>kubectl apply -f https://k8s.io/examples/controllers/daemonset.yaml
</code></pre><h3 id=必須のフィールド>必須のフィールド</h3>
<p>他の全てのKubernetesの設定と同様に、DaemonSetは<code>apiVersion</code>、<code>kind</code>と<code>metadata</code>フィールドが必須となります。設定ファイルの活用法に関する一般的な情報は、<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>ステートレスアプリケーションの稼働</a>、<a href=/ja/docs/tasks/>コンテナの設定</a>、<a href=/ja/docs/concepts/overview/working-with-objects/object-management/>kubectlを用いたオブジェクトの管理</a>といったドキュメントを参照ください。</p>
<p>DaemonSetオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<p>また、DaemonSetにおいて<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code></a>セクションも必須となります。</p>
<h3 id=podテンプレート>Podテンプレート</h3>
<p><code>.spec.template</code>は<code>.spec</code>内での必須のフィールドの1つです。</p>
<p><code>.spec.template</code>は<a href=/docs/concepts/workloads/pods/#pod-templates>Podテンプレート</a>となります。これはフィールドがネストされていて、<code>apiVersion</code>や<code>kind</code>をもたないことを除いては、<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>のテンプレートと同じスキーマとなります。</p>
<p>Podに対する必須のフィールドに加えて、DaemonSet内のPodテンプレートは適切なラベルを指定しなくてはなりません(<a href=#pod-selector>Podセレクター</a>の項目を参照ください)。</p>
<p>DaemonSet内のPodテンプレートでは、<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>RestartPolicy</code></a>フィールドを指定せずにデフォルトの<code>Always</code>を使用するか、明示的に<code>Always</code>を設定するかのどちらかである必要があります。</p>
<h3 id=podセレクター>Podセレクター</h3>
<p><code>.spec.selector</code>フィールドはPodセレクターとなります。これは<a href=/docs/concepts/workloads/controllers/job/>Job</a>の<code>.spec.selector</code>と同じものです。</p>
<p>Kubernetes1.8のように、ユーザーは<code>.spec.template</code>のラベルにマッチするPodセレクターを指定しなくてはいけません。Podセレクターは、値を空のままにしてもデフォルト設定にならなくなりました。セレクターのデフォルト化は<code>kubectl apply</code>と互換性はありません。また、一度DaemonSetが作成されると、その<code>.spec.selector</code>は変更不可能になります。Podセレクターの変更は、意図しないPodの孤立を引き起こし、ユーザーにとってやっかいなものとなります。</p>
<p><code>.spec.selector</code>は2つのフィールドからなるオブジェクトです。</p>
<ul>
<li><code>matchLabels</code> - <a href=/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>の<code>.spec.selector</code>と同じように機能します。</li>
<li><code>matchExpressions</code> - キーと、値のリストとさらにはそれらのキーとバリューに関連したオペレーターを指定することにより、より洗練された形式のセレクターを構成できます。</li>
</ul>
<p>上記の2つが指定された場合は、2つの条件をANDでどちらも満たすものを結果として返します。</p>
<p>もし<code>spec.selector</code>が指定されたとき、<code>.spec.template.metadata.labels</code>とマッチしなければなりません。この2つの値がマッチしない設定をした場合、APIによってリジェクトされます。</p>
<h3 id=選択したnode上でpodを稼働させる>選択したNode上でPodを稼働させる</h3>
<p>もしユーザーが<code>.spec.template.spec.nodeSelector</code>を指定したとき、DaemonSetコントローラーは、その<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>node
selector</a>にマッチするPodをNode上に作成します。同様に、もし<code>.spec.template.spec.affinity</code>を指定したとき、DaemonSetコントローラーは<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>node affinity</a>マッチするPodをNode上に作成します。
もしユーザーがどちらも指定しないとき、DaemonSetコントローラーは全てのNode上にPodを作成します。</p>
<h2 id=daemon-podがどのようにスケジューリングされるか>Daemon Podがどのようにスケジューリングされるか</h2>
<h3 id=デフォルトスケジューラーによってスケジューリングされる場合>デフォルトスケジューラーによってスケジューリングされる場合</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<p>DaemonSetは全ての利用可能なNodeが単一のPodのコピーを稼働させることを保証します。通常、Podが稼働するNodeはKubernetesスケジューラーによって選択されます。しかし、DaemonSetのPodは代わりにDaemonSetコントローラーによって作成され、スケジューリングされます。<br>
下記の問題について説明します:</p>
<ul>
<li>矛盾するPodのふるまい: スケジューリングされるのを待っている通常のPodは、作成されているが<code>Pending</code>状態となりますが、DaemonSetのPodは<code>Pending</code>状態で作成されません。これはユーザーにとって困惑するものです。</li>
<li><a href=/docs/concepts/configuration/pod-priority-preemption/>Podプリエンプション(Pod preemption)</a>はデフォルトスケジューラーによってハンドルされます。もしプリエンプションが有効な場合、そのDaemonSetコントローラーはPodの優先順位とプリエンプションを考慮することなくスケジューリングの判断を行います。</li>
</ul>
<p><code>ScheduleDaemonSetPods</code>は、DaemonSetのPodに対して<code>NodeAffinity</code>項目を追加することにより、DaemonSetコントローラーの代わりにデフォルトスケジューラーを使ってDaemonSetのスケジュールを可能にします。その際に、デフォルトスケジューラーはPodをターゲットのホストにバインドします。もしDaemonSetのNodeAffinityが存在するとき、それは新しいものに置き換えられます(ターゲットホストを選択する前に、元のNodeAffinityが考慮されます)。DaemonSetコントローラーはDaemonSetのPodの作成や修正を行うときのみそれらの操作を実施します。そしてDaemonSetの<code>.spec.template</code>フィールドに対しては何も変更が加えられません。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>matchFields</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- target-host-name<span style=color:#bbb>
</span></code></pre></div><p>さらに、<code>node.kubernetes.io/unschedulable:NoSchedule</code>というtolarationがDaemonSetのPodに自動的に追加されます。デフォルトスケジューラーは、DaemonSetのPodのスケジューリングのときに、<code>unschedulable</code>なNodeを無視します。</p>
<h3 id=taintsとtolerations>TaintsとTolerations</h3>
<p>DaemonSetのPodは<a href=/docs/concepts/scheduling-eviction/taint-and-toleration/>TaintsとTolerations</a>の設定を尊重します。下記のTolerationsは、関連する機能によって自動的にDaemonSetのPodに追加されます。</p>
<table>
<thead>
<tr>
<th>Toleration Key</th>
<th>Effect</th>
<th>Version</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>node.kubernetes.io/not-ready</code></td>
<td>NoExecute</td>
<td>1.13+</td>
<td>DaemonSetのPodはネットワーク分割のようなNodeの問題が発生したときに除外されません。</td>
</tr>
<tr>
<td><code>node.kubernetes.io/unreachable</code></td>
<td>NoExecute</td>
<td>1.13+</td>
<td>DaemonSetのPodはネットワーク分割のようなNodeの問題が発生したときに除外されません。</td>
</tr>
<tr>
<td><code>node.kubernetes.io/disk-pressure</code></td>
<td>NoSchedule</td>
<td>1.8+</td>
<td></td>
</tr>
<tr>
<td><code>node.kubernetes.io/memory-pressure</code></td>
<td>NoSchedule</td>
<td>1.8+</td>
<td></td>
</tr>
<tr>
<td><code>node.kubernetes.io/unschedulable</code></td>
<td>NoSchedule</td>
<td>1.12+</td>
<td>DaemonSetのPodはデフォルトスケジューラーによってスケジュール不可能な属性を許容(tolerate)します。</td>
</tr>
<tr>
<td><code>node.kubernetes.io/network-unavailable</code></td>
<td>NoSchedule</td>
<td>1.12+</td>
<td>ホストネットワークを使うDaemonSetのPodはデフォルトスケジューラーによってネットワーク利用不可能な属性を許容(tolerate)します。</td>
</tr>
</tbody>
</table>
<h2 id=daemon-podとのコミュニケーション>Daemon Podとのコミュニケーション</h2>
<p>DaemonSet内のPodとのコミュニケーションをする際に考えられるパターンは以下の通りです。:</p>
<ul>
<li><strong>Push</strong>: DaemonSet内のPodは他のサービスに対して更新情報を送信するように設定されます。</li>
<li><strong>NodeIPとKnown Port</strong>: PodがNodeIPを介して疎通できるようにするため、DaemonSet内のPodは<code>hostPort</code>を使用できます。慣例により、クライアントはNodeIPのリストとポートを知っています。</li>
<li><strong>DNS</strong>: 同じPodセレクターを持つ<a href=/ja/docs/concepts/services-networking/service/#headless-service>HeadlessService</a>を作成し、<code>endpoints</code>リソースを使ってDaemonSetを探すか、DNSから複数のAレコードを取得します。</li>
<li><strong>Service</strong>: 同じPodセレクターを持つServiceを作成し、複数のうちのいずれかのNode上のDaemonに疎通させるためにそのServiceを使います。</li>
</ul>
<h2 id=daemonsetの更新>DaemonSetの更新</h2>
<p>もしNodeラベルが変更されたとき、そのDaemonSetは直ちに新しくマッチしたNodeにPodを追加し、マッチしなくなったNodeからPodを削除します。</p>
<p>ユーザーはDaemonSetが作成したPodを修正可能です。しかし、Podは全てのフィールドの更新を許可していません。また、DaemonSetコントローラーは次のNode(同じ名前でも)が作成されたときにオリジナルのテンプレートを使ってPodを作成します。</p>
<p>ユーザーはDaemonSetを削除可能です。<code>kubectl</code>コマンドで<code>--cascade=false</code>を指定するとDaemonSetのPodはNode上に残り続けます。その後、同じセレクターで新しいDaemonSetを作成すると、新しいDaemonSetは既存のPodを再利用します。PodでDaemonSetを置き換える必要がある場合は、<code>updateStrategy</code>に従ってそれらを置き換えます。</p>
<p>ユーザーはDaemonSet上で<a href=/docs/tasks/manage-daemon/update-daemon-set/>ローリングアップデートの実施</a>が可能です。</p>
<h2 id=daemonsetの代替案>DaemonSetの代替案</h2>
<h3 id=initスクリプト>Initスクリプト</h3>
<p>Node上で直接起動することにより(例: <code>init</code>、<code>upstartd</code>、<code>systemd</code>を使用する)、デーモンプロセスを稼働することが可能です。この方法は非常に良いですが、このようなプロセスをDaemonSetを介して起動することはいくつかの利点があります。</p>
<ul>
<li>アプリケーションと同じ方法でデーモンの監視とログの管理ができる。</li>
<li>デーモンとアプリケーションで同じ設定用の言語とツール(例: Podテンプレート、<code>kubectl</code>)を使える。</li>
<li>リソースリミットを使ったコンテナ内でデーモンを稼働させることにより、デーモンとアプリケーションコンテナの分離を促進します。しかし、これはPod内でなく、コンテナ内でデーモンを稼働させることにより可能です(Dockerを介して直接起動する)。</li>
</ul>
<h3 id=ベアpod>ベアPod</h3>
<p>特定のNode上で稼働するように指定したPodを直接作成することは可能です。しかし、DaemonSetはNodeの故障やNodeの破壊的なメンテナンスやカーネルのアップグレードなど、どのような理由に限らず、削除されたもしくは停止されたPodを置き換えます。このような理由で、ユーザーはPod単体を作成するよりもむしろDaemonSetを使うべきです。</p>
<h3 id=静的pod-pods>静的Pod Pods</h3>
<p>Kubeletによって監視されているディレクトリに対してファイルを書き込むことによって、Podを作成することが可能です。これは<a href=/docs/tasks/configure-pod-container/static-pod/>静的Pod</a>と呼ばれます。DaemonSetと違い、静的Podはkubectlや他のKubernetes APIクライアントで管理できません。静的PodはApiServerに依存しておらず、クラスターの自立起動時に最適です。また、静的Podは将来的には廃止される予定です。</p>
<h3 id=deployment>Deployment</h3>
<p>DaemonSetは、Podの作成し、そのPodが停止されることのないプロセスを持つことにおいて<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>と同様です(例: webサーバー、ストレージサーバー)。</p>
<p>フロントエンドのようなServiceのように、どのホスト上にPodが稼働するか制御するよりも、レプリカ数をスケールアップまたはスケールダウンしたりローリングアップデートする方が重要であるような、状態をもたないServiceに対してDeploymentを使ってください。
Podのコピーが全てまたは特定のホスト上で常に稼働していることが重要な場合や、他のPodの前に起動させる必要があるときにDaemonSetを使ってください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9add0d2120634b63073ad08dc8683bd6>3.4.2.5 - ガベージコレクション</h1>
<p>Kubernetesのガベージコレクターの役割は、かつてオーナーがいたが、現時点でもはやオーナーがいないようなオブジェクトの削除を行うことです。</p>
<h2 id=owners-and-dependents>オーナーとその従属オブジェクト</h2>
<p>いくつかのKubernetesオブジェクトは他のオブジェクトのオーナーとなります。例えば、ReplicaSetはPodのセットに対するオーナーです。オーナーによって所有されたオブジェクトは、オーナーオブジェクトの<em>従属オブジェクト(Dependents)</em> と呼ばれます。全ての従属オブジェクトは、オーナーオブジェクトを指し示す<code>metadata.ownerReferences</code>というフィールドを持ちます。</p>
<p>時々、Kubernetesは<code>ownerReference</code>フィールドに値を自動的にセットします。例えば、ユーザーがReplicaSetを作成したとき、KubernetesはReplicaSet内の各Podの<code>ownerReference</code>フィールドに自動的に値をセットします。Kubernetes1.8において、KubernetesはReplicaController、ReplicaSet、StatefulSet、DaemonSet、Deployment、Job、CronJobによって作成され、適用されたオブジェクトの<code>ownerReference</code>フィールドに自動的にその値をセットします。</p>
<p>ユーザーはまた<code>ownerReference</code>フィールドに手動で値をセットすることにより、オーナーと従属オブジェクト間の関係を指定することができます。</p>
<p>下記の例は、3つのPodを持つReplicaSetの設定ファイルとなります。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/controllers/replicaset.yaml download=controllers/replicaset.yaml><code>controllers/replicaset.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('controllers-replicaset-yaml')" title="Copy controllers/replicaset.yaml to clipboard">
</img>
</div>
<div class=includecode id=controllers-replicaset-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-repset<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pod-is-for</span>:<span style=color:#bbb> </span>garbage-collection-example<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pod-is-for</span>:<span style=color:#bbb> </span>garbage-collection-example<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>もしユーザーがReplicaSetを作成し、Podのメタデータを見る時、<code>ownerReference</code>フィールドの値を確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/controllers/replicaset.yaml
kubectl get pods --output<span style=color:#666>=</span>yaml
</code></pre></div><p>その出力結果によると、そのPodのオーナーは<code>my-repset</code>という名前のReplicaSetです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ownerReferences</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>blockOwnerDeletion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-repset<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>d9607e19-f88f-11e6-a518-42010a800195<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>ネームスペースをまたいだownerReferenceは意図的に許可されていません。これは以下のことを意味します。</p>
<ol>
<li>ネームスペース内のスコープの従属オブジェクトは、同一のネームスペース内のオーナーと、クラスターのスコープ内のオーナーのみ指定できます。</li>
<li>クラスターのスコープ内の従属オブジェクトは、クラスターのスコープ内のオーナーオブジェクトのみ指定でき、ネームスペース内のスコープのオーナーオブジェクトは指定できません。</li>
</ol>
</div>
<h2 id=ガベージコレクターがどのように従属オブジェクトの削除をするかを制御する>ガベージコレクターがどのように従属オブジェクトの削除をするかを制御する</h2>
<p>ユーザーがオブジェクトを削除するとき、それに紐づく従属オブジェクトも自動で削除するか指定できます。従属オブジェクトの自動削除は、<em>カスケード削除(Cascading deletion)</em> と呼ばれます。<em>カスケード削除</em> には2つのモードがあり、<em>バックグラウンド</em> と<em>フォアグラウンド</em> があります。</p>
<p>もしユーザーが、従属オブジェクトの自動削除なしにあるオブジェクトを削除する場合、その従属オブジェクトは<em>みなしご(orphaned)</em> と呼ばれます。</p>
<h3 id=フォアグラウンドのカスケード削除>フォアグラウンドのカスケード削除</h3>
<p><em>フォアグラウンドのカスケード削除</em> において、そのルートオブジェクトは最初に"削除処理中"という状態に遷移します。その<em>削除処理中</em> 状態において、下記の項目は正となります。</p>
<ul>
<li>そのオブジェクトはREST APIを介して確認可能です。</li>
<li>そのオブジェクトの<code>deletionTimestamp</code>がセットされます。</li>
<li>そのオブジェクトの<code>metadata.finalizers</code>フィールドは、<code>foregroundDeletion</code>という値を含みます。</li>
</ul>
<p>一度"削除処理中"状態に遷移すると、そのガベージコレクターはオブジェクトの従属オブジェクトを削除します。一度そのガベージコレクターが全ての”ブロッキングしている”従属オブジェクトを削除すると(<code>ownerReference.blockOwnerDeletion=true</code>という値を持つオブジェクト)、それはオーナーのオブジェクトも削除します。</p>
<p>注意点として、"フォアグラウンドのカスケード削除"において、<code>ownerReference.blockOwnerDeletion=true</code>フィールドを持つ従属オブジェクトのみ、そのオーナーオブジェクトの削除をブロックします。
Kubernetes1.7では、認証されていない従属オブジェクトがオーナーオブジェクトの削除を遅らせることができないようにするために<a href=/docs/reference/access-authn-authz/admission-controllers/#ownerreferencespermissionenforcement>アドミッションコントローラー</a>が追加され、それは、オーナーオブジェクトの削除パーミッションに基づいて<code>blockOwnerDeletion</code>の値がtrueに設定してユーザーアクセスをコントロールします。</p>
<p>もしオブジェクトの<code>ownerReferences</code>フィールドがコントローラー(DeploymentやReplicaSetなど)によってセットされている場合、<code>blockOwnerDeletion</code>は自動的にセットされ、ユーザーはこのフィールドを手動で修正する必要はありません。</p>
<h3 id=バックグラウンドのカスケード削除>バックグラウンドのカスケード削除</h3>
<p><em>バックグラウンドのカスケード削除</em> において、Kubernetesはそのオーナーオブジェクトを即座に削除し、ガベージコレクションはその従属オブジェクトをバックグラウンドで削除します。</p>
<h3 id=カスケード削除ポリシーの設定>カスケード削除ポリシーの設定</h3>
<p>カスケード削除ポリシーを制御するためには、オブジェクトをいつ設定するか<code>deleteOptions</code>引数上の<code>propagationPolicy</code>フィールドに設定してください。設定可能な値は<code>Orphan</code>、<code>Foreground</code>、もしくは<code>Background</code>のどれかです。</p>
<p>下記のコマンドは従属オブジェクトをバックグラウンドで削除する例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Background&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div><p>下記のコマンドは従属オブジェクトをフォアグラウンドで削除する例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div><p>下記のコマンドは従属オブジェクトをみなしご状態になった従属オブジェクトの例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</code></pre></div><p>kubectlもまたカスケード削除をサポートしています。<br>
kubectlを使って従属オブジェクトを自動的に削除するためには、<code>--cascade</code>をtrueにセットしてください。
従属オブジェクトを削除せず、みなしご状態にするには<code>--cascade</code>をfalseにセットしてください。
<code>--cascade</code>オプションのデフォルト値はtrueになります。</p>
<p>下記のコマンドは、ReplicaSetを削除し、その従属オブジェクトをみなしご状態にします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete replicaset my-repset --cascade<span style=color:#666>=</span><span style=color:#a2f>false</span>
</code></pre></div><h3 id=deploymentsに関する追記事項>Deploymentsに関する追記事項</h3>
<p>Kubernetes1.7以前では、Deploymentに対するカスケード削除において、作成されたReplicaSetだけでなく、それらのPodも削除するためには、ユーザーは<code>propagationPolicy: Foreground</code>と指定<em>しなくてはなりません</em> 。もしこのタイプの<em>propagationPolicy</em>が使われなかった場合、そのReplicaSetは削除されますが、そのPodは削除されずみなしご状態になります。<br>
さらなる詳細に関しては<a href=https://github.com/kubernetes/kubeadm/issues/149#issuecomment-284766613>kubeadm/#149</a>を参照してください。</p>
<h2 id=既知の問題について>既知の問題について</h2>
<p><a href=https://github.com/kubernetes/kubernetes/issues/26120>#26120</a>にてイシューがトラックされています。</p>
<h2 id=次の項目>次の項目</h2>
<p><a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/garbage-collection.md>Design Doc 1</a></p>
<p><a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/synchronous-garbage-collection.md>Design Doc 2</a></p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4de50a37ebb6f2340484192126cb7a04>3.4.2.6 - 終了したリソースのためのTTLコントローラー(TTL Controller for Finished Resources)</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code>
</div>
<p>TTLコントローラーは実行を終えたリソースオブジェクトのライフタイムを制御するためのTTL (time to live) メカニズムを提供します。<br>
TTLコントローラーは現在<a class=glossary-tooltip title="A finite or batch task that runs to completion." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>のみ扱っていて、将来的にPodやカスタムリソースなど、他のリソースの実行終了を扱えるように拡張される予定です。</p>
<p>α版の免責事項: この機能は現在α版の機能で、kube-apiserverとkube-controller-managerの<a href=/docs/reference/command-line-tools-reference/feature-gates/>Feature Gate</a>の<code>TTLAfterFinished</code>を有効にすることで使用可能です。</p>
<h2 id=ttlコントローラー>TTLコントローラー</h2>
<p>TTLコントローラーは現在Jobに対してのみサポートされています。クラスターオペレーターはこの<a href=/ja/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically>例</a>のように、Jobの<code>.spec.ttlSecondsAfterFinished</code>フィールドを指定することにより、終了したJob(<code>完了した</code>もしくは<code>失敗した</code>)を自動的に削除するためにこの機能を使うことができます。<br>
TTLコントローラーは、そのリソースが終了したあと指定したTTLの秒数後に削除できるか推定します。言い換えると、そのTTLが期限切れになると、TTLコントローラーがリソースをクリーンアップするときに、そのリソースに紐づく従属オブジェクトも一緒に連続で削除します。注意点として、リソースが削除されるとき、ファイナライザーのようなライフサイクルに関する保証は尊重されます。</p>
<p>TTL秒はいつでもセット可能です。下記はJobの<code>.spec.ttlSecondsAfterFinished</code>フィールドのセットに関するいくつかの例です。</p>
<ul>
<li>Jobがその終了後にいくつか時間がたった後に自動的にクリーンアップできるように、そのリソースマニフェストにこの値を指定します。</li>
<li>この新しい機能を適用させるために、存在していてすでに終了したリソースに対してこのフィールドをセットします。</li>
<li>リソース作成時に、このフィールドを動的にセットするために、<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>管理webhookの変更</a>をさせます。クラスター管理者は、終了したリソースに対して、このTTLポリシーを強制するために使うことができます。</li>
<li>リソースが終了した後に、このフィールドを動的にセットしたり、リソースステータスやラベルなどの値に基づいて異なるTTL値を選択するために、<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>管理webhookの変更</a>をさせます。</li>
</ul>
<h2 id=注意>注意</h2>
<h3 id=ttl秒の更新>TTL秒の更新</h3>
<p>注意点として、Jobの<code>.spec.ttlSecondsAfterFinished</code>フィールドといったTTL期間はリソースが作成された後、もしくは終了した後に変更できます。しかし、一度Jobが削除可能(TTLの期限が切れたとき)になると、それがたとえTTLを伸ばすような更新に対してAPIのレスポンスで成功したと返されたとしても、そのシステムはJobが稼働し続けることをもはや保証しません。</p>
<h3 id=タイムスキュー-time-skew>タイムスキュー(Time Skew)</h3>
<p>TTLコントローラーが、TTL値が期限切れかそうでないかを決定するためにKubernetesリソース内に保存されたタイムスタンプを使うため、この機能はクラスター内のタイムスキュー(時刻のずれ)に対してセンシティブとなります。タイムスキューは、誤った時間にTTLコントローラーに対してリソースオブジェクトのクリーンアップしてしまうことを引き起こすものです。</p>
<p>Kubernetesにおいてタイムスキューを避けるために、全てのNode上でNTPの稼働を必須とします(<a href=https://github.com/kubernetes/kubernetes/issues/6159#issuecomment-93844058>#6159</a>を参照してください)。クロックは常に正しいものではありませんが、Node間におけるその差はとても小さいものとなります。TTLに0でない値をセットするときにこのリスクに対して注意してください。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>
<p><a href=/ja/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically>Jobの自動クリーンアップ</a></p>
</li>
<li>
<p><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-apps/592-ttl-after-finish/README.md>設計ドキュメント</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2e4cec01c525b45eccd6010e21cc76d9>3.4.2.7 - CronJob</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.8 [beta]</code>
</div>
<p><em>CronJob</em> は繰り返しのスケジュールによって<a class=glossary-tooltip title="A finite or batch task that runs to completion." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>を作成します。</p>
<p><em>CronJob</em> オブジェクトとは <em>crontab</em> (cron table)ファイルでみられる一行のようなものです。
<a href=https://ja.wikipedia.org/wiki/Cron>Cron</a>形式で記述された指定のスケジュールの基づき、定期的にジョブが実行されます。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <p>すべての<strong>CronJob</strong><code>スケジュール</code>: 時刻はジョブが開始された<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>のタイムゾーンに基づいています。</p>
<p>コントロールプレーンがkube-controller-managerをPodもしくは素のコンテナで実行している場合、CronJobコントローラーのタイムゾーンとして、kube-controller-managerコンテナに設定されたタイムゾーンを使用します。</p>
</div>
<p>CronJobリソースのためのマニフェストを作成する場合、その名前が有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>か確認してください。
名前は52文字を超えることはできません。これはCronJobコントローラーが自動的に、与えられたジョブ名に11文字を追加し、ジョブ名の長さは最大で63文字以内という制約があるためです。</p>
<h2 id=cronjob>CronJob</h2>
<p>CronJobは、バックアップの実行やメール送信のような定期的であったり頻発するタスクの作成に役立ちます。
CronJobは、クラスターがアイドル状態になりそうなときにJobをスケジューリングするなど、特定の時間に個々のタスクをスケジュールすることもできます。</p>
<h3 id=例>例</h3>
<p>このCronJobマニフェスト例は、毎分ごとに現在の時刻とhelloメッセージを表示します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/job/cronjob.yaml download=application/job/cronjob.yaml><code>application/job/cronjob.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-cronjob-yaml')" title="Copy application/job/cronjob.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-cronjob-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronJob<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*/1 * * * *&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jobTemplate</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- date; echo Hello from the Kubernetes cluster<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>(<a href=/docs/tasks/job/automated-tasks-with-cron-jobs/>Running Automated Tasks with a CronJob</a>ではこの例をより詳しく説明しています。).</p>
<h2 id=cron-job-limitations>CronJobの制限</h2>
<p>cronジョブは一度のスケジュール実行につき、 <em>おおよそ</em> 1つのジョブオブジェクトを作成します。ここで <em>おおよそ</em> と言っているのは、ある状況下では2つのジョブが作成される、もしくは1つも作成されない場合があるためです。通常、このようなことが起こらないようになっていますが、完全に防ぐことはできません。したがって、ジョブは <em>冪等</em> であるべきです。</p>
<p><code>startingDeadlineSeconds</code>が大きな値、もしくは設定されていない(デフォルト)、そして、<code>concurrencyPolicy</code>を<code>Allow</code>に設定している場合には、少なくとも一度、ジョブが実行されることを保証します。</p>
<p>最後にスケジュールされた時刻から現在までの間に、CronJob<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>はどれだけスケジュールが間に合わなかったのかをCronJobごとにチェックします。もし、100回以上スケジュールが失敗していると、ジョブは開始されずに、ログにエラーが記録されます。</p>
<pre><code>Cannot determine if job needs to be started. Too many missed start time (&gt; 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew.
</code></pre><p><code>startingDeadlineSeconds</code>フィールドが設定されると(<code>nil</code>ではない)、最後に実行された時刻から現在までではなく、<code>startingDeadlineSeconds</code>の値から現在までで、どれだけジョブを逃したのかをコントローラーが数えます。 <code>startingDeadlineSeconds</code>が<code>200</code>の場合、過去200秒間にジョブが失敗した回数を記録します。</p>
<p>スケジュールされた時間にCronJobが作成できないと、失敗したとみなされます。たとえば、<code>concurrencyPolicy</code>が<code>Forbid</code>に設定されている場合、前回のスケジュールがまだ実行中にCronJobをスケジュールしようとすると、CronJobは作成されません。</p>
<p>例として、CronJobが<code>08:30:00</code>を開始時刻として1分ごとに新しいJobをスケジュールするように設定され、<code>startingDeadlineSeconds</code>フィールドが設定されていない場合を想定します。CronJobコントローラーが<code>08:29:00</code> から<code>10:21:00</code>の間にダウンしていた場合、スケジューリングを逃したジョブの数が100を超えているため、ジョブは開始されません。</p>
<p>このコンセプトをさらに掘り下げるために、CronJobが<code>08:30:00</code>から1分ごとに新しいJobを作成し、<code>startingDeadlineSeconds</code>が200秒に設定されている場合を想定します。CronJobコントローラーが前回の例と同じ期間(<code>08:29:00</code> から<code>10:21:00</code>まで)にダウンしている場合でも、10:22:00時点でJobはまだ動作しています。このようなことは、過去200秒間(言い換えると、3回の失敗)に何回スケジュールが間に合わなかったをコントローラーが確認するときに発生します。これは最後にスケジュールされた時間から今までのものではありません。</p>
<p>CronJobはスケジュールに一致するJobの作成にのみ関与するのに対して、JobはJobが示すPod管理を担います。</p>
<h2 id=次の項目>次の項目</h2>
<p><a href=https://en.wikipedia.org/wiki/Cron>Cron表現形式</a>では、CronJobの<code>schedule</code>フィールドのフォーマットを説明しています。</p>
<p>cronジョブの作成や動作の説明、CronJobマニフェストの例については、<a href=/docs/tasks/job/automated-tasks-with-cron-jobs>Running automated tasks with cron jobs</a>を見てください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0a0a7eca3e302a3c08f8c85e15d337fd>3.5 - Service、負荷分散とネットワーキング</h1>
<div class=lead>Kubernetesにおけるネットワーキングの概念とリソース。</div>
<p>Kubernetesのネットワーキングは4つの懸念事項に対処します。</p>
<ul>
<li>Pod内のコンテナは、ネットワーキングを利用してループバック経由の通信を行います。</li>
<li>クラスターネットワーキングは、異なるPod間の通信を提供します。</li>
<li>Serviceリソースは、Pod内で動作しているアプリケーションへクラスターの外部から到達可能なように露出を許可します。</li>
<li>Serviceを利用して、クラスタ内部のみで使用するServiceの公開も可能です。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5701136fd2ce258047b6ddc389112352>3.5.1 - Service</h1>
<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>の集合で実行されているアプリケーションをネットワークサービスとして公開する抽象的な方法です。
<p>Kubernetesでは、なじみのないサービスディスカバリーのメカニズムを使用するためにユーザーがアプリケーションの修正をする必要はありません。
KubernetesはPodにそれぞれのIPアドレス割り振りや、Podのセットに対する単一のDNS名を提供したり、それらのPodのセットに対する負荷分散が可能です。</p>
<h2 id=serviceを利用する動機>Serviceを利用する動機</h2>
<p>Kubernetes <a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>はクラスターの状態に合わせて作成され削除されます。Podは揮発的なリソースです。
<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>をアプリケーションを稼働させるために使用すると、Podを動的に作成・削除してくれます。</p>
<p>各Podはそれ自身のIPアドレスを持ちます。しかしDeploymentでは、ある時点において同時に稼働しているPodのセットは、その後のある時点において稼働しているPodのセットとは異なる場合があります。</p>
<p>この仕組みはある問題を引き起こします。もし、あるPodのセット(ここでは"バックエンド"と呼びます)がクラスター内で他のPodのセット(ここでは"フロントエンド"と呼びます)に対して機能を提供する場合、フロントエンドのPodがワークロードにおけるバックエンドを使用するために、バックエンドのPodのIPアドレスを探し出したり、記録し続けるためにはどうすればよいでしょうか?</p>
<p>ここで <em>Service</em> について説明します。</p>
<h2 id=service-resource>Serviceリソース</h2>
<p>Kubernetesにおいて、ServiceはPodの論理的なセットや、そのPodのセットにアクセスするためのポリシーを定義します(このパターンはよくマイクロサービスと呼ばることがあります)。
ServiceによってターゲットとされたPodのセットは、たいてい <a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=セレクター>セレクター</a>によって定義されます。
その他の方法について知りたい場合は<a href=#services-without-selectors>セレクターなしのService</a>を参照してください。</p>
<p>例えば、3つのレプリカが稼働しているステートレスな画像処理用のバックエンドを考えます。これらのレプリカは代替可能です。— フロントエンドはバックエンドが何であろうと気にしません。バックエンドのセットを構成する実際のPodのセットが変更された際、フロントエンドクライアントはその変更を気にしたり、バックエンドのPodのセットの情報を記録しておく必要はありません。</p>
<p>Serviceによる抽象化は、クライアントからバックエンドのPodの管理する責務を分離することを可能にします。</p>
<h3 id=クラウドネイティブのサービスディスカバリー>クラウドネイティブのサービスディスカバリー</h3>
<p>アプリケーション内でサービスディスカバリーのためにKubernetes APIが使える場合、ユーザーはエンドポイントを<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API Server">API Server</a>に問い合わせることができ、またService内のPodのセットが変更された時はいつでも更新されたエンドポイントの情報を取得できます。</p>
<p>非ネイティブなアプリケーションのために、KubernetesはアプリケーションとバックエンドPodの間で、ネットワークポートやロードバランサーを配置する方法を提供します。</p>
<h2 id=serviceの定義>Serviceの定義</h2>
<p>KubernetesのServiceはPodと同様にRESTのオブジェクトです。他のRESTオブジェクトと同様に、ユーザーはServiceの新しいインスタンスを作成するためにAPIサーバーに対してServiceの定義を<code>POST</code>できます。Serviceオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-label-names>DNSラベル名</a>である必要があります。</p>
<p>例えば、TCPで9376番ポートで待ち受けていて、<code>app=Myapp</code>というラベルをもつPodのセットがあるとします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></code></pre></div><p>この定義では、"my-service"という名前のついた新しいServiceオブジェクトを作成します。これは<code>app=Myapp</code>ラベルのついた各Pod上でTCPの9376番ポートをターゲットとします。</p>
<p>Kubernetesは、このServiceに対してIPアドレス("clusterIP"とも呼ばれます)を割り当てます。これはServiceのプロキシーによって使用されます(下記の<a href=#virtual-ips-and-service-proxies>仮想IPとServiceプロキシー</a>を参照ください)。</p>
<p>Serviceセレクターのコントローラーはセレクターに一致するPodを継続的にスキャンし、“my-service”という名前のEndpointsオブジェクトに対して変更をPOSTします。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Serviceは<code>port</code>から<code>targetPort</code>へのマッピングを行います。デフォルトでは、利便性のために<code>targetPort</code>フィールドは<code>port</code>フィールドと同じ値で設定されます。
</div>
<p>Pod内のポートの定義は名前を設定でき、Serviceの<code>targetPort</code>属性にてその名前を参照できます。これは単一の設定名をもつService内で、複数の種類のPodが混合していたとしても有効で、異なるポート番号を介することによって利用可能な、同一のネットワークプロトコルを利用します。
この仕組みはServiceをデプロイしたり、設定を追加する場合に多くの点でフレキシブルです。例えば、バックエンドソフトウェアにおいて、次のバージョンでPodが公開するポート番号を変更するときに、クライアントの変更なしに行えます。</p>
<p>ServiceのデフォルトプロトコルはTCPです。また、他の<a href=#protocol-support>サポートされているプロトコル</a>も利用可能です。</p>
<p>多くのServiceが、1つ以上のポートを公開する必要があるように、Kubernetesは1つのServiceオブジェクトに対して複数のポートの定義をサポートしています。
各ポート定義は同一の<code>protocol</code>または異なる値を設定できます。</p>
<h3 id=services-without-selectors>セレクターなしのService</h3>
<p>Serviceは多くの場合、KubernetesのPodに対するアクセスを抽象化しますが、他の種類のバックエンドも抽象化できます。
例えば:</p>
<ul>
<li>プロダクション環境で外部のデータベースクラスターを利用したいが、テスト環境では、自身のクラスターが持つデータベースを利用したい場合</li>
<li>Serviceを、異なる<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=Namespace>Namespace</a>のServiceや他のクラスターのServiceに向ける場合</li>
<li>ワークロードをKubernetesに移行するとき、アプリケーションに対する処理をしながら、バックエンドの一部をKubernetesで実行する場合</li>
</ul>
<p>このような場合において、ユーザーはPodセレクター<em>なしで</em>Serviceを定義できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></code></pre></div><p>このServiceはセレクターがないため、対応するEndpointsオブジェクトは自動的に作成されません。
ユーザーはEndpointsオブジェクトを手動で追加することにより、向き先のネットワークアドレスとポートを手動でマッピングできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Endpoints<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subsets</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>192.0.2.42</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></code></pre></div><p>Endpointsオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>Endpointsのipは、loopback (127.0.0.0/8 for IPv4, ::1/128 for IPv6), や
link-local (169.254.0.0/16 and 224.0.0.0/24 for IPv4, fe80::/64 for IPv6)に設定することができません。</p>
<p><a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>が仮想IPを最終的な到達先に設定することをサポートしていないため、Endpointsのipアドレスは他のKubernetes ServiceのClusterIPにすることができません。</p>
</div>
<p>セレクターなしのServiceへのアクセスは、セレクターをもっているServiceと同じようにふるまいます。上記の例では、トラフィックはYAMLファイル内で<code>192.0.2.42:9376</code> (TCP)で定義された単一のエンドポイントにルーティングされます。</p>
<p>ExternalName Serviceはセレクターの代わりにDNS名を使用する特殊なケースのServiceです。さらなる情報は、このドキュメントの後で紹介する<a href=#externalname>ExternalName</a>を参照ください。</p>
<h3 id=エンドポイントスライス>エンドポイントスライス</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code>
</div>
<p>エンドポイントスライスは、Endpointsに対してよりスケーラブルな代替手段を提供できるAPIリソースです。概念的にはEndpointsに非常に似ていますが、エンドポイントスライスを使用すると、ネットワークエンドポイントを複数のリソースに分割できます。デフォルトでは、エンドポイントスライスは、100個のエンドポイントに到達すると「いっぱいである」と見なされ、その時点で追加のエンドポイントスライスが作成され、追加のエンドポイントが保存されます。</p>
<p>エンドポイントスライスは、<a href=/ja/docs/concepts/services-networking/endpoint-slices/>エンドポイントスライスのドキュメント</a>にて詳しく説明されている追加の属性と機能を提供します。</p>
<h3 id=アプリケーションプロトコル>アプリケーションプロトコル</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code>
</div>
<p><code>AppProtocol</code>フィールドによってServiceの各ポートに対して特定のアプリケーションプロトコルを指定することができます。
この値は、対応するEndpointsオブジェクトとEndpointSliceオブジェクトに反映されます。</p>
<h2 id=virtual-ips-and-service-proxies>仮想IPとサービスプロキシー</h2>
<p>Kubernetesクラスターの各Nodeは<code>kube-proxy</code>を稼働させています。<code>kube-proxy</code>は<a href=#externalname><code>ExternalName</code></a>タイプ以外の<code>Service</code>用に仮想IPを実装する責務があります。</p>
<h3 id=なぜ-dnsラウンドロビンを使わないのでしょうか>なぜ、DNSラウンドロビンを使わないのでしょうか。</h3>
<p>ここで湧き上がる質問として、なぜKubernetesは内部のトラフィックをバックエンドへ転送するためにプロキシーに頼るのでしょうか。
他のアプローチはどうなのでしょうか。例えば、複数のAバリュー(もしくはIPv6用にAAAAバリューなど)をもつDNSレコードを設定し、ラウンドロビン方式で名前を解決することは可能でしょうか。</p>
<p>Serviceにおいてプロキシーを使う理由はいくつかあります。</p>
<ul>
<li>DNSの実装がレコードのTTLをうまく扱わず、期限が切れた後も名前解決の結果をキャッシュするという長い歴史がある。</li>
<li>いくつかのアプリケーションではDNSルックアップを1度だけ行い、その結果を無期限にキャッシュする。</li>
<li>アプリケーションとライブラリーが適切なDNS名の再解決を行ったとしても、DNSレコード上の0もしくは低い値のTTLがDNSに負荷をかけることがあり、管理が難しい。</li>
</ul>
<h3 id=proxy-mode-userspace>user-spaceプロキシーモード</h3>
<p>このモードでは、kube-proxyはServiceやEndpointsオブジェクトの追加・削除をチェックするために、Kubernetes Masterを監視します。
各Serviceは、ローカルのNode上でポート(ランダムに選ばれたもの)を公開します。この"プロキシーポート"に対するどのようなリクエストも、そのServiceのバックエンドPodのどれか1つにプロキシーされます(Endpointsを介して通知されたPodに対して)。
kube-proxyは、どのバックエンドPodを使うかを決める際にServiceの<code>SessionAffinity</code>項目の設定を考慮に入れます。</p>
<p>最後に、user-spaceプロキシーはServiceの<code>clusterIP</code>(仮想IP)と<code>port</code>に対するトラフィックをキャプチャするiptablesルールをインストールします。
そのルールは、トラフィックをバックエンドPodにプロキシーするためのプロキシーポートにリダイレクトします。</p>
<p>デフォルトでは、user-spaceモードにおけるkube-proxyはラウンドロビンアルゴリズムによってバックエンドPodを選択します。</p>
<p><img src=/images/docs/services-userspace-overview.svg alt=user-spaceプロキシーのService概要ダイアグラム></p>
<h3 id=proxy-mode-iptables><code>iptables</code>プロキシーモード</h3>
<p>このモードでは、kube-proxyはServiceやEndpointsオブジェクトの追加・削除のチェックのためにKubernetesコントロールプレーンを監視します。
各Serviceでは、そのServiceの<code>clusterIP</code>と<code>port</code>に対するトラフィックをキャプチャするiptablesルールをインストールし、そのトラフィックをServiceのあるバックエンドのセットに対してリダイレクトします。
各Endpointsオブジェクトは、バックエンドのPodを選択するiptablesルールをインストールします。</p>
<p>デフォルトでは、iptablesモードにおけるkube-proxyはバックエンドPodをランダムで選択します。</p>
<p>トラフィックのハンドリングのためにiptablesを使用すると、システムのオーバーヘッドが少なくなります。これは、トラフィックがLinuxのnetfilterによってuser-spaceとkernel-spaceを切り替える必要がないためです。
このアプローチは、オーバーヘッドが少ないことに加えて、より信頼できる方法でもあります。</p>
<p>kube-proxyがiptablesモードで稼働し、最初に選択されたPodが応答しない場合、そのコネクションは失敗します。
これはuser-spaceモードでの挙動と異なります: user-spaceモードにおいては、kube-proxyは最初のPodに対するコネクションが失敗したら、自動的に他のバックエンドPodに対して再接続を試みます。</p>
<p>iptablesモードのkube-proxyが正常なバックエンドPodのみをリダイレクト対象とするために、Podの<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>ReadinessProbe</a>を使用してバックエンドPodが正常に動作しているか確認できます。これは、ユーザーがkube-proxyを介して、コネクションに失敗したPodに対してトラフィックをリダイレクトするのを除外することを意味します。</p>
<p><img src=/images/docs/services-iptables-overview.svg alt=iptablesプロキシーのService概要ダイアグラム></p>
<h3 id=proxy-mode-ipvs>IPVSプロキシーモード</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [stable]</code>
</div>
<p><code>ipvs</code>モードにおいて、kube-proxyはServiceとEndpointsオブジェクトを監視し、IPVSルールを作成するために<code>netlink</code>インターフェースを呼び出し、定期的にKubernetesのServiceとEndpointsとIPVSルールを同期させます。
このコントロールループはIPVSのステータスが理想的な状態になることを保証します。
Serviceにアクセスするとき、IPVSはトラフィックをバックエンドのPodに向けます。</p>
<p>IPVSプロキシーモードはiptablesモードと同様に、netfilterのフック関数に基づいています。ただし、基礎となるデータ構造としてハッシュテーブルを使っているのと、kernel-spaceで動作します。
これは、IPVSモードにおけるkube-proxyはiptablesモードに比べてより低いレイテンシーでトラフィックをリダイレクトし、プロキシーのルールを同期する際にはよりパフォーマンスがよいことを意味します。
他のプロキシーモードと比較して、IPVSモードはより高いネットワークトラフィックのスループットをサポートしています。</p>
<p>IPVSはバックエンドPodに対するトラフィックのバランシングのために多くのオプションを下記のとおりに提供します。</p>
<ul>
<li><code>rr</code>: ラウンドロビン</li>
<li><code>lc</code>: 最低コネクション数(オープンされているコネクション数がもっとも小さいもの)</li>
<li><code>dh</code>: 送信先IPによって割り当てられたハッシュ値をもとに割り当てる(Destination Hashing)</li>
<li><code>sh</code>: 送信元IPによって割り当てられたハッシュ値をもとに割り当てる(Source Hashing)</li>
<li><code>sed</code>: 見込み遅延が最小なもの</li>
<li><code>nq</code>: キューなしスケジューリング</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>IPVSモードでkube-proxyを稼働させるためには、kube-proxyを稼働させる前にNode上でIPVSを有効にしなければなりません。</p>
<p>kube-proxyはIPVSモードで起動する場合、IPVSカーネルモジュールが利用可能かどうかを確認します。
もしIPVSカーネルモジュールが見つからなかった場合、kube-proxyはiptablesモードで稼働するようにフォールバックされます。</p>
</div>
<p><img src=/images/docs/services-ipvs-overview.svg alt=IPVSプロキシーのService概要ダイアグラム></p>
<p>このダイアグラムのプロキシーモデルにおいて、ServiceのIP:Portに対するトラフィックは、クライアントがKubernetesのServiceやPodについて何も知ることなく適切にバックエンドにプロキシーされています。</p>
<p>特定のクライアントからのコネクションが、毎回同一のPodにリダイレクトされるようにするためには、<code>service.spec.sessionAffinity</code>に"ClientIP"を設定することにより、クライアントのIPアドレスに基づいたSessionAffinityを選択することができます(デフォルトは"None")。
また、<code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code>を適切に設定することにより、セッションのタイムアウト時間を設定できます(デフォルトではこの値は18,000で、3時間となります)。</p>
<h2 id=複数のポートを公開するservice>複数のポートを公開するService</h2>
<p>いくつかのServiceにおいて、ユーザーは1つ以上のポートを公開する必要があります。Kubernetesは、Serviceオブジェクト上で複数のポートを定義するように設定できます。
Serviceで複数のポートを使用するとき、どのポートかを明確にするために、複数のポート全てに対して名前をつける必要があります。
例えば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>https<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>KubernetesのPod名と同様に、ポート名は小文字の英数字と<code>-</code>のみ含める必要があります。また、ポート名の最初と最後の文字は英数字である必要があります。</p>
<p>例えば、<code>123-abc</code>や<code>web</code>という名前は有効で、<code>123_abc</code>や<code>-web</code>は無効です。</p>
</div>
<h2 id=ユーザー所有のipアドレスを選択する>ユーザー所有のIPアドレスを選択する</h2>
<p><code>Service</code>を作成するリクエストの一部として、ユーザー所有のclusterIPアドレスを指定することができます。
これを行うためには<code>.spec.clusterIP</code>フィールドにセットします。
使用例として、もしすでに再利用したいDNSエントリーが存在していた場合や、特定のIPアドレスを設定されたレガシーなシステムや、IPの再設定が難しい場合です。</p>
<p>ユーザーが指定したIPアドレスは、そのAPIサーバーのために設定されている<code>service-cluster-ip-range</code>というCIDRレンジ内の有効なIPv4またはIPv6アドレスである必要があります。
もし無効なclusterIPアドレスの値を設定してServiceを作成した場合、問題があることを示すためにAPIサーバーはHTTPステータスコード422を返します。</p>
<h2 id=サービスディスカバリー>サービスディスカバリー</h2>
<p>Kubernetesは、Serviceオブジェクトを見つけ出すために2つの主要なモードをサポートしています。 - それは環境変数とDNSです。</p>
<h3 id=環境変数>環境変数</h3>
<p>PodがNode上で稼働するとき、kubeletはアクティブな各Serviceに対して、環境変数のセットを追加します。
これは<a href=https://docs.docker.com/userguide/dockerlinks/>Docker links互換性</a>のある変数(
<a href=https://releases.k8s.io/v1.22.16/pkg/kubelet/envvars/envvars.go#L72>makeLinkVariables関数</a>を確認してください)や、より簡単な<code>{SVCNAME}_SERVICE_HOST</code>や、<code>{SVCNAME}_SERVICE_PORT</code>変数をサポートします。この変数名で使われるService名は大文字に変換され、<code>-</code>は<code>_</code>に変換されます。</p>
<p>例えば、TCPポート6379番を公開していて、さらにclusterIPが10.0.0.11に割り当てられている<code>redis-master</code>というServiceは、下記のような環境変数を生成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>REDIS_MASTER_SERVICE_HOST</span><span style=color:#666>=</span>10.0.0.11
<span style=color:#b8860b>REDIS_MASTER_SERVICE_PORT</span><span style=color:#666>=</span><span style=color:#666>6379</span>
<span style=color:#b8860b>REDIS_MASTER_PORT</span><span style=color:#666>=</span>tcp://10.0.0.11:6379
<span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP</span><span style=color:#666>=</span>tcp://10.0.0.11:6379
<span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_PROTO</span><span style=color:#666>=</span>tcp
<span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_PORT</span><span style=color:#666>=</span><span style=color:#666>6379</span>
<span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_ADDR</span><span style=color:#666>=</span>10.0.0.11
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>Serviceにアクセスする必要のあるPodがあり、クライアントであるそのPodに対して環境変数を使ってポートとclusterIPを公開する場合、クライアントのPodが存在する<em>前に</em> Serviceを作成しなくてはなりません。
そうでない場合、クライアントのPodはそれらの環境変数を作成しません。</p>
<p>ServiceのclusterIPを発見するためにDNSのみを使う場合、このような問題を心配する必要はありません。</p>
</div>
<h3 id=dns>DNS</h3>
<p>ユーザーは<a href=/ja/docs/concepts/cluster-administration/addons/>アドオン</a>を使ってKubernetesクラスターにDNS Serviceをセットアップできます(常にセットアップすべきです)。</p>
<p>CoreDNSなどのクラスター対応のDNSサーバーは新しいServiceや、各Service用のDNSレコードのセットのためにKubernetes APIを常に監視します。
もしクラスターを通してDNSが有効になっている場合、全てのPodはDNS名によって自動的にServiceに対する名前解決をするようにできるはずです。</p>
<p>例えば、Kubernetesの<code>my-ns</code>というNamespace内で<code>my-service</code>というServiceがある場合、KubernetesコントロールプレーンとDNS Serviceが協調して動作し、<code>my-service.my-ns</code>というDNSレコードを作成します。
<code>my-ns</code>というNamespace内のPodは<code>my-service</code>という名前で簡単に名前解決できるはずです(<code>my-service.my-ns</code>でも動作します)。</p>
<p>他のNamespace内でのPodは<code>my-service.my-ns</code>といった形で指定しなくてはなりません。これらのDNS名は、そのServiceのclusterIPに名前解決されます。</p>
<p>Kubernetesは名前付きのポートに対するDNS SRV(Service)レコードもサポートしています。もし<code>my-service.my-ns</code>というServiceが<code>http</code>という名前のTCPポートを持っていた場合、IPアドレスと同様に、<code>http</code>のポート番号を探すために<code>_http._tcp.my-service.my-ns</code>というDNS SRVクエリを実行できます。</p>
<p>KubernetesのDNSサーバーは<code>ExternalName</code> Serviceにアクセスする唯一の方法です。
<a href=/ja/docs/concepts/services-networking/dns-pod-service/>DNS Pods と Service</a>にて<code>ExternalName</code>による名前解決に関するさらなる情報を確認できます。</p>
<h2 id=headless-service>Headless Service</h2>
<p>場合によっては、負荷分散と単一のService IPは不要です。このケースにおいて、clusterIP(<code>.spec.clusterIP</code>)の値を<code>"None"</code>に設定することにより、"Headless"とよばれるServiceを作成できます。</p>
<p>ユーザーは、Kubernetesの実装と紐づくことなく、他のサービスディスカバリーのメカニズムと連携するためにHeadless Serviceを使用できます。
例えば、ユーザーはこのAPI上でカスタム<a class=glossary-tooltip title="A specialized controller used to manage a custom resource" data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=オペレーター>オペレーター</a>を実装することができます。</p>
<p>この<code>Service</code>においては、clusterIPは割り当てられず、kube-proxyはこのServiceをハンドリングしないのと、プラットフォームによって行われるはずの
ロードバランシングやプロキシーとしての処理は行われません。DNSがどのように自動で設定されるかは、定義されたServiceが定義されたラベルセレクターを持っているかどうかに依存します。</p>
<h3 id=ラベルセレクターの利用>ラベルセレクターの利用</h3>
<p>ラベルセレクターを定義したHeadless Serviceにおいて、EndpointsコントローラーはAPIにおいて<code>Endpoints</code>レコードを作成し、<code>Service</code>のバックエンドにある<code>Pod</code>へのIPを直接指し示すためにDNS設定を修正します。</p>
<h3 id=ラベルセレクターなしの場合>ラベルセレクターなしの場合</h3>
<p>ラベルセレクターを定義しないHeadless Serviceにおいては、Endpointsコントローラーは<code>Endpoints</code>レコードを作成しません。
しかしDNSのシステムは下記の2つ両方を探索し、設定します。</p>
<ul>
<li><a href=#externalname><code>ExternalName</code></a>タイプのServiceに対するCNAMEレコード</li>
<li>他の全てのServiceタイプを含む、Service名を共有している全ての<code>Endpoints</code>レコード</li>
</ul>
<h2 id=publishing-services-service-types>Serviceの公開 (Serviceのタイプ)</h2>
<p>ユーザーのアプリケーションのいくつかの部分において(例えば、frontendsなど)、ユーザーのクラスターの外部にあるIPアドレス上でServiceを公開したい場合があります。</p>
<p>Kubernetesの<code>ServiceTypes</code>によって、ユーザーがどのような種類のServiceを使いたいかを指定することが可能です。
デフォルトでは<code>ClusterIP</code>となります。</p>
<p><code>Type</code>項目の値と、そのふるまいは以下のようになります。</p>
<ul>
<li><code>ClusterIP</code>: クラスター内部のIPでServiceを公開する。このタイプではServiceはクラスター内部からのみ疎通性があります。このタイプはデフォルトの<code>ServiceType</code>です。</li>
<li><a href=#nodeport><code>NodePort</code></a>: 各NodeのIPにて、静的なポート(<code>NodePort</code>)上でServiceを公開します。その<code>NodePort</code> のServiceが転送する先の<code>ClusterIP</code> Serviceが自動的に作成されます。<code>&lt;NodeIP>:&lt;NodePort></code>にアクセスすることによって<code>NodePort</code> Serviceにアクセスできるようになります。</li>
<li><a href=#loadbalancer><code>LoadBalancer</code></a>: クラウドプロバイダーのロードバランサーを使用して、Serviceを外部に公開します。クラスター外部にあるロードバランサーが転送する先の<code>NodePort</code>と<code>ClusterIP</code> Serviceは自動的に作成されます。</li>
<li><a href=#externalname><code>ExternalName</code></a>: <code>CNAME</code>レコードを返すことにより、<code>externalName</code>フィールドに指定したコンテンツ(例: <code>foo.bar.example.com</code>)とServiceを紐づけます。しかし、いかなる種類のプロキシーも設定されません。
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>ExternalName</code>タイプのServiceを利用するためには、kube-dnsのバージョン1.7かCoreDNSのバージョン0.0.8以上が必要となります。
</div></li>
</ul>
<p>また、Serviceを公開するために<a href=/ja/docs/concepts/services-networking/ingress/>Ingress</a>も利用可能です。IngressはServiceのタイプではありませんが、クラスターに対するエントリーポイントとして動作します。
Ingressは同一のIPアドレスにおいて、複数のServiceを公開するように、ユーザーの設定した転送ルールを1つのリソースにまとめることができます。</p>
<h3 id=nodeport>NodePort タイプ</h3>
<p>もし<code>type</code>フィールドの値を<code>NodePort</code>に設定すると、Kubernetesコントロールプレーンは<code>--service-node-port-range</code>フラグによって指定されたレンジのポート(デフォルト: 30000-32767)を割り当てます。
各Nodeはそのポート(各Nodeで同じポート番号)への通信をServiceに転送します。
作成したServiceは、<code>.spec.ports[*].nodePort</code>フィールド内に割り当てられたポートを記述します。</p>
<p>もしポートへの通信を転送する特定のIPを指定したい場合、特定のIPブロックをkube-proxyの<code>--nodeport-address</code>フラグで指定できます。これはKubernetes v1.10からサポートされています。
このフラグは、コンマ区切りのIPブロックのリスト(例: 10.0.0./8, 192.0.2.0/25)を使用し、kube-proxyがこのNodeに対してローカルとみなすべきIPアドレスの範囲を指定します。</p>
<p>例えば、<code>--nodeport-addresses=127.0.0.0/8</code>というフラグによってkube-proxyを起動した時、kube-proxyはNodePort Serviceのためにループバックインターフェースのみ選択します。<code>--nodeport-addresses</code>のデフォルト値は空のリストになります。これはkube-proxyがNodePort Serviceに対して全てのネットワークインターフェースを利用可能とするべきということを意味します(これは以前のKubernetesのバージョンとの互換性があります)。</p>
<p>もしポート番号を指定したい場合、<code>nodePort</code>フィールドに値を指定できます。コントロールプレーンは指定したポートを割り当てるか、APIトランザクションが失敗したことを知らせるかのどちらかになります。
これは、ユーザーが自分自身で、ポート番号の衝突に関して気をつける必要があることを意味します。
また、ユーザーは有効なポート番号を指定する必要があり、NodePortの使用において、設定された範囲のポートを指定する必要があります。</p>
<p>NodePortの使用は、Kubernetesによって完全にサポートされていないようなユーザー独自の負荷分散を設定をするための有効な方法や、1つ以上のNodeのIPを直接公開するための方法となりえます。</p>
<p>注意点として、このServiceは<code>&lt;NodeIP>:spec.ports[*].nodePort</code>と、<code>.spec.clusterIP:spec.ports[*].port</code>として疎通可能です。
(もしkube-proxyにおいて<code>--nodeport-addressses</code>が設定された場合、<nodeip>はフィルターされたNodeIPとなります。)</p>
<p>例えば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># デフォルトでは利便性のため、 `targetPort` は `port` と同じ値にセットされます。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 省略可能なフィールド</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># デフォルトでは利便性のため、Kubernetesコントロールプレーンはある範囲から1つポートを割り当てます(デフォルト値の範囲:30000-32767)</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodePort</span>:<span style=color:#bbb> </span><span style=color:#666>30007</span><span style=color:#bbb>
</span></code></pre></div><h3 id=loadbalancer>LoadBalancer タイプ</h3>
<p>外部のロードバランサーをサポートするクラウドプロバイダー上で、<code>type</code>フィールドに<code>LoadBalancer</code>を設定すると、Service用にロードバランサーがプロビジョニングされます。
実際のロードバランサーの作成は非同期で行われ、プロビジョンされたバランサーの情報は、Serviceの<code>.status.loadBalancer</code>フィールドに記述されます。
例えば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.171.239</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>192.0.2.127</span><span style=color:#bbb>
</span></code></pre></div><p>外部のロードバランサーからのトラフィックはバックエンドのPodに直接転送されます。クラウドプロバイダーはどのようにそのリクエストをバランシングするかを決めます。</p>
<p>LoadBalancerタイプのサービスで複数のポートが定義されている場合、すべてのポートが同じプロトコルである必要があり、さらにそのプロトコルは<code>TCP</code>、<code>UDP</code>、<code>SCTP</code>のいずれかである必要があります。</p>
<p>いくつかのクラウドプロバイダーにおいて、<code>loadBalancerIP</code>の設定をすることができます。このようなケースでは、そのロードバランサーはユーザーが指定した<code>loadBalancerIP</code>に対してロードバランサーを作成します。
もし<code>loadBalancerIP</code>フィールドの値が指定されていない場合、そのロードバランサーはエフェメラルなIPアドレスに対して作成されます。もしユーザーが<code>loadBalancerIP</code>を指定したが、使っているクラウドプロバイダーがその機能をサポートしていない場合、その<code>loadBalancerIP</code>フィールドに設定された値は無視されます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> もしSCTPを使っている場合、<code>LoadBalancer</code> タイプのServiceに関する<a href=#caveat-sctp-loadbalancer-service-type>使用上の警告</a>を参照してください。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p><strong>Azure</strong> において、もしユーザーが指定する<code>loadBalancerIP</code>を使用したい場合、最初に静的なパブリックIPアドレスのリソースを作成する必要があります。
このパブリックIPアドレスのリソースは、クラスター内で自動的に作成された他のリソースと同じグループに作られるべきです。
例: <code>MC_myResourceGroup_myAKSCluster_eastus</code></p>
<p>割り当てられたIPアドレスをloadBalancerIPとして指定してください。クラウドプロバイダーの設定ファイルにおいてsecurityGroupNameを更新したことを確認してください。
<code>CreatingLoadBalancerFailed</code>というパーミッションの問題に対するトラブルシューティングの情報は、<a href=https://docs.microsoft.com/en-us/azure/aks/static-ip>Azure Kubernetes Service(AKS)のロードバランサーで静的IPアドレスを使用する</a> や、<a href=https://github.com/Azure/AKS/issues/357>高度なネットワークを使用したAKSクラスターでのCreatingLoadBalancerFailed</a>を参照してください。</p>
</div>
<h4 id=内部のロードバランサー>内部のロードバランサー</h4>
<p>複雑な環境において、同一の(仮想)ネットワークアドレスブロック内のServiceからのトラフィックを転送する必要がでてきます。</p>
<p>Split-HorizonなDNS環境において、ユーザーは2つのServiceを外部と内部の両方からのトラフィックをエンドポイントに転送させる必要がでてきます。</p>
<p>ユーザーは、Serviceに対して下記のアノテーションを1つ追加することでこれを実現できます。
追加するアノテーションは、ユーザーが使っているクラウドプロバイダーに依存しています。</p>
<ul class="nav nav-tabs" id=service-tabs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#service-tabs-0 role=tab aria-controls=service-tabs-0 aria-selected=true>Default</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-1 role=tab aria-controls=service-tabs-1>GCP</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-2 role=tab aria-controls=service-tabs-2>AWS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-3 role=tab aria-controls=service-tabs-3>Azure</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-4 role=tab aria-controls=service-tabs-4>IBM Cloud</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-5 role=tab aria-controls=service-tabs-5>OpenStack</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-6 role=tab aria-controls=service-tabs-6>Baidu Cloud</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-7 role=tab aria-controls=service-tabs-7>Tencent Cloud</a></li></ul>
<div class=tab-content id=service-tabs><div id=service-tabs-0 class="tab-pane show active" role=tabpanel aria-labelledby=service-tabs-0>
<p><p>タブを選択してください。</p>
</div>
<div id=service-tabs-1 class=tab-pane role=tabpanel aria-labelledby=service-tabs-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cloud.google.com/load-balancer-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Internal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-2 class=tab-pane role=tabpanel aria-labelledby=service-tabs-2>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-internal</span>:<span style=color:#bbb> </span><span style=color:#666>0.0.0.0</span>/0<span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-3 class=tab-pane role=tabpanel aria-labelledby=service-tabs-3>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/azure-load-balancer-internal</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-4 class=tab-pane role=tabpanel aria-labelledby=service-tabs-4>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/ibm-load-balancer-cloud-provider-ip-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;private&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-5 class=tab-pane role=tabpanel aria-labelledby=service-tabs-5>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/openstack-internal-load-balancer</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-6 class=tab-pane role=tabpanel aria-labelledby=service-tabs-6>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/cce-load-balancer-internal-vpc</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div>
<div id=service-tabs-7 class=tab-pane role=tabpanel aria-labelledby=service-tabs-7>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>[...]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internal-subnetid</span>:<span style=color:#bbb> </span>subnet-xxxxx<span style=color:#bbb>
</span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></code></pre></div></div></div>
<h4 id=ssl-support-on-aws>AWSにおけるTLSのサポート</h4>
<p>AWS上で稼働しているクラスターにおいて、部分的なTLS/SSLのサポートをするには、<code>LoadBalancer</code> Serviceに対して3つのアノテーションを追加できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-cert</span>:<span style=color:#bbb> </span>arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012<span style=color:#bbb>
</span></code></pre></div><p>1つ目は、使用する証明書のARNです。これはIAMにアップロードされたサードパーティーが発行した証明書か、AWS Certificate Managerで作成された証明書になります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>(https|http|ssl|tcp)<span style=color:#bbb>
</span></code></pre></div><p>2つ目のアノテーションはPodが利用するプロトコルを指定するものです。HTTPSとSSLの場合、ELBはそのPodが証明書を使って暗号化されたコネクションを介して自分自身のPodを認証すると推測します。</p>
<p>HTTPとHTTPSでは、レイヤー7でのプロキシーを選択します。ELBはユーザーとのコネクションを切断し、リクエストを転送するときにリクエストヘッダーをパースして、<code>X-Forwarded-For</code>ヘッダーにユーザーのIPを追加します(Podは接続相手のELBのIPアドレスのみ確認可能です)。</p>
<p>TCPとSSLでは、レイヤー4でのプロキシーを選択します。ELBはヘッダーの値を変更せずにトラフィックを転送します。</p>
<p>いくつかのポートがセキュアに保護され、他のポートではセキュアでないような混合した環境において、下記のようにアノテーションを使うことができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-ports</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;443,8443&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>上記の例では、もしServiceが<code>80</code>、<code>443</code>、<code>8443</code>と3つのポートを含んでいる場合、<code>443</code>と<code>8443</code>はSSL証明書を使いますが、<code>80</code>では単純にHTTPでのプロキシーとなります。</p>
<p>Kubernetes v1.9以降のバージョンからは、Serviceのリスナー用にHTTPSやSSLと<a href=https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-policy-table.html>事前定義されたAWS SSLポリシー</a>を使用できます。
どのポリシーが使用できるかを確認するために、<code>aws</code>コマンドラインツールを使用できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>aws elb describe-load-balancer-policies --query <span style=color:#b44>&#39;PolicyDescriptions[].PolicyName&#39;</span>
</code></pre></div><p>ユーザーは"<code>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</code>"というアノテーションを使用することにより、複数のポリシーの中からどれか1つを指定できます。
例えば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ELBSecurityPolicy-TLS-1-2-2017-01&#34;</span><span style=color:#bbb>
</span></code></pre></div><h4 id=aws上でのproxyプロトコルのサポート>AWS上でのPROXYプロトコルのサポート</h4>
<p>AWS上で稼働するクラスターで<a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>PROXY protocol</a>のサポートを有効にするために、下記のServiceのアノテーションを使用できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-proxy-protocol</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>Kubernetesバージョン1.3.0からは、このアノテーションを使用するとELBによってプロキシーされた全てのポートが対象になり、そしてそれ以外の場合は構成されません。</p>
<h4 id=aws上でのelbのアクセスログ>AWS上でのELBのアクセスログ</h4>
<p>AWS上でのELB Service用のアクセスログを管理するためにはいくつかのアノテーションが使用できます。</p>
<p><code>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</code>というアノテーションはアクセスログを有効にするかを設定できます。</p>
<p><code>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</code>というアノテーションはアクセスログをパブリッシュするためのインターバル(分)を設定できます。
ユーザーはそのインターバルで5分もしくは60分で設定できます。</p>
<p><code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</code>というアノテーションはロードバランサーのアクセスログが保存されるAmazon S3のバケット名を設定できます。</p>
<p><code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</code>というアノテーションはユーザーが作成したAmazon S3バケットの論理的な階層を指定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ロードバランサーのアクセスログが有効かどうか。</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># アクセスログをパブリッシュするためのインターバル(分)。ユーザーはそのインターバルで5分もしくは60分で設定できます。</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-bucket&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ロードバランサーのアクセスログが保存されるAmazon S3のバケット名。</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-bucket-prefix/prod&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ユーザーが作成したAmazon S3バケットの論理的な階層。例えば: `my-bucket-prefix/prod`</span><span style=color:#bbb>
</span></code></pre></div><h4 id=awsでの接続の中断>AWSでの接続の中断</h4>
<p>古いタイプのELBでの接続の中断は、<code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</code>というアノテーションを<code>"true"</code>に設定することで管理できます。
<code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</code>というアノテーションで、インスタンスを登録解除するまえに既存の接続をオープンにし続けるための最大時間(秒)を指定できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></code></pre></div><h4 id=他のelbアノテーション>他のELBアノテーション</h4>
<p>古いタイプのELBを管理するためのアノテーションは他にもあり、下記で紹介します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ロードバランサーによってクローズされる前にアイドル状態(コネクションでデータは送信されない)になれる秒数</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ゾーンを跨いだロードバランシングが有効かどうか</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;environment=prod,owner=devops&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ELBにおいて追加タグとして保存されるキー・バリューのペアのコンマ区切りのリスト</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># バックエンドへのトラフィックが正常になったと判断するために必要なヘルスチェックの連続成功数</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># デフォルトでは2 この値は2から10の間で設定可能</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># バックエンドへのトラフィックが異常になったと判断するために必要なヘルスチェックの連続失敗数</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># デフォルトでは6 この値は2から10の間で設定可能</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 各インスタンスのヘルスチェックのおよそのインターバル(秒)</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># デフォルトでは10 この値は5から300の間で設定可能</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ヘルスチェックが失敗したと判断されるレスポンスタイムのリミット(秒)</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># この値はservice.beta.kubernetes.io/aws-load-balancer-healthcheck-intervalの値以下である必要があります。</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># デフォルトでは5 この値は2から60の間で設定可能</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-security-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sg-53fae93f&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ELBが作成される際に追加されるセキュリティグループのリスト</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># service.beta.kubernetes.io/aws-load-balancer-extra-security-groupsアノテーションと異なり</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 元々ELBに付与されていたセキュリティグループを置き換えることになります。</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-extra-security-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sg-53fae93f,sg-42efd82e&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ELBに追加される予定のセキュリティーグループのリスト</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-target-node-labels</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ingress-gw,gw-name=public-api&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ロードバランサーがターゲットノードを指定する際に利用するキーバリューのペアのコンマ区切りリストです。</span><span style=color:#bbb>
</span></code></pre></div><h4 id=aws-nlb-support>AWSでのNetwork Load Balancerのサポート</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code>
</div>
<p>AWSでNetwork Load Balancerを使用するには、値を<code>nlb</code>に設定してアノテーション<code>service.beta.kubernetes.io/aws-load-balancer-type</code>を付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nlb&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> NLBは特定のインスタンスクラスでのみ稼働します。サポートされているインスタンスタイプを確認するためには、ELBに関する<a href=https://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-register-targets.html#register-deregister-targets>AWS documentation</a>を参照してください。
</div>
<p>古いタイプのElastic Load Balancersとは異なり、Network Load Balancers (NLBs)はクライアントのIPアドレスをNodeに転送します。
もしServiceの<code>.spec.externalTrafficPolicy</code>の値が<code>Cluster</code>に設定されていた場合、クライアントのIPアドレスは末端のPodに伝播しません。</p>
<p><code>.spec.externalTrafficPolicy</code>を<code>Local</code>に設定することにより、クライアントIPアドレスは末端のPodに伝播します。しかし、これにより、トラフィックの分配が不均等になります。
特定のLoadBalancer Serviceに紐づいたPodがないNodeでは、自動的に割り当てられた<code>.spec.healthCheckNodePort</code>に対するNLBのターゲットグループのヘルスチェックが失敗し、トラフィックを全く受信しません。</p>
<p>均等なトラフィックの分配を実現するために、DaemonSetの使用や、同一のNodeに配備しないように<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity>Podのanti-affinity</a>を設定します。</p>
<p>また、<a href=/ja/docs/concepts/services-networking/service/#internal-load-balancer>内部のロードバランサー</a>のアノテーションとNLB Serviceを使用できます。</p>
<p>NLBの背後にあるインスタンスに対してクライアントのトラフィックを転送するために、Nodeのセキュリティーグループは下記のようなIPルールに従って変更されます。</p>
<table>
<thead>
<tr>
<th>Rule</th>
<th>Protocol</th>
<th>Port(s)</th>
<th>IpRange(s)</th>
<th>IpRange Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ヘルスチェック</td>
<td>TCP</td>
<td>NodePort(s) (<code>.spec.healthCheckNodePort</code> for <code>.spec.externalTrafficPolicy = Local</code>)</td>
<td>VPC CIDR</td>
<td>kubernetes.io/rule/nlb/health=&lt;loadBalancerName></td>
</tr>
<tr>
<td>クライアントのトラフィック</td>
<td>TCP</td>
<td>NodePort(s)</td>
<td><code>.spec.loadBalancerSourceRanges</code> (デフォルト: <code>0.0.0.0/0</code>)</td>
<td>kubernetes.io/rule/nlb/client=&lt;loadBalancerName></td>
</tr>
<tr>
<td>MTUによるサービスディスカバリー</td>
<td>ICMP</td>
<td>3,4</td>
<td><code>.spec.loadBalancerSourceRanges</code> (デフォルト: <code>0.0.0.0/0</code>)</td>
<td>kubernetes.io/rule/nlb/mtu=&lt;loadBalancerName></td>
</tr>
</tbody>
</table>
<p>どのクライアントIPがNLBにアクセス可能かを制限するためには、<code>loadBalancerSourceRanges</code>を指定してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancerSourceRanges</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;143.231.0.0/16&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> もし<code>.spec.loadBalancerSourceRanges</code>が設定されていない場合、KubernetesはNodeのセキュリティーグループに対して<code>0.0.0.0/0</code>からのトラフィックを許可します。
もしNodeがパブリックなIPアドレスを持っていた場合、NLBでないトラフィックも修正されたセキュリティーグループ内の全てのインスタンスにアクセス可能になってしまうので注意が必要です。
</div>
<h4 id=tencent-kubernetes-engine-tke-におけるその他のclbアノテーション>Tencent Kubernetes Engine(TKE)におけるその他のCLBアノテーション</h4>
<p>以下に示すように、TKEでCloud Load Balancerを管理するためのその他のアノテーションがあります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 指定したノードでロードバランサーをバインドします</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-backends-label</span>:<span style=color:#bbb> </span>key in (value1, value2)<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 既存のロードバランサーのID</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/tke-existed-lbid</span>:<span style=color:#bbb> </span>lb-6swtxxxx<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ロードバランサー(LB)のカスタムパラメーターは、LBタイプの変更をまだサポートしていません</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/service.extensiveParameters</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># LBリスナーのカスタムパラメーター</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/service.listenerParameters</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ロードバランサーのタイプを指定します</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 有効な値: classic(Classic Cloud Load Balancer)またはapplication(Application Cloud Load Balancer)</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/loadbalance-type</span>:<span style=color:#bbb> </span>xxxxx<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># パブリックネットワーク帯域幅の課金方法を指定します</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 有効な値: TRAFFIC_POSTPAID_BY_HOUR(bill-by-traffic)およびBANDWIDTH_POSTPAID_BY_HOUR(bill-by-bandwidth)</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internet-charge-type</span>:<span style=color:#bbb> </span>xxxxxx<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 帯域幅の値を指定します(値の範囲:[1-2000] Mbps)。</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/qcloud-loadbalancer-internet-max-bandwidth-out</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># この注釈が設定されている場合、ロードバランサーはポッドが実行されているノードのみを登録します</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># そうでない場合、すべてのノードが登録されます</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.kubernetes.io/local-svc-only-bind-node-with-pod</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><h3 id=externalname>ExternalName タイプ</h3>
<p>ExternalNameタイプのServiceは、ServiceをDNS名とマッピングし、<code>my-service</code>や<code>cassandra</code>というような従来のラベルセレクターとはマッピングしません。
ユーザーはこれらのServiceにおいて<code>spec.externalName</code>フィールドの値を指定します。</p>
<p>このServiceの定義では、例えば<code>prod</code>というNamespace内の<code>my-service</code>というServiceを<code>my.database.example.com</code>にマッピングします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>prod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ExternalName<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalName</span>:<span style=color:#bbb> </span>my.database.example.com<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ExternalNameはIpv4のアドレスの文字列のみ受け付けますが、IPアドレスではなく、数字で構成されるDNS名として受け入れます。
IPv4アドレスに似ているExternalNamesはCoreDNSもしくはIngress-Nginxによって名前解決されず、これはExternalNameは正規のDNS名を指定することを目的としているためです。
IPアドレスをハードコードする場合、<a href=#headless-service>Headless Service</a>の使用を検討してください。
</div>
<p><code>my-service.prod.svc.cluster.local</code>というホストをルックアップするとき、クラスターのDNS Serviceは<code>my.database.example.com</code>という値をもつ<code>CNAME</code>レコードを返します。
<code>my-service</code>へのアクセスは、他のServiceと同じ方法ですが、再接続する際はプロキシーや転送を介して行うよりも、DNSレベルで行われることが決定的に異なる点となります。
後にユーザーが使用しているデータベースをクラスター内に移行することになった場合は、Podを起動させ、適切なラベルセレクターやEndpointsを追加し、Serviceの<code>type</code>を変更します。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> <p>HTTPやHTTPSなどの一般的なプロトコルでExternalNameを使用する際に問題が発生する場合があります。ExternalNameを使用する場合、クラスター内のクライアントが使用するホスト名は、ExternalNameが参照する名前とは異なります。</p>
<p>ホスト名を使用するプロトコルの場合、この違いによりエラーまたは予期しない応答が発生する場合があります。HTTPリクエストがオリジンサーバーが認識しない<code>Host:</code>ヘッダーを持っていたなら、TLSサーバーはクライアントが接続したホスト名に一致する証明書を提供できません。</p>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このセクションは、<a href=https://akomljen.com/>Alen Komljen</a>による<a href=https://akomljen.com/kubernetes-tips-part-1/>Kubernetes Tips - Part1</a>というブログポストを参考にしています。
</div>
<h3 id=external-ips>External IPs</h3>
<p>もし1つ以上のクラスターNodeに転送するexternalIPが複数ある場合、Kubernetes Serviceは<code>externalIPs</code>に指定したIPで公開されます。
そのexternalIP(到達先のIPとして扱われます)のServiceのポートからトラフィックがクラスターに入って来る場合、ServiceのEndpointsのどれか1つに対して転送されます。
<code>externalIPs</code>はKubernetesによって管理されず、それを管理する責任はクラスターの管理者にあります。</p>
<p>Serviceのspecにおいて、<code>externalIPs</code>は他のどの<code>ServiceTypes</code>と併用して設定できます。
下記の例では、"<code>my-service</code>"は"<code>80.11.12.10:80</code>" (<code>externalIP:port</code>)のクライアントからアクセス可能です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalIPs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#666>80.11.12.10</span><span style=color:#bbb>
</span></code></pre></div><h2 id=serviceの欠点>Serviceの欠点</h2>
<p>仮想IP用にuserspaceモードのプロキシーを使用すると、小規模もしくは中規模のスケールでうまく稼働できますが、1000以上のServiceがあるようなとても大きなクラスターではうまくスケールしません。
これについては、<a href=https://github.com/kubernetes/kubernetes/issues/1107>Serviceのデザインプロポーザル</a>にてさらなる詳細を確認できます。</p>
<p>userspaceモードのプロキシーの使用は、Serviceにアクセスするパケットの送信元IPアドレスが不明瞭になります。
これは、いくつかの種類のネットワークフィルタリング(ファイアウォールによるフィルタリング)を不可能にします。
iptablesプロキシーモードはクラスター内の送信元IPを不明瞭にはしませんが、依然としてロードバランサーやNodePortへ疎通するクライアントに影響があります。</p>
<p><code>Type</code>フィールドはネストされた機能としてデザインされています。 - 各レベルの値は前のレベルに対して追加します。
これは全てのクラウドプロバイダーにおいて厳密に要求されていません(例: Google Compute Engineは<code>LoadBalancer</code>を動作させるために<code>NodePort</code>を割り当てる必要はありませんが、AWSではその必要があります)が、現在のAPIでは要求しています。</p>
<h2 id=the-gory-details-of-virtual-ips>仮想IPの実装について</h2>
<p>これより前の情報は、ただServiceを使いたいという多くのユーザーにとっては有益かもしれません。しかし、その裏側では多くのことが行われており、理解する価値があります。</p>
<h3 id=衝突の回避>衝突の回避</h3>
<p>Kubernetesの主要な哲学のうちの一つは、ユーザーは、ユーザー自身のアクションによるミスでないものによって、ユーザーのアクションが失敗するような状況に晒されるべきでないことです。
Serviceリソースの設計において、これはユーザーの指定したポートが衝突する可能性がある場合はそのポートのServiceを作らないことを意味します。これは障害を分離することとなります。</p>
<p>Serviceのポート番号を選択できるようにするために、我々はどの2つのServiceでもポートが衝突しないことを保証します。
Kubernetesは各Serviceに、それ自身のIPアドレスを割り当てることで実現しています。</p>
<p>各Serviceが固有のIPを割り当てられるのを保証するために、内部のアロケーターは、Serviceを作成する前に、etcd内のグローバルの割り当てマップをアトミックに更新します。
そのマップオブジェクトはServiceのIPアドレスの割り当てのためにレジストリー内に存在しなくてはならず、そうでない場合は、Serviceの作成時にIPアドレスが割り当てられなかったことを示すエラーメッセージが表示されます。</p>
<p>コントロールプレーンにおいて、バックグラウンドのコントローラーはそのマップを作成する責務があります(インメモリーのロックが使われていた古いバージョンのKubernetesからのマイグレーションをサポートすることも必要です)。
また、Kubernetesは(例えば、管理者の介入によって)無効な割り当てがされているかをチェックすることと、現時点でどのServiceにも使用されていない割り当て済みIPアドレスのクリーンアップのためにコントローラーを使用します。</p>
<h3 id=ips-and-vips>ServiceのIPアドレス</h3>
<p>実際に固定された向き先であるPodのIPアドレスとは異なり、ServiceのIPは実際には単一のホストによって応答されません。
その代わり、kube-proxyは必要な時に透過的にリダイレクトされる<em>仮想</em>IPアドレスを定義するため、iptables(Linuxのパケット処理ロジック)を使用します。
クライアントがVIPに接続する時、そのトラフィックは自動的に適切なEndpointsに転送されます。
Service用の環境変数とDNSは、Serviceの仮想IPアドレス(とポート)の面において、自動的に生成されます。</p>
<p>kube-proxyは3つの微妙に異なった動作をするプロキシーモード— userspace、iptablesとIPVS — をサポートしています。</p>
<h4 id=userspace>Userspace</h4>
<p>例として、上記で記述されている画像処理のアプリケーションを考えます。
バックエンドのServiceが作成されたとき、KubernetesのMasterは仮想IPを割り当てます。例えば10.0.0.1などです。
そのServiceのポートが1234で、そのServiceはクラスター内の全てのkube-proxyインスタンスによって監視されていると仮定します。
kube-proxyが新しいServiceを見つけた時、kube-proxyは新しいランダムポートをオープンし、その仮想IPアドレスの新しいポートにリダイレクトするようにiptablesを更新し、そのポート上で新しい接続を待ち受けを開始します。</p>
<p>クライアントがServiceの仮想IPアドレスに接続したとき、iptablesルールが有効になり、そのパケットをプロキシー自身のポートにリダイレクトします。
その"Service プロキシー"はバックエンドPodの対象を選択し、クライアントのトラフィックをバックエンドPodに転送します。</p>
<p>これはServiceのオーナーは、衝突のリスクなしに、求めるどのようなポートも選択できることを意味します。
クライアントは単純にそのIPとポートに対して接続すればよく、実際にどのPodにアクセスしているかを意識しません。</p>
<h4 id=iptables>iptables</h4>
<p>また画像処理のアプリケーションについて考えます。バックエンドServiceが作成された時、そのKubernetesコントロールプレーンは仮想IPアドレスを割り当てます。例えば10.0.0.1などです。
Serviceのポートが1234で、そのServiceがクラスター内のすべてのkube-proxyインスタンスによって監視されていると仮定します。
kube-proxyが新しいServiceを見つけた時、kube-proxyは仮想IPから各Serviceのルールにリダイレクトされるような、iptablesルールのセットをインストールします。
Service毎のルールは、トラフィックをバックエンドにリダイレクト(Destination NATを使用)しているEndpoints毎のルールに対してリンクしています。</p>
<p>クライアントがServiceの仮想IPアドレスに対して接続しているとき、そのiptablesルールが有効になります。
バックエンドのPodが選択され(SessionAffinityに基づくか、もしくはランダムで選択される)、パケットはバックエンドにリダイレクトされます。
userspaceモードのプロキシーとは異なり、パケットは決してuserspaceにコピーされず、kube-proxyは仮想IPのために稼働される必要はなく、またNodeでは変更されていないクライアントIPからトラフィックがきます。</p>
<p>このように同じ基本的なフローは、NodePortまたはLoadBalancerを介してトラフィックがきた場合に、実行され、ただクライアントIPは変更されます。</p>
<h4 id=ipvs>IPVS</h4>
<p>iptablesの処理は、大規模なクラスターの場合劇的に遅くなります。例としてはServiceが10,000ほどある場合です。
IPVSは負荷分散のために設計され、カーネル内のハッシュテーブルに基づいています。そのためIPVSベースのkube-proxyによって、多数のServiceがある場合でも一貫して高パフォーマンスを実現できます。
次第に、IPVSベースのkube-proxyは負荷分散のアルゴリズムはさらに洗練されています(最小接続数、位置ベース、重み付け、永続性など)。</p>
<h2 id=apiオブジェクト>APIオブジェクト</h2>
<p>ServiceはKubernetesのREST APIにおいてトップレベルのリソースです。ユーザーはそのAPIオブジェクトに関して、<a href=/docs/reference/generated/kubernetes-api/v1.22/#service-v1-core>Service API object</a>でさらなる情報を確認できます。</p>
<h2 id=protocol-support>サポートされているプロトコル</h2>
<h3 id=tcp>TCP</h3>
<p>ユーザーはどの種類のServiceにおいてもTCPを利用できます。これはデフォルトのネットワークプロトコルです。</p>
<h3 id=udp>UDP</h3>
<p>ユーザーは多くのServiceにおいてUDPを利用できます。 type=LoadBalancerのServiceにおいては、UDPのサポートはこの機能を提供しているクラウドプロバイダーに依存しています。</p>
<h3 id=http>HTTP</h3>
<p>もしクラウドプロバイダーがサポートしている場合、ServiceのEndpointsに転送される外部のHTTP/HTTPSでのリバースプロキシーをセットアップするために、LoadBalancerモードでServiceを作成可能です。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ユーザーはまた、HTTP/HTTPS Serviceを公開するために、Serviceの代わりに<a class=glossary-tooltip title=クラスター内のServiceに対する外部からのアクセス(主にHTTP)を管理するAPIオブジェクトです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/ingress/ target=_blank aria-label=Ingress>Ingress</a>を利用することもできます。
</div>
<h3 id=proxy-プロトコル>PROXY プロトコル</h3>
<p>もしクラウドプロバイダーがサポートしている場合、Kubernetesクラスターの外部のロードバランサーを設定するためにLoadBalancerモードでServiceを利用できます。これは<a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>PROXY protocol</a>がついた接続を転送します。</p>
<p>ロードバランサーは、最初の一連のオクテットを送信します。
下記のような例となります。</p>
<pre><code>PROXY TCP4 192.0.2.202 10.0.42.7 12345 7\r\n
</code></pre><p>クライアントからのデータのあとに追加されます。</p>
<h3 id=sctp>SCTP</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code>
</div>
<p>KubernetesはService、Endpoints、EndpointSlice、NetworkPolicyとPodの定義において<code>protocol</code>フィールドの値でSCTPをサポートしています。ベータ版の機能のため、この機能はデフォルトで有効になっています。SCTPをクラスターレベルで無効にするには、クラスター管理者はAPI Serverにおいて<code>SCTPSupport</code> <a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を<code>--feature-gates=SCTPSupport=false,…</code>と設定して無効にする必要があります。</p>
<p>そのフィーチャーゲートが有効になった時、ユーザーはService、Endpoints、EndpointSlice、NetworkPolicy、またはPodの<code>protocol</code>フィールドに<code>SCTP</code>を設定できます。
Kubernetesは、TCP接続と同様に、SCTPアソシエーションに応じてネットワークをセットアップします。</p>
<h4 id=caveat-sctp-overview>警告</h4>
<h5 id=caveat-sctp-multihomed>マルチホームSCTPアソシエーションのサポート</h5>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> <p>マルチホームSCTPアソシエーションのサポートは、複数のインターフェースとPodのIPアドレスの割り当てをサポートできるCNIプラグインを要求します。</p>
<p>マルチホームSCTPアソシエーションにおけるNATは、対応するカーネルモジュール内で特別なロジックを要求します。</p>
</div>
<h5 id=caveat-sctp-loadbalancer-service-type>type=LoadBalancer Service について</h5>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> クラウドプロバイダーのロードバランサーの実装がプロトコルとしてSCTPをサポートしている場合は、<code>type</code> がLoadBalancerで<code> protocol</code>がSCTPの場合でのみサービスを作成できます。
そうでない場合、Serviceの作成要求はリジェクトされます。現時点でのクラウドのロードバランサーのプロバイダー(Azure、AWS、CloudStack、GCE、OpenStack)は全てSCTPのサポートをしていません。
</div>
<h5 id=caveat-sctp-windows-os>Windows</h5>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> SCTPはWindowsベースのNodeではサポートされていません。
</div>
<h5 id=caveat-sctp-kube-proxy-userspace>Userspace kube-proxy</h5>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> kube-proxyはuserspaceモードにおいてSCTPアソシエーションの管理をサポートしません。
</div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>Connecting Applications with Services</a>を参照してください。</li>
<li><a href=/ja/docs/concepts/services-networking/ingress/>Ingress</a>を参照してください。</li>
<li><a href=/ja/docs/concepts/services-networking/endpoint-slices/>EndpointSlices</a>を参照してください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3a38878244d862dfdb8d7adb32f77584>3.5.2 - Serviceトポロジー</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [alpha]</code>
</div>
<p><em>Serviceトポロジー</em>を利用すると、Serviceのトラフィックをクラスターのノードトポロジーに基づいてルーティングできるようになります。たとえば、あるServiceのトラフィックに対して、できるだけ同じノードや同じアベイラビリティゾーン上にあるエンドポイントを優先してルーティングするように指定できます。</p>
<h2 id=はじめに>はじめに</h2>
<p>デフォルトでは、<code>ClusterIP</code>や<code>NodePort</code>Serviceに送信されたトラフィックは、Serviceに対応する任意のバックエンドのアドレスにルーティングされる可能性があります。しかし、Kubernetes 1.7以降では、「外部の」トラフィックをそのトラフィックを受信したノード上のPodにルーティングすることが可能になりました。しかし、この機能は<code>ClusterIP</code>Serviceでは対応しておらず、ゾーン内ルーティングなどのより複雑なトポロジーは実現不可能でした。<em>Serviceトポロジー</em>の機能を利用すれば、Serviceの作者が送信元ノードと送信先ノードのNodeのラベルに基づいてトラフィックをルーティングするためのポリシーを定義できるようになるため、この問題を解決できます。</p>
<p>送信元と送信先の間のNodeラベルのマッチングを使用することにより、オペレーターは、そのオペレーターの要件に適したメトリクスを使用して、お互いに「より近い」または「より遠い」ノードのグループを指定できます。たとえば、パブリッククラウド上のさまざまなオペレーターでは、Serviceのトラフィックを同一ゾーン内に留めようとする傾向があります。パブリッククラウドでは、ゾーンをまたぐトラフィックでは関連するコストがかかる一方、ゾーン内のトラフィックにはコストがかからない場合があるからです。その他のニーズとしては、DaemonSetが管理するローカルのPodにトラフィックをルーティングできるようにしたり、レイテンシーを低く抑えるために同じラック上のスイッチに接続されたノードにトラフィックを限定したいというものがあります。</p>
<h2 id=serviceトポロジーを利用する>Serviceトポロジーを利用する</h2>
<p>クラスターのServiceトポロジーが有効になっていれば、Serviceのspecに<code>topologyKeys</code>フィールドを指定することで、Serviceのトラフィックのルーティングを制御できます。このフィールドは、Nodeラベルの優先順位リストで、このServiceにアクセスするときにエンドポイントをソートするために使われます。トラフィックは、最初のラベルの値が送信元Nodeのものと一致するNodeに送信されます。一致したノード上にServiceに対応するバックエンドが存在しなかった場合は、2つ目のラベルについて検討が行われ、同様に、残っているラベルが順番に検討されまます。</p>
<p>一致するキーが1つも見つからなかった場合、トラフィックは、Serviceに対応するバックエンドが存在しなかったかのように拒否されます。言い換えると、エンドポイントは、利用可能なバックエンドが存在する最初のトポロジーキーに基づいて選択されます。このフィールドが指定され、すべてのエントリーでクライアントのトポロジーに一致するバックエンドが存在しない場合、そのクライアントに対するバックエンドが存在しないものとしてコネクションが失敗します。「任意のトポロジー」を意味する特別な値<code>"*"</code>を指定することもできます。任意の値にマッチするこの値に意味があるのは、リストの最後の値として使った場合だけです。</p>
<p><code>topologyKeys</code>が未指定または空の場合、トポロジーの制約は適用されません。</p>
<p>ホスト名、ゾーン名、リージョン名のラベルが付いたNodeを持つクラスターについて考えてみましょう。このとき、Serviceの<code>topologyKeys</code>の値を設定することで、トラフィックの向きを以下のように制御できます。</p>
<ul>
<li>トラフィックを同じノード上のエンドポイントのみに向け、同じノード上にエンドポイントが1つも存在しない場合には失敗するようにする: <code>["kubernetes.io/hostname"]</code>。</li>
<li>同一ノード上のエンドポイントを優先し、失敗した場合には同一ゾーン上のエンドポイント、同一リージョンゾーンのエンドポイントへとフォールバックし、それ以外の場合には失敗する: <code>["kubernetes.io/hostname", "topology.kubernetes.io/zone", "topology.kubernetes.io/region"]</code>。これは、たとえばデータのローカリティが非常に重要である場合などに役に立ちます。</li>
<li>同一ゾーンを優先しますが、ゾーン内に利用可能なノードが存在しない場合は、利用可能な任意のエンドポイントにフォールバックする: <code>["topology.kubernetes.io/zone", "*"]</code>。</li>
</ul>
<h2 id=制約>制約</h2>
<ul>
<li>
<p>Serviceトポロジーは<code>externalTrafficPolicy=Local</code>と互換性がないため、Serviceは2つの機能を同時に利用できません。2つの機能を同じクラスター上の異なるServiceでそれぞれ利用することは可能ですが、同一のService上では利用できません。</p>
</li>
<li>
<p>有効なトポロジーキーは、現在は<code>kubernetes.io/hostname</code>、<code>topology.kubernetes.io/zone</code>、および<code>topology.kubernetes.io/region</code>に限定されています。しかし、将来は一般化され、他のノードラベルも使用できるようになる予定です。</p>
</li>
<li>
<p>トポロジーキーは有効なラベルのキーでなければならず、最大で16個のキーまで指定できます。</p>
</li>
<li>
<p>すべての値をキャッチする<code>"*"</code>を使用する場合は、トポロジーキーの最後の値として指定しなければなりません。</p>
</li>
</ul>
<h2 id=例>例</h2>
<p>以下では、Serviceトポロジーの機能を利用したよくある例を紹介します。</p>
<h3 id=ノードローカルのエンドポイントだけを使用する>ノードローカルのエンドポイントだけを使用する</h3>
<p>ノードローカルのエンドポイントのみにルーティングするServiceの例です。もし同一ノード上にエンドポイントが存在しない場合、トラフィックは損失します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=ノードローカルのエンドポイントを優先して使用する>ノードローカルのエンドポイントを優先して使用する</h3>
<p>ノードローカルのエンドポイントを優先して使用しますが、ノードローカルのエンドポイントが存在しない場合にはクラスター全体のエンドポイントにフォールバックするServiceの例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=同一ゾーンや同一リージョンのエンドポイントだけを使用する>同一ゾーンや同一リージョンのエンドポイントだけを使用する</h3>
<p>同一リージョンのエンドポイントより同一ゾーンのエンドポイントを優先するServiceの例です。もしいずれのエンドポイントも存在しない場合、トラフィックは損失します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/zone&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/region&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=ノードローカル-同一ゾーン-同一リーションのエンドポイントを優先して使用する>ノードローカル、同一ゾーン、同一リーションのエンドポイントを優先して使用する</h3>
<p>ノードローカル、同一ゾーン、同一リージョンのエンドポイントを順番に優先し、クラスター全体のエンドポイントにフォールバックするServiceの例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/zone&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/region&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/administer-cluster/enabling-service-topology>Serviceトポトジーを有効にする</a>を読む。</li>
<li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>サービスとアプリケーションの接続</a>を読む。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-91cb8a4438b003df11bc1c426a81b756>3.5.3 - ServiceとPodに対するDNS</h1>
<p>このページではKubernetesによるDNSサポートについて概観します。</p>
<h2 id=イントロダクション>イントロダクション</h2>
<p>KubernetesのDNSはクラスター上でDNS PodとServiceをスケジュールし、DNSの名前解決をするために各コンテナに対してDNS ServiceのIPを使うようにKubeletを設定します。</p>
<h3 id=何がdns名を取得するか>何がDNS名を取得するか</h3>
<p>クラスター内(DNSサーバーそれ自体も含む)で定義された全てのServiceはDNS名を割り当てられます。デフォルトでは、クライアントPodのDNSサーチリストはPod自身のネームスペースと、クラスターのデフォルトドメインを含みます。<br>
下記の例でこの仕組みを説明します。</p>
<p>Kubernetesの<code>bar</code>というネームスペース内で<code>foo</code>という名前のServiceがあると仮定します。<code>bar</code>ネームスペース内で稼働しているPodは、<code>foo</code>に対してDNSクエリを実行するだけでこのServiceを探すことができます。<code>bar</code>とは別の<code>quux</code>ネームスペース内で稼働しているPodは、<code>foo.bar</code>に対してDNSクエリを実行するだけでこのServiceを探すことができます。</p>
<p>下記のセクションでは、サポートされているレコードタイプとレイアウトについて詳しくまとめています。
うまく機能する他のレイアウト、名前、またはクエリーは、実装の詳細を考慮し、警告なしに変更されることがあります。<br>
最新の仕様に関する詳細は、<a href=https://github.com/kubernetes/dns/blob/master/docs/specification.md>KubernetesにおけるDNSベースのServiceディスカバリ</a>を参照ください。</p>
<h2 id=services>Service</h2>
<h3 id=a-aaaaレコード>A/AAAAレコード</h3>
<p>"通常の"(Headlessでない)Serviceは、<code>my-svc.my-namespace.svc.cluster.local</code>という形式のDNS A(AAAA)レコードを、ServiceのIPバージョンに応じて割り当てられます。このAレコードはそのServiceのClusterIPへと名前解決されます。</p>
<p>"Headless"(ClusterIPなしの)Serviceもまた<code>my-svc.my-namespace.svc.cluster.local</code>という形式のDNS A(AAAA)レコードを、ServiceのIPバージョンに応じて割り当てられます。通常のServiceとは異なり、このレコードはServiceによって選択されたPodのIPの一覧へと名前解決されます。クライアントはこの一覧のIPを使うか、その一覧から標準のラウンドロビン方式によって選択されたIPを使います。</p>
<h3 id=srvレコード>SRVレコード</h3>
<p>SRVレコードは、通常のServiceもしくは<a href=/ja/docs/concepts/services-networking/service/#headless-service>Headless
Services</a>の一部である名前付きポート向けに作成されます。それぞれの名前付きポートに対して、そのSRVレコードは<code>_my-port-name._my-port-protocol.my-svc.my-namespace.svc.cluster.local</code>という形式となります。<br>
通常のServiceに対しては、このSRVレコードは<code>my-svc.my-namespace.svc.cluster.local</code>という形式のドメイン名とポート番号へ名前解決します。<br>
Headless Serviceに対しては、このSRVレコードは複数の結果を返します。それはServiceの背後にある各Podの1つを返すのと、<code>auto-generated-name.my-svc.my-namespace.svc.cluster.local</code>という形式のPodのドメイン名とポート番号を含んだ結果を返します。</p>
<h2 id=pod>Pod</h2>
<h3 id=a-aaaaレコード-1>A/AAAAレコード</h3>
<p>一般的にPodは下記のDNS解決となります。</p>
<p><code>pod-ip-address.my-namespace.pod.cluster-domain.example</code></p>
<p>例えば、<code>default</code>ネームスペースのpodのIPアドレスが172.17.0.3で、クラスターのドメイン名が<code>cluster.local</code>の場合、PodのDNS名は以下になります。</p>
<p><code>172-17-0-3.default.pod.cluster.local</code></p>
<p>DeploymentかDaemonSetに作成され、Serviceに公開されるどのPodも以下のDNS解決が利用できます。</p>
<p><code>pod-ip-address.deployment-name.my-namespace.svc.cluster-domain.example</code></p>
<h3 id=podのhostnameとsubdomainフィールド>Podのhostnameとsubdomainフィールド</h3>
<p>現在、Podが作成されたとき、そのPodのホスト名はPodの<code>metadata.name</code>フィールドの値となります。</p>
<p>Pod Specは、オプションである<code>hostname</code>フィールドを持ち、Podのホスト名を指定するために使うことができます。<code>hostname</code>が指定されたとき、<code>hostname</code>はそのPodの名前よりも優先されます。例えば、<code>hostname</code>フィールドが"<code>my-host</code>"にセットされたPodを考えると、Podはそのhostnameが"<code>my-host</code>"に設定されます。</p>
<p>Pod Specはまた、オプションである<code>subdomain</code>フィールドも持ち、Podのサブドメイン名を指定するために使うことができます。例えば、"<code>my-namespace</code>"というネームスペース内で<code>hostname</code>が<code>foo</code>とセットされていて、<code>subdomain</code>が<code>bar</code>とセットされているPodの場合、そのPodは"<code>foo.bar.my-namespace.svc.cluster.local</code>"という名前の完全修飾ドメイン名(FQDN)を持つことになります。</p>
<p>例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 実際は、portは必要ありません。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>busybox-1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subdomain</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>busybox-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subdomain</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></code></pre></div><p>もしそのPodと同じネームスペース内で、同じサブドメインを持ったHeadless Serviceが存在していた場合、クラスターのDNSサーバーもまた、そのPodの完全修飾ドメイン名(FQDN)に対するA(AAAA)レコードを返します。
例えば、"<code>busybox-1</code>"というホスト名で、"<code>default-subdomain</code>"というサブドメインを持ったPodと、そのPodと同じネームスペース内にある"<code>default-subdomain</code>"という名前のHeadless Serviceがあると考えると、そのPodは自身の完全修飾ドメイン名(FQDN)を"<code>busybox-1.default-subdomain.my-namespace.svc.cluster.local</code>"として扱います。DNSはそのPodのIPを指し示すA(AAAA)レコードを返します。"<code>busybox1</code>"と"<code>busybox2</code>"の両方のPodはそれぞれ独立したA(AAAA)レコードを持ちます。</p>
<p>そのエンドポイントオブジェクトはそのIPに加えて<code>hostname</code>を任意のエンドポイントアドレスに対して指定できます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> A(AAAA)レコードはPodの名前に対して作成されないため、<code>hostname</code>はPodのA(AAAA)レコードが作成されるために必須となります。<code>hostname</code>を持たないが<code>subdomain</code>を持つようなPodは、そのPodのIPアドレスを指し示すHeadless Service(<code>default-subdomain.my-namespace.svc.cluster.local</code>)に対するA(AAAA)レコードのみ作成します。
</div>
<h3 id=podのsethostnameasfqdnフィールド>PodのsetHostnameAsFQDNフィールド</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [alpha]</code>
</div>
<p><strong>前提条件</strong>: <a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API Server">API Server</a>に対して<code>SetHostnameAsFQDN</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にする必要があります。</p>
<p>Podが完全修飾ドメイン名(FQDN)を持つように構成されている場合、そのホスト名は短いホスト名です。
例えば、FQDNが<code>busybox-1.default-subdomain.my-namespace.svc.cluster-domain.example</code>のPodがある場合、
デフォルトではそのPod内の<code>hostname</code>コマンドは<code>busybox-1</code>を返し、<code>hostname --fqdn</code>コマンドはFQDNを返します。</p>
<p>Podのspecで<code>setHostnameAsFQDN: true</code>を設定した場合、そのPodの名前空間に対してkubeletはPodのFQDNをホスト名に書き込みます。
この場合、<code>hostname</code>と<code>hostname --fqdn</code>の両方がPodのFQDNを返します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>Linuxでは、カーネルのホスト名のフィールド(<code>struct utsname</code>の<code>nodename</code>フィールド)は64文字に制限されています。</p>
<p>Podがこの機能を有効にしていて、そのFQDNが64文字より長い場合、Podは起動に失敗します。
Podは<code>Pending</code>ステータス(<code>kubectl</code>でみられる<code>ContainerCreating</code>)のままになり、「Podのホスト名とクラスタードメインからFQDNを作成できなかった」や、「FQDN<code>long-FQDN</code>が長すぎる(64文字が最大, 70文字が要求された)」などのエラーイベントが生成されます。</p>
<p>このシナリオのユーザー体験を向上させる1つの方法は、<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>admission webhook controller</a>を作成して、ユーザーがDeploymentなどのトップレベルのオブジェクトを作成するときにFQDNのサイズを制御することです。</p>
</div>
<h3 id=podのdnsポリシー>PodのDNSポリシー</h3>
<p>DNSポリシーはPod毎に設定できます。現在のKubernetesでは次のようなPod固有のDNSポリシーをサポートしています。これらのポリシーはPod Specの<code>dnsPolicy</code>フィールドで指定されます。</p>
<ul>
<li>"<code>Default</code>": そのPodはPodが稼働しているNodeから名前解決の設定を継承します。詳細に関しては、<a href=/docs/tasks/administer-cluster/dns-custom-nameservers/#inheriting-dns-from-the-node>関連する議論</a>を参照してください。</li>
<li>"<code>ClusterFirst</code>": "<code>www.kubernetes.io</code>"のようなクラスタードメインのサフィックスにマッチしないようなDNSクエリーは、Nodeから継承された上流のネームサーバーにフォワーディングされます。クラスター管理者は、追加のstubドメインと上流のDNSサーバーを設定できます。このような場合におけるDNSクエリー処理の詳細に関しては、<a href=/docs/tasks/administer-cluster/dns-custom-nameservers/#effects-on-pods>関連する議論</a>を参照してください。</li>
<li>"<code>ClusterFirstWithHostNet</code>": hostNetworkによって稼働しているPodに対しては、ユーザーは明示的にDNSポリシーを"<code>ClusterFirstWithHostNet</code>"とセットするべきです。</li>
<li>"<code>None</code>": この設定では、Kubernetesの環境からDNS設定を無視することができます。全てのDNS設定は、Pod Spec内の<code>dnsConfig</code>フィールドを指定して提供することになっています。下記のセクションの<a href=#pod-dns-config>Pod's DNS config</a>を参照ください。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> "Default"は、デフォルトのDNSポリシーではありません。もし<code>dnsPolicy</code>が明示的に指定されていない場合、"ClusterFirst"が使用されます。
</div>
<p>下記の例では、<code>hostNetwork</code>フィールドが<code>true</code>にセットされているため、<code>dnsPolicy</code>が"<code>ClusterFirstWithHostNet</code>"とセットされているPodを示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>ClusterFirstWithHostNet<span style=color:#bbb>
</span></code></pre></div><h3 id=pod-dns-config>PodのDNS設定</h3>
<p>PodのDNS設定は、ユーザーがPodに対してそのDNS設定上でさらに制御するための手段を提供します。</p>
<p><code>dnsConfig</code>フィールドはオプションで、どのような設定の<code>dnsPolicy</code>でも共に機能することができます。しかし、Podの<code>dnsPolicy</code>が"<code>None</code>"にセットされていたとき、<code>dnsConfig</code>フィールドは必ず指定されなくてはなりません。</p>
<p>下記の項目は、ユーザーが<code>dnsConfig</code>フィールドに指定可能なプロパティーとなります。</p>
<ul>
<li><code>nameservers</code>: そのPodに対するDNSサーバーとして使われるIPアドレスのリストです。これは最大で3つのIPアドレスを指定することができます。Podの<code>dnsPolicy</code>が"<code>None</code>"に指定されていたとき、そのリストは最低1つのIPアドレスを指定しなければならず、もし指定されていなければ、それ以外の<code>dnsPolicy</code>の値の場合は、このプロパティーはオプションとなります。</li>
<li><code>searches</code>: Pod内のホスト名のルックアップのためのDNSサーチドメインのリストです。このプロパティーはオプションです。指定されていたとき、このリストは選択されたDNSポリシーから生成されたサーチドメイン名のベースとなるリストにマージされます。重複されているドメイン名は削除されます。Kubernetesでは最大6つのサーチドメインの設定を許可しています。</li>
<li><code>options</code>: <code>name</code>プロパティー(必須)と<code>value</code>プロパティー(オプション)を持つような各オプジェクトのリストで、これはオプションです。このプロパティー内の内容は指定されたDNSポリシーから生成されたオプションにマージされます。重複されたエントリーは削除されます。</li>
</ul>
<p>下記のファイルはカスタムDNS設定を持ったPodの例です。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/custom-dns.yaml download=service/networking/custom-dns.yaml><code>service/networking/custom-dns.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-custom-dns-yaml')" title="Copy service/networking/custom-dns.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-custom-dns-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dns-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;None&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsConfig</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nameservers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#666>1.2.3.4</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>searches</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- ns1.svc.cluster.local<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- my.dns.search.suffix<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>options</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ndots<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>edns0<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>上記のPodが作成されたとき、<code>test</code>コンテナは、コンテナ内の<code>/etc/resolv.conf</code>ファイル内にある下記の内容を取得します。</p>
<pre><code>nameserver 1.2.3.4
search ns1.svc.cluster.local my.dns.search.suffix
options ndots:2 edns0
</code></pre><p>IPv6用のセットアップのためには、サーチパスとname serverは下記のようにセットアップするべきです。</p>
<pre><code>$ kubectl exec -it dns-example -- cat /etc/resolv.conf
nameserver fd00:79:30::a
search default.svc.cluster.local svc.cluster.local cluster.local
options ndots:5
</code></pre><h3 id=dns機能を利用可用なバージョン>DNS機能を利用可用なバージョン</h3>
<p>PodのDNS設定と"<code>None</code>"というDNSポリシーの利用可能なバージョンに関しては下記の通りです。</p>
<table>
<thead>
<tr>
<th style=text-align:center>k8s version</th>
<th style=text-align:center>Feature support</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center>1.14</td>
<td style=text-align:center>ステーブル</td>
</tr>
<tr>
<td style=text-align:center>1.10</td>
<td style=text-align:center>β版 (デフォルトで有効)</td>
</tr>
<tr>
<td style=text-align:center>1.9</td>
<td style=text-align:center>α版</td>
</tr>
</tbody>
</table>
<h2 id=次の項目>次の項目</h2>
<p>DNS設定の管理方法に関しては、<a href=/docs/tasks/administer-cluster/dns-custom-nameservers/>DNS Serviceの設定</a>
を確認してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f804ac0532fcade3966ea2e3769ca031>3.5.4 - サービスとアプリケーションの接続</h1>
<h2 id=コンテナを接続するためのkubernetesモデル>コンテナを接続するためのKubernetesモデル</h2>
<p>継続的に実行され、複製されたアプリケーションの準備ができたので、ネットワーク上で公開することが可能になります。
Kubernetesのネットワークのアプローチについて説明する前に、Dockerの「通常の」ネットワーク手法と比較することが重要です。</p>
<p>デフォルトでは、Dockerはホストプライベートネットワーキングを使用するため、コンテナは同じマシン上にある場合にのみ他のコンテナと通信できます。
Dockerコンテナがノード間で通信するには、マシンのIPアドレスにポートを割り当ててから、コンテナに転送またはプロキシする必要があります。
これは明らかに、コンテナが使用するポートを非常に慎重に調整するか、ポートを動的に割り当てる必要があることを意味します。</p>
<p>コンテナを提供する複数の開発者やチーム間でポートの割り当てを調整することは、規模的に大変困難であり、ユーザが制御できないクラスターレベルの問題にさらされます。
Kubernetesでは、どのホストで稼働するかに関わらず、Podが他のPodと通信できると想定しています。
すべてのPodに独自のクラスタープライベートIPアドレスを付与するため、Pod間のリンクを明示的に作成したり、コンテナポートをホストポートにマップしたりする必要はありません。
これは、Pod内のコンテナがすべてlocalhostの相互のポートに到達でき、クラスター内のすべてのPodがNATなしで相互に認識できることを意味します。
このドキュメントの残りの部分では、このようなネットワークモデルで信頼できるサービスを実行する方法について詳しく説明します。</p>
<p>このガイドでは、シンプルなnginxサーバーを使用して概念実証を示します。</p>
<h2 id=podをクラスターに公開する>Podをクラスターに公開する</h2>
<p>前の例でネットワークモデルを紹介しましたが、再度ネットワークの観点に焦点を当てましょう。
nginx Podを作成し、コンテナポートの仕様を指定していることに注意してください。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/run-my-nginx.yaml download=service/networking/run-my-nginx.yaml><code>service/networking/run-my-nginx.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-run-my-nginx-yaml')" title="Copy service/networking/run-my-nginx.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-run-my-nginx-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>これにより、クラスター内のどのノードからでもアクセスできるようになります。
Podが実行されているノードを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f ./run-my-nginx.yaml
kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o wide
</code></pre></div><pre><code>NAME                        READY     STATUS    RESTARTS   AGE       IP            NODE
my-nginx-3800858182-jr4a2   1/1       Running   0          13s       10.244.3.4    kubernetes-minion-905m
my-nginx-3800858182-kna2y   1/1       Running   0          13s       10.244.2.5    kubernetes-minion-ljyd
</code></pre><p>PodのIPを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o yaml | grep podIP
    podIP: 10.244.3.4
    podIP: 10.244.2.5
</code></pre></div><p>クラスター内の任意のノードにSSH接続し、両方のIPにcurl接続できるはずです。
コンテナはノードでポート80を使用<strong>していない</strong>ことに注意してください。
また、Podにトラフィックをルーティングする特別なNATルールもありません。
つまり、同じcontainerPortを使用して同じノードで複数のnginx Podを実行し、IPを使用してクラスター内の他のPodやノードからそれらにアクセスできます。
Dockerと同様に、ポートは引き続きホストノードのインターフェイスに公開できますが、ネットワークモデルにより、この必要性は根本的に減少します。</p>
<p>興味があれば、これを<a href=/docs/concepts/cluster-administration/networking/#how-to-achieve-this>どのように達成するか</a>について詳しく読むことができます。</p>
<h2 id=serviceを作成する>Serviceを作成する</h2>
<p>そのため、フラットでクラスター全体のアドレス空間でnginxを実行するPodがあります。
理論的には、これらのPodと直接通信することができますが、ノードが停止するとどうなりますか？
Podはそれで死に、Deploymentは異なるIPを持つ新しいものを作成します。
これは、Serviceが解決する問題です。</p>
<p>Kubernetes Serviceは、クラスター内のどこかで実行されるPodの論理セットを定義する抽象化であり、すべて同じ機能を提供します。
作成されると、各Serviceには一意のIPアドレス(clusterIPとも呼ばれます)が割り当てられます。
このアドレスはServiceの有効期間に関連付けられており、Serviceが動作している間は変更されません。
Podは、Serviceと通信するように構成でき、Serviceへの通信は、ServiceのメンバーであるPodに自動的に負荷分散されることを認識できます。</p>
<p>2つのnginxレプリカのサービスを<code>kubectl expose</code>で作成できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment/my-nginx
</code></pre></div><pre><code>service/my-nginx exposed
</code></pre><p>これは次のyamlを<code>kubectl apply -f</code>することと同等です:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/nginx-svc.yaml download=service/networking/nginx-svc.yaml><code>service/networking/nginx-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-nginx-svc-yaml')" title="Copy service/networking/nginx-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-nginx-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>この仕様は、<code>run：my-nginx</code>ラベルを持つ任意のPodのTCPポート80をターゲットとするサービスを作成し、抽象化されたサービスポートでPodを公開します(<code>targetPort</code>:はコンテナがトラフィックを受信するポート、<code>port</code>:は抽象化されたServiceのポートであり、他のPodがServiceへのアクセスに使用する任意のポートにすることができます)。
サービス定義でサポートされているフィールドのリストは<a href=/docs/reference/generated/kubernetes-api/v1.22/#service-v1-core>Service</a> APIオブジェクトを参照してください。</p>
<p>Serviceを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-nginx
</code></pre></div><pre><code>NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
my-nginx   ClusterIP   10.0.162.149   &lt;none&gt;        80/TCP    21s
</code></pre><p>前述のように、ServiceはPodのグループによってサポートされています。
これらのPodはエンドポイントを通じて公開されます。
Serviceのセレクターは継続的に評価され、結果は<code>my-nginx</code>という名前のEndpointsオブジェクトにPOSTされます。
Podが終了すると、エンドポイントから自動的に削除され、Serviceのセレクターに一致する新しいPodが自動的にエンドポイントに追加されます。
エンドポイントを確認し、IPが最初のステップで作成されたPodと同じであることを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe svc my-nginx
</code></pre></div><pre><code>Name:                my-nginx
Namespace:           default
Labels:              run=my-nginx
Annotations:         &lt;none&gt;
Selector:            run=my-nginx
Type:                ClusterIP
IP:                  10.0.162.149
Port:                &lt;unset&gt; 80/TCP
Endpoints:           10.244.2.5:80,10.244.3.4:80
Session Affinity:    None
Events:              &lt;none&gt;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get ep my-nginx
</code></pre></div><pre><code>NAME       ENDPOINTS                     AGE
my-nginx   10.244.2.5:80,10.244.3.4:80   1m
</code></pre><p>クラスター内の任意のノードから、<code>&lt;CLUSTER-IP>:&lt;PORT></code>でnginx Serviceにcurl接続できるようになりました。
Service IPは完全に仮想的なもので、ホスト側のネットワークには接続できないことに注意してください。
この仕組みに興味がある場合は、<a href=/ja/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>サービスプロキシー</a>の詳細をお読みください。</p>
<h2 id=serviceにアクセスする>Serviceにアクセスする</h2>
<p>Kubernetesは、環境変数とDNSの2つの主要なService検索モードをサポートしています。
前者はそのまま使用でき、後者は<a href=https://releases.k8s.io/v1.22.16/cluster/addons/dns/coredns>CoreDNSクラスタアドオン</a>を必要とします。
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> サービス環境変数が望ましくない場合(予想されるプログラム変数と衝突する可能性がある、処理する変数が多すぎる、DNSのみを使用するなど)、<a href=/docs/reference/generated/kubernetes-api/v1.22/#pod-v1-core>Pod仕様</a>で<code>enableServiceLinks</code>フラグを<code>false</code>に設定することでこのモードを無効にできます。
</div></p>
<h3 id=環境変数>環境変数</h3>
<p>ノードでPodが実行されると、kubeletはアクティブな各サービスの環境変数のセットを追加します。
これにより、順序付けの問題が発生します。
理由を確認するには、実行中のnginx Podの環境を調べます(Pod名は環境によって異なります):</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> my-nginx-3800858182-jr4a2 -- printenv | grep SERVICE
</code></pre></div><pre><code>KUBERNETES_SERVICE_HOST=10.0.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><p>サービスに言及がないことに注意してください。これは、サービスの前にレプリカを作成したためです。
これのもう1つの欠点は、スケジューラーが両方のPodを同じマシンに配置し、サービスが停止した場合にサービス全体がダウンする可能性があることです。
2つのPodを強制終了し、Deploymentがそれらを再作成するのを待つことで、これを正しい方法で実行できます。
今回は、サービスはレプリカの「前」に存在します。
これにより、スケジューラーレベルのサービスがPodに広がり(すべてのノードの容量が等しい場合)、適切な環境変数が提供されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment my-nginx --replicas<span style=color:#666>=</span>0; kubectl scale deployment my-nginx --replicas<span style=color:#666>=</span>2;

kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o wide
</code></pre></div><pre><code>NAME                        READY     STATUS    RESTARTS   AGE     IP            NODE
my-nginx-3800858182-e9ihh   1/1       Running   0          5s      10.244.2.7    kubernetes-minion-ljyd
my-nginx-3800858182-j4rm4   1/1       Running   0          5s      10.244.3.8    kubernetes-minion-905m
</code></pre><p>Podは強制終了されて再作成されるため、異なる名前が付いていることに気付くでしょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> my-nginx-3800858182-e9ihh -- printenv | grep SERVICE
</code></pre></div><pre><code>KUBERNETES_SERVICE_PORT=443
MY_NGINX_SERVICE_HOST=10.0.162.149
KUBERNETES_SERVICE_HOST=10.0.0.1
MY_NGINX_SERVICE_PORT=80
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><h3 id=dns>DNS</h3>
<p>Kubernetesは、DNS名を他のServiceに自動的に割り当てるDNSクラスターアドオンサービスを提供します。
クラスターで実行されているかどうかを確認できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get services kube-dns --namespace<span style=color:#666>=</span>kube-system
</code></pre></div><pre><code>NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE
kube-dns   ClusterIP   10.0.0.10    &lt;none&gt;        53/UDP,53/TCP   8m
</code></pre><p>このセクションの残りの部分は、寿命の長いIP(my-nginx)を持つServiceと、そのIPに名前を割り当てたDNSサーバーがあることを前提にしています。ここではCoreDNSクラスターアドオン(アプリケーション名: <code>kube-dns</code>)を使用しているため、標準的なメソッド(<code>gethostbyname()</code>など) を使用してクラスター内の任意のPodからServiceに通信できます。CoreDNSが起動していない場合、<a href=https://github.com/coredns/deployment/tree/master/kubernetes>CoreDNS README</a>または<a href=/docs/tasks/administer-cluster/coredns/#installing-coredns>Installing CoreDNS</a>を参照し、有効にする事ができます。curlアプリケーションを実行して、これをテストしてみましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run curl --image<span style=color:#666>=</span>radial/busyboxplus:curl -i --tty
</code></pre></div><pre><code>Waiting for pod default/curl-131556218-9fnch to be running, status is Pending, pod ready: false
Hit enter for command prompt
</code></pre><p>次に、Enterキーを押して<code>nslookup my-nginx</code>を実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#666>[</span> root@curl-131556218-9fnch:/ <span style=color:#666>]</span>$ nslookup my-nginx
Server:    10.0.0.10
Address 1: 10.0.0.10

Name:      my-nginx
Address 1: 10.0.162.149
</code></pre></div><h2 id=serviceを安全にする>Serviceを安全にする</h2>
<p>これまでは、クラスター内からnginxサーバーにアクセスしただけでした。
サービスをインターネットに公開する前に、通信チャネルが安全であることを確認する必要があります。
これには、次のものが必要です:</p>
<ul>
<li>https用の自己署名証明書(既にID証明書を持っている場合を除く)</li>
<li>証明書を使用するように構成されたnginxサーバー</li>
<li>Podが証明書にアクセスできるようにする<a href=/docs/concepts/configuration/secret/>Secret</a></li>
</ul>
<p>これらはすべて<a href=https://github.com/kubernetes/examples/tree/v1.22.16/staging/https-nginx/>nginx httpsの例</a>から取得できます。
これにはツールをインストールする必要があります。
これらをインストールしたくない場合は、後で手動の手順に従ってください。つまり:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>make keys <span style=color:#b8860b>KEY</span><span style=color:#666>=</span>/tmp/nginx.key <span style=color:#b8860b>CERT</span><span style=color:#666>=</span>/tmp/nginx.crt
kubectl create secret tls nginxsecret --key /tmp/nginx.key --cert /tmp/nginx.crt
</code></pre></div><pre><code>secret/nginxsecret created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secrets
</code></pre></div><pre><code>NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           kubernetes.io/tls                     2         1m
</code></pre><p>configmapも作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap nginxconfigmap --from-file<span style=color:#666>=</span>default.conf
</code></pre></div><pre><code>configmap/nginxconfigmap created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmaps
</code></pre></div><pre><code>NAME             DATA   AGE
nginxconfigmap   1      114s
</code></pre><p>以下は、(Windows上など)makeの実行で問題が発生した場合に実行する手動の手順です:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 公開秘密鍵ペアを作成します</span>
openssl req -x509 -nodes -days <span style=color:#666>365</span> -newkey rsa:2048 -keyout /d/tmp/nginx.key -out /d/tmp/nginx.crt -subj <span style=color:#b44>&#34;/CN=my-nginx/O=my-nginx&#34;</span>
<span style=color:#080;font-style:italic># キーをbase64エンコードに変換します</span>
cat /d/tmp/nginx.crt | base64
cat /d/tmp/nginx.key | base64
</code></pre></div><p>前のコマンドの出力を使用して、次のようにyamlファイルを作成します。
base64でエンコードされた値はすべて1行である必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Secret&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginxsecret&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;default&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nginx.crt</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURIekNDQWdlZ0F3SUJBZ0lKQUp5M3lQK0pzMlpJTUEwR0NTcUdTSWIzRFFFQkJRVUFNQ1l4RVRBUEJnTlYKQkFNVENHNW5hVzU0YzNaak1SRXdEd1lEVlFRS0V3aHVaMmx1ZUhOMll6QWVGdzB4TnpFd01qWXdOekEzTVRKYQpGdzB4T0RFd01qWXdOekEzTVRKYU1DWXhFVEFQQmdOVkJBTVRDRzVuYVc1NGMzWmpNUkV3RHdZRFZRUUtFd2h1CloybHVlSE4yWXpDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBSjFxSU1SOVdWM0IKMlZIQlRMRmtobDRONXljMEJxYUhIQktMSnJMcy8vdzZhU3hRS29GbHlJSU94NGUrMlN5ajBFcndCLzlYTnBwbQppeW1CL3JkRldkOXg5UWhBQUxCZkVaTmNiV3NsTVFVcnhBZW50VWt1dk1vLzgvMHRpbGhjc3paenJEYVJ4NEo5Ci82UVRtVVI3a0ZTWUpOWTVQZkR3cGc3dlVvaDZmZ1Voam92VG42eHNVR0M2QURVODBpNXFlZWhNeVI1N2lmU2YKNHZpaXdIY3hnL3lZR1JBRS9mRTRqakxCdmdONjc2SU90S01rZXV3R0ljNDFhd05tNnNTSzRqYUNGeGpYSnZaZQp2by9kTlEybHhHWCtKT2l3SEhXbXNhdGp4WTRaNVk3R1ZoK0QrWnYvcW1mMFgvbVY0Rmo1NzV3ajFMWVBocWtsCmdhSXZYRyt4U1FVQ0F3RUFBYU5RTUU0d0hRWURWUjBPQkJZRUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjcKTUI4R0ExVWRJd1FZTUJhQUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjdNQXdHQTFVZEV3UUZNQU1CQWY4dwpEUVlKS29aSWh2Y05BUUVGQlFBRGdnRUJBRVhTMW9FU0lFaXdyMDhWcVA0K2NwTHI3TW5FMTducDBvMm14alFvCjRGb0RvRjdRZnZqeE04Tzd2TjB0clcxb2pGSW0vWDE4ZnZaL3k4ZzVaWG40Vm8zc3hKVmRBcStNZC9jTStzUGEKNmJjTkNUekZqeFpUV0UrKzE5NS9zb2dmOUZ3VDVDK3U2Q3B5N0M3MTZvUXRUakViV05VdEt4cXI0Nk1OZWNCMApwRFhWZmdWQTRadkR4NFo3S2RiZDY5eXM3OVFHYmg5ZW1PZ05NZFlsSUswSGt0ejF5WU4vbVpmK3FqTkJqbWZjCkNnMnlwbGQ0Wi8rUUNQZjl3SkoybFIrY2FnT0R4elBWcGxNSEcybzgvTHFDdnh6elZPUDUxeXdLZEtxaUMwSVEKQ0I5T2wwWW5scE9UNEh1b2hSUzBPOStlMm9KdFZsNUIyczRpbDlhZ3RTVXFxUlU9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nginx.key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRQ2RhaURFZlZsZHdkbFIKd1V5eFpJWmVEZWNuTkFhbWh4d1NpeWF5N1AvOE9ta3NVQ3FCWmNpQ0RzZUh2dGtzbzlCSzhBZi9WemFhWm9zcApnZjYzUlZuZmNmVUlRQUN3WHhHVFhHMXJKVEVGSzhRSHA3VkpMcnpLUC9QOUxZcFlYTE0yYzZ3MmtjZUNmZitrCkU1bEVlNUJVbUNUV09UM3c4S1lPNzFLSWVuNEZJWTZMMDUrc2JGQmd1Z0ExUE5JdWFubm9UTWtlZTRuMG4rTDQKb3NCM01ZUDhtQmtRQlAzeE9JNHl3YjREZXUraURyU2pKSHJzQmlIT05Xc0RadXJFaXVJMmdoY1kxeWIyWHI2UAozVFVOcGNSbC9pVG9zQngxcHJHclk4V09HZVdPeGxZZmcvbWIvNnBuOUYvNWxlQlkrZStjSTlTMkQ0YXBKWUdpCkwxeHZzVWtGQWdNQkFBRUNnZ0VBZFhCK0xkbk8ySElOTGo5bWRsb25IUGlHWWVzZ294RGQwci9hQ1Zkank4dlEKTjIwL3FQWkUxek1yall6Ry9kVGhTMmMwc0QxaTBXSjdwR1lGb0xtdXlWTjltY0FXUTM5SjM0VHZaU2FFSWZWNgo5TE1jUHhNTmFsNjRLMFRVbUFQZytGam9QSFlhUUxLOERLOUtnNXNrSE5pOWNzMlY5ckd6VWlVZWtBL0RBUlBTClI3L2ZjUFBacDRuRWVBZmI3WTk1R1llb1p5V21SU3VKdlNyblBESGtUdW1vVlVWdkxMRHRzaG9reUxiTWVtN3oKMmJzVmpwSW1GTHJqbGtmQXlpNHg0WjJrV3YyMFRrdWtsZU1jaVlMbjk4QWxiRi9DSmRLM3QraTRoMTVlR2ZQegpoTnh3bk9QdlVTaDR2Q0o3c2Q5TmtEUGJvS2JneVVHOXBYamZhRGR2UVFLQmdRRFFLM01nUkhkQ1pKNVFqZWFKClFGdXF4cHdnNzhZTjQyL1NwenlUYmtGcVFoQWtyczJxWGx1MDZBRzhrZzIzQkswaHkzaE9zSGgxcXRVK3NHZVAKOWRERHBsUWV0ODZsY2FlR3hoc0V0L1R6cEdtNGFKSm5oNzVVaTVGZk9QTDhPTm1FZ3MxMVRhUldhNzZxelRyMgphRlpjQ2pWV1g0YnRSTHVwSkgrMjZnY0FhUUtCZ1FEQmxVSUUzTnNVOFBBZEYvL25sQVB5VWs1T3lDdWc3dmVyClUycXlrdXFzYnBkSi9hODViT1JhM05IVmpVM25uRGpHVHBWaE9JeXg5TEFrc2RwZEFjVmxvcG9HODhXYk9lMTAKMUdqbnkySmdDK3JVWUZiRGtpUGx1K09IYnRnOXFYcGJMSHBzUVpsMGhucDBYSFNYVm9CMUliQndnMGEyOFVadApCbFBtWmc2d1BRS0JnRHVIUVV2SDZHYTNDVUsxNFdmOFhIcFFnMU16M2VvWTBPQm5iSDRvZUZKZmcraEppSXlnCm9RN3hqWldVR3BIc3AyblRtcHErQWlSNzdyRVhsdlhtOElVU2FsbkNiRGlKY01Pc29RdFBZNS9NczJMRm5LQTQKaENmL0pWb2FtZm1nZEN0ZGtFMXNINE9MR2lJVHdEbTRpb0dWZGIwMllnbzFyb2htNUpLMUI3MkpBb0dBUW01UQpHNDhXOTVhL0w1eSt5dCsyZ3YvUHM2VnBvMjZlTzRNQ3lJazJVem9ZWE9IYnNkODJkaC8xT2sybGdHZlI2K3VuCnc1YytZUXRSTHlhQmd3MUtpbGhFZDBKTWU3cGpUSVpnQWJ0LzVPbnlDak9OVXN2aDJjS2lrQ1Z2dTZsZlBjNkQKckliT2ZIaHhxV0RZK2Q1TGN1YSt2NzJ0RkxhenJsSlBsRzlOZHhrQ2dZRUF5elIzT3UyMDNRVVV6bUlCRkwzZAp4Wm5XZ0JLSEo3TnNxcGFWb2RjL0d5aGVycjFDZzE2MmJaSjJDV2RsZkI0VEdtUjZZdmxTZEFOOFRwUWhFbUtKCnFBLzVzdHdxNWd0WGVLOVJmMWxXK29xNThRNTBxMmk1NVdUTThoSDZhTjlaMTltZ0FGdE5VdGNqQUx2dFYxdEYKWSs4WFJkSHJaRnBIWll2NWkwVW1VbGc9Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>ファイルを使用してSecretを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f nginxsecrets.yaml
kubectl get secrets
</code></pre></div><pre><code>NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           kubernetes.io/tls                     2         1m
</code></pre><p>次に、nginxレプリカを変更して、シークレットの証明書とServiceを使用してhttpsサーバーを起動し、両方のポート(80と443)を公開します:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/nginx-secure-app.yaml download=service/networking/nginx-secure-app.yaml><code>service/networking/nginx-secure-app.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-nginx-secure-app-yaml')" title="Copy service/networking/nginx-secure-app.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-nginx-secure-app-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>https<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>nginxsecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginxhttps<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>bprashanth/nginxhttps:1.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/ssl<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>nginx-secure-appマニフェストに関する注目すべき点:</p>
<ul>
<li>同じファイルにDeploymentとServiceの両方が含まれています。</li>
<li><a href=https://github.com/kubernetes/examples/tree/v1.22.16/staging/https-nginx/default.conf>nginxサーバー</a>はポート80のHTTPトラフィックと443のHTTPSトラフィックを処理し、nginx Serviceは両方のポートを公開します。</li>
<li>各コンテナは<code>/etc/nginx/ssl</code>にマウントされたボリュームを介してキーにアクセスできます。
これは、nginxサーバーが起動する<em>前に</em>セットアップされます。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployments,svc my-nginx; kubectl create -f ./nginx-secure-app.yaml
</code></pre></div><p>この時点で、任意のノードからnginxサーバーに到達できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -o yaml | grep -i podip
    podIP: 10.244.3.5
node $ curl -k https://10.244.3.5
...
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</code></pre></div><p>最後の手順でcurlに<code>-k</code>パラメーターを指定したことに注意してください。
これは、証明書の生成時にnginxを実行しているPodについて何も知らないためです。
CNameの不一致を無視するようcurlに指示する必要があります。
Serviceを作成することにより、証明書で使用されるCNameを、Service検索中にPodで使用される実際のDNS名にリンクしました。
これをPodからテストしましょう(簡単にするために同じシークレットを再利用しています。PodはServiceにアクセスするためにnginx.crtのみを必要とします):</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/curlpod.yaml download=service/networking/curlpod.yaml><code>service/networking/curlpod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-curlpod-yaml')" title="Copy service/networking/curlpod.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-curlpod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>curl-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>nginxsecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- sh<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- while true; do sleep 1; done<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>radial/busyboxplus:curl<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/ssl<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f ./curlpod.yaml
kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>curlpod
</code></pre></div><pre><code>NAME                               READY     STATUS    RESTARTS   AGE
curl-deployment-1515033274-1410r   1/1       Running   0          1m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> curl-deployment-1515033274-1410r -- curl https://my-nginx --cacert /etc/nginx/ssl/tls.crt
...
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
...
</code></pre></div><h2 id=serviceを公開する>Serviceを公開する</h2>
<p>アプリケーションの一部では、Serviceを外部IPアドレスに公開したい場合があります。
Kubernetesは、NodePortとLoadBalancerの2つの方法をサポートしています。
前のセクションで作成したServiceはすでに<code>NodePort</code>を使用しているため、ノードにパブリックIPがあれば、nginx HTTPSレプリカはインターネット上のトラフィックを処理する準備ができています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-nginx -o yaml | grep nodePort -C <span style=color:#666>5</span>
  uid: 07191fb3-f61a-11e5-8ae5-42010af00002
spec:
  clusterIP: 10.0.162.149
  ports:
  - name: http
    nodePort: <span style=color:#666>31704</span>
    port: <span style=color:#666>8080</span>
    protocol: TCP
    targetPort: <span style=color:#666>80</span>
  - name: https
    nodePort: <span style=color:#666>32453</span>
    port: <span style=color:#666>443</span>
    protocol: TCP
    targetPort: <span style=color:#666>443</span>
  selector:
    run: my-nginx
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes -o yaml | grep ExternalIP -C <span style=color:#666>1</span>
    - address: 104.197.41.11
      type: ExternalIP
    allocatable:
--
    - address: 23.251.152.56
      type: ExternalIP
    allocatable:
...

$ curl https://&lt;EXTERNAL-IP&gt;:&lt;NODE-PORT&gt; -k
...
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</code></pre></div><p>クラウドロードバランサーを使用するようにサービスを再作成しましょう。
<code>my-nginx</code>サービスの<code>Type</code>を<code>NodePort</code>から<code>LoadBalancer</code>に変更するだけです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit svc my-nginx
kubectl get svc my-nginx
</code></pre></div><pre><code>NAME       TYPE           CLUSTER-IP     EXTERNAL-IP        PORT(S)               AGE
my-nginx   LoadBalancer   10.0.162.149     xx.xxx.xxx.xxx     8080:30163/TCP        21s
</code></pre><pre><code>curl https://&lt;EXTERNAL-IP&gt; -k
...
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</code></pre><p><code>EXTERNAL-IP</code>列のIPアドレスは、パブリックインターネットで利用可能なものです。
<code>CLUSTER-IP</code>は、クラスター/プライベートクラウドネットワーク内でのみ使用できます。</p>
<p>AWSでは、type <code>LoadBalancer</code>はIPではなく(長い)ホスト名を使用するELBが作成されます。
実際、標準の<code>kubectl get svc</code>の出力に収まるには長すぎるので、それを確認するには<code>kubectl describe service my-nginx</code>を実行する必要があります。
次のようなものが表示されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe service my-nginx
...
LoadBalancer Ingress:   a320587ffd19711e5a37606cf4a74574-1142138393.us-east-1.elb.amazonaws.com
...
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li>詳細: <a href=/ja/docs/tasks/access-application-cluster/service-access-application-cluster/>Serviceを利用したクラスター内のアプリケーションへのアクセス</a></li>
<li>詳細: <a href=/ja/docs/tasks/access-application-cluster/connecting-frontend-backend/>Serviceを使用してフロントエンドをバックエンドに接続する</a></li>
<li>詳細: <a href=/docs/tasks/access-application-cluster/create-external-load-balancer/>Creating an External Load Balancer</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f51db1097575de8072afe1f5b156a70c>3.5.5 - EndpointSlice</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code>
</div>
<p><em>EndpointSlice</em>は、Kubernetesクラスター内にあるネットワークエンドポイントを追跡するための単純な手段を提供します。EndpointSliceは、よりスケーラブルでより拡張可能な、Endpointの代わりとなるものです。</p>
<h2 id=動機>動機</h2>
<p>Endpoint APIはKubernetes内のネットワークエンドポイントを追跡する単純で直観的な手段を提供してきました。
残念ながら、Kubernetesクラスターや<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>が大規模になり、より多くのトラフィックを処理し、より多くのバックエンドPodに送信するようになるにしたがって、Endpoint APIの限界が明らかになってきました。
最も顕著な問題の1つに、ネットワークエンドポイントの数が大きくなったときのスケーリングの問題があります。</p>
<p>Serviceのすべてのネットワークエンドポイントが単一のEndpointリソースに格納されていたため、リソースのサイズが非常に大きくなる場合がありました。これがKubernetesのコンポーネント(特に、マスターコントロールプレーン)の性能に悪影響を与え、結果として、Endpointに変更があるたびに、大量のネットワークトラフィックと処理が発生するようになってしまいました。EndpointSliceは、この問題を緩和するとともに、トポロジカルルーティングなどの追加機能のための拡張可能なプラットフォームを提供します。</p>
<h2 id=endpointslice-resource>EndpointSliceリソース</h2>
<p>Kubernetes内ではEndpointSliceにはネットワークエンドポイントの集合へのリファレンスが含まれます。
コントロールプレーンは、<a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=セレクター>セレクター</a>が指定されているKubernetes ServiceのEndpointSliceを自動的に作成します。
これらのEndpointSliceには、Serviceセレクターに一致するすべてのPodへのリファレンスが含まれています。
EndpointSliceは、プロトコル、ポート番号、およびサービス名の一意の組み合わせによってネットワークエンドポイントをグループ化します。
EndpointSliceオブジェクトの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<p>一例として、以下に<code>example</code>というKubernetes Serviceに対するサンプルのEndpointSliceリソースを示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>discovery.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EndpointSlice<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-abc<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>addressType</span>:<span style=color:#bbb> </span>IPv4<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>endpoints</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>pod-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topology</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/hostname</span>:<span style=color:#bbb> </span>node-1<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>topology.kubernetes.io/zone</span>:<span style=color:#bbb> </span>us-west2-a<span style=color:#bbb>
</span></code></pre></div><p>デフォルトでは、コントロールプレーンはEndpointSliceを作成・管理し、それぞれのエンドポイント数が100以下になるようにします。<code>--max-endpoints-per-slice</code><a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>フラグを設定することで、最大1000個まで設定可能です。</p>
<p>EndpointSliceは内部トラフィックのルーティング方法に関して、<a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>に対する唯一のソース(source of truth)として振る舞うことができます。EndpointSliceを有効にすれば、非常に多数のエンドポイントを持つServiceに対して性能向上が得られるはずです。</p>
<h3 id=アドレスの種類>アドレスの種類</h3>
<p>EndpointSliceは次の3種類のアドレスをサポートします。</p>
<ul>
<li>IPv4</li>
<li>IPv6</li>
<li>FQDN (Fully Qualified Domain Name、完全修飾ドメイン名)</li>
</ul>
<h3 id=topology>トポロジー</h3>
<p>EndpointSliceに属する各エンドポイントは、関連するトポロジーの情報を持つことができます。この情報は、エンドポイントの場所を示すために使われ、対応するNode、ゾーン、リージョンに関する情報が含まれます。
値が利用できる場合には、コントロールプレーンはEndpointSliceコントローラーに次のようなTopologyラベルを設定します。</p>
<ul>
<li><code>kubernetes.io/hostname</code> - このエンドポイントが存在するNodeの名前。</li>
<li><code>topology.kubernetes.io/zone</code> - このエンドポイントが存在するゾーン。</li>
<li><code>topology.kubernetes.io/region</code> - このエンドポイントが存在するリージョン。</li>
</ul>
<p>これらのラベルの値はスライス内の各エンドポイントと関連するリソースから継承したものです。hostnameラベルは対応するPod上のNodeNameフィールドの値を表します。zoneとregionラベルは対応するNode上の同じ名前のラベルの値を表します。</p>
<h3 id=管理>管理</h3>
<p>ほとんどの場合、コントロールプレーン（具体的には、EndpointSlice <a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>）は、EndpointSliceオブジェクトを作成および管理します。EndpointSliceには、サービスメッシュの実装など、他のさまざまなユースケースがあり、他のエンティティまたはコントローラーがEndpointSliceの追加セットを管理する可能性があります。</p>
<p>複数のエンティティが互いに干渉することなくEndpointSliceを管理できるようにするために、KubernetesはEndpointSliceを管理するエンティティを示す<code>endpointslice.kubernetes.io/managed-by</code>という<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=ラベル>ラベル</a>を定義します。
EndpointSliceを管理するその他のエンティティも同様に、このラベルにユニークな値を設定する必要があります。</p>
<h3 id=所有権>所有権</h3>
<p>ほとんどのユースケースでは、EndpointSliceはエンドポイントスライスオブジェクトがエンドポイントを追跡するServiceによって所有されます。
これは、各EndpointSlice上のownerリファレンスと<code>kubernetes.io/service-name</code>ラベルによって示されます。これにより、Serviceに属するすべてのEndpointSliceを簡単に検索できるようになっています。</p>
<h3 id=endpointsliceのミラーリング>EndpointSliceのミラーリング</h3>
<p>場合によっては、アプリケーションはカスタムEndpointリソースを作成します。これらのアプリケーションがEndpointリソースとEndpointSliceリソースの両方に同時に書き込む必要がないようにするために、クラスターのコントロールプレーンは、ほとんどのEndpointリソースを対応するEndpointSliceにミラーリングします。</p>
<p>コントロールプレーンは、次の場合を除いて、Endpointリソースをミラーリングします。</p>
<ul>
<li>Endpointリソースの<code>endpointslice.kubernetes.io/skip-mirror</code>ラベルが<code>true</code>に設定されています。</li>
<li>Endpointリソースが<code>control-plane.alpha.kubernetes.io/leader</code>アノテーションを持っています。</li>
<li>対応するServiceリソースが存在しません。</li>
<li>対応するServiceリソースには、nil以外のセレクターがあります。</li>
</ul>
<p>個々のEndpointリソースは、複数のEndpointSliceに変換される場合があります。これは、Endpointリソースに複数のサブセットがある場合、または複数のIPファミリ（IPv4およびIPv6）を持つエンドポイントが含まれている場合に発生します。サブセットごとに最大1000個のアドレスがEndpointSliceにミラーリングされます。</p>
<h3 id=endpointsliceの分散>EndpointSliceの分散</h3>
<p>それぞれのEndpointSliceにはポートの集合があり、リソース内のすべてのエンドポイントに適用されます。サービスが名前付きポートを使用した場合、Podが同じ名前のポートに対して、結果的に異なるターゲットポート番号が使用されて、異なるEndpointSliceが必要になる場合があります。これはサービスの部分集合がEndpointにグループ化される場合と同様です。</p>
<p>コントロールプレーンはEndpointSliceをできる限り充填しようとしますが、積極的にリバランスを行うことはありません。コントローラーのロジックは極めて単純で、以下のようになっています。</p>
<ol>
<li>既存のEndpointSliceをイテレートし、もう必要のないエンドポイントを削除し、変更があったエンドポイントを更新する。</li>
<li>前のステップで変更されたEndpointSliceをイテレートし、追加する必要がある新しいエンドポイントで充填する。</li>
<li>まだ追加するべき新しいエンドポイントが残っていた場合、これまで変更されなかったスライスに追加を試み、その後、新しいスライスを作成する。</li>
</ol>
<p>ここで重要なのは、3番目のステップでEndpointSliceを完全に分散させることよりも、EndpointSliceの更新を制限することを優先していることです。たとえば、もし新しい追加するべきエンドポイントが10個あり、2つのEndpointSliceにそれぞれ5個の空きがあった場合、このアプローチでは2つの既存のEndpointSliceを充填する代わりに、新しいEndpointSliceが作られます。言い換えれば、1つのEndpointSliceを作成する方が複数のEndpointSliceを更新するよりも好ましいということです。</p>
<p>各Node上で実行されているkube-proxyはEndpointSliceを監視しており、EndpointSliceに加えられた変更はクラスター内のすべてのNodeに送信されるため、比較的コストの高い処理になります。先ほどのアプローチは、たとえ複数のEndpointSliceが充填されない結果となるとしても、すべてのNodeへ送信しなければならない変更の数を抑制することを目的としています。</p>
<p>現実的には、こうしたあまり理想的ではない分散が発生することは稀です。EndpointSliceコントローラーによって処理されるほとんどの変更は、既存のEndpointSliceに収まるほど十分小さくなるためです。そうでなかったとしても、すぐに新しいEndpointSliceが必要になる可能性が高いです。また、Deploymentのローリングアップデートが行われれば、自然な再充填が行われます。Podとそれに対応するエンドポイントがすべて置換されるためです。</p>
<h3 id=エンドポイントの重複>エンドポイントの重複</h3>
<p>EndpointSliceの変更の性質上、エンドポイントは同時に複数のEndpointSliceで表される場合があります。
これは、さまざまなEndpointSliceオブジェクトへの変更が、さまざまな時間にKubernetesクライアントのウォッチ/キャッシュに到達する可能性があるために自然に発生します。
EndpointSliceを使用する実装では、エンドポイントを複数のスライスに表示できる必要があります。
エンドポイント重複排除を実行する方法のリファレンス実装は、<code>kube-proxy</code>の<code>EndpointSliceCache</code>実装にあります。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/administer-cluster/enabling-endpointslices>EndpointSliceの有効化</a>について学ぶ</li>
<li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>サービスとアプリケーションの接続</a>を読む</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-199bcc92443dbc9bed44819467d7eb75>3.5.6 - Ingress</h1>
<p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [stable]</code>
</div>
<p>クラスター内のServiceに対する外部からのアクセス(主にHTTP)を管理するAPIオブジェクトです。</p>
<p>Ingressは負荷分散、SSL終端、名前ベースの仮想ホスティングの機能を提供します。</p></p>
<h2 id=用語>用語</h2>
<p>簡単のために、このガイドでは次の用語を定義します。</p>
<ul>
<li>ノード: Kubernetes内のワーカーマシンで、クラスターの一部です。</li>
<li>クラスター: Kubernetesによって管理されているコンテナ化されたアプリケーションを実行させるノードの集合です。この例や、多くのKubernetesによるデプロイでは、クラスター内のノードはインターネットに公開されていません。</li>
<li>エッジルーター: クラスターでファイアウォールのポリシーを強制するルーターです。クラウドプロバイダーが管理するゲートウェイや、物理的なハードウェアの一部である場合もあります。</li>
<li>クラスターネットワーク: 物理的または論理的な繋がりの集合で、Kubernetesの<a href=/ja/docs/concepts/cluster-administration/networking/>ネットワークモデル</a>によって、クラスター内でのコミュニケーションを司るものです。</li>
<li>Service: <a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=ラベル>ラベル</a>セレクターを使ったPodの集合を特定するKubernetes <a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>です。特に指定がない限り、Serviceはクラスターネットワーク内でのみ疎通可能な仮想IPを持つものとして扱われます。</li>
</ul>
<h2 id=ingressとは何か>Ingressとは何か</h2>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#ingress-v1-networking-k8s-io>Ingress</a>はクラスター外からクラスター内<a href=/ja/docs/concepts/services-networking/service/ target=_blank>Service</a>へのHTTPとHTTPSのルートを公開します。トラフィックのルーティングはIngressリソース上で定義されるルールによって制御されます。</p>
<p>全てのトラフィックを単一のServiceに送る単純なIngressの例を示します。</p>
<div class=mermaid>
graph LR;
client([クライアント])-. Ingress管理下の <br> ロードバランサー .->ingress[Ingress];
ingress-->|ルーティングルール|service[Service];
subgraph cluster[クラスター]
ingress;
service-->pod1[Pod];
service-->pod2[Pod];
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class ingress,service,pod1,pod2 k8s;
class client plain;
class cluster cluster;
</div>
<noscript>
<style type=text/css>.mermaid{display:none}</style>
<h4>[JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view content]</h4>
</noscript>
<p>IngressはServiceに対して、外部疎通できるURL、負荷分散トラフィック、SSL/TLS終端の機能や、名前ベースの仮想ホスティングを提供するように設定できます。<a href=/ja/docs/concepts/services-networking/ingress-controllers/>Ingressコントローラー</a>は通常はロードバランサーを使用してIngressの機能を実現しますが、エッジルーターや、追加のフロントエンドを構成してトラフィックの処理を支援することもできます。</p>
<p>Ingressは任意のポートやプロトコルを公開しません。HTTPやHTTPS以外のServiceをインターネットに公開する場合、<a href=/ja/docs/concepts/services-networking/service/#nodeport>Service.Type=NodePort</a>や<a href=/ja/docs/concepts/services-networking/service/#loadbalancer>Service.Type=LoadBalancer</a>のServiceタイプを一般的には使用します。</p>
<h2 id=ingressを使用する上での前提条件>Ingressを使用する上での前提条件</h2>
<p>Ingressを提供するためには<a href=/ja/docs/concepts/services-networking/ingress-controllers>Ingressコントローラー</a>が必要です。Ingressリソースを作成するのみでは何の効果もありません。</p>
<p><a href=https://kubernetes.github.io/ingress-nginx/deploy/>ingress-nginx</a>のようなIngressコントローラーのデプロイが必要な場合があります。いくつかの<a href=/ja/docs/concepts/services-networking/ingress-controllers>Ingressコントローラー</a>の中から選択してください。</p>
<p>理想的には、全てのIngressコントローラーはリファレンスの仕様を満たすはずです。しかし実際には、各Ingressコントローラーは微妙に異なる動作をします。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Ingressコントローラーのドキュメントを確認して、選択する際の注意点について理解してください。
</div>
<h2 id=ingressリソース>Ingressリソース</h2>
<p>Ingressリソースの最小構成の例は以下のとおりです。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/minimal-ingress.yaml download=service/networking/minimal-ingress.yaml><code>service/networking/minimal-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-minimal-ingress-yaml')" title="Copy service/networking/minimal-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-minimal-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>minimal-ingress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/testpath<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>他の全てのKubernetesリソースと同様に、Ingressには<code>apiVersion</code>、<code>kind</code>や<code>metadata</code>フィールドが必要です。Ingressオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。設定ファイルに関する一般的な情報は、<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>アプリケーションのデプロイ</a>、<a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>コンテナの設定</a>、<a href=/ja/docs/concepts/cluster-administration/manage-deployment/>リソースの管理</a>を参照してください。Ingressでは、Ingressコントローラーに依存しているいくつかのオプションの設定をするためにアノテーションを一般的に使用します。例としては、<a href=https://github.com/kubernetes/ingress-nginx/blob/master/docs/examples/rewrite/README.md>rewrite-targetアノテーション</a>などがあります。<a href=/ja/docs/concepts/services-networking/ingress-controllers>Ingressコントローラー</a>の種類が異なれば、サポートするアノテーションも異なります。サポートされているアノテーションについて学ぶためには、使用するIngressコントローラーのドキュメントを確認してください。</p>
<p>Ingress <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>Spec</a>は、ロードバランサーやプロキシーサーバーを設定するために必要な全ての情報を持っています。最も重要なものとして、外部からくる全てのリクエストに対して一致したルールのリストを含みます。IngressリソースはHTTP(S)トラフィックに対してのルールのみサポートしています。</p>
<h3 id=ingressのルール>Ingressのルール</h3>
<p>各HTTPルールは以下の情報を含みます。</p>
<ul>
<li>オプションで設定可能なホスト名。上記のリソースの例では、ホスト名が指定されていないと、そのルールは指定されたIPアドレスを経由する全てのインバウンドHTTPトラフィックに適用されます。ホスト名が指定されていると(例: foo.bar.com)、そのルールはホストに対して適用されます。</li>
<li>パスのリスト(例: <code>/testpath</code>)。各パスには<code>service.name</code>と<code>service.port.name</code>または<code>service.port.number</code>で定義されるバックエンドが関連づけられます。ロードバランサーがトラフィックを関連づけられたServiceに転送するために、外部からくるリクエストのホスト名とパスが条件と一致させる必要があります。</li>
<li>バックエンドは<a href=/ja/docs/concepts/services-networking/service/>Serviceドキュメント</a>に書かれているようなService名とポート名の組み合わせ、または<a class=glossary-tooltip title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle=tooltip data-placement=top href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CRD>CRD</a>による<a href=#resource-backend>カスタムリソースバックエンド</a>です。Ingressで設定されたホスト名とパスのルールに一致するHTTP(とHTTPS)のリクエストは、リスト内のバックエンドに対して送信されます。</li>
</ul>
<p>Ingressコントローラーでは、<code>defaultBackend</code>が設定されていることがあります。これはSpec内で指定されているパスに一致しないようなリクエストのためのバックエンドです。</p>
<h3 id=default-backend>デフォルトのバックエンド</h3>
<p>ルールが設定されていないIngressは、全てのトラフィックをデフォルトのバックエンドに転送します。<code>defaultBackend</code>は、<a href=/ja/docs/concepts/services-networking/ingress-controllers>Ingressコントローラー</a>のオプション設定であり、Ingressリソースでは指定されていません。</p>
<p>HTTPリクエストがIngressオブジェクトのホスト名とパスの条件に1つも一致しない時、そのトラフィックはデフォルトのバックエンドに転送されます。</p>
<h3 id=resource-backend>リソースバックエンド</h3>
<p><code>Resource</code>バックエンドはIngressオブジェクトと同じnamespaceにある他のKubernetesリソースを指すObjectRefです。
<code>Resource</code>はServiceの設定とは排他であるため、両方を指定するとバリデーションに失敗します。
<code>Resource</code>バックエンドのよくある用途は、静的なアセットが入ったオブジェクトストレージを設定することです。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/ingress-resource-backend.yaml download=service/networking/ingress-resource-backend.yaml><code>service/networking/ingress-resource-backend.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-ingress-resource-backend-yaml')" title="Copy service/networking/ingress-resource-backend.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-ingress-resource-backend-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ingress-resource-backend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultBackend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageBucket<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>static-assets<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/icons<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>ImplementationSpecific<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageBucket<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>icon-assets<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>上記のIngressを作成した後に、次のコマンドで参照することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl describe ingress ingress-resource-backend
</code></pre></div><pre><code>Name:             ingress-resource-backend
Namespace:        default
Address:
Default backend:  APIGroup: k8s.example.com, Kind: StorageBucket, Name: static-assets
Rules:
  Host        Path  Backends
  ----        ----  --------
  *
              /icons   APIGroup: k8s.example.com, Kind: StorageBucket, Name: icon-assets
Annotations:  &lt;none&gt;
Events:       &lt;none&gt;
</code></pre><h3 id=パスのタイプ>パスのタイプ</h3>
<p>Ingressのそれぞれのパスは対応するパスのタイプを持ちます。<code>pathType</code>が明示的に指定されていないパスはバリデーションに通らないでしょう。サポートされているパスのタイプは3種類あります。</p>
<ul>
<li>
<p><code>ImplementationSpecific</code>（実装に特有）: このパスタイプでは、パスとの一致はIngressClassに依存します。Ingressの実装はこれを独立した<code>pathType</code>と扱うことも、<code>Prefix</code>や<code>Exact</code>と同一のパスタイプと扱うこともできます。</p>
</li>
<li>
<p><code>Exact</code>: 大文字小文字を区別して完全に一致するURLパスと一致します。</p>
</li>
<li>
<p><code>Prefix</code>: <code>/</code>で分割されたURLと前方一致で一致します。大文字小文字は区別され、パスの要素対要素で比較されます。パス要素は<code>/</code>で分割されたパスの中のラベルのリストを参照します。リクエストがパス <em>p</em> に一致するのは、Ingressのパス <em>p</em> がリクエストパス <em>p</em> と要素単位で前方一致する場合です。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> パスの最後の要素がリクエストパスの最後の要素の部分文字列である場合、これは一致しません（例えば、<code>/foo/bar</code>は<code>/foo/bar/baz</code>と一致しますが、<code>/foo/barbaz</code>とは一致しません）。
</div>
</li>
</ul>
<h3 id=例>例</h3>
<table>
<thead>
<tr>
<th>タイプ</th>
<th>パス</th>
<th>リクエストパス</th>
<th>一致するか</th>
</tr>
</thead>
<tbody>
<tr>
<td>Prefix</td>
<td><code>/</code></td>
<td>（全てのパス）</td>
<td>はい</td>
</tr>
<tr>
<td>Exact</td>
<td><code>/foo</code></td>
<td><code>/foo</code></td>
<td>はい</td>
</tr>
<tr>
<td>Exact</td>
<td><code>/foo</code></td>
<td><code>/bar</code></td>
<td>いいえ</td>
</tr>
<tr>
<td>Exact</td>
<td><code>/foo</code></td>
<td><code>/foo/</code></td>
<td>いいえ</td>
</tr>
<tr>
<td>Exact</td>
<td><code>/foo/</code></td>
<td><code>/foo</code></td>
<td>いいえ</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/foo</code></td>
<td><code>/foo</code>, <code>/foo/</code></td>
<td>はい</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/foo/</code></td>
<td><code>/foo</code>, <code>/foo/</code></td>
<td>はい</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bb</code></td>
<td><code>/aaa/bbb</code></td>
<td>いいえ</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb</code></td>
<td><code>/aaa/bbb</code></td>
<td>はい</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb/</code></td>
<td><code>/aaa/bbb</code></td>
<td>はい、末尾のスラッシュは無視</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb</code></td>
<td><code>/aaa/bbb/</code></td>
<td>はい、末尾のスラッシュと一致</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb</code></td>
<td><code>/aaa/bbb/ccc</code></td>
<td>はい、パスの一部と一致</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa/bbb</code></td>
<td><code>/aaa/bbbxyz</code></td>
<td>いいえ、接頭辞と一致しない</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/</code>, <code>/aaa</code></td>
<td><code>/aaa/ccc</code></td>
<td>はい、接頭辞<code>/aaa</code>と一致</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/</code>, <code>/aaa</code>, <code>/aaa/bbb</code></td>
<td><code>/aaa/bbb</code></td>
<td>はい、接頭辞<code>/aaa/bbb</code>と一致</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/</code>, <code>/aaa</code>, <code>/aaa/bbb</code></td>
<td><code>/ccc</code></td>
<td>はい、接頭辞<code>/</code>と一致</td>
</tr>
<tr>
<td>Prefix</td>
<td><code>/aaa</code></td>
<td><code>/ccc</code></td>
<td>いいえ、デフォルトバックエンドを使用</td>
</tr>
<tr>
<td>Mixed</td>
<td><code>/foo</code> (Prefix), <code>/foo</code> (Exact)</td>
<td><code>/foo</code></td>
<td>はい、Exactが優先</td>
</tr>
</tbody>
</table>
<h4 id=複数のパスとの一致>複数のパスとの一致</h4>
<p>リクエストがIngressの複数のパスと一致することがあります。そのような場合は、最も長くパスが一致したものが優先されます。2つのパスが同等に一致した場合は、完全一致が前方一致よりも優先されます。</p>
<h2 id=ホスト名のワイルドカード>ホスト名のワイルドカード</h2>
<p>ホストは正確に一致する（例えば<code>foo.bar.com</code>）かワイルドカード（例えば<code>*.foo.com</code>）とすることができます。
正確な一致ではHTTPヘッダーの<code>host</code>が<code>host</code>フィールドと一致することが必要です。
ワイルドカードによる一致では、HTTPヘッダーの<code>host</code>がワイルドカードルールに沿って後方一致することが必要です。</p>
<table>
<thead>
<tr>
<th>Host</th>
<th>Hostヘッダー</th>
<th>一致するか</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*.foo.com</code></td>
<td><code>bar.foo.com</code></td>
<td>共通の接尾辞により一致</td>
</tr>
<tr>
<td><code>*.foo.com</code></td>
<td><code>baz.bar.foo.com</code></td>
<td>一致しない。ワイルドカードは単一のDNSラベルのみを対象とする</td>
</tr>
<tr>
<td><code>*.foo.com</code></td>
<td><code>foo.com</code></td>
<td>一致しない。ワイルドカードは単一のDNSラベルのみを対象とする</td>
</tr>
</tbody>
</table>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/ingress-wildcard-host.yaml download=service/networking/ingress-wildcard-host.yaml><code>service/networking/ingress-wildcard-host.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-ingress-wildcard-host-yaml')" title="Copy service/networking/ingress-wildcard-host.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-ingress-wildcard-host-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ingress-wildcard-host<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;foo.bar.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/bar&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*.foo.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h2 id=ingress-class>Ingress Class</h2>
<p>Ingressは異なったコントローラーで実装されうるため、しばしば異なった設定を必要とします。
IngressClassリソースは、この種別のIngressを実装すべきコントローラーの名称を含む追加の設定情報を含みます。各IngressはIngressClassリソースへの参照によって種別を指定すべきです。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/external-lb.yaml download=service/networking/external-lb.yaml><code>service/networking/external-lb.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-external-lb-yaml')" title="Copy service/networking/external-lb.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-external-lb-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-lb<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb> </span>example.com/ingress-controller<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>k8s.example.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>IngressParameters<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>external-lb<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>IngressClassリソースは任意のパラメータフィールドを含むことができます。これは追加の設定情報を参照するために利用することができます。</p>
<h3 id=非推奨のアノテーション>非推奨のアノテーション</h3>
<p>Kubernetes 1.18でIngressClassリソースと<code>ingressClassName</code>フィールドが追加される前は、Ingressの種別はIngressの<code>kubernetes.io/ingress.class</code>アノテーションにより指定されていました。
このアノテーションは正式に定義されたことはありませんが、Ingressコントローラーに広くサポートされています。</p>
<p>Ingressの新しい<code>ingressClassName</code>フィールドはこのアノテーションを置き換えるものですが、完全に等価ではありません。
アノテーションは一般にIngressを実装すべきIngressのコントローラーの名称を示していましたが、フィールドはIngressClassリソースを示しており、これはIngressのコントローラーの名称を含む追加のIngressの設定情報を持ちます。</p>
<h3 id=default-ingress-class>デフォルトのIngressClass</h3>
<p>特定のIngressClassをクラスターでのデフォルトとすることができます。
IngressClassリソースの<code>ingressclass.kubernetes.io/is-default-class</code>アノテーションを<code>true</code>に設定すると、<code>ingressClassName</code>フィールドが指定されないIngressにはこのデフォルトIngressClassが割り当てられるようになります。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> 複数のIngressClassをクラスターのデフォルトに設定すると、アドミッションコントローラーは<code>ingressClassName</code>が指定されていないIngressオブジェクトの作成を防ぐようになります。クラスターのデフォルトのIngressClassを1つ以下にすることで、これを解消することができます。
</div>
<h2 id=ingressのタイプ>Ingressのタイプ</h2>
<h3 id=single-service-ingress>単一ServiceのIngress</h3>
<p>Kubernetesには、単一のServiceを公開できるようにする既存の概念があります（<a href=#alternatives>Ingressの代替案</a>を参照してください）。ルールなしで<em>デフォルトのバックエンド</em> を指定することにより、Ingressでこれを実現することもできます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/test-ingress.yaml download=service/networking/test-ingress.yaml><code>service/networking/test-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-test-ingress-yaml')" title="Copy service/networking/test-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-test-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultBackend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p><code>kubectl apply -f</code>を実行してIngressを作成すると、その作成したIngressの状態を確認することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get ingress test-ingress
</code></pre></div><pre><code>NAME           CLASS         HOSTS   ADDRESS         PORTS   AGE
test-ingress   external-lb   *       203.0.113.123   80      59s
</code></pre><p><code>203.0.113.123</code>はIngressコントローラーによって割り当てられたIPで、作成したIngressを利用するためのものです。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> IngressコントローラーとロードバランサーがIPアドレス割り当てるのに1、2分ほどかかります。この間、ADDRESSの情報は<code>&lt;pending></code>となっているのを確認できます。
</div>
<h3 id=リクエストのシンプルなルーティング>リクエストのシンプルなルーティング</h3>
<p>ファンアウト設定では単一のIPアドレスのトラフィックを、リクエストされたHTTP URIに基づいて1つ以上のServiceに転送します。Ingressによってロードバランサーの数を少なくすることができます。例えば、以下のように設定します。</p>
<div class=mermaid>
graph LR;
client([クライアント])-. Ingress管理下の <br> ロードバランサー .->ingress[Ingress, 178.91.123.132];
ingress-->|/foo|service1[Service service1:4200];
ingress-->|/bar|service2[Service service2:8080];
subgraph cluster[クラスター]
ingress;
service1-->pod1[Pod];
service1-->pod2[Pod];
service2-->pod3[Pod];
service2-->pod4[Pod];
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class ingress,service1,service2,pod1,pod2,pod3,pod4 k8s;
class client plain;
class cluster cluster;
</div>
<noscript>
<style type=text/css>.mermaid{display:none}</style>
<h4>[JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view content]</h4>
</noscript>
<p>Ingressを以下のように設定します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/simple-fanout-example.yaml download=service/networking/simple-fanout-example.yaml><code>service/networking/simple-fanout-example.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-simple-fanout-example-yaml')" title="Copy service/networking/simple-fanout-example.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-simple-fanout-example-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>simple-fanout-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>4200</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/bar<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Ingressを<code>kubectl apply -f</code>によって作成したとき:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe ingress simple-fanout-example
</code></pre></div><pre><code>Name:             simple-fanout-example
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:4200 (10.8.0.90:4200)
               /bar   service2:8080 (10.8.0.91:8080)
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     22s                loadbalancer-controller  default/test
</code></pre><p>IngressコントローラーはService(<code>service1</code>、<code>service2</code>)が存在する限り、Ingressの条件を満たす実装固有のロードバランサーを構築します。
構築が完了すると、ADDRESSフィールドでロードバランサーのアドレスを確認できます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 使用する<a href=/ja/docs/concepts/services-networking/ingress-controllers/>Ingressコントローラー</a>に依存しますが、default-http-backend<a href=/ja/docs/concepts/services-networking/service/>Service</a>の作成が必要な場合があります。
</div>
<h3 id=名前ベースのバーチャルホスティング>名前ベースのバーチャルホスティング</h3>
<p>名前ベースのバーチャルホストは、HTTPトラフィックを同一のIPアドレスの複数のホスト名に転送することをサポートしています。</p>
<div class=mermaid>
graph LR;
client([クライアント])-. Ingress管理下の <br> ロードバランサー .->ingress[Ingress, 178.91.123.132];
ingress-->|Host: foo.bar.com|service1[Service service1:80];
ingress-->|Host: bar.foo.com|service2[Service service2:80];
subgraph cluster[クラスター]
ingress;
service1-->pod1[Pod];
service1-->pod2[Pod];
service2-->pod3[Pod];
service2-->pod4[Pod];
end
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;
class ingress,service1,service2,pod1,pod2,pod3,pod4 k8s;
class client plain;
class cluster cluster;
</div>
<noscript>
<style type=text/css>.mermaid{display:none}</style>
<h4>[JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view content]</h4>
</noscript>
<p>以下のIngress設定は、ロードバランサーに対して、<a href=https://tools.ietf.org/html/rfc7230#section-5.4>Hostヘッダー</a>に基づいてリクエストを転送するように指示するものです。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/name-virtual-host-ingress.yaml download=service/networking/name-virtual-host-ingress.yaml><code>service/networking/name-virtual-host-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-name-virtual-host-ingress-yaml')" title="Copy service/networking/name-virtual-host-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-name-virtual-host-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-virtual-host-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>bar.foo.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>rules項目でのホストの設定がないIngressを作成すると、IngressコントローラーのIPアドレスに対するwebトラフィックは、要求されている名前ベースのバーチャルホストなしにマッチさせることができます。</p>
<p>例えば、以下のIngressは<code>first.bar.com</code>に対するトラフィックを<code>service1</code>へ、<code>second.foo.com</code>に対するトラフィックを<code>service2</code>へ、リクエストにおいてホスト名が指定されていない(リクエストヘッダーがないことを意味します)トラフィックは<code>service3</code>へ転送します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/name-virtual-host-ingress-no-third-host.yaml download=service/networking/name-virtual-host-ingress-no-third-host.yaml><code>service/networking/name-virtual-host-ingress-no-third-host.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-name-virtual-host-ingress-no-third-host-yaml')" title="Copy service/networking/name-virtual-host-ingress-no-third-host.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-name-virtual-host-ingress-no-third-host-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-virtual-host-ingress-no-third-host<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>first.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>second.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service3<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h3 id=tls>TLS</h3>
<p>TLSの秘密鍵と証明書を含んだ<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>を指定することにより、Ingressをセキュアにできます。Ingressは単一のTLSポートである443番ポートのみサポートし、IngressでTLS終端を行うことを想定しています。IngressからServiceやPodへのトラフィックは平文です。IngressのTLS設定のセクションで異なるホストを指定すると、それらのホストはSNI TLSエクステンション(IngressコントローラーがSNIをサポートしている場合)を介して指定されたホスト名に対し、同じポート上で多重化されます。TLSのSecretは<code>tls.crt</code>と<code>tls.key</code>というキーを含む必要があり、TLSを使用するための証明書と秘密鍵を含む値となります。以下がその例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>testsecret-tls<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>base64 encoded cert<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>base64 encoded key<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span></code></pre></div><p>IngressでこのSecretを参照すると、クライアントとロードバランサー間の通信にTLSを使用するようIngressコントローラーに指示することになります。作成したTLS Secretは、<code>https-example.foo.com</code>の完全修飾ドメイン名(FQDN)とも呼ばれる共通名(CN)を含む証明書から作成したものであることを確認する必要があります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> デフォルトルールではTLSが機能しない可能性があることに注意してください。
これは取り得る全てのサブドメインに対する証明書を発行する必要があるからです。
そのため、<code>tls</code>セクションの<code>hosts</code>は<code>rules</code>セクションの<code>host</code>と明示的に一致する必要があります。
</div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/tls-example-ingress.yaml download=service/networking/tls-example-ingress.yaml><code>service/networking/tls-example-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-tls-example-ingress-yaml')" title="Copy service/networking/tls-example-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-tls-example-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>tls-example-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>hosts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- https-example.foo.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>testsecret-tls<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>https-example.foo.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> サポートされるTLSの機能はIngressコントローラーによって違いがあります。利用する環境でTLSがどのように動作するかを理解するためには、<a href=https://kubernetes.github.io/ingress-nginx/user-guide/tls/>nginx</a>や、<a href=https://git.k8s.io/ingress-gce/README.md#frontend-https>GCE</a>、他のプラットフォーム固有のIngressコントローラーのドキュメントを確認してください。
</div>
<h3 id=load-balancing>負荷分散</h3>
<p>Ingressコントローラーは、負荷分散アルゴリズムやバックエンドの重みスキームなど、すべてのIngressに適用されるいくつかの負荷分散ポリシーの設定とともにブートストラップされます。発展した負荷分散のコンセプト(例: セッションの永続化、動的重み付けなど)はIngressによってサポートされていません。代わりに、それらの機能はService用のロードバランサーを介して利用できます。</p>
<p>Ingressによってヘルスチェックの機能が直接に公開されていない場合でも、Kubernetesにおいて、同等の機能を提供する<a href=/ja/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>Readiness Probe</a>のようなコンセプトが存在することは注目に値します。コントローラーがどのようにヘルスチェックを行うかについては、コントローラーのドキュメントを参照してください(例えば<a href=https://git.k8s.io/ingress-nginx/README.md>nginx</a>、または<a href=https://git.k8s.io/ingress-gce/README.md#health-checks>GCE</a>)。</p>
<h2 id=ingressの更新>Ingressの更新</h2>
<p>リソースを編集することで、既存のIngressに対して新しいホストを追加することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe ingress <span style=color:#a2f>test</span>
</code></pre></div><pre><code>Name:             test
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:80 (10.8.0.90:80)
Annotations:
  nginx.ingress.kubernetes.io/rewrite-target:  /
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     35s                loadbalancer-controller  default/test
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit ingress <span style=color:#a2f>test</span>
</code></pre></div><p>このコマンドを実行すると既存の設定をYAMLフォーマットで編集するエディターが表示されます。新しいホストを追加するために、リソースを修正してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>bar.baz.com<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb></span>..<span style=color:#bbb>
</span></code></pre></div><p>変更を保存した後、kubectlはAPIサーバー内のリソースを更新し、Ingressコントローラーに対してロードバランサーの再設定を指示します。</p>
<p>変更内容を確認してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe ingress <span style=color:#a2f>test</span>
</code></pre></div><pre><code>Name:             test
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:80 (10.8.0.90:80)
  bar.baz.com
               /foo   service2:80 (10.8.0.91:80)
Annotations:
  nginx.ingress.kubernetes.io/rewrite-target:  /
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     45s                loadbalancer-controller  default/test
</code></pre><p>修正されたIngressのYAMLファイルに対して<code>kubectl replace -f</code>を実行することで、同様の結果を得られます。</p>
<h2 id=アベイラビリティーゾーンをまたいだ障害について>アベイラビリティーゾーンをまたいだ障害について</h2>
<p>障害のあるドメインをまたいでトラフィックを分散する手法は、クラウドプロバイダーによって異なります。詳細に関して、<a href=/ja/docs/concepts/services-networking/ingress-controllers>Ingress コントローラー</a>のドキュメントを参照してください。</p>
<h2 id=alternatives>Ingressの代替案</h2>
<p>Ingressリソースを直接含まない複数の方法でサービスを公開できます。</p>
<ul>
<li><a href=/ja/docs/concepts/services-networking/service/#loadbalancer>Service.Type=LoadBalancer</a></li>
<li><a href=/ja/docs/concepts/services-networking/service/#nodeport>Service.Type=NodePort</a></li>
</ul>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#ingress-v1beta1-networking-k8s-io>Ingress API</a>について学ぶ</li>
<li><a href=/ja/docs/concepts/services-networking/ingress-controllers/>Ingressコントローラー</a>について学ぶ</li>
<li><a href=/ja/docs/tasks/access-application-cluster/ingress-minikube/>MinikubeとNGINXコントローラーでIngressのセットアップを行う</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5a8edeb1f2dc8e38cd6d561bb08b0d78>3.5.7 - Ingressコントローラー</h1>
<p>Ingressリソースが動作するためには、クラスターでIngressコントローラーが実行されている必要があります。</p>
<p><code>kube-controller-manager</code>バイナリの一部として実行される他のタイプのコントローラーとは異なり、Ingressコントローラーはクラスターで自動的に起動されません。このページを使用して、クラスターに最適なIngressコントローラーの実装を選択してください。</p>
<p>プロジェクトとしてのKubernetesは現在、<a href=https://github.com/kubernetes-sigs/aws-load-balancer-controller#readme>AWS</a>、<a href=https://git.k8s.io/ingress-gce/README.md#readme>GCE</a>、および<a href=https://git.k8s.io/ingress-nginx/README.md#readme>nginx</a>のIngressコントローラーをサポート・保守しています。</p>
<h2 id=additional-controllers>追加のコントローラー</h2>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>備考:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<ul>
<li><a href=https://github.com/Azure/application-gateway-kubernetes-ingress>AKS Application Gateway Ingress Controller</a>は、<a href=https://docs.microsoft.com/azure/application-gateway/overview>Azure Application Gateway</a>を設定するIngressコントローラーです。</li>
<li><a href=https://www.getambassador.io/>Ambassador</a> API Gatewayは<a href=https://www.envoyproxy.io>Envoy</a>ベースのIngressコントローラーです。</li>
<li><a href=https://github.com/citrix/citrix-k8s-ingress-controller#readme>Citrix ingress controller</a>は、Citrix Application Delivery Controllerで動作します。</li>
<li><a href=https://projectcontour.io/>Contour</a>は、<a href=https://www.envoyproxy.io/>Envoy</a>ベースのIngressコントローラーです。</li>
<li>F5 BIG-IPの<a href=https://clouddocs.f5.com/containers/latest/userguide/kubernetes/>Container Ingress Services for Kubernetes</a>はF5 BIG-IPの仮想サーバー上でIngressの設定を可能にします。</li>
<li><a href=https://gloo.solo.io>Gloo</a>は<a href=https://www.envoyproxy.io>Envoy</a>をベースにしたオープンソースのIngressコントローラーで、API Gateway機能を提供しています。</li>
<li><a href=https://haproxy-ingress.github.io>HAProxy Ingress</a>は、<a href=http://www.haproxy.org/#desc>HAProxy</a>用のIngressコントローラーです。</li>
<li><a href=https://github.com/haproxytech/kubernetes-ingress>HAProxy Ingress Controller for Kubernetes</a>も、<a href=http://www.haproxy.org/#desc>HAProxy</a>用のIngressコントローラーです。</li>
<li><a href=https://istio.io/latest/docs/tasks/traffic-management/ingress/kubernetes-ingress/>Istio Ingress</a>は、<a href=https://istio.io/>Istio</a>ベースのIngressコントローラーです。</li>
<li><a href=https://github.com/Kong/kubernetes-ingress-controller#readme>Kong Ingress Controller for Kubernetes</a>は、<a href=https://konghq.com/kong/>Kong Gateway</a>向けのIngressコントローラーです。</li>
<li><a href=https://www.nginx.com/products/nginx/kubernetes-ingress-controller>NGINX Ingress Controller for Kubernetes</a>は、<a href=https://www.nginx.com/resources/glossary/nginx/>NGINX</a>ウェブサーバーで(プロキシとして)動作します。</li>
<li><a href=https://opensource.zalando.com/skipper/kubernetes/ingress-controller/>Skipper</a>は、カスタムプロキシーを構築するためのライブラリーとして設計された、Kubernetes Ingressなどのユースケースを含む、サービス構成用のHTTPルーターとリバースプロキシーです。</li>
<li><a href=https://doc.traefik.io/traefik/providers/kubernetes-ingress/>Traefik Kubernetes Ingress provider</a>は、<a href=https://github.com/containous/traefik>Traefik</a> proxy向けのIngressコントローラーです。</li>
<li><a href=https://appscode.com/products/voyager>Voyager</a>は、<a href=http://www.haproxy.org/#desc>HAProxy</a>向けのIngressコントローラーです。</li>
</ul>
<h2 id=using-multiple-ingress-controllers>複数のIngressコントローラーの使用</h2>
<p><a href=https://git.k8s.io/ingress-nginx/docs/user-guide/multiple-ingress.md#multiple-ingress-controllers>Ingressコントローラーは、好きな数だけ</a>クラスターにデプロイすることができます。Ingressを作成する際には、クラスター内に複数のIngressコントローラーが存在する場合にどのIngressコントローラーを使用するかを示すために適切な<a href=https://git.k8s.io/ingress-gce/docs/faq/README.md#how-do-i-run-multiple-ingress-controllers-in-the-same-cluster><code>ingress.class</code></a>のアノテーションを指定する必要があります。</p>
<p>クラスを定義しない場合、クラウドプロバイダーはデフォルトのIngressコントローラーを使用する場合があります。</p>
<p>理想的には、すべてのIngressコントローラーはこの仕様を満たすべきですが、いくつかのIngressコントローラーはわずかに異なる動作をします。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Ingressコントローラーのドキュメントを確認して、選択する際の注意点を理解してください。
</div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/services-networking/ingress/>Ingress</a>についてさらに学ぶ。</li>
<li><a href=/ja/docs/tasks/access-application-cluster/ingress-minikube>Minikube上でNGINX Ingressコントローラーを使用してIngressをセットアップする</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ded1daafdcd293023ee333728007ca61>3.5.8 - ネットワークポリシー</h1>
<p>IPアドレスまたはポートのレベル(OSI参照モデルのレイヤ3または4)でトラフィックフローを制御したい場合、クラスター内の特定のアプリケーションにKubernetesのネットワークポリシーを使用することを検討してください。ネットワークポリシーはアプリケーション中心の構造であり、<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>がネットワークを介して多様な「エンティティ」(「Endpoint」や「Service」のようなKubernetesに含まれる特定の意味を持つ共通の用語との重複を避けるため、ここではエンティティという単語を使用します。)と通信する方法を指定できます。</p>
<p>Podが通信できるエンティティは以下の3つの識別子の組み合わせによって識別されます。</p>
<ol>
<li>許可されている他のPod(例外: Podはそれ自体へのアクセスをブロックできません)</li>
<li>許可されている名前空間</li>
<li>IPブロック(例外: PodまたはノードのIPアドレスに関係なく、Podが実行されているノードとの間のトラフィックは常に許可されます。)</li>
</ol>
<p>Podベースもしくは名前空間ベースのネットワークポリシーを定義する場合、<a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=セレクター>セレクター</a>を使用してセレクターに一致するPodとの間で許可されるトラフィックを指定します。</p>
<p>一方でIPベースのネットワークポリシーが作成されると、IPブロック(CIDRの範囲)に基づいてポリシーが定義されます。</p>
<h2 id=前提条件>前提条件</h2>
<p>ネットワークポリシーは、<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a>により実装されます。ネットワークポリシーを使用するには、NetworkPolicyをサポートするネットワークソリューションを使用しなければなりません。ネットワークポリシーを実装したコントローラーを使用せずにNetworkPolicyリソースを作成した場合は、何も効果はありません。</p>
<h2 id=分離されたpodと分離されていないpod>分離されたPodと分離されていないPod</h2>
<p>デフォルトでは、Podは分離されていない状態(non-isolated)となるため、すべてのソースからのトラフィックを受信します。</p>
<p>Podを選択するNetworkPolicyが存在すると、Podは分離されるようになります。名前空間内に特定のPodを選択するNetworkPolicyが1つでも存在すると、そのPodはいずれかのNetworkPolicyで許可されていないすべての接続を拒否するようになります。(同じ名前空間内のPodでも、どのNetworkPolicyにも選択されなかった他のPodは、引き続きすべてのトラフィックを許可します。)</p>
<p>ネットワークポリシーは追加式であるため、競合することはありません。複数のポリシーがPodを選択する場合、そのPodに許可されるトラフィックは、それらのポリシーのingress/egressルールの和集合で制限されます。したがって、評価の順序はポリシーの結果には影響がありません。</p>
<h2 id=networkpolicy-resource>NetworkPolicyリソース</h2>
<p>リソースの完全な定義については、リファレンスの<a href=/docs/reference/generated/kubernetes-api/v1.22/#networkpolicy-v1-networking-k8s-io>NetworkPolicy</a>のセクションを参照してください。</p>
<p>以下は、NetworkPolicyの一例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-network-policy<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.0</span>/16<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>except</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#666>172.17.1.0</span>/24<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>project</span>:<span style=color:#bbb> </span>myproject<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>to</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.0.0</span>/24<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>5978</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 選択したネットワークソリューションがネットワークポリシーをサポートしていない場合には、これをクラスターのAPIサーバーにPOSTしても効果はありません。
</div>
<p><strong>必須フィールド</strong>: 他のKubernetesの設定と同様に、NetworkPolicyにも<code>apiVersion</code>、<code>kind</code>、<code>metadata</code>フィールドが必須です。設定ファイルの扱い方に関する一般的な情報については、<a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMapを使用してコンテナを構成する</a>と<a href=/ja/docs/concepts/overview/working-with-objects/object-management>オブジェクト管理</a>を参照してください。</p>
<p><strong>spec</strong>: NetworkPolicyの<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>spec</a>を見ると、指定した名前空間内で特定のネットワークポリシーを定義するのに必要なすべての情報が確認できます。</p>
<p><strong>podSelector</strong>: 各NetworkPolicyには、ポリシーを適用するPodのグループを選択する<code>podSelector</code>が含まれます。ポリシーの例では、ラベル"role=db"を持つPodを選択しています。<code>podSelector</code>を空にすると、名前空間内のすべてのPodが選択されます。</p>
<p><strong>policyTypes</strong>: 各NetworkPolicyには、<code>policyTypes</code>として、<code>Ingress</code>、<code>Egress</code>、またはその両方からなるリストが含まれます。<code>policyTypes</code>フィールドでは、指定したポリシーがどの種類のトラフィックに適用されるかを定めます。トラフィックの種類としては、選択したPodへの内向きのトラフィック(Ingress)、選択したPodからの外向きのトラフィック(Egress)、またはその両方を指定します。<code>policyTypes</code>を指定しなかった場合、デフォルトで常に
<code>Ingress</code>が指定され、NetworkPolicyにegressルールが1つでもあれば<code>Egress</code>も設定されます。</p>
<p><strong>ingress</strong>: 各NetworkPolicyには、許可する<code>ingress</code>ルールのリストを指定できます。各ルールは、<code>from</code>および<code>ports</code>セクションの両方に一致するトラフィックを許可します。ポリシーの例には1つのルールが含まれ、このルールは、3つのソースのいずれかから送信された1つのポート上のトラフィックに一致します。1つ目のソースは<code>ipBlock</code>で、2つ目のソースは<code>namespaceSelector</code>で、3つ目のソースは<code>podSelector</code>でそれぞれ定められます。</p>
<p><strong>egress</strong>: 各NetworkPolicyには、許可する<code>egress</code>ルールのリストを指定できます。各ルールは、<code>to</code>および<code>ports</code>セクションの両方に一致するトラフィックを許可します。ポリシーの例には1つのルールが含まれ、このルールは、1つのポート上で<code>10.0.0.0/24</code>の範囲内の任意の送信先へ送られるトラフィックに一致します。</p>
<p>したがって、上のNetworkPolicyの例では、次のようにネットワークポリシーを適用します。</p>
<ol>
<li>"default"名前空間内にある"role=db"のPodを、内向きと外向きのトラフィックに対して分離する(まだ分離されていない場合)</li>
<li>(Ingressルール) "default"名前空間内の"role=db"ラベルが付いたすべてのPodのTCPの6379番ポートへの接続のうち、次の送信元からのものを許可する
<ul>
<li>"default"名前空間内のラベル"role=frontend"が付いたすべてのPod</li>
<li>ラベル"project=myproject"が付いた名前空間内のすべてのPod</li>
<li>172.17.0.0–172.17.0.255および172.17.2.0–172.17.255.255(言い換えれば、172.17.1.0/24の範囲を除く172.17.0.0/16)の範囲内のすべてのIPアドレス</li>
</ul>
</li>
<li>(Egressルール) "role=db"というラベルが付いた"default"名前空間内のすべてのPodからの、TCPの5978番ポート上でのCIDR 10.0.0.0/24への接続を許可する</li>
</ol>
<p>追加の例については、<a href=/ja/docs/tasks/administer-cluster/declare-network-policy/>ネットワークポリシーを宣言する</a>の説明を参照してください。</p>
<h2 id=to-と-from-のセレクターの振る舞い><code>to</code>と<code>from</code>のセレクターの振る舞い</h2>
<p><code>ingress</code>の<code>from</code>セクションまたは<code>egress</code>の<code>to</code>セクションに指定できるセレクターは4種類あります。</p>
<p><strong>podSelector</strong>: NetworkPolicyと同じ名前空間内の特定のPodを選択して、ingressの送信元またはegressの送信先を許可します。</p>
<p><strong>namespaceSelector</strong>: 特定の名前空間を選択して、その名前空間内のすべてのPodについて、ingressの送信元またはegressの送信先を許可します。</p>
<p><strong>namespaceSelector</strong> <em>および</em> <strong>podSelector</strong>: 1つの<code>to</code>または<code>from</code>エントリーで<code>namespaceSelector</code>と<code>podSelector</code>の両方を指定して、特定の名前空間内の特定のPodを選択します。正しいYAMLの構文を使うように気をつけてください。このポリシーの例を以下に示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>alice<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>client<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>このポリシーには、1つの<code>from</code>要素があり、ラベル<code>user=alice</code>の付いた名前空間内にある、ラベル<code>role=client</code>の付いたPodからの接続を許可します。しかし、<em>以下の</em>ポリシーには注意が必要です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>alice<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>client<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>このポリシーには、<code>from</code>配列の中に2つの要素があります。そのため、ラベル<code>role=client</code>の付いた名前空間内にあるすべてのPodからの接続、<em>または</em>、任意の名前空間内にあるラベル<code>user=alice</code>の付いたすべてのPodからの接続を許可します。</p>
<p>正しいルールになっているか自信がないときは、<code>kubectl describe</code>を使用すると、Kubernetesがどのようにポリシーを解釈したのかを確認できます。</p>
<p><strong>ipBlock</strong>: 特定のIPのCIDRの範囲を選択して、ingressの送信元またはegressの送信先を許可します。PodのIPは一時的なもので予測できないため、ここにはクラスター外のIPを指定するべきです。</p>
<p>クラスターのingressとegressの仕組みはパケットの送信元IPや送信先IPの書き換えを必要とすることがよくあります。その場合、NetworkPolicyの処理がIPの書き換えの前後どちらで行われるのかは定義されていません。そのため、ネットワークプラグイン、クラウドプロバイダー、<code>Service</code>の実装などの組み合わせによっては、動作が異なる可能性があります。</p>
<p>内向きのトラフィックの場合は、実際のオリジナルの送信元IPに基づいてパケットをフィルタリングできる可能性もあれば、NetworkPolicyが対象とする「送信元IP」が<code>LoadBalancer</code>やPodのノードなどのIPになってしまっている可能性もあることになります。</p>
<p>外向きのトラフィックの場合は、クラスター外のIPに書き換えられたPodから<code>Service</code>のIPへの接続は、<code>ipBlock</code>ベースのポリシーの対象になる場合とならない場合があることになります。</p>
<h2 id=デフォルトのポリシー>デフォルトのポリシー</h2>
<p>デフォルトでは、名前空間にポリシーが存在しない場合、その名前空間内のPodの内向きと外向きのトラフィックはすべて許可されます。以下の例を利用すると、その名前空間内でのデフォルトの振る舞いを変更できます。</p>
<h3 id=デフォルトですべての内向きのトラフィックを拒否する>デフォルトですべての内向きのトラフィックを拒否する</h3>
<p>すべてのPodを選択して、そのPodへのすべての内向きのトラフィックを許可しないNetworkPolicyを作成すると、その名前空間に対する「デフォルト」の分離ポリシーを作成できます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/network-policy-default-deny-ingress.yaml download=service/networking/network-policy-default-deny-ingress.yaml><code>service/networking/network-policy-default-deny-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-default-deny-ingress-yaml')" title="Copy service/networking/network-policy-default-deny-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-default-deny-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>このポリシーを利用すれば、他のいかなるNetworkPolicyにも選択されなかったPodでも分離されることを保証できます。このポリシーは、デフォルトの外向きの分離の振る舞いを変更しません。</p>
<h3 id=デフォルトで内向きのすべてのトラフィックを許可する>デフォルトで内向きのすべてのトラフィックを許可する</h3>
<p>(たとえPodを「分離されたもの」として扱うポリシーが追加された場合でも)名前空間内のすべてのPodへのすべてのトラフィックを許可したい場合には、その名前空間内のすべてのトラフィックを明示的に許可するポリシーを作成できます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/network-policy-allow-all-ingress.yaml download=service/networking/network-policy-allow-all-ingress.yaml><code>service/networking/network-policy-allow-all-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-allow-all-ingress-yaml')" title="Copy service/networking/network-policy-allow-all-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-allow-all-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-all-ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- {}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h3 id=デフォルトで外向きのすべてのトラフィックを拒否する>デフォルトで外向きのすべてのトラフィックを拒否する</h3>
<p>すべてのPodを選択して、そのPodからのすべての外向きのトラフィックを許可しないNetworkPolicyを作成すると、その名前空間に対する「デフォルト」の外向きの分離ポリシーを作成できます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/network-policy-default-deny-egress.yaml download=service/networking/network-policy-default-deny-egress.yaml><code>service/networking/network-policy-default-deny-egress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-default-deny-egress-yaml')" title="Copy service/networking/network-policy-default-deny-egress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-default-deny-egress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-egress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>このポリシーを利用すれば、他のいかなるNetworkPolicyにも選択されなかったPodでも、外向きのトラフィックが許可されないことを保証できます。このポリシーは、デフォルトの内向きの分離の振る舞いを変更しません。</p>
<h3 id=デフォルトで外向きのすべてのトラフィックを許可する>デフォルトで外向きのすべてのトラフィックを許可する</h3>
<p>(たとえPodを「分離されたもの」として扱うポリシーが追加された場合でも)名前空間内のすべてのPodからのすべてのトラフィックを許可したい場合には、その名前空間内のすべての外向きのトラフィックを明示的に許可するポリシーを作成できます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/network-policy-allow-all-egress.yaml download=service/networking/network-policy-allow-all-egress.yaml><code>service/networking/network-policy-allow-all-egress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-allow-all-egress-yaml')" title="Copy service/networking/network-policy-allow-all-egress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-allow-all-egress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-all-egress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- {}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h3 id=デフォルトで内向きと外向きのすべてのトラフィックを拒否する>デフォルトで内向きと外向きのすべてのトラフィックを拒否する</h3>
<p>名前空間内に以下のNetworkPolicyを作成すると、その名前空間で内向きと外向きのすべてのトラフィックを拒否する「デフォルト」のポリシーを作成できます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/network-policy-default-deny-all.yaml download=service/networking/network-policy-default-deny-all.yaml><code>service/networking/network-policy-default-deny-all.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-network-policy-default-deny-all-yaml')" title="Copy service/networking/network-policy-default-deny-all.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-network-policy-default-deny-all-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-all<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>このポリシーを利用すれば、他のいかなるNetworkPolicyにも選択されなかったPodでも、内向きと外向きのトラフィックが許可されないことを保証できます。</p>
<h2 id=sctpのサポート>SCTPのサポート</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code>
</div>
<p>ベータ版の機能として、これはデフォルトで有効化されます。
クラスターレベルでSCTPを無効化するために、クラスター管理者はAPIサーバーで<code>--feature-gates=SCTPSupport=false,…</code>と指定して、<code>SCTPSupport</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を無効にする必要があります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> SCTPプロトコルのネットワークポリシーをサポートする<a class=glossary-tooltip title="Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification." data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni target=_blank aria-label=CNI>CNI</a>プラグインを使用している必要があります。
</div>
<h2 id=ネットワークポリシーでできないこと-少なくともまだ>ネットワークポリシーでできないこと(少なくともまだ)</h2>
<p>Kubernetes1.20現在、ネットワークポリシーAPIに以下の機能は存在しません。
しかし、オペレーティングシステムのコンポーネント(SELinux、OpenVSwitch、IPTablesなど)、レイヤ7の技術(Ingressコントローラー、サービスメッシュ実装)、もしくはアドミッションコントローラーを使用して回避策を実装できる場合があります。
Kubernetesのネットワークセキュリティを初めて使用する場合は、ネットワークポリシーAPIを使用して以下のユーザーストーリーを(まだ)実装できないことに注意してください。これらのユーザーストーリーの一部(全てではありません)は、ネットワークポリシーAPIの将来のリリースで活発に議論されています。</p>
<ul>
<li>クラスター内トラフィックを強制的に共通ゲートウェイを通過させる(これは、サービスメッシュもしくは他のプロキシで提供するのが最適な場合があります)。</li>
<li>TLS関連のもの(これにはサービスメッシュまたはIngressコントローラを使用します)。</li>
<li>ノードの固有のポリシー(これらにはCIDR表記を使用できますが、Kubernetesのアイデンティティでノードを指定することはできません)。</li>
<li>名前空間またはサービスを名前で指定する(ただし、Podまたは名前空間を<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=ラベル>ラベル</a>で指定することができます。これは多くの場合で実行可能な回避策です)。</li>
<li>サードパーティによって実行される「ポリシー要求」の作成または管理</li>
<li>全ての名前空間もしくはPodに適用されるデフォルトのポリシー(これを実現できるサードパーティのKubernetesディストリビューションとプロジェクトがいくつか存在します)。</li>
<li>高度なポリシークエリと到達可能性ツール</li>
<li>単一のポリシー宣言でポートの範囲を指定する機能</li>
<li>ネットワークセキュリティイベント(例えばブロックされた接続や受け入れられた接続)をログに記録する機能</li>
<li>ポリシーを明示的に拒否する機能(現在、ネットワークポリシーのモデルはデフォルトで拒否されており、許可ルールを追加する機能のみが存在します)。</li>
<li>ループバックまたは内向きのホストトラフィックを拒否する機能(Podは現在localhostのアクセスやそれらが配置されているノードからのアクセスをブロックすることはできません)。</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/tasks/administer-cluster/declare-network-policy/>ネットワークポリシーを宣言する</a>で追加の例の説明を読む。</li>
<li>NetworkPolicyリソースで実現できるよくあるシナリオのためのさまざまな<a href=https://github.com/ahmetb/kubernetes-network-policy-recipes>レシピ</a>を確認する。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-21f8d19c60c33914baab66224c3d46a7>3.5.9 - IPv4/IPv6デュアルスタック</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code>
</div>
<p>IPv4/IPv6デュアルスタックを利用すると、IPv4とIPv6のアドレスの両方を<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>および<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>に指定できるようになります。</p>
<p>KubernetesクラスターでIPv4/IPv6デュアルスタックのネットワークを有効にすれば、クラスターはIPv4とIPv6のアドレスの両方を同時に割り当てることをサポートするようになります。</p>
<h2 id=サポートされている機能>サポートされている機能</h2>
<p>KubernetesクラスターでIPv4/IPv6デュアルスタックを有効にすると、以下の機能が提供されます。</p>
<ul>
<li>デュアルスタックのPodネットワーク(PodごとにIPv4とIPv6のアドレスが1つずつ割り当てられます)</li>
<li>IPv4およびIPv6が有効化されたService(各Serviceは1つのアドレスファミリーでなければなりません)</li>
<li>IPv4およびIPv6インターフェイスを経由したPodのクラスター外向きの(たとえば、インターネットへの)ルーティング</li>
</ul>
<h2 id=前提条件>前提条件</h2>
<p>IPv4/IPv6デュアルスタックのKubernetesクラスターを利用するには、以下の前提条件を満たす必要があります。</p>
<ul>
<li>Kubernetesのバージョンが1.16以降である</li>
<li>プロバイダーがデュアルスタックのネットワークをサポートしている(クラウドプロバイダーなどが、ルーティング可能なIPv4/IPv6ネットワークインターフェイスが搭載されたKubernetesを提供可能である)</li>
<li>ネットワークプラグインがデュアルスタックに対応している(KubenetやCalicoなど)</li>
</ul>
<h2 id=ipv4-ipv6デュアルスタックを有効にする>IPv4/IPv6デュアルスタックを有効にする</h2>
<p>IPv4/IPv6デュアルスタックを有効にするには、クラスターの関連コンポーネントで<code>IPv6DualStack</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にして、デュアルスタックのクラスターネットワークの割り当てを以下のように設定します。</p>
<ul>
<li>kube-apiserver:
<ul>
<li><code>--feature-gates="IPv6DualStack=true"</code></li>
<li><code>--service-cluster-ip-range=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li>
</ul>
</li>
<li>kube-controller-manager:
<ul>
<li><code>--feature-gates="IPv6DualStack=true"</code></li>
<li><code>--cluster-cidr=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li>
<li><code>--service-cluster-ip-range=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li>
<li><code>--node-cidr-mask-size-ipv4|--node-cidr-mask-size-ipv6</code> デフォルトのサイズは、IPv4では/24、IPv6では/64です</li>
</ul>
</li>
<li>kubelet:
<ul>
<li><code>--feature-gates="IPv6DualStack=true"</code></li>
</ul>
</li>
<li>kube-proxy:
<ul>
<li><code>--cluster-cidr=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li>
<li><code>--feature-gates="IPv6DualStack=true"</code></li>
</ul>
</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>IPv4 CIDRの例: <code>10.244.0.0/16</code> (自分のクラスターのアドレス範囲を指定してください)</p>
<p>IPv6 CIDRの例: <code>fdXY:IJKL:MNOP:15::/64</code> (これはフォーマットを示すための例であり、有効なアドレスではありません。詳しくは<a href=https://tools.ietf.org/html/rfc4193>RFC 4193</a>を参照してください)</p>
</div>
<h2 id=service>Service</h2>
<p>クラスターでIPv4/IPv6デュアルスタックのネットワークを有効にした場合、IPv4またはIPv6のいずれかのアドレスを持つ<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>を作成できます。Serviceのcluster IPのアドレスファミリーは、Service上に<code>.spec.ipFamily</code>フィールドを設定することで選択できます。このフィールドを設定できるのは、新しいServiceの作成時のみです。<code>.spec.ipFamily</code>フィールドの指定はオプションであり、<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>と<a class=glossary-tooltip title=クラスター内のServiceに対する外部からのアクセス(主にHTTP)を管理するAPIオブジェクトです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/ingress/ target=_blank aria-label=Ingress>Ingress</a>でIPv4とIPv6を有効にする予定がある場合にのみ使用するべきです。このフィールドの設定は、<a href=#egress-traffic>外向きのトラフィック</a>に対する要件には含まれません。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> クラスターのデフォルトのアドレスファミリーは、kube-controller-managerに<code>--service-cluster-ip-range</code>フラグで設定した、最初のservice cluster IPの範囲のアドレスファミリーです。
</div>
<p><code>.spec.ipFamily</code>は、次のいずれかに設定できます。</p>
<ul>
<li><code>IPv4</code>: APIサーバーは<code>ipv4</code>の<code>service-cluster-ip-range</code>の範囲からIPアドレスを割り当てます</li>
<li><code>IPv6</code>: APIサーバーは<code>ipv6</code>の<code>service-cluster-ip-range</code>の範囲からIPアドレスを割り当てます</li>
</ul>
<p>次のServiceのspecには<code>ipFamily</code>フィールドが含まれていません。Kubernetesは、最初に設定した<code>service-cluster-ip-range</code>の範囲からこのServiceにIPアドレス(別名「cluster IP」)を割り当てます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/dual-stack-default-svc.yaml download=service/networking/dual-stack-default-svc.yaml><code>service/networking/dual-stack-default-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-default-svc-yaml')" title="Copy service/networking/dual-stack-default-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-default-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>次のServiceのspecには<code>ipFamily</code>フィールドが含まれています。Kubernetesは、最初に設定した<code>service-cluster-ip-range</code>の範囲からこのServiceにIPv6のアドレス(別名「cluster IP」)を割り当てます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/dual-stack-ipv6-svc.yaml download=service/networking/dual-stack-ipv6-svc.yaml><code>service/networking/dual-stack-ipv6-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-ipv6-svc-yaml')" title="Copy service/networking/dual-stack-ipv6-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-ipv6-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamily</span>:<span style=color:#bbb> </span>IPv6<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span></code></pre></div>
</div>
</div>
<p>比較として次のServiceのspecを見ると、このServiceには最初に設定した<code>service-cluster-ip-range</code>の範囲からIPv4のアドレス(別名「cluster IP」)が割り当てられます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/dual-stack-ipv4-svc.yaml download=service/networking/dual-stack-ipv4-svc.yaml><code>service/networking/dual-stack-ipv4-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-ipv4-svc-yaml')" title="Copy service/networking/dual-stack-ipv4-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-ipv4-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamily</span>:<span style=color:#bbb> </span>IPv4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span></code></pre></div>
</div>
</div>
<h3 id=type-loadbalancer>Type LoadBalancer</h3>
<p>IPv6が有効になった外部ロードバランサーをサポートしているクラウドプロバイダーでは、<code>type</code>フィールドに<code>LoadBalancer</code>を指定し、<code>ipFamily</code>フィールドに<code>IPv6</code>を指定することにより、クラウドロードバランサーをService向けにプロビジョニングできます。</p>
<h2 id=egress-traffic>外向きのトラフィック</h2>
<p>パブリックおよび非パブリックでのルーティングが可能なIPv6アドレスのブロックを利用するためには、クラスターがベースにしている<a class=glossary-tooltip title="Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification." data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#cni target=_blank aria-label=CNI>CNI</a>プロバイダーがIPv6の転送を実装している必要があります。もし非パブリックでのルーティングが可能なIPv6アドレスを使用するPodがあり、そのPodをクラスター外の送信先(例:パブリックインターネット)に到達させたい場合、外向きのトラフィックと応答の受信のためにIPマスカレードを設定する必要があります。<a href=https://github.com/kubernetes-sigs/ip-masq-agent>ip-masq-agent</a>はデュアルスタックに対応しているため、デュアルスタックのクラスター上でのIPマスカレードにはip-masq-agentが利用できます。</p>
<h2 id=既知の問題>既知の問題</h2>
<ul>
<li>Kubenetは、IPv4,IPv6の順番にIPを報告することを強制します(--cluster-cidr)</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/network/validate-dual-stack>IPv4/IPv6デュアルスタックのネットワークを検証する</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f018f568c6723865753f150c3c59bdda>3.6 - ストレージ</h1>
</div>
<div class=td-content>
<h1 id=pg-ffd12528a12882b282e1bd19e29f9e75>3.6.1 - 永続ボリューム</h1>
<p>このドキュメントではKubernetesの <em>PersistentVolume</em> について説明します。<a href=/docs/concepts/storage/volumes/>ボリューム</a>を一読することをおすすめします。</p>
<h2 id=概要>概要</h2>
<p>ストレージを管理することはインスタンスを管理することとは全くの別物です。PersistentVolumeサブシステムは、ストレージが何から提供されているか、どのように消費されているかをユーザーと管理者から抽象化するAPIを提供します。これを実現するためのPersistentVolumeとPersistentVolumeClaimという2つの新しいAPIリソースを紹介します。</p>
<p><em>PersistentVolume</em> (PV)は<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>を使って管理者もしくは動的にプロビジョニングされるクラスターのストレージの一部です。これはNodeと同じようにクラスターリソースの一部です。PVはVolumeのようなボリュームプラグインですが、PVを使う個別のPodとは独立したライフサイクルを持っています。このAPIオブジェクトはNFS、iSCSIやクラウドプロバイダー固有のストレージシステムの実装の詳細を捕捉します。</p>
<p><em>PersistentVolumeClaim</em> (PVC)はユーザーによって要求されるストレージです。これはPodと似ています。PodはNodeリソースを消費し、PVCはPVリソースを消費します。Podは特定レベルのCPUとメモリーリソースを要求することができます。クレームは特定のサイズやアクセスモード(例えば、ReadWriteOnce、ReadOnlyMany、ReadWriteManyにマウントできます。詳しくは<a href=#access-modes>アクセスモード</a>を参照してください)を要求することができます。</p>
<p>PersistentVolumeClaimはユーザーに抽象化されたストレージリソースの消費を許可する一方、ユーザーは色々な問題に対処するためにパフォーマンスといった様々なプロパティを持ったPersistentVolumeを必要とすることは一般的なことです。クラスター管理者はユーザーに様々なボリュームがどのように実装されているかを表に出すことなく、サイズやアクセスモードだけではない色々な点で異なった、様々なPersistentVolumeを提供できる必要があります。これらのニーズに応えるために <em>StorageClass</em> リソースがあります。</p>
<p><a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/>実例を含む詳細なチュートリアル</a>を参照して下さい。</p>
<h2 id=ボリュームと要求のライフサイクル>ボリュームと要求のライフサイクル</h2>
<p>PVはクラスター内のリソースです。PVCはこれらのリソースの要求でありまた、クレームのチェックとしても機能します。PVとPVCの相互作用はこのライフサイクルに従います。</p>
<h3 id=プロビジョニング>プロビジョニング</h3>
<p>PVは静的か動的どちらかでプロビジョニングされます。</p>
<h4 id=静的>静的</h4>
<p>クラスター管理者は多数のPVを作成します。それらはクラスターのユーザーが使うことのできる実際のストレージの詳細を保持します。それらはKubernetes APIに存在し、利用できます。</p>
<h4 id=動的>動的</h4>
<p>ユーザーのPersistentVolumeClaimが管理者の作成したいずれの静的PVにも一致しない場合、クラスターはPVC用にボリュームを動的にプロビジョニングしようとする場合があります。
このプロビジョニングはStorageClassに基づいています。PVCは<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>の要求が必要であり、管理者は動的プロビジョニングを行うためにストレージクラスの作成・設定が必要です。ストレージクラスを""にしたストレージ要求は、自身の動的プロビジョニングを事実上無効にします。</p>
<p>ストレージクラスに基づいたストレージの動的プロビジョニングを有効化するには、クラスター管理者が<code>DefaultStorageClass</code><a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass>アドミッションコントローラー</a>をAPIサーバーで有効化する必要があります。
これは例えば、<code>DefaultStorageClass</code>がAPIサーバーコンポーネントの<code>--enable-admission-plugins</code>フラグのコンマ区切りの順序付きリストの中に含まれているかで確認できます。
APIサーバーのコマンドラインフラグの詳細については<a href=/docs/admin/kube-apiserver/>kube-apiserver</a>のドキュメントを参照してください。</p>
<h3 id=バインディング>バインディング</h3>
<p>ユーザは、特定のサイズのストレージとアクセスモードを指定した上でPersistentVolumeClaimを作成します（動的プロビジョニングの場合は、すでに作られています）。マスター内のコントロールループは、新しく作られるPVCをウォッチして、それにマッチするPVが見つかったときに、それらを紐付けます。PVが新しいPVC用に動的プロビジョニングされた場合、コントロールループは常にPVをそのPVCに紐付けます。そうでない場合、ユーザーは常に少なくとも要求したサイズ以上のボリュームを取得しますが、ボリュームは要求されたサイズを超えている可能性があります。一度紐付けされると、どのように紐付けられたかに関係なくPersistentVolumeClaimの紐付けは排他的（決められた特定のPVとしか結びつかない状態）になります。PVCからPVへの紐付けは、PersistentVolumeとPersistentVolumeClaim間の双方向の紐付けであるClaimRefを使用した1対1のマッピングになっています。</p>
<p>一致するボリュームが存在しない場合、クレームはいつまでも紐付けされないままになります。一致するボリュームが利用可能になると、クレームがバインドされます。たとえば、50GiのPVがいくつもプロビジョニングされているクラスターだとしても、100Giを要求するPVCとは一致しません。100GiのPVがクラスターに追加されると、PVCを紐付けできます。</p>
<h3 id=使用>使用</h3>
<p>Podは要求をボリュームとして使用します。クラスターは、要求を検査して紐付けられたボリュームを見つけそのボリュームをPodにマウントします。複数のアクセスモードをサポートするボリュームの場合、ユーザーはPodのボリュームとしてクレームを使う時にどのモードを希望するかを指定します。</p>
<p>ユーザーがクレームを取得し、そのクレームがバインドされると、バインドされたPVは必要な限りそのユーザーに属します。ユーザーはPodをスケジュールし、Podのvolumesブロックに<code>persistentVolumeClaim</code>を含めることで、バインドされたクレームのPVにアクセスします。
<a href=#claims-as-volumes>書式の詳細はこちらを確認して下さい。</a></p>
<h3 id=使用中のストレージオブジェクトの保護>使用中のストレージオブジェクトの保護</h3>
<p>使用中のストレージオブジェクト保護機能の目的はデータ損失を防ぐために、Podによって実際に使用されている永続ボリュームクレーム(PVC)と、PVCにバインドされている永続ボリューム(PV)がシステムから削除されないようにすることです。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> PVCを使用しているPodオブジェクトが存在する場合、PVCはPodによって実際に使用されています。
</div>
<p>ユーザーがPodによって実際に使用されているPVCを削除しても、そのPVCはすぐには削除されません。PVCの削除は、PVCがPodで使用されなくなるまで延期されます。また、管理者がPVCに紐付けられているPVを削除しても、PVはすぐには削除されません。PVがPVCに紐付けられなくなるまで、PVの削除は延期されます。</p>
<p>PVCの削除が保護されているかは、PVCのステータスが<code>Terminating</code>になっていて、そして<code>Finalizers</code>のリストに<code>kubernetes.io/pvc-protection</code>が含まれているかで確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pvc hostpath
Name:          hostpath
Namespace:     default
StorageClass:  example-hostpath
Status:        Terminating
Volume:
Labels:        &lt;none&gt;
Annotations:   volume.beta.kubernetes.io/storage-class<span style=color:#666>=</span>example-hostpath
               volume.beta.kubernetes.io/storage-provisioner<span style=color:#666>=</span>example.com/hostpath
Finalizers:    <span style=color:#666>[</span>kubernetes.io/pvc-protection<span style=color:#666>]</span>
</code></pre></div><p>同様にPVの削除が保護されているかは、PVのステータスが<code>Terminating</code>になっていて、そして<code>Finalizers</code>のリストに<code>kubernetes.io/pv-protection</code>が含まれているかで確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pv task-pv-volume
Name:            task-pv-volume
Labels:          <span style=color:#b8860b>type</span><span style=color:#666>=</span><span style=color:#a2f>local</span>
Annotations:     &lt;none&gt;
Finalizers:      <span style=color:#666>[</span>kubernetes.io/pv-protection<span style=color:#666>]</span>
StorageClass:    standard
Status:          Terminating
Claim:
Reclaim Policy:  Delete
Access Modes:    RWO
Capacity:        1Gi
Message:
Source:
    Type:          HostPath <span style=color:#666>(</span>bare host directory volume<span style=color:#666>)</span>
    Path:          /tmp/data
    HostPathType:
Events:            &lt;none&gt;
</code></pre></div><h3 id=再クレーム>再クレーム</h3>
<p>ユーザーは、ボリュームの使用が完了したら、リソースの再クレームを許可するAPIからPVCオブジェクトを削除できます。PersistentVolumeの再クレームポリシーはそのクレームが解放された後のボリュームの処理をクラスターに指示します。現在、ボリュームは保持、リサイクル、または削除できます。</p>
<h4 id=保持>保持</h4>
<p><code>Retain</code>という再クレームポリシーはリソースを手動で再クレームすることができます。PersistentVolumeClaimが削除される時、PersistentVolumeは依然として存在はしますが、ボリュームは解放済みです。ただし、以前のクレームデータはボリューム上に残っているため、別のクレームにはまだ使用できません。管理者は次の手順でボリュームを手動で再クレームできます。</p>
<ol>
<li>PersistentVolumeを削除します。PVが削除された後も、外部インフラストラクチャー(AWS EBS、GCE PD、Azure Disk、Cinderボリュームなど)に関連付けられたストレージアセットは依然として残ります。</li>
<li>ストレージアセットに関連するのデータを手動で適切にクリーンアップします。</li>
<li>関連するストレージアセットを手動で削除するか、同じストレージアセットを再利用したい場合、新しいストレージアセット定義と共にPersistentVolumeを作成します。</li>
</ol>
<h4 id=削除>削除</h4>
<p><code>Delete</code>再クレームポリシーをサポートするボリュームプラグインの場合、削除するとPersistentVolumeオブジェクトがKubernetesから削除されるだけでなく、AWS EBS、GCE PD、Azure Disk、Cinderボリュームなどの外部インフラストラクチャーの関連ストレージアセットも削除されます。動的にプロビジョニングされたボリュームは、<a href=#reclaim-policy>StorageClassの再クレームポリシー</a>を継承します。これはデフォルトで削除です。管理者は、ユーザーの需要に応じてStorageClassを構成する必要があります。そうでない場合、PVは作成後に編集またはパッチを適用する必要があります。<a href=/docs/tasks/administer-cluster/change-pv-reclaim-policy/>PersistentVolumeの再クレームポリシーの変更</a>を参照してください。</p>
<h4 id=リサイクル>リサイクル</h4>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> <code>Recycle</code>再クレームポリシーは非推奨になりました。代わりに、動的プロビジョニングを使用することをおすすめします。
</div>
<p>基盤となるボリュームプラグインでサポートされている場合、<code>Recycle</code>再クレームポリシーはボリュームに対して基本的な削除(<code>rm -rf /thevolume/*</code>)を実行し、新しいクレームに対して再び利用できるようにします。</p>
<p>管理者は<a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>reference</a>で説明するように、Kubernetesコントローラーマネージャーのコマンドライン引数を使用して、カスタムリサイクラーPodテンプレートを構成できます。カスタムリサイクラーPodテンプレートには、次の例に示すように、<code>volumes</code>仕様が含まれている必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/any/path/it/will/be/replaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/busybox&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;test -e /scrub &amp;&amp; rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  &amp;&amp; test -z \&#34;$(ls -A /scrub)\&#34; || exit 1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/scrub<span style=color:#bbb>
</span></code></pre></div><p>ただし、カスタムリサイクラーPodテンプレートの<code>volumes</code>パート内で指定された特定のパスは、リサイクルされるボリュームの特定のパスに置き換えられます。</p>
<h3 id=永続ボリュームの予約>永続ボリュームの予約</h3>
<p>コントロールプレーンは、永続ボリュームクレームをクラスター内の一致する永続ボリュームに<a href=#%E3%83%90%E3%82%A4%E3%83%B3%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0>バインド</a>できます。
ただし、永続ボリュームクレームを特定の永続ボリュームにバインドする場合、それらを事前にバインドする必要があります。</p>
<p>永続ボリュームクレームで永続ボリュームを指定することにより、その特定の永続ボリュームと永続ボリュームクレームの間のバインディングを宣言します。
永続ボリュームが存在し、その<code>claimRef</code>フィールドで永続ボリュームクレームを予約していない場合に永続ボリュームと永続ボリュームクレームがバインドされます。</p>
<p>バインディングは、ノードアフィニティを含むいくつかのボリュームの一致基準に関係なく発生します。
コントロールプレーンは、依然として<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>、アクセスモード、および要求されたストレージサイズが有効であることをチェックします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 空の文字列を明示的に指定する必要があります。そうしないとデフォルトのストレージクラスが設定されてしまいます。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>この方法は、永続ボリュームへのバインド特権を保証するものではありません。
他の永続ボリュームクレームが指定した永続ボリュームを使用できる場合、最初にそのストレージボリュームを予約する必要があります。
永続ボリュームの<code>claimRef</code>フィールドに関連する永続ボリュームクレームを指定して、他の永続ボリュームクレームがその永続ボリュームにバインドできないようにしてください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>claimRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>これは、既存の永続ボリュームを再利用する場合など、<code>claimPolicy</code>が<code>Retain</code>に設定されている永続ボリュームを使用する場合に役立ちます。</p>
<h3 id=永続ボリュームクレームの拡大>永続ボリュームクレームの拡大</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p>PersistentVolumeClaim(PVC)の拡大はデフォルトで有効です。次のボリュームの種類で拡大できます。</p>
<ul>
<li>gcePersistentDisk</li>
<li>awsElasticBlockStore</li>
<li>Cinder</li>
<li>glusterfs</li>
<li>rbd</li>
<li>Azure File</li>
<li>Azure Disk</li>
<li>Portworx</li>
<li>FlexVolumes</li>
<li>CSI</li>
</ul>
<p>そのストレージクラスの<code>allowVolumeExpansion</code>フィールドがtrueとなっている場合のみ、PVCを拡大できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gluster-vol-default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://192.168.10.100:8080&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><p>PVCに対してさらに大きなボリュームを要求するには、PVCオブジェクトを編集してより大きなサイズを指定します。これによりPersistentVolumeを受け持つ基盤にボリュームの拡大がトリガーされます。クレームを満たすため新しくPersistentVolumeが作成されることはありません。代わりに既存のボリュームがリサイズされます。</p>
<h4 id=csiボリュームの拡張>CSIボリュームの拡張</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code>
</div>
<p>CSIボリュームの拡張のサポートはデフォルトで有効になっていますが、ボリューム拡張をサポートするにはボリューム拡張を利用できるCSIドライバーも必要です。詳細については、それぞれのCSIドライバーのドキュメントを参照してください。</p>
<h4 id=ファイルシステムを含むボリュームのリサイズ>ファイルシステムを含むボリュームのリサイズ</h4>
<p>ファイルシステムがXFS、Ext3、またはExt4の場合にのみ、ファイルシステムを含むボリュームのサイズを変更できます。</p>
<p>ボリュームにファイルシステムが含まれる場合、新しいPodが<code>PersistentVolumeClaim</code>でReadWriteモードを使用している場合にのみ、ファイルシステムのサイズが変更されます。ファイルシステムの拡張は、Podの起動時、もしくはPodの実行時で基盤となるファイルシステムがオンラインの拡張をサポートする場合に行われます。</p>
<p>FlexVolumesでは、ドライバの<code>RequiresFSResize</code>機能がtrueに設定されている場合、サイズを変更できます。
FlexVolumeは、Podの再起動時にサイズ変更できます。</p>
<h4 id=使用中の永続ボリュームクレームのリサイズ>使用中の永続ボリュームクレームのリサイズ</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 使用中のPVCの拡張は、Kubernetes 1.15以降のベータ版と、1.11以降のアルファ版として利用可能です。<code>ExpandInUsePersistentVolume</code>機能を有効化する必要があります。これはベータ機能のため多くのクラスターで自動的に行われます。詳細については、<a href=/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>のドキュメントを参照してください。
</div>
<p>この場合、既存のPVCを使用しているPodまたはDeploymentを削除して再作成する必要はありません。使用中のPVCは、ファイルシステムが拡張されるとすぐにPodで自動的に使用可能になります。この機能は、PodまたはDeploymentで使用されていないPVCには影響しません。拡張を完了する前に、PVCを使用するPodを作成する必要があります。</p>
<p>他のボリュームタイプと同様、FlexVolumeボリュームは、Podによって使用されている最中でも拡張できます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> FlexVolumeのリサイズは、基盤となるドライバーがリサイズをサポートしている場合のみ可能です。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> EBSの拡張は時間がかかる操作です。また変更は、ボリュームごとに6時間に1回までというクォータもあります。
</div>
<h4 id=ボリューム拡張時の障害からの復旧>ボリューム拡張時の障害からの復旧</h4>
<p>基盤ストレージの拡張に失敗した際には、クラスターの管理者はPersistent Volume Claim (PVC)の状態を手動で復旧し、リサイズ要求をキャンセルします。それをしない限り、リサイズ要求は管理者の介入なしにコントローラーによって継続的に再試行されます。</p>
<ol>
<li>PersistentVolumeClaim(PVC)にバインドされているPersistentVolume(PV)を<code>Retain</code>再クレームポリシーとしてマークします。</li>
<li>PVCを削除します。PVは<code>Retain</code>再クレームポリシーを持っているため、PVCを再び作成したときにいかなるデータも失うことはありません。</li>
<li><code>claimRef</code>エントリーをPVスペックから削除して、新しいPVCがそれにバインドできるようにします。これによりPVは<code>Available</code>になります。</li>
<li>PVより小さいサイズでPVCを再作成し、PVCの<code>volumeName</code>フィールドをPVの名前に設定します。これにより新しいPVCを既存のPVにバインドします。</li>
<li>PVを再クレームポリシーを復旧することを忘れずに行ってください。</li>
</ol>
<h2 id=永続ボリュームの種類>永続ボリュームの種類</h2>
<p>PersistentVolumeの種類はプラグインとして実装されます。Kubernetesは現在次のプラグインに対応しています。</p>
<ul>
<li><a href=/docs/concepts/storage/volumes/#awselasticblockstore><code>awsElasticBlockStore</code></a> - AWS Elastic Block Store (EBS)</li>
<li><a href=/docs/concepts/storage/volumes/#azuredisk><code>azureDisk</code></a> - Azure Disk</li>
<li><a href=/docs/concepts/storage/volumes/#azurefile><code>azureFile</code></a> - Azure File</li>
<li><a href=/docs/concepts/storage/volumes/#cephfs><code>cephfs</code></a> - CephFS volume</li>
<li><a href=/docs/concepts/storage/volumes/#cinder><code>cinder</code></a> - Cinder (OpenStack block storage)
(<strong>非推奨</strong>)</li>
<li><a href=/docs/concepts/storage/volumes/#csi><code>csi</code></a> - Container Storage Interface (CSI)</li>
<li><a href=/docs/concepts/storage/volumes/#fc><code>fc</code></a> - Fibre Channel (FC) storage</li>
<li><a href=/docs/concepts/storage/volumes/#flexVolume><code>flexVolume</code></a> - FlexVolume</li>
<li><a href=/docs/concepts/storage/volumes/#flocker><code>flocker</code></a> - Flocker storage</li>
<li><a href=/docs/concepts/storage/volumes/#gcepersistentdisk><code>gcePersistentDisk</code></a> - GCE Persistent Disk</li>
<li><a href=/docs/concepts/storage/volumes/#glusterfs><code>glusterfs</code></a> - Glusterfs volume</li>
<li><a href=/docs/concepts/storage/volumes/#hostpath><code>hostPath</code></a> - HostPath volume
(テスト用の単一ノードのみ。マルチノードクラスターでは動作しません。代わりに<code>local</code>ボリュームを利用することを検討してください。)</li>
<li><a href=/docs/concepts/storage/volumes/#iscsi><code>iscsi</code></a> - iSCSI (SCSI over IP) storage</li>
<li><a href=/docs/concepts/storage/volumes/#local><code>local</code></a> - ノードにマウントされたローカルストレージデバイス</li>
<li><a href=/docs/concepts/storage/volumes/#nfs><code>nfs</code></a> - Network File System (NFS) storage</li>
<li><code>photonPersistentDisk</code> - Photon controller persistent disk
(対応するクラウドプロバイダーが削除されたため、このボリュームタイプは機能しなくなりました。)</li>
<li><a href=/docs/concepts/storage/volumes/#portworxvolume><code>portworxVolume</code></a> - Portworx volume</li>
<li><a href=/docs/concepts/storage/volumes/#quobyte><code>quobyte</code></a> - Quobyte volume</li>
<li><a href=/docs/concepts/storage/volumes/#rbd><code>rbd</code></a> - Rados Block Device (RBD) volume</li>
<li><a href=/docs/concepts/storage/volumes/#scaleio><code>scaleIO</code></a> - ScaleIO volume
(<strong>非推奨</strong>)</li>
<li><a href=/docs/concepts/storage/volumes/#storageos><code>storageos</code></a> - StorageOS volume</li>
<li><a href=/docs/concepts/storage/volumes/#vspherevolume><code>vsphereVolume</code></a> - vSphere VMDK volume</li>
</ul>
<h2 id=永続ボリューム>永続ボリューム</h2>
<p>各PVには、仕様とボリュームのステータスが含まれているspecとstatusが含まれています。
PersistentVolumeオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv0003<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Recycle<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>mountOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- hard<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- nfsvers=4.1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nfs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/tmp<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.2</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> クラスター内でPersistentVolumeを使用するには、ボリュームタイプに関連するヘルパープログラムが必要な場合があります。
この例では、PersistentVolumeはNFSタイプで、NFSファイルシステムのマウントをサポートするためにヘルパープログラム<code>/sbin/mount.nfs</code>が必要になります。
</div>
<h3 id=容量>容量</h3>
<p>通常、PVには特定のストレージ容量があります。これはPVの<code>capacity</code>属性を使用して設定されます。容量によって期待される単位を理解するためには、Kubernetesの<a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>リソースモデル</a>を参照してください。</p>
<p>現在、設定または要求できるのはストレージサイズのみです。将来の属性には、IOPS、スループットなどが含まれます。</p>
<h3 id=ボリュームモード>ボリュームモード</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>KubernetesはPersistentVolumesの2つの<code>volumeModes</code>をサポートしています: <code>Filesystem</code>と<code>Block</code>です。<br>
<code>volumeMode</code>は任意のAPIパラメーターです。<br>
<code>Filesystem</code>は<code>volumeMode</code>パラメーターが省略されたときに使用されるデフォルトのモードです。</p>
<p><code>volumeMode: Filesystem</code>であるボリュームはPodに<em>マウント</em>されてディレクトリになります。 ボリュームがブロックデバイスでデバイスが空の時、Kubernetesは初めてそれにマウントされる前にデバイスのファイルシステムを作成します。</p>
<p><code>volumeMode</code>の値を<code>Block</code>に設定してボリュームをRAWブロックデバイスとして使用します。<br>
このようなボリュームは、ファイルシステムを持たないブロックデバイスとしてPodに提示されます。<br>
このモードは、Podとボリュームの間のファイルシステムレイヤなしにボリュームにアクセスする可能な限り最速の方法をPodに提供するのに便利です。一方で、Pod上で実行しているアプリケーションはRAWブロックデバイスの扱い方を知っていなければなりません。<br>
Pod内で<code>volumeMode: Block</code>とともにボリュームを使用する例としては、<a href=#raw-block-volume-support>Raw Block Volume Support</a>を参照してください。</p>
<h3 id=アクセスモード>アクセスモード</h3>
<p>PersistentVolumeは、リソースプロバイダーがサポートする方法でホストにマウントできます。次の表に示すように、プロバイダーにはさまざまな機能があり、各PVのアクセスモードは、その特定のボリュームでサポートされる特定のモードに設定されます。たとえば、NFSは複数の読み取り/書き込みクライアントをサポートできますが、特定のNFSのPVはサーバー上で読み取り専用としてエクスポートされる場合があります。各PVは、その特定のPVの機能を記述する独自のアクセスモードのセットを取得します。</p>
<p>アクセスモードは次の通りです。</p>
<ul>
<li>ReadWriteOnce –ボリュームは単一のNodeで読み取り/書き込みとしてマウントできます</li>
<li>ReadOnlyMany –ボリュームは多数のNodeで読み取り専用としてマウントできます</li>
<li>ReadWriteMany –ボリュームは多数のNodeで読み取り/書き込みとしてマウントできます</li>
</ul>
<p>CLIではアクセスモードは次のように略されます。</p>
<ul>
<li>RWO - ReadWriteOnce</li>
<li>ROX - ReadOnlyMany</li>
<li>RWX - ReadWriteMany</li>
</ul>
<blockquote>
<p><strong>Important!</strong> ボリュームは、多数のモードをサポートしていても、一度に1つのアクセスモードでしかマウントできません。たとえば、GCEPersistentDiskは、単一NodeではReadWriteOnceとして、または多数のNodeではReadOnlyManyとしてマウントできますが、同時にマウントすることはできません。</p>
</blockquote>
<table>
<thead>
<tr>
<th style=text-align:left>ボリュームプラグイン</th>
<th style=text-align:center>ReadWriteOnce</th>
<th style=text-align:center>ReadOnlyMany</th>
<th style=text-align:center>ReadWriteMany</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>AWSElasticBlockStore</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>AzureFile</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
</tr>
<tr>
<td style=text-align:left>AzureDisk</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>CephFS</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
</tr>
<tr>
<td style=text-align:left>Cinder</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>CSI</td>
<td style=text-align:center>ドライバーに依存</td>
<td style=text-align:center>ドライバーに依存</td>
<td style=text-align:center>ドライバーに依存</td>
</tr>
<tr>
<td style=text-align:left>FC</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>FlexVolume</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>ドライバーに依存</td>
</tr>
<tr>
<td style=text-align:left>Flocker</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>GCEPersistentDisk</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>Glusterfs</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
</tr>
<tr>
<td style=text-align:left>HostPath</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>iSCSI</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>Quobyte</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
</tr>
<tr>
<td style=text-align:left>NFS</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
</tr>
<tr>
<td style=text-align:left>RBD</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>VsphereVolume</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>- (Podが連結されている場合のみ)</td>
</tr>
<tr>
<td style=text-align:left>PortworxVolume</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>✓</td>
</tr>
<tr>
<td style=text-align:left>ScaleIO</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>StorageOS</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
</tbody>
</table>
<h3 id=class>Class</h3>
<p>PVはクラスを持つことができます。これは<code>storageClassName</code>属性を<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>の名前に設定することで指定されます。特定のクラスのPVは、そのクラスを要求するPVCにのみバインドできます。<code>storageClassName</code>にクラスがないPVは、特定のクラスを要求しないPVCにのみバインドできます。</p>
<p>以前<code>volume.beta.kubernetes.io/storage-class</code>アノテーションは、<code>storageClassName</code>属性の代わりに使用されていました。このアノテーションはまだ機能しています。ただし、将来のKubernetesリリースでは完全に非推奨です。</p>
<h3 id=reclaim-policy>再クレームポリシー</h3>
<p>現在の再クレームポリシーは次のとおりです。</p>
<ul>
<li>保持 -- 手動再クレーム</li>
<li>リサイクル -- 基本的な削除 (<code>rm -rf /thevolume/*</code>)</li>
<li>削除 -- AWS EBS、GCE PD、Azure Disk、もしくはOpenStack Cinderボリュームに関連するストレージアセットを削除</li>
</ul>
<p>現在、NFSとHostPathのみがリサイクルをサポートしています。AWS EBS、GCE PD、Azure Disk、およびCinder volumeは削除をサポートしています。</p>
<h3 id=マウントオプション>マウントオプション</h3>
<p>Kubernetes管理者は永続ボリュームがNodeにマウントされるときの追加マウントオプションを指定できます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> すべての永続ボリュームタイプがすべてのマウントオプションをサポートするわけではありません。
</div>
<p>次のボリュームタイプがマウントオプションをサポートしています。</p>
<ul>
<li>AWSElasticBlockStore</li>
<li>AzureDisk</li>
<li>AzureFile</li>
<li>CephFS</li>
<li>Cinder (OpenStackブロックストレージ)</li>
<li>GCEPersistentDisk</li>
<li>Glusterfs</li>
<li>NFS</li>
<li>Quobyte Volumes</li>
<li>RBD (Ceph Block Device)</li>
<li>StorageOS</li>
<li>VsphereVolume</li>
<li>iSCSI</li>
</ul>
<p>マウントオプションは検証されないため、不正だった場合マウントは失敗します。</p>
<p>以前<code>volume.beta.kubernetes.io/mount-options</code>アノテーションが<code>mountOptions</code>属性の代わりに使われていました。このアノテーションはまだ機能しています。ただし、将来のKubernetesリリースでは完全に非推奨です。</p>
<h3 id=ノードアフィニティ>ノードアフィニティ</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ほとんどのボリュームタイプはこのフィールドを設定する必要がありません。<a href=/docs/concepts/storage/volumes/#awselasticblockstore>AWS EBS</a>、<a href=/docs/concepts/storage/volumes/#gcepersistentdisk>GCE PD</a>、もしくは<a href=/docs/concepts/storage/volumes/#azuredisk>Azure Disk</a>ボリュームブロックタイプの場合自動的に設定されます。<a href=/docs/concepts/storage/volumes/#local>local</a>ボリュームは明示的に設定する必要があります。
</div>
<p>PVは<a href=/docs/reference/generated/kubernetes-api/v1.22/#volumenodeaffinity-v1-core>ノードアフィニティ</a>を指定して、このボリュームにアクセスできるNodeを制限する制約を定義できます。PVを使用するPodは、ノードアフィニティによって選択されたNodeにのみスケジュールされます。</p>
<h3 id=フェーズ>フェーズ</h3>
<p>ボリュームは次のフェーズのいずれかです。</p>
<ul>
<li>利用可能 -- まだクレームに紐付いていない自由なリソース</li>
<li>バウンド -- クレームに紐付いている</li>
<li>リリース済み -- クレームが削除されたが、クラスターにまだクレームされている</li>
<li>失敗 -- 自動再クレームに失敗</li>
</ul>
<p>CLIにはPVに紐付いているPVCの名前が表示されます。</p>
<h2 id=persistentvolumeclaims>永続ボリューム要求</h2>
<p>各PVCにはspecとステータスが含まれます。これは、仕様とクレームのステータスです。</p>
<p>PersistentVolumeClaimオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>8Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>release</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- {<span style=color:green;font-weight:700>key: environment, operator: In, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></code></pre></div><h3 id=アクセスモード-1>アクセスモード</h3>
<p>クレームは、特定のアクセスモードでストレージを要求するときにボリュームと同じ規則を使用します。</p>
<h3 id=ボリュームモード-1>ボリュームモード</h3>
<p>クレームは、ボリュームと同じ規則を使用して、ファイルシステムまたはブロックデバイスとしてのボリュームの消費を示します。</p>
<h3 id=リソース>リソース</h3>
<p>Podと同様に、クレームは特定の量のリソースを要求できます。この場合、要求はストレージ用です。同じ<a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>リソースモデル</a>がボリュームとクレームの両方に適用されます。</p>
<h3 id=セレクター>セレクター</h3>
<p>クレームでは、<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルセレクター</a>を指定して、ボリュームセットをさらにフィルター処理できます。ラベルがセレクターに一致するボリュームのみがクレームにバインドできます。セレクターは2つのフィールドで構成できます。</p>
<ul>
<li><code>matchLabels</code> - ボリュームはこの値のラベルが必要です</li>
<li><code>matchExpressions</code> - キー、値のリスト、およびキーと値を関連付ける演算子を指定することによって作成された要件のリスト。有効な演算子は、In、NotIn、ExistsおよびDoesNotExistです。</li>
</ul>
<p><code>matchLabels</code>と<code>matchExpressions</code>の両方からのすべての要件はANDで結合されます。一致するには、すべてが一致する必要があります。</p>
<h3 id=クラス>クラス</h3>
<p>クレームは、<code>storageClassName</code>属性を使用して<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>の名前を指定することにより、特定のクラスを要求できます。PVCにバインドできるのは、PVCと同じ<code>storageClassName</code>を持つ、要求されたクラスのPVのみです。</p>
<p>PVCは必ずしもクラスをリクエストする必要はありません。<code>storageClassName</code>が<code>""</code>に設定されているPVCは、クラスのないPVを要求していると常に解釈されるため、クラスのないPVにのみバインドできます（アノテーションがないか、<code>""</code>に等しい1つのセット）。<code>storageClassName</code>のないPVCはまったく同じではなく、<a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code>アドミッションプラグイン</a>がオンになっているかどうかによって、クラスターによって異なる方法で処理されます。</p>
<ul>
<li>アドミッションプラグインがオンになっている場合、管理者はデフォルトの<code>StorageClass</code>を指定できます。<code>storageClassName</code>を持たないすべてのPVCは、そのデフォルトのPVにのみバインドできます。デフォルトの<code>StorageClass</code>の指定は、<code>StorageClass</code>オブジェクトで<code>storageclass.kubernetes.io/is-default-class</code>アノテーションを<code>true</code>に設定することにより行われます。管理者がデフォルトを指定しない場合、クラスターは、アドミッションプラグインがオフになっているかのようにPVC作成をレスポンスします。複数のデフォルトが指定されている場合、アドミッションプラグインはすべてのPVCの作成を禁止します。</li>
<li>アドミッションプラグインがオフになっている場合、デフォルトの<code>StorageClass</code>の概念はありません。<code>storageClassName</code>を持たないすべてのPVCは、クラスを持たないPVにのみバインドできます。この場合、storageClassNameを持たないPVCは、<code>storageClassName</code>が<code>""</code>に設定されているPVCと同じように扱われます。</li>
</ul>
<p>インストール方法によっては、インストール時にアドオンマネージャーによってデフォルトのストレージクラスがKubernetesクラスターにデプロイされる場合があります。</p>
<p>PVCが<code>selector</code>を要求することに加えて<code>StorageClass</code>を指定する場合、要件はANDで一緒に結合されます。要求されたクラスのPVと要求されたラベルのみがPVCにバインドされます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 現在、<code>selector</code>が空ではないPVCは、PVを動的にプロビジョニングできません。
</div>
<p>以前は、<code>storageClassName</code>属性の代わりに<code>volume.beta.kubernetes.io/storage-class</code>アノテーションが使用されていました。このアノテーションはまだ機能しています。ただし、今後のKubernetesリリースではサポートされません。</p>
<h2 id=ボリュームとしてのクレーム>ボリュームとしてのクレーム</h2>
<p>Podは、クレームをボリュームとして使用してストレージにアクセスします。クレームは、そのクレームを使用するPodと同じ名前空間に存在する必要があります。クラスターは、Podの名前空間でクレームを見つけ、それを使用してクレームを支援しているPersistentVolumeを取得します。次に、ボリュームがホストとPodにマウントされます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfrontend<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/www/html&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></code></pre></div><h3 id=名前空間に関する注意>名前空間に関する注意</h3>
<p>PersistentVolumeバインドは排他的であり、PersistentVolumeClaimは名前空間オブジェクトであるため、"多"モード(<code>ROX</code>、<code>RWX</code>)でクレームをマウントすることは1つの名前空間内でのみ可能です。</p>
<h2 id=rawブロックボリュームのサポート>Rawブロックボリュームのサポート</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>次のボリュームプラグインは、必要に応じて動的プロビジョニングを含むrawブロックボリュームをサポートします。</p>
<ul>
<li>AWSElasticBlockStore</li>
<li>AzureDisk</li>
<li>CSI</li>
<li>FC (Fibre Channel)</li>
<li>GCEPersistentDisk</li>
<li>iSCSI</li>
<li>Local volume</li>
<li>OpenStack Cinder</li>
<li>RBD (Ceph Block Device)</li>
<li>VsphereVolume</li>
</ul>
<h3 id=persistent-volume-using-a-raw-block-volume>Rawブロックボリュームを使用した永続ボリューム</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pv<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fc</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetWWNs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;50060e801049cfd1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lun</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></code></pre></div><h3 id=rawブロックボリュームを要求する永続ボリュームクレーム>Rawブロックボリュームを要求する永続ボリュームクレーム</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></code></pre></div><h3 id=コンテナにrawブロックデバイスパスを追加するpod仕様>コンテナにRawブロックデバイスパスを追加するPod仕様</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-block-volume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fc-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:26<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;tail -f /dev/null&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeDevices</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>devicePath</span>:<span style=color:#bbb> </span>/dev/xvda<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Podにrawブロックデバイスを追加する場合は、マウントパスの代わりにコンテナーでデバイスパスを指定します。
</div>
<h3 id=ブロックボリュームのバインド>ブロックボリュームのバインド</h3>
<p>ユーザーがPersistentVolumeClaim specの<code>volumeMode</code>フィールドを使用してrawブロックボリュームの要求を示す場合、バインディングルールは、このモードをspecの一部として考慮しなかった以前のリリースとわずかに異なります。表にリストされているのは、ユーザーと管理者がrawブロックデバイスを要求するために指定可能な組み合わせの表です。この表は、ボリュームがバインドされるか、組み合わせが与えられないかを示します。静的にプロビジョニングされたボリュームのボリュームバインディングマトリクスはこちらです。</p>
<table>
<thead>
<tr>
<th>PVボリュームモード</th>
<th style=text-align:center>PVCボリュームモード</th>
<th style=text-align:right>結果</th>
</tr>
</thead>
<tbody>
<tr>
<td>未定義</td>
<td style=text-align:center>未定義</td>
<td style=text-align:right>バインド</td>
</tr>
<tr>
<td>未定義</td>
<td style=text-align:center>ブロック</td>
<td style=text-align:right>バインドなし</td>
</tr>
<tr>
<td>未定義</td>
<td style=text-align:center>ファイルシステム</td>
<td style=text-align:right>バインド</td>
</tr>
<tr>
<td>ブロック</td>
<td style=text-align:center>未定義</td>
<td style=text-align:right>バインドなし</td>
</tr>
<tr>
<td>ブロック</td>
<td style=text-align:center>ブロック</td>
<td style=text-align:right>バインド</td>
</tr>
<tr>
<td>ブロック</td>
<td style=text-align:center>ファイルシステム</td>
<td style=text-align:right>バインドなし</td>
</tr>
<tr>
<td>ファイルシステム</td>
<td style=text-align:center>ファイルシステム</td>
<td style=text-align:right>バインド</td>
</tr>
<tr>
<td>ファイルシステム</td>
<td style=text-align:center>ブロック</td>
<td style=text-align:right>バインドなし</td>
</tr>
<tr>
<td>ファイルシステム</td>
<td style=text-align:center>未定義</td>
<td style=text-align:right>バインド</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> アルファリリースでは、静的にプロビジョニングされたボリュームのみがサポートされます。管理者は、rawブロックデバイスを使用する場合、これらの値を考慮するように注意する必要があります。
</div>
<h2 id=ボリュームのスナップショットとスナップショットからのボリュームの復元のサポート>ボリュームのスナップショットとスナップショットからのボリュームの復元のサポート</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code>
</div>
<p>ボリュームスナップショット機能は、CSIボリュームプラグインのみをサポートするために追加されました。詳細については、<a href=/docs/concepts/storage/volume-snapshots/>ボリュームのスナップショット</a>を参照してください。</p>
<p>ボリュームスナップショットのデータソースからボリュームを復元する機能を有効にするには、apiserverおよびcontroller-managerで<code>VolumeSnapshotDataSource</code>フィーチャーゲートを有効にします。</p>
<h3 id=create-persistent-volume-claim-from-volume-snapshot>ボリュームスナップショットから永続ボリュームクレームを作成する</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>restore-pvc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>csi-hostpath-sc<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></code></pre></div><h2 id=ボリュームの複製>ボリュームの複製</h2>
<p><a href=/ja/docs/concepts/storage/volume-pvc-datasource/>ボリュームの複製</a>はCSIボリュームプラグインにのみ利用可能です。</p>
<p>PVCデータソースからのボリューム複製機能を有効にするには、apiserverおよびcontroller-managerで<code>VolumeSnapshotDataSource</code>フィーチャーゲートを有効にします。</p>
<h3 id=create-persistent-volume-claim-from-an-existing-pvc>既存のPVCからの永続ボリュームクレーム作成</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloned-pvc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>my-csi-plugin<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>existing-src-pvc-name<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></code></pre></div><h2 id=可搬性の高い設定の作成>可搬性の高い設定の作成</h2>
<p>もし幅広いクラスターで実行され、永続ボリュームが必要となる構成テンプレートやサンプルを作成している場合は、次のパターンを使用することをお勧めします。</p>
<ul>
<li>
<p>構成にPersistentVolumeClaimオブジェクトを含める(DeploymentやConfigMapと共に)</p>
</li>
<li>
<p>ユーザーが設定をインスタンス化する際にPersistentVolumeを作成する権限がない場合があるため、設定にPersistentVolumeオブジェクトを含めない。</p>
</li>
<li>
<p>テンプレートをインスタンス化する時にストレージクラス名を指定する選択肢をユーザーに与える</p>
<ul>
<li>ユーザーがストレージクラス名を指定する場合、persistentVolumeClaim.storageClassName フィールドにその値を入力する。これにより、クラスターが管理者によって有効にされたストレージクラスを持っている場合、PVCは正しいストレージクラスと一致する。</li>
<li>ユーザーがストレージクラス名を指定しない場合、<code>persistentVolumeClaim.storageClassName</code>フィールドはnilのままにする。これにより、PVはユーザーにクラスターのデフォルトストレージクラスで自動的にプロビジョニングされる。多くのクラスター環境ではデフォルトのストレージクラスがインストールされているが、管理者は独自のデフォルトストレージクラスを作成することができる。</li>
</ul>
</li>
<li>
<p>ツールがPVCを監視し、しばらくしてもバインドされないことをユーザーに表示する。これはクラスターが動的ストレージをサポートしない(この場合ユーザーは対応するPVを作成するべき)、もしくはクラスターがストレージシステムを持っていない(この場合ユーザーはPVCを必要とする設定をデプロイできない)可能性があることを示す。</p>
<h2 id=次の項目>次の項目</h2>
</li>
</ul>
<ul>
<li><a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume>Creating a Persistent Volume</a>について学ぶ</li>
<li><a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolumeclaim>Creating a Persistent Volume Claim</a>について学ぶ</li>
<li><a href=https://git.k8s.io/community/contributors/design-proposals/storage/persistent-storage.md>Persistent Storage design document</a>を読む</li>
</ul>
<h3 id=リファレンス>リファレンス</h3>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#persistentvolume-v1-core>PersistentVolume</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#persistentvolumespec-v1-core>PersistentVolumeSpec</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#persistentvolumeclaim-v1-core>PersistentVolumeClaim</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#persistentvolumeclaimspec-v1-core>PersistentVolumeClaimSpec</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-707ca81a34eb1ca202f34692e9917d1e>3.6.2 - CSI Volume Cloning</h1>
<p>このドキュメントではKubernetesで既存のCSIボリュームの複製についてのコンセプトを説明します。このページを読む前にあらかじめ<a href=/docs/concepts/storage/volumes>ボリューム</a>についてよく理解していることが望ましいです。</p>
<h2 id=イントロダクション>イントロダクション</h2>
<p><a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>のボリューム複製機能は、ユーザーが<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>の複製を作成することを示す<code>dataSource</code>フィールドで既存の<a class=glossary-tooltip title=コンテナ内でボリュームとしてマウントするためにPersistentVolume内で定義されたストレージリソースを要求します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PVC>PVC</a>を指定するためのサポートを追加します。</p>
<p>複製は既存のKubernetesボリュームの複製として定義され、標準のボリュームと同じように使用できます。唯一の違いは、プロビジョニング時に「新しい」空のボリュームを作成するのではなく、バックエンドデバイスが指定されたボリュームの正確な複製を作成することです。</p>
<p>複製の実装は、Kubernetes APIの観点からは新しいPVCの作成時に既存のPVCをdataSourceとして指定する機能を追加するだけです。ソースPVCはバインドされており、使用可能でなければなりません(使用中ではありません)。</p>
<p>この機能を使用する場合、ユーザーは次のことに注意する必要があります:</p>
<ul>
<li>複製のサポート(<code>VolumePVCDataSource</code>)はCSIドライバーのみです。</li>
<li>複製のサポートは動的プロビジョニングのみです。</li>
<li>CSIドライバーはボリューム複製機能を実装している場合としていない場合があります。</li>
<li>PVCは複製先のPVCと同じ名前空間に存在する場合にのみ複製できます(複製元と複製先は同じ名前空間になければなりません)。</li>
<li>複製は同じストレージクラス内でのみサポートされます。
<ul>
<li>宛先ボリュームは、ソースと同じストレージクラスである必要があります。</li>
<li>デフォルトのストレージクラスを使用でき、仕様ではstorageClassNameを省略できます。</li>
</ul>
</li>
<li>複製は同じVolumeMode設定を使用する2つのボリューム間でのみ実行できます(ブロックモードのボリュームを要求する場合、ソースもブロックモードである必要があります)。</li>
</ul>
<h2 id=プロビジョニング>プロビジョニング</h2>
<p>複製は同じ名前空間内の既存のPVCを参照するdataSourceを追加すること以外は他のPVCと同様にプロビジョニングされます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>clone-of-pvc-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>myns<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>cloning<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pvc-1<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>spec.resources.requests.storage</code>に容量の値を指定する必要があります。指定する値は、ソースボリュームの容量と同じかそれ以上である必要があります。
</div>
<p>このyamlの作成結果は指定された複製元である<code>pvc-1</code>と全く同じデータを持つ<code>clone-of-pvc-1</code>という名前の新しいPVCです。</p>
<h2 id=使い方>使い方</h2>
<p>新しいPVCが使用可能になると、複製されたPVCは他のPVCと同じように利用されます。またこの時点で新しく作成されたPVCは独立したオブジェクトであることが期待されます。元のdataSource PVCを考慮せず個別に利用、複製、スナップショット、削除できます。これはまた複製元が新しく作成された複製にリンクされておらず、新しく作成された複製に影響を与えずに変更または削除できることを意味します。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4d00116c86dade62bdd5be7dc2afa1ca>3.6.3 - VolumeSnapshotClass</h1>
<p>このドキュメントでは、Kubernetesにおける<code>VolumeSnapshotClass</code>のコンセプトについて説明します。<br>
関連する項目として、<a href=/docs/concepts/storage/volume-snapshots/>Volumeのスナップショット</a>と<a href=/docs/concepts/storage/storage-classes>ストレージクラス</a>も参照してください。</p>
<h2 id=イントロダクション>イントロダクション</h2>
<p><code>StorageClass</code>はVolumeをプロビジョンするときに、ストレージの"クラス"に関する情報を記述する方法を提供します。それと同様に、<code>VolumeSnapshotClass</code>ではVolumeSnapshotをプロビジョンするときに、ストレージの"クラス"に関する情報を記述する方法を提供します。</p>
<h2 id=volumesnapshotclass-リソース>VolumeSnapshotClass リソース</h2>
<p>各<code>VolumeSnapshotClass</code>は<code>driver</code>、<code>deletionPolicy</code>と<code>parameters</code>フィールドを含み、それらは、そのクラスに属する<code>VolumeSnapshot</code>が動的にプロビジョンされるときに使われます。</p>
<p><code>VolumeSnapshotClass</code>オブジェクトの名前は重要であり、それはユーザーがどのように特定のクラスをリクエストできるかを示したものです。管理者は初めて<code>VolumeSnapshotClass</code>オブジェクトを作成するときに、その名前と他のパラメーターをセットし、そのオブジェクトは一度作成されるとそのあと更新することができません。</p>
<p>管理者は、バインド対象のクラスを1つもリクエストしないようなVolumeSnapshotのために、デフォルトの<code>VolumeSnapshotClass</code>を指定することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></code></pre></div><h3 id=driver>Driver</h3>
<p>VolumeSnapshotClassは、VolumeSnapshotをプロビジョンするときに何のCSIボリュームプラグインを使うか決定するための<code>driver</code>フィールドを持っています。このフィールドは必須となります。</p>
<h3 id=deletionpolicy>DeletionPolicy</h3>
<p>VolumeSnapshotClassにはdeletionPolicyがあります。これにより、バインドされている <code>VolumeSnapshot</code>オブジェクトが削除されるときに、<code>VolumeSnapshotContent</code>がどうなるかを設定することができます。VolumeSnapshotのdeletionPolicyは、<code>Retain</code>または<code>Delete</code>のいずれかです。このフィールドは指定しなければなりません。</p>
<p>deletionPolicyが<code>Delete</code>の場合、元となるストレージスナップショットは <code>VolumeSnapshotContent</code>オブジェクトとともに削除されます。deletionPolicyが<code>Retain</code>の場合、元となるスナップショットと<code>VolumeSnapshotContent</code>の両方が残ります。</p>
<h2 id=parameters>Parameters</h2>
<p>VolumeSnapshotClassは、そのクラスに属するVolumeSnapshotを指定するパラメータを持っています。
<code>driver</code>に応じて様々なパラメータを使用できます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-018f0a7fc6e2f6d16da37702fc39b4f3>3.6.4 - ボリュームの動的プロビジョニング(Dynamic Volume Provisioning)</h1>
<p>ボリュームの動的プロビジョニングにより、ストレージ用のボリュームをオンデマンドに作成することができます。
動的プロビジョニングなしでは、クラスター管理者はクラウドプロバイダーまたはストレージプロバイダーに対して新規のストレージ用のボリュームと<a href=/ja/docs/concepts/storage/persistent-volumes/><code>PersistentVolume</code>オブジェクト</a>を作成するように手動で指示しなければなりません。動的プロビジョニングの機能によって、クラスター管理者がストレージを事前にプロビジョンする必要がなくなります。その代わりに、ユーザーによってリクエストされたときに自動でストレージをプロビジョンします。</p>
<h2 id=バックグラウンド>バックグラウンド</h2>
<p>ボリュームの動的プロビジョニングの実装は<code>storage.k8s.io</code>というAPIグループ内の<code>StorageClass</code>というAPIオブジェクトに基づいています。クラスター管理者は<code>StorageClass</code>オブジェクトを必要に応じていくつでも定義でき、各オブジェクトはボリュームをプロビジョンする<em>Volumeプラグイン</em> (別名<em>プロビジョナー</em>)と、プロビジョンされるときにプロビジョナーに渡されるパラメータを指定します。
クラスター管理者はクラスター内で複数の種類のストレージ(同一または異なるストレージシステム)を定義し、さらには公開でき、それらのストレージはパラメータのカスタムセットを持ちます。この仕組みにおいて、エンドユーザーはストレージがどのようにプロビジョンされるか心配する必要がなく、それでいて複数のストレージオプションから選択できることを保証します。</p>
<p>StorageClassに関するさらなる情報は<a href=/docs/concepts/storage/storage-classes/>Storage Class</a>を参照ください。</p>
<h2 id=動的プロビジョニングを有効にする>動的プロビジョニングを有効にする</h2>
<p>動的プロビジョニングを有効にするために、クラスター管理者はユーザーのために1つまたはそれ以上のStorageClassを事前に作成する必要があります。StorageClassオブジェクトは、動的プロビジョニングが実行されるときに、どのプロビジョナーが使用されるべきか、またどのようなパラメーターをプロビジョナーに渡すべきか定義します。StorageClassオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<p>下記のマニフェストでは標準的な永続化ディスクをプロビジョンする"slow"というStorageClassを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span></code></pre></div><p>下記のマニフェストではSSDを使った永続化ディスクをプロビジョンする"fast"というStorageClassを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-ssd<span style=color:#bbb>
</span></code></pre></div><h2 id=動的プロビジョニングの使用>動的プロビジョニングの使用</h2>
<p>ユーザーは<code>PersistentVolumeClaim</code>リソース内でStorageClassを含むことで、動的にプロビジョンされたStorageをリクエストできます。Kubernetes v1.6以前では、この機能は<code>volume.beta.kubernetes.io/storage-class</code>アノテーションを介して使うことができました。しかしこのアノテーションではv1.6から廃止になりました。その代わりユーザーは現在では<code>PersistentVolumeClaim</code>オブジェクトの<code>storageClassName</code>を使う必要があります。このフィールドの値は、管理者によって設定された<code>StorageClass</code>の名前と一致しなければなりません(<a href=#enabling-dynamic-provisioning>下記</a>のセクションも参照ください)。</p>
<p>"fast"というStorageClassを選択するために、例としてユーザーは下記のPersistentVolumeClaimを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>claim1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>30Gi<span style=color:#bbb>
</span></code></pre></div><p>このリソースによってSSDのような永続化ディスクが自動的にプロビジョンされます。このリソースが削除された時、そのボリュームは削除されます。</p>
<h2 id=デフォルトの挙動>デフォルトの挙動</h2>
<p>動的プロビジョニングは、もしStorageClassが1つも指定されていないときに全てのPersistentVolumeClaimが動的にプロビジョンされるようにクラスター上で有効にできます。クラスター管理者は、下記を行うことによりこのふるまいを有効にできます。</p>
<ul>
<li>1つの<code>StorageClass</code>オブジェクトを<em>default</em> としてマーキングする</li>
<li>API Server上で<a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code>管理コントローラー</a>を有効にする。</li>
</ul>
<p>管理者は<code>StorageClass</code>に対して<code>storageclass.kubernetes.io/is-default-class</code>アノテーションをつけることで、デフォルトのStorageClassとしてマーキングできます。
デフォルトの<code>StorageClass</code>がクラスター内で存在し、かつユーザーが<code>PersistentVolumeClaim</code>リソースで<code>storageClassName</code>を指定しなかった場合、<code>DefaultStorageClass</code>という管理コントローラーは<code>storageClassName</code>フィールドの値をデフォルトのStorageClassを指し示すように自動で追加します。</p>
<p>注意点として、クラスター上では最大1つしか<em>デフォルト</em> のStorageClassが指定できず、<code>storageClassName</code>を明示的に指定しない<code>PersistentVolumeClaim</code>は作成することもできません。</p>
<h2 id=トポロジーに関する注意>トポロジーに関する注意</h2>
<p><a href=/docs/setup/multiple-zones>マルチゾーン</a>クラスター内では、Podは単一のリージョン内のゾーンをまたいでしか稼働できません。シングルゾーンのStorageバックエンドはPodがスケジュールされるゾーン内でプロビジョンされる必要があります。これは<a href=/docs/concepts/storage/storage-classes/#volume-binding-mode>Volume割り当てモード</a>を設定することにより可能となります。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-00cd24f4570b7acaac75c2551c948bc7>3.6.5 - ストレージ容量</h1>
<p>ストレージ容量は、Podが実行されるノードごとに制限があったり、大きさが異なる可能性があります。たとえば、NASがすべてのノードからはアクセスできなかったり、初めからストレージがノードローカルでしか利用できない可能性があります。</p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [alpha]</code>
</div>
<p>このページでは、Kubernetesがストレージ容量を追跡し続ける方法と、スケジューラーがその情報を利用して、残りの未作成のボリュームのために十分なストレージ容量へアクセスできるノード上にどのようにPodをスケジューリングするかについて説明します。もしストレージ容量の追跡がなければ、スケジューラーは、ボリュームをプロビジョニングするために十分な容量のないノードを選択してしまい、スケジューリングの再試行が複数回行われてしまう恐れがあります。</p>
<p>ストレージ容量の追跡は、<a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label="Container Storage Interface">Container Storage Interface</a>(CSI)向けにサポートされており、CSIドライバーのインストール時に<a href=#enabling-storage-capacity-tracking>有効にする必要があります</a>。</p>
<h2 id=api>API</h2>
<p>この機能には、以下の2つのAPI拡張があります。</p>
<ul>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#csistoragecapacity-v1alpha1-storage-k8s-io>CSIStorageCapacity</a>オブジェクト: このオブジェクトは、CSIドライバーがインストールされた名前空間に生成されます。各オブジェクトには1つのストレージクラスに対する容量の情報が含まれ、そのストレージに対してどのノードがアクセス権を持つかが定められています。</p>
</li>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#csidriverspec-v1-storage-k8s-io><code>CSIDriverSpec.StorageCapacity</code>フィールド</a>: <code>true</code>に設定すると、Kubernetesのスケジューラーが、CSIドライバーを使用するボリュームに対してストレージ容量を考慮するようになります。</p>
</li>
</ul>
<h2 id=スケジューリング>スケジューリング</h2>
<p>ストレージ容量の情報がKubernetesのスケジューラーで利用されるのは、以下のすべての条件を満たす場合です。</p>
<ul>
<li><code>CSIStorageCapacity</code>フィーチャーゲートがtrueである</li>
<li>Podがまだ作成されていないボリュームを使用する時</li>
<li>そのボリュームが、CSIドライバーを参照し、<a href=/docs/concepts/storage/storage-classes/#volume-binding-mode>volume binding mode</a>に<code>WaitForFirstConsumer</code>を使う<a class=glossary-tooltip title=StorageClassは管理者が利用可能なさまざまなストレージタイプを記述する方法を提供します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/storage-classes target=_blank aria-label=StorageClass>StorageClass</a>を使用している</li>
<li>ドライバーに対する<code>CSIDriver</code>オブジェクトの<code>StorageCapacity</code>がtrueに設定されている</li>
</ul>
<p>その場合、スケジューラーはPodに対して、十分なストレージ容量が利用できるノードだけを考慮するようになります。このチェックは非常に単純で、ボリュームのサイズと、<code>CSIStorageCapacity</code>オブジェクトに一覧された容量を、ノードを含むトポロジーで比較するだけです。</p>
<p>volume binding modeが<code>Immediate</code>のボリュームの場合、ストレージドライバーはボリュームを使用するPodとは関係なく、ボリュームを作成する場所を決定します。次に、スケジューラーはボリュームが作成された後、Podをボリュームが利用できるノードにスケジューリングします。</p>
<p><a href=/docs/concepts/storage/volumes/#csi>CSI ephemeral volumes</a>の場合、スケジューリングは常にストレージ容量を考慮せずに行われます。このような動作になっているのは、このボリュームタイプはノードローカルな特別なCSIドライバーでのみ使用され、そこでは特に大きなリソースが必要になることはない、という想定に基づいています。</p>
<h2 id=再スケジューリング>再スケジューリング</h2>
<p><code>WaitForFirstConsumer</code>ボリュームがあるPodに対してノードが選択された場合は、その決定はまだ一時的なものです。次のステップで、CSIストレージドライバーに対して、選択されたノード上でボリュームが利用可能になることが予定されているというヒントを使用してボリュームの作成を要求します。</p>
<p>Kubernetesは古い容量の情報をもとにノードを選択する場合があるため、実際にはボリュームが作成できないという可能性が存在します。その場合、ノードの選択がリセットされ、KubernetesスケジューラーはPodに割り当てるノードを再び探します。</p>
<h2 id=制限>制限</h2>
<p>ストレージ容量を追跡することで、1回目の試行でスケジューリングが成功する可能性が高くなります。しかし、スケジューラーは潜在的に古い情報に基づいて決定を行う可能性があるため、成功を保証することはできません。通常、ストレージ容量の情報が存在しないスケジューリングと同様のリトライの仕組みによって、スケジューリングの失敗に対処します。</p>
<p>スケジューリングが永続的に失敗する状況の1つは、Podが複数のボリュームを使用する場合で、あるトポロジーのセグメントで1つのボリュームがすでに作成された後、もう1つのボリュームのために十分な容量が残っていないような場合です。この状況から回復するには、たとえば、容量を増加させたり、すでに作成されたボリュームを削除するなどの手動での対応が必要です。この問題に自動的に対処するためには、まだ<a href=https://github.com/kubernetes/enhancements/pull/1703>追加の作業</a>が必要となっています。</p>
<h2 id=enabling-storage-capacity-tracking>ストレージ容量の追跡を有効にする</h2>
<p>ストレージ容量の追跡は<em>アルファ機能</em>であり、<code>CSIStorageCapacity</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>と<code>storage.k8s.io/v1alpha1</code> <a class=glossary-tooltip title="A set of related paths in the Kubernetes API." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label="API group">API group</a>を有効にした場合にのみ、有効化されます。詳細については、<code>--feature-gates</code>および<code>--runtime-config</code> <a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserverパラメータ</a>を参照してください。</p>
<p>Kubernetesクラスターがこの機能をサポートしているか簡単に確認するには、以下のコマンドを実行して、CSIStorageCapacityオブジェクトを一覧表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csistoragecapacities --all-namespaces
</code></pre></div><p>クラスターがCSIStorageCapacityをサポートしていれば、CSIStorageCapacityのリストが表示されるか、次のメッセージが表示されます。</p>
<pre><code>No resources found
</code></pre><p>もしサポートされていなければ、代わりに次のエラーが表示されます。</p>
<pre><code>error: the server doesn't have a resource type &quot;csistoragecapacities&quot;
</code></pre><p>クラスター内で機能を有効化することに加えて、CSIドライバーもこの機能をサポートしている必要があります。詳細については、各ドライバーのドキュメントを参照してください。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>設計に関するさらなる情報について知るために、<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1472-storage-capacity-tracking/README.md>Storage Capacity Constraints for Pod Scheduling KEP</a>を読む。</li>
<li>この機能の今後の開発に関する情報について知るために、<a href=https://github.com/kubernetes/enhancements/issues/1472>enhancement tracking issue #1472</a>を参照する。</li>
<li><a href=/ja/docs/concepts/scheduling-eviction/kube-scheduler/>Kubernetesのスケジューラー</a>についてもっと学ぶ。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-275bea454e1cf4c5adeca4058b5af988>3.7 - 設定</h1>
</div>
<div class=td-content>
<h1 id=pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>3.7.1 - 設定のベストプラクティス</h1>
<p>このドキュメントでは、ユーザーガイド、入門マニュアル、および例を通して紹介されている設定のベストプラクティスを中心に説明します。</p>
<p>このドキュメントは生ものです。このリストには載っていないが他の人に役立つかもしれない何かについて考えている場合、IssueまたはPRを遠慮なく作成してください。</p>
<h2 id=一般的な設定のtips>一般的な設定のTips</h2>
<ul>
<li>
<p>構成を定義する際には、最新の安定したAPIバージョンを指定してください。</p>
</li>
<li>
<p>設定ファイルは、クラスターに反映される前にバージョン管理システムに保存されるべきです。これによって、必要に応じて設定変更を迅速にロールバックできます。また、クラスターの再作成や復元時にも役立ちます。</p>
</li>
<li>
<p>JSONではなくYAMLを使って設定ファイルを書いてください。これらのフォーマットはほとんどすべてのシナリオで互換的に使用できますが、YAMLはよりユーザーフレンドリーになる傾向があります。</p>
</li>
<li>
<p>意味がある場合は常に、関連オブジェクトを単一ファイルにグループ化します。多くの場合、1つのファイルの方が管理が簡単です。例として<a href=https://github.com/kubernetes/examples/tree/v1.22.16/guestbook/all-in-one/guestbook-all-in-one.yaml>guestbook-all-in-one.yaml</a>ファイルを参照してください。</p>
</li>
<li>
<p>多くの<code>kubectl</code>コマンドがディレクトリに対しても呼び出せることも覚えておきましょう。たとえば、設定ファイルのディレクトリで <code>kubectl apply</code>を呼び出すことができます。</p>
</li>
<li>
<p>不必要にデフォルト値を指定しないでください。シンプルかつ最小限の設定のほうがエラーが発生しにくくなります。</p>
</li>
<li>
<p>よりよいイントロスペクションのために、オブジェクトの説明をアノテーションに入れましょう。</p>
</li>
</ul>
<h2 id=naked-pods-vs-replicasets-deployments-and-jobs>"真っ裸"のPod に対する ReplicaSet、Deployment、およびJob</h2>
<ul>
<li>
<p>可能な限り、"真っ裸"のPod(<a href=/ja/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>や<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>にバインドされていないPod)は使わないでください。Nodeに障害が発生した場合、これらのPodは再スケジュールされません。</p>
<p>明示的に<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>restartPolicy: Never</code></a>を使いたいシーンを除いて、DeploymentはPodを直接作成するよりもほとんど常に望ましい方法です。Deploymentには、希望する数のPodが常に使用可能であることを確認するためにReplicaSetを作成したり、Podを置き換えるための戦略(RollingUpdateなど)を指定したりできます。<a href=/docs/concepts/workloads/controllers/job/>Job</a>のほうが適切な場合もあるかもしれません。</p>
</li>
</ul>
<h2 id=service>Service</h2>
<ul>
<li>
<p>対応するバックエンドワークロード（DeploymentまたはReplicaSet）の前、およびそれにアクセスする必要があるワークロードの前に<a href=/ja/docs/concepts/services-networking/service/>Service</a>を作成します。Kubernetesがコンテナを起動すると、コンテナ起動時に実行されていたすべてのServiceを指す環境変数が提供されます。たとえば、fooという名前のServiceが存在する場合、すべてのコンテナは初期環境で次の変数を取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;the host the Service is running on&gt;
<span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;the port the Service is running on&gt;
</code></pre></div><p><em>これは順序付けの必要性を意味します</em> - <code>Pod</code>がアクセスしたい<code>Service</code>は<code>Pod</code>自身の前に作らなければならず、そうしないと環境変数は注入されません。DNSにはこの制限はありません。</p>
</li>
<li>
<p>（強くお勧めしますが）<a href=/ja/docs/concepts/cluster-administration/addons/>クラスターアドオン</a>の1つの選択肢はDNSサーバーです。DNSサーバーは、新しい<code>Service</code>についてKubernetes APIを監視し、それぞれに対して一連のDNSレコードを作成します。クラスタ全体でDNSが有効になっている場合は、すべての<code>Pod</code>が自動的に<code>Services</code>の名前解決を行えるはずです。</p>
</li>
<li>
<p>どうしても必要な場合以外は、Podに<code>hostPort</code>を指定しないでください。Podを<code>hostPort</code>にバインドすると、Podがスケジュールできる場所の数を制限します、それぞれの&lt;<code>hostIP</code>、 <code>hostPort</code>、<code>protocol</code>>の組み合わせはユニークでなければならないからです。<code>hostIP</code>と<code>protocol</code>を明示的に指定しないと、Kubernetesはデフォルトの<code>hostIP</code>として<code>0.0.0.0</code>を、デフォルトの <code>protocol</code>として<code>TCP</code>を使います。</p>
<p>デバッグ目的でのみポートにアクセスする必要がある場合は、<a href=/docs/tasks/access-application-cluster/access-cluster/#manually-constructing-apiserver-proxy-urls>apiserver proxy</a>または<a href=/docs/tasks/access-application-cluster/port-forward-access-application-cluster/><code>kubectl port-forward</code></a>を使用できます。</p>
<p>ノード上でPodのポートを明示的に公開する必要がある場合は、hostPortに頼る前に<a href=/ja/docs/concepts/services-networking/service/#nodeport>NodePort</a>の使用を検討してください。</p>
</li>
<li>
<p><code>hostPort</code>の理由と同じくして、<code>hostNetwork</code>の使用はできるだけ避けてください。</p>
</li>
<li>
<p><code>kube-proxy</code>のロードバランシングが不要な場合は、<a href=/ja/docs/concepts/services-networking/service/#headless-service>headless Service</a>（<code>ClusterIP</code>が<code>None</code>）を使用してServiceを簡単に検出できます。</p>
</li>
</ul>
<h2 id=ラベルの使用>ラベルの使用</h2>
<ul>
<li><code>{ app: myapp, tier: frontend, phase: test, deployment: v3 }</code>のように、アプリケーションまたはデプロイメントの <strong>セマンティック属性</strong> を識別する<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベル</a>を定義して使いましょう。これらのラベルを使用して、他のリソースに適切なPodを選択できます。例えば、すべての<code>tier：frontend</code>を持つPodを選択するServiceや、<code>app：myapp</code>に属するすべての<code>phase：test</code>コンポーネント、などです。このアプローチの例を知るには、<a href=https://github.com/kubernetes/examples/tree/v1.22.16/guestbook/>ゲストブック</a>アプリも合わせてご覧ください。</li>
</ul>
<p>セレクターからリリース固有のラベルを省略することで、Serviceを複数のDeploymentにまたがるように作成できます。 <a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>により、ダウンタイムなしで実行中のサービスを簡単に更新できます。</p>
<p>オブジェクトの望ましい状態はDeploymentによって記述され、その仕様への変更が <em>適用</em> されると、Deploymentコントローラは制御された速度で実際の状態を望ましい状態に変更します。</p>
<ul>
<li>デバッグ用にラベルを操作できます。Kubernetesコントローラー（ReplicaSetなど）とServiceはセレクターラベルを使用してPodとマッチするため、Podから関連ラベルを削除すると、コントローラーによって考慮されたり、Serviceによってトラフィックを処理されたりすることがなくなります。既存のPodのラベルを削除すると、そのコントローラーはその代わりに新しいPodを作成します。これは、「隔離」環境で以前の「ライブ」Podをデバッグするのに便利な方法です。対話的にラベルを削除または追加するには、<a href=/docs/reference/generated/kubectl/kubectl-commands#label><code>kubectl label</code></a>を使います。</li>
</ul>
<h2 id=コンテナイメージ>コンテナイメージ</h2>
<p><a href=/ja/docs/concepts/containers/images/#updating-images>imagePullPolicy</a>とイメージのタグは、<a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>が特定のイメージをpullしようとしたときに作用します。</p>
<ul>
<li>
<p><code>imagePullPolicy: IfNotPresent</code>: ローカルでイメージが見つからない場合にのみイメージをpullします。</p>
</li>
<li>
<p><code>imagePullPolicy: Always</code>: kubeletがコンテナを起動する度に、kubeletはコンテナイメージレジストリに問い合わせて、イメージのダイジェストの名前解決を行います。もし、kubeletが同じダイジェストのコンテナイメージをローカルにキャッシュしていたら、kubeletはそのキャッシュされたイメージを利用します。そうでなければ、kubeletは解決されたダイジェストのイメージをダウンロードし、そのイメージを利用してコンテナを起動します。</p>
</li>
<li>
<p><code>imagePullPolicy</code> のタグが省略されていて、利用してるイメージのタグが<code>:latest</code>の場合や省略されている場合、<code>Always</code>が適用されます。</p>
</li>
<li>
<p><code>imagePullPolicy</code> のタグが省略されていて、利用してるイメージのタグはあるが<code>:latest</code>でない場合、<code>IfNotPresent</code>が適用されます。</p>
</li>
<li>
<p><code>imagePullPolicy: Never</code>: 常にローカルでイメージを探そうとします。ない場合にもイメージはpullしません。</p>
</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> コンテナが常に同じバージョンのイメージを使用するようにするためには、そのコンテナイメージの<a href=https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier>ダイジェスト</a>を指定することができます。<code>&lt;image-name>:&lt;tag></code>を<code>&lt;image-name>@&lt;digest></code>で置き換えます(例:<code>image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>)。このダイジェストはイメージの特定のバージョンを一意に識別するため、ダイジェスト値を変更しない限り、Kubernetesによって更新されることはありません。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> どのバージョンのイメージが実行されているのかを追跡するのが難しく、適切にロールバックするのが難しいため、本番環境でコンテナをデプロイするときは <code>：latest</code>タグを使用しないでください。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ベースイメージのプロバイダーのキャッシュセマンティクスにより、<code>imagePullPolicy：Always</code>もより効率的になります。たとえば、Dockerでは、イメージがすでに存在する場合すべてのイメージレイヤーがキャッシュされ、イメージのダウンロードが不要であるため、pullが高速になります。
</div>
<h2 id=kubectlの使い方>kubectlの使い方</h2>
<ul>
<li>
<p><code>kubectl apply -f &lt;directory></code>を使いましょう。これを使うと、ディレクトリ内のすべての<code>.yaml</code>、<code>.yml</code>、および<code>.json</code>ファイルが<code>apply</code>に渡されます。</p>
</li>
<li>
<p><code>get</code>や<code>delete</code>を行う際は、特定のオブジェクト名を指定するのではなくラベルセレクターを使いましょう。<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルセレクター</a>と<a href=/ja/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively>ラベルの効果的な使い方</a>のセクションを参照してください。</p>
</li>
<li>
<p>単一コンテナのDeploymentやServiceを素早く作成するなら、<code>kubectl create deployment</code>や<code>kubectl expose</code>を使いましょう。一例として、<a href=/ja/docs/tasks/access-application-cluster/service-access-application-cluster/>Serviceを利用したクラスター内のアプリケーションへのアクセス</a>を参照してください。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-6b5ccadd699df0904e8e9917c5450c4b>3.7.2 - ConfigMap</h1>
<p><p>ConfigMapは、 機密性のないデータをキーと値のペアで保存するために使用されるAPIオブジェクトです。<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>は、環境変数、コマンドライン引数、または<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>内の設定ファイルとしてConfigMapを使用できます。</p></p>
<p>ConfigMapを使用すると、環境固有の設定を<a class=glossary-tooltip title=アプリケーションの実行に必要なソフトウェアのセットを持つ、保存されたコンテナの実体です。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-image" target=_blank aria-label=コンテナイメージ>コンテナイメージ</a>から分離できるため、アプリケーションを簡単に移植できるようになります。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> ConfigMapは機密性や暗号化を提供しません。保存したいデータが機密情報である場合は、ConfigMapの代わりに<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>を使用するか、追加の(サードパーティー)ツールを使用してデータが非公開になるようにしてください。
</div>
<h2 id=動機>動機</h2>
<p>アプリケーションのコードとは別に設定データを設定するには、ConfigMapを使用します。</p>
<p>たとえば、アプリケーションを開発していて、(開発用時には)自分のコンピューター上と、(実際のトラフィックをハンドルするときは)クラウド上とで実行することを想像してみてください。あなたは、<code>DATABASE_HOST</code>という名前の環境変数を使用するコードを書きます。ローカルでは、この変数を<code>localhost</code>に設定します。クラウド上では、データベースコンポーネントをクラスター内に公開するKubernetesの<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>を指すように設定します。</p>
<p>こうすることで、必要であればクラウド上で実行しているコンテナイメージを取得することで、ローカルでも完全に同じコードを使ってデバッグができるようになります。</p>
<p>ConfigMapは、大量のデータを保持するようには設計されていません。ConfigMapに保存されるデータは1MiBを超えることはできません。この制限を超える設定を保存する必要がある場合は、ボリュームのマウントを検討するか、別のデータベースまたはファイルサービスを使用することを検討してください。</p>
<h2 id=configmapオブジェクト>ConfigMapオブジェクト</h2>
<p>ConfigMapは、他のオブジェクトが使うための設定を保存できるAPI<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/>オブジェクト</a>です。ほとんどのKubernetesオブジェクトに<code>spec</code>セクションがあるのとは違い、ConfigMapには<code>data</code>および<code>binaryData</code>フィールドがあります。これらのフィールドは、キーとバリューのペアを値として受け入れます。<code>data</code>フィールドと<code>binaryData</code>フィールドはどちらもオプションです。<code>data</code>フィールドはUTF-8バイトシーケンスを含むように設計されていますが、<code>binaryData</code>フィールドはバイナリデータを含むように設計されています。</p>
<p>ConfigMapの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSのサブドメイン名</a>でなければなりません。</p>
<p><code>data</code>または<code>binaryData</code>フィールドの各キーは、英数字、<code>-</code>、<code>_</code>、または<code>.</code>で構成されている必要があります。<code>data</code>に格納されているキーは、<code>binaryData</code>フィールドのキーと重複することはできません。</p>
<p>v1.19以降、ConfigMapの定義に<code>immutable</code>フィールドを追加して、<a href=#configmap-immutable>イミュータブルなConfigMap</a>を作成できます。</p>
<h2 id=configmapとpod>ConfigMapとPod</h2>
<p>ConfigMapを参照して、ConfigMap内のデータを元にしてPod内のコンテナの設定をするPodの<code>spec</code>を書くことができます。このとき、PodとConfigMapは同じ<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=名前空間>名前空間</a>内に存在する必要があります。</p>
<p>以下に、ConfigMapの例を示します。単一の値を持つキーと、Configuration形式のデータ片のような値を持つキーがあります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># プロパティーに似たキー。各キーは単純な値にマッピングされている</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>player_initial_lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui_properties_file_name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ファイルに似たキー</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    enemy.types=aliens,monsters
</span><span style=color:#b44;font-style:italic>    player.maximum-lives=5</span><span style=color:#bbb>    
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user-interface.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    color.good=purple
</span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span><span style=color:#b44;font-style:italic>    allow.textmode=true</span><span style=color:#bbb>    
</span></code></pre></div><p>ConfigMapを利用してPod内のコンテナを設定する方法には、次の4種類があります。</p>
<ol>
<li>コンテナ内のコマンドと引数</li>
<li>環境変数をコンテナに渡す</li>
<li>読み取り専用のボリューム内にファイルを追加し、アプリケーションがそのファイルを読み取る</li>
<li>Kubernetes APIを使用してConfigMapを読み込むコードを書き、そのコードをPod内で実行する</li>
</ol>
<p>これらのさまざまな方法は、利用するデータをモデル化するのに役立ちます。最初の3つの方法では、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>がPodのコンテナを起動する時にConfigMapのデータを使用します。</p>
<p>4番目の方法では、ConfigMapとそのデータを読み込むためのコードを自分自身で書く必要があります。しかし、Kubernetes APIを直接使用するため、アプリケーションはConfigMapがいつ変更されても更新イベントを受信でき、変更が発生したときにすぐに反応できます。この手法では、Kubernetes APIに直接アクセスすることで、別の名前空間にあるConfigMapにもアクセスできます。</p>
<p>以下に、Podを設定するために<code>game-demo</code>から値を使用するPodの例を示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-demo-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>alpine<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;3600&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 環境変数を定義します。</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PLAYER_INITIAL_LIVES<span style=color:#bbb> </span><span style=color:#080;font-style:italic># ここではConfigMap内のキーの名前とは違い</span><span style=color:#bbb>
</span><span style=color:#bbb>                                     </span><span style=color:#080;font-style:italic># 大文字が使われていることに着目してください。</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo          <span style=color:#bbb> </span><span style=color:#080;font-style:italic># この値を取得するConfigMap。</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>player_initial_lives<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 取得するキー。</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>UI_PROPERTIES_FILE_NAME<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ui_properties_file_name<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/config&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Podレベルでボリュームを設定し、Pod内のコンテナにマウントします。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># マウントしたいConfigMapの名前を指定します。</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ファイルとして作成するConfigMapのキーの配列</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>ConfigMapは1行のプロパティの値と複数行のファイルに似た形式の値を区別しません。問題となるのは、Podや他のオブジェクトによる値の使用方法です。</p>
<p>この例では、ボリュームを定義して、<code>demo</code>コンテナの内部で<code>/config</code>にマウントしています。これにより、ConfigMap内には4つのキーがあるにもかかわらず、2つのファイル<code>/config/game.properties</code>および<code>/config/user-interface.properties</code>だけが作成されます。</p>
<p>これは、Podの定義が<code>volumes</code>セクションで<code>items</code>という配列を指定しているためです。もし<code>items</code>の配列を完全に省略すれば、ConfigMap内の各キーがキーと同じ名前のファイルになり、4つのファイルが作成されます。</p>
<h2 id=configmapを使う>ConfigMapを使う</h2>
<p>ConfigMapは、データボリュームとしてマウントできます。ConfigMapは、Podへ直接公開せずにシステムの他の部品として使うこともできます。たとえば、ConfigMapには、システムの他の一部が設定のために使用するデータを保存できます。</p>
<p>ConfigMapの最も一般的な使い方では、同じ名前空間にあるPod内で実行されているコンテナに設定を構成します。ConfigMapを独立して使用することもできます。</p>
<p>たとえば、ConfigMapに基づいて動作を調整する<a class=glossary-tooltip title="Resources that extend the functionality of Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=アドオン>アドオン</a>や<a class=glossary-tooltip title="A specialized controller used to manage a custom resource" data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=オペレーター>オペレーター</a>を見かけることがあるかもしれません。</p>
<h3 id=configmapをpodからファイルとして使う>ConfigMapをPodからファイルとして使う</h3>
<p>ConfigMapをPod内のボリュームで使用するには、次のようにします。</p>
<ol>
<li>ConfigMapを作成するか、既存のConfigMapを使用します。複数のPodから同じConfigMapを参照することもできます。</li>
<li>Podの定義を修正して、<code>.spec.volumes[]</code>以下にボリュームを追加します。ボリュームに任意の名前を付け、<code>.spec.volumes[].configMap.name</code>フィールドにConfigMapオブジェクトへの参照を設定します。</li>
<li>ConfigMapが必要な各コンテナに<code>.spec.containers[].volumeMounts[]</code>を追加します。<code>.spec.containers[].volumeMounts[].readOnly = true</code>を指定して、<code>.spec.containers[].volumeMounts[].mountPath</code>には、ConfigMapのデータを表示したい未使用のディレクトリ名を指定します。</li>
<li>イメージまたはコマンドラインを修正して、プログラムがそのディレクトリ内のファイルを読み込むように設定します。ConfigMapの<code>data</code>マップ内の各キーが、<code>mountPath</code>以下のファイル名になります。</li>
</ol>
<p>以下は、ボリューム内にConfigMapをマウントするPodの例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></code></pre></div><p>使用したいそれぞれのConfigMapごとに、<code>.spec.volumes</code>内で参照する必要があります。</p>
<p>Pod内に複数のコンテナが存在する場合、各コンテナにそれぞれ別の<code>volumeMounts</code>のブロックが必要ですが、<code>.spec.volumes</code>はConfigMapごとに1つしか必要ありません。</p>
<h4 id=マウントしたconfigmapの自動的な更新>マウントしたConfigMapの自動的な更新</h4>
<p>ボリューム内で現在使用中のConfigMapが更新されると、射影されたキーも最終的に(eventually)更新されます。kubeletは定期的な同期のたびにマウントされたConfigMapが新しいかどうか確認します。しかし、kubeletが現在のConfigMapの値を取得するときにはローカルキャッシュを使用します。キャッシュの種類は、<a href=https://github.com/kubernetes/kubernetes/blob/release-1.22/staging/src/k8s.io/kubelet/config/v1beta1/types.go>KubeletConfiguration構造体</a>の中の<code>ConfigMapAndSecretChangeDetectionStrategy</code>フィールドで設定可能です。ConfigMapは、監視(デフォルト)、ttlベース、またはすべてのリクエストを直接APIサーバーへ単純にリダイレクトする方法のいずれかによって伝搬されます。その結果、ConfigMapが更新された瞬間から、新しいキーがPodに射影されるまでの遅延の合計は、最長でkubeletの同期期間+キャッシュの伝搬遅延になります。ここで、キャッシュの伝搬遅延は選択したキャッシュの種類に依存します(監視の伝搬遅延、キャッシュのttl、または0に等しくなります)。</p>
<p>環境変数として使用されるConfigMapは自動的に更新されないため、ポッドを再起動する必要があります。</p>
<h2 id=configmap-immutable>イミュータブルなConfigMap</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code>
</div>
<p>Kubernetesのベータ版の機能である <em>イミュータブルなSecretおよびConfigMap</em> は、個別のSecretやConfigMapをイミュータブルに設定するオプションを提供します。ConfigMapを広範に使用している(少なくとも数万のConfigMapがPodにマウントされている)クラスターでは、データの変更を防ぐことにより、以下のような利点が得られます。</p>
<ul>
<li>アプリケーションの停止を引き起こす可能性のある予想外の(または望まない)変更を防ぐことができる</li>
<li>ConfigMapをイミュータブルにマークして監視を停止することにより、kube-apiserverへの負荷を大幅に削減し、クラスターの性能が向上する</li>
</ul>
<p>この機能は、<code>ImmutableEmphemeralVolumes</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>によって管理されます。<code>immutable</code>フィールドを<code>true</code>に設定することで、イミュータブルなConfigMapを作成できます。次に例を示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><p>一度ConfigMapがイミュータブルに設定されると、この変更を元に戻したり、<code>data</code>または<code>binaryData</code>フィールドのコンテンツを変更することは<em>できません</em>。ConfigMapの削除と再作成のみ可能です。既存のPodは削除されたConfigMapのマウントポイントを保持するため、こうしたPodは再作成することをおすすめします。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/concepts/configuration/secret/>Secret</a>について読む。</li>
<li><a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>Podを構成してConfigMapを使用する</a>を読む。</li>
<li>コードを設定から分離する動機を理解するために<a href=https://12factor.net/ja/>The Twelve-Factor App</a>を読む。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e511ed821ada65d0053341dbd8ad2bb5>3.7.3 - Secret</h1>
<p>KubernetesのSecretはパスワード、OAuthトークン、SSHキーのような機密情報を保存し、管理できるようにします。
Secretに機密情報を保存することは、それらを<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>の定義や<a class=glossary-tooltip title=アプリケーションの実行に必要なソフトウェアのセットを持つ、保存されたコンテナの実体です。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-image" target=_blank aria-label=コンテナイメージ>コンテナイメージ</a>に直接記載するより、安全で柔軟です。
詳しくは<a href=https://git.k8s.io/community/contributors/design-proposals/auth/secrets.md>Secretの設計文書</a>を参照してください。</p>
<p>Secretはパスワード、トークン、キーのような小容量の機密データを含むオブジェクトです。
他の方法としては、そのような情報はPodの定義やイメージに含めることができます。
ユーザーはSecretを作ることができ、またシステムが作るSecretもあります。</p>
<h2 id=secretの概要>Secretの概要</h2>
<p>Secretを使うには、PodはSecretを参照することが必要です。
PodがSecretを使う方法は3種類あります。</p>
<ul>
<li><a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>内の<a href=#using-secrets-as-files-from-a-pod>ファイル</a>として、Podの単一または複数のコンテナにマウントする</li>
<li><a href=#using-secrets-as-environment-variables>コンテナの環境変数</a>として利用する</li>
<li>Podを生成するために<a href=#using-imagepullsecrets>kubeletがイメージをpullする</a>ときに使用する</li>
</ul>
<p>Secretオブジェクトの名称は正当な<a href=/ja/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。
シークレットの構成ファイルを作成するときに、<code>data</code>および/または<code>stringData</code>フィールドを指定できます。<code>data</code>フィールドと<code>stringData</code>フィールドはオプションです。
<code>data</code>フィールドのすべてのキーの値は、base64でエンコードされた文字列である必要があります。
base64文字列への変換が望ましくない場合は、代わりに<code>stringData</code>フィールドを指定することを選択できます。これは任意の文字列を値として受け入れます。</p>
<p><code>data</code>と<code>stringData</code>のキーは、英数字、<code>-</code>、<code>_</code>、または<code>.</code>で構成されている必要があります。
<code>stringData</code>フィールドのすべてのキーと値のペアは、内部で<code>data</code>フィールドにマージされます。
キーが<code>data</code>フィールドと<code>stringData</code>フィールドの両方に表示される場合、<code>stringData</code>フィールドで指定された値が優先されます。</p>
<h2 id=secret-types>Secretの種類</h2>
<p>Secretを作成するときは、<a href=/docs/reference/generated/kubernetes-api/v1.22/#secret-v1-core><code>Secret</code></a>の<code>type</code>フィールド、または特定の同等の<code>kubectl</code>コマンドラインフラグ（使用可能な場合）を使用して、その型を指定できます。
Secret型は、Secret dataのプログラムによる処理を容易にするために使用されます。</p>
<p>Kubernetesは、いくつかの一般的な使用シナリオに対応するいくつかの組み込み型を提供します。
これらの型は、実行される検証とKubernetesが課す制約の点で異なります。</p>
<table>
<thead>
<tr>
<th>Builtin Type</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Opaque</code></td>
<td>arbitrary user-defined data</td>
</tr>
<tr>
<td><code>kubernetes.io/service-account-token</code></td>
<td>service account token</td>
</tr>
<tr>
<td><code>kubernetes.io/dockercfg</code></td>
<td>serialized <code>~/.dockercfg</code> file</td>
</tr>
<tr>
<td><code>kubernetes.io/dockerconfigjson</code></td>
<td>serialized <code>~/.docker/config.json</code> file</td>
</tr>
<tr>
<td><code>kubernetes.io/basic-auth</code></td>
<td>credentials for basic authentication</td>
</tr>
<tr>
<td><code>kubernetes.io/ssh-auth</code></td>
<td>credentials for SSH authentication</td>
</tr>
<tr>
<td><code>kubernetes.io/tls</code></td>
<td>data for a TLS client or server</td>
</tr>
<tr>
<td><code>bootstrap.kubernetes.io/token</code></td>
<td>bootstrap token data</td>
</tr>
</tbody>
</table>
<p>Secretオブジェクトの<code>type</code>値として空でない文字列を割り当てることにより、独自のSecret型を定義して使用できます。空の文字列は<code>Opaque</code>型として扱われます。Kubernetesは型名に制約を課しません。ただし、組み込み型の1つを使用している場合は、その型に定義されているすべての要件を満たす必要があります。</p>
<h3 id=opaque-secrets>Opaque secrets</h3>
<p><code>Opaque</code>は、Secret構成ファイルから省略された場合のデフォルトのSecret型です。
<code>kubectl</code>を使用してSecretを作成する場合、<code>generic</code>サブコマンドを使用して<code>Opaque</code>Secret型を示します。 たとえば、次のコマンドは、<code>Opaque</code>型の空のSecretを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic empty-secret
kubectl get secret empty-secret
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME           TYPE     DATA   AGE
empty-secret   Opaque   0      2m6s
</code></pre><p><code>DATA</code>列には、Secretに保存されているデータ項目の数が表示されます。
この場合、<code>0</code>は空のSecretを作成したことを意味します。</p>
<h3 id=service-account-token-secrets>Service account token Secrets</h3>
<p><code>kubernetes.io/service-account-token</code>型のSecretは、サービスアカウントを識別するトークンを格納するために使用されます。 このSecret型を使用する場合は、<code>kubernetes.io/service-account.name</code>アノテーションが既存のサービスアカウント名に設定されていることを確認する必要があります。Kubernetesコントローラーは、<code>kubernetes.io/service-account.uid</code>アノテーションや実際のトークンコンテンツに設定された<code>data</code>フィールドの<code>token</code>キーなど、他のいくつかのフィールドに入力します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-sa-sample<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-account.name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sa-name&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># You can include additional key value pairs as you do with Opaque Secrets</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb> </span>YmFyCg==<span style=color:#bbb>
</span></code></pre></div><p><code>Pod</code>を作成すると、Kubernetesはservice account Secretを自動的に作成し、このSecretを使用するようにPodを自動的に変更します。service account token Secretには、APIにアクセスするための資格情報が含まれています。</p>
<p>API証明の自動作成と使用は、必要に応じて無効にするか、上書きすることができます。 ただし、API Serverに安全にアクセスするだけの場合は、これが推奨されるワークフローです。</p>
<p>ServiceAccountの動作の詳細については、<a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>のドキュメントを参照してください。
PodからServiceAccountを参照する方法については、<a href=/docs/reference/generated/kubernetes-api/v1.22/#pod-v1-core><code>Pod</code></a>の<code>automountServiceAccountToken</code>フィールドと<code>serviceAccountName</code>フィールドを確認することもできます。</p>
<h3 id=docker-config-secrets>Docker config Secrets</h3>
<p>次の<code>type</code>値のいずれかを使用して、イメージのDockerレジストリにアクセスするための資格情報を格納するSecretを作成できます。</p>
<ul>
<li><code>kubernetes.io/dockercfg</code></li>
<li><code>kubernetes.io/dockerconfigjson</code></li>
</ul>
<p><code>kubernetes.io/dockercfg</code>型は、Dockerコマンドラインを構成するためのレガシー形式であるシリアル化された<code>~/.dockercfg</code>を保存するために予約されています。
このSecret型を使用する場合は、Secretの<code>data</code>フィールドに<code>.dockercfg</code>キーが含まれていることを確認する必要があります。このキーの値は、base64形式でエンコードされた<code>~/.dockercfg</code>ファイルの内容です。</p>
<p><code>kubernetes.io/dockerconfigjson</code>型は、<code>~/.dockercfg</code>の新しいフォーマットである<code>~/.docker/config.json</code>ファイルと同じフォーマットルールに従うシリアル化されたJSONを保存するために設計されています。
このSecret型を使用する場合、Secretオブジェクトの<code>data</code>フィールドには<code>.dockerconfigjson</code>キーが含まれている必要があります。このキーでは、<code>~/.docker/config.json</code>ファイルのコンテンツがbase64でエンコードされた文字列として提供されます。</p>
<p>以下は、<code>kubernetes.io/dockercfg</code>型のSecretの例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dockercfg<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockercfg<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockercfg</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span><span style=color:#b44>&#34;&lt;base64 encoded ~/.dockercfg file&gt;&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> base64エンコーディングを実行したくない場合は、代わりに<code>stringData</code>フィールドを使用することを選択できます。
</div>
<p>マニフェストを使用してこれらの型のSecretを作成すると、APIserverは期待されるキーが<code>data</code>フィールドに存在するかどうかを確認し、提供された値を有効なJSONとして解析できるかどうかを確認します。APIサーバーは、JSONが実際にDocker configファイルであるかどうかを検証しません。</p>
<p>Docker configファイルがない場合、または<code>kubectl</code>を使用してDockerレジストリSecretを作成する場合は、次の操作を実行できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret docker-registry secret-tiger-docker <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-username<span style=color:#666>=</span>tiger <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-password<span style=color:#666>=</span>pass113 <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --docker-email<span style=color:#666>=</span>tiger@acme.com
</code></pre></div><p>このコマンドは、<code>kubernetes.io/dockerconfigjson</code>型のSecretを作成します。
<code>data</code>フィールドから<code>.dockerconfigjson</code>コンテンツをダンプすると、その場で作成された有効なDocker configである次のJSONコンテンツを取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;https://index.docker.io/v1/&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;tiger&#34;</span>,
      <span style=color:green;font-weight:700>&#34;password&#34;</span>: <span style=color:#b44>&#34;pass113&#34;</span>,
      <span style=color:green;font-weight:700>&#34;email&#34;</span>: <span style=color:#b44>&#34;tiger@acme.com&#34;</span>,
      <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;dGlnZXI6cGFzczExMw==&#34;</span>
    }
  }
}
</code></pre></div><h3 id=basic-authentication-secret>Basic authentication Secret</h3>
<p><code>kubernetes.io/basic-auth</code>型は、Basic認証に必要な認証を保存するために提供されています。このSecret型を使用する場合、Secretの<code>data</code>フィールドには次の2つのキーが含まれている必要があります。</p>
<ul>
<li><code>username</code>: 認証のためのユーザー名</li>
<li><code>password</code>: 認証のためのパスワードかトークン</li>
</ul>
<p>上記の2つのキーの両方の値は、base64でエンコードされた文字列です。もちろん、Secretの作成に<code>stringData</code>を使用してクリアテキストコンテンツを提供することもできます。</p>
<p>次のYAMLは、Basic authentication Secretの設定例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-basic-auth<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/basic-auth<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>admin<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>t0p-Secret<span style=color:#bbb>
</span></code></pre></div><p>Basic認証Secret型は、ユーザーの便宜のためにのみ提供されています。Basic認証に使用される資格情報の<code>Opaque</code>を作成できます。
ただし、組み込みのSecret型を使用すると、認証の形式を統一するのに役立ち、APIserverは必要なキーがSecret configurationで提供されているかどうかを確認します。</p>
<h3 id=ssh-authentication-secrets>SSH authentication secrets</h3>
<p>組み込みのタイプ<code>kubernetes.io/ssh-auth</code>は、SSH認証で使用されるデータを保存するために提供されています。このSecret型を使用する場合、使用するSSH認証として<code>data</code>（または<code>stringData</code>）フィールドに<code>ssh-privatekey</code>キーと値のペアを指定する必要があります。</p>
<p>次のYAMLはSSH authentication Secretの設定例です：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-ssh-auth<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/ssh-auth<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># the data is abbreviated in this example</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ssh-privatekey</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>     </span><span style=color:#bbb>     </span>MIIEpQIBAAKCAQEAulqb/Y ...<span style=color:#bbb>
</span></code></pre></div><p>SSH authentication Secret型は、ユーザーの便宜のためにのみ提供されています。
SSH認証に使用される資格情報の<code>Opaque</code>を作成できます。
ただし、組み込みのSecret型を使用すると、認証の形式を統一するのに役立ち、APIserverは必要なキーがSecret configurationで提供されているかどうかを確認します。</p>
<h3 id=tls-secrets>TLS secrets</h3>
<p>Kubernetesは、TLSに通常使用される証明書とそれに関連付けられたキーを保存するための組み込みのSecret型<code>kubernetes.io/tls</code>を提供します。このデータは、主にIngressリソースのTLS terminationで使用されますが、他のリソースで使用されることも、ワークロードによって直接使用されることもあります。
このSecret型を使用する場合、APIサーバーは各キーの値を実際には検証しませんが、<code>tls.key</code>および<code>tls.crt</code>キーをSecret configurationの<code>data</code>（または<code>stringData</code>）フィールドに指定する必要があります。</p>
<p>次のYAMLはTLS Secretの設定例です：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-tls<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># the data is abbreviated in this example</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIC2DCCAcCgAwIBAgIBATANBgkqh ...<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...<span style=color:#bbb>
</span></code></pre></div><p>TLS Secret型は、ユーザーの便宜のために提供されています。 TLSサーバーやクライアントに使用される資格情報の<code>Opaque</code>を作成できます。ただし、組み込みのSecret型を使用すると、プロジェクトでSecret形式の一貫性を確保できます。APIserverは、必要なキーがSecret configurationで提供されているかどうかを確認します。</p>
<p><code>kubectl</code>を使用してTLS Secretを作成する場合、次の例に示すように<code>tls</code>サブコマンドを使用できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret tls my-tls-secret <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --cert<span style=color:#666>=</span>path/to/cert/file <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --key<span style=color:#666>=</span>path/to/key/file
</code></pre></div><p>公開鍵と秘密鍵のペアは、事前に存在している必要があります。<code>--cert</code>の公開鍵証明書は.PEMエンコード（Base64エンコードDER形式）であり、<code>--key</code>の指定された秘密鍵と一致する必要があります。
秘密鍵は、一般にPEM秘密鍵形式と呼ばれる暗号化されていない形式である必要があります。どちらの場合も、PEMの最初と最後の行（たとえば、<code>-------- BEGIN CERTIFICATE -----</code>と<code>------- END CERTIFICATE ----</code>）は含まれて<em>いません</em>。</p>
<h3 id=bootstrap-token-secrets>Bootstrap token Secrets</h3>
<p>Bootstrap token Secretは、Secretの<code>type</code>を<code>bootstrap.kubernetes.io/token</code>に明示的に指定することで作成できます。このタイプのSecretは、ノードのブートストラッププロセス中に使用されるトークン用に設計されています。よく知られているConfigMapに署名するために使用されるトークンを格納します。</p>
<p>Bootstrap toke Secretは通常、<code>kube-system</code>namespaceで作成され<code>bootstrap-token-&lt;token-id></code>の形式で名前が付けられます。ここで<code>&lt;token-id></code>はトークンIDの6文字の文字列です。</p>
<p>Kubernetesマニフェストとして、Bootstrap token Secretは次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>c3lzdGVtOmJvb3RzdHJhcHBlcnM6a3ViZWFkbTpkZWZhdWx0LW5vZGUtdG9rZW4=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span>MjAyMC0wOS0xM1QwNDozOToxMFo=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>NWVtaXRq<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>a3E0Z2lodnN6emduMXAwcg==<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></code></pre></div><p>Bootstrap type Secretには、<code>data</code>で指定された次のキーがあります。</p>
<ul>
<li><code>token_id</code>：トークン識別子としてのランダムな6文字の文字列。必須。</li>
<li><code>token-secret</code>：実際のtoken secretとしてのランダムな16文字の文字列。必須。</li>
<li><code>description</code>：トークンの使用目的を説明する人間が読める文字列。オプション。</li>
<li><code>expiration</code>：トークンの有効期限を指定するRFC3339を使用した絶対UTC時間。オプション。</li>
<li><code>usage-bootstrap-&lt;usage></code>：Bootstrap tokenの追加の使用法を示すブールフラグ。</li>
<li><code>auth-extra-groups</code>：<code>system：bootstrappers</code>グループに加えて認証されるグループ名のコンマ区切りのリスト。</li>
</ul>
<p>上記のYAMLは、値がすべてbase64でエンコードされた文字列であるため、分かりづらく見えるかもしれません。実際には、次のYAMLを使用して同一のSecretを作成できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Note how the Secret is named</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># A bootstrap token Secret usually resides in the kube-system namespace</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;system:bootstrappers:kubeadm:default-node-token&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-09-13T04:39:10Z&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># This token ID is used in the name</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5emitj&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kq4gihvszzgn1p0r&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># This token can be used for authentication</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># and it can be used for signing</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=secretの作成>Secretの作成</h2>
<p>Secretを作成するには、いくつかのオプションがあります。</p>
<ul>
<li><a href=/docs/tasks/configmap-secret/managing-secret-using-kubectl/>create Secret using <code>kubectl</code> command</a></li>
<li><a href=/docs/tasks/configmap-secret/managing-secret-using-config-file/>create Secret from config file</a></li>
<li><a href=/docs/tasks/configmap-secret/managing-secret-using-kustomize/>create Secret using kustomize</a></li>
</ul>
<h2 id=secretの編集>Secretの編集</h2>
<p>既存のSecretは次のコマンドで編集することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit secrets mysecret
</code></pre></div><p>デフォルトに設定されたエディターが開かれ、<code>data</code>フィールドのBase64でエンコードされたSecretの値を編集することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># Please edit the object below. Lines beginning with a &#39;#&#39; will be ignored,</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># and an empty file will abort the edit. If an error occurs while saving this file will be</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># reopened with the relevant failures.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>{<span style=color:#bbb> </span>... }<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-01-22T18:41:56Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;164619&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>cfee02d6-c137-11e5-8d73-42010af00002<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></code></pre></div><h2 id=secretの使用>Secretの使用</h2>
<p>Podの中のコンテナがSecretを使うために、データボリュームとしてマウントしたり、<a class=glossary-tooltip title="Container environment variables are name=value pairs that provide useful information into containers running in a Pod." data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment/ target=_blank aria-label=環境変数>環境変数</a>として値を参照できるようにできます。
Secretは直接Podが参照できるようにはされず、システムの別の部分に使われることもあります。
例えば、Secretはあなたに代わってシステムの他の部分が外部のシステムとやりとりするために使う機密情報を保持することもあります。</p>
<h3 id=secretをファイルとしてpodから利用する>SecretをファイルとしてPodから利用する</h3>
<p>PodのボリュームとしてSecretを使うには、</p>
<ol>
<li>Secretを作成するか既存のものを使用します。複数のPodが同一のSecretを参照することができます。</li>
<li>ボリュームを追加するため、Podの定義の<code>.spec.volumes[]</code>以下を書き換えます。ボリュームに命名し、<code>.spec.volumes[].secret.secretName</code>フィールドはSecretオブジェクトの名称と同一にします。</li>
<li>Secretを必要とするそれぞれのコンテナに<code>.spec.containers[].volumeMounts[]</code>を追加します。<code>.spec.containers[].volumeMounts[].readOnly = true</code>を指定して<code>.spec.containers[].volumeMounts[].mountPath</code>をSecretをマウントする未使用のディレクトリ名にします。</li>
<li>イメージやコマンドラインを変更し、プログラムがそのディレクトリを参照するようにします。連想配列<code>data</code>のキーは<code>mountPath</code>以下のファイル名になります。</li>
</ol>
<p>これはSecretをボリュームとしてマウントするPodの例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></code></pre></div><p>使用したいSecretはそれぞれ<code>.spec.volumes</code>の中で参照されている必要があります。</p>
<p>Podに複数のコンテナがある場合、それぞれのコンテナが<code>volumeMounts</code>ブロックを必要としますが、<code>.spec.volumes</code>はSecret1つあたり1つで十分です。</p>
<p>多くのファイルを一つのSecretにまとめることも、多くのSecretを使うことも、便利な方を採ることができます。</p>
<h4 id=secretのキーの特定のパスへの割り当て>Secretのキーの特定のパスへの割り当て</h4>
<p>Secretのキーが割り当てられるパスを制御することができます。
それぞれのキーがターゲットとするパスは<code>.spec.volumes[].secret.items</code>フィールドによって指定できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></code></pre></div><p>次のような挙動をします。</p>
<ul>
<li><code>username</code>は<code>/etc/foo/username</code>の代わりに<code>/etc/foo/my-group/my-username</code>の元に格納されます。</li>
<li><code>password</code>は現れません。</li>
</ul>
<p><code>.spec.volumes[].secret.items</code>が使われるときは、<code>items</code>の中で指定されたキーのみが現れます。
Secretの中の全てのキーを使用したい場合は、<code>items</code>フィールドに全て列挙する必要があります。
列挙されたキーは対応するSecretに存在する必要があり、そうでなければボリュームは生成されません。</p>
<h4 id=secretファイルのパーミッション>Secretファイルのパーミッション</h4>
<p>単一のSecretキーに対して、ファイルアクセスパーミッションビットを指定することができます。
パーミッションを指定しない場合、デフォルトで<code>0644</code>が使われます。
Secretボリューム全体のデフォルトモードを指定し、必要に応じてキー単位で上書きすることもできます。</p>
<p>例えば、次のようにしてデフォルトモードを指定できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>0400</span><span style=color:#bbb>
</span></code></pre></div><p>Secretは<code>/etc/foo</code>にマウントされ、Secretボリュームが生成する全てのファイルはパーミッション<code>0400</code>に設定されます。</p>
<p>JSONの仕様は8進数の記述に対応していないため、パーミッション0400を示す値として256を使用することに注意が必要です。
Podの定義にJSONではなくYAMLを使う場合は、パーミッションを指定するためにより自然な8進表記を使うことができます。</p>
<p><code>kubectl exec</code>を使ってPodに入るときは、期待したファイルモードを知るためにシンボリックリンクを辿る必要があることに注意してください。</p>
<p>例として、PodのSecretのファイルモードを確認します。</p>
<pre><code>kubectl exec mypod -it sh

cd /etc/foo
ls -l
</code></pre><p>出力は次のようになります。</p>
<pre><code>total 0
lrwxrwxrwx 1 root root 15 May 18 00:18 password -&gt; ..data/password
lrwxrwxrwx 1 root root 15 May 18 00:18 username -&gt; ..data/username
</code></pre><p>正しいファイルモードを知るためにシンボリックリンクを辿ります。</p>
<pre><code>cd /etc/foo/..data
ls -l
</code></pre><p>出力は次のようになります。</p>
<pre><code>total 8
-r-------- 1 root root 12 May 18 00:18 password
-r-------- 1 root root  5 May 18 00:18 username
</code></pre><p>前の例のようにマッピングを使い、ファイルごとに異なるパーミッションを指定することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>0777</span><span style=color:#bbb>
</span></code></pre></div><p>この例では、ファイル<code>/etc/foo/my-group/my-username</code>のパーミッションは<code>0777</code>になります。
JSONを使う場合は、JSONの制約により10進表記の<code>511</code>と記述する必要があります。</p>
<p>後で参照する場合、このパーミッションの値は10進表記で表示されることがあることに注意してください。</p>
<h4 id=secretの値のボリュームによる利用>Secretの値のボリュームによる利用</h4>
<p>Secretのボリュームがマウントされたコンテナからは、Secretのキーはファイル名として、Secretの値はBase64デコードされ、それらのファイルに格納されます。
上記の例のコンテナの中でコマンドを実行した結果を示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls /etc/foo/
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>username
password
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /etc/foo/username
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /etc/foo/password
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>1f2d1e2e67df
</code></pre><p>コンテナ内のプログラムはファイルからSecretの内容を読み取る責務を持ちます。</p>
<h4 id=マウントされたsecretの自動更新>マウントされたSecretの自動更新</h4>
<p>ボリュームとして使用されているSecretが更新されると、やがて割り当てられたキーも同様に更新されます。
kubeletは定期的な同期のたびにマウントされたSecretが新しいかどうかを確認します。
しかしながら、kubeletはSecretの現在の値の取得にローカルキャッシュを使用します。
このキャッシュは<a href=https://github.com/kubernetes/kubernetes/blob/release-1.22/staging/src/k8s.io/kubelet/config/v1beta1/types.go>KubeletConfiguration struct</a>内の<code>ConfigMapAndSecretChangeDetectionStrategy</code>フィールドによって設定可能です。
Secretはwatch（デフォルト）、TTLベース、単に全てのリクエストをAPIサーバーへリダイレクトすることのいずれかによって伝搬します。
結果として、Secretが更新された時点からPodに新しいキーが反映されるまでの遅延時間の合計は、kubeletの同期間隔 + キャッシュの伝搬遅延となります。
キャッシュの遅延は、キャッシュの種別により、それぞれwatchの伝搬遅延、キャッシュのTTL、0になります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Secretを<a href=/docs/concepts/storage/volumes#using-subpath>subPath</a>を指定してボリュームにマウントしているコンテナには、Secretの更新が反映されません。
</div>
<h3 id=using-secrets-as-environment-variables>Secretを環境変数として使用する</h3>
<p>SecretをPodの<a class=glossary-tooltip title="Container environment variables are name=value pairs that provide useful information into containers running in a Pod." data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment/ target=_blank aria-label=環境変数>環境変数</a>として使用するには、</p>
<ol>
<li>Secretを作成するか既存のものを使います。複数のPodが同一のSecretを参照することができます。</li>
<li>Podの定義を変更し、Secretを使用したいコンテナごとにSecretのキーと割り当てたい環境変数を指定します。Secretキーを利用する環境変数は<code>env[].valueFrom.secretKeyRef</code>にSecretの名前とキーを指定すべきです。</li>
<li>イメージまたはコマンドライン（もしくはその両方）を変更し、プログラムが指定した環境変数を参照するようにします。</li>
</ol>
<p>Secretを環境変数で参照するPodの例を示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-env-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mycontainer<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div><h4 id=環境変数からのsecretの値の利用>環境変数からのSecretの値の利用</h4>
<p>Secretを環境変数として利用するコンテナの内部では、Secretのキーは一般の環境変数名として現れ、値はBase64デコードされた状態で保持されます。</p>
<p>上記の例のコンテナの内部でコマンドを実行した結果の例を示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_USERNAME</span>
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_PASSWORD</span>
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>1f2d1e2e67df
</code></pre><h2 id=secret-immutable>Immutable Secrets</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code>
</div>
<p>Kubernetesベータ機能<em>ImmutableSecrets and ConfigMaps</em>は、個々のSecretsとConfigMapsをimutableとして設定するオプションを提供します。Secret（少なくとも数万の、SecretからPodへの一意のマウント）を広範囲に使用するクラスターの場合、データの変更を防ぐことには次の利点があります。</p>
<ul>
<li>アプリケーションの停止を引き起こす可能性のある偶発的な（または不要な）更新からユーザーを保護します</li>
<li>imutableとしてマークされたSecretのウォッチを閉じることで、kube-apiserverの負荷を大幅に削減することができ、クラスターのパフォーマンスを向上させます。</li>
</ul>
<p>この機能は、<code>ImmutableEphemeralVolumes</code><a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>によって制御されます。これは、v1.19以降デフォルトで有効になっています。<code>immutable</code>フィールドを<code>true</code>に設定することで、imutableのSecretを作成できます。例えば、</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> SecretまたはConfigMapがimutableとしてマークされると、この変更を元に戻したり、<code>data</code>フィールドの内容を変更したりすることは<em>できません</em>。Secretを削除して再作成することしかできません。
既存のPodは、削除されたSecretへのマウントポイントを維持します。これらのPodを再作成することをお勧めします。
</div>
<h3 id=using-imagepullsecrets>imagePullSecretsを使用する</h3>
<p><code>imagePullSecrets</code>フィールドは同一のネームスペース内のSecretの参照のリストです。
kubeletにDockerやその他のイメージレジストリのパスワードを渡すために、<code>imagePullSecrets</code>にそれを含むSecretを指定することができます。
kubeletはこの情報をPodのためにプライベートイメージをpullするために使います。
<code>imagePullSecrets</code>の詳細は<a href=/docs/reference/generated/kubernetes-api/v1.26/#podspec-v1-core>PodSpec API</a>を参照してください。</p>
<h4 id=imagepullsecretを手動で指定する>imagePullSecretを手動で指定する</h4>
<p><code>ImagePullSecrets</code>の指定の方法は<a href=/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>コンテナイメージのドキュメント</a>に記載されています。</p>
<h3 id=imagepullsecretsが自動的にアタッチされるようにする>imagePullSecretsが自動的にアタッチされるようにする</h3>
<p><code>imagePullSecrets</code>を手動で作成し、サービスアカウントから参照することができます。
サービスアカウントが指定されるまたはデフォルトでサービスアカウントが設定されたPodは、サービスアカウントが持つ<code>imagePullSecrets</code>フィールドを得ます。
詳細な手順の説明は<a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>サービスアカウントへのImagePullSecretsの追加</a>を参照してください。</p>
<h3 id=手動で作成されたsecretの自動的なマウント>手動で作成されたSecretの自動的なマウント</h3>
<p>手動で作成されたSecret（例えばGitHubアカウントへのアクセスに使うトークンを含む）はサービスアカウントを基に自動的にアタッチすることができます。
詳細な説明は<a href=/docs/tasks/inject-data-application/podpreset/>PodPresetを使ったPodへの情報の注入</a>を参照してください。</p>
<h2 id=詳細>詳細</h2>
<h3 id=制限事項>制限事項</h3>
<p>Secretボリュームは指定されたオブジェクト参照が実際に存在するSecretオブジェクトを指していることを保証するため検証されます。
そのため、Secretはそれを必要とするPodよりも先に作成する必要があります。</p>
<p>Secretリソースは<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>に属します。
Secretは同一のnamespaceに属するPodからのみ参照することができます。</p>
<p>各Secretは1MiBの容量制限があります。
これはAPIサーバーやkubeletのメモリーを枯渇するような非常に大きなSecretを作成することを避けるためです。
しかしながら、小さなSecretを多数作成することも同様にメモリーを枯渇させます。
Secretに起因するメモリー使用量をより網羅的に制限することは、将来計画されています。</p>
<p>kubeletがPodに対してSecretを使用するとき、APIサーバーから取得されたSecretのみをサポートします。
これには<code>kubectl</code>を利用して、またはレプリケーションコントローラーによって間接的に作成されたPodが含まれます。
kubeletの<code>--manifest-url</code>フラグ、<code>--config</code>フラグ、またはREST APIにより生成されたPodは含まれません
（これらはPodを生成するための一般的な方法ではありません）。</p>
<p>環境変数として使われるSecretは任意と指定されていない限り、それを使用するPodよりも先に作成される必要があります。
存在しないSecretへの参照はPodの起動を妨げます。</p>
<p>Secretに存在しないキーへの参照（<code>secretKeyRef</code>フィールド）はPodの起動を妨げます。</p>
<p>Secretを<code>envFrom</code>フィールドによって環境変数へ設定する場合、環境変数の名称として不適切なキーは飛ばされます。
Podは起動することを認められます。
このとき、reasonが<code>InvalidVariableNames</code>であるイベントが発生し、メッセージに飛ばされたキーのリストが含まれます。
この例では、Podは2つの不適切なキー<code>1badkey</code>と<code>2alsobad</code>を含むdefault/mysecretを参照しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentVariableNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variable names.
</code></pre><h3 id=secretとpodの相互作用>SecretとPodの相互作用</h3>
<p>Kubernetes APIがコールされてPodが生成されるとき、参照するSecretの存在は確認されません。
Podがスケジューリングされると、kubeletはSecretの値を取得しようとします。
Secretが存在しない、または一時的にAPIサーバーへの接続が途絶えたことにより取得できない場合、kubeletは定期的にリトライします。
kubeletはPodがまだ起動できない理由に関するイベントを報告します。
Secretが取得されると、kubeletはそのボリュームを作成しマウントします。
Podのボリュームが全てマウントされるまでは、Podのコンテナは起動することはありません。</p>
<h2 id=ユースケース>ユースケース</h2>
<h3 id=ユースケース-コンテナの環境変数として>ユースケース: コンテナの環境変数として</h3>
<p>Secretの作成</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>USER_NAME</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>PASSWORD</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f mysecret.yaml
</code></pre></div><p><code>envFrom</code>を使ってSecretの全てのデータをコンテナの環境変数として定義します。
SecretのキーはPod内の環境変数の名称になります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div><h3 id=ユースケース-ssh鍵を持つpod>ユースケース: SSH鍵を持つPod</h3>
<p>SSH鍵を含むSecretを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic ssh-key-secret --from-file<span style=color:#666>=</span>ssh-privatekey<span style=color:#666>=</span>/path/to/.ssh/id_rsa --from-file<span style=color:#666>=</span>ssh-publickey<span style=color:#666>=</span>/path/to/.ssh/id_rsa.pub
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>secret &quot;ssh-key-secret&quot; created
</code></pre><p>SSH鍵を含む<code>secretGenerator</code>フィールドを持つ<code>kustomization.yaml</code>を作成することもできます。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> 自身のSSH鍵を送る前に慎重に検討してください。クラスターの他のユーザーがSecretにアクセスできる可能性があります。
Kubernetesクラスターを共有しているユーザー全員がアクセスできるようにサービスアカウントを使用し、ユーザーが安全でない状態になったらアカウントを無効化することができます。
</div>
<p>SSH鍵のSecretを参照し、ボリュームとして使用するPodを作成することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>ssh-key-secret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ssh-test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mySshImage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>コンテナのコマンドを実行するときは、下記のパスにて鍵が利用可能です。</p>
<pre><code>/etc/secret-volume/ssh-publickey
/etc/secret-volume/ssh-privatekey
</code></pre><p>コンテナーはSecretのデータをSSH接続を確立するために使用することができます。</p>
<h3 id=ユースケース-本番-テスト用の認証情報を持つpod>ユースケース: 本番、テスト用の認証情報を持つPod</h3>
<p>あるPodは本番の認証情報のSecretを使用し、別のPodはテスト環境の認証情報のSecretを使用する例を示します。</p>
<p><code>secretGenerator</code>フィールドを持つ<code>kustomization.yaml</code>を作成するか、<code>kubectl create secret</code>を実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic prod-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>produser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>Y4nys7f11
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>secret &quot;prod-db-secret&quot; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic test-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>testuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>iluvtests
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>secret &quot;test-db-secret&quot; created
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p><code>$</code>、<code>\</code>、<code>*</code>、<code>=</code>、<code>!</code>のような特殊文字は<a href=https://ja.wikipedia.org/wiki/%E3%82%B7%E3%82%A7%E3%83%AB>シェル</a>に解釈されるので、エスケープする必要があります。
ほとんどのシェルではパスワードをエスケープする最も簡単な方法はシングルクォート(<code>'</code>)で囲むことです。
例えば、実際のパスワードが<code>S!B\*d$zDsb=</code>だとすると、実行すべきコマンドは下記のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic dev-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;S!B\*d$zDsb=&#39;</span>
</code></pre></div><p><code>--from-file</code>によってファイルを指定する場合は、そのパスワードに含まれる特殊文字をエスケープする必要はありません。</p>
</div>
<p>Podを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: List
</span><span style=color:#b44>items:
</span><span style=color:#b44>- kind: Pod
</span><span style=color:#b44>  apiVersion: v1
</span><span style=color:#b44>  metadata:
</span><span style=color:#b44>    name: prod-db-client-pod
</span><span style=color:#b44>    labels:
</span><span style=color:#b44>      name: prod-db-client
</span><span style=color:#b44>  spec:
</span><span style=color:#b44>    volumes:
</span><span style=color:#b44>    - name: secret-volume
</span><span style=color:#b44>      secret:
</span><span style=color:#b44>        secretName: prod-db-secret
</span><span style=color:#b44>    containers:
</span><span style=color:#b44>    - name: db-client-container
</span><span style=color:#b44>      image: myClientImage
</span><span style=color:#b44>      volumeMounts:
</span><span style=color:#b44>      - name: secret-volume
</span><span style=color:#b44>        readOnly: true
</span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span><span style=color:#b44>- kind: Pod
</span><span style=color:#b44>  apiVersion: v1
</span><span style=color:#b44>  metadata:
</span><span style=color:#b44>    name: test-db-client-pod
</span><span style=color:#b44>    labels:
</span><span style=color:#b44>      name: test-db-client
</span><span style=color:#b44>  spec:
</span><span style=color:#b44>    volumes:
</span><span style=color:#b44>    - name: secret-volume
</span><span style=color:#b44>      secret:
</span><span style=color:#b44>        secretName: test-db-secret
</span><span style=color:#b44>    containers:
</span><span style=color:#b44>    - name: db-client-container
</span><span style=color:#b44>      image: myClientImage
</span><span style=color:#b44>      volumeMounts:
</span><span style=color:#b44>      - name: secret-volume
</span><span style=color:#b44>        readOnly: true
</span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>同じkustomization.yamlにPodを追記します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- pod.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>下記のコマンドを実行して、APIサーバーにこれらのオブジェクト群を適用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
</code></pre></div><p>両方のコンテナはそれぞれのファイルシステムに下記に示すファイルを持ちます。ファイルの値はそれぞれのコンテナの環境ごとに異なります。</p>
<pre><code>/etc/secret-volume/username
/etc/secret-volume/password
</code></pre><p>2つのPodの仕様の差分は1つのフィールドのみである点に留意してください。
これは共通のPodテンプレートから異なる能力を持つPodを作成することを容易にします。</p>
<p>2つのサービスアカウントを使用すると、ベースのPod仕様をさらに単純にすることができます。</p>
<ol>
<li><code>prod-user</code>と<code>prod-db-secret</code></li>
<li><code>test-user</code>と<code>test-db-secret</code></li>
</ol>
<p>簡略化されたPod仕様は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client-pod<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-client-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myClientImage<span style=color:#bbb>
</span></code></pre></div><h3 id=ユースケース-secretボリューム内のdotfile>ユースケース: Secretボリューム内のdotfile</h3>
<p>キーをドットから始めることで、データを「隠す」ことができます。
このキーはdotfileまたは「隠し」ファイルを示します。例えば、次のSecretは<code>secret-volume</code>ボリュームにマウントされます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.secret-file</span>:<span style=color:#bbb> </span>dmFsdWUtMg0KDQo=<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dotfiles-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-test-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ls<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-l&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>このボリュームは<code>.secret-file</code>という単一のファイルを含み、<code>dotfile-test-container</code>はこのファイルを<code>/etc/secret-volume/.secret-file</code>のパスに持ちます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ドットから始まるファイルは<code>ls -l</code>の出力では隠されるため、ディレクトリの内容を参照するときには<code>ls -la</code>を使わなければなりません。
</div>
<h3 id=ユースケース-podの中の単一コンテナのみが参照できるsecret>ユースケース: Podの中の単一コンテナのみが参照できるSecret</h3>
<p>HTTPリクエストを扱い、複雑なビジネスロジックを処理し、メッセージにHMACによる認証コードを付与する必要のあるプログラムを考えます。
複雑なアプリケーションロジックを持つため、サーバーにリモートのファイルを読み出せる未知の脆弱性がある可能性があり、この脆弱性は攻撃者に秘密鍵を晒してしまいます。</p>
<p>このプログラムは2つのコンテナに含まれる2つのプロセスへと分割することができます。
フロントエンドのコンテナはユーザーとのやりとりやビジネスロジックを扱い、秘密鍵を参照することはできません。
署名コンテナは秘密鍵を参照することができて、単にフロントエンドからの署名リクエストに応答します。例えば、localhostの通信によって行います。</p>
<p>この分割する手法によって、攻撃者はアプリケーションサーバーを騙して任意の処理を実行させる必要があるため、ファイルの内容を読み出すより困難になります。</p>
<h2 id=ベストプラクティス>ベストプラクティス</h2>
<h3 id=secret-apiを使用するクライアント>Secret APIを使用するクライアント</h3>
<p>Secret APIとやりとりするアプリケーションをデプロイするときには、<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>のような<a href=/docs/reference/access-authn-authz/authorization/>認可ポリシー</a>を使用して、アクセスを制限すべきです。
Secretは様々な種類の重要な値を保持することが多く、サービスアカウントのトークンのようにKubernetes内部や、外部のシステムで昇格できるものも多くあります。個々のアプリケーションが、Secretの能力について推論することができたとしても、同じネームスペースの別のアプリケーションがその推定を覆すこともあります。</p>
<p>これらの理由により、ネームスペース内のSecretに対する<code>watch</code>や<code>list</code>リクエストはかなり強力な能力であり、避けるべきです。Secretのリストを取得することはクライアントにネームスペース内の全てのSecretの値を調べさせることを認めるからです。クラスター内の全てのSecretに対する<code>watch</code>、<code>list</code>権限は最も特権的な、システムレベルのコンポーネントに限って認めるべきです。</p>
<p>Secret APIへのアクセスが必要なアプリケーションは、必要なSecretに対する<code>get</code>リクエストを発行すべきです。管理者は全てのSecretに対するアクセスは制限しつつ、アプリケーションが必要とする<a href=/docs/reference/access-authn-authz/rbac/#referring-to-resources>個々のインスタンスに対するアクセス許可</a>を与えることができます。</p>
<p><code>get</code>リクエストの繰り返しに対するパフォーマンスを向上するために、クライアントはSecretを参照するリソースを設計し、それを<code>watch</code>して、参照が変更されたときにSecretを再度リクエストすることができます。加えて、個々のリソースを<code>watch</code>することのできる<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/bulk_watch.md>"bulk watch" API</a>が提案されており、将来のKubernetesリリースにて利用可能になる可能性があります。</p>
<h2 id=セキュリティ特性>セキュリティ特性</h2>
<h3 id=保護>保護</h3>
<p>Secretはそれを使用するPodとは独立に作成されるので、Podを作ったり、参照したり、編集したりするワークフローにおいてSecretが晒されるリスクは軽減されています。
システムは、可能であればSecretの内容をディスクに書き込まないような、Secretについて追加の考慮も行っています。</p>
<p>Secretはノード上のPodが必要とした場合のみ送られます。
kubeletはSecretがディスクストレージに書き込まれないよう、<code>tmpfs</code>に保存します。
Secretを必要とするPodが削除されると、kubeletはSecretのローカルコピーも同様に削除します。</p>
<p>同一のノードにいくつかのPodに対する複数のSecretが存在することもあります。
しかし、コンテナから参照できるのはPodが要求したSecretのみです。
そのため、あるPodが他のPodのためのSecretにアクセスすることはできません。</p>
<p>Podに複数のコンテナが含まれることもあります。しかし、Podの各コンテナはコンテナ内からSecretを参照するために<code>volumeMounts</code>によってSecretボリュームを要求する必要があります。
これは<a href=#use-case-secret-visible-to-one-container-in-a-pod>Podレベルでのセキュリティ分離</a>を実装するのに便利です。</p>
<p>ほとんどのKubernetesディストリビューションにおいては、ユーザーとAPIサーバー間やAPIサーバーからkubelet間の通信はSSL/TLSで保護されています。
そのような経路で伝送される場合、Secretは保護されています。</p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.13 [beta]</code>
</div>
<p><a href=/docs/tasks/administer-cluster/encrypt-data/>保存データの暗号化</a>を有効にして、Secretが<a class=glossary-tooltip title=一貫性、高可用性を持ったキーバリューストアで、Kubernetesの全てのクラスター情報の保存場所として利用されています。 data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>に平文で保存されないようにすることができます。</p>
<h3 id=リスク>リスク</h3>
<ul>
<li>APIサーバーでは、機密情報は<a class=glossary-tooltip title=一貫性、高可用性を持ったキーバリューストアで、Kubernetesの全てのクラスター情報の保存場所として利用されています。 data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>に保存されます。
そのため、
<ul>
<li>管理者はクラスターデータの保存データの暗号化を有効にすべきです（v1.13以降が必要）。</li>
<li>管理者はetcdへのアクセスを管理ユーザに限定すべきです。</li>
<li>管理者はetcdで使用していたディスクを使用しなくなったときにはそれをワイプするか完全消去したくなるでしょう。</li>
<li>クラスターの中でetcdが動いている場合、管理者はetcdのピアツーピア通信がSSL/TLSを利用していることを確認すべきです。</li>
</ul>
</li>
<li>Secretをマニフェストファイル（JSONまたはYAML）を介して設定する場合、それはBase64エンコードされた機密情報を含んでいるので、ファイルを共有したりソースリポジトリに入れることは秘密が侵害されることを意味します。Base64エンコーディングは暗号化手段では <em>なく</em> 、平文と同様であると判断すべきです。</li>
<li>アプリケーションはボリュームからSecretの値を読み取った後も、その値を保護する必要があります。例えば意図せずログに出力する、信用できない相手に送信するようなことがないようにです。</li>
<li>Secretを利用するPodを作成できるユーザーはSecretの値を見ることができます。たとえAPIサーバーのポリシーがユーザーにSecretの読み取りを許可していなくても、ユーザーはSecretを晒すPodを実行することができます。</li>
<li>現在、任意のノードでルート権限を持つ人は誰でも、kubeletに偽装することで <em>任意の</em> SecretをAPIサーバーから読み取ることができます。
単一のノードのルート権限を不正に取得された場合の影響を抑えるため、実際に必要としているノードに対してのみSecretを送る機能が計画されています。</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/configmap-secret/managing-secret-using-kubectl/><code>kubectl</code>を使用してSecretを管理する</a>方法を学ぶ</li>
<li><a href=/docs/tasks/configmap-secret/managing-secret-using-config-file/>config fileを使用してSecretを管理する</a>方法を学ぶ</li>
<li><a href=/docs/tasks/configmap-secret/managing-secret-using-kustomize/>kustomizeを使用してSecretを管理する</a>方法を学ぶ</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-436057b96151ecb8a4a9a9f456b5d0fc>3.7.4 - コンテナのリソース管理</h1>
<p><a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>を指定する際に、<a class=glossary-tooltip title=軽量でポータブルなソフトウェアとそのすべての依存関係が含まれている実行可能なイメージです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=コンテナ>コンテナ</a>が必要とする各リソースの量をオプションで指定することができます。
指定する最も一般的なリソースはCPUとメモリ(RAM)ですが、他にもあります。</p>
<p>Pod内のコンテナのリソース<em>要求</em>を指定すると、スケジューラはこの情報を使用して、どのNodeにPodを配置するかを決定します。コンテナに<em>制限</em>ソースを指定すると、kubeletはその制限を適用し、実行中のコンテナが設定した制限を超えてリソースを使用することができないようにします。また、kubeletは、少なくともそのシステムリソースのうち、<em>要求</em>の量を、そのコンテナが使用するために特別に確保します。</p>
<h2 id=要求と制限>要求と制限</h2>
<p>Podが動作しているNodeに利用可能なリソースが十分にある場合、そのリソースの<code>要求</code>が指定するよりも多くのリソースをコンテナが使用することが許可されます
ただし、コンテナはそのリソースの<code>制限</code>を超えて使用することはできません。</p>
<p>たとえば、コンテナに256MiBの<code>メモリー</code>要求を設定し、そのコンテナが8GiBのメモリーを持つNodeにスケジュールされたPod内に存在し、他のPodが存在しない場合、コンテナはより多くのRAMを使用しようとする可能性があります。</p>
<p>そのコンテナに4GiBの<code>メモリー</code>制限を設定すると、kubelet(および<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>) が制限を適用します。ランタイムは、コンテナーが設定済みのリソース制限を超えて使用するのを防ぎます。例えば、コンテナ内のプロセスが、許容量を超えるメモリを消費しようとすると、システムカーネルは、メモリ不足(OOM)エラーで、割り当てを試みたプロセスを終了します。</p>
<p>制限は、違反が検出されるとシステムが介入するように事後的に、またはコンテナーが制限を超えないようにシステムが防ぐように強制的に、実装できます。
異なるランタイムは、同じ制限を実装するために異なる方法をとることができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> コンテナが自身のメモリー制限を指定しているが、メモリー要求を指定していない場合、Kubernetesは制限に一致するメモリー要求を自動的に割り当てます。同様に、コンテナが自身のCPU制限を指定しているが、CPU要求を指定していない場合、Kubernetesは制限に一致するCPU要求を自動的に割り当てます。
</div>
<h2 id=リソースタイプ>リソースタイプ</h2>
<p><em>CPU</em>と<em>メモリー</em>はいずれも<em>リソースタイプ</em>です。リソースタイプには基本単位があります。
CPUは計算処理を表し、<a href=#meaning-of-cpu>Kubernetes CPUs</a>の単位で指定されます。
メモリはバイト単位で指定されます。
Kubernetes v1.14以降を使用している場合は、<em>huge page</em>リソースを指定することができます。
Huge PageはLinux固有の機能であり、Nodeのカーネルはデフォルトのページサイズよりもはるかに大きいメモリブロックを割り当てます。</p>
<p>たとえば、デフォルトのページサイズが4KiBのシステムでは、<code>hugepages-2Mi: 80Mi</code>という制限を指定できます。
コンテナが40を超える2MiBの巨大ページ(合計80 MiB)を割り当てようとすると、その割り当ては失敗します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>hugepages-*</code>リソースをオーバーコミットすることはできません。
これは<code>memory</code>や<code>cpu</code>リソースとは異なります。
</div>
<p>CPUとメモリーは、まとめて<em>コンピュートリソース</em>または単に<em>リソース</em>と呼ばれます。
コンピューティングリソースは、要求され、割り当てられ、消費され得る測定可能な量です。
それらは<a href=/docs/concepts/overview/kubernetes-api/>API resources</a>とは異なります。
Podや<a href=/docs/concepts/services-networking/service/>Services</a>などのAPIリソースは、Kubernetes APIサーバーを介して読み取りおよび変更できるオブジェクトです。</p>
<h2 id=podとコンテナのリソース要求と制限>Podとコンテナのリソース要求と制限</h2>
<p>Podの各コンテナは、次の1つ以上を指定できます。</p>
<ul>
<li><code>spec.containers[].resources.limits.cpu</code></li>
<li><code>spec.containers[].resources.limits.memory</code></li>
<li><code>spec.containers[].resources.limits.hugepages-&lt;size></code></li>
<li><code>spec.containers[].resources.requests.cpu</code></li>
<li><code>spec.containers[].resources.requests.memory</code></li>
<li><code>spec.containers[].resources.requests.hugepages-&lt;size></code></li>
</ul>
<p>要求と制限はそれぞれのコンテナでのみ指定できますが、このPodリソースの要求と制限の関係性について理解すると便利です。
特定のリソースタイプの<em>Podリソース要求/制限</em>は、Pod内の各コンテナに対するそのタイプのリソース要求/制限の合計です。</p>
<h2 id=kubernetesにおけるリソースの単位>Kubernetesにおけるリソースの単位</h2>
<h3 id=cpuの意味>CPUの意味</h3>
<p>CPUリソースの制限と要求は、<em>cpu</em>単位で測定されます。
Kuberenetesにおける1つのCPUは、クラウドプロバイダーの<strong>1 vCPU/コア</strong>およびベアメタルのインテルプロセッサーの<strong>1 ハイパースレッド</strong>に相当します。</p>
<p>要求を少数で指定することもできます。
<code>spec.containers[].resources.requests.cpu</code>が<code>0.5</code>のコンテナは、1CPUを要求するコンテナの半分のCPUが保証されます。
<code>0.1</code>という表現は<code>100m</code>という表現と同等であり、<code>100ミリCPU</code>と読み替えることができます。
<code>100ミリコア</code>という表現も、同じことを意味しています。
<code>0.1</code>のような小数点のある要求はAPIによって<code>100m</code>に変換され、<code>1m</code>より細かい精度は許可されません。
このため、<code>100m</code>の形式が推奨されます。</p>
<p>CPUは常に相対量としてではなく、絶対量として要求されます。
0.1は、シングルコア、デュアルコア、あるいは48コアマシンのどのCPUに対してでも、同一の量を要求します。</p>
<h3 id=メモリーの意味>メモリーの意味</h3>
<p><code>メモリー</code>の制限と要求はバイト単位で測定されます。
E、P、T、G、M、Kのいずれかのサフィックスを使用して、メモリーを整数または固定小数点数として表すことができます。
また、Ei、Pi、Ti、Gi、Mi、Kiのような2の累乗の値を使用することもできます。
たとえば、以下はほぼ同じ値を表しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>128974848, 129e6, 129M, 123Mi
</code></pre></div><p>例を見てみましょう。
次のPodには2つのコンテナがあります。
各コンテナには、0.25cpuおよび64MiB(2<sup>26</sup>バイト)のメモリー要求と、0.5cpuおよび128MiBのメモリー制限があります
Podには0.5cpuと128MiBのメモリー要求があり、1cpuと256MiBのメモリ制限があると言えます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=リソース要求を含むpodがどのようにスケジュールされるか>リソース要求を含むPodがどのようにスケジュールされるか</h2>
<p>Podを作成すると、KubernetesスケジューラーはPodを実行するNodeを選択します。
各Nodeには、リソースタイプごとに最大容量があります。それは、Podに提供できるCPUとメモリの量です。
スケジューラーは、リソースタイプごとに、スケジュールされたコンテナのリソース要求の合計がNodeの容量より少ないことを確認します。
Node上の実際のメモリーまたはCPUリソースの使用率は非常に低いですが、容量チェックが失敗した場合、スケジューラーはNodeにPodを配置しないことに注意してください。
これにより、例えば日々のリソース要求のピーク時など、リソース利用が増加したときに、Nodeのリソース不足から保護されます。</p>
<h2 id=リソース制限のあるpodがどのように実行されるか>リソース制限のあるPodがどのように実行されるか</h2>
<p>kubeletがPodのコンテナを開始すると、CPUとメモリーの制限がコンテナランタイムに渡されます。</p>
<p>Dockerを使用する場合:</p>
<ul>
<li>
<p><code>spec.containers[].resources.requests.cpu</code>は、潜在的に小数であるコア値に変換され、1024倍されます。
<code>docker run</code>コマンドの<a href=https://docs.docker.com/engine/reference/run/#cpu-share-constraint><code>--cpu-shares</code></a>フラグの値は、この数値と2のいずれか大きい方が用いられます。</p>
</li>
<li>
<p><code>spec.containers[].resources.limits.cpu</code>はミリコアの値に変換され、100倍されます。
結果の値は、コンテナが100ミリ秒ごとに使用できるCPU時間の合計です。
コンテナは、この間隔の間、CPU時間の占有率を超えて使用することはできません。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> デフォルトのクォータ期間は100ミリ秒です。
CPUクォータの最小分解能は1ミリ秒です。
</div>
</li>
<li>
<p><code>spec.containers[].resources.limits.memory</code>は整数に変換され、<code>docker run</code>コマンドの<a href=https://docs.docker.com/engine/reference/run/#/user-memory-constraints><code>--memory</code></a>フラグの値として使用されます。</p>
</li>
</ul>
<p>コンテナがメモリー制限を超過すると、終了する場合があります。
コンテナが再起動可能である場合、kubeletは他のタイプのランタイム障害と同様にコンテナを再起動します。</p>
<p>コンテナがメモリー要求を超過すると、Nodeのメモリーが不足するたびにそのPodが排出される可能性があります。</p>
<p>コンテナは、長時間にわたってCPU制限を超えることが許可される場合と許可されない場合があります。
ただし、CPUの使用量が多すぎるために、コンテナが強制終了されることはありません。</p>
<p>コンテナをスケジュールできないか、リソース制限が原因で強制終了されているかどうかを確認するには、<a href=#troubleshooting>トラブルシューティング</a>のセクションを参照してください。</p>
<h3 id=コンピュートリソースとメモリーリソースの使用量を監視する>コンピュートリソースとメモリーリソースの使用量を監視する</h3>
<p>Podのリソース使用量は、Podのステータスの一部として報告されます。</p>
<p>オプションの<a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>監視ツール</a>がクラスターにおいて利用可能な場合、Podのリソース使用量は<a href=/docs/tasks/debug-application-cluster/resource-metrics-pipeline/#the-metrics-api>メトリクスAPI</a>から直接、もしくは監視ツールから取得できます。</p>
<h2 id=ローカルのエフェメラルストレージ>ローカルのエフェメラルストレージ</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code>
</div>
<p>Nodeには、ローカルに接続された書き込み可能なデバイス、または場合によってはRAMによってサポートされるローカルのエフェメラルストレージがあります。
"エフェメラル"とは、耐久性について長期的な保証がないことを意味します。</p>
<p>Podは、スクラッチ領域、キャッシュ、ログ用にエフェメラルなローカルストレージを使用しています。
kubeletは、ローカルのエフェメラルストレージを使用して、Podにスクラッチ領域を提供し、<a href=https://kubernetes.io/docs/concepts/storage/volumes/#emptydir><code>emptyDir</code></a> <a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>をコンテナにマウントできます。</p>
<p>また、kubeletはこの種類のストレージを使用して、<a href=/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>Nodeレベルのコンテナログ</a>、コンテナイメージ、実行中のコンテナの書き込み可能なレイヤーを保持します。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> Nodeに障害が発生すると、そのエフェメラルストレージ内のデータが失われる可能性があります。
アプリケーションは、ローカルのエフェメラルストレージにパフォーマンスのサービス品質保証(ディスクのIOPSなど)を期待することはできません。
</div>
<p>ベータ版の機能として、Kubernetesでは、Podが消費するローカルのエフェメラルストレージの量を追跡、予約、制限することができます。</p>
<h3 id=ローカルエフェメラルストレージの設定>ローカルエフェメラルストレージの設定</h3>
<p>Kubernetesは、Node上のローカルエフェメラルストレージを構成する2つの方法をサポートしています。
<ul class="nav nav-tabs" id=local-storage-configurations role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#local-storage-configurations-0 role=tab aria-controls=local-storage-configurations-0 aria-selected=true>シングルファイルシステム</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#local-storage-configurations-1 role=tab aria-controls=local-storage-configurations-1>2ファイルシステム</a></li></ul>
<div class=tab-content id=local-storage-configurations><div id=local-storage-configurations-0 class="tab-pane show active" role=tabpanel aria-labelledby=local-storage-configurations-0>
<p><p>この構成では、さまざまな種類のローカルのエフェメラルデータ(<code>emptyDir</code>ボリュームや、書き込み可能なレイヤー、コンテナイメージ、ログなど)をすべて1つのファイルシステムに配置します。
kubeletを構成する最も効果的な方法は、このファイルシステムをKubernetes(kubelet)データ専用にすることです。</p>
<p>kubeletは<a href=/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>Nodeレベルのコンテナログ</a>も書き込み、これらをエフェメラルなローカルストレージと同様に扱います。</p>
<p>kubeletは、設定されたログディレクトリ(デフォルトでは<code>/var/log</code>)内のファイルにログを書き出し、ローカルに保存された他のデータのベースディレクトリ(デフォルトでは<code>/var/lib/kubelet</code>)を持ちます。</p>
<p>通常、<code>/var/lib/kubelet</code>と<code>/var/log</code>はどちらもシステムルートファイルシステムにあり、kubeletはそのレイアウトを考慮して設計されています。</p>
<p>Nodeには、Kubernetesに使用されていない他のファイルシステムを好きなだけ持つことができます。</p>
</div>
<div id=local-storage-configurations-1 class=tab-pane role=tabpanel aria-labelledby=local-storage-configurations-1>
<p><p>Node上にファイルシステムがありますが、このファイルシステムは、ログや<code>emptyDir</code>ボリュームなど、実行中のPodの一時的なデータに使用されます。
このファイルシステムは、例えばKubernetesに関連しないシステムログなどの他のデータに使用することができ、ルートファイルシステムとすることさえ可能です。</p>
<p>また、kubeletは<a href=/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>ノードレベルのコンテナログ</a>を最初のファイルシステムに書き込み、これらをエフェメラルなローカルストレージと同様に扱います。</p>
<p>また、別の論理ストレージデバイスでバックアップされた別のファイルシステムを使用することもできます。
この設定では、コンテナイメージレイヤーと書き込み可能なレイヤーを配置するようにkubeletに指示するディレクトリは、この2番目のファイルシステム上にあります。</p>
<p>最初のファイルシステムは、コンテナイメージレイヤーや書き込み可能なレイヤーを保持していません。</p>
<p>Nodeには、Kubernetesに使用されていない他のファイルシステムを好きなだけ持つことができます。</p>
</div></div>
</p>
<p>kubeletは、ローカルストレージの使用量を測定できます。
これは、以下の条件で提供されます。</p>
<ul>
<li><code>LocalStorageCapacityIsolation</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>が有効になっています。(デフォルトでオンになっています。)</li>
<li>そして、ローカルのエフェメラルストレージ用にサポートされている構成の1つを使用してNodeをセットアップします。</li>
</ul>
<p>別の構成を使用している場合、kubeletはローカルのエフェメラルストレージにリソース制限を適用しません。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> kubeletは、<code>tmpfs</code>のemptyDirボリュームをローカルのエフェメラルストレージとしてではなく、コンテナメモリーとして追跡します。
</div>
<h3 id=ローカルのエフェメラルストレージの要求と制限設定>ローカルのエフェメラルストレージの要求と制限設定</h3>
<p>ローカルのエフェメラルストレージを管理するためには <em>ephemeral-storage</em> パラメーターを利用することができます。
Podの各コンテナは、次の1つ以上を指定できます。</p>
<ul>
<li><code>spec.containers[].resources.limits.ephemeral-storage</code></li>
<li><code>spec.containers[].resources.requests.ephemeral-storage</code></li>
</ul>
<p><code>ephemeral-storage</code>の制限と要求はバイト単位で記します。
ストレージは、次のいずれかの接尾辞を使用して、通常の整数または固定小数点数として表すことができます。
E、P、T、G、M、K。Ei、Pi、Ti、Gi、Mi、Kiの2のべき乗を使用することもできます。
たとえば、以下はほぼ同じ値を表しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>128974848, 129e6, 129M, 123Mi
</code></pre></div><p>次の例では、Podに2つのコンテナがあります。
各コンテナには、2GiBのローカルのエフェメラルストレージ要求があります。
各コンテナには、4GiBのローカルのエフェメラルストレージ制限があります。
したがって、Podには4GiBのローカルのエフェメラルストレージの要求と、8GiBのローカルのエフェメラルストレージ制限があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div><h3 id=エフェメラルストレージを要求するpodのスケジュール方法>エフェメラルストレージを要求するPodのスケジュール方法</h3>
<p>Podを作成すると、KubernetesスケジューラーはPodを実行するNodeを選択します。
各Nodeには、Podに提供できるローカルのエフェメラルストレージの上限があります。
詳細については、<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>Node割り当て可能</a>を参照してください。</p>
<p>スケジューラーは、スケジュールされたコンテナのリソース要求の合計がNodeの容量より少なくなるようにします。</p>
<h3 id=resource-emphemeralstorage-consumption>エフェメラルストレージの消費管理</h3>
<p>kubeletがローカルのエフェメラルストレージをリソースとして管理している場合、kubeletはストレージの使用量を測定します</p>
<ul>
<li><em>tmpfs</em><code>emptyDir</code>ボリュームを除く<code>emptyDir</code>ボリューム</li>
<li>Nodeレベルのログを保持するディレクトリ</li>
<li>書き込み可能なコンテナレイヤー</li>
</ul>
<p>Podが許可するよりも多くのエフェメラルストレージを使用している場合、kubeletはPodの排出をトリガーするシグナルを設定します。</p>
<p>コンテナレベルの分離の場合、コンテナの書き込み可能なレイヤーとログ使用量がストレージの制限を超えると、kubeletはPodに排出のマークを付けます。</p>
<p>Podレベルの分離の場合、kubeletはPod内のコンテナの制限を合計し、Podの全体的なストレージ制限を計算します。
このケースでは、すべてのコンテナからのローカルのエフェメラルストレージの使用量とPodの<code>emptyDir</code>ボリュームの合計がPod全体のストレージ制限を超過する場合、
kubeletはPodをまた排出対象としてマークします。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <p>kubeletがローカルのエフェメラルストレージを測定していない場合、ローカルストレージの制限を超えるPodは、ローカルストレージのリソース制限に違反しても排出されません。</p>
<p>ただし、書き込み可能なコンテナレイヤー、Nodeレベルのログ、または<code>emptyDir</code>ボリュームのファイルシステムスペースが少なくなると、Nodeはローカルストレージが不足していると汚染<a class=glossary-tooltip title="A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups." data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taints>taints</a>し、この汚染は、汚染を特に許容しないPodの排出をトリガーします。</p>
<p>ローカルのエフェメラルストレージについては、サポートされている<a href=%EF%BC%83configurations-for-local-ephemeral-storage>設定</a>をご覧ください。</p>
</div>
<p>kubeletはPodストレージの使用状況を測定するさまざまな方法をサポートしています</p>
<ul class="nav nav-tabs" id=resource-emphemeralstorage-measurement role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#resource-emphemeralstorage-measurement-0 role=tab aria-controls=resource-emphemeralstorage-measurement-0 aria-selected=true>定期スキャン</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#resource-emphemeralstorage-measurement-1 role=tab aria-controls=resource-emphemeralstorage-measurement-1>ファイルシステムプロジェクトクォータ</a></li></ul>
<div class=tab-content id=resource-emphemeralstorage-measurement><div id=resource-emphemeralstorage-measurement-0 class="tab-pane show active" role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-0>
<p><p>kubeletは、<code>emptyDir</code>ボリューム、コンテナログディレクトリ、書き込み可能なコンテナレイヤーをスキャンする定期的なスケジュールチェックを実行します。</p>
<p>スキャンは、使用されているスペースの量を測定します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>このモードでは、kubeletは削除されたファイルのために、開いているファイルディスクリプタを追跡しません。</p>
<p>あなた(またはコンテナ)が<code>emptyDir</code>ボリューム内にファイルを作成した後、何かがそのファイルを開き、そのファイルが開かれたままの状態でファイルを削除した場合、削除されたファイルのinodeはそのファイルを閉じるまで残りますが、kubeletはそのスペースを使用中として分類しません。</p>
</div>
</div>
<div id=resource-emphemeralstorage-measurement-1 class=tab-pane role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-1>
<p><div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.15 [alpha]</code>
</div>
<p>プロジェクトクォータは、ファイルシステム上のストレージ使用量を管理するためのオペレーティングシステムレベルの機能です。
Kubernetesでは、プロジェクトクォータを有効にしてストレージの使用状況を監視することができます。
ノード上の<code>emptyDir</code>ボリュームをバックアップしているファイルシステムがプロジェクトクォータをサポートしていることを確認してください。
例えば、XFSやext4fsはプロジェクトクォータを提供しています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> プロジェクトクォータはストレージの使用状況を監視しますが、制限を強制するものではありません。
</div>
<p>Kubernetesでは、<code>1048576</code>から始まるプロジェクトIDを使用します。
使用するプロジェクトIDは<code>/etc/projects</code>と<code>/etc/projid</code>に登録されます。
この範囲のプロジェクトIDをシステム上で別の目的で使用する場合は、それらのプロジェクトIDを<code>/etc/projects</code>と<code>/etc/projid</code>に登録し、
Kubernetesが使用しないようにする必要があります。</p>
<p>クォータはディレクトリスキャンよりも高速で正確です。
ディレクトリがプロジェクトに割り当てられると、ディレクトリ配下に作成されたファイルはすべてそのプロジェクト内に作成され、カーネルはそのプロジェクト内のファイルによって使用されているブロックの数を追跡するだけです。
ファイルが作成されて削除されても、開いているファイルディスクリプタがあれば、スペースを消費し続けます。
クォータトラッキングはそのスペースを正確に記録しますが、ディレクトリスキャンは削除されたファイルが使用するストレージを見落としてしまいます。</p>
<p>プロジェクトクォータを使用する場合は、次のことを行う必要があります。</p>
<ul>
<li>
<p>kubelet設定で、<code>LocalocalStorpactionCapactionIsolationFSQuotaMonitoring=true</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gate/>フィーチャーゲート</a>を有効にします。</p>
</li>
<li>
<p>ルートファイルシステム(またはオプションのランタイムファイルシステム))がプロジェクトクォータを有効にしていることを確認してください。
すべてのXFSファイルシステムはプロジェクトクォータをサポートしています。
ext4ファイルシステムでは、ファイルシステムがマウントされていない間は、プロジェクトクォータ追跡機能を有効にする必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># ext4の場合、/dev/block-deviceがマウントされていません</span>
sudo tune2fs -O project -Q prjquota /dev/block-device
</code></pre></div></li>
<li>
<p>ルートファイルシステム(またはオプションのランタイムファイルシステム)がプロジェクトクォータを有効にしてマウントされていることを確認してください。
XFSとext4fsの両方で、マウントオプションは<code>prjquota</code>という名前になっています。</p>
</li>
</ul>
</div></div>
<h2 id=拡張リソース>拡張リソース</h2>
<p>拡張リソースは<code>kubernetes.io</code>ドメインの外で完全に修飾されたリソース名です。
これにより、クラスタオペレータはKubernetesに組み込まれていないリソースをアドバタイズし、ユーザはそれを利用することができるようになります。</p>
<p>拡張リソースを使用するためには、2つのステップが必要です。
第一に、クラスタオペレーターは拡張リソースをアドバタイズする必要があります。
第二に、ユーザーはPodで拡張リソースを要求する必要があります。</p>
<h3 id=拡張リソースの管理>拡張リソースの管理</h3>
<h4 id=nodeレベルの拡張リソース>Nodeレベルの拡張リソース</h4>
<p>Nodeレベルの拡張リソースはNodeに関連付けられています。</p>
<h5 id=デバイスプラグイン管理のリソース>デバイスプラグイン管理のリソース</h5>
<p>各Nodeにデバイスプラグインで管理されているリソースをアドバタイズする方法については、<a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a>を参照してください。</p>
<h5 id=その他のリソース>その他のリソース</h5>
<p>新しいNodeレベルの拡張リソースをアドバタイズするには、クラスタオペレータはAPIサーバに<code>PATCH</code>HTTPリクエストを送信し、クラスタ内のNodeの<code>status.capacity</code>に利用可能な量を指定します。
この操作の後、ノードの<code>status.capacity</code>には新しいリソースが含まれます。
<code>status.allocatable</code>フィールドは、kubeletによって非同期的に新しいリソースで自動的に更新されます。
スケジューラはPodの適合性を評価する際にNodeの<code>status.allocatable</code>値を使用するため、Nodeの容量に新しいリソースを追加してから、そのNodeでリソースのスケジューリングを要求する最初のPodが現れるまでには、短い遅延が生じる可能性があることに注意してください。</p>
<p><strong>例:</strong></p>
<p>以下は、<code>curl</code>を使用して、Masterが<code>k8s-master</code>であるNode<code>k8s-node-1</code>で5つの<code>example.com/foo</code>リソースを示すHTTPリクエストを作成する方法を示す例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1foo&#34;, &#34;value&#34;: &#34;5&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>http://k8s-master:8080/api/v1/nodes/k8s-node-1/status
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 上記のリクエストでは、<code>~1</code>はパッチパス内の文字<code>/</code>のエンコーディングです。
JSON-Patchの操作パス値は、JSON-Pointerとして解釈されます。
詳細については、<a href=https://tools.ietf.org/html/rfc6901#section-3>IETF RFC 6901, section 3</a>を参照してください。
</div>
<h4 id=クラスターレベルの拡張リソース>クラスターレベルの拡張リソース</h4>
<p>クラスターレベルの拡張リソースはノードに関連付けられていません。
これらは通常、リソース消費とリソースクォータを処理するスケジューラー拡張機能によって管理されます。</p>
<p><a href=https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/scheduler/api/v1/types.go#L31>スケジューラーポリシー構成</a>では。スケジューラー拡張機能によって扱われる拡張リソースを指定できます。</p>
<p><strong>例:</strong></p>
<p>次のスケジューラーポリシーの構成は、クラスターレベルの拡張リソース"example.com/foo"がスケジューラー拡張機能によって処理されることを示しています。</p>
<ul>
<li>スケジューラーは、Podが"example.com/foo"を要求した場合にのみ、Podをスケジューラー拡張機能に送信します。</li>
<li><code>ignoredByScheduler</code>フィールドは、スケジューラがその<code>PodFitsResources</code>述語で"example.com/foo"リソースをチェックしないことを指定します。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;extenders&#34;</span>: [
    {
      <span style=color:green;font-weight:700>&#34;urlPrefix&#34;</span>:<span style=color:#b44>&#34;&lt;extender-endpoint&gt;&#34;</span>,
      <span style=color:green;font-weight:700>&#34;bindVerb&#34;</span>: <span style=color:#b44>&#34;bind&#34;</span>,
      <span style=color:green;font-weight:700>&#34;managedResources&#34;</span>: [
        {
          <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example.com/foo&#34;</span>,
          <span style=color:green;font-weight:700>&#34;ignoredByScheduler&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
        }
      ]
    }
  ]
}
</code></pre></div><h3 id=拡張リソースの消費>拡張リソースの消費</h3>
<p>ユーザーは、CPUやメモリのようにPodのスペックで拡張されたリソースを消費できます。
利用可能な量以上のリソースが同時にPodに割り当てられないように、スケジューラーがリソースアカウンティングを行います。</p>
<p>APIサーバーは、拡張リソースの量を整数の値で制限します。
有効な数量の例は、<code>3</code>、<code>3000m</code>、<code>3Ki</code>です。
無効な数量の例は、<code>0.5</code>、<code>1500m</code>です。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 拡張リソースは不透明な整数リソースを置き換えます。
ユーザーは、予約済みの<code>kubernetes.io</code>以外のドメイン名プレフィックスを使用できます。
</div>
<p>Podで拡張リソースを消費するには、コンテナ名の<code>spec.containers[].resources.limits</code>マップにキーとしてリソース名を含めます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 拡張リソースはオーバーコミットできないので、コンテナスペックに要求と制限の両方が存在する場合は等しくなければなりません。
</div>
<p>Podは、CPU、メモリ、拡張リソースを含むすべてのリソース要求が満たされた場合にのみスケジュールされます。
リソース要求が満たされない限り、Podは<code>PENDING</code>状態のままです。</p>
<p><strong>例:</strong></p>
<p>下のPodはCPUを2つ、"example.com/foo"(拡張リソース)を1つ要求しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myimage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></code></pre></div><h2 id=トラブルシューティング>トラブルシューティング</h2>
<h3 id=failedschedulingイベントメッセージが表示され-podが保留中になる>failedSchedulingイベントメッセージが表示され、Podが保留中になる</h3>
<p>スケジューラーがPodが収容されるNodeを見つけられない場合、場所が見つかるまでPodはスケジュールされないままになります。
スケジューラーがPodの場所を見つけられないたびに、次のようなイベントが生成されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod frontend | grep -A <span style=color:#666>3</span> Events
</code></pre></div><pre><code>Events:
  FirstSeen LastSeen   Count  From          Subobject   PathReason      Message
  36s   5s     6      {scheduler }              FailedScheduling  Failed for reason PodExceedsFreeCPU and possibly others
</code></pre><p>前述の例では、"frontend"という名前のPodは、Node上のCPUリソースが不足しているためにスケジューリングに失敗しています。
同様のエラーメッセージは、メモリー不足による失敗を示唆することもあります(PodExceedsFreeMemory)。
一般的に、このタイプのメッセージでPodが保留されている場合は、いくつか試すべきことがあります。</p>
<ul>
<li>クラスタにNodeを追加します。</li>
<li>不要なポッドを終了して、保留中のPodのためのスペースを空けます。</li>
<li>PodがすべてのNodeよりも大きくないことを確認してください。
例えば、すべてのNodeが<code>cpu: 1</code>の容量を持っている場合、<code>cpu: 1.1</code>を要求するPodは決してスケジューリングされません。</li>
</ul>
<p>Nodeの容量や割り当て量は<code>kubectl describe nodes</code>コマンドで調べることができる。
例えば、以下のようになる。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe nodes e2e-test-node-pool-4lw4
</code></pre></div><pre><code>Name:            e2e-test-node-pool-4lw4
[ ... lines removed for clarity ...]
Capacity:
 cpu:                               2
 memory:                            7679792Ki
 pods:                              110
Allocatable:
 cpu:                               1800m
 memory:                            7474992Ki
 pods:                              110
[ ... lines removed for clarity ...]
Non-terminated Pods:        (5 in total)
  Namespace    Name                                  CPU Requests  CPU Limits  Memory Requests  Memory Limits
  ---------    ----                                  ------------  ----------  ---------------  -------------
  kube-system  fluentd-gcp-v1.38-28bv1               100m (5%)     0 (0%)      200Mi (2%)       200Mi (2%)
  kube-system  kube-dns-3297075139-61lj3             260m (13%)    0 (0%)      100Mi (1%)       170Mi (2%)
  kube-system  kube-proxy-e2e-test-...               100m (5%)     0 (0%)      0 (0%)           0 (0%)
  kube-system  monitoring-influxdb-grafana-v4-z1m12  200m (10%)    200m (10%)  600Mi (8%)       600Mi (8%)
  kube-system  node-problem-detector-v0.1-fj7m3      20m (1%)      200m (10%)  20Mi (0%)        100Mi (1%)
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests    CPU Limits    Memory Requests    Memory Limits
  ------------    ----------    ---------------    -------------
  680m (34%)      400m (20%)    920Mi (12%)        1070Mi (14%)
</code></pre><p>前述の出力では、Podが1120m以上のCPUや6.23Gi以上のメモリーを要求した場合、そのPodはNodeに収まらないことがわかります。</p>
<p><code>Pods</code>セクションを見れば、どのPodがNode上でスペースを占有しているかがわかります。</p>
<p>システムデーモンが利用可能なリソースの一部を使用しているため、Podに利用可能なリソースの量はNodeの容量よりも少なくなっています。
<code>allocatable</code>フィールド<a href=/docs/reference/generated/kubernetes-api/v1.22/#nodestatus-v1-core>NodeStatus</a>は、Podに利用可能なリソースの量を与えます。
詳細については、<a href=https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md>ノード割り当て可能なリソース</a>を参照してください。</p>
<p><a href=/docs/concepts/policy/resource-quotas/>リソースクォータ</a>機能は、消費できるリソースの総量を制限するように設定することができます。
名前空間と組み合わせて使用すると、1つのチームがすべてのリソースを占有するのを防ぐことができます。</p>
<h3 id=コンテナが終了した>コンテナが終了した</h3>
<p>コンテナはリソース不足のため、終了する可能性があります。
コンテナがリソース制限に達したために強制終了されているかどうかを確認するには、対象のPodで<code>kubectl describe pod</code>を呼び出します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod simmemleak-hra99
</code></pre></div><pre><code>Name:                           simmemleak-hra99
Namespace:                      default
Image(s):                       saadali/simmemleak
Node:                           kubernetes-node-tf0f/10.240.216.66
Labels:                         name=simmemleak
Status:                         Running
Reason:
Message:
IP:                             10.244.2.75
Replication Controllers:        simmemleak (1/1 replicas created)
Containers:
  simmemleak:
    Image:  saadali/simmemleak
    Limits:
      cpu:                      100m
      memory:                   50Mi
    State:                      Running
      Started:                  Tue, 07 Jul 2015 12:54:41 -0700
    Last Termination State:     Terminated
      Exit Code:                1
      Started:                  Fri, 07 Jul 2015 12:54:30 -0700
      Finished:                 Fri, 07 Jul 2015 12:54:33 -0700
    Ready:                      False
    Restart Count:              5
Conditions:
  Type      Status
  Ready     False
Events:
  FirstSeen                         LastSeen                         Count  From                              SubobjectPath                       Reason      Message
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {scheduler }                                                          scheduled   Successfully assigned simmemleak-hra99 to kubernetes-node-tf0f
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   pulled      Pod container image &quot;k8s.gcr.io/pause:0.8.0&quot; already present on machine
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   created     Created with docker id 6a41280f516d
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   started     Started with docker id 6a41280f516d
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    spec.containers{simmemleak}         created     Created with docker id 87348f12526a
</code></pre><p>上記の例では、<code>Restart Count：5</code>はPodの<code>simmemleak</code>コンテナが終了して、5回再起動したことを示しています。</p>
<p><code>-o go-template=...</code>オプションを指定して、<code>kubectl get pod</code>を呼び出し、以前に終了したコンテナのステータスを取得できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range.status.containerStatuses}}{{&#34;Container Name: &#34;}}{{.name}}{{&#34;\r\nLastState: &#34;}}{{.lastState}}{{end}}&#39;</span>  simmemleak-hra99
</code></pre></div><pre><code>Container Name: simmemleak
LastState: map[terminated:map[exitCode:137 reason:OOM Killed startedAt:2015-07-07T20:58:43Z finishedAt:2015-07-07T20:58:43Z containerID:docker://0e4095bba1feccdfe7ef9fb6ebffe972b4b14285d5acdec6f0d3ae8a22fad8b2]]
</code></pre><p><code>reason：OOM Killed</code>が原因でコンテナが終了したことがわかります。<code>OOM</code>はメモリー不足を表します。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>
<p><a href=/docs/tasks/configure-pod-container/assign-memory-resource/>コンテナとPodへのメモリーリソースの割り当て</a>ハンズオンを行う</p>
</li>
<li>
<p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>コンテナとPodへのCPUリソースの割り当て</a>ハンズオンを行う</p>
</li>
<li>
<p>要求と制限の違いの詳細については、<a href=https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md>リソースQoS</a>を参照する</p>
</li>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#container-v1-core>コンテナ</a>APIリファレンスを読む</p>
</li>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#resourcerequirements-v1-core>リソース要求</a>APIリファレンスを読む</p>
</li>
<li>
<p>XFSの<a href=http://xfs.org/docs/xfsdocs-xml-dev/XFS_User_Guide/tmp/en-US/html/xfs-quotas.html>プロジェクトクォータ</a>について読む</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>3.7.5 - kubeconfigファイルを使用してクラスターアクセスを組織する</h1>
<p>kubeconfigを使用すると、クラスターに、ユーザー、名前空間、認証の仕組みに関する情報を組織できます。<code>kubectl</code>コマンドラインツールはkubeconfigファイルを使用してクラスターを選択するために必要な情報を見つけ、クラスターのAPIサーバーと通信します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> クラスターへのアクセスを設定するために使われるファイルは<em>kubeconfigファイル</em>と呼ばれます。これは設定ファイルを指すために使われる一般的な方法です。<code>kubeconfig</code>という名前を持つファイルが存在するという意味ではありません。
</div>
<p>デフォルトでは、<code>kubectl</code>は<code>$HOME/.kube</code>ディレクトリ内にある<code>config</code>という名前のファイルを探します。<code>KUBECONFIG</code>環境変数を設定するか、<a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a>フラグで指定することで、別のkubeconfigファイルを指定することもできます。</p>
<p>kubeconfigファイルの作成と指定に関するステップバイステップの手順を知りたいときは、<a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters>複数のクラスターへのアクセスを設定する</a>を参照してください。</p>
<h2 id=複数のクラスター-ユーザ-認証の仕組みのサポート>複数のクラスター、ユーザ、認証の仕組みのサポート</h2>
<p>複数のクラスターを持っていて、ユーザーやコンポーネントがさまざまな方法で認証を行う次のような状況を考えてみます。</p>
<ul>
<li>実行中のkubeletが証明書を使用して認証を行う可能性がある。</li>
<li>ユーザーがトークンを使用して認証を行う可能性がある。</li>
<li>管理者が個別のユーザに提供する複数の証明書を持っている可能性がある。</li>
</ul>
<p>kubeconfigファイルを使用すると、クラスター、ユーザー、名前空間を組織化することができます。また、contextを定義することで、複数のクラスターや名前空間を素早く簡単に切り替えられます。</p>
<h2 id=context>Context</h2>
<p>kubeconfigファイルの<em>context</em>要素は、アクセスパラメーターを使いやすい名前でグループ化するために使われます。各contextは3つのパラメータ、cluster、namespace、userを持ちます。デフォルトでは、<code>kubectl</code>コマンドラインツールはクラスターとの通信に<em>current context</em>のパラメーターを使用します。</p>
<p>current contextを選択するには、以下のコマンドを使用します。</p>
<pre><code>kubectl config use-context
</code></pre><h2 id=kubeconfig環境変数>KUBECONFIG環境変数</h2>
<p><code>KUBECONFIG</code>環境変数には、kubeconfigファイルのリストを指定できます。LinuxとMacでは、リストはコロン区切りです。Windowsでは、セミコロン区切りです。<code>KUBECONFIG</code>環境変数は必須ではありません。<code>KUBECONFIG</code>環境変数が存在しない場合は、<code>kubectl</code>はデフォルトのkubeconfigファイルである<code>$HOME/.kube/config</code>を使用します。</p>
<p><code>KUBECONFIG</code>環境変数が存在する場合は、<code>kubectl</code>は<code>KUBECONFIG</code>環境変数にリストされているファイルをマージした結果を有効な設定として使用します。</p>
<h2 id=kubeconfigファイルのマージ>kubeconfigファイルのマージ</h2>
<p>設定ファイルを確認するには、以下のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div><p>上で説明したように、出力は1つのkubeconfigファイルから作られる場合も、複数のkubeconfigファイルをマージした結果となる場合もあります。</p>
<p><code>kubectl</code>がkubeconfigファイルをマージするときに使用するルールを以下に示します。</p>
<ol>
<li>
<p>もし<code>--kubeconfig</code>フラグが設定されていた場合、指定したファイルだけが使用されます。マージは行いません。このフラグに指定できるのは1つのファイルだけです。</p>
<p>そうでない場合、<code>KUBECONFIG</code>環境変数が設定されていた場合には、それをマージするべきファイルのリストとして使用します。<code>KUBECONFIG</code>環境変数にリストされたファイルのマージは、次のようなルールに従って行われます。</p>
<ul>
<li>空のファイルを無視する。</li>
<li>デシリアライズできない内容のファイルに対してエラーを出す。</li>
<li>特定の値やmapのキーを設定する最初のファイルが勝つ。</li>
<li>値やmapのキーは決して変更しない。
例: 最初のファイルが指定した<code>current-context</code>を保持する。
例: 2つのファイルが<code>red-user</code>を指定した場合、1つ目のファイルの<code>red-user</code>だけを使用する。もし2つ目のファイルの<code>red-user</code>以下に競合しないエントリーがあったとしても、それらは破棄する。</li>
</ul>
<p><code>KUBECONFIG</code>環境変数を設定する例については、<a href=/ja/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable>KUBECONFIG環境変数を設定する</a>を参照してください。</p>
<p>それ以外の場合は、デフォルトのkubeconfigファイル<code>$HOME/.kube/config</code>をマージせずに使用します。</p>
</li>
<li>
<p>以下のチェーンで最初に見つかったものをもとにして、使用するcontextを決定する。</p>
<ol>
<li><code>--context</code>コマンドラインフラグが存在すれば、それを使用する。</li>
<li>マージしたkubeconrfigファイルから<code>current-context</code>を使用する。</li>
</ol>
<p>この時点では、空のcontextも許容されます。</p>
</li>
<li>
<p>クラスターとユーザーを決定する。この時点では、contextである場合もそうでない場合もあります。以下のチェーンで最初に見つかったものをもとにして、クラスターとユーザーを決定します。この手順はユーザーとクラスターについてそれぞれ1回ずつ、合わせて2回実行されます。</p>
<ol>
<li>もし存在すれば、コマンドラインフラグ<code>--user</code>または<code>--cluster</code>を使用する。</li>
<li>もしcontextが空でなければ、contextからユーザーまたはクラスターを取得する。</li>
</ol>
<p>この時点では、ユーザーとクラスターは空である可能性があります。</p>
</li>
<li>
<p>使用する実際のクラスター情報を決定する。この時点では、クラスター情報は存在しない可能性があります。以下のチェーンで最初に見つかったものをもとにして、クラスター情報の各パーツをそれぞれを構築します。</p>
<ol>
<li>もし存在すれば、<code>--server</code>、<code>--certificate-authority</code>、<code>--insecure-skip-tls-verify</code>コマンドラインフラグを使用する。</li>
<li>もしマージしたkubeconfigファイルにクラスター情報の属性が存在すれば、それを使用する。</li>
<li>もしサーバーの場所が存在しなければ、マージは失敗する。</li>
</ol>
</li>
<li>
<p>使用する実際のユーザー情報を決定する。クラスター情報の場合と同じルールを使用して、ユーザー情報を構築します。ただし、ユーザーごとに許可される認証方法は1つだけです。</p>
<ol>
<li>もし存在すれば、<code>--client-certificate</code>、<code>--client-key</code>、<code>--username</code>、<code>--password</code>、<code>--token</code>コマンドラインフラグを使用する。</li>
<li>マージしたkubeconfigファイルの<code>user</code>フィールドを使用する。</li>
<li>もし2つの競合する方法が存在する場合、マージは失敗する。</li>
</ol>
</li>
<li>
<p>もし何らかの情報がまだ不足していれば、デフォルトの値を使用し、認証情報については場合によってはプロンプトを表示する。</p>
</li>
</ol>
<h2 id=ファイルリファレンス>ファイルリファレンス</h2>
<p>kubeconfigファイル内のファイルとパスのリファレンスは、kubeconfigファイルの位置からの相対パスで指定します。コマンドライン上のファイルのリファレンスは、現在のワーキングディレクトリからの相対パスです。<code>$HOME/.kube/config</code>内では、相対パスは相対のまま、絶対パスは絶対のまま保存されます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>複数のクラスターへのアクセスを設定する</a></li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ed4ae5e4344d619bc6df6e1278efae74>3.7.6 - Podの優先度とプリエンプション</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code>
</div>
<p><a href=/ja/docs/concepts/workloads/pods/>Pod</a>は <em>priority</em>（優先度）を持つことができます。
優先度は他のPodに対する相対的なPodの重要度を示します。
もしPodをスケジューリングできないときには、スケジューラーはそのPodをスケジューリングできるようにするため、優先度の低いPodをプリエンプトする（追い出す）ことを試みます。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> <p>クラスターの全てのユーザーが信用されていない場合、悪意のあるユーザーが可能な範囲で最も高い優先度のPodを作成することが可能です。これは他のPodが追い出されたりスケジューリングできない状態を招きます。
管理者はResourceQuotaを使用して、ユーザーがPodを高い優先度で作成することを防ぐことができます。</p>
<p>詳細は<a href=/ja/docs/concepts/policy/resource-quotas/#limit-priority-class-consumption-by-default>デフォルトで優先度クラスの消費を制限する</a>
を参照してください。</p>
</div>
<h2 id=優先度とプリエンプションを使う方法>優先度とプリエンプションを使う方法</h2>
<p>優先度とプリエンプションを使うには、</p>
<ol>
<li>
<p>1つまたは複数の<a href=#priorityclass>PriorityClass</a>を追加します</p>
</li>
<li>
<p>追加したPriorityClassを<a href=#pod-priority><code>priorityClassName</code></a>に設定したPodを作成します。
もちろんPodを直接作る必要はありません。
一般的には<code>priorityClassName</code>をDeploymentのようなコレクションオブジェクトのPodテンプレートに追加します。</p>
</li>
</ol>
<p>これらの手順のより詳しい情報については、この先を読み進めてください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Kubernetesには最初から既に2つのPriorityClassが設定された状態になっています。
<code>system-cluster-critical</code>と<code>system-node-critical</code>です。
これらは汎用のクラスであり、<a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/>重要なコンポーネントが常に最初にスケジュールされることを保証する</a>ために使われます。
</div>
<h2 id=priorityclass>PriorityClass</h2>
<p>PriorityClassはnamespaceによらないオブジェクトで、優先度クラスの名称から優先度を表す整数値への対応を定義します。
PriorityClassオブジェクトのメタデータの<code>name</code>フィールドにて名称を指定します。
値は<code>value</code>フィールドで指定し、必須です。
値が大きいほど、高い優先度を示します。
PriorityClassオブジェクトの名称は<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>として適切であり、かつ<code>system-</code>から始まってはいけません。</p>
<p>PriorityClassオブジェクトは10億以下の任意の32ビットの整数値を持つことができます。
それよりも大きな値は通常はプリエンプトや追い出すべきではない重要なシステム用のPodのために予約されています。
クラスターの管理者は割り当てたい優先度に対して、PriorityClassオブジェクトを1つずつ作成すべきです。</p>
<p>PriorityClassは任意でフィールド<code>globalDefault</code>と<code>description</code>を設定可能です。
<code>globalDefault</code>フィールドは<code>priorityClassName</code>が指定されないPodはこのPriorityClassを使うべきであることを示します。<code>globalDefault</code>がtrueに設定されたPriorityClassはシステムで一つのみ存在可能です。<code>globalDefault</code>が設定されたPriorityClassが存在しない場合は、<code>priorityClassName</code>が設定されていないPodの優先度は0に設定されます。</p>
<p><code>description</code>フィールドは任意の文字列です。クラスターの利用者に対して、PriorityClassをどのような時に使うべきか示すことを意図しています。</p>
<h3 id=podpriorityと既存のクラスターに関する注意>PodPriorityと既存のクラスターに関する注意</h3>
<ul>
<li>
<p>もし既存のクラスターをこの機能がない状態でアップグレードすると、既存のPodの優先度は実質的に0になります。</p>
</li>
<li>
<p><code>globalDefault</code>が<code>true</code>に設定されたPriorityClassを追加しても、既存のPodの優先度は変わりません。PriorityClassのそのような値は、PriorityClassが追加された以後に作成されたPodのみに適用されます。</p>
</li>
<li>
<p>PriorityClassを削除した場合、削除されたPriorityClassの名前を使用する既存のPodは変更されませんが、削除されたPriorityClassの名前を使うPodをそれ以上作成することはできなくなります。</p>
</li>
</ul>
<h3 id=priorityclassの例>PriorityClassの例</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>scheduling.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>1000000</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>globalDefault</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;この優先度クラスはXYZサービスのPodに対してのみ使用すべきです。&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=non-preempting-priority-class>非プリエンプトのPriorityClass</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code>
</div>
<p><code>PreemptionPolicy: Never</code>と設定されたPodは、スケジューリングのキューにおいて他の優先度の低いPodよりも優先されますが、他のPodをプリエンプトすることはありません。
スケジューリングされるのを待つ非プリエンプトのPodは、リソースが十分に利用可能になるまでスケジューリングキューに残ります。
非プリエンプトのPodは、他のPodと同様に、スケジューラーのバックオフの対象になります。これは、スケジューラーがPodをスケジューリングしようと試みたものの失敗した場合、低い頻度で再試行するようにして、より優先度の低いPodが先にスケジューリングされることを許します。</p>
<p>非プリエンプトのPodは、他の優先度の高いPodにプリエンプトされる可能性はあります。</p>
<p><code>PreemptionPolicy</code>はデフォルトでは<code>PreemptLowerPriority</code>に設定されており、これが設定されているPodは優先度の低いPodをプリエンプトすることを許容します。これは既存のデフォルトの挙動です。
<code>PreemptionPolicy</code>を<code>Never</code>に設定すると、これが設定されたPodはプリエンプトを行わないようになります。</p>
<p>ユースケースの例として、データサイエンスの処理を挙げます。
ユーザーは他の処理よりも優先度を高くしたいジョブを追加できますが、そのとき既存の実行中のPodの処理結果をプリエンプトによって破棄させたくはありません。
<code>PreemptionPolicy: Never</code>が設定された優先度の高いジョブは、他の既にキューイングされたPodよりも先に、クラスターのリソースが「自然に」開放されたときにスケジューリングされます。</p>
<h3 id=非プリエンプトのpriorityclassの例>非プリエンプトのPriorityClassの例</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>scheduling.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority-nonpreempting<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>1000000</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>preemptionPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>globalDefault</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;この優先度クラスは他のPodをプリエンプトさせません。&#34;</span><span style=color:#bbb>
</span></code></pre></div><h2 id=pod-priority>Podの優先度</h2>
<p>一つ以上のPriorityClassがあれば、仕様にPriorityClassを指定したPodを作成することができるようになります。優先度のアドミッションコントローラーは<code>priorityClassName</code>フィールドを使用し、優先度の整数値を設定します。PriorityClassが見つからない場合、そのPodの作成は拒否されます。</p>
<p>下記のYAMLは上記の例で作成したPriorityClassを使用するPodの設定の例を示します。優先度のアドミッションコントローラーは仕様を確認し、このPodの優先度は1000000であると設定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></code></pre></div><h3 id=スケジューリング順序におけるpodの優先度の効果>スケジューリング順序におけるPodの優先度の効果</h3>
<p>Podの優先度が有効な場合、スケジューラーは待機状態のPodをそれらの優先度順に並べ、スケジューリングキューにおいてより優先度の低いPodよりも前に来るようにします。その結果、その条件を満たしたときには優先度の高いPodは優先度の低いPodより早くスケジューリングされます。優先度の高いPodがスケジューリングできない場合は、スケジューラーは他の優先度の低いPodのスケジューリングも試みます。</p>
<h2 id=プリエンプション>プリエンプション</h2>
<p>Podが作成されると、スケジューリング待ちのキューに入り待機状態になります。スケジューラーはキューからPodを取り出し、ノードへのスケジューリングを試みます。Podに指定された条件を全て満たすノードが見つからない場合は、待機状態のPodのためにプリエンプションロジックが発動します。待機状態のPodをPと呼ぶことにしましょう。プリエンプションロジックはPよりも優先度の低いPodを一つ以上追い出せばPをスケジューリングできるようになるノードを探します。そのようなノードがあれば、優先度の低いPodはノードから追い出されます。Podが追い出された後に、Pはノードへスケジューリング可能になります。</p>
<h3 id=ユーザーへ開示される情報>ユーザーへ開示される情報</h3>
<p>Pod PがノードNのPodをプリエンプトした場合、ノードNの名称がPのステータスの<code>nominatedNodeName</code>フィールドに設定されます。このフィールドはスケジューラーがPod Pのために予約しているリソースの追跡を助け、ユーザーにクラスターにおけるプリエンプトに関する情報を与えます。</p>
<p>Pod Pは必ずしも「指名したノード」へスケジューリングされないことに注意してください。Podがプリエンプトされると、そのPodは終了までの猶予期間を得ます。スケジューラーがPodの終了を待つ間に他のノードが利用可能になると、スケジューラーは他のノードをPod Pのスケジューリング先にします。この結果、Podの<code>nominatedNodeName</code>と<code>nodeName</code>は必ずしも一致しません。また、スケジューラーがノードNのPodをプリエンプトさせた後に、Pod Pよりも優先度の高いPodが来た場合、スケジューラーはノードNをその新しい優先度の高いPodへ与えます。このような場合は、スケジューラーはPod Pの<code>nominatedNodeName</code>を消去します。これによって、スケジューラーはPod Pが他のノードのPodをプリエンプトさせられるようにします。</p>
<h3 id=プリエンプトの制限>プリエンプトの制限</h3>
<h4 id=プリエンプトされるpodの正常終了>プリエンプトされるPodの正常終了</h4>
<p>Podがプリエンプトされると、<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>猶予期間</a>が与えられます。</p>
<p>Podは作業を完了し、終了するために十分な時間が与えられます。仮にそうでない場合、強制終了されます。この猶予期間によって、スケジューラーがPodをプリエンプトした時刻と、待機状態のPod Pがノード Nにスケジュール可能になるまでの時刻の間に間が開きます。この間、スケジューラーは他の待機状態のPodをスケジュールしようと試みます。プリエンプトされたPodが終了したら、スケジューラーは待ち行列にあるPodをスケジューリングしようと試みます。そのため、Podがプリエンプトされる時刻と、Pがスケジュールされた時刻には間が開くことが一般的です。この間を最小にするには、優先度の低いPodの猶予期間を0または小さい値にする方法があります。</p>
<h4 id=poddisruptionbudgetは対応するが-保証されない>PodDisruptionBudgetは対応するが、保証されない</h4>
<p><a href=/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a> (PDB)は、アプリケーションのオーナーが冗長化されたアプリケーションのPodが意図的に中断される数の上限を設定できるようにするものです。KubernetesはPodをプリエンプトする際にPDBに対応しますが、PDBはベストエフォートで考慮します。スケジューラーはプリエンプトさせたとしてもPDBに違反しないPodを探します。そのようなPodが見つからない場合でもプリエンプションは実行され、PDBに反しますが優先度の低いPodが追い出されます。</p>
<h4 id=優先度の低いpodにおけるpod間のアフィニティ>優先度の低いPodにおけるPod間のアフィニティ</h4>
<p>次の条件が真の場合のみ、ノードはプリエンプションの候補に入ります。
「待機状態のPodよりも優先度の低いPodをノードから全て追い出したら、待機状態のPodをノードへスケジュールできるか」</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> プリエンプションは必ずしも優先度の低いPodを全て追い出しません。
優先度の低いPodを全て追い出さなくても待機状態のPodがスケジューリングできる場合、一部のPodのみ追い出されます。
このような場合であったとしても、上記の条件は真である必要があります。偽であれば、そのノードはプリエンプションの対象とはされません。
</div>
<p>待機状態のPodが、優先度の低いPodとの間でPod間のアフィニティを持つ場合、Pod間のアフィニティはそれらの優先度の低いPodがなければ満たされません。この場合、スケジューラーはノードのどのPodもプリエンプトしようとはせず、代わりに他のノードを探します。スケジューラーは適切なノードを探せる場合と探せない場合があります。この場合、待機状態のPodがスケジューリングされる保証はありません。</p>
<p>この問題に対して推奨される解決策は、優先度が同一または高いPodに対してのみPod間のアフィニティを作成することです。</p>
<h4 id=複数ノードに対するプリエンプション>複数ノードに対するプリエンプション</h4>
<p>Pod PがノードNにスケジューリングできるよう、ノードNがプリエンプションの対象となったとします。
他のノードのPodがプリエンプトされた場合のみPが実行可能になることもあります。下記に例を示します。</p>
<ul>
<li>Pod PをノードNに配置することを検討します。</li>
<li>Pod QはノードNと同じゾーンにある別のノードで実行中です。</li>
<li>Pod Pはゾーンに対するQへのアンチアフィニティを持ちます (<code>topologyKey: topology.kubernetes.io/zone</code>)。</li>
<li>Pod Pと、ゾーン内の他のPodに対しては他のアンチアフィニティはない状態です。</li>
<li>Pod PをノードNへスケジューリングするには、Pod Qをプリエンプトすることが考えられますが、スケジューラーは複数ノードにわたるプリエンプションは行いません。そのため、Pod PはノードNへはスケジューリングできないとみなされます。</li>
</ul>
<p>Pod Qがそのノードから追い出されると、Podアンチアフィニティに違反しなくなるので、Pod PはノードNへスケジューリング可能になります。</p>
<p>複数ノードに対するプリエンプションに関しては、十分な需要があり、合理的な性能を持つアルゴリズムを見つけられた場合に、追加することを検討する可能性があります。</p>
<h2 id=トラブルシューティング>トラブルシューティング</h2>
<p>Podの優先度とプリエンプションは望まない副作用をもたらす可能性があります。
いくつかの起こりうる問題と、その対策について示します。</p>
<h3 id=podが不必要にプリエンプトされる>Podが不必要にプリエンプトされる</h3>
<p>プリエンプションは、リソースが不足している場合に優先度の高い待機状態のPodのためにクラスターの既存のPodを追い出します。
誤って高い優先度をPodに割り当てると、意図しない高い優先度のPodはクラスター内でプリエンプションを引き起こす可能性があります。Podの優先度はPodの仕様の<code>priorityClassName</code>フィールドにて指定されます。優先度を示す整数値へと変換された後、<code>podSpec</code>の<code>priority</code>へ設定されます。</p>
<p>この問題に対処するには、Podの<code>priorityClassName</code>をより低い優先度に変更するか、このフィールドを未設定にすることができます。<code>priorityClassName</code>が未設定の場合、デフォルトでは優先度は0とされます。</p>
<p>Podがプリエンプトされたとき、プリエンプトされたPodのイベントが記録されます。
プリエンプションはPodに必要なリソースがクラスターにない場合のみ起こるべきです。
このような場合、プリエンプションはプリエンプトされるPodよりも待機状態のPodの優先度が高い場合のみ発生します。
プリエンプションは待機状態のPodがない場合や待機状態のPodがプリエンプト対象のPod以下の優先度を持つ場合には決して発生しません。そのような状況でプリエンプションが発生した場合、問題を報告してください。</p>
<h3 id=podはプリエンプトされたが-プリエンプトさせたpodがスケジューリングされない>Podはプリエンプトされたが、プリエンプトさせたPodがスケジューリングされない</h3>
<p>Podがプリエンプトされると、それらのPodが要求した猶予期間が与えられます。そのデフォルトは30秒です。
Podがその期間内に終了しない場合、強制終了されます。プリエンプトされたPodがなくなれば、プリエンプトさせたPodはスケジューリング可能です。</p>
<p>プリエンプトさせたPodがプリエンプトされたPodの終了を待っている間に、より優先度の高いPodが同じノードに対して作成されることもあります。この場合、スケジューラーはプリエンプトさせたPodの代わりに優先度の高いPodをスケジューリングします。</p>
<p>これは予期された挙動です。優先度の高いPodは優先度の低いPodに取って代わります。</p>
<h3 id=優先度の高いpodが優先度の低いpodより先にプリエンプトされる>優先度の高いPodが優先度の低いPodより先にプリエンプトされる</h3>
<p>スケジューラーは待機状態のPodが実行可能なノードを探します。ノードが見つからない場合、スケジューラーは任意のノードから優先度の低いPodを追い出し、待機状態のPodのためのリソースを確保しようとします。
仮に優先度の低いPodが動いているノードが待機状態のPodを動かすために適切ではない場合、スケジューラーは他のノードで動いているPodと比べると、優先度の高いPodが動いているノードをプリエンプションの対象に選ぶことがあります。この場合もプリエンプトされるPodはプリエンプトを起こしたPodよりも優先度が低い必要があります。</p>
<p>複数のノードがプリエンプションの対象にできる場合、スケジューラーは優先度が最も低いPodのあるノードを選ぼうとします。しかし、そのようなPodがPodDisruptionBudgetを持っており、プリエンプトするとPDBに反する場合はスケジューラーは優先度の高いPodのあるノードを選ぶこともあります。</p>
<p>複数のノードがプリエンプションの対象として利用可能で、上記の状況に当てはまらない場合、スケジューラーは優先度の最も低いノードを選択します。</p>
<h2 id=interactions-of-pod-priority-and-qos>Podの優先度とQoSの相互作用</h2>
<p>Podの優先度と<a class=glossary-tooltip title="QoS Class (Quality of Service Class) provides a way for Kubernetes to classify pods within the cluster into several classes and make decisions about scheduling and eviction." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-qos-class" target=_blank aria-label=QoSクラス>QoSクラス</a>は直交する機能で、わずかに相互作用がありますが、デフォルトではQoSクラスによる優先度の設定の制約はありません。スケジューラーのプリエンプションのロジックはプリエンプションの対象を決めるときにQoSクラスは考慮しません。
プリエンプションはPodの優先度を考慮し、優先度が最も低いものを候補とします。より優先度の高いPodは優先度の低いPodを追い出すだけではプリエンプトを起こしたPodのスケジューリングに不十分な場合と、<code>PodDisruptionBudget</code>により優先度の低いPodが保護されている場合のみ対象になります。</p>
<p>QoSとPodの優先度の両方を考慮するコンポーネントは<a href=/docs/tasks/administer-cluster/out-of-resource/>リソース不足によりkubeletがPodを追い出す</a>のみです。
kubeletは追い出すPodの順位付けを次の順で行います。枯渇したリソースを要求以上に使用しているか、優先度、枯渇したリソースの消費量の複数のPodの要求に対する相対値。
詳細は<a href=/docs/tasks/administer-cluster/out-of-resource/#evicting-end-user-pods>エンドユーザーのPodの追い出し</a>を参照してください。</p>
<p>kubeletによるリソース不足時のPodの追い出しでは、リソースの消費が要求を超えないPodは追い出されません。優先度の低いPodのリソースの利用量がその要求を超えていなければ、追い出されることはありません。より優先度が高く、要求を超えてリソースを使用しているPodが追い出されます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>PriorityClassと関連付けてResourceQuotaを使用することに関して <a href=/ja/docs/concepts/policy/resource-quotas/#limit-priority-class-consumption-by-default>デフォルトで優先度クラスの消費を制限する</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-712cb3c03ff14a39e5a83a6d9b71d203>3.8 - セキュリティ</h1>
<div class=lead>クラウドネイティブなワークロードをセキュアに維持するための概念</div>
</div>
<div class=td-content>
<h1 id=pg-1fb24c1dd155f43849da490a74c4b8c5>3.8.1 - Podセキュリティの標準</h1>
<p>Podに対するセキュリティの設定は通常<a href=/docs/tasks/configure-pod-container/security-context/>Security Context</a>を使用して適用されます。Security ContextはPod単位での特権やアクセスコントロールの定義を実現します。</p>
<p>クラスターにおけるSecurity Contextの強制やポリシーベースの定義は<a href=/docs/concepts/policy/pod-security-policy/>Pod Security Policy</a>によって実現されてきました。
<em>Pod Security Policy</em> はクラスターレベルのリソースで、Pod定義のセキュリティに関する設定を制御します。</p>
<p>しかし、PodSecurityPolicyを拡張したり代替する、ポリシーを強制するための多くの方法が生まれてきました。
このページの意図は、推奨されるPodのセキュリティプロファイルを特定の実装から切り離して詳しく説明することです。</p>
<h2 id=ポリシーの種別>ポリシーの種別</h2>
<p>まず、幅広いセキュリティの範囲をカバーできる、基礎となるポリシーの定義が必要です。
それらは強く制限をかけるものから自由度の高いものまでをカバーすべきです。</p>
<ul>
<li><strong><em>特権</em></strong> - 制限のかかっていないポリシーで、可能な限り幅広い権限を提供します。このポリシーは既知の特権昇格を認めます。</li>
<li><strong><em>ベースライン、デフォルト</em></strong> - 制限は最小限にされたポリシーですが、既知の特権昇格を防止します。デフォルト（最小の指定）のPod設定を許容します。</li>
<li><strong><em>制限</em></strong> - 厳しく制限されたポリシーで、Podを強化するための現在のベストプラクティスに沿っています。</li>
</ul>
<h2 id=ポリシー>ポリシー</h2>
<h3 id=特権>特権</h3>
<p>特権ポリシーは意図的に開放されていて、完全に制限がかけられていません。この種のポリシーは通常、特権ユーザーまたは信頼されたユーザーが管理する、システムまたはインフラレベルのワークロードに対して適用されることを意図しています。</p>
<p>特権ポリシーは制限がないことと定義されます。gatekeeperのようにデフォルトで許可される仕組みでは、特権プロファイルはポリシーを設定せず、何も制限を適用しないことにあたります。
一方で、Pod Security Policyのようにデフォルトで拒否される仕組みでは、特権ポリシーでは全ての制限を無効化してコントロールできるようにする必要があります。</p>
<h3 id=ベースライン-デフォルト>ベースライン、デフォルト</h3>
<p>ベースライン、デフォルトのプロファイルは一般的なコンテナ化されたランタイムに適用しやすく、かつ既知の特権昇格を防ぐことを意図しています。
このポリシーはクリティカルではないアプリケーションの運用者または開発者を対象にしています。
次の項目は強制、または無効化すべきです。</p>
<table>
<caption style=display:none>ベースラインポリシーの定義</caption>
<tbody>
<tr>
<td><strong>項目</strong></td>
<td><strong>ポリシー</strong></td>
</tr>
<tr>
<td>ホストのネームスペース</td>
<td>
ホストのネームスペースの共有は無効化すべきです。<br>
<br><b>制限されるフィールド:</b><br>
spec.hostNetwork<br>
spec.hostPID<br>
spec.hostIPC<br>
<br><b>認められる値:</b> false<br>
</td>
</tr>
<tr>
<td>特権コンテナ</td>
<td>
特権を持つPodはほとんどのセキュリティ機構を無効化できるので、禁止すべきです。<br>
<br><b>制限されるフィールド:</b><br>
spec.containers[*].securityContext.privileged<br>
spec.initContainers[*].securityContext.privileged<br>
<br><b>認められる値:</b> false, undefined/nil<br>
</td>
</tr>
<tr>
<td>ケーパビリティー</td>
<td>
<a href=https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities>デフォルト</a>よりも多くのケーパビリティーを与えることは禁止すべきです。<br>
<br><b>制限されるフィールド:</b><br>
spec.containers[*].securityContext.capabilities.add<br>
spec.initContainers[*].securityContext.capabilities.add<br>
<br><b>認められる値:</b> 空 (または既知のリストに限定)<br>
</td>
</tr>
<tr>
<td>HostPathボリューム</td>
<td>
HostPathボリュームは禁止すべきです。<br>
<br><b>制限されるフィールド:</b><br>
spec.volumes[*].hostPath<br>
<br><b>認められる値:</b> undefined/nil<br>
</td>
</tr>
<tr>
<td>ホストのポート</td>
<td>
HostPortは禁止するか、最小限の既知のリストに限定すべきです。<br>
<br><b>制限されるフィールド:</b><br>
spec.containers[*].ports[*].hostPort<br>
spec.initContainers[*].ports[*].hostPort<br>
<br><b>認められる値:</b> 0, undefined (または既知のリストに限定)<br>
</td>
</tr>
<tr>
<td>AppArmor <em>(任意)</em></td>
<td>
サポートされるホストでは、AppArmorの'runtime/default'プロファイルがデフォルトで適用されます。デフォルトのポリシーはポリシーの上書きや無効化を防ぎ、許可されたポリシーのセットを上書きできないよう制限すべきです。<br>
<br><b>制限されるフィールド:</b><br>
metadata.annotations['container.apparmor.security.beta.kubernetes.io/*']<br>
<br><b>認められる値:</b> 'runtime/default', undefined<br>
</td>
</tr>
<tr>
<td>SELinux <em>(任意)</em></td>
<td>
SELinuxのオプションをカスタムで設定することは禁止すべきです。<br>
<br><b>制限されるフィールド:</b><br>
spec.securityContext.seLinuxOptions<br>
spec.containers[*].securityContext.seLinuxOptions<br>
spec.initContainers[*].securityContext.seLinuxOptions<br>
<br><b>認められる値:</b> undefined/nil<br>
</td>
</tr>
<tr>
<td>/procマウントタイプ</td>
<td>
攻撃対象を縮小するため/procのマスクを設定し、必須とすべきです。<br>
<br><b>制限されるフィールド:</b><br>
spec.containers[*].securityContext.procMount<br>
spec.initContainers[*].securityContext.procMount<br>
<br><b>認められる値:</b> undefined/nil, 'Default'<br>
</td>
</tr>
<tr>
<td>Sysctl</td>
<td>
Sysctlはセキュリティ機構を無効化したり、ホストの全てのコンテナに影響を与えたりすることが可能なので、「安全」なサブネットを除いては禁止すべきです。
コンテナまたはPodの中にsysctlがありネームスペースが分離されていて、同じノードの別のPodやプロセスから分離されている場合はsysctlは安全だと考えられます。<br>
<br><b>制限されるフィールド:</b><br>
spec.securityContext.sysctls<br>
<br><b>認められる値:</b><br>
kernel.shm_rmid_forced<br>
net.ipv4.ip_local_port_range<br>
net.ipv4.tcp_syncookies<br>
net.ipv4.ping_group_range<br>
undefined/空文字列<br>
</td>
</tr>
</tbody>
</table>
<h3 id=制限>制限</h3>
<p>制限ポリシーはいくらかの互換性を犠牲にして、Podを強化するためのベストプラクティスを強制することを意図しています。
セキュリティ上クリティカルなアプリケーションの運用者や開発者、また信頼度の低いユーザーも対象にしています。
下記の項目を強制、無効化すべきです。</p>
<table>
<caption style=display:none>制限ポリシーの定義</caption>
<tbody>
<tr>
<td><strong>項目</strong></td>
<td><strong>ポリシー</strong></td>
</tr>
<tr>
<td colspan=2><em>デフォルトプロファイルにある項目全て</em></td>
</tr>
<tr>
<td>Volumeタイプ</td>
<td>
HostPathボリュームの制限に加え、制限プロファイルではコアでない種類のボリュームの利用をPersistentVolumeにより定義されたものに限定します。<br>
<br><b>制限されるフィールド:</b><br>
spec.volumes[*].hostPath<br>
spec.volumes[*].gcePersistentDisk<br>
spec.volumes[*].awsElasticBlockStore<br>
spec.volumes[*].gitRepo<br>
spec.volumes[*].nfs<br>
spec.volumes[*].iscsi<br>
spec.volumes[*].glusterfs<br>
spec.volumes[*].rbd<br>
spec.volumes[*].flexVolume<br>
spec.volumes[*].cinder<br>
spec.volumes[*].cephFS<br>
spec.volumes[*].flocker<br>
spec.volumes[*].fc<br>
spec.volumes[*].azureFile<br>
spec.volumes[*].vsphereVolume<br>
spec.volumes[*].quobyte<br>
spec.volumes[*].azureDisk<br>
spec.volumes[*].portworxVolume<br>
spec.volumes[*].scaleIO<br>
spec.volumes[*].storageos<br>
spec.volumes[*].csi<br>
<br><b>認められる値:</b> undefined/nil<br>
</td>
</tr>
<tr>
<td>特権昇格</td>
<td>
特権昇格(ファイルモードのset-user-IDまたはset-group-IDのような方法による)は禁止すべきです。<br>
<br><b>制限されるフィールド:</b><br>
spec.containers[*].securityContext.allowPrivilegeEscalation<br>
spec.initContainers[*].securityContext.allowPrivilegeEscalation<br>
<br><b>認められる値:</b> false<br>
</td>
</tr>
<tr>
<td>root以外での実行</td>
<td>
コンテナはroot以外のユーザーで実行する必要があります。<br>
<br><b>制限されるフィールド:</b><br>
spec.securityContext.runAsNonRoot<br>
spec.containers[*].securityContext.runAsNonRoot<br>
spec.initContainers[*].securityContext.runAsNonRoot<br>
<br><b>認められる値:</b> true<br>
</td>
</tr>
<tr>
<td>root以外のグループ <em>(任意)</em></td>
<td>
コンテナをrootのプライマリまたは補助GIDで実行することを禁止すべきです。<br>
<br><b>制限されるフィールド:</b><br>
spec.securityContext.runAsGroup<br>
spec.securityContext.supplementalGroups[*]<br>
spec.securityContext.fsGroup<br>
spec.containers[*].securityContext.runAsGroup<br>
spec.initContainers[*].securityContext.runAsGroup<br>
<br><b>認められる値:</b><br>
0以外<br>
undefined / nil (`*.runAsGroup`を除く)<br>
</td>
</tr>
<tr>
<td>Seccomp</td>
<td>
SeccompのRuntimeDefaultを必須とする、または特定の追加プロファイルを許可することが必要です。<br>
<br><b>制限されるフィールド:</b><br>
spec.securityContext.seccompProfile.type<br>
spec.containers[*].securityContext.seccompProfile<br>
spec.initContainers[*].securityContext.seccompProfile<br>
<br><b>認められる値:</b><br>
'runtime/default'<br>
undefined / nil<br>
</td>
</tr>
</tbody>
</table>
<h2 id=ポリシーの実例>ポリシーの実例</h2>
<p>ポリシーの定義とポリシーの実装を切り離すことによって、ポリシーを強制する機構とは独立して、汎用的な理解や複数のクラスターにわたる共通言語とすることができます。</p>
<p>機構が成熟してきたら、ポリシーごとに下記に定義されます。それぞれのポリシーを強制する方法についてはここでは定義しません。</p>
<p><a href=/docs/concepts/policy/pod-security-policy/><strong>PodSecurityPolicy</strong></a></p>
<ul>
<li><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/privileged-psp.yaml>特権</a></li>
<li><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/baseline-psp.yaml>ベースライン</a></li>
<li><a href=https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/policy/restricted-psp.yaml>制限</a></li>
</ul>
<h2 id=faq>FAQ</h2>
<h3 id=特権とデフォルトの間のプロファイルがないのはどうしてですか>特権とデフォルトの間のプロファイルがないのはどうしてですか?</h3>
<p>ここで定義されている3つのプロファイルは最も安全(制限)から最も安全ではない(特権)まで、直線的に段階が設定されており、幅広いワークロードをカバーしています。
ベースラインを超える特権が必要な場合、その多くはアプリケーションに特化しているため、その限られた要求に対して標準的なプロファイルを提供することはできません。
これは、このような場合に必ず特権プロファイルを使用すべきだという意味ではなく、場合に応じてポリシーを定義する必要があります。</p>
<p>将来、他のプロファイルの必要性が明らかになった場合、SIG Authはこの方針について再考する可能性があります。</p>
<h3 id=セキュリティポリシーとセキュリティコンテキストの違いは何ですか>セキュリティポリシーとセキュリティコンテキストの違いは何ですか?</h3>
<p><a href=/docs/tasks/configure-pod-container/security-context/>Security Context</a>は実行時のコンテナやPodを設定するものです。
Security ContextはPodのマニフェストの中でPodやコンテナの仕様の一部として定義され、コンテナランタイムへ渡されるパラメータを示します。</p>
<p>セキュリティポリシーはコントロールプレーンの機構で、Security Contextとそれ以外も含め、特定の設定を強制するものです。
2020年2月時点では、ネイティブにサポートされているポリシー強制の機構は<a href=/docs/concepts/policy/pod-security-policy/>Pod Security
Policy</a>です。これはクラスター全体にわたってセキュリティポリシーを中央集権的に強制するものです。
セキュリティポリシーを強制する他の手段もKubernetesのエコシステムでは開発が進められています。例えば<a href=https://github.com/open-policy-agent/gatekeeper>OPA
Gatekeeper</a>があります。</p>
<h3 id=windowsのpodにはどのプロファイルを適用すればよいですか>WindowsのPodにはどのプロファイルを適用すればよいですか?</h3>
<p>Kubernetesでは、Linuxベースのワークロードと比べてWindowsの使用は制限や差異があります。
特に、PodのSecurityContextフィールドは<a href=/docs/setup/production-environment/windows/intro-windows-in-kubernetes/#v1-podsecuritycontext>Windows環境では効果がありません</a>。
したがって、現段階では標準化されたセキュリティポリシーは存在しません。</p>
<h3 id=サンドボックス化されたpodはどのように扱えばよいでしょうか>サンドボックス化されたPodはどのように扱えばよいでしょうか?</h3>
<p>現在のところ、Podがサンドボックス化されていると見なされるかどうかを制御できるAPI標準はありません。
サンドボックス化されたPodはサンドボックス化されたランタイム（例えばgVisorやKata Containers）の使用により特定することは可能ですが、サンドボックス化されたランタイムの標準的な定義は存在しません。</p>
<p>サンドボックス化されたランタイムに対して必要な保護は、それ以外に対するものとは異なります。
例えば、ワークロードがその基になるカーネルと分離されている場合、特権を制限する必要性は小さくなります。
これにより、強い権限を必要とするワークロードが隔離された状態を維持できます。</p>
<p>加えて、サンドボックス化されたワークロードの保護はサンドボックス化の実装に強く依存します。
したがって、全てのサンドボックス化されたワークロードに推奨される単一のポリシーは存在しません。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-04eeb110d75afc8acb2cf7a3db743985>3.8.2 - クラウドネイティブセキュリティの概要</h1>
<p>この概要では、クラウドネイティブセキュリティにおけるKubernetesのセキュリティを考えるためのモデルを定義します。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> コンテナセキュリティモデルは、実証済の情報セキュリティポリシーではなく提案を提供します。
</div>
<h2 id=クラウドネイティブセキュリティの４c>クラウドネイティブセキュリティの４C</h2>
<p>セキュリティは階層で考えることができます。クラウドネイティブの4Cは、クラウド、クラスター、コンテナ、そしてコードです。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 階層化されたアプローチは、セキュリティに対する<a href=https://en.wikipedia.org/wiki/Defense_in_depth_(computing)>多層防御</a>のアプローチを強化します。これはソフトウェアシステムを保護するベストプラクティスとして幅広く認知されています。
</div>
<figure>
<img src=/images/docs/4c.png> <figcaption>
<h4>クラウドネイティブセキュリティの４C</h4>
</figcaption>
</figure>
<p>クラウドネイティブセキュリティモデルの各レイヤーは次の最も外側のレイヤー上に構築します。コードレイヤーは、強固な基盤(クラウド、クラスター、コンテナ)セキュリティレイヤーから恩恵を受けます。コードレベルのセキュリティに対応しても基盤レイヤーが低い水準のセキュリティでは守ることができません。</p>
<h2 id=クラウド>クラウド</h2>
<p>いろいろな意味でも、クラウド(または同じ場所に設置されたサーバー、企業のデータセンター)はKubernetesクラスターの<a href=https://en.wikipedia.org/wiki/Trusted_computing_base>トラステッド・コンピューティング・ベース</a>です。クラウドレイヤーが脆弱な(または脆弱な方法で構成されている)場合、この基盤の上に構築されたコンポーネントが安全であるという保証はありません。各クラウドプロバイダーは、それぞれの環境でワークロードを安全に実行させるためのセキュリティの推奨事項を作成しています。</p>
<h3 id=クラウドプロバイダーのセキュリティ>クラウドプロバイダーのセキュリティ</h3>
<p>Kubernetesクラスターを所有しているハードウェアや様々なクラウドプロバイダー上で実行している場合、セキュリティのベストプラクティスに関するドキュメントを参考にしてください。ここでは人気のあるクラウドプロバイダーのセキュリティドキュメントの一部のリンクを紹介します。</p>
<table><caption style=display:none>Cloud provider security</caption>
<thead>
<tr>
<th>IaaSプロバイダー</th>
<th>リンク</th>
</tr>
</thead>
<tbody>
<tr>
<td>Alibaba Cloud</td>
<td><a href=https://www.alibabacloud.com/trust-center>https://www.alibabacloud.com/trust-center</a></td>
</tr>
<tr>
<td>Amazon Web Services</td>
<td><a href=https://aws.amazon.com/security/>https://aws.amazon.com/security/</a></td>
</tr>
<tr>
<td>Google Cloud Platform</td>
<td><a href=https://cloud.google.com/security/>https://cloud.google.com/security/</a></td>
</tr>
<tr>
<td>IBM Cloud</td>
<td><a href=https://www.ibm.com/cloud/security>https://www.ibm.com/cloud/security</a></td>
</tr>
<tr>
<td>Microsoft Azure</td>
<td><a href=https://docs.microsoft.com/en-us/azure/security/azure-security>https://docs.microsoft.com/en-us/azure/security/azure-security</a></td>
</tr>
<tr>
<td>Oracle Cloud Infrastructure</td>
<td><a href=https://www.oracle.com/security/>https://www.oracle.com/security/</a></td>
</tr>
<tr>
<td>VMWare VSphere</td>
<td><a href=https://www.vmware.com/security/hardening-guides.html>https://www.vmware.com/security/hardening-guides.html</a></td>
</tr>
</tbody>
</table>
<h3 id=infrastructure-security>インフラのセキュリティ</h3>
<p>Kubernetesクラスターのインフラを保護するための提案です。</p>
<table><caption style=display:none>Infrastructure security</caption>
<thead>
<tr>
<th>Kubernetesインフラに関する懸念事項</th>
<th>推奨事項</th>
</tr>
</thead>
<tbody>
<tr>
<td>API Server(コントロールプレーン)へのネットワークアクセス</td>
<td>Kubernetesコントロールプレーンへのすべてのアクセスは、インターネット上での一般公開は許されず、クラスター管理に必要なIPアドレスに制限するネットワークアクセス制御リストによって制御されます。</td>
</tr>
<tr>
<td>Nodeへのネットワークアクセス</td>
<td>Nodeはコントロールプレーンの特定ポート <em>のみ</em> 接続(ネットワークアクセス制御リストを介して)を受け入れるよう設定し、NodePortとLoadBalancerタイプのKubernetesのServiceに関する接続を受け入れるよう設定する必要があります。可能であれば、それらのNodeはパブリックなインターネットに完全公開しないでください。</td>
</tr>
<tr>
<td>KubernetesからのクラウドプロバイダーAPIへのアクセス</td>
<td>各クラウドプロバイダーはKubernetesコントロールプレーンとNodeに異なる権限を与える必要があります。<a href=https://en.wikipedia.org/wiki/Principle_of_least_privilege>最小権限の原則</a>に従い、管理に必要なリソースに対してクラウドプロバイダーへのアクセスをクラスターに提供するのが最善です。<a href=https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles>Kopsドキュメント</a>にはIAMのポリシーとロールについての情報が記載されています。</td>
</tr>
<tr>
<td>etcdへのアクセス</td>
<td>etcd(Kubernetesのデータストア)へのアクセスはコントロールプレーンのみに制限すべきです。設定によっては、TLS経由でetcdを利用する必要があります。詳細な情報は<a href=https://github.com/etcd-io/etcd/tree/master/Documentation>etcdドキュメント</a>を参照してください。</td>
</tr>
<tr>
<td>etcdの暗号化</td>
<td>可能な限り、保存時に全ドライブを暗号化することは良いプラクティスですが、etcdはクラスター全体(Secretを含む)の状態を保持しているため、そのディスクは特に暗号化する必要があります。</td>
</tr>
</tbody>
</table>
<h2 id=クラスター>クラスター</h2>
<p>Kubernetesを保護する為には２つの懸念事項があります。</p>
<ul>
<li>設定可能なクラスターコンポーネントの保護</li>
<li>クラスターで実行されるアプリケーションの保護</li>
</ul>
<h3 id=cluster-components>クラスターのコンポーネント</h3>
<p>想定外または悪意のあるアクセスからクラスターを保護して適切なプラクティスを採用したい場合、<a href=/docs/tasks/administer-cluster/securing-a-cluster/>クラスターの保護</a>に関するアドバイスを読み従ってください。</p>
<h3 id=cluster-applications>クラスター内のコンポーネント(アプリケーション)</h3>
<p>アプリケーションを対象にした攻撃に応じて、セキュリティの特定側面に焦点をあてたい場合があります。例:他のリソースとの連携で重要なサービス(サービスA)と、リソース枯渇攻撃に対して脆弱な別のワークロード(サービスB)が実行されている場合、サービスBのリソースを制限していないとサービスAが危険にさらされるリスクが高くなります。次の表はセキュリティの懸念事項とKubernetesで実行されるワークロードを保護するための推奨事項を示しています。</p>
<table>
<thead>
<tr>
<th>ワークロードセキュリティに関する懸念事項</th>
<th>推奨事項</th>
</tr>
</thead>
<tbody>
<tr>
<td>RBAC認可(Kubernetes APIへのアクセス)</td>
<td><a href=https://kubernetes.io/ja/docs/reference/access-authn-authz/rbac/>https://kubernetes.io/ja/docs/reference/access-authn-authz/rbac/</a></td>
</tr>
<tr>
<td>認証</td>
<td><a href=https://kubernetes.io/docs/concepts/security/controlling-access/>https://kubernetes.io/docs/concepts/security/controlling-access/</a></td>
</tr>
<tr>
<td>アプリケーションのSecret管理(およびetcdへの保存時に暗号化)</td>
<td><a href=https://kubernetes.io/ja/docs/concepts/configuration/secret/>https://kubernetes.io/ja/docs/concepts/configuration/secret/</a> <br> <a href=https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/>https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/</a></td>
</tr>
<tr>
<td>PodSecurityPolicy</td>
<td><a href=https://kubernetes.io/docs/concepts/policy/pod-security-policy/>https://kubernetes.io/docs/concepts/policy/pod-security-policy/</a></td>
</tr>
<tr>
<td>Quality of Service (およびクラスターリソース管理)</td>
<td><a href=https://kubernetes.io/ja/docs/tasks/configure-pod-container/quality-service-pod/>https://kubernetes.io/ja/docs/tasks/configure-pod-container/quality-service-pod/</a></td>
</tr>
<tr>
<td>NetworkPolicy</td>
<td><a href=https://kubernetes.io/ja/docs/concepts/services-networking/network-policies/>https://kubernetes.io/ja/docs/concepts/services-networking/network-policies/</a></td>
</tr>
<tr>
<td>Kubernetes IngressのTLS</td>
<td><a href=https://kubernetes.io/ja/docs/concepts/services-networking/ingress/#tls>https://kubernetes.io/ja/docs/concepts/services-networking/ingress/#tls</a></td>
</tr>
</tbody>
</table>
<h2 id=コンテナ>コンテナ</h2>
<p>コンテナセキュリティは本ガイドの範囲外になります。このトピックを検索するために一般的な推奨事項とリンクを以下に示します。</p>
<table>
<thead>
<tr>
<th>コンテナに関する懸念事項</th>
<th>推奨事項</th>
</tr>
</thead>
<tbody>
<tr>
<td>コンテナの脆弱性スキャンとOS依存のセキュリティ</td>
<td>イメージをビルドする手順の一部として、既知の脆弱性がないかコンテナをスキャンする必要があります。</td>
</tr>
<tr>
<td>イメージの署名と実施</td>
<td>コンテナイメージを署名し、コンテナの中身に関する信頼性を維持します。</td>
</tr>
<tr>
<td>特権ユーザーを許可しない</td>
<td>コンテナの構成時に、コンテナの目的を実行するために必要最低限なOS特権を持ったユーザーをコンテナ内部に作成する方法のドキュメントを参考にしてください。</td>
</tr>
</tbody>
</table>
<h2 id=コード>コード</h2>
<p>アプリケーションコードは、あなたが最も制御できる主要な攻撃対象のひとつです。アプリケーションコードを保護することはKubernetesのセキュリティトピックの範囲外ですが、アプリケーションコードを保護するための推奨事項を以下に示します。</p>
<h3 id=コードセキュリティ>コードセキュリティ</h3>
<table><caption style=display:none>Code security</caption>
<thead>
<tr>
<th>コードに関する懸念事項</th>
<th>推奨事項</th>
</tr>
</thead>
<tbody>
<tr>
<td>TLS経由のアクセスのみ</td>
<td>コードがTCP通信を必要とする場合は、事前にクライアントとのTLSハンドシェイクを実行してください。 いくつかの例外を除いて、全ての通信を暗号化してください。さらに一歩すすめて、サービス間のネットワークトラフィックを暗号化することはよい考えです。これは、サービスを特定した2つの証明書で通信の両端を検証する相互認証、または<a href=https://en.wikipedia.org/wiki/Mutual_authentication>mTLS</a>して知られているプロセスを通じて実行できます。</td>
</tr>
<tr>
<td>通信ポートの範囲制限</td>
<td>この推奨事項は一目瞭然かもしれませんが、可能なかぎり、通信とメトリクス収集に必要不可欠なサービスのポートのみを公開します。</td>
</tr>
<tr>
<td>サードパティに依存するセキュリティ</td>
<td>既知の脆弱性についてアプリケーションのサードパーティ製ライブラリーを定期的にスキャンすることを推奨します。それぞれの言語は自動でこのチェックを実行するツールを持っています。</td>
</tr>
<tr>
<td>静的コード解析</td>
<td>ほとんどの言語ではコードのスニペットを解析して、安全でない可能性のあるコーディングを分析する方法が提供しています。可能な限り、コードベースでスキャンして、よく起こるセキュリティエラーを検出できる自動ツールを使用してチェックを実行すべきです。一部のツールはここで紹介されています。 <a href=https://owasp.org/www-community/Source_Code_Analysis_Tools>https://owasp.org/www-community/Source_Code_Analysis_Tools</a></td>
</tr>
<tr>
<td>動的プロービング攻撃</td>
<td>よく知られているいくつかのサービス攻撃をサービスに対して試すことができる自動ツールがいくつかあります。これにはSQLインジェクション、CSRF、そしてXSSが含まれます。よく知られている動的解析ツールは<a href=https://owasp.org/www-project-zap/>OWASP Zed Attack proxy</a>toolです。</td>
</tr>
</tbody>
</table>
<h2 id=次の項目>次の項目</h2>
<p>関連するKubernetesセキュリティについて学びます。</p>
<ul>
<li><a href=/ja/docs/concepts/security/pod-security-standards/>Podセキュリティの標準</a></li>
<li>[Podのネットワークポリシー]](/ja/docs/concepts/services-networking/network-policies/)</li>
<li><a href=/docs/concepts/security/controlling-access>Kubernetes APIへのアクセスを制御する</a></li>
<li><a href=/docs/tasks/administer-cluster/securing-a-cluster/>クラスターの保護</a></li>
<li>コントロールプレーンとの<a href=/docs/tasks/tls/managing-tls-in-a-cluster/>通信時のデータ暗号化</a></li>
<li><a href=/docs/tasks/administer-cluster/encrypt-data/>保存時のデータ暗号化</a></li>
<li><a href=/ja/docs/concepts/configuration/secret/>Kubernetes Secret</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c21d05f31057c5bcd2ebdd01f4e62a0e>3.9 - スケジューリングと退避</h1>
<div class=lead>Kubernetesにおいてスケジューリングとは、稼働させたいPodをNodeにマッチさせ、kubeletが実行できるようにすることを指します。 退避とは、リソース不足のNodeで1つ以上のPodを積極的に停止させるプロセスです。</div>
</div>
<div class=td-content>
<h1 id=pg-21169f516071aea5d16734a4c27789a5>3.9.1 - Node上へのPodのスケジューリング</h1>
<p><a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>が稼働する<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>を特定のものに指定したり、優先条件を指定して制限することができます。
これを実現するためにはいくつかの方法がありますが、推奨されている方法は<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベルでの選択</a>です。
スケジューラーが最適な配置を選択するため、一般的にはこのような制限は不要です(例えば、複数のPodを別々のNodeへデプロイしたり、Podを配置する際にリソースが不十分なNodeにはデプロイされないことが挙げられます)が、
SSDが搭載されているNodeにPodをデプロイしたり、同じアベイラビリティーゾーン内で通信する異なるサービスのPodを同じNodeにデプロイする等、柔軟な制御が必要なこともあります。</p>
<h2 id=nodeselector>nodeSelector</h2>
<p><code>nodeSelector</code>は、Nodeを選択するための、最も簡単で推奨されている手法です。
<code>nodeSelector</code>はPodSpecのフィールドです。これはkey-valueペアのマップを特定します。
あるノードでPodを稼働させるためには、そのノードがラベルとして指定されたkey-valueペアを保持している必要があります(複数のラベルを保持することも可能です)。
最も一般的な使用方法は、1つのkey-valueペアを付与する方法です。</p>
<p>以下に、<code>nodeSelector</code>の使用例を紹介します。</p>
<h3 id=ステップ0-前提条件>ステップ0: 前提条件</h3>
<p>この例では、KubernetesのPodに関して基本的な知識を有していることと、<a href=/ja/docs/setup/>Kubernetesクラスターのセットアップ</a>がされていることが前提となっています。</p>
<h3 id=ステップ1-nodeへのラベルの付与>ステップ1: Nodeへのラベルの付与</h3>
<p><code>kubectl get nodes</code>で、クラスターのノードの名前を取得してください。
そして、ラベルを付与するNodeを選び、<code>kubectl label nodes &lt;node-name> &lt;label-key>=&lt;label-value></code>で選択したNodeにラベルを付与します。
例えば、Nodeの名前が'kubernetes-foo-node-1.c.a-robinson.internal'、付与するラベルが'disktype=ssd'の場合、<code>kubectl label nodes kubernetes-foo-node-1.c.a-robinson.internal disktype=ssd</code>によってラベルが付与されます。</p>
<p><code>kubectl get nodes --show-labels</code>によって、ノードにラベルが付与されたかを確認することができます。
また、<code>kubectl describe node "nodename"</code>から、そのNodeの全てのラベルを表示することもできます。</p>
<h3 id=ステップ2-podへのnodeselectorフィールドの追加>ステップ2: PodへのnodeSelectorフィールドの追加</h3>
<p>該当のPodのconfigファイルに、nodeSelectorのセクションを追加します:
例として以下のconfigファイルを扱います:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div><p>nodeSelectorを以下のように追加します:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-nginx.yaml download=pods/pod-nginx.yaml><code>pods/pod-nginx.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-yaml')" title="Copy pods/pod-nginx.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>disktype</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p><code>kubectl apply -f https://k8s.io/examples/pods/pod-nginx.yaml</code>により、Podは先ほどラベルを付与したNodeへスケジュールされます。
<code>kubectl get pods -o wide</code>で表示される"NODE"の列から、PodがデプロイされているNodeを確認することができます。</p>
<h2 id=built-in-node-labels>補足: ビルトインNodeラベル</h2>
<p>明示的に<a href=#step-one-attach-label-to-the-node>付与</a>するラベルの他に、事前にNodeへ付与されているものもあります。
これらのラベルのリストは、<a href=/docs/reference/kubernetes-api/labels-annotations-taints/>Well-Known Labels, Annotations and Taints</a>を参照してください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> これらのラベルは、クラウドプロバイダー固有であり、確実なものではありません。
例えば、<code>kubernetes.io/hostname</code>の値はNodeの名前と同じである環境もあれば、異なる環境もあります。
</div>
<h2 id=nodeの隔離や制限>Nodeの隔離や制限</h2>
<p>Nodeにラベルを付与することで、Podは特定のNodeやNodeグループにスケジュールされます。
これにより、特定のPodを、確かな隔離性や安全性、特性を持ったNodeで稼働させることができます。
この目的でラベルを使用する際に、Node上のkubeletプロセスに上書きされないラベルキーを選択することが強く推奨されています。
これは、安全性が損なわれたNodeがkubeletの認証情報をNodeのオブジェクトに設定したり、スケジューラーがそのようなNodeにデプロイすることを防ぎます。</p>
<p><code>NodeRestriction</code>プラグインは、kubeletが<code>node-restriction.kubernetes.io/</code>プレフィックスを有するラベルの設定や上書きを防ぎます。
Nodeの隔離にラベルのプレフィックスを使用するためには、以下のようにします。</p>
<ol>
<li><a href=/docs/reference/access-authn-authz/node/>Node authorizer</a>を使用していることと、<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a>が <em>有効</em> になっていること。</li>
<li>Nodeに<code>node-restriction.kubernetes.io/</code> プレフィックスのラベルを付与し、そのラベルがnode selectorに指定されていること。
例えば、<code>example.com.node-restriction.kubernetes.io/fips=true</code> または <code>example.com.node-restriction.kubernetes.io/pci-dss=true</code>のようなラベルです。</li>
</ol>
<h2 id=affinity-and-anti-affinity>アフィニティとアンチアフィニティ</h2>
<p><code>nodeSelector</code>はPodの稼働を特定のラベルが付与されたNodeに制限する最も簡単な方法です。
アフィニティ/アンチアフィニティでは、より柔軟な指定方法が提供されています。
拡張機能は以下の通りです。</p>
<ol>
<li>アフィニティ/アンチアフィニティという用語はとても表現豊かです。この用語は論理AND演算で作成された完全一致だけではなく、より多くのマッチングルールを提供します。</li>
<li>必須条件ではなく優先条件を指定でき、条件を満たさない場合でもPodをスケジュールさせることができます。</li>
<li>Node自体のラベルではなく、Node(または他のトポロジカルドメイン)上で稼働している他のPodのラベルに対して条件を指定することができ、そのPodと同じ、または異なるドメインで稼働させることができます。</li>
</ol>
<p>アフィニティは"Nodeアフィニティ"と"Pod間アフィニティ/アンチアフィニティ"の2種類から成ります。
Nodeアフィニティは<code>nodeSelector</code>(前述の2つのメリットがあります)に似ていますが、Pod間アフィニティ/アンチアフィニティは、上記の3番目の機能に記載している通り、NodeのラベルではなくPodのラベルに対して制限をかけます。</p>
<h3 id=nodeアフィニティ>Nodeアフィニティ</h3>
<p>Nodeアフィニティは概念的には、NodeのラベルによってPodがどのNodeにスケジュールされるかを制限する<code>nodeSelector</code>と同様です。</p>
<p>現在は2種類のNodeアフィニティがあり、<code>requiredDuringSchedulingIgnoredDuringExecution</code>と<code>preferredDuringSchedulingIgnoredDuringExecution</code>です。
前者はNodeにスケジュールされるPodが条件を満たすことが必須(<code>nodeSelector</code>に似ていますが、より柔軟に条件を指定できます)であり、後者は条件を指定できますが保証されるわけではなく、優先的に考慮されます。
"IgnoredDuringExecution"の意味するところは、<code>nodeSelector</code>の機能と同様であり、Nodeのラベルが変更され、Podがその条件を満たさなくなった場合でも
PodはそのNodeで稼働し続けるということです。
将来的には、<code>requiredDuringSchedulingIgnoredDuringExecution</code>に、PodのNodeアフィニティに記された必須要件を満たさなくなったNodeからそのPodを退避させることができる機能を備えた<code>requiredDuringSchedulingRequiredDuringExecution</code>が提供される予定です。</p>
<p>それぞれの使用例として、
<code>requiredDuringSchedulingIgnoredDuringExecution</code> は、"インテルCPUを供えたNode上でPodを稼働させる"、
<code>preferredDuringSchedulingIgnoredDuringExecution</code>は、"ゾーンXYZでPodの稼働を試みますが、実現不可能な場合には他の場所で稼働させる"
といった方法が挙げられます。</p>
<p>Nodeアフィニティは、PodSpecの<code>affinity</code>フィールドにある<code>nodeAffinity</code>フィールドで特定します。</p>
<p>Nodeアフィニティを使用したPodの例を以下に示します:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-with-node-affinity.yaml download=pods/pod-with-node-affinity.yaml><code>pods/pod-with-node-affinity.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-with-node-affinity-yaml')" title="Copy pods/pod-with-node-affinity.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-with-node-affinity-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-node-affinity<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>kubernetes.io/e2e-az-name<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- e2e-az1<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- e2e-az2<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>preference</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>another-node-label-key<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- another-node-label-value<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-node-affinity<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0</code></pre></div>
</div>
</div>
<p>このNodeアフィニティでは、Podはキーが<code>kubernetes.io/e2e-az-name</code>、値が<code>e2e-az1</code>または<code>e2e-az2</code>のラベルが付与されたNodeにしか配置されません。
加えて、キーが<code>another-node-label-key</code>、値が<code>another-node-label-value</code>のラベルが付与されたNodeが優先されます。</p>
<p>この例ではオペレーター<code>In</code>が使われています。
Nodeアフィニティでは、<code>In</code>、<code>NotIn</code>、<code>Exists</code>、<code>DoesNotExist</code>、<code>Gt</code>、<code>Lt</code>のオペレーターが使用できます。
<code>NotIn</code>と<code>DoesNotExist</code>はNodeアンチアフィニティ、またはPodを特定のNodeにスケジュールさせない場合に使われる<a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>Taints</a>に使用します。</p>
<p><code>nodeSelector</code>と<code>nodeAffinity</code>の両方を指定した場合、Podは<strong>両方の</strong>条件を満たすNodeにスケジュールされます。</p>
<p><code>nodeAffinity</code>内で複数の<code>nodeSelectorTerms</code>を指定した場合、Podは<strong>いずれかの</strong><code>nodeSelectorTerms</code>を満たしたNodeへスケジュールされます。</p>
<p><code>nodeSelectorTerms</code>内で複数の<code>matchExpressions</code>を指定した場合にはPodは<strong>全ての</strong><code>matchExpressions</code>を満たしたNodeへスケジュールされます。</p>
<p>PodがスケジュールされたNodeのラベルを削除したり変更しても、Podは削除されません。
言い換えると、アフィニティはPodをスケジュールする際にのみ考慮されます。</p>
<p><code>preferredDuringSchedulingIgnoredDuringExecution</code>内の<code>weight</code>フィールドは、1から100の範囲で指定します。
全ての必要条件(リソースやRequiredDuringSchedulingアフィニティ等)を満たしたNodeに対して、スケジューラーはそのNodeがMatchExpressionsを満たした場合に、このフィルードの"weight"を加算して合計を計算します。
このスコアがNodeの他の優先機能のスコアと組み合わせれ、最も高いスコアを有したNodeが優先されます。</p>
<h3 id=pod間アフィニティとアンチアフィニティ>Pod間アフィニティとアンチアフィニティ</h3>
<p>Pod間アフィニティとアンチアフィニティは、Nodeのラベルではなく、すでにNodeで稼働しているPodのラベルに従ってPodがスケジュールされるNodeを制限します。
このポリシーは、"XにてルールYを満たすPodがすでに稼働している場合、このPodもXで稼働させる(アンチアフィニティの場合は稼働させない)"という形式です。
Yはnamespaceのリストで指定したLabelSelectorで表されます。
Nodeと異なり、Podはnamespaceで区切られているため(それゆえPodのラベルも暗黙的にnamespaceで区切られます)、Podのラベルを指定するlabel selectorは、どのnamespaceにselectorを適用するかを指定する必要があります。
概念的に、XはNodeや、ラック、クラウドプロバイダゾーン、クラウドプロバイダのリージョン等を表すトポロジードメインです。
これらを表すためにシステムが使用するNodeラベルのキーである<code>topologyKey</code>を使うことで、トポロジードメインを指定することができます。
先述のセクション<a href=#interlude-built-in-node-labels>補足: ビルトインNodeラベル</a>にてラベルの例が紹介されています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Pod間アフィニティとアンチアフィニティは、大規模なクラスター上で使用する際にスケジューリングを非常に遅くする恐れのある多くの処理を要します。
そのため、数百台以上のNodeから成るクラスターでは使用することを推奨されません。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Podのアンチアフィニティは、Nodeに必ずラベルが付与されている必要があります。
言い換えると、クラスターの全てのNodeが、<code>topologyKey</code>で指定されたものに合致する適切なラベルが必要になります。
それらが付与されていないNodeが存在する場合、意図しない挙動を示すことがあります。
</div>
<p>Nodeアフィニティと同様に、PodアフィニティとPodアンチアフィニティにも必須条件と優先条件を示す<code>requiredDuringSchedulingIgnoredDuringExecution</code>と<code>preferredDuringSchedulingIgnoredDuringExecution</code>があります。
前述のNodeアフィニティのセクションを参照してください。
<code>requiredDuringSchedulingIgnoredDuringExecution</code>を指定するアフィニティの使用例は、"Service AのPodとService BのPodが密に通信する際、それらを同じゾーンで稼働させる場合"です。
また、<code>preferredDuringSchedulingIgnoredDuringExecution</code>を指定するアンチアフィニティの使用例は、"ゾーンをまたいでPodのサービスを稼働させる場合"(Podの数はゾーンの数よりも多いため、必須条件を指定すると合理的ではありません)です。</p>
<p>Pod間アフィニティは、PodSpecの<code>affinity</code>フィールド内に<code>podAffinity</code>で指定し、Pod間アンチアフィニティは、<code>podAntiAffinity</code>で指定します。</p>
<h4 id=podアフィニティを使用したpodの例>Podアフィニティを使用したPodの例</h4>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-with-pod-affinity.yaml download=pods/pod-with-pod-affinity.yaml><code>pods/pod-with-pod-affinity.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-with-pod-affinity-yaml')" title="Copy pods/pod-with-pod-affinity.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-with-pod-affinity-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-pod-affinity<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>security<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- S1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAffinityTerm</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>security<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- S2<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>kubernetes.io/hostname<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-pod-affinity<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>このPodのアフィニティは、PodアフィニティとPodアンチアフィニティを1つずつ定義しています。
この例では、<code>podAffinity</code>に<code>requiredDuringSchedulingIgnoredDuringExecution</code>、<code>podAntiAffinity</code>に<code>preferredDuringSchedulingIgnoredDuringExecution</code>が設定されています。
Podアフィニティは、「キーが"security"、値が"S1"のラベルが付与されたPodが少なくとも1つは稼働しているNodeが同じゾーンにあれば、PodはそのNodeにスケジュールされる」という条件を指定しています(より正確には、キーが"security"、値が"S1"のラベルが付与されたPodが稼働しており、キーが<code>topology.kubernetes.io/zone</code>、値がVであるNodeが少なくとも1つはある状態で、
Node Nがキー<code>topology.kubernetes.io/zone</code>、値Vのラベルを持つ場合に、PodはNode Nで稼働させることができます)。
Podアンチアフィニティは、「すでにあるNode上で、キーが"security"、値が"S2"であるPodが稼働している場合に、Podを可能な限りそのNode上で稼働させない」という条件を指定しています
(<code>topologyKey</code>が<code>topology.kubernetes.io/zone</code>であった場合、キーが"security"、値が"S2"であるであるPodが稼働しているゾーンと同じゾーン内のNodeにはスケジュールされなくなります)。
PodアフィニティとPodアンチアフィニティや、<code>requiredDuringSchedulingIgnoredDuringExecution</code>と<code>preferredDuringSchedulingIgnoredDuringExecution</code>に関する他の使用例は<a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/podaffinity.md>デザインドック</a>を参照してください。</p>
<p>PodアフィニティとPodアンチアフィニティで使用できるオペレーターは、<code>In</code>、<code>NotIn</code>、 <code>Exists</code>、 <code>DoesNotExist</code>です。</p>
<p>原則として、<code>topologyKey</code>には任意のラベルとキーが使用できます。
しかし、パフォーマンスやセキュリティの観点から、以下の制約があります:</p>
<ol>
<li>アフィニティと、<code>requiredDuringSchedulingIgnoredDuringExecution</code>を指定したPodアンチアフィニティは、<code>topologyKey</code>を指定しないことは許可されていません。</li>
<li><code>requiredDuringSchedulingIgnoredDuringExecution</code>を指定したPodアンチアフィニティでは、<code>kubernetes.io/hostname</code>の<code>topologyKey</code>を制限するため、アドミッションコントローラー<code>LimitPodHardAntiAffinityTopology</code>が導入されました。
トポロジーをカスタマイズする場合には、アドミッションコントローラーを修正または無効化する必要があります。</li>
<li><code>preferredDuringSchedulingIgnoredDuringExecution</code>を指定したPodアンチアフィニティでは、<code>topologyKey</code>を省略することはできません。</li>
<li>上記の場合を除き、<code>topologyKey</code> は任意のラベルとキーを指定することができます。</li>
</ol>
<p><code>labelSelector</code>と<code>topologyKey</code>に加え、<code>labelSelector</code>が合致すべき<code>namespaces</code>のリストを特定することも可能です(これは<code>labelSelector</code>と<code>topologyKey</code>を定義することと同等です)。
省略した場合や空の場合は、アフィニティとアンチアフィニティが定義されたPodのnamespaceがデフォルトで設定されます。</p>
<p><code>requiredDuringSchedulingIgnoredDuringExecution</code>が指定されたアフィニティとアンチアフィニティでは、<code>matchExpressions</code>に記載された全ての条件が満たされるNodeにPodがスケジュールされます。</p>
<h4 id=実際的なユースケース>実際的なユースケース</h4>
<p>Pod間アフィニティとアンチアフィニティは、ReplicaSet、StatefulSet、Deploymentなどのより高レベルなコレクションと併せて使用するとさらに有用です。
Workloadが、Node等の定義された同じトポロジーに共存させるよう、簡単に設定できます。</p>
<h5 id=常に同じnodeで稼働させる場合>常に同じNodeで稼働させる場合</h5>
<p>３つのノードから成るクラスターでは、ウェブアプリケーションはredisのようにインメモリキャッシュを保持しています。
このような場合、ウェブサーバーは可能な限りキャッシュと共存させることが望ましいです。</p>
<p>ラベル<code>app=store</code>を付与した3つのレプリカから成るredisのdeploymentを記述したyamlファイルを示します。
Deploymentには、1つのNodeにレプリカを共存させないために<code>PodAntiAffinity</code>を付与しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-cache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>store<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>store<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span>- store<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-server<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis:3.2-alpine<span style=color:#bbb>
</span></code></pre></div><p>ウェブサーバーのDeploymentを記載した以下のyamlファイルには、<code>podAntiAffinity</code> と<code>podAffinity</code>が設定されています。
全てのレプリカが<code>app=store</code>のラベルが付与されたPodと同じゾーンで稼働するよう、スケジューラーに設定されます。
また、それぞれのウェブサーバーは1つのノードで稼働されないことも保証されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web-server<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>web-store<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>web-store<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span>- web-store<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span>- store<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web-app<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16-alpine<span style=color:#bbb>
</span></code></pre></div><p>上記2つのDeploymentが生成されると、3つのノードは以下のようになります。</p>
<table>
<thead>
<tr>
<th style=text-align:center>node-1</th>
<th style=text-align:center>node-2</th>
<th style=text-align:center>node-3</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:center><em>webserver-1</em></td>
<td style=text-align:center><em>webserver-2</em></td>
<td style=text-align:center><em>webserver-3</em></td>
</tr>
<tr>
<td style=text-align:center><em>cache-1</em></td>
<td style=text-align:center><em>cache-2</em></td>
<td style=text-align:center><em>cache-3</em></td>
</tr>
</tbody>
</table>
<p>このように、3つの<code>web-server</code>は期待通り自動的にキャッシュと共存しています。</p>
<pre><code>kubectl get pods -o wide
</code></pre><p>出力は以下のようになります:</p>
<pre><code>NAME                           READY     STATUS    RESTARTS   AGE       IP           NODE
redis-cache-1450370735-6dzlj   1/1       Running   0          8m        10.192.4.2   kube-node-3
redis-cache-1450370735-j2j96   1/1       Running   0          8m        10.192.2.2   kube-node-1
redis-cache-1450370735-z73mh   1/1       Running   0          8m        10.192.3.1   kube-node-2
web-server-1287567482-5d4dz    1/1       Running   0          7m        10.192.2.3   kube-node-1
web-server-1287567482-6f7v5    1/1       Running   0          7m        10.192.4.3   kube-node-3
web-server-1287567482-s330j    1/1       Running   0          7m        10.192.3.2   kube-node-2
</code></pre><h5 id=同じnodeに共存させない場合>同じNodeに共存させない場合</h5>
<p>上記の例では <code>PodAntiAffinity</code>を<code>topologyKey: "kubernetes.io/hostname"</code>と合わせて指定することで、redisクラスター内の2つのインスタンスが同じホストにデプロイされない場合を扱いました。
同様の方法で、アンチアフィニティを用いて高可用性を実現したStatefulSetの使用例は<a href=/docs/tutorials/stateful-application/zookeeper/#tolerating-node-failure>ZooKeeper tutorial</a>を参照してください。</p>
<h2 id=nodename>nodeName</h2>
<p><code>nodeName</code>はNodeの選択を制限する最も簡単な方法ですが、制約があることからあまり使用されません。
<code>nodeName</code>はPodSpecのフィールドです。
ここに値が設定されると、schedulerはそのPodを考慮しなくなり、その名前が付与されているNodeのkubeletはPodを稼働させようとします。
そのため、PodSpecに<code>nodeName</code>が指定されると、上述のNodeの選択方法よりも優先されます。</p>
<p><code>nodeName</code>を使用することによる制約は以下の通りです:</p>
<ul>
<li>その名前のNodeが存在しない場合、Podは起動されす、自動的に削除される場合があります。</li>
<li>その名前のNodeにPodを稼働させるためのリソースがない場合、Podの起動は失敗し、理由は例えばOutOfmemoryやOutOfcpuになります。</li>
<li>クラウド上のNodeの名前は予期できず、変更される可能性があります。</li>
</ul>
<p><code>nodeName</code>を指定したPodの設定ファイルの例を示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>kube-01<span style=color:#bbb>
</span></code></pre></div><p>上記のPodはkube-01という名前のNodeで稼働します。</p>
<h2 id=次の項目>次の項目</h2>
<p><a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>Taints</a>を使うことで、NodeはPodを追い出すことができます。</p>
<p><a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/nodeaffinity.md>Nodeアフィニティ</a>と
<a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/podaffinity.md>Pod間アフィニティ/アンチアフィニティ</a>
のデザインドキュメントには、これらの機能の追加のバックグラウンドの情報が記載されています。</p>
<p>一度PodがNodeに割り当たると、kubeletはPodを起動してノード内のリソースを確保します。
<a href=/docs/tasks/administer-cluster/topology-manager/>トポロジーマネージャー</a>はNodeレベルのリソース割り当てを決定する際に関与します。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ede4960b56a3529ee0bfe7c8fe2d09a5>3.9.2 - TaintとToleration</h1>
<p><a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity><em>Nodeアフィニティ</em></a>は
<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>の属性であり、ある<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>群を<em>引きつけます</em>（優先条件または必須条件）。反対に <em>taint</em> はNodeがある種のPodを排除できるようにします。</p>
<p><em>toleration</em> はPodに適用され、一致するtaintが付与されたNodeへPodがスケジューリングされることを認めるものです。ただしそのNodeへ必ずスケジューリングされるとは限りません。</p>
<p>taintとtolerationは組になって機能し、Podが不適切なNodeへスケジューリングされないことを保証します。taintはNodeに一つまたは複数個付与することができます。これはそのNodeがtaintを許容しないPodを受け入れるべきではないことを示します。</p>
<h2 id=コンセプト>コンセプト</h2>
<p>Nodeにtaintを付与するには<a href=/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a>コマンドを使用します。
例えば、次のコマンドは</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule
</code></pre></div><p><code>node1</code>にtaintを設定します。このtaintのキーは<code>key1</code>、値は<code>value1</code>、taintの効果は<code>NoSchedule</code>です。
これは<code>node1</code>にはPodに合致するtolerationがなければスケジューリングされないことを意味します。</p>
<p>上記のコマンドで付与したtaintを外すには、下記のコマンドを使います。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule-
</code></pre></div><p>PodのtolerationはPodSpecの中に指定します。下記のtolerationはどちらも、上記の<code>kubectl taint</code>コマンドで追加したtaintと合致するため、どちらのtolerationが設定されたPodも<code>node1</code>へスケジューリングされることができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>tolerationを設定したPodの例を示します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-with-toleration.yaml download=pods/pod-with-toleration.yaml><code>pods/pod-with-toleration.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-with-toleration-yaml')" title="Copy pods/pod-with-toleration.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-with-toleration-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-key&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p><code>operator</code>のデフォルトは<code>Equal</code>です。</p>
<p>tolerationがtaintと合致するのは、<code>key</code>と<code>effect</code>が同一であり、さらに下記の条件のいずれかを満たす場合です。</p>
<ul>
<li><code>operator</code>が<code>Exists</code>（<code>value</code>を指定すべきでない場合）</li>
<li><code>operator</code>が<code>Equal</code>であり、かつ<code>value</code>が同一である場合</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>2つ特殊な場合があります。</p>
<p>空の<code>key</code>と演算子<code>Exists</code>は全ての<code>key</code>、<code>value</code>、<code>effect</code>と一致するため、すべてのtaintと合致します。</p>
<p>空の<code>effect</code>は<code>key1</code>が一致する全てのeffectと合致します。</p>
</div>
<p>上記の例では<code>effect</code>に<code>NoSchedule</code>を指定しました。代わりに、<code>effect</code>に<code>PreferNoSchedule</code>を指定することができます。
これは<code>NoSchedule</code>の「ソフトな」バージョンであり、システムはtaintに対応するtolerationが設定されていないPodがNodeへ配置されることを避けようとしますが、必須の条件とはしません。3つ目の<code>effect</code>の値として<code>NoExecute</code>がありますが、これについては後述します。</p>
<p>同一のNodeに複数のtaintを付与することや、同一のPodに複数のtolerationを設定することができます。
複数のtaintやtolerationが設定されている場合、Kubernetesはフィルタのように扱います。最初はNodeの全てのtaintがある状態から始め、Podが対応するtolerationを持っているtaintは無視され外されていきます。無視されずに残ったtaintが効果を及ぼします。
具体的には、</p>
<ul>
<li>effect <code>NoSchedule</code>のtaintが無視されず残った場合、KubernetesはそのPodをNodeへスケジューリングしません。</li>
<li>effect <code>NoSchedule</code>のtaintは残らず、effect <code>PreferNoSchedule</code>のtaintは残った場合、KubernetesはそのNodeへのスケジューリングをしないように試みます。</li>
<li>effect <code>NoExecute</code>のtaintが残った場合、既に稼働中のPodはそのNodeから排除され、まだ稼働していないPodはスケジューリングされないようになります。</li>
</ul>
<p>例として、下記のようなtaintが付与されたNodeを考えます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule
kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoExecute
kubectl taint nodes node1 <span style=color:#b8860b>key2</span><span style=color:#666>=</span>value2:NoSchedule
</code></pre></div><p>Podには2つのtolerationが設定されています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>この例では、3つ目のtaintと合致するtolerationがないため、PodはNodeへはスケジューリングされません。
しかし、これらのtaintが追加された時点で、そのNodeでPodが稼働していれば続けて稼働することが可能です。 これは、Podのtolerationと合致しないtaintは3つあるtaintのうちの3つ目のtaintのみであり、それが<code>NoSchedule</code>であるためです。</p>
<p>一般に、effect <code>NoExecute</code>のtaintがNodeに追加されると、合致するtolerationが設定されていないPodは即時にNodeから排除され、合致するtolerationが設定されたPodが排除されることは決してありません。
しかし、effect<code>NoExecute</code>に対するtolerationは<code>tolerationSeconds</code>フィールドを任意で指定することができ、これはtaintが追加された後にそのNodeにPodが残る時間を示します。例えば、</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>
</span></code></pre></div><p>この例のPodが稼働中で、対応するtaintがNodeへ追加された場合、PodはそのNodeに3600秒残り、その後排除されます。仮にtaintがそれよりも前に外された場合、Podは排除されません。</p>
<h2 id=ユースケースの例>ユースケースの例</h2>
<p>taintとtolerationは、実行されるべきではないNodeからPodを遠ざけたり、排除したりするための柔軟な方法です。いくつかのユースケースを示します。</p>
<ul>
<li>
<p><strong>専有Node</strong>: あるNode群を特定のユーザーに専有させたい場合、そのNode群へtaintを追加し(<code>kubectl taint nodes nodename dedicated=groupName:NoSchedule</code>) 対応するtolerationをPodへ追加します（これを実現する最も容易な方法はカスタム
<a href=/docs/reference/access-authn-authz/admission-controllers/>アドミッションコントローラー</a>を書くことです）。
tolerationが設定されたPodはtaintの設定された（専有の）Nodeと、クラスターにあるその他のNodeの使用が認められます。もしPodが必ず専有Node<em>のみ</em>を使うようにしたい場合は、taintと同様のラベルをそのNode群に設定し(例: <code>dedicated=groupName</code>)、アドミッションコントローラーはNodeアフィニティを使ってPodが<code>dedicated=groupName</code>のラベルの付いたNodeへスケジューリングすることが必要であるということも設定する必要があります。</p>
</li>
<li>
<p><strong>特殊なハードウェアを備えるNode</strong>: クラスターの中の少数のNodeが特殊なハードウェア（例えばGPU）を備える場合、そのハードウェアを必要としないPodがスケジューリングされないようにして、後でハードウェアを必要とするPodができたときの余裕を確保したいことがあります。
これは特殊なハードウェアを持つNodeにtaintを追加(例えば <code>kubectl taint nodes nodename special=true:NoSchedule</code> または
<code>kubectl taint nodes nodename special=true:PreferNoSchedule</code>)して、ハードウェアを使用するPodに対応するtolerationを追加することで可能です。
専有Nodeのユースケースと同様に、tolerationを容易に適用する方法はカスタム
<a href=/docs/reference/access-authn-authz/admission-controllers/>アドミッションコントローラー</a>を使うことです。
例えば、特殊なハードウェアを表すために<a href=/docs/concepts/configuration/manage-compute-resources-container/#extended-resources>拡張リソース</a>
を使い、ハードウェアを備えるNodeに拡張リソースの名称のtaintを追加して、
<a href=/docs/reference/access-authn-authz/admission-controllers/#extendedresourcetoleration>拡張リソースtoleration</a>
アドミッションコントローラーを実行することが推奨されます。Nodeにはtaintが付与されているため、tolerationのないPodはスケジューリングされません。しかし拡張リソースを要求するPodを作成しようとすると、<code>拡張リソースtoleration</code> アドミッションコントローラーはPodに自動的に適切なtolerationを設定し、Podはハードウェアを備えるNodeへスケジューリングされます。
これは特殊なハードウェアを備えたNodeではそれを必要とするPodのみが稼働し、Podに対して手作業でtolerationを追加しなくて済むようにします。</p>
</li>
<li>
<p><strong>taintを基にした排除</strong>: Nodeに問題が起きたときにPodごとに排除する設定を行うことができます。次のセクションにて説明します。</p>
</li>
</ul>
<h2 id=taintを基にした排除>taintを基にした排除</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>上述したように、effect <code>NoExecute</code>のtaintはNodeで実行中のPodに次のような影響を与えます。</p>
<ul>
<li>対応するtolerationのないPodは即座に除外される</li>
<li>対応するtolerationがあり、それに<code>tolerationSeconds</code>が指定されていないPodは残り続ける</li>
<li>対応するtolerationがあり、それに<code>tolerationSeconds</code>が指定されているPodは指定された間、残される</li>
</ul>
<p>Nodeコントローラーは特定の条件を満たす場合に自動的にtaintを追加します。
組み込まれているtaintは下記の通りです。</p>
<ul>
<li><code>node.kubernetes.io/not-ready</code>: Nodeの準備ができていない場合。これはNodeCondition <code>Ready</code>が<code>False</code>である場合に対応します。</li>
<li><code>node.kubernetes.io/unreachable</code>: NodeがNodeコントローラーから到達できない場合。これはNodeCondition<code>Ready</code>が<code>Unknown</code>の場合に対応します。</li>
<li><code>node.kubernetes.io/out-of-disk</code>: Nodeのディスクの空きがない場合。</li>
<li><code>node.kubernetes.io/memory-pressure</code>: Nodeのメモリーが不足している場合。</li>
<li><code>node.kubernetes.io/disk-pressure</code>: Nodeのディスクが不足している場合。</li>
<li><code>node.kubernetes.io/network-unavailable</code>: Nodeのネットワークが利用できない場合。</li>
<li><code>node.kubernetes.io/unschedulable</code>: Nodeがスケジューリングできない場合。</li>
<li><code>node.cloudprovider.kubernetes.io/uninitialized</code>: kubeletが外部のクラウド事業者により起動されたときに設定されるtaintで、このNodeは利用不可能であることを示します。cloud-controller-managerによるコントローラーがこのNodeを初期化した後にkubeletはこのtaintを外します。</li>
</ul>
<p>Nodeから追い出すときには、Nodeコントローラーまたはkubeletは関連するtaintを<code>NoExecute</code>効果の状態で追加します。
不具合のある状態から通常の状態へ復帰した場合は、kubeletまたはNodeコントローラーは関連するtaintを外すことができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> コントロールプレーンは新しいtaintをNodeに加えるレートを制限しています。
このレート制限は一度に多くのNodeが到達不可能になった場合（例えばネットワークの断絶）に、退役させられるNodeの数を制御します。
</div>
<p>Podに<code>tolerationSeconds</code>を指定することで不具合があるか応答のないNodeに残る時間を指定することができます。</p>
<p>例えば、ローカルの状態を多数持つアプリケーションとネットワークが分断された場合を考えます。ネットワークが復旧して、Podを排除しなくて済むことを見込んで、長時間Nodeから排除されないようにしたいこともあるでしょう。
この場合Podに設定するtolerationは次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;node.kubernetes.io/unreachable&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>6000</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>Kubernetesはユーザーまたはコントローラーが明示的に指定しない限り、自動的に<code>node.kubernetes.io/not-ready</code>と<code>node.kubernetes.io/unreachable</code>に対するtolerationを<code>tolerationSeconds=300</code>にて設定します。</p>
<p>自動的に設定されるtolerationは、taintに対応する問題がNodeで検知されても5分間はそのNodeにPodが残されることを意味します。</p>
</div>
<p><a href=/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a>のPodは次のtaintに対して<code>NoExecute</code>のtolerationが<code>tolerationSeconds</code>を指定せずに設定されます。</p>
<ul>
<li><code>node.kubernetes.io/unreachable</code></li>
<li><code>node.kubernetes.io/not-ready</code></li>
</ul>
<p>これはDaemonSetのPodはこれらの問題によって排除されないことを保証します。</p>
<h2 id=条件によるtaintの付与>条件によるtaintの付与</h2>
<p>NodeのライフサイクルコントローラーはNodeの状態に応じて<code>NoSchedule</code>効果のtaintを付与します。
スケジューラーはNodeの状態ではなく、taintを確認します。
Nodeに何がスケジューリングされるかは、そのNodeの状態に影響されないことを保証します。ユーザーは適切なtolerationをPodに付与することで、どの種類のNodeの問題を無視するかを選ぶことができます。</p>
<p>DaemonSetのコントローラーは、DaemonSetが中断されるのを防ぐために自動的に次の<code>NoSchedule</code>tolerationを全てのDaemonSetに付与します。</p>
<ul>
<li><code>node.kubernetes.io/memory-pressure</code></li>
<li><code>node.kubernetes.io/disk-pressure</code></li>
<li><code>node.kubernetes.io/out-of-disk</code> (<em>重要なPodのみ</em>)</li>
<li><code>node.kubernetes.io/unschedulable</code> (1.10またはそれ以降)</li>
<li><code>node.kubernetes.io/network-unavailable</code> (<em>ホストネットワークのみ</em>)</li>
</ul>
<p>これらのtolerationを追加することは後方互換性を保証します。DaemonSetに任意のtolerationを加えることもできます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/administer-cluster/out-of-resource/>リソース枯渇の対処</a>とどのような設定ができるかについてを読む</li>
<li><a href=/docs/concepts/configuration/pod-priority-preemption/>Podの優先度</a>を読む</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-598f36d691ab197f9d995784574b0a12>3.9.3 - Kubernetesのスケジューラー</h1>
<p>Kubernetesにおいて、<em>スケジューリング</em> とは、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>が<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>を稼働させるために<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>に割り当てることを意味します。</p>
<h2 id=scheduling>スケジューリングの概要</h2>
<p>スケジューラーは新規に作成されたPodで、Nodeに割り当てられていないものを監視します。スケジューラーは発見した各Podのために、稼働させるべき最適なNodeを見つけ出す責務を担っています。そのスケジューラーは下記で説明するスケジューリングの原理を考慮に入れて、NodeへのPodの割り当てを行います。</p>
<p>Podが特定のNodeに割り当てられる理由を理解したい場合や、カスタムスケジューラーを自身で作ろうと考えている場合、このページはスケジューリングに関して学ぶのに役立ちます。</p>
<h2 id=kube-scheduler>kube-scheduler</h2>
<p><a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a>はKubernetesにおけるデフォルトのスケジューラーで、<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>の一部分として稼働します。
kube-schedulerは、もし希望するのであれば自分自身でスケジューリングのコンポーネントを実装でき、それを代わりに使用できるように設計されています。</p>
<p>kube-schedulerは、新規に作成された各Podや他のスケジューリングされていないPodを稼働させるために最適なNodeを選択します。
しかし、Pod内の各コンテナにはそれぞれ異なるリソースの要件があり、各Pod自体にもそれぞれ異なる要件があります。そのため、既存のNodeは特定のスケジューリング要求によってフィルターされる必要があります。</p>
<p>クラスター内でPodに対する割り当て要求を満たしたNodeは <em>割り当て可能</em> なNodeと呼ばれます。
もし適切なNodeが一つもない場合、スケジューラーがNodeを割り当てることができるまで、そのPodはスケジュールされずに残ります。</p>
<p>スケジューラーはPodに対する割り当て可能なNodeをみつけ、それらの割り当て可能なNodeにスコアをつけます。その中から最も高いスコアのNodeを選択し、Podに割り当てるためのいくつかの関数を実行します。
スケジューラーは <em>binding</em> と呼ばれる処理中において、APIサーバーに対して割り当てが決まったNodeの情報を通知します。</p>
<p>スケジューリングを決定する上で考慮が必要な要素としては、個別または複数のリソース要求や、ハードウェア/ソフトウェアのポリシー制約、affinityやanti-affinityの設定、データの局所性や、ワークロード間での干渉などが挙げられます。</p>
<h2 id=kube-scheduler-implementation>kube-schedulerによるスケジューリング</h2>
<p>kube-schedulerは2ステップの操作によってPodに割り当てるNodeを選択します。</p>
<ol>
<li>
<p>フィルタリング</p>
</li>
<li>
<p>スコアリング</p>
</li>
</ol>
<p><em>フィルタリング</em> ステップでは、Podに割り当て可能なNodeのセットを探します。例えばPodFitsResourcesフィルターは、Podのリソース要求を満たすのに十分なリソースをもつNodeがどれかをチェックします。このステップの後、候補のNodeのリストは、要求を満たすNodeを含みます。
たいてい、リストの要素は複数となります。もしこのリストが空の場合、そのPodはスケジュール可能な状態とはなりません。</p>
<p><em>スコアリング</em> ステップでは、Podを割り当てるのに最も適したNodeを選択するために、スケジューラーはリストの中のNodeをランク付けします。
スケジューラーは、フィルタリングによって選ばれた各Nodeに対してスコアを付けます。このスコアはアクティブなスコア付けのルールに基づいています。</p>
<p>最後に、kube-schedulerは最も高いランクのNodeに対してPodを割り当てます。もし同一のスコアのNodeが複数ある場合は、kube-schedulerがランダムに1つ選択します。</p>
<p>スケジューラーのフィルタリングとスコアリングの動作に関する設定には2つのサポートされた手法があります。</p>
<ol>
<li><a href=/docs/reference/scheduling/policies>スケジューリングポリシー</a> は、フィルタリングのための <em>Predicates</em> とスコアリングのための <em>Priorities</em> の設定することができます。</li>
<li><a href=/docs/reference/scheduling/config/#profiles>スケジューリングプロファイル</a>は、<code>QueueSort</code>、 <code>Filter</code>、 <code>Score</code>、 <code>Bind</code>、 <code>Reserve</code>、 <code>Permit</code>やその他を含む異なるスケジューリングの段階を実装するプラグインを設定することができます。kube-schedulerを異なるプロファイルを実行するように設定することもできます。</li>
</ol>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/scheduling-eviction/scheduler-perf-tuning/>スケジューラーのパフォーマンスチューニング</a>を参照してください。</li>
<li><a href=/docs/concepts/workloads/pods/pod-topology-spread-constraints/>Podトポロジーの分散制約</a>を参照してください。</li>
<li>kube-schedulerの<a href=/docs/reference/command-line-tools-reference/kube-scheduler/>リファレンスドキュメント</a>を参照してください。</li>
<li><a href=/docs/tasks/administer-cluster/configure-multiple-schedulers/>複数のスケジューラーの設定</a>について学んでください。</li>
<li><a href=/docs/tasks/administer-cluster/topology-manager/>トポロジーの管理ポリシー</a>について学んでください。</li>
<li><a href=/docs/concepts/scheduling-eviction/pod-overhead/>Podのオーバーヘッド</a>について学んでください。</li>
<li>ボリュームを使用するPodのスケジューリングについて以下で学んでください。
<ul>
<li><a href=/docs/concepts/storage/storage-classes/#volume-binding-mode>Volume Topology Support</a></li>
<li><a href=/ja//docs/concepts/storage/storage-capacity/>ストレージ容量の追跡</a></li>
<li><a href=/docs/concepts/storage/storage-limits/>Node-specific Volume Limits</a></li>
</ul>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d9574a30fcbc631b0d2a57850e161e89>3.9.4 - スケジューラーのパフォーマンスチューニング</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes 1.14 [beta]</code>
</div>
<p><a href=/ja/docs/concepts/scheduling-eviction/kube-scheduler/#kube-scheduler>kube-scheduler</a>はKubernetesのデフォルトのスケジューラーです。クラスター内のノード上にPodを割り当てる責務があります。</p>
<p>クラスター内に存在するノードで、Podのスケジューリング要求を満たすものはPodに対して<em>割り当て可能</em>なノードと呼ばれます。スケジューラーはPodに対する割り当て可能なノードをみつけ、それらの割り当て可能なノードにスコアをつけます。その中から最も高いスコアのノードを選択し、Podに割り当てるためのいくつかの関数を実行します。スケジューラーは<em>Binding</em>と呼ばれる処理中において、APIサーバーに対して割り当てが決まったノードの情報を通知します。</p>
<p>このページでは、大規模のKubernetesクラスターにおけるパフォーマンス最適化のためのチューニングについて説明します。</p>
<p>大規模クラスターでは、レイテンシー(新規Podをすばやく配置)と精度(スケジューラーが不適切な配置を行うことはめったにありません)の間でスケジューリング結果を調整するスケジューラーの動作をチューニングできます。</p>
<p>このチューニング設定は、kube-scheduler設定の<code>percentageOfNodesToScore</code>で設定できます。KubeSchedulerConfiguration設定は、クラスター内のノードにスケジュールするための閾値を決定します。</p>
<h3 id=閾値の設定>閾値の設定</h3>
<p><code>percentageOfNodesToScore</code>オプションは、0から100までの数値を受け入れます。0は、kube-schedulerがコンパイル済みのデフォルトを使用することを示す特別な値です。
<code>percentageOfNodesToScore</code>に100より大きな値を設定した場合、kube-schedulerの挙動は100を設定した場合と同様となります。</p>
<p>この値を変更するためには、kube-schedulerの設定ファイル(これは<code>/etc/kubernetes/config/kube-scheduler.yaml</code>の可能性が高い)を編集し、スケジューラーを再起動します。</p>
<p>この変更をした後、</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get pods -n kube-system | grep kube-scheduler
</code></pre></div><p>を実行して、kube-schedulerコンポーネントが正常であることを確認できます。</p>
<h2 id=percentage-of-nodes-to-score>ノードへのスコア付けの閾値</h2>
<p>スケジューリング性能を改善するため、kube-schedulerは割り当て可能なノードが十分に見つかるとノードの検索を停止できます。大規模クラスターでは、すべてのノードを考慮する単純なアプローチと比較して時間を節約できます。</p>
<p>クラスター内のすべてのノードに対する十分なノード数を整数パーセンテージで指定します。kube-schedulerは、これをノード数に変換します。スケジューリング中に、kube-schedulerが設定されたパーセンテージを超える十分な割り当て可能なノードを見つけた場合、kube-schedulerはこれ以上割り当て可能なノードを探すのを止め、<a href=/docs/concepts/scheduling-eviction/kube-scheduler/#kube-scheduler-implementation>スコアリングフェーズ</a>に進みます。</p>
<p><a href=#how-the-scheduler-iterates-over-nodes>スケジューラーはどのようにノードを探索するか</a>で処理を詳しく説明しています。</p>
<h3 id=デフォルトの閾値>デフォルトの閾値</h3>
<p>閾値を指定しない場合、Kubernetesは100ノードのクラスタでは50%、5000ノードのクラスタでは10%になる線形方程式を使用して数値を計算します。自動計算の下限は5%です。</p>
<p>つまり、明示的に<code>percentageOfNodesToScore</code>を5未満の値を設定しない限り、クラスターの規模に関係なく、kube-schedulerは常に少なくともクラスターの5%のノードに対してスコア付けをします。</p>
<p>スケジューラーにクラスター内のすべてのノードに対してスコア付けをさせる場合は、<code>percentageOfNodesToScore</code>の値に100を設定します。</p>
<h2 id=例>例</h2>
<p><code>percentageOfNodesToScore</code>の値を50%に設定する例は下記のとおりです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1alpha1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>algorithmSource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>provider</span>:<span style=color:#bbb> </span>DefaultProvider<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>percentageOfNodesToScore</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></code></pre></div><h2 id=percentageofnodestoscoreのチューニング>percentageOfNodesToScoreのチューニング</h2>
<p><code>percentageOfNodesToScore</code>は1から100の間の範囲である必要があり、デフォルト値はクラスターのサイズに基づいて計算されます。また、クラスターのサイズの最小値は50ノードとハードコードされています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>割り当て可能なノードが50以下のクラスタでは、スケジューラの検索を早期に停止するのに十分な割り当て可能なノードがないため、スケジューラはすべてのノードをチェックします。</p>
<p>小規模クラスタでは、<code>percentageOfNodesToScore</code>に低い値を設定したとしても、同様の理由で変更による影響は全くないか、ほとんどありません。</p>
<p>クラスターのノード数が数百以下の場合は、この設定オプションをデフォルト値のままにします。変更してもスケジューラの性能を大幅に改善する可能性はほとんどありません。</p>
</div>
<p>この値を設定する際に考慮するべき重要な注意事項として、割り当て可能ノードのチェック対象のノードが少ないと、一部のノードはPodの割り当てのためにスコアリングされなくなります。結果として、高いスコアをつけられる可能性のあるノードがスコアリングフェーズに渡されることがありません。これにより、Podの配置が理想的なものでなくなります。</p>
<p>kube-schedulerが頻繁に不適切なPodの配置を行わないよう、<code>percentageOfNodesToScore</code>をかなり低い値を設定することは避けるべきです。スケジューラのスループットがアプリケーションにとって致命的で、ノードのスコアリングが重要でない場合を除いて、10%未満に設定することは避けてください。言いかえると、割り当て可能な限り、Podは任意のノード上で稼働させるのが好ましいです。</p>
<h2 id=how-the-scheduler-iterates-over-nodes>スケジューラーはどのようにノードを探索するか</h2>
<p>このセクションでは、この機能の内部の詳細を理解したい人向けになります。</p>
<p>クラスター内の全てのノードに対して平等にPodの割り当ての可能性を持たせるため、スケジューラーはラウンドロビン方式でノードを探索します。複数のノードの配列になっているイメージです。スケジューラーはその配列の先頭から探索を開始し、<code>percentageOfNodesToScore</code>によって指定された数のノードを検出するまで、割り当て可能かどうかをチェックしていきます。次のPodでは、スケジューラーは前のPodの割り当て処理でチェックしたところから探索を再開します。</p>
<p>ノードが複数のゾーンに存在するとき、スケジューラーは様々なゾーンのノードを探索して、異なるゾーンのノードが割り当て可能かどうかのチェック対象になるようにします。例えば2つのゾーンに6つのノードがある場合を考えます。</p>
<pre><code>Zone 1: Node 1, Node 2, Node 3, Node 4
Zone 2: Node 5, Node 6
</code></pre><p>スケジューラーは、下記の順番でノードの割り当て可能性を評価します。</p>
<pre><code>Node 1, Node 5, Node 2, Node 6, Node 3, Node 4
</code></pre><p>全てのノードのチェックを終えたら、1番目のノードに戻ってチェックをします。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ac9161c6d952925b083ad9602b4e8e7f>3.10 - ポリシー</h1>
</div>
<div class=td-content>
<h1 id=pg-a935ff8c59eb116b43494255cc67f69a>3.10.1 - Limit Range</h1>
<p>デフォルトでは、コンテナは、Kubernetesクラスター上の<a href=/docs/concepts/configuration/manage-resources-containers/>計算リソース</a>の消費を制限されずに実行されます。リソースクォータを利用すれば、クラスター管理者はリソースの消費と作成を<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=名前空間>名前空間</a>ベースで制限することができます。名前空間内では、Podやコンテナは名前空間のリソースクォータで定義された範囲内でできるだけ多くのCPUとメモリーを消費できてしまうため、1つのPodまたはコンテナが利用可能なすべてのリソースを専有してしまう恐れがあります。LimitRangeを利用すれば、このような名前空間内での(Podやコンテナへの)リソースの割り当てを制限するポリシーを定めることができます。</p>
<p><em>LimitRange</em>を利用すると、次のような制約を課せるようになります。</p>
<ul>
<li>名前空間内のPodまたはコンテナごとに、計算リソースの使用量の最小値と最大値を強制する。</li>
<li>名前空間内のPersistentVolumeClaimごとに、ストレージリクエストの最小値と最大値を強制する。</li>
<li>名前空間内で、リソースのrequestとlimitの割合を強制する。</li>
<li>名前空間内の計算リソースのデフォルトのrequest/limitの値を設定して、実行時にコンテナに自動的に注入する。</li>
</ul>
<h2 id=limitrangeを有効にする>LimitRangeを有効にする</h2>
<p>Kubernetes 1.10以降では、LimitRangeのサポートはデフォルトで有効になりました。</p>
<p>LimitRangeが特定の名前空間内で強制されるのは、その名前空間内にLimitRangeオブジェクトが存在する場合です。</p>
<p>LimitRangeオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>でなければなりません。</p>
<h3 id=limit-rangeの概要>Limit Rangeの概要</h3>
<ul>
<li>管理者は、1つの名前空間に1つのLimitRangeを作成します。</li>
<li>ユーザーは、Pod、コンテナ、PersistentVolumeClaimのようなリソースを名前空間内に作成します。</li>
<li><code>LimitRanger</code>アドミッションコントローラーは、計算リソース要求が設定されていないすべてのPodとコンテナに対して、デフォルト値と制限値を強制します。そして、リソースの使用量を追跡し、名前空間内に存在するすべてのLimitRangeで定義された最小値、最大値、割合を外れないことを保証します。</li>
<li>LimitRangeの制約を破るようなリソース(Pod、コンテナ、PersistentVolumeClaim)の作成や更新を行うと、APIサーバーへのリクエストがHTTPステータスコード<code>403 FORBIDDEN</code>で失敗し、破られた制約を説明するメッセージが返されます。</li>
<li>名前空間内でLimitRangeが<code>cpu</code>や<code>memory</code>などの計算リソースに対して有効になっている場合、ユーザーはrequestsやlimitsに値を指定しなければなりません。指定しなかった場合、システムはPodの作成を拒否する可能性があります。</li>
<li>LimitRangeの検証は、Podのアドミッションステージでのみ発生し、実行中のPodでは発生しません。</li>
</ul>
<p>以下は、LimitRangeを使用して作成できるポリシーの例です。</p>
<ul>
<li>8GiBのRAMと16コアのCPUの容量がある2ノードのクラスター上で、名前空間内のPodに対して、CPUには100mのrequestと最大500mのlimitの制約を課し、メモリーには200Miのrequestと600Miのlimitの制約を課す。</li>
<li>Spec内のrequestsにcpuやmemoryを指定せずに起動したコンテナに対して、CPUにはデフォルトで150mのlimitとrequestを、メモリーにはデフォルトで300Miのrequestをそれぞれ定義する。</li>
</ul>
<p>名前空間のlimitの合計が、Podやコンテナのlimitの合計よりも小さくなる場合、リソースの競合が起こる可能性があります。その場合、コンテナやPodは作成されません。</p>
<p>LimitRangeに対する競合や変更は、すでに作成済みのリソースに対しては影響しません。</p>
<h2 id=次の項目>次の項目</h2>
<p>より詳しい情報は、<a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md>LimitRangerの設計ドキュメント</a>を参照してください。</p>
<p>制限の使用例については、以下のページを読んでください。</p>
<ul>
<li><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>名前空間ごとにCPUの最小値と最大値の制約を設定する方法</a>。</li>
<li><a href=/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>名前空間ごとにメモリーの最小値と最大値の制約を設定する方法</a>。</li>
<li><a href=/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>名前空間ごとにCPUのRequestとLimitのデフォルト値を設定する方法</a>。</li>
<li><a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>名前空間ごとにメモリーのRequestとLimitのデフォルト値を設定する方法</a>。</li>
<li><a href=/docs/tasks/administer-cluster/limit-storage-consumption/#limitrange-to-limit-requests-for-storage>名前空間ごとにストレージ消費量の最小値と最大値を設定する方法</a>。</li>
<li><a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>名前空間ごとのクォータを設定する詳細な例</a>。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-94ddc6e901c30f256138db11d09f05a3>3.10.2 - リソースクォータ</h1>
<p>複数のユーザーやチームが決められた数のノードを持つクラスターを共有しているとき、1つのチームが公平に使えるリソース量を超えて使用するといった問題が出てきます。</p>
<p>リソースクォータはこの問題に対処するための管理者向けツールです。</p>
<p><code>ResourceQuota</code>オブジェクトによって定義されるリソースクォータは、名前空間ごとの総リソース消費を制限するための制約を提供します。リソースクォータは同じ名前空間のクラスター内でタイプごとに作成できるオブジェクト数や、名前空間内のリソースによって消費されるコンピュートリソースの総量を制限できます。</p>
<p>リソースクォータは下記のように働きます。</p>
<ul>
<li>異なる名前空間で異なるチームが存在するとき。現時点ではこれは自主的なものですが、将来的にはACLsを介してリソースクォータの設定を強制するように計画されています。</li>
<li>管理者は各名前空間で1つの<code>ResourceQuota</code>を作成します。</li>
<li>ユーザーが名前空間内でリソース(Pod、Serviceなど)を作成し、クォータシステムが<code>ResourceQuota</code>によって定義されたハードリソースリミットを超えないことを保証するために、リソースの使用量をトラッキングします。</li>
<li>リソースの作成や更新がクォータの制約に違反しているとき、そのリクエストはHTTPステータスコード<code>403 FORBIDDEN</code>で失敗し、違反した制約を説明するメッセージが表示されます。</li>
<li><code>cpu</code>や<code>memory</code>といったコンピューターリソースに対するクォータが名前空間内で有効になっているとき、ユーザーはそれらの値に対する<code>requests</code>や<code>limits</code>を設定する必要があります。設定しないとクォータシステムがPodの作成を拒否します。 ヒント: コンピュートリソースの要求を設定しないPodに対してデフォルト値を強制するために、<code>LimitRanger</code>アドミッションコントローラーを使用してください。この問題を解決する例は<a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>walkthrough</a>で参照できます。</li>
</ul>
<p>ResourceQuotaのオブジェクト名は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります.</p>
<p>名前空間とクォータを使用して作成できるポリシーの例は以下の通りです。</p>
<ul>
<li>32GiB RAM、16コアのキャパシティーを持つクラスターで、Aチームに20GiB、10コアを割り当て、Bチームに10GiB、4コアを割り当て、将来の割り当てのために2GiB、2コアを予約しておく。</li>
<li>"testing"という名前空間に対して1コア、1GiB RAMの使用制限をかけ、"production"という名前空間には制限をかけない。</li>
</ul>
<p>クラスターの総キャパシティーが、その名前空間のクォータの合計より少ない場合、リソースの競合が発生する場合があります。このとき、リソースの先着順で処理されます。</p>
<p>リソースの競合もクォータの変更も、作成済みのリソースには影響しません。</p>
<h2 id=リソースクォータを有効にする>リソースクォータを有効にする</h2>
<p>多くのKubernetesディストリビューションにおいてリソースクォータはデフォルトで有効になっています。APIサーバーで<code>--enable-admission-plugins=</code>の値に<code>ResourceQuota</code>が含まれるときに有効になります。</p>
<p>特定の名前空間にResourceQuotaがあるとき、そのリソースクォータはその名前空間に適用されます。</p>
<h2 id=リソースクォータの計算>リソースクォータの計算</h2>
<p>特定の名前空間において、<a href=/docs/concepts/configuration/manage-resources-containers/>コンピュートリソース</a>の合計に上限を設定できます。</p>
<p>下記のリソースタイプがサポートされています。</p>
<table>
<thead>
<tr>
<th>リソース名</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>limits.cpu</code></td>
<td>停止していない状態の全てのPodで、CPUリミットの合計がこの値を超えることができません。</td>
</tr>
<tr>
<td><code>limits.memory</code></td>
<td>停止していない状態の全てのPodで、メモリーの合計がこの値を超えることができません。</td>
</tr>
<tr>
<td><code>requests.cpu</code></td>
<td>停止していない状態の全てのPodで、CPUリクエストの合計がこの値を超えることができません。</td>
</tr>
<tr>
<td><code>requests.memory</code></td>
<td>停止していない状態の全てのPodで、メモリーリクエストの合計がこの値を超えることができません。</td>
</tr>
<tr>
<td><code>hugepages-&lt;size></code></td>
<td>停止していない状態の全てのPodで, 指定されたサイズのHuge Pageリクエスト数がこの値を超えることができません。</td>
</tr>
<tr>
<td><code>cpu</code></td>
<td><code>requests.cpu</code>と同じ。</td>
</tr>
<tr>
<td><code>memory</code></td>
<td><code>requests.memory</code>と同じ。</td>
</tr>
</tbody>
</table>
<h3 id=拡張リソースのためのリソースクォータ>拡張リソースのためのリソースクォータ</h3>
<p>上記で取り上げたリソースに加えて、Kubernetes v1.10において、<a href=/docs/concepts/configuration/manage-resources-containers/#extended-resources>拡張リソース</a>のためのリソースクォータのサポートが追加されました。</p>
<p>拡張リソースに対するオーバーコミットが禁止されているのと同様に、リソースクォータで拡張リソース用に<code>requests</code>と<code>limits</code>の両方を指定しても意味がありません。現在、拡張リソースに対しては<code>requests.</code>というプレフィックスのついたクォータアイテムのみ設定できます。</p>
<p>GPUリソースを例にすると、もしリソース名が<code>nvidia.com/gpu</code>で、ユーザーが名前空間内でリクエストされるGPUの上限を4に指定するとき、下記のようにリソースクォータを定義します。</p>
<ul>
<li><code>requests.nvidia.com/gpu: 4</code></li>
</ul>
<p>さらなる詳細は<a href=#viewing-and-setting-quotas>クォータの確認と設定</a>を参照してください。</p>
<h2 id=ストレージのリソースクォータ>ストレージのリソースクォータ</h2>
<p>特定の名前空間において<a href=/ja/docs/concepts/storage/persistent-volumes/>ストレージリソース</a>の総数に上限をかけることができます。</p>
<p>さらに、関連するストレージクラスに基づいて、ストレージリソースの消費量に上限をかけることもできます。</p>
<table>
<thead>
<tr>
<th>リソース名</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>requests.storage</code></td>
<td>全てのPersistentVolumeClaimにおいて、ストレージのリクエストの合計がこの値を超えないようにします。</td>
</tr>
<tr>
<td><code>persistentvolumeclaims</code></td>
<td>特定の名前空間内で作成可能な<a href=/ja/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaim</a>の総数。</td>
</tr>
<tr>
<td><code>&lt;storage-class-name>.storageclass.storage.k8s.io/requests.storage</code></td>
<td>ストレージクラス名<code>&lt;storage-class-name></code>に関連する全てのPersistentVolumeClaimにおいて、ストレージリクエストの合計がこの値を超えないようにします。</td>
</tr>
<tr>
<td><code>&lt;storage-class-name>.storageclass.storage.k8s.io/persistentvolumeclaims</code></td>
<td>ストレージクラス名<code>&lt;storage-class-name></code>に関連する全てのPersistentVolumeClaimにおいて、特定の名前空間内で作成可能な<a href=/ja/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaim</a>の総数。</td>
</tr>
</tbody>
</table>
<p>例えば、もし管理者が<code>gold</code>ストレージクラスを<code>bronze</code>ストレージクラスと分けてリソースクォータを設定するとき、管理者はリソースクォータを下記のように指定できます。</p>
<ul>
<li><code>gold.storageclass.storage.k8s.io/requests.storage: 500Gi</code></li>
<li><code>bronze.storageclass.storage.k8s.io/requests.storage: 100Gi</code></li>
</ul>
<p>Kubernetes v1.8において、ローカルのエフェメラルストレージに対するリソースクォータのサポートがα版の機能として追加されました。</p>
<table>
<thead>
<tr>
<th>リソース名</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>requests.ephemeral-storage</code></td>
<td>名前空間内の全てのPodで、ローカルのエフェメラルストレージのリクエストの合計がこの値を超えないようにします。</td>
</tr>
<tr>
<td><code>limits.ephemeral-storage</code></td>
<td>名前空間内の全てのPodで、ローカルのエフェメラルストレージのリミットの合計がこの値を超えないようにします。</td>
</tr>
<tr>
<td><code>ephemeral-storage</code></td>
<td><code>requests.ephemeral-storage</code>と同じ。</td>
</tr>
</tbody>
</table>
<h2 id=オブジェクト数に対するクォータ>オブジェクト数に対するクォータ</h2>
<p>下記のシンタックスを使用して、名前空間に紐づいた全ての標準であるリソースタイプの中の特定のリソースの総数に対するリソースクォータを設定できます。</p>
<ul>
<li><code>count/&lt;resource>.&lt;group></code> コアでないグループのリソース用</li>
<li><code>count/&lt;resource></code> コアグループのリソース用</li>
</ul>
<p>オブジェクト数に対するクォータでユーザーが設定するリソースの例は下記の通りです。</p>
<ul>
<li><code>count/persistentvolumeclaims</code></li>
<li><code>count/services</code></li>
<li><code>count/secrets</code></li>
<li><code>count/configmaps</code></li>
<li><code>count/replicationcontrollers</code></li>
<li><code>count/deployments.apps</code></li>
<li><code>count/replicasets.apps</code></li>
<li><code>count/statefulsets.apps</code></li>
<li><code>count/jobs.batch</code></li>
<li><code>count/cronjobs.batch</code></li>
</ul>
<p>カスタムリソースに対して同じシンタックスを使用できます。例えば、<code>example.com</code>というAPIグループ内の<code>widgets</code>というカスタムリソースのリソースクォータを設定するには<code>count/widgets.example.com</code>と記述します。</p>
<p><code>count/*</code>リソースクォータの使用において、オブジェクトがサーバーストレージに存在するときオブジェクトはクォータの計算対象となります。このようなタイプのリソースクォータはストレージリソース浪費の防止に有効です。例えば、もしSecretが大量に存在するとき、そのSecretリソースの総数に対してリソースクォータの制限をかけたい場合です。クラスター内でSecretが大量にあると、サーバーとコントローラーの起動を妨げることになります。適切に設定されていないCronJobから保護するためにジョブのクォータを設定できます。名前空間内で大量のJobを作成するCronJobは、サービスを利用不可能にする可能性があります。</p>
<p>また、限定されたリソースのセットにおいて汎用オブジェクトカウントのリソースクォータを実行可能です。</p>
<p>下記のタイプのリソースがサポートされています。</p>
<table>
<thead>
<tr>
<th>リソース名</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>configmaps</code></td>
<td>名前空間内で存在可能なConfigMapの総数。</td>
</tr>
<tr>
<td><code>persistentvolumeclaims</code></td>
<td>名前空間内で存在可能な<a href=/ja/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaim</a>の総数。</td>
</tr>
<tr>
<td><code>pods</code></td>
<td>名前空間内で存在可能な停止していないPodの総数。<code>.status.phase in (Failed, Succeeded)</code>がtrueのとき、Podは停止状態にあります。</td>
</tr>
<tr>
<td><code>replicationcontrollers</code></td>
<td>名前空間内で存在可能なReplicationControlerの総数。</td>
</tr>
<tr>
<td><code>resourcequotas</code></td>
<td>名前空間内で存在可能なResourceQuotaの総数。</td>
</tr>
<tr>
<td><code>services</code></td>
<td>名前空間内で存在可能なServiceの総数。</td>
</tr>
<tr>
<td><code>services.loadbalancers</code></td>
<td>名前空間内で存在可能なtype:LoadBalancerであるServiceの総数。</td>
</tr>
<tr>
<td><code>services.nodeports</code></td>
<td>名前空間内で存在可能なtype:NodePortであるServiceの総数。</td>
</tr>
<tr>
<td><code>secrets</code></td>
<td>名前空間内で存在可能なSecretの総数。</td>
</tr>
</tbody>
</table>
<p>例えば、<code>pods</code>のリソースクォータは<code>Pod</code>の総数をカウントし、特定の名前空間内で作成された<code>Pod</code>の総数の最大数を設定します。またユーザーが多くのPodを作成し、クラスターのPodのIPが枯渇する状況を避けるために<code>pods</code>のリソースクォータを名前空間に設定したい場合があります。</p>
<h2 id=クォータのスコープについて>クォータのスコープについて</h2>
<p>各リソースクォータには関連する<code>scope</code>のセットを関連づけることができます。クォータは、列挙されたscopeの共通部分と一致する場合にのみリソースの使用量を計測します。</p>
<p>スコープがクォータに追加されると、サポートするリソースの数がスコープに関連するリソースに制限されます。許可されたセット以外のクォータ上でリソースを指定するとバリデーションエラーになります。</p>
<table>
<thead>
<tr>
<th>スコープ</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Terminating</code></td>
<td><code>.spec.activeDeadlineSeconds >= 0</code>であるPodに一致します。</td>
</tr>
<tr>
<td><code>NotTerminating</code></td>
<td><code>.spec.activeDeadlineSecondsがnil</code>であるPodに一致します。</td>
</tr>
<tr>
<td><code>BestEffort</code></td>
<td>ベストエフォート型のサービス品質のPodに一致します。</td>
</tr>
<tr>
<td><code>NotBestEffort</code></td>
<td>ベストエフォート型のサービス品質でないPodに一致します。</td>
</tr>
<tr>
<td><code>PriorityClass</code></td>
<td>指定された<a href=/docs/concepts/configuration/pod-priority-preemption>優先度クラス</a>と関連付いているPodに一致します。</td>
</tr>
</tbody>
</table>
<p><code>BestEffort</code>スコープはリソースクォータを次のリソースに対するトラッキングのみに制限します:</p>
<ul>
<li><code>pods</code></li>
</ul>
<p><code>Terminating</code>、<code>NotTerminating</code>、<code>NotBestEffort</code>、<code>PriorityClass</code>スコープは、リソースクォータを次のリソースに対するトラッキングのみに制限します:</p>
<ul>
<li><code>pods</code></li>
<li><code>cpu</code></li>
<li><code>memory</code></li>
<li><code>requests.cpu</code></li>
<li><code>requests.memory</code></li>
<li><code>limits.cpu</code></li>
<li><code>limits.memory</code></li>
</ul>
<p>同じクォータで<code>Terminating</code>と<code>NotTerminating</code>の両方のスコープを指定することはできず、また同じクォータで<code>BestEffort</code>と<code>NotBestEffort</code>の両方のスコープを指定することもできないことに注意してください。</p>
<p><code>scopeSelector</code>は<code>operator</code> フィールドにおいて下記の値をサポートしています。:</p>
<ul>
<li><code>In</code></li>
<li><code>NotIn</code></li>
<li><code>Exists</code></li>
<li><code>DoesNotExist</code></li>
</ul>
<p><code>scopeSelector</code>の定義において<code>scopeName</code>に下記のいずれかの値を使用する場合、<code>operator</code>に<code>Exists</code>を指定してください。</p>
<ul>
<li><code>Terminating</code></li>
<li><code>NotTerminating</code></li>
<li><code>BestEffort</code></li>
<li><code>NotBestEffort</code></li>
</ul>
<p><code>operator</code>が<code>In</code>または<code>NotIn</code>の場合、<code>values</code>フィールドには少なくとも1つの値が必要です。例えば以下のように記述します：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- middle<span style=color:#bbb>
</span></code></pre></div><p><code>operator</code>が<code>Exists</code>または<code>DoesNotExist</code>の場合、<code>values</code>フィールドは指定<em>しないでください</em>。</p>
<h3 id=priorityclass毎のリソースクォータ>PriorityClass毎のリソースクォータ</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>
<p>Podは特定の<a href=/docs/concepts/configuration/pod-priority-preemption/#pod-priority>優先度</a>で作成されます。リソースクォータのSpec内にある<code>scopeSelector</code>フィールドを使用して、Podの優先度に基づいてPodのシステムリソースの消費をコントロールできます。</p>
<p>リソースクォータのSpec内の<code>scopeSelector</code>によってPodが選択されたときのみ、そのリソースクォータが一致し、消費されます。</p>
<p>リソースクォータが<code>scopeSelector</code>フィールドを使用して優先度クラスに対してスコープされる場合、リソースクォータのオプジェクトは、次のリソースのみトラッキングするように制限されます:</p>
<ul>
<li><code>pods</code></li>
<li><code>cpu</code></li>
<li><code>memory</code></li>
<li><code>ephemeral-storage</code></li>
<li><code>limits.cpu</code></li>
<li><code>limits.memory</code></li>
<li><code>limits.ephemeral-storage</code></li>
<li><code>requests.cpu</code></li>
<li><code>requests.memory</code></li>
<li><code>requests.ephemeral-storage</code></li>
</ul>
<p>この例ではリソースクォータのオブジェクトを作成し、特定の優先度を持つPodに一致させます。この例は下記のように動作します。</p>
<ul>
<li>クラスター内のPodは"low"、"medium"、"high"の3つの優先度クラスのうち1つをもちます。</li>
<li>1つのリソースクォータのオブジェクトは優先度毎に作成されます。</li>
</ul>
<p>下記のYAMLを<code>quota.yml</code>というファイルに保存します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>List<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-high<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Gi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;high&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-medium<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;medium&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-low<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;low&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p><code>kubectl create</code>を実行してYAMLの内容を適用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./quota.yml
</code></pre></div><pre><code>resourcequota/pods-high created
resourcequota/pods-medium created
resourcequota/pods-low created
</code></pre><p><code>kubectl describe quota</code>を実行して<code>Used</code>クォータが<code>0</code>であることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota
</code></pre></div><pre><code>Name:       pods-high
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     1k
memory      0     200Gi
pods        0     10


Name:       pods-low
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     5
memory      0     10Gi
pods        0     10


Name:       pods-medium
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     10
memory      0     20Gi
pods        0     10
</code></pre><p>プライオリティーが"high"であるPodを作成します。下記の内容を<code>high-priority-pod.yml</code>というファイルに保存します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>ubuntu<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;while true; do echo hello; sleep 10;done&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>high<span style=color:#bbb>
</span></code></pre></div><p><code>kubectl create</code>でマニフェストを適用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./high-priority-pod.yml
</code></pre></div><p><code>pods-high</code>という名前のプライオリティーが"high"のクォータにおける"Used"項目の値が変更され、それ以外の2つの値は変更されていないことを確認してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota
</code></pre></div><pre><code>Name:       pods-high
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         500m  1k
memory      10Gi  200Gi
pods        1     10


Name:       pods-low
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     5
memory      0     10Gi
pods        0     10


Name:       pods-medium
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     10
memory      0     20Gi
pods        0     10
</code></pre><h2 id=リクエスト-vs-リミット>リクエスト vs リミット</h2>
<p>コンピュートリソースを分配する際に、各コンテナはCPUとメモリーそれぞれのリクエストとリミット値を指定します。クォータはそれぞれの値を設定できます。</p>
<p>クォータに<code>requests.cpu</code>や<code>requests.memory</code>の値が指定されている場合は、コンテナはそれらのリソースに対する明示的な要求を行います。同様に、クォータに<code>limits.cpu</code>や<code>limits.memory</code>の値が指定されている場合は、コンテナはそれらのリソースに対する明示的な制限を行います。</p>
<h2 id=viewing-and-setting-quotas>クォータの確認と設定</h2>
<p>kubectlでは、クォータの作成、更新、確認をサポートしています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt; compute-resources.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: ResourceQuota
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: compute-resources
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  hard:
</span><span style=color:#b44>    requests.cpu: &#34;1&#34;
</span><span style=color:#b44>    requests.memory: 1Gi
</span><span style=color:#b44>    limits.cpu: &#34;2&#34;
</span><span style=color:#b44>    limits.memory: 2Gi
</span><span style=color:#b44>    requests.nvidia.com/gpu: 4
</span><span style=color:#b44>EOF</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./compute-resources.yaml --namespace<span style=color:#666>=</span>myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt; object-counts.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: ResourceQuota
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: object-counts
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  hard:
</span><span style=color:#b44>    configmaps: &#34;10&#34;
</span><span style=color:#b44>    persistentvolumeclaims: &#34;4&#34;
</span><span style=color:#b44>    pods: &#34;4&#34;
</span><span style=color:#b44>    replicationcontrollers: &#34;20&#34;
</span><span style=color:#b44>    secrets: &#34;10&#34;
</span><span style=color:#b44>    services: &#34;10&#34;
</span><span style=color:#b44>    services.loadbalancers: &#34;2&#34;
</span><span style=color:#b44>EOF</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./object-counts.yaml --namespace<span style=color:#666>=</span>myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get quota --namespace<span style=color:#666>=</span>myspace
</code></pre></div><pre><code>NAME                    AGE
compute-resources       30s
object-counts           32s
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota compute-resources --namespace<span style=color:#666>=</span>myspace
</code></pre></div><pre><code>Name:                    compute-resources
Namespace:               myspace
Resource                 Used  Hard
--------                 ----  ----
limits.cpu               0     2
limits.memory            0     2Gi
requests.cpu             0     1
requests.memory          0     1Gi
requests.nvidia.com/gpu  0     4
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota object-counts --namespace<span style=color:#666>=</span>myspace
</code></pre></div><pre><code>Name:                   object-counts
Namespace:              myspace
Resource                Used    Hard
--------                ----    ----
configmaps              0       10
persistentvolumeclaims  0       4
pods                    0       4
replicationcontrollers  0       20
secrets                 1       10
services                0       10
services.loadbalancers  0       2
</code></pre><p>また、kubectlは<code>count/&lt;resource>.&lt;group></code>というシンタックスを用いることにより、名前空間に依存した全ての主要なリソースに対するオブジェクト数のクォータをサポートしています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create quota <span style=color:#a2f>test</span> --hard<span style=color:#666>=</span>count/deployments.apps<span style=color:#666>=</span>2,count/replicasets.apps<span style=color:#666>=</span>4,count/pods<span style=color:#666>=</span>3,count/secrets<span style=color:#666>=</span><span style=color:#666>4</span> --namespace<span style=color:#666>=</span>myspace
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>myspace --replicas<span style=color:#666>=</span><span style=color:#666>2</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe quota --namespace<span style=color:#666>=</span>myspace
</code></pre></div><pre><code>Name:                         test
Namespace:                    myspace
Resource                      Used  Hard
--------                      ----  ----
count/deployments.apps        1     2
count/pods                    2     3
count/replicasets.apps        1     4
count/secrets                 1     4
</code></pre><h2 id=クォータとクラスター容量>クォータとクラスター容量</h2>
<p>ResourceQuotaはクラスター容量に依存しません。またユニット数の絶対値で表されます。そのためクラスターにノードを追加したことにより、各名前空間が自動的により多くのリソースを消費するような機能が提供されるわけでは<em>ありません</em>。</p>
<p>下記のようなより複雑なポリシーが必要な状況があります。</p>
<ul>
<li>複数チーム間でクラスターリソースの総量を分けあう。</li>
<li>各テナントが必要な時にリソース使用量を増やせるようにするが、偶発的なリソースの枯渇を防ぐために上限を設定する。</li>
<li>1つの名前空間に対してリソース消費の需要を検出し、ノードを追加し、クォータを増加させる。</li>
</ul>
<p>このようなポリシーは、クォータの使用量の監視と、他のシグナルにしたがってクォータのハードの制限を調整する"コントローラー"を記述することにより、ResourceQuotaをビルディングブロックのように使用して実装できます。</p>
<p>リソースクォータは集約されたクラスターリソースを分割しますが、ノードに対しては何の制限も行わないことに注意して下さい。例: 複数の名前空間のPodは同一のノード上で稼働する可能性があります。</p>
<h2 id=limit-priority-class-consumption-by-default>デフォルトで優先度クラスの消費を制限する</h2>
<p>例えば"cluster-services"のように、条件に一致するクォータオブジェクトが存在する場合に限り、特定の優先度のPodを名前空間で許可することが望ましい場合があります。</p>
<p>このメカニズムにより、オペレーターは特定の高優先度クラスの使用を限られた数の名前空間に制限することができ、全ての名前空間でこれらの優先度クラスをデフォルトで使用することはできなくなります。</p>
<p>これを実施するには、<code>kube-apiserver</code>の<code>--admission-control-config-file</code>というフラグを使い、下記の設定ファイルに対してパスを渡す必要がります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ResourceQuota&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuotaConfiguration<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limitedResources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>pods<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchScopes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;cluster-services&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>なお、"cluster-services"Podは、条件に一致する<code>scopeSelector</code>を持つクォータオブジェクトが存在する名前空間でのみ許可されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;cluster-services&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li>さらなる情報は<a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_resource_quota.md>クォータの design doc</a>を参照してください。</li>
<li><a href=/docs/tasks/administer-cluster/quota-api-object/>リソースクォータの使用方法の例</a>を参照してください。</li>
<li><a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/pod-priority-resourcequota.md>優先度クラスに対するクォータサポートの design doc</a>を参照してください。</li>
<li><a href=https://github.com/kubernetes/kubernetes/pull/36765>LimitedResources</a>を参照してください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-285a3785fd3d20f437c28d87ca4dadca>3.11 - クラスターの管理</h1>
</div>
<div class=td-content>
<h1 id=pg-fb494ea3b1874bd753dcd11c3f35c2dc>3.11.1 - クラスター管理の概要</h1>
<p>このページはKubernetesクラスターの作成や管理者向けの内容です。Kubernetesのコア<a href=/ja/docs/concepts/>コンセプト</a>についてある程度精通していることを前提とします。</p>
<h2 id=クラスターのプランニング>クラスターのプランニング</h2>
<p>Kubernetesクラスターの計画、セットアップ、設定の例を知るには<a href=/ja/docs/setup/>設定</a>のガイドを参照してください。この記事で列挙されているソリューションは<em>ディストリビューション</em> と呼ばれます。</p>
<p>ガイドを選択する前に、いくつかの考慮事項を挙げます。</p>
<ul>
<li>ユーザーのコンピューター上でKubernetesを試したいでしょうか、それとも高可用性のあるマルチノードクラスターを構築したいでしょうか？あなたのニーズにあったディストリビューションを選択してください。</li>
<li><strong>もしあなたが高可用性を求める場合</strong>、 <a href=/docs/concepts/cluster-administration/federation/>複数ゾーンにまたがるクラスター</a>の設定について学んでください。</li>
<li><a href=https://cloud.google.com/kubernetes-engine/>Google Kubernetes Engine</a>のような<strong>ホストされているKubernetesクラスター</strong>を使用するのか、それとも<strong>自分自身でクラスターをホストするのでしょうか</strong>？</li>
<li>使用するクラスターは<strong>オンプレミス</strong>なのか、それとも<strong>クラウド(IaaS)</strong> でしょうか？Kubernetesはハイブリッドクラスターを直接サポートしていません。その代わりユーザーは複数のクラスターをセットアップできます。</li>
<li>Kubernetesを <strong>「ベアメタル」なハードウェア</strong>上で稼働させますか？それとも<strong>仮想マシン(VMs)</strong> 上で稼働させますか？</li>
<li><strong>もしオンプレミスでKubernetesを構築する場合</strong>、どの<a href=/ja/docs/concepts/cluster-administration/networking/>ネットワークモデル</a>が最適か検討してください。</li>
<li><strong>ただクラスターを稼働させたいだけ</strong>でしょうか、それとも<strong>Kubernetesプロジェクトのコードの開発</strong>を行いたいでしょうか？もし後者の場合、開発が進行中のディストリビューションを選択してください。いくつかのディストリビューションはバイナリリリースのみ使用していますが、多くの選択肢があります。</li>
<li>クラスターを稼働させるのに必要な<a href=/ja/docs/concepts/overview/components/>コンポーネント</a>についてよく理解してください。</li>
</ul>
<p>注意: 全てのディストリビューションがアクティブにメンテナンスされている訳ではありません。最新バージョンのKubernetesでテストされたディストリビューションを選択してください。</p>
<h2 id=クラスターの管理>クラスターの管理</h2>
<ul>
<li>
<p><a href=/ja/docs/concepts/architecture/nodes/>ノードの管理</a>方法について学んでください。</p>
</li>
<li>
<p>共有クラスターにおける<a href=/docs/concepts/policy/resource-quotas/>リソースクォータ</a>のセットアップと管理方法について学んでください。</p>
</li>
</ul>
<h2 id=クラスターをセキュアにする>クラスターをセキュアにする</h2>
<ul>
<li>
<p><a href=/ja/docs/concepts/cluster-administration/certificates/>Certificates</a>では、異なるツールチェインを使用して証明書を作成する方法を説明します。</p>
</li>
<li>
<p><a href=/ja/docs/concepts/containers/container-environment/>Kubernetes コンテナの環境</a>では、Kubernetesノード上でのKubeletが管理するコンテナの環境について説明します。</p>
</li>
<li>
<p><a href=/docs/concepts/security/controlling-access>Kubernetes APIへのアクセス制御</a>では、Kubernetesで自身のAPIに対するアクセスコントロールがどのように実装されているかを説明します。</p>
</li>
<li>
<p><a href=/docs/reference/access-authn-authz/authentication/>認証</a>では、様々な認証オプションを含むKubernetesでの認証について説明します。</p>
</li>
<li>
<p><a href=/docs/reference/access-authn-authz/authorization/>認可</a>では、認証とは別に、HTTPリクエストの処理方法を制御します。</p>
</li>
<li>
<p><a href=/docs/reference/access-authn-authz/admission-controllers/>アドミッションコントローラーの使用</a>では、認証と認可の後にKubernetes APIに対するリクエストをインターセプトするプラグインについて説明します。</p>
</li>
<li>
<p><a href=/docs/concepts/cluster-administration/sysctl-cluster/>Kubernetesクラスターでのsysctlの使用</a>では、管理者向けにカーネルパラメーターを設定するため<code>sysctl</code>コマンドラインツールの使用方法について解説します。</p>
</li>
<li>
<p><a href=/docs/tasks/debug-application-cluster/audit/>クラスターの監査</a>では、Kubernetesの監査ログの扱い方について解説します。</p>
</li>
</ul>
<h3 id=kubeletをセキュアにする>kubeletをセキュアにする</h3>
<ul>
<li><a href=/ja/docs/concepts/architecture/master-node-communication/>マスターとノードのコミュニケーション</a></li>
<li><a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLSのブートストラップ</a></li>
<li><a href=/docs/admin/kubelet-authentication-authorization/>Kubeletの認証/認可</a></li>
</ul>
<h2 id=オプションのクラスターサービス>オプションのクラスターサービス</h2>
<ul>
<li>
<p><a href=/ja/docs/concepts/services-networking/dns-pod-service/>DNSのインテグレーション</a>では、DNS名をKubernetes Serviceに直接名前解決する方法を解説します。</p>
</li>
<li>
<p><a href=/docs/concepts/cluster-administration/logging/>クラスターアクティビィのロギングと監視</a>では、Kubernetesにおけるロギングがどのように行われ、どう実装されているかについて解説します。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2bf9a93ab5ba014fb6ff70b22c29d432>3.11.2 - 証明書</h1>
<p>クライアント証明書認証を使用する場合、<code>easyrsa</code>や<code>openssl</code>、<code>cfssl</code>を用いて、手動で証明書を生成できます。</p>
<h3 id=easyrsa>easyrsa</h3>
<p><strong>easyrsa</strong>を用いると、クラスターの証明書を手動で生成できます。</p>
<ol>
<li>
<p>パッチを当てたバージョンのeasyrsa3をダウンロードして解凍し、初期化します。</p>
<pre><code>curl -LO https://storage.googleapis.com/kubernetes-release/easy-rsa/easy-rsa.tar.gz
tar xzf easy-rsa.tar.gz
cd easy-rsa-master/easyrsa3
./easyrsa init-pki
</code></pre>
</li>
<li>
<p>新しい認証局(CA)を生成します。<code>--batch</code>は自動モードを設定し、<code>--req-cn</code>はCAの新しいルート証明書の共通名(CN)を指定します。</p>
<pre><code>./easyrsa --batch &quot;--req-cn=${MASTER_IP}@`date +%s`&quot; build-ca nopass
</code></pre>
</li>
<li>
<p>サーバー証明書と鍵を生成します。
引数<code>--subject-alt-name</code>は、APIサーバーへのアクセスに使用できるIPおよびDNS名を設定します。
<code>MASTER_CLUSTER_IP</code>は通常、APIサーバーとコントローラーマネージャーコンポーネントの両方で引数<code>--service-cluster-ip-range</code>として指定されるサービスCIDRの最初のIPです。
引数<code>--days</code>は、証明書の有効期限が切れるまでの日数を設定するために使われます。
以下の例は、デフォルトのDNSドメイン名として<code>cluster.local</code>を使用していることを前提とします。</p>
<pre><code>./easyrsa --subject-alt-name=&quot;IP:${MASTER_IP},&quot;\
&quot;IP:${MASTER_CLUSTER_IP},&quot;\
&quot;DNS:kubernetes,&quot;\
&quot;DNS:kubernetes.default,&quot;\
&quot;DNS:kubernetes.default.svc,&quot;\
&quot;DNS:kubernetes.default.svc.cluster,&quot;\
&quot;DNS:kubernetes.default.svc.cluster.local&quot; \
--days=10000 \
build-server-full server nopass
</code></pre>
</li>
<li>
<p><code>pki/ca.crt</code>、<code>pki/issued/server.crt</code>、<code>pki/private/server.key</code>をディレクトリーにコピーします。</p>
</li>
<li>
<p>以下のパラメーターを、APIサーバーの開始パラメーターとして追加します。</p>
<pre><code>--client-ca-file=/yourdirectory/ca.crt
--tls-cert-file=/yourdirectory/server.crt
--tls-private-key-file=/yourdirectory/server.key
</code></pre>
</li>
</ol>
<h3 id=openssl>openssl</h3>
<p><strong>openssl</strong>はクラスターの証明書を手動で生成できます。</p>
<ol>
<li>
<p>2048ビットのca.keyを生成します。</p>
<pre><code>openssl genrsa -out ca.key 2048
</code></pre>
</li>
<li>
<p>ca.keyに応じて、ca.crtを生成します。証明書の有効期間を設定するには、-daysを使用します。</p>
<pre><code>openssl req -x509 -new -nodes -key ca.key -subj &quot;/CN=${MASTER_IP}&quot; -days 10000 -out ca.crt
</code></pre>
</li>
<li>
<p>2048ビットのserver.keyを生成します。</p>
<pre><code>openssl genrsa -out server.key 2048
</code></pre>
</li>
<li>
<p>証明書署名要求(CSR)を生成するための設定ファイルを生成します。
ファイル(例: <code>csr.conf</code>)に保存する前に、かぎ括弧で囲まれた値(例: <code>&lt;MASTER_IP></code>)を必ず実際の値に置き換えてください。
<code>MASTER_CLUSTER_IP</code>の値は、前節で説明したAPIサーバーのサービスクラスターIPであることに注意してください。
以下の例は、デフォルトのDNSドメイン名として<code>cluster.local</code>を使用していることを前提とします。</p>
<pre><code>[ req ]
default_bits = 2048
prompt = no
default_md = sha256
req_extensions = req_ext
distinguished_name = dn

[ dn ]
C = &lt;country&gt;
ST = &lt;state&gt;
L = &lt;city&gt;
O = &lt;organization&gt;
OU = &lt;organization unit&gt;
CN = &lt;MASTER_IP&gt;

[ req_ext ]
subjectAltName = @alt_names

[ alt_names ]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster
DNS.5 = kubernetes.default.svc.cluster.local
IP.1 = &lt;MASTER_IP&gt;
IP.2 = &lt;MASTER_CLUSTER_IP&gt;

[ v3_ext ]
authorityKeyIdentifier=keyid,issuer:always
basicConstraints=CA:FALSE
keyUsage=keyEncipherment,dataEncipherment
extendedKeyUsage=serverAuth,clientAuth
subjectAltName=@alt_names
</code></pre>
</li>
<li>
<p>設定ファイルに基づいて、証明書署名要求を生成します。</p>
<pre><code>openssl req -new -key server.key -out server.csr -config csr.conf
</code></pre>
</li>
<li>
<p>ca.key、ca.crt、server.csrを使用してサーバー証明書を生成します。</p>
<pre><code>openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key \
-CAcreateserial -out server.crt -days 10000 \
-extensions v3_ext -extfile csr.conf
</code></pre>
</li>
<li>
<p>証明書を表示します。</p>
<pre><code>openssl x509  -noout -text -in ./server.crt
</code></pre>
</li>
</ol>
<p>最後にAPIサーバーの起動パラメーターに、同様のパラメーターを追加します。</p>
<h3 id=cfssl>cfssl</h3>
<p><strong>cfssl</strong>も証明書を生成するためのツールです。</p>
<ol>
<li>
<p>以下のように、ダウンロードして解凍し、コマンドラインツールを用意します。
使用しているハードウェアアーキテクチャやcfsslのバージョンに応じて、サンプルコマンドの調整が必要な場合があります。</p>
<pre><code>curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl_1.5.0_linux_amd64 -o cfssl
chmod +x cfssl
curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssljson_1.5.0_linux_amd64 -o cfssljson
chmod +x cfssljson
curl -L https://github.com/cloudflare/cfssl/releases/download/v1.5.0/cfssl-certinfo_1.5.0_linux_amd64 -o cfssl-certinfo
chmod +x cfssl-certinfo
</code></pre>
</li>
<li>
<p>アーティファクトを保持するディレクトリーを生成し、cfsslを初期化します。</p>
<pre><code>mkdir cert
cd cert
../cfssl print-defaults config &gt; config.json
../cfssl print-defaults csr &gt; csr.json
</code></pre>
</li>
<li>
<p>CAファイルを生成するためのJSON設定ファイル(例: <code>ca-config.json</code>)を生成します。</p>
<pre><code>{
  &quot;signing&quot;: {
    &quot;default&quot;: {
      &quot;expiry&quot;: &quot;8760h&quot;
    },
    &quot;profiles&quot;: {
      &quot;kubernetes&quot;: {
        &quot;usages&quot;: [
          &quot;signing&quot;,
          &quot;key encipherment&quot;,
          &quot;server auth&quot;,
          &quot;client auth&quot;
        ],
        &quot;expiry&quot;: &quot;8760h&quot;
      }
    }
  }
}
</code></pre>
</li>
<li>
<p>CA証明書署名要求(CSR)用のJSON設定ファイル(例: <code>ca-csr.json</code>)を生成します。
かぎ括弧で囲まれた値は、必ず使用したい実際の値に置き換えてください。</p>
<pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;:[{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre>
</li>
<li>
<p>CA鍵(<code>ca-key.pem</code>)と証明書(<code>ca.pem</code>)を生成します。</p>
<pre><code>../cfssl gencert -initca ca-csr.json | ../cfssljson -bare ca
</code></pre>
</li>
<li>
<p>APIサーバーの鍵と証明書を生成するためのJSON設定ファイル(例: <code>server-csr.json</code>)を生成します。
かぎ括弧で囲まれた値は、必ず使用したい実際の値に置き換えてください。
<code>MASTER_CLUSTER_IP</code>の値は、前節で説明したAPIサーバーのサービスクラスターIPです。
以下の例は、デフォルトのDNSドメイン名として<code>cluster.local</code>を使用していることを前提とします。</p>
<pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;hosts&quot;: [
    &quot;127.0.0.1&quot;,
    &quot;&lt;MASTER_IP&gt;&quot;,
    &quot;&lt;MASTER_CLUSTER_IP&gt;&quot;,
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.cluster&quot;,
    &quot;kubernetes.default.svc.cluster.local&quot;
  ],
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre>
</li>
<li>
<p>APIサーバーの鍵と証明書を生成します。デフォルトでは、それぞれ<code>server-key.pem</code>と<code>server.pem</code>というファイルに保存されます。</p>
<pre><code>../cfssl gencert -ca=ca.pem -ca-key=ca-key.pem \
--config=ca-config.json -profile=kubernetes \
server-csr.json | ../cfssljson -bare server
</code></pre>
</li>
</ol>
<h2 id=自己署名ca証明書の配布>自己署名CA証明書の配布</h2>
<p>クライアントノードは、自己署名CA証明書を有効だと認識しないことがあります。
プロダクション用でない場合や、会社のファイアウォールの背後で実行する場合は、自己署名CA証明書をすべてのクライアントに配布し、有効な証明書のローカルリストを更新できます。</p>
<p>各クライアントで、以下の操作を実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo cp ca.crt /usr/local/share/ca-certificates/kubernetes.crt
sudo update-ca-certificates
</code></pre></div><pre><code>Updating certificates in /etc/ssl/certs...
1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d....
done.
</code></pre><h2 id=証明書api>証明書API</h2>
<p><code>certificates.k8s.io</code>APIを用いることで、<a href=/ja/docs/tasks/tls/managing-tls-in-a-cluster>こちら</a>のドキュメントにあるように、認証に使用するx509証明書をプロビジョニングすることができます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3aeeecf7cdb2a21eb4b31db7a71c81e2>3.11.3 - リソースの管理</h1>
<p>アプリケーションをデプロイし、Serviceを介して外部に公開できました。さて、どうしますか？Kubernetesは、スケーリングや更新など、アプリケーションのデプロイを管理するための多くのツールを提供します。
我々が取り上げる機能についての詳細は<a href=/ja/docs/concepts/configuration/overview/>設定ファイル</a>と<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベル</a>について詳細に説明します。</p>
<h2 id=リソースの設定を管理する>リソースの設定を管理する</h2>
<p>多くのアプリケーションではDeploymentやServiceなど複数のリソースの作成を要求します。複数のリソースの管理は、同一のファイルにひとまとめにしてグループ化すると簡単になります(YAMLファイル内で<code>---</code>で区切る)。
例えば:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/nginx-app.yaml download=application/nginx-app.yaml><code>application/nginx-app.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-nginx-app-yaml')" title="Copy application/nginx-app.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-nginx-app-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx-svc<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>複数のリソースは単一のリソースと同様の方法で作成できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/nginx-app.yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>service/my-nginx-svc created
deployment.apps/my-nginx created
</code></pre></div><p>リソースは、ファイル内に記述されている順番通りに作成されます。そのため、Serviceを最初に指定するのが理想です。スケジューラーがServiceに関連するPodを、Deploymentなどのコントローラーによって作成されるときに確実に拡散できるようにするためです。</p>
<p><code>kubectl apply</code>もまた、複数の<code>-f</code>による引数指定を許可しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/nginx/nginx-svc.yaml -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml
</code></pre></div><p>個別のファイルに加えて、-fの引数としてディレクトリ名も指定できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/nginx/
</code></pre></div><p><code>kubectl</code>は<code>.yaml</code>、<code>.yml</code>、<code>.json</code>といったサフィックスの付くファイルを読み込みます。</p>
<p>同じマイクロサービス、アプリケーションティアーのリソースは同一のファイルにまとめ、アプリケーションに関するファイルをグループ化するために、それらのファイルを同一のディレクトリに配備するのを推奨します。アプリケーションのティアーがDNSを通じて互いにバインドされると、アプリケーションスタックの全てのコンポーネントをひとまとめにして簡単にデプロイできます。</p>
<p>リソースの設定ソースとして、URLも指定できます。githubから取得した設定ファイルから直接手軽にデプロイができます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/application/nginx/nginx-deployment.yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps/my-nginx created
</code></pre></div><h2 id=kubectlによる一括操作>kubectlによる一括操作</h2>
<p><code>kubectl</code>が一括して実行できる操作はリソースの作成のみではありません。作成済みのリソースの削除などの他の操作を実行するために、設定ファイルからリソース名を取得することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete -f https://k8s.io/examples/application/nginx-app.yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps <span style=color:#b44>&#34;my-nginx&#34;</span> deleted
service <span style=color:#b44>&#34;my-nginx-svc&#34;</span> deleted
</code></pre></div><p>2つのリソースだけを削除する場合には、コマンドラインでリソース/名前というシンタックスを使うことで簡単に指定できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployments/my-nginx services/my-nginx-svc
</code></pre></div><p>さらに多くのリソースに対する操作では、リソースをラベルでフィルターするために<code>-l</code>や<code>--selector</code>を使ってセレクター(ラベルクエリ)を指定するのが簡単です:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment,services -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps <span style=color:#b44>&#34;my-nginx&#34;</span> deleted
service <span style=color:#b44>&#34;my-nginx-svc&#34;</span> deleted
</code></pre></div><p><code>kubectl</code>は同様のシンタックスでリソース名を出力するので、<code>$()</code>や<code>xargs</code>を使ってパイプで操作するのが容易です:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get <span style=color:#a2f;font-weight:700>$(</span>kubectl create -f docs/concepts/cluster-administration/nginx/ -o name | grep service<span style=color:#a2f;font-weight:700>)</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME           TYPE           CLUSTER-IP   EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>      AGE
my-nginx-svc   LoadBalancer   10.0.0.208   &lt;pending&gt;     80/TCP       0s
</code></pre></div><p>上記のコマンドで、最初に<code>examples/application/nginx/</code>配下でリソースを作成し、<code>-o name</code>という出力フォーマットにより、作成されたリソースの名前を表示します(各リソースをresource/nameという形式で表示)。そして"service"のみ<code>grep</code>し、<code>kubectl get</code>を使って表示させます。</p>
<p>あるディレクトリ内の複数のサブディレクトリをまたいでリソースを管理するような場合、<code>--filename,-f</code>フラグと合わせて<code>--recursive</code>や<code>-R</code>を指定することでサブディレクトリに対しても再帰的に操作が可能です。</p>
<p>例えば、開発環境用に必要な全ての<a class=glossary-tooltip title="A serialized specification of one or more Kubernetes API objects." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-manifest" target=_blank aria-label=マニフェスト>マニフェスト</a>をリソースタイプによって整理している<code>project/k8s/development</code>というディレクトリがあると仮定します。</p>
<pre><code>project/k8s/development
├── configmap
│   └── my-configmap.yaml
├── deployment
│   └── my-deployment.yaml
└── pvc
    └── my-pvc.yaml
</code></pre><p>デフォルトでは、<code>project/k8s/development</code>における一括操作は、どのサブディレクトリも処理せず、ディレクトリの第1階層で処理が止まります。下記のコマンドによってこのディレクトリ配下でリソースを作成しようとすると、エラーが発生します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f project/k8s/development
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>error: you must provide one or more resources by argument or filename <span style=color:#666>(</span>.json|.yaml|.yml|stdin<span style=color:#666>)</span>
</code></pre></div><p>代わりに、下記のように<code>--filename,-f</code>フラグと合わせて<code>--recursive</code>や<code>-R</code>を指定してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f project/k8s/development --recursive
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>configmap/my-config created
deployment.apps/my-deployment created
persistentvolumeclaim/my-pvc created
</code></pre></div><p><code>--recursive</code>フラグは<code>kubectl {create,get,delete,describe,rollout}</code>などのような<code>--filename,-f</code>フラグを扱うどの操作でも有効です。</p>
<p>また、<code>--recursive</code>フラグは複数の<code>-f</code>フラグの引数を指定しても有効です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f project/k8s/namespaces -f project/k8s/development --recursive
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>namespace/development created
namespace/staging created
configmap/my-config created
deployment.apps/my-deployment created
persistentvolumeclaim/my-pvc created
</code></pre></div><p><code>kubectl</code>についてさらに知りたい場合は、<a href=/docs/reference/kubectl/overview/>kubectlの概要</a>を参照してください。</p>
<h2 id=ラベルを有効に使う>ラベルを有効に使う</h2>
<p>これまで取り上げた例では、リソースに対して最大1つのラベルを適用してきました。リソースのセットを他のセットと区別するために、複数のラベルが必要な状況があります。</p>
<p>例えば、異なるアプリケーション間では、異なる<code>app</code>ラベルを使用したり、<a href=https://github.com/kubernetes/examples/tree/v1.22.16/guestbook/>ゲストブックの例</a>のようなマルチティアーのアプリケーションでは、各ティアーを区別する必要があります。frontendというティアーでは下記のラベルを持ちます。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></code></pre></div><p>Redisマスターやスレーブでは異なる<code>tier</code>ラベルを持ち、加えて<code>role</code>ラベルも持つことでしょう。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></code></pre></div><p>そして</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>slave<span style=color:#bbb>
</span></code></pre></div><p>ラベルを使用すると、ラベルで指定された任意の次元に沿ってリソースを分割できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f examples/guestbook/all-in-one/guestbook-all-in-one.yaml
kubectl get pods -Lapp -Ltier -Lrole
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                           READY     STATUS    RESTARTS   AGE       APP         TIER       ROLE
guestbook-fe-4nlpb             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
guestbook-fe-ght6d             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
guestbook-fe-jpy62             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
guestbook-redis-master-5pg3b   1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    master
guestbook-redis-slave-2q2yf    1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    slave
guestbook-redis-slave-qgazl    1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    slave
my-nginx-divi2                 1/1       Running   <span style=color:#666>0</span>          29m       nginx       &lt;none&gt;     &lt;none&gt;
my-nginx-o0ef1                 1/1       Running   <span style=color:#666>0</span>          29m       nginx       &lt;none&gt;     &lt;none&gt;
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -lapp<span style=color:#666>=</span>guestbook,role<span style=color:#666>=</span>slave
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                          READY     STATUS    RESTARTS   AGE
guestbook-redis-slave-2q2yf   1/1       Running   <span style=color:#666>0</span>          3m
guestbook-redis-slave-qgazl   1/1       Running   <span style=color:#666>0</span>          3m
</code></pre></div><h2 id=canary-deployments-カナリアデプロイ>Canary deployments カナリアデプロイ</h2>
<p>複数のラベルが必要な他の状況として、異なるリリース間でのDeploymentや、同一コンポーネントの設定を区別することが挙げられます。よく知られたプラクティスとして、本番環境の実際のトラフィックを受け付けるようにするために、新しいリリースを完全にロールアウトする前に、新しい<em>カナリア版</em>のアプリケーションを過去のリリースと合わせてデプロイする方法があります。</p>
<p>例えば、異なるリリースバージョンを分けるために<code>track</code>ラベルを使用できます。</p>
<p>主要な安定板のリリースでは<code>track</code>ラベルに<code>stable</code>という値をつけることがあるでしょう。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gb-frontend:v3<span style=color:#bbb>
</span></code></pre></div><p>そして2つの異なるPodのセットを上書きしないようにするため、<code>track</code>ラベルに異なる値を持つ(例: <code>canary</code>)ようなguestbookフロントエンドの新しいリリースを作成できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-canary<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>canary<span style=color:#bbb>
</span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gb-frontend:v4<span style=color:#bbb>
</span></code></pre></div><p>frontend Serviceは、トラフィックを両方のアプリケーションにリダイレクトさせるために、両方のアプリケーションに共通したラベルのサブセットを選択して両方のレプリカを扱えるようにします。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></code></pre></div><p>安定版とカナリア版リリースで本番環境の実際のトラフィックを転送する割合を決めるため、双方のレプリカ数を変更できます(このケースでは3対1)。
最新版のリリースをしても大丈夫な場合、安定版のトラックを新しいアプリケーションにして、カナリア版を削除します。</p>
<p>さらに具体的な例については、<a href=https://github.com/kelseyhightower/talks/tree/master/kubecon-eu-2016/demo#deploy-a-canary>tutorial of deploying Ghost</a>を参照してください。</p>
<h2 id=ラベルの更新>ラベルの更新</h2>
<p>新しいリソースを作成する前に、既存のPodと他のリソースのラベルの変更が必要な状況があります。これは<code>kubectl label</code>で実行できます。
例えば、全てのnginx Podを frontendティアーとしてラベル付けするには、下記のコマンドを実行するのみです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl label pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx <span style=color:#b8860b>tier</span><span style=color:#666>=</span>fe
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>pod/my-nginx-2035384211-j5fhi labeled
pod/my-nginx-2035384211-u2c7e labeled
pod/my-nginx-2035384211-u3t6x labeled
</code></pre></div><p>これは最初に"app=nginx"というラベルのついたPodをフィルターし、そのPodに対して"tier=fe"というラベルを追加します。
ラベル付けしたPodを確認するには、下記のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -L tier
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                        READY     STATUS    RESTARTS   AGE       TIER
my-nginx-2035384211-j5fhi   1/1       Running   <span style=color:#666>0</span>          23m       fe
my-nginx-2035384211-u2c7e   1/1       Running   <span style=color:#666>0</span>          23m       fe
my-nginx-2035384211-u3t6x   1/1       Running   <span style=color:#666>0</span>          23m       fe
</code></pre></div><p>このコマンドでは"app=nginx"というラベルのついた全てのPodを出力し、Podのtierという項目も表示します(<code>-L</code>または<code>--label-columns</code>で指定)。</p>
<p>さらなる情報は、<a href=/docs/concepts/overview/working-with-objects/labels/>ラベル</a>や<a href=/docs/reference/generated/kubectl/kubectl-commands/#label>kubectl label</a>を参照してください。</p>
<h2 id=アノテーションの更新>アノテーションの更新</h2>
<p>リソースに対してアノテーションを割り当てたい状況があります。アノテーションは、ツール、ライブラリなどのAPIクライアントによって取得するための任意の非識別メタデータです。アノテーションの割り当ては<code>kubectl annotate</code>で可能です。例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl annotate pods my-nginx-v4-9gw19 <span style=color:#b8860b>description</span><span style=color:#666>=</span><span style=color:#b44>&#39;my frontend running nginx&#39;</span>
kubectl get pods my-nginx-v4-9gw19 -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apiVersion: v1
kind: pod
metadata:
  annotations:
    description: my frontend running nginx
...
</code></pre></div><p>さらなる情報は、<a href=/docs/concepts/overview/working-with-objects/annotations/>アノテーション</a> や、<a href=/docs/reference/generated/kubectl/kubectl-commands/#annotate>kubectl annotate</a>を参照してください。</p>
<h2 id=アプリケーションのスケール>アプリケーションのスケール</h2>
<p>アプリケーションの負荷が増減するとき、<code>kubectl</code>を使って簡単にスケールできます。例えば、nginxのレプリカを3から1に減らす場合、下記を実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment/my-nginx --replicas<span style=color:#666>=</span><span style=color:#666>1</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps/my-nginx scaled
</code></pre></div><p>実行すると、Deploymentによって管理されるPod数が1となります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                        READY     STATUS    RESTARTS   AGE
my-nginx-2035384211-j5fhi   1/1       Running   <span style=color:#666>0</span>          30m
</code></pre></div><p>システムに対してnginxのレプリカ数を自動で選択させるには、下記のように1から3の範囲で指定します。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl autoscale deployment/my-nginx --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>3</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>horizontalpodautoscaler.autoscaling/my-nginx autoscaled
</code></pre></div><p>実行すると、nginxのレプリカは必要に応じて自動でスケールアップ、スケールダウンします。</p>
<p>さらなる情報は、<a href=/docs/reference/generated/kubectl/kubectl-commands/#scale>kubectl scale</a>、<a href=/docs/reference/generated/kubectl/kubectl-commands/#autoscale>kubectl autoscale</a> and <a href=/docs/tasks/run-application/horizontal-pod-autoscale/>horizontal pod autoscaler</a>を参照してください。</p>
<h2 id=リソースの直接的アップデート>リソースの直接的アップデート</h2>
<p>場合によっては、作成したリソースに対して処理を中断させずに更新を行う必要があります。</p>
<h3 id=kubectl-apply>kubectl apply</h3>
<p>開発者が設定するリソースをコードとして管理しバージョニングも行えるように、設定ファイルのセットをソースによって管理する方法が推奨されています。
この場合、クラスターに対して設定の変更をプッシュするために<a href=/docs/reference/generated/kubectl/kubectl-commands/#apply><code>kubectl apply</code></a>を使用できます。</p>
<p>このコマンドは、リソース設定の過去のバージョンと、今適用した変更を比較し、差分に現れないプロパティーに対して上書き変更することなくクラスターに適用させます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml
deployment.apps/my-nginx configured
</code></pre></div><p>注意として、前回の変更適用時からの設定の変更内容を決めるため、<code>kubectl apply</code>はリソースに対してアノテーションを割り当てます。変更が実施されると<code>kubectl apply</code>は、1つ前の設定内容と、今回変更しようとする入力内容と、現在のリソースの設定との3つの間で変更内容の差分をとります。</p>
<p>現在、リソースはこのアノテーションなしで作成されました。そのため、最初の<code>kubectl paply</code>の実行においては、与えられたにゅうチョクト、現在のリソースの設定の2つの間の差分が取られ、フォールバックします。この最初の実行の間、リソースが作成された時にプロパティーセットの削除を検知できません。この理由により、プロパティーの削除はされません。</p>
<p><code>kubectl apply</code>の実行後の全ての呼び出しや、<code>kubectl replace</code>や<code>kubectl edit</code>などの設定を変更する他のコマンドではアノテーションを更新します。<code>kubectl apply</code>した後の全ての呼び出しにおいて3-wayの差分取得によってプロパティの検知と削除を実施します。</p>
<h3 id=kubectl-edit>kubectl edit</h3>
<p>その他に、<code>kubectl edit</code>によってリソースの更新もできます。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit deployment/my-nginx
</code></pre></div><p>このコマンドは、最初にリソースを<code>get</code>し、テキストエディタでリソースを編集し、更新されたバージョンでリソースを<code>apply</code>します。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment my-nginx -o yaml &gt; /tmp/nginx.yaml
vi /tmp/nginx.yaml
<span style=color:#080;font-style:italic># yamlファイルを編集し、ファイルを保存します。</span>

kubectl apply -f /tmp/nginx.yaml
deployment.apps/my-nginx configured

rm /tmp/nginx.yaml
</code></pre></div><p>このコマンドによってより重大な変更を簡単に行えます。注意として、あなたの<code>EDITOR</code>や<code>KUBE_EDITOR</code>といった環境変数も指定できます。</p>
<p>さらなる情報は、<a href=/docs/reference/generated/kubectl/kubectl-commands/#edit>kubectl edit</a>を参照してください。</p>
<h3 id=kubectl-patch>kubectl patch</h3>
<p>APIオブジェクトの更新には<code>kubectl patch</code>を使うことができます。このコマンドはJSON patch、JSON merge patch、戦略的merge patchをサポートしています。
<a href=/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>kubectl patchを使ったAPIオブジェクトの更新</a>や<a href=/docs/reference/generated/kubectl/kubectl-commands/#patch>kubectl patch</a>を参照してください。</p>
<h2 id=破壊的なアップデート>破壊的なアップデート</h2>
<p>一度初期化された後、更新できないようなリソースフィールドの更新が必要な場合や、Deploymentによって作成され、壊れている状態のPodを修正するなど、再帰的な変更を即座に行いたい場合があります。このようなフィールドを変更するため、リソースの削除と再作成を行う<code>replace --force</code>を使用してください。このケースでは、シンプルに元の設定ファイルを修正するのみです。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl replace -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml --force
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps/my-nginx deleted
deployment.apps/my-nginx replaced
</code></pre></div><h2 id=サービス停止なしでアプリケーションを更新する>サービス停止なしでアプリケーションを更新する</h2>
<p>ある時点で、前述したカナリアデプロイのシナリオにおいて、新しいイメージやイメージタグを指定することによって、デプロイされたアプリケーションを更新が必要な場合があります。<code>kubectl</code>ではいくつかの更新操作をサポートしており、それぞれの操作が異なるシナリオに対して適用可能です。</p>
<p>ここでは、Deploymentを使ってアプリケーションの作成と更新についてガイドします。</p>
<p>まずnginxのバージョン1.14.2を稼働させていると仮定します。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment my-nginx --image<span style=color:#666>=</span>nginx:1.14.2
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps/my-nginx created
</code></pre></div><p>レプリカ数を3にします(新旧のリビジョンは混在します)。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment my-nginx --current-replicas<span style=color:#666>=</span><span style=color:#666>1</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span>
</code></pre></div><pre><code>deployment.apps/my-nginx scaled
</code></pre><p>バージョン1.16.1に更新するには、上述したkubectlコマンドを使って<code>.spec.template.spec.containers[0].image</code>の値を<code>nginx:1.14.2</code>から<code>nginx:1.16.1</code>に変更するだけでできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit deployment/my-nginx
</code></pre></div><p>できました!Deploymentはデプロイされたnginxのアプリケーションを宣言的にプログレッシブに更新します。更新途中では、決まった数の古いレプリカのみダウンし、一定数の新しいレプリカが希望するPod数以上作成されても良いことを保証します。詳細について学ぶには<a href=/docs/concepts/workloads/controllers/deployment/>Deployment page</a>を参照してください。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/debug-application-cluster/debug-application-introspection/>アプリケーションの調査とデバッグのための<code>kubectl</code>の使用方法</a>について学んでください。</li>
<li><a href=/ja/docs/concepts/configuration/overview/>設定のベストプラクティスとTIPS</a>を参照してください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d649067a69d8d5c7e71564b42b96909e>3.11.4 - クラスターのネットワーク</h1>
<p>ネットワークはKubernetesにおける中心的な部分ですが、どのように動作するかを正確に理解することは難解な場合もあります。
Kubernetesには、4つの異なる対応すべきネットワークの問題があります:</p>
<ol>
<li>高度に結合されたコンテナ間の通信: これは、<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>および<code>localhost</code>通信によって解決されます。</li>
<li>Pod間の通信: 本ドキュメントの主な焦点です。</li>
<li>Podからサービスへの通信：これは<a href=/ja/docs/concepts/services-networking/service/>Service</a>でカバーされています。</li>
<li>外部からサービスへの通信：これは<a href=/ja/docs/concepts/services-networking/service/>Service</a>でカバーされています。</li>
</ol>
<p>Kubernetesは、言ってしまえばアプリケーション間でマシンを共有するためのものです。通常、マシンを共有するには、2つのアプリケーションが同じポートを使用しないようにする必要があります。
複数の開発者間でポートを調整することは、大規模に行うことは非常に難しく、ユーザーが制御できないクラスターレベルの問題に見合うことがあります。</p>
<p>動的ポート割り当てはシステムに多くの複雑さをもたらします。すべてのアプリケーションはパラメータとしてポートを管理する必要があり、APIサーバーにて動的なポート番号を設定値として注入する方法が必要となり、各サービスはお互いにお互いを見つける方法が必要です。Kubernetesはこれに対処するのではなく、別のアプローチを取ります。</p>
<h2 id=the-kubernetes-network-model>Kubernetesのネットワークモデル</h2>
<p>すべての<code>Pod</code>は独自のIPアドレスを持ちます。これは、<code>Pod</code>間のリンクを明示的に作成する必要がなく、コンテナポートをホストポートにマッピングする必要がほとんどないことを意味します。こうすることで、ポート割り当て、名前解決、サービスディスカバリー、負荷分散、アプリケーション設定、および移行の観点から、<code>Pod</code>をVMまたは物理ホストと同様に扱うことができる、クリーンで後方互換性のあるモデルを生み出しています。</p>
<p>Kubernetesは、ネットワークの実装に次の基本的な要件を課しています(意図的なネットワークセグメンテーションポリシーを除きます):</p>
<ul>
<li>ノード上のPodが、NATなしですべてのノード上のすべてのPodと通信できること</li>
<li>systemdやkubeletなどノード上にあるエージェントが、そのノード上のすべてのPodと通信できること</li>
</ul>
<p>注: ホストネットワークで実行される<code>Pod</code>をサポートするプラットフォームの場合(Linuxなど):</p>
<ul>
<li>ノードのホストネットワーク内のPodは、NATなしですべてのノード上のすべてのPodと通信できます</li>
</ul>
<p>このモデルは全体としてそれほど複雑ではないことに加え、KubernetesがVMからコンテナへのアプリへの移植を簡単にするという要望と基本的に互換性があります。ジョブがVMで実行されていた頃も、VMにはIPがあってプロジェクト内の他のVMと通信できました。これは同じ基本モデルです。</p>
<p>KubernetesのIPアドレスは<code>Pod</code>スコープに存在します。<code>Pod</code>内のコンテナは、IPアドレスとMACアドレスを含むネットワーク名前空間を共有します。これは、<code>Pod</code>内のコンテナがすべて<code>localhost</code>上の互いのポートに到達できることを意味します。また、<code>Pod</code>内のコンテナがポートの使用を調整する必要があることも意味しますが、これもVM内のプロセスと同じです。これのことを「IP-per-pod(Pod毎のIP)」モデルと呼びます。</p>
<p>この実装方法は実際に使われているコンテナランタイムの詳細部分です。</p>
<p><code>Pod</code>に転送する<code>ノード</code>自体のポート(ホストポートと呼ばれる)を要求することは可能ですが、これは非常にニッチな操作です。このポート転送の実装方法も、コンテナランタイムの詳細部分です。<code>Pod</code>自体は、ホストポートの有無を認識しません。</p>
<h2 id=how-to-implement-the-kubernetes-networking-model>Kubernetesネットワークモデルの実装方法</h2>
<p>このネットワークモデルを実装する方法はいくつかあります。このドキュメントは、こうした方法を網羅的にはカバーしませんが、いくつかの技術の紹介として、また出発点として役立つことを願っています。</p>
<p>この一覧はアルファベット順にソートされており、順序は優先ステータスを意味するものではありません。</p>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>備考:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<h3 id=aci>ACI</h3>
<p><a href=https://www.cisco.com/c/en/us/solutions/data-center-virtualization/application-centric-infrastructure/index.html>Cisco Application Centric Infrastructure</a> offers an integrated overlay and underlay SDN solution that supports containers, virtual machines, and bare metal servers.
<a href=https://www.github.com/noironetworks/aci-containers>ACI</a> provides container networking integration for ACI.
An overview of the integration is provided <a href=https://www.cisco.com/c/dam/en/us/solutions/collateral/data-center-virtualization/application-centric-infrastructure/solution-overview-c22-739493.pdf>here</a>.</p>
<h3 id=antrea>Antrea</h3>
<p>Project <a href=https://github.com/vmware-tanzu/antrea>Antrea</a> is an opensource Kubernetes networking solution intended to be Kubernetes native.
It leverages Open vSwitch as the networking data plane.
Open vSwitch is a high-performance programmable virtual switch that supports both Linux and Windows.
Open vSwitch enables Antrea to implement Kubernetes Network Policies in a high-performance and efficient manner.
Thanks to the "programmable" characteristic of Open vSwitch, Antrea is able to implement an extensive set of networking and security features and services on top of Open vSwitch.</p>
<h3 id=aos-from-apstra>AOS from Apstra</h3>
<p><a href=https://www.apstra.com/products/aos/>AOS</a> is an Intent-Based Networking system that creates and manages complex datacenter environments from a simple integrated platform. AOS leverages a highly scalable distributed design to eliminate network outages while minimizing costs.</p>
<p>The AOS Reference Design currently supports Layer-3 connected hosts that eliminate legacy Layer-2 switching problems. These Layer-3 hosts can be Linux servers (Debian, Ubuntu, CentOS) that create BGP neighbor relationships directly with the top of rack switches (TORs). AOS automates the routing adjacencies and then provides fine grained control over the route health injections (RHI) that are common in a Kubernetes deployment.</p>
<p>AOS has a rich set of REST API endpoints that enable Kubernetes to quickly change the network policy based on application requirements. Further enhancements will integrate the AOS Graph model used for the network design with the workload provisioning, enabling an end to end management system for both private and public clouds.</p>
<p>AOS supports the use of common vendor equipment from manufacturers including Cisco, Arista, Dell, Mellanox, HPE, and a large number of white-box systems and open network operating systems like Microsoft SONiC, Dell OPX, and Cumulus Linux.</p>
<p>Details on how the AOS system works can be accessed here: <a href=https://www.apstra.com/products/how-it-works/>https://www.apstra.com/products/how-it-works/</a></p>
<h3 id=aws-vpc-cni-for-kubernetes>AWS VPC CNI for Kubernetes</h3>
<p><a href=https://github.com/aws/amazon-vpc-cni-k8s>AWS VPC CNI</a>は、Kubernetesクラスター向けの統合されたAWS Virtual Private Cloud(VPC)ネットワーキングを提供します。このCNIプラグインは、高いスループットと可用性、低遅延、および最小のネットワークジッタを提供します。さらに、ユーザーは、Kubernetesクラスターを構築するための既存のAWS VPCネットワーキングとセキュリティのベストプラクティスを適用できます。これには、ネットワークトラフィックの分離にVPCフローログ、VPCルーティングポリシー、およびセキュリティグループを使用する機能が含まれます。</p>
<p>このCNIプラグインを使用すると、Kubernetes PodはVPCネットワーク上と同じIPアドレスをPod内に持つことができます。CNIはAWS Elastic Networking Interface(ENI)を各Kubernetesノードに割り当て、ノード上のPodに各ENIのセカンダリIP範囲を使用します。このCNIには、Podの起動時間を短縮するためのENIとIPアドレスの事前割り当ての制御が含まれており、最大2,000ノードの大規模クラスターが可能です。</p>
<p>さらに、このCNIは<a href=https://docs.aws.amazon.com/ja_jp/eks/latest/userguide/calico.html>ネットワークポリシーの適用のためにCalico</a>と一緒に実行できます。AWS VPC CNIプロジェクトは、<a href=https://github.com/aws/amazon-vpc-cni-k8s>GitHubのドキュメント</a>とともにオープンソースで公開されています。</p>
<h3 id=azure-cni-for-kubernetes>Azure CNI for Kubernetes</h3>
<p><a href=https://docs.microsoft.com/en-us/azure/virtual-network/container-networking-overview>Azure CNI</a> is an <a href=https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md>open source</a> plugin that integrates Kubernetes Pods with an Azure Virtual Network (also known as VNet) providing network performance at par with VMs. Pods can connect to peered VNet and to on-premises over Express Route or site-to-site VPN and are also directly reachable from these networks. Pods can access Azure services, such as storage and SQL, that are protected by Service Endpoints or Private Link. You can use VNet security policies and routing to filter Pod traffic. The plugin assigns VNet IPs to Pods by utilizing a pool of secondary IPs pre-configured on the Network Interface of a Kubernetes node.</p>
<p>Azure CNI is available natively in the [Azure Kubernetes Service (AKS)] (<a href=https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni)>https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni)</a>.</p>
<h3 id=big-cloud-fabric-from-big-switch-networks>Big Cloud Fabric from Big Switch Networks</h3>
<p><a href=https://www.bigswitch.com/container-network-automation>Big Cloud Fabric</a> is a cloud native networking architecture, designed to run Kubernetes in private cloud/on-premises environments. Using unified physical & virtual SDN, Big Cloud Fabric tackles inherent container networking problems such as load balancing, visibility, troubleshooting, security policies & container traffic monitoring.</p>
<p>With the help of the Big Cloud Fabric's virtual pod multi-tenant architecture, container orchestration systems such as Kubernetes, RedHat OpenShift, Mesosphere DC/OS & Docker Swarm will be natively integrated alongside with VM orchestration systems such as VMware, OpenStack & Nutanix. Customers will be able to securely inter-connect any number of these clusters and enable inter-tenant communication between them if needed.</p>
<p>BCF was recognized by Gartner as a visionary in the latest <a href=https://go.bigswitch.com/17GatedDocuments-MagicQuadrantforDataCenterNetworking_Reg.html>Magic Quadrant</a>. One of the BCF Kubernetes on-premises deployments (which includes Kubernetes, DC/OS & VMware running on multiple DCs across different geographic regions) is also referenced <a href=https://portworx.com/architects-corner-kubernetes-satya-komala-nio/>here</a>.</p>
<h3 id=calico>Calico</h3>
<p><a href=https://docs.projectcalico.org/>Calico</a>は、コンテナ、仮想マシン、ホストベースのワークロードのためのオープンソースのネットワーク及びネットワークセキュリティのソリューションです。Calicoは、純粋なLinuxのeBPFデータプレーンや、Linuxの標準的なネットワークデータプレーン、WindowsのHNSデータプレーンを含む、複数のデータプレーンをサポートしています。Calicoは完全なネットワークスタックを提供していますが、<a href=https://docs.projectcalico.org/networking/determine-best-networking#calico-compatible-cni-plugins-and-cloud-provider-integrations>クラウドプロバイダーのCNI</a>と組み合わせてネットワークポリシーを提供することもできます。</p>
<h3 id=cilium>Cilium</h3>
<p><a href=https://github.com/cilium/cilium>Cilium</a> is open source software for
providing and transparently securing network connectivity between application
containers. Cilium is L7/HTTP aware and can enforce network policies on L3-L7
using an identity based security model that is decoupled from network
addressing, and it can be used in combination with other CNI plugins.</p>
<h3 id=cni-genie-from-huawei>CNI-Genie from Huawei</h3>
<p><a href=https://github.com/Huawei-PaaS/CNI-Genie>CNI-Genie</a> is a CNI plugin that enables Kubernetes to <a href=https://github.com/Huawei-PaaS/CNI-Genie/blob/master/docs/multiple-cni-plugins/README.md#what-cni-genie-feature-1-multiple-cni-plugins-enables>simultaneously have access to different implementations</a> of the <a href=/ja/docs/concepts/cluster-administration/networking/#the-kubernetes-network-model>Kubernetes network model</a> in runtime. This includes any implementation that runs as a <a href=https://github.com/containernetworking/cni#3rd-party-plugins>CNI plugin</a>, such as <a href=https://github.com/coreos/flannel#flannel>Flannel</a>, <a href=http://docs.projectcalico.org/>Calico</a>, <a href=http://romana.io>Romana</a>, <a href=https://www.weave.works/products/weave-net/>Weave-net</a>.</p>
<p>CNI-Genie also supports <a href=https://github.com/Huawei-PaaS/CNI-Genie/blob/master/docs/multiple-ips/README.md#feature-2-extension-cni-genie-multiple-ip-addresses-per-pod>assigning multiple IP addresses to a pod</a>, each from a different CNI plugin.</p>
<h3 id=cni-ipvlan-vpc-k8s>cni-ipvlan-vpc-k8s</h3>
<p><a href=https://github.com/lyft/cni-ipvlan-vpc-k8s>cni-ipvlan-vpc-k8s</a> contains a set
of CNI and IPAM plugins to provide a simple, host-local, low latency, high
throughput, and compliant networking stack for Kubernetes within Amazon Virtual
Private Cloud (VPC) environments by making use of Amazon Elastic Network
Interfaces (ENI) and binding AWS-managed IPs into Pods using the Linux kernel's
IPvlan driver in L2 mode.</p>
<p>The plugins are designed to be straightforward to configure and deploy within a
VPC. Kubelets boot and then self-configure and scale their IP usage as needed
without requiring the often recommended complexities of administering overlay
networks, BGP, disabling source/destination checks, or adjusting VPC route
tables to provide per-instance subnets to each host (which is limited to 50-100
entries per VPC). In short, cni-ipvlan-vpc-k8s significantly reduces the
network complexity required to deploy Kubernetes at scale within AWS.</p>
<h3 id=coil>Coil</h3>
<p><a href=https://github.com/cybozu-go/coil>Coil</a>は、容易に連携できるよう設計されていて、フレキシブルなEgressネットワークを提供することができるCNIプラグインです。
Coilはベアメタルと比較して低いオーバーヘッドで操作することができ、また外部のネットワークへの任意のEgress NATゲートウェイを定義することができます。</p>
<h3 id=contiv>Contiv</h3>
<p><a href=https://github.com/contiv/netplugin>Contiv</a> provides configurable networking (native l3 using BGP, overlay using vxlan, classic l2, or Cisco-SDN/ACI) for various use cases.</p>
<h3 id=contrail-tungsten-fabric>Contrail / Tungsten Fabric</h3>
<p><a href=https://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/>Contrail</a>, based on <a href=https://tungsten.io>Tungsten Fabric</a>, is a truly open, multi-cloud network virtualization and policy management platform. Contrail and Tungsten Fabric are integrated with various orchestration systems such as Kubernetes, OpenShift, OpenStack and Mesos, and provide different isolation modes for virtual machines, containers/pods and bare metal workloads.</p>
<h3 id=danm>DANM</h3>
<p><a href=https://github.com/nokia/danm>DANM</a> is a networking solution for telco workloads running in a Kubernetes cluster. It's built up from the following components:</p>
<ul>
<li>A CNI plugin capable of provisioning IPVLAN interfaces with advanced features</li>
<li>An in-built IPAM module with the capability of managing multiple, cluster-wide, discontinuous L3 networks and provide a dynamic, static, or no IP allocation scheme on-demand</li>
<li>A CNI metaplugin capable of attaching multiple network interfaces to a container, either through its own CNI, or through delegating the job to any of the popular CNI solution like SRI-OV, or Flannel in parallel</li>
<li>A Kubernetes controller capable of centrally managing both VxLAN and VLAN interfaces of all Kubernetes hosts</li>
<li>Another Kubernetes controller extending Kubernetes' Service-based service discovery concept to work over all network interfaces of a Pod</li>
</ul>
<p>With this toolset DANM is able to provide multiple separated network interfaces, the possibility to use different networking back ends and advanced IPAM features for the pods.</p>
<h3 id=flannel>Flannel</h3>
<p><a href=https://github.com/coreos/flannel#flannel>Flannel</a> is a very simple overlay
network that satisfies the Kubernetes requirements. Many
people have reported success with Flannel and Kubernetes.</p>
<h3 id=google-compute-engine-gce>Google Compute Engine (GCE)</h3>
<p>For the Google Compute Engine cluster configuration scripts, <a href=https://cloud.google.com/vpc/docs/routes>advanced
routing</a> is used to
assign each VM a subnet (default is <code>/24</code> - 254 IPs). Any traffic bound for that
subnet will be routed directly to the VM by the GCE network fabric. This is in
addition to the "main" IP address assigned to the VM, which is NAT'ed for
outbound internet access. A linux bridge (called <code>cbr0</code>) is configured to exist
on that subnet, and is passed to docker's <code>--bridge</code> flag.</p>
<p>Docker is started with:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>DOCKER_OPTS</span><span style=color:#666>=</span><span style=color:#b44>&#34;--bridge=cbr0 --iptables=false --ip-masq=false&#34;</span>
</code></pre></div><p>This bridge is created by Kubelet (controlled by the <code>--network-plugin=kubenet</code>
flag) according to the <code>Node</code>'s <code>.spec.podCIDR</code>.</p>
<p>Docker will now allocate IPs from the <code>cbr-cidr</code> block. Containers can reach
each other and <code>Nodes</code> over the <code>cbr0</code> bridge. Those IPs are all routable
within the GCE project network.</p>
<p>GCE itself does not know anything about these IPs, though, so it will not NAT
them for outbound internet traffic. To achieve that an iptables rule is used
to masquerade (aka SNAT - to make it seem as if packets came from the <code>Node</code>
itself) traffic that is bound for IPs outside the GCE project network
(10.0.0.0/8).</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>iptables -t nat -A POSTROUTING ! -d 10.0.0.0/8 -o eth0 -j MASQUERADE
</code></pre></div><p>Lastly IP forwarding is enabled in the kernel (so the kernel will process
packets for bridged containers):</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sysctl net.ipv4.ip_forward<span style=color:#666>=</span><span style=color:#666>1</span>
</code></pre></div><p>The result of all this is that all <code>Pods</code> can reach each other and can egress
traffic to the internet.</p>
<h3 id=jaguar>Jaguar</h3>
<p><a href=https://gitlab.com/sdnlab/jaguar>Jaguar</a> is an open source solution for Kubernetes's network based on OpenDaylight. Jaguar provides overlay network using vxlan and Jaguar CNIPlugin provides one IP address per pod.</p>
<h3 id=k-vswitch>k-vswitch</h3>
<p><a href=https://github.com/k-vswitch/k-vswitch>k-vswitch</a> is a simple Kubernetes networking plugin based on <a href=https://www.openvswitch.org/>Open vSwitch</a>. It leverages existing functionality in Open vSwitch to provide a robust networking plugin that is easy-to-operate, performant and secure.</p>
<h3 id=knitter>Knitter</h3>
<p><a href=https://github.com/ZTE/Knitter/>Knitter</a> is a network solution which supports multiple networking in Kubernetes. It provides the ability of tenant management and network management. Knitter includes a set of end-to-end NFV container networking solutions besides multiple network planes, such as keeping IP address for applications, IP address migration, etc.</p>
<h3 id=kube-ovn>Kube-OVN</h3>
<p><a href=https://github.com/alauda/kube-ovn>Kube-OVN</a> is an OVN-based kubernetes network fabric for enterprises. With the help of OVN/OVS, it provides some advanced overlay network features like subnet, QoS, static IP allocation, traffic mirroring, gateway, openflow-based network policy and service proxy.</p>
<h3 id=kube-router>Kube-router</h3>
<p><a href=https://github.com/cloudnativelabs/kube-router>Kube-router</a> is a purpose-built networking solution for Kubernetes that aims to provide high performance and operational simplicity. Kube-router provides a Linux <a href=https://www.linuxvirtualserver.org/software/ipvs.html>LVS/IPVS</a>-based service proxy, a Linux kernel forwarding-based pod-to-pod networking solution with no overlays, and iptables/ipset-based network policy enforcer.</p>
<h3 id=l2-networks-and-linux-bridging>L2 networks and linux bridging</h3>
<p>If you have a "dumb" L2 network, such as a simple switch in a "bare-metal"
environment, you should be able to do something similar to the above GCE setup.
Note that these instructions have only been tried very casually - it seems to
work, but has not been thoroughly tested. If you use this technique and
perfect the process, please let us know.</p>
<p>Follow the "With Linux Bridge devices" section of
<a href=http://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/>this very nice tutorial</a> from
Lars Kellogg-Stedman.</p>
<h3 id=multus-a-multi-network-plugin>Multus (a Multi Network plugin)</h3>
<p><a href=https://github.com/Intel-Corp/multus-cni>Multus</a> is a Multi CNI plugin to support the Multi Networking feature in Kubernetes using CRD based network objects in Kubernetes.</p>
<p>Multus supports all <a href=https://github.com/containernetworking/plugins>reference plugins</a> (eg. <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel>Flannel</a>, <a href=https://github.com/containernetworking/plugins/tree/master/plugins/ipam/dhcp>DHCP</a>, <a href=https://github.com/containernetworking/plugins/tree/master/plugins/main/macvlan>Macvlan</a>) that implement the CNI specification and 3rd party plugins (eg. <a href=https://github.com/projectcalico/cni-plugin>Calico</a>, <a href=https://github.com/weaveworks/weave>Weave</a>, <a href=https://github.com/cilium/cilium>Cilium</a>, <a href=https://github.com/contiv/netplugin>Contiv</a>). In addition to it, Multus supports <a href=https://github.com/hustcat/sriov-cni>SRIOV</a>, <a href=https://github.com/Intel-Corp/sriov-cni>DPDK</a>, <a href=https://github.com/intel/vhost-user-net-plugin>OVS-DPDK & VPP</a> workloads in Kubernetes with both cloud native and NFV based applications in Kubernetes.</p>
<h3 id=ovn4nfv-k8s-plugin-ovn-based-cni-controller-plugin>OVN4NFV-K8s-Plugin (OVN based CNI controller & plugin)</h3>
<p><a href=https://github.com/opnfv/ovn4nfv-k8s-plugin>OVN4NFV-K8S-Plugin</a> is OVN based CNI controller plugin to provide cloud native based Service function chaining(SFC), Multiple OVN overlay networking, dynamic subnet creation, dynamic creation of virtual networks, VLAN Provider network, Direct provider network and pluggable with other Multi-network plugins, ideal for edge based cloud native workloads in Multi-cluster networking</p>
<h3 id=nsx-t>NSX-T</h3>
<p><a href=https://docs.vmware.com/en/VMware-NSX-T/index.html>VMware NSX-T</a> is a network virtualization and security platform. NSX-T can provide network virtualization for a multi-cloud and multi-hypervisor environment and is focused on emerging application frameworks and architectures that have heterogeneous endpoints and technology stacks. In addition to vSphere hypervisors, these environments include other hypervisors such as KVM, containers, and bare metal.</p>
<p><a href=https://docs.vmware.com/en/VMware-NSX-T/2.0/nsxt_20_ncp_kubernetes.pdf>NSX-T Container Plug-in (NCP)</a> provides integration between NSX-T and container orchestrators such as Kubernetes, as well as integration between NSX-T and container-based CaaS/PaaS platforms such as Pivotal Container Service (PKS) and OpenShift.</p>
<h3 id=nuage-networks-vcs-virtualized-cloud-services>Nuage Networks VCS (Virtualized Cloud Services)</h3>
<p><a href=https://www.nuagenetworks.net>Nuage</a> provides a highly scalable policy-based Software-Defined Networking (SDN) platform. Nuage uses the open source Open vSwitch for the data plane along with a feature rich SDN Controller built on open standards.</p>
<p>The Nuage platform uses overlays to provide seamless policy-based networking between Kubernetes Pods and non-Kubernetes environments (VMs and bare metal servers). Nuage's policy abstraction model is designed with applications in mind and makes it easy to declare fine-grained policies for applications.The platform's real-time analytics engine enables visibility and security monitoring for Kubernetes applications.</p>
<h3 id=openvswitch>OpenVSwitch</h3>
<p><a href=https://www.openvswitch.org/>OpenVSwitch</a> is a somewhat more mature but also
complicated way to build an overlay network. This is endorsed by several of the
"Big Shops" for networking.</p>
<h3 id=ovn-open-virtual-networking>OVN (Open Virtual Networking)</h3>
<p>OVN is an opensource network virtualization solution developed by the
Open vSwitch community. It lets one create logical switches, logical routers,
stateful ACLs, load-balancers etc to build different virtual networking
topologies. The project has a specific Kubernetes plugin and documentation
at <a href=https://github.com/openvswitch/ovn-kubernetes>ovn-kubernetes</a>.</p>
<h3 id=romana>Romana</h3>
<p><a href=https://romana.io>Romana</a> is an open source network and security automation solution that lets you deploy Kubernetes without an overlay network. Romana supports Kubernetes <a href=/docs/concepts/services-networking/network-policies/>Network Policy</a> to provide isolation across network namespaces.</p>
<h3 id=weave-net-from-weaveworks>Weave Net from Weaveworks</h3>
<p><a href=https://www.weave.works/products/weave-net/>Weave Net</a> is a
resilient and simple to use network for Kubernetes and its hosted applications.
Weave Net runs as a <a href=https://www.weave.works/docs/net/latest/cni-plugin/>CNI plug-in</a>
or stand-alone. In either version, it doesn't require any configuration or extra code
to run, and in both cases, the network provides one IP address per pod - as is standard for Kubernetes.</p>
<h2 id=次の項目>次の項目</h2>
<p>ネットワークモデルの初期設計とその根拠、および将来の計画については、<a href=https://git.k8s.io/community/contributors/design-proposals/network/networking.md>ネットワーク設計ドキュメント</a>で詳細に説明されています。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5cc31ecfba86467f8884856412cfb6b2>3.11.5 - システムログ</h1>
<p>システムコンポーネントのログは、クラスター内で起こったイベントを記録します。このログはデバッグのために非常に役立ちます。ログのverbosityを設定すると、ログをどの程度詳細に見るのかを変更できます。ログはコンポーネント内のエラーを表示する程度の荒い粒度にすることも、イベントのステップバイステップのトレース(HTTPのアクセスログ、Podの状態の変更、コントローラーの動作、スケジューラーの決定など)を表示するような細かい粒度に設定することもできます。</p>
<h2 id=klog>klog</h2>
<p>klogは、Kubernetesのログライブラリです。<a href=https://github.com/kubernetes/klog>klog</a>は、Kubernetesのシステムコンポーネント向けのログメッセージを生成します。</p>
<p>klogの設定に関する詳しい情報については、<a href=/docs/reference/command-line-tools-reference/>コマンドラインツールのリファレンス</a>を参照してください。</p>
<p>klogネイティブ形式の例:</p>
<pre><code>I1025 00:15:15.525108       1 httplog.go:79] GET /api/v1/namespaces/kube-system/pods/metrics-server-v0.3.1-57c75779f-9p8wg: (1.512ms) 200 [pod_nanny/v0.0.0 (linux/amd64) kubernetes/$Format 10.56.1.19:51756]
</code></pre><h3 id=構造化ログ>構造化ログ</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [alpha]</code>
</div>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> <p>構造化ログへのマイグレーションは現在進行中の作業です。このバージョンでは、すべてのログメッセージが構造化されているわけではありません。ログファイルをパースする場合、JSONではないログの行にも対処しなければなりません。</p>
<p>ログの形式と値のシリアライズは変更される可能性があります。</p>
</div>
<p>構造化ログは、ログメッセージに単一の構造を導入し、プログラムで情報の抽出ができるようにするものです。構造化ログは、僅かな労力とコストで保存・処理できます。新しいメッセージ形式は後方互換性があり、デフォルトで有効化されます。</p>
<p>構造化ログの形式:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=color:#b44>&lt;klog header&gt; &#34;&lt;message&gt;&#34; &lt;key1&gt;</span><span style=color:#666>=</span><span style=color:#b44>&#34;&lt;value1&gt;&#34; &lt;key2&gt;=&#34;&lt;value2&gt;&#34; ...</span>
</code></pre></div><p>例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=color:#b44>I1025 00:15:15.525108       1 controller_utils.go:116] &#34;Pod status updated&#34; pod</span><span style=color:#666>=</span><span style=color:#b44>&#34;kube-system/kubedns&#34; status=&#34;ready&#34;</span>
</code></pre></div><h3 id=jsonログ形式>JSONログ形式</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [alpha]</code>
</div>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> <p>JSONの出力は多数の標準のklogフラグをサポートしていません。非対応のklogフラグの一覧については、<a href=/docs/reference/command-line-tools-reference/>コマンドラインツールリファレンス</a>を参照してください。</p>
<p>すべてのログがJSON形式で書き込むことに対応しているわけではありません(たとえば、プロセスの開始時など)。ログのパースを行おうとしている場合、JSONではないログの行に対処できるようにしてください。</p>
<p>フィールド名とJSONのシリアライズは変更される可能性があります。</p>
</div>
<p><code>--logging-format=json</code>フラグは、ログの形式をネイティブ形式klogからJSON形式に変更します。以下は、JSONログ形式の例(pretty printしたもの)です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
   <span style=color:green;font-weight:700>&#34;ts&#34;</span>: <span style=color:#666>1580306777.04728</span>,
   <span style=color:green;font-weight:700>&#34;v&#34;</span>: <span style=color:#666>4</span>,
   <span style=color:green;font-weight:700>&#34;msg&#34;</span>: <span style=color:#b44>&#34;Pod status updated&#34;</span>,
   <span style=color:green;font-weight:700>&#34;pod&#34;</span>:{
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx-1&#34;</span>,
      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>
   },
   <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;ready&#34;</span>
}
</code></pre></div><p>特別な意味を持つキー:</p>
<ul>
<li><code>ts</code> - Unix時間のタイムスタンプ(必須、float)</li>
<li><code>v</code> - verbosity (必須、int、デフォルトは0)</li>
<li><code>err</code> - エラー文字列 (オプション、string)</li>
<li><code>msg</code> - メッセージ (必須、string)</li>
</ul>
<p>現在サポートされているJSONフォーマットの一覧:</p>
<ul>
<li><a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a></li>
<li><a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a></li>
<li><a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a></li>
<li><a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a></li>
</ul>
<h3 id=ログのサニタイズ>ログのサニタイズ</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code>
</div>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> ログのサニタイズ大きな計算のオーバーヘッドを引き起こす可能性があるため、本番環境では有効にするべきではありません。
</div>
<p><code>--experimental-logging-sanitization</code>フラグはklogのサニタイズフィルタを有効にします。有効にすると、すべてのログの引数が機密データ(パスワード、キー、トークンなど)としてタグ付けされたフィールドについて検査され、これらのフィールドのログの記録は防止されます。</p>
<p>現在ログのサニタイズをサポートしているコンポーネント一覧:</p>
<ul>
<li>kube-controller-manager</li>
<li>kube-apiserver</li>
<li>kube-scheduler</li>
<li>kubelet</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ログのサニタイズフィルターは、ユーザーのワークロードのログが機密データを漏洩するのを防げるわけではありません。
</div>
<h3 id=ログのverbosityレベル>ログのverbosityレベル</h3>
<p><code>-v</code>フラグはログのverbosityを制御します。値を増やすとログに記録されるイベントの数が増えます。値を減らすとログに記録されるイベントの数が減ります。verbosityの設定を増やすと、ますます多くの深刻度の低いイベントをログに記録するようになります。verbosityの設定を0にすると、クリティカルなイベントだけをログに記録します。</p>
<h3 id=ログの場所>ログの場所</h3>
<p>システムコンポーネントには2種類あります。コンテナ内で実行されるコンポーネントと、コンテナ内で実行されないコンポーネントです。たとえば、次のようなコンポーネントがあります。</p>
<ul>
<li>Kubernetesのスケジューラーやkube-proxyはコンテナ内で実行されます。</li>
<li>kubeletやDockerのようなコンテナランタイムはコンテナ内で実行されません。</li>
</ul>
<p>systemdを使用しているマシンでは、kubeletとコンテナランタイムはjournaldに書き込みを行います。それ以外のマシンでは、<code>/var/log</code>ディレクトリ内の<code>.log</code>ファイルに書き込みます。コンテナ内部のシステムコンポーネントは、デフォルトのログ機構をバイパスするため、常に<code>/var/log</code>ディレクトリ内の<code>.log</code>ファイルに書き込みます。コンテナのログと同様に、<code>/var/log</code>ディレクトリ内のシステムコンポーネントのログはローテートする必要があります。<code>kube-up.sh</code>スクリプトによって作成されたKubernetesクラスターでは、ログローテーションは<code>logrotate</code>ツールで設定されます。<code>logrotate</code>ツールはログを1日ごとまたはログのサイズが100MBを超えたときにローテートします。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/concepts/cluster-administration/logging/>Kubernetesのログのアーキテクチャ</a>について読む。</li>
<li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/1602-structured-logging>構造化ログ</a>について読む。</li>
<li><a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>ログの深刻度の慣習</a>について読む。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2e05a56491965ae320c2662590b2ca18>3.11.6 - コンテナイメージのガベージコレクション</h1>
<p>ガベージコレクションは、未使用の<a href=/ja/docs/concepts/containers/#container-images>イメージ</a>と未使用の<a href=/ja/docs/concepts/containers/>コンテナ</a>をクリーンアップするkubeletの便利な機能です。kubeletコンテナのガベージコレクションを1分ごとに行い、イメージのガベージコレクションは5分ごとに行います。</p>
<p>存在することが期待されているコンテナを削除してkubeletの動作を壊す可能性があるため、外部のガベージコレクションのツールは推奨されません。</p>
<h2 id=イメージのガベージコレクション>イメージのガベージコレクション</h2>
<p>Kubernetesでは、すべてのイメージのライフサイクルの管理はcadvisorと協調してimageManager経由で行います。</p>
<p>イメージのガベージコレクションのポリシーについて考えるときは、<code>HighThresholdPercent</code>および<code>LowThresholdPercent</code>という2つの要因について考慮する必要があります。ディスク使用量がhigh thresholdを超えると、ガベージコレクションがトリガされます。ガベージコレクションは、low
thresholdが満たされるまで、最後に使われてから最も時間が経った(least recently used)イメージを削除します。</p>
<h2 id=コンテナのガベージコレクション>コンテナのガベージコレクション</h2>
<p>コンテナのガベージコレクションのポリシーは、3つのユーザー定義の変数を考慮に入れます。<code>MinAge</code>は、ガベージコレクションできるコンテナの最小の年齢です。<code>MaxPerPodContainer</code>は、すべての単一のPod(UID、コンテナ名)が保持することを許されているdead状態のコンテナの最大値です。<code>MaxContainers</code>はdead状態のコンテナの合計の最大値です。これらの変数は、<code>MinAge</code>は0に、<code>MaxPerPodContainer</code>と<code>MaxContainers</code>は0未満にそれぞれ設定することで個別に無効にできます。</p>
<p>kubeletは、未指定のコンテナ、削除されたコンテナ、前述のフラグにより設定された境界の外にあるコンテナに対して動作します。一般に、最も古いコンテナが最初に削除されます。<code>MaxPerPodContainer</code>と<code>MaxContainer</code>は、Podごとの保持するコンテナの最大値(<code>MaxPerPodContainer</code>)がグローバルのdead状態のコンテナの許容範囲(<code>MaxContainers</code>)外である場合には、互いに競合する可能性があります。このような状況では、<code>MaxPerPodContainer</code>が調整されます。最悪のケースのシナリオでは、<code>MaxPerPodContainer</code>が1にダウングレードされ、最も古いコンテナが強制退去されます。さらに、<code>MinAge</code>より古くなると、削除済みのPodが所有するコンテナが削除されます。</p>
<p>kubeletによって管理されないコンテナは、コンテナのガベージコレクションの対象にはなりません。</p>
<h2 id=ユーザー設定>ユーザー設定</h2>
<p>イメージのガベージコレクションを調整するために、以下のkubeletのフラグを使用して次のようなしきい値を調整できます。</p>
<ol>
<li><code>image-gc-high-threshold</code>: イメージのガベージコレクションをトリガするディスク使用量の割合(%)。デフォルトは85%。</li>
<li><code>image-gc-low-threshold</code>: イメージのガベージコレクションが解放を試みるディスク使用量の割合(%)。デフォルトは80%。</li>
</ol>
<p>ガベージコレクションのポリシーは、以下のkubeletのフラグを使用してカスタマイズできます。</p>
<ol>
<li><code>minimum-container-ttl-duration</code>: 完了したコンテナがガベージコレクションされる前に経過するべき最小期間。デフォルトは0分です。つまり、すべての完了したコンテナはガベージコレクションされます。</li>
<li><code>maximum-dead-containers-per-container</code>: コンテナごとに保持される古いインスタンスの最大値です。デフォルトは1です。</li>
<li><code>maximum-dead-containers</code>: グローバルに保持するべき古いコンテナのインスタンスの最大値です。デフォルトは-1です。つまり、グローバルなリミットは存在しません。</li>
</ol>
<p>コンテナは役に立たなくなる前にガベージコレクションされる可能性があります。こうしたコンテナには、トラブルシューティングに役立つログや他のデータが含まれるかもしれません。そのため、期待されるコンテナごとに最低でも1つのdead状態のコンテナが許容されるようにするために、<code>maximum-dead-containers-per-container</code>には十分大きな値を設定することが強く推奨されます。同様の理由で、<code>maximum-dead-containers</code>にも、より大きな値を設定することが推奨されます。詳しくは、<a href=https://github.com/kubernetes/kubernetes/issues/13287>こちらのissue</a>を読んでください。</p>
<h2 id=廃止>廃止</h2>
<p>このドキュメントにあるkubeletの一部のガベージコレクションの機能は、将来kubelet evictionで置換される予定です。</p>
<p>これには以下のものが含まれます。</p>
<table>
<thead>
<tr>
<th>既存のフラグ</th>
<th>新しいフラグ</th>
<th>理由</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--image-gc-high-threshold</code></td>
<td><code>--eviction-hard</code>または<code>--eviction-soft</code></td>
<td>既存のevictionのシグナルがイメージのガベージコレクションをトリガする可能性がある</td>
</tr>
<tr>
<td><code>--image-gc-low-threshold</code></td>
<td><code>--eviction-minimum-reclaim</code></td>
<td>eviction reclaimが同等の動作を実現する</td>
</tr>
<tr>
<td><code>--maximum-dead-containers</code></td>
<td></td>
<td>古いログがコンテナのコンテキストの外部に保存されるようになったら廃止</td>
</tr>
<tr>
<td><code>--maximum-dead-containers-per-container</code></td>
<td></td>
<td>古いログがコンテナのコンテキストの外部に保存されるようになったら廃止</td>
</tr>
<tr>
<td><code>--minimum-container-ttl-duration</code></td>
<td></td>
<td>古いログがコンテナのコンテキストの外部に保存されるようになったら廃止</td>
</tr>
<tr>
<td><code>--low-diskspace-threshold-mb</code></td>
<td><code>--eviction-hard</code> or <code>eviction-soft</code></td>
<td>evictionはディスクのしきい値を他のリソースに一般化している</td>
</tr>
<tr>
<td><code>--outofdisk-transition-frequency</code></td>
<td><code>--eviction-pressure-transition-period</code></td>
<td>evictionはディスクのpressure transitionを他のリソースに一般化している</td>
</tr>
</tbody>
</table>
<h2 id=次の項目>次の項目</h2>
<p>詳細については、<a href=/docs/tasks/administer-cluster/out-of-resource/>リソース不足のハンドリング方法を設定する</a>を参照してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-08e94e6a480e0d6b2de72d84a1b97617>3.11.7 - Kubernetesのプロキシー</h1>
<p>このページではKubernetesと併用されるプロキシーについて説明します。</p>
<h2 id=プロキシー>プロキシー</h2>
<p>Kubernetesを使用する際に、いくつかのプロキシーを使用する場面があります。</p>
<ol>
<li>
<p><a href=/docs/tasks/access-application-cluster/access-cluster/#directly-accessing-the-rest-api>kubectlのプロキシー</a>:</p>
<ul>
<li>ユーザーのデスクトップ上かPod内で稼働します</li>
<li>ローカルホストのアドレスからKubernetes apiserverへのプロキシーを行います</li>
<li>クライアントからプロキシー間ではHTTPを使用します</li>
<li>プロキシーからapiserverへはHTTPSを使用します</li>
<li>apiserverの場所を示します</li>
<li>認証用のヘッダーを追加します</li>
</ul>
</li>
<li>
<p><a href=/docs/tasks/access-application-cluster/access-cluster/#discovering-builtin-services>apiserverのプロキシー</a>:</p>
<ul>
<li>apiserver内で動作する踏み台となります</li>
<li>これがなければ到達不可能であるクラスターIPへ、クラスターの外部からのユーザーを接続します</li>
<li>apiserverのプロセス内で稼働します</li>
<li>クライアントからプロキシー間ではHTTPSを使用します(apiserverの設定により、HTTPを使用します)</li>
<li>プロキシーからターゲット間では利用可能な情報を使用して、プロキシーによって選択されたHTTPかHTTPSのいずれかを使用します</li>
<li>Node、Pod、Serviceへ到達するのに使えます</li>
<li>Serviceへ到達するときは負荷分散を行います</li>
</ul>
</li>
<li>
<p><a href=/ja/docs/concepts/services-networking/service/#ips-and-vips>kube proxy</a>:</p>
<ul>
<li>各ノード上で稼働します</li>
<li>UDP、TCP、SCTPをプロキシーします</li>
<li>HTTPを解釈しません</li>
<li>負荷分散機能を提供します</li>
<li>Serviceへ到達させるためのみに使用されます</li>
</ul>
</li>
<li>
<p>apiserverの前段にあるプロキシー/ロードバランサー:</p>
<ul>
<li>実際に存在するかどうかと実装はクラスターごとに異なります(例: nginx)</li>
<li>全てのクライアントと、1つ以上のapiserverの間に位置します</li>
<li>複数のapiserverがあるときロードバランサーとして稼働します</li>
</ul>
</li>
<li>
<p>外部サービス上で稼働するクラウドロードバランサー:</p>
<ul>
<li>いくつかのクラウドプロバイダーによって提供されます(例: AWS ELB、Google Cloud Load Balancer)</li>
<li><code>LoadBalancer</code>というtypeのKubernetes Serviceが作成されたときに自動で作成されます</li>
<li>たいていのクラウドロードバランサーはUDP/TCPのみサポートしています</li>
<li>SCTPのサポートはクラウドプロバイダーのロードバランサーの実装によって異なります</li>
<li>ロードバランサーの実装はクラウドプロバイダーによって異なります</li>
</ul>
</li>
</ol>
<p>Kubernetesユーザーのほとんどは、最初の2つのタイプ以外に心配する必要はありません。クラスター管理者はそれ以外のタイプのロードバランサーを正しくセットアップすることを保証します。</p>
<h2 id=リダイレクトの要求>リダイレクトの要求</h2>
<p>プロキシーはリダイレクトの機能を置き換えました。リダイレクトの使用は非推奨となります。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-85d633ae590aa20ec024f1b7af1d74fc>3.11.8 - アドオンのインストール</h1>
<div class="alert alert-secondary callout third-party-content" role=alert><strong>備考:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div>
<p>アドオンはKubernetesの機能を拡張するものです。</p>
<p>このページでは、利用可能なアドオンの一部の一覧と、それぞれのアドオンのインストール方法へのリンクを提供します。</p>
<h2 id=ネットワークとネットワークポリシー>ネットワークとネットワークポリシー</h2>
<ul>
<li><a href=https://www.github.com/noironetworks/aci-containers>ACI</a>は、統合されたコンテナネットワークとネットワークセキュリティをCisco ACIを使用して提供します。</li>
<li><a href=https://antrea.io/>Antrea</a>は、L3またはL4で動作して、Open vSwitchをネットワークデータプレーンとして活用する、Kubernetes向けのネットワークとセキュリティサービスを提供します。</li>
<li><a href=https://docs.projectcalico.org/latest/introduction/>Calico</a>はネットワークとネットワークプリシーのプロバイダーです。Calicoは、BGPを使用または未使用の非オーバーレイおよびオーバーレイネットワークを含む、フレキシブルなさまざまなネットワークオプションをサポートします。Calicoはホスト、Pod、そして(IstioとEnvoyを使用している場合には)サービスメッシュ上のアプリケーションに対してネットワークポリシーを強制するために、同一のエンジンを使用します。</li>
<li><a href=https://github.com/tigera/canal/tree/master/k8s-install>Canal</a>はFlannelとCalicoをあわせたもので、ネットワークとネットワークポリシーを提供します。</li>
<li><a href=https://github.com/cilium/cilium>Cilium</a>は、L3のネットワークとネットワークポリシーのプラグインで、HTTP/API/L7のポリシーを透過的に強制できます。ルーティングとoverlay/encapsulationモードの両方をサポートしており、他のCNIプラグイン上で機能できます。</li>
<li><a href=https://github.com/Huawei-PaaS/CNI-Genie>CNI-Genie</a>は、KubernetesをCalico、Canal、Flannel、Romana、Weaveなど選択したCNIプラグインをシームレスに接続できるようにするプラグインです。</li>
<li><a href=https://contiv.github.io>Contiv</a>は、さまざまなユースケースと豊富なポリシーフレームワーク向けに設定可能なネットワーク(BGPを使用したネイティブのL3、vxlanを使用したオーバーレイ、古典的なL2、Cisco-SDN/ACI)を提供します。Contivプロジェクトは完全に<a href=https://github.com/contiv>オープンソース</a>です。<a href=https://github.com/contiv/install>インストーラ</a>はkubeadmとkubeadm以外の両方をベースとしたインストールオプションがあります。</li>
<li><a href=https://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/>Contrail</a>は、<a href=https://tungsten.io>Tungsten Fabric</a>をベースにしている、オープンソースでマルチクラウドに対応したネットワーク仮想化およびポリシー管理プラットフォームです。ContrailおよびTungsten Fabricは、Kubernetes、OpenShift、OpenStack、Mesosなどのオーケストレーションシステムと統合されており、仮想マシン、コンテナ/Pod、ベアメタルのワークロードに隔離モードを提供します。</li>
<li><a href=https://github.com/flannel-io/flannel#deploying-flannel-manually>Flannel</a>は、Kubernetesで使用できるオーバーレイネットワークプロバイダーです。</li>
<li><a href=https://github.com/ZTE/Knitter/>Knitter</a>は、1つのKubernetes Podで複数のネットワークインターフェイスをサポートするためのプラグインです。</li>
<li><a href=https://github.com/Intel-Corp/multus-cni>Multus</a>は、すべてのCNIプラグイン(たとえば、Calico、Cilium、Contiv、Flannel)に加えて、SRIOV、DPDK、OVS-DPDK、VPPをベースとするKubernetes上のワークロードをサポートする、複数のネットワークサポートのためのマルチプラグインです。</li>
<li><a href=https://github.com/ovn-org/ovn-kubernetes/>OVN-Kubernetes</a>は、Open vSwitch(OVS)プロジェクトから生まれた仮想ネットワーク実装である<a href=https://github.com/ovn-org/ovn/>OVN(Open Virtual Network)</a>をベースとする、Kubernetesのためのネットワークプロバイダです。OVN-Kubernetesは、OVSベースのロードバランサーおよびネットワークポリシーの実装を含む、Kubernetes向けのオーバーレイベースのネットワーク実装を提供します。</li>
<li><a href=https://github.com/opnfv/ovn4nfv-k8s-plugin>OVN4NFV-K8S-Plugin</a>は、クラウドネイティブベースのService function chaining(SFC)、Multiple OVNオーバーレイネットワーク、動的なサブネットの作成、動的な仮想ネットワークの作成、VLANプロバイダーネットワーク、Directプロバイダーネットワークを提供し、他のMulti-networkプラグインと付け替え可能なOVNベースのCNIコントローラープラグインです。</li>
<li><a href=https://docs.vmware.com/en/VMware-NSX-T/2.0/nsxt_20_ncp_kubernetes.pdf>NSX-T</a> Container Plug-in(NCP)は、VMware NSX-TとKubernetesなどのコンテナオーケストレーター間のインテグレーションを提供します。また、NSX-Tと、Pivotal Container Service(PKS)とOpenShiftなどのコンテナベースのCaaS/PaaSプラットフォームとのインテグレーションも提供します。</li>
<li><a href=https://github.com/nuagenetworks/nuage-kubernetes/blob/v5.1.1-1/docs/kubernetes-1-installation.rst>Nuage</a>は、Kubernetes Podと非Kubernetes環境間で可視化とセキュリティモニタリングを使用してポリシーベースのネットワークを提供するSDNプラットフォームです。</li>
<li><a href=https://romana.io>Romana</a>は、<a href=/docs/concepts/services-networking/network-policies/>NetworkPolicy API</a>もサポートするPodネットワーク向けのL3のネットワークソリューションです。Kubeadmアドオンのインストールの詳細は<a href=https://github.com/romana/romana/tree/master/containerize>こちら</a>で確認できます。</li>
<li><a href=https://www.weave.works/docs/net/latest/kubernetes/kube-addon/>Weave Net</a>は、ネットワークパーティションの両面で機能し、外部データベースを必要とせずに、ネットワークとネットワークポリシーを提供します。</li>
</ul>
<h2 id=サービスディスカバリ>サービスディスカバリ</h2>
<ul>
<li><a href=https://coredns.io>CoreDNS</a>は、フレキシブルで拡張可能なDNSサーバーです。Pod向けのクラスター内DNSとして<a href=https://github.com/coredns/deployment/tree/master/kubernetes>インストール</a>できます。</li>
</ul>
<h2 id=可視化と制御>可視化と制御</h2>
<ul>
<li><a href=https://github.com/kubernetes/dashboard#kubernetes-dashboard>Dashboard</a>はKubernetes向けのダッシュボードを提供するウェブインターフェイスです。</li>
<li><a href=https://www.weave.works/documentation/scope-latest-installing/#k8s>Weave Scope</a>は、コンテナ、Pod、Serviceなどをグラフィカルに可視化するツールです。<a href=https://cloud.weave.works/>Weave Cloud account</a>と組み合わせて使うか、UIを自分でホストして使います。</li>
</ul>
<h2 id=インフラストラクチャ>インフラストラクチャ</h2>
<ul>
<li><a href=https://kubevirt.io/user-guide/#/installation/installation>KubeVirt</a>は仮想マシンをKubernetes上で実行するためのアドオンです。通常、ベアメタルのクラスタで実行します。</li>
</ul>
<h2 id=レガシーなアドオン>レガシーなアドオン</h2>
<p>いくつかのアドオンは、廃止された<a href=https://git.k8s.io/kubernetes/cluster/addons>cluster/addons</a>ディレクトリに掲載されています。</p>
<p>よくメンテナンスされたアドオンはここにリンクしてください。PRを歓迎しています。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7e0d97616b15e2c383c6a0a96ec442cb>3.12 - Kubernetesを拡張する</h1>
<div class=lead>Kubernetesクラスターの挙動を変えるいろいろな方法</div>
<p>Kubernetesは柔軟な設定が可能で、高い拡張性を持っています。
結果として、Kubernetesのプロジェクトソースコードをフォークしたり、パッチを当てて利用することは滅多にありません。
このガイドは、Kubernetesクラスターをカスタマイズするための選択肢を記載します。
管理しているKubernetesクラスターを、動作環境の要件にどのように適合させるべきかを理解したい<a class=glossary-tooltip title=クラスターを設定、管理そして、監視する人 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-cluster-operator" target=_blank aria-label=クラスター管理者>クラスター管理者</a>を対象にしています。
将来の <a class=glossary-tooltip title=自身のプロジェクトの要件に合わせ、Kubernetesプラットフォームをカスタマイズする人 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-platform-developer" target=_blank aria-label=プラットフォーム開発者>プラットフォーム開発者</a> 、またはKubernetesプロジェクトの<a class=glossary-tooltip title=Kubernetesプロジェクトやコミュニティのために、コード、ドキュメント、またはその他の作業に自身の時間を使って貢献している人々 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-contributor" target=_blank aria-label=コントリビューター>コントリビューター</a>にとっても、どのような拡張のポイントやパターンが存在するのか、また、それぞれのトレードオフや制限事項を学ぶための導入として役立つでしょう。</p>
<h2 id=概要>概要</h2>
<p>カスタマイズのアプローチには大きく分けて、フラグ、ローカル設定ファイル、またはAPIリソースの変更のみを含んだ <em>設定</em> と、稼働しているプログラムまたはサービスも含んだ <em>拡張</em> があります。このドキュメントでは、主に拡張について説明します。</p>
<h2 id=設定>設定</h2>
<p><em>設定ファイル</em> と <em>フラグ</em> はオンラインドキュメントのリファレンスセクションの中の、各項目に記載されています:</p>
<ul>
<li><a href=/docs/admin/kubelet/>kubelet</a></li>
<li><a href=/docs/admin/kube-apiserver/>kube-apiserver</a></li>
<li><a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a></li>
<li><a href=/docs/admin/kube-scheduler/>kube-scheduler</a></li>
<li><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a></li>
<li><a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a></li>
<li><a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a></li>
<li><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a></li>
</ul>
<p>ホスティングされたKubernetesサービスやマネージドなKubernetesでは、フラグと設定ファイルが常に変更できるとは限りません。変更可能な場合でも、通常はクラスターの管理者のみが変更できます。また、それらは将来のKubernetesバージョンで変更される可能性があり、設定変更にはプロセスの再起動が必要になるかもしれません。これらの理由により、この方法は他の選択肢が無いときにのみ利用するべきです。</p>
<p><a href=/docs/concepts/policy/resource-quotas/>ResourceQuota</a>、<a href=/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>、<a href=/docs/concepts/services-networking/network-policies/>NetworkPolicy</a>、そしてロールベースアクセス制御(<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>)といった <em>ビルトインポリシーAPI</em> は、ビルトインのKubernetes APIです。APIは通常、ホスティングされたKubernetesサービスやマネージドなKubernetesで利用されます。これらは宣言的で、Podのような他のKubernetesリソースと同じ慣例に従っています。そのため、新しいクラスターの設定は繰り返し再利用することができ、アプリケーションと同じように管理することが可能です。さらに、安定版(stable)を利用している場合、他のKubernetes APIのような<a href=/docs/reference/deprecation-policy/>定義済みのサポートポリシー</a>を利用することができます。これらの理由により、この方法は、適切な用途の場合、 <em>設定ファイル</em> や <em>フラグ</em> よりも好まれます。</p>
<h2 id=拡張>拡張</h2>
<p>拡張はKubernetesを拡張し、深く統合されたソフトウェアの構成要素です。
これは新しいタイプと、新しい種類のハードウェアをサポートするために利用されます。</p>
<p>ほとんどのクラスター管理者は、ホスティングされている、またはディストリビューションとしてのKubernetesを使っているでしょう。
結果として、ほとんどのKubernetesユーザーは既存の拡張を使えばよいため、新しい拡張を書く必要は無いと言えます。</p>
<h2 id=extension-patterns>拡張パターン</h2>
<p>Kubernetesは、クライアントのプログラムを書くことで自動化ができるようにデザインされています。
Kubernetes APIに読み書きをするどのようなプログラムも、役に立つ自動化機能を提供することができます。
<em>自動化機能</em> はクラスター上、またはクラスター外で実行できます。
このドキュメントに後述のガイダンスに従うことで、高い可用性を持つ頑強な自動化機能を書くことができます。
自動化機能は通常、ホスティングされているクラスター、マネージドな環境など、どのKubernetesクラスター上でも動きます。</p>
<p>Kubernetes上でうまく動くクライアントプログラムを書くために、<em>コントローラー</em> パターンという明確なパターンがあります。
コントローラーは通常、オブジェクトの <code>.spec</code> を読み取り、何らかの処理をして、オブジェクトの <code>.status</code> を更新します。</p>
<p>コントローラーはKubernetesのクライアントです。Kubernetesがクライアントとして動き、外部のサービスを呼び出す場合、それは <em>Webhook</em> と呼ばれます。
呼び出されるサービスは <em>Webhookバックエンド</em> と呼ばれます。コントローラーのように、Webhookも障害点を追加します。</p>
<p>Webhookのモデルでは、Kubernetesは外部のサービスを呼び出します。
<em>バイナリプラグイン</em> モデルでは、Kubernetesはバイナリ(プログラム)を実行します。
バイナリプラグインはkubelet(例、<a href=/docs/concepts/storage/volumes/#flexVolume>FlexVolumeプラグイン</a>、<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a>)、またkubectlで利用されています。</p>
<p>下図は、それぞれの拡張ポイントが、Kubernetesのコントロールプレーンとどのように関わっているかを示しています。</p>
<img src="https://docs.google.com/drawings/d/e/2PACX-1vQBRWyXLVUlQPlp7BvxvV9S1mxyXSM6rAc_cbLANvKlu6kCCf-kGTporTMIeG5GZtUdxXz1xowN7RmL/pub?w=960&h=720">
<h2 id=拡張ポイント>拡張ポイント</h2>
<p>この図は、Kubernetesにおける拡張ポイントを示しています。</p>
<img src="https://docs.google.com/drawings/d/e/2PACX-1vSH5ZWUO2jH9f34YHenhnCd14baEb4vT-pzfxeFC7NzdNqRDgdz4DDAVqArtH4onOGqh0bhwMX0zGBb/pub?w=425&h=809">
<ol>
<li>ユーザーは頻繁に<code>kubectl</code>を使って、Kubernetes APIとやり取りをします。<a href=/docs/tasks/extend-kubectl/kubectl-plugins/>Kubectlプラグイン</a>は、kubectlのバイナリを拡張します。これは個別ユーザーのローカル環境のみに影響を及ぼすため、サイト全体にポリシーを強制することはできません。</li>
<li>APIサーバーは全てのリクエストを処理します。APIサーバーのいくつかの拡張ポイントは、リクエストを認可する、コンテキストに基づいてブロックする、リクエストを編集する、そして削除を処理することを可能にします。これらは<a href=/docs/concepts/extend-kubernetes/#api-access-extensions>APIアクセス拡張</a>セクションに記載されています。</li>
<li>APIサーバーは様々な種類の <em>リソース</em> を扱います。<code>Pod</code>のような <em>ビルトインリソース</em> はKubernetesプロジェクトにより定義され、変更できません。ユーザーも、自身もしくは、他のプロジェクトで定義されたリソースを追加することができます。それは <em>カスタムリソース</em> と呼ばれ、<a href=/docs/concepts/extend-kubernetes/#user-defined-types>カスタムリソース</a>セクションに記載されています。カスタムリソースは度々、APIアクセス拡張と一緒に使われます。</li>
<li>KubernetesのスケジューラーはPodをどのノードに配置するかを決定します。スケジューリングを拡張するには、いくつかの方法があります。それらは<a href=/docs/concepts/extend-kubernetes/#scheduler-extensions>スケジューラー拡張</a>セクションに記載されています。</li>
<li>Kubernetesにおける多くの振る舞いは、APIサーバーのクライアントであるコントローラーと呼ばれるプログラムに実装されています。コントローラーは度々、カスタムリソースと共に使われます。</li>
<li>kubeletはサーバー上で実行され、Podが仮想サーバーのようにクラスターネットワーク上にIPを持った状態で起動することをサポートします。<a href=/docs/concepts/extend-kubernetes/#network-plugins>ネットワークプラグイン</a>がPodのネットワーキングにおける異なる実装を適用することを可能にします。</li>
<li>kubeletはまた、コンテナのためにボリュームをマウント、アンマウントします。新しい種類のストレージは<a href=/docs/concepts/extend-kubernetes/#storage-plugins>ストレージプラグイン</a>を通じてサポートされます。</li>
</ol>
<p>もしあなたがどこから始めるべきかわからない場合、このフローチャートが役立つでしょう。一部のソリューションは、いくつかの種類の拡張を含んでいることを留意してください。</p>
<img src="https://docs.google.com/drawings/d/e/2PACX-1vRWXNNIVWFDqzDY0CsKZJY3AR8sDeFDXItdc5awYxVH8s0OLherMlEPVUpxPIB1CSUu7GPk7B2fEnzM/pub?w=1440&h=1080">
<h2 id=api拡張>API拡張</h2>
<h3 id=ユーザー定義タイプ>ユーザー定義タイプ</h3>
<p>新しいコントローラー、アプリケーションの設定に関するオブジェクト、また宣言型APIを定義し、それらを<code>kubectl</code>のようなKubernetesのツールから管理したい場合、Kubernetesにカスタムリソースを追加することを検討して下さい。</p>
<p>カスタムリソースはアプリケーション、ユーザー、監視データのデータストレージとしては使わないで下さい。</p>
<p>カスタムリソースに関するさらなる情報は、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソースコンセプトガイド</a>を参照して下さい。</p>
<h3 id=新しいapiと自動化機能の連携>新しいAPIと自動化機能の連携</h3>
<p>カスタムリソースAPIと制御ループの組み合わせは<a href=/ja/docs/concepts/extend-kubernetes/operator/>オペレーターパターン</a>と呼ばれています。オペレーターパターンは、通常ステートフルな特定のアプリケーションを管理するために利用されます。これらのカスタムAPIと制御ループは、ストレージ、またはポリシーのような他のリソースを管理するためにも利用されます。</p>
<h3 id=ビルトインリソースの変更>ビルトインリソースの変更</h3>
<p>カスタムリソースを追加し、KubernetesAPIを拡張する場合、新たに追加されたリソースは常に新しいAPIグループに分類されます。既存のAPIグループを置き換えたり、変更することはできません。APIを追加することは直接、既存のAPI(例、Pod)の振る舞いに影響を与えることは無いですが、APIアクセス拡張の場合、その可能性があります。</p>
<h3 id=api-access-extensions>APIアクセス拡張</h3>
<p>リクエストがKubernetes APIサーバーに到達すると、まず最初に認証が行われ、次に認可、その後、様々なAdmission Controlの対象になります。このフローの詳細は<a href=/docs/concepts/security/controlling-access/>Kubernetes APIへのアクセスをコントロールする</a>を参照して下さい。</p>
<p>これらの各ステップごとに拡張ポイントが用意されています。</p>
<p>Kubdernetesはいくつかのビルトイン認証方式をサポートしています。それは認証プロキシの後ろに配置することも可能で、認可ヘッダーを通じて(Webhookの)検証のために外部サービスにトークンを送ることもできます。全てのこれらの方法は<a href=/ja/docs/reference/access-authn-authz/authentication/>認証ドキュメント</a>でカバーされています。</p>
<h3 id=認証>認証</h3>
<p><a href=/ja/docs/reference/access-authn-authz/authentication/>認証</a>は、全てのリクエストのヘッダーまたは証明書情報を、リクエストを投げたクライアントのユーザー名にマッピングします。</p>
<p>Kubernetesはいくつかのビルトイン認証方式と、それらが要件に合わない場合、<a href=/docs/reference/access-authn-authz/authentication/#webhook-token-authentication>認証Webhook</a>を提供します。</p>
<h3 id=認可>認可</h3>
<p><a href=/docs/reference/access-authn-authz/webhook/>認可</a>は特定のユーザーがAPIリソースに対して、読み込み、書き込み、そしてその他の操作が可能かどうかを決定します。それはオブジェクト全体のレベルで機能し、任意のオブジェクトフィールドに基づいての区別は行いません。もしビルトインの認可メカニズムが要件に合わない場合、<a href=/docs/reference/access-authn-authz/webhook/>認可Webhook</a>が、ユーザー提供のコードを呼び出し認可の決定を行うことを可能にします。</p>
<h3 id=動的admission-control>動的Admission Control</h3>
<p>リクエストが認可された後、もしそれが書き込み操作だった場合、リクエストは<a href=/docs/reference/access-authn-authz/admission-controllers/>Admission Control</a>のステップを通ります。ビルトインのステップに加え、いくつかの拡張が存在します:</p>
<ul>
<li><a href=/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook>イメージポリシーWebhook</a>は、コンテナでどのイメージを実行することができるかを制限する</li>
<li>任意のAdmission Controlの決定を行うには、一般的な<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>Admission webhook</a>が利用できる。Admission Webhookは作成、更新を拒絶できる</li>
</ul>
<h2 id=インフラストラクチャ拡張>インフラストラクチャ拡張</h2>
<h3 id=ストレージプラグイン>ストレージプラグイン</h3>
<p><a href=/docs/concepts/storage/volumes/#flexVolume>Flex Volumes</a>は、Kubeletがバイナリプラグインを呼び出してボリュームをマウントすることにより、ユーザーはビルトインのサポートなしでボリュームタイプをマウントすることを可能にします。</p>
<h3 id=デバイスプラグイン>デバイスプラグイン</h3>
<p><a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a>を通じて、ノードが新たなノードのリソース(CPU、メモリなどのビルトインのものに加え)を見つけることを可能にします。</p>
<h3 id=ネットワークプラグイン>ネットワークプラグイン</h3>
<p>他のネットワークファブリックが<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a>を通じてサポートされます。</p>
<h3 id=スケジューラー拡張>スケジューラー拡張</h3>
<p>スケジューラーは特別な種類のコントローラーで、Podを監視し、Podをノードに割り当てます。デフォルトのコントローラーを完全に置き換えることもできますが、他のKubernetesのコンポーネントの利用を継続する、または<a href=/docs/tasks/extend-kubernetes/configure-multiple-schedulers/>複数のスケジューラー</a>を同時に動かすこともできます。</p>
<p>これはかなりの大きな作業で、ほとんど全てのKubernetesユーザーはスケジューラーを変更する必要はありません。</p>
<p>スケジューラは<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/scheduler_extender.md>Webhook</a>もサポートしており、Webhookバックエンド(スケジューラー拡張)を通じてPodを配置するために選択されたノードをフィルタリング、優先度付けすることが可能です。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>についてより深く学ぶ</li>
<li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>動的Admission control</a>について学ぶ</li>
<li>インフラストラクチャ拡張についてより深く学ぶ
<ul>
<li><a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a></li>
<li><a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a></li>
</ul>
</li>
<li><a href=/docs/tasks/extend-kubectl/kubectl-plugins/>kubectlプラグイン</a>について学ぶ</li>
<li><a href=/docs/concepts/extend-kubernetes/operator/>オペレーターパターン</a>について学ぶ</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5c2b36cd0ddbe006b575d4e54c63d508>3.12.1 - Kubernetesクラスターの拡張</h1>
<p>Kubernetesは柔軟な設定が可能で、高い拡張性を持っています。
結果として、Kubernetesのプロジェクトソースコードをフォークしたり、パッチを当てて利用することは滅多にありません。</p>
<p>このガイドは、Kubernetesクラスターをカスタマイズするための選択肢を記載します。
管理しているKubernetesクラスターを、動作環境の要件にどのように適合させるべきかを理解したい<a class=glossary-tooltip title=クラスターを設定、管理そして、監視する人 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-cluster-operator" target=_blank aria-label=クラスター管理者>クラスター管理者</a>を対象にしています。
将来の <a class=glossary-tooltip title=自身のプロジェクトの要件に合わせ、Kubernetesプラットフォームをカスタマイズする人 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-platform-developer" target=_blank aria-label=プラットフォーム開発者>プラットフォーム開発者</a> 、またはKubernetesプロジェクトの<a class=glossary-tooltip title=Kubernetesプロジェクトやコミュニティのために、コード、ドキュメント、またはその他の作業に自身の時間を使って貢献している人々 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-contributor" target=_blank aria-label=コントリビューター>コントリビューター</a>にとっても、どのような拡張のポイントやパターンが存在するのか、また、それぞれのトレードオフや制限事項を学ぶための導入として役立つでしょう。</p>
<h2 id=概要>概要</h2>
<p>カスタマイズのアプローチには大きく分けて、フラグ、ローカル設定ファイル、またはAPIリソースの変更のみを含んだ <em>コンフィグレーション</em> と、稼働しているプログラムまたはサービスも含んだ <em>エクステンション</em> があります。このドキュメントでは、主にエクステンションについて説明します。</p>
<h2 id=コンフィグレーション>コンフィグレーション</h2>
<p><em>設定ファイル</em> と <em>フラグ</em> はオンラインドキュメントのリファレンスセクションの中の、各項目に記載されています:</p>
<ul>
<li><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a></li>
<li><a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a></li>
<li><a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a></li>
<li><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a></li>
</ul>
<p>ホスティングされたKubernetesサービスやマネージドなKubernetesでは、フラグと設定ファイルが常に変更できるとは限りません。変更可能な場合でも、通常はクラスターの管理者のみが変更できます。また、それらは将来のKubernetesバージョンで変更される可能性があり、設定変更にはプロセスの再起動が必要になるかもしれません。これらの理由により、この方法は他の選択肢が無いときにのみ利用するべきです。</p>
<p><a href=/ja/docs/concepts/policy/resource-quotas/>ResourceQuota</a>、<a href=/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>、<a href=/docs/concepts/services-networking/network-policies/>NetworkPolicy</a>、そしてロールベースアクセス制御(<a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>)といった <em>ビルトインポリシーAPI</em> は、ビルトインのKubernetes APIです。APIは通常、ホスティングされたKubernetesサービスやマネージドなKubernetesで利用されます。これらは宣言的で、Podのような他のKubernetesリソースと同じ慣例に従っています。そのため、新しいクラスターの設定は繰り返し再利用することができ、アプリケーションと同じように管理することが可能です。さらに、安定版(stable)を利用している場合、他のKubernetes APIのような<a href=/docs/reference/using-api/deprecation-policy/>定義済みのサポートポリシー</a>を利用することができます。これらの理由により、この方法は、適切な用途の場合、 <em>設定ファイル</em> や <em>フラグ</em> よりも好まれます。</p>
<h2 id=エクステンション>エクステンション</h2>
<p>エクステンションはKubernetesを拡張し、深く統合されたソフトウェアの構成要素です。
これは新しいタイプと、新しい種類のハードウェアをサポートするために利用されます。</p>
<p>ほとんどのクラスター管理者は、ホスティングされている、またはディストリビューションとしてのKubernetesを使っているでしょう。
結果として、ほとんどのKubernetesユーザーは既存のエクステンションを使えばよいため、新しいエクステンションを書く必要は無いと言えます。</p>
<h2 id=extension-patterns>エクステンションパターン</h2>
<p>Kubernetesは、クライアントのプログラムを書くことで自動化ができるようにデザインされています。
Kubernetes APIに読み書きをするどのようなプログラムも、役に立つ自動化機能を提供することができます。
<em>自動化機能</em> はクラスター上、またはクラスター外で実行できます。
このドキュメントに後述のガイダンスに従うことで、高い可用性を持つ頑強な自動化機能を書くことができます。
自動化機能は通常、ホスティングされているクラスター、マネージドな環境など、どのKubernetesクラスター上でも動きます。</p>
<p>Kubernetes上でうまく動くクライアントプログラムを書くために、<em>コントローラー</em> パターンという明確なパターンがあります。
コントローラーは通常、オブジェクトの <code>.spec</code> を読み取り、何らかの処理をして、オブジェクトの <code>.status</code> を更新します。</p>
<p>コントローラーはKubernetesのクライアントです。Kubernetesがクライアントとして動き、外部のサービスを呼び出す場合、それは <em>Webhook</em> と呼ばれます。
呼び出されるサービスは <em>Webhookバックエンド</em> と呼ばれます。コントローラーのように、Webhookも障害点を追加します。</p>
<p>Webhookのモデルでは、Kubernetesは外部のサービスを呼び出します。
<em>バイナリプラグイン</em> モデルでは、Kubernetesはバイナリ(プログラム)を実行します。
バイナリプラグインはkubelet(例、<a href=/docs/concepts/storage/volumes/#flexvolume>FlexVolumeプラグイン</a>、<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a>)、またkubectlで利用されています。</p>
<p>下図は、それぞれの拡張ポイントが、Kubernetesのコントロールプレーンとどのように関わっているかを示しています。</p>
<img src="https://docs.google.com/drawings/d/e/2PACX-1vQBRWyXLVUlQPlp7BvxvV9S1mxyXSM6rAc_cbLANvKlu6kCCf-kGTporTMIeG5GZtUdxXz1xowN7RmL/pub?w=960&h=720">
<h2 id=拡張ポイント>拡張ポイント</h2>
<p>この図は、Kubernetesにおける拡張ポイントを示しています。</p>
<img src="https://docs.google.com/drawings/d/e/2PACX-1vSH5ZWUO2jH9f34YHenhnCd14baEb4vT-pzfxeFC7NzdNqRDgdz4DDAVqArtH4onOGqh0bhwMX0zGBb/pub?w=425&h=809">
<ol>
<li>ユーザーは頻繁に<code>kubectl</code>を使って、Kubernetes APIとやり取りをします。<a href=/docs/tasks/extend-kubectl/kubectl-plugins/>Kubectlプラグイン</a>は、kubectlのバイナリを拡張します。これは個別ユーザーのローカル環境のみに影響を及ぼすため、サイト全体にポリシーを強制することはできません。</li>
<li>APIサーバーは全てのリクエストを処理します。APIサーバーのいくつかの拡張ポイントは、リクエストを認可する、コンテキストに基づいてブロックする、リクエストを編集する、そして削除を処理することを可能にします。これらは<a href=/ja/docs/concepts/extend-kubernetes/#api-access-extensions>APIアクセスエクステンション</a>セクションに記載されています。</li>
<li>APIサーバーは様々な種類の <em>リソース</em> を扱います。<code>Pod</code>のような <em>ビルトインリソース</em> はKubernetesプロジェクトにより定義され、変更できません。ユーザーも、自身もしくは、他のプロジェクトで定義されたリソースを追加することができます。それは <em>カスタムリソース</em> と呼ばれ、<a href=/ja/docs/concepts/extend-kubernetes/#user-defined-types>カスタムリソース</a>セクションに記載されています。カスタムリソースは度々、APIアクセスエクステンションと一緒に使われます。</li>
<li>KubernetesのスケジューラーはPodをどのノードに配置するかを決定します。スケジューリングを拡張するには、いくつかの方法があります。それらは<a href=/ja/docs/concepts/extend-kubernetes/#scheduler-extensions>スケジューラーエクステンション</a>セクションに記載されています。</li>
<li>Kubernetesにおける多くの振る舞いは、APIサーバーのクライアントであるコントローラーと呼ばれるプログラムに実装されています。コントローラーは度々、カスタムリソースと共に使われます。</li>
<li>kubeletはサーバー上で実行され、Podが仮想サーバーのようにクラスターネットワーク上にIPを持った状態で起動することをサポートします。<a href=/ja/docs/concepts/extend-kubernetes/#network-plugins>ネットワークプラグイン</a>がPodのネットワーキングにおける異なる実装を適用することを可能にします。</li>
<li>kubeletはまた、コンテナのためにボリュームをマウント、アンマウントします。新しい種類のストレージは<a href=/ja/docs/concepts/extend-kubernetes/#storage-plugins>ストレージプラグイン</a>を通じてサポートされます。</li>
</ol>
<p>もしあなたがどこから始めるべきかわからない場合、このフローチャートが役立つでしょう。一部のソリューションは、いくつかの種類のエクステンションを含んでいることを留意してください。</p>
<img src="https://docs.google.com/drawings/d/e/2PACX-1vRWXNNIVWFDqzDY0CsKZJY3AR8sDeFDXItdc5awYxVH8s0OLherMlEPVUpxPIB1CSUu7GPk7B2fEnzM/pub?w=1440&h=1080">
<h2 id=apiエクステンション>APIエクステンション</h2>
<h3 id=ユーザー定義タイプ>ユーザー定義タイプ</h3>
<p>新しいコントローラー、アプリケーションの設定に関するオブジェクト、また宣言型APIを定義し、それらを<code>kubectl</code>のようなKubernetesのツールから管理したい場合、Kubernetesにカスタムリソースを追加することを検討して下さい。</p>
<p>カスタムリソースはアプリケーション、ユーザー、監視データのデータストレージとしては使わないで下さい。</p>
<p>カスタムリソースに関するさらなる情報は、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソースコンセプトガイド</a>を参照して下さい。</p>
<h3 id=新しいapiと自動化機能の連携>新しいAPIと自動化機能の連携</h3>
<p>カスタムリソースAPIと制御ループの組み合わせは<a href=/ja/docs/concepts/extend-kubernetes/operator/>オペレーターパターン</a>と呼ばれています。オペレーターパターンは、通常ステートフルな特定のアプリケーションを管理するために利用されます。これらのカスタムAPIと制御ループは、ストレージ、またはポリシーのような他のリソースを管理するためにも利用されます。</p>
<h3 id=ビルトインリソースの変更>ビルトインリソースの変更</h3>
<p>カスタムリソースを追加し、KubernetesAPIを拡張する場合、新たに追加されたリソースは常に新しいAPIグループに分類されます。既存のAPIグループを置き換えたり、変更することはできません。APIを追加することは直接、既存のAPI(例、Pod)の振る舞いに影響を与えることは無いですが、APIアクセスエクステンションの場合、その可能性があります。</p>
<h3 id=apiアクセスエクステンション>APIアクセスエクステンション</h3>
<p>リクエストがKubernetes APIサーバーに到達すると、まず最初に認証が行われ、次に認可、その後、様々なAdmission Controlの対象になります。このフローの詳細は<a href=/docs/concepts/security/controlling-access/>Kubernetes APIへのアクセスをコントロールする</a>を参照して下さい。</p>
<p>これらの各ステップごとに拡張ポイントが用意されています。</p>
<p>Kubdernetesはいくつかのビルトイン認証方式をサポートしています。それは認証プロキシの後ろに配置することも可能で、認可ヘッダーを通じて(Webhookの)検証のために外部サービスにトークンを送ることもできます。全てのこれらの方法は<a href=/ja/docs/reference/access-authn-authz/authentication/>認証ドキュメント</a>でカバーされています。</p>
<h3 id=認証>認証</h3>
<p><a href=/ja/docs/reference/access-authn-authz/authentication/>認証</a>は、全てのリクエストのヘッダーまたは証明書情報を、リクエストを投げたクライアントのユーザー名にマッピングします。</p>
<p>Kubernetesはいくつかのビルトイン認証方式と、それらが要件に合わない場合、<a href=/docs/reference/access-authn-authz/authentication/#webhook-token-authentication>認証Webhook</a>を提供します。</p>
<h3 id=認可>認可</h3>
<p><a href=/docs/reference/access-authn-authz/webhook/>認可</a>は特定のユーザーがAPIリソースに対して、読み込み、書き込み、そしてその他の操作が可能かどうかを決定します。それはオブジェクト全体のレベルで機能し、任意のオブジェクトフィールドに基づいての区別は行いません。もしビルトインの認可メカニズムが要件に合わない場合、<a href=/docs/reference/access-authn-authz/webhook/>認可Webhook</a>が、ユーザー提供のコードを呼び出し認可の決定を行うことを可能にします。</p>
<h3 id=動的admission-control>動的Admission Control</h3>
<p>リクエストが認可された後、もしそれが書き込み操作だった場合、リクエストは<a href=/docs/reference/access-authn-authz/admission-controllers/>Admission Control</a>のステップを通ります。ビルトインのステップに加え、いくつかのエクステンションが存在します:</p>
<ul>
<li><a href=/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook>イメージポリシーWebhook</a>は、コンテナでどのイメージを実行することができるかを制限する</li>
<li>任意のAdmission Controlの決定を行うには、一般的な<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>Admission webhook</a>が利用できる。Admission Webhookは作成、更新を拒絶できる</li>
</ul>
<h2 id=インフラストラクチャエクステンション>インフラストラクチャエクステンション</h2>
<h3 id=ストレージプラグイン>ストレージプラグイン</h3>
<p><a href=/docs/concepts/storage/volumes/#flexvolume>Flex Volumes</a>は、Kubeletがバイナリプラグインを呼び出してボリュームをマウントすることにより、ユーザーはビルトインのサポートなしでボリュームタイプをマウントすることを可能にします。</p>
<h3 id=デバイスプラグイン>デバイスプラグイン</h3>
<p><a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a>を通じて、ノードが新たなノードのリソース(CPU、メモリなどのビルトインのものに加え)を見つけることを可能にします。</p>
<h3 id=ネットワークプラグイン>ネットワークプラグイン</h3>
<p>他のネットワークファブリックが<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a>を通じてサポートされます。</p>
<h3 id=スケジューラーエクステンション>スケジューラーエクステンション</h3>
<p>スケジューラーは特別な種類のコントローラーで、Podを監視し、Podをノードに割り当てます。デフォルトのコントローラーを完全に置き換えることもできますが、他のKubernetesのコンポーネントの利用を継続する、または<a href=/docs/tasks/extend-kubernetes/configure-multiple-schedulers/>複数のスケジューラー</a>を同時に動かすこともできます。</p>
<p>これはかなりの大きな作業で、ほとんど全てのKubernetesユーザーはスケジューラーを変更する必要はありません。</p>
<p>スケジューラは<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/scheduler_extender.md>Webhook</a>もサポートしており、Webhookバックエンド(スケジューラーエクステンション)を通じてPodを配置するために選択されたノードをフィルタリング、優先度付けすることが可能です。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>についてより深く学ぶ</li>
<li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>動的Admission control</a>について学ぶ</li>
<li>インフラストラクチャエクステンションについてより深く学ぶ
<ul>
<li><a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a></li>
<li><a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>デバイスプラグイン</a></li>
</ul>
</li>
<li><a href=/docs/tasks/extend-kubectl/kubectl-plugins/>kubectlプラグイン</a>について学ぶ</li>
<li><a href=/docs/concepts/extend-kubernetes/operator/>オペレーターパターン</a>について学ぶ</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-0af41d3bd7c785621b58b7564793396a>3.12.2 - Kubernetes APIの拡張</h1>
</div>
<div class=td-content>
<h1 id=pg-342388440304e19ce30c0f8ada1c77ce>3.12.2.1 - カスタムリソース</h1>
<p><em>カスタムリソース</em> はKubernetes APIの拡張です。このページでは、いつKubernetesのクラスターにカスタムリソースを追加するべきなのか、そしていつスタンドアローンのサービスを利用するべきなのかを議論します。カスタムリソースを追加する2つの方法と、それらの選択方法について説明します。</p>
<h2 id=カスタムリソース>カスタムリソース</h2>
<p><em>リソース</em> は、<a href=/ja/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>のエンドポイントで、特定の<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/>APIオブジェクト</a>のコレクションを保持します。例えば、ビルトインの <em>Pods</em> リソースは、Podオブジェクトのコレクションを包含しています。</p>
<p><em>カスタムリソース</em> は、Kubernetes APIの拡張で、デフォルトのKubernetesインストールでは、必ずしも利用できるとは限りません。つまりそれは、特定のKubernetesインストールのカスタマイズを表します。しかし、今現在、多数のKubernetesのコア機能は、カスタムリソースを用いて作られており、Kubernetesをモジュール化しています。</p>
<p>カスタムリソースは、稼働しているクラスターに動的に登録され、現れたり、消えたりし、クラスター管理者はクラスター自体とは無関係にカスタムリソースを更新できます。一度、カスタムリソースがインストールされると、ユーザーは<a href=/ja/docs/reference/kubectl/overview/>kubectl</a>を使い、ビルトインのリソースである <em>Pods</em> と同じように、オブジェクトを作成、アクセスすることが可能です。</p>
<h2 id=カスタムコントローラー>カスタムコントローラー</h2>
<p>カスタムリソースそれ自身は、単純に構造化データを格納、取り出す機能を提供します。カスタムリソースを <em>カスタムコントローラー</em> と組み合わせることで、カスタムリソースは真の <em>宣言的API</em> を提供します。</p>
<p><a href=/ja/docs/concepts/overview/kubernetes-api/>宣言的API</a>は、リソースのあるべき状態を <em>宣言</em> または指定することを可能にし、Kubernetesオブジェクトの現在の状態を、あるべき状態に同期し続けるように動きます。
コントローラーは、構造化データをユーザーが指定したあるべき状態と解釈し、その状態を管理し続けます。</p>
<p>稼働しているクラスターのライフサイクルとは無関係に、カスタムコントローラーをデプロイ、更新することが可能です。カスタムコントローラーはあらゆるリソースと連携できますが、カスタムリソースと組み合わせると特に効果を発揮します。<a href=https://coreos.com/blog/introducing-operators.html>オペレーターパターン</a>は、カスタムリソースとカスタムコントローラーの組み合わせです。カスタムコントローラーにより、特定アプリケーションのドメイン知識を、Kubernetes APIの拡張に変換することができます。</p>
<h2 id=カスタムリソースをクラスターに追加するべきか>カスタムリソースをクラスターに追加するべきか？</h2>
<p>新しいAPIを作る場合、<a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>APIをKubernetesクラスターAPIにアグリゲート(集約)する</a>か、もしくはAPIをスタンドアローンで動かすかを検討します。</p>
<table>
<thead>
<tr>
<th>APIアグリゲーションを使う場合:</th>
<th>スタンドアローンAPIを使う場合:</th>
</tr>
</thead>
<tbody>
<tr>
<td>APIが<a href=#%E5%AE%A3%E8%A8%80%E7%9A%84API>宣言的</a></td>
<td>APIが<a href=#%E5%AE%A3%E8%A8%80%E7%9A%84API>宣言的</a>モデルに適さない</td>
</tr>
<tr>
<td>新しいリソースを<code>kubectl</code>を使い読み込み、書き込みしたい</td>
<td><code>kubectl</code>のサポートは必要ない</td>
</tr>
<tr>
<td>新しいリソースをダッシュボードのような、Kubernetes UIで他のビルトインリソースと同じように管理したい</td>
<td>Kubernetes UIのサポートは必要ない</td>
</tr>
<tr>
<td>新しいAPIを開発している</td>
<td>APIを提供し、適切に機能するプログラムが既に存在している</td>
</tr>
<tr>
<td>APIグループ、名前空間というような、RESTリソースパスに割り当てられた、Kubernetesのフォーマット仕様の制限を許容できる(<a href=/ja/docs/concepts/overview/kubernetes-api/>API概要</a>を参照)</td>
<td>既に定義済みのREST APIと互換性を持っていなければならない</td>
</tr>
<tr>
<td>リソースはクラスターごとか、クラスター内の名前空間に自然に分けることができる</td>
<td>クラスター、または名前空間による分割がリソース管理に適さない。特定のリソースパスに基づいて管理したい</td>
</tr>
<tr>
<td><a href=#%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E6%A9%9F%E8%83%BD>Kubernetes APIサポート機能</a>を再利用したい</td>
<td>これらの機能は必要ない</td>
</tr>
</tbody>
</table>
<h3 id=宣言的api>宣言的API</h3>
<p>宣言的APIは、通常、下記に該当します:</p>
<ul>
<li>APIは、比較的少数の、比較的小さなオブジェクト(リソース)で構成されている</li>
<li>オブジェクトは、アプリケーションの設定、インフラストラクチャーを定義する</li>
<li>オブジェクトは、比較的更新頻度が低い</li>
<li>人は、オブジェクトの情報をよく読み書きする</li>
<li>オブジェクトに対する主要な手続きは、CRUD(作成、読み込み、更新、削除)になる</li>
<li>複数オブジェクトをまたいだトランザクションは必要ない: APIは今現在の状態ではなく、あるべき状態を表現する</li>
</ul>
<p>命令的APIは、宣言的ではありません。
APIが宣言的ではない兆候として、次のものがあります:</p>
<ul>
<li>クライアントから"これを実行"と命令がきて、完了の返答を同期的に受け取る</li>
<li>クライアントから"これを実行"と命令がきて、処理IDを取得する。そして処理が完了したかどうかを、処理IDを利用して別途問い合わせる</li>
<li>リモートプロシージャコール(RPC)という言葉が飛び交っている</li>
<li>直接、大量のデータを格納している(例、1オブジェクトあたり数kBより大きい、または数千オブジェクトより多い)</li>
<li>高帯域アクセス(持続的に毎秒数十リクエスト)が必要</li>
<li>エンドユーザーのデータ(画像、PII、その他)を格納している、またはアプリケーションが処理する大量のデータを格納している</li>
<li>オブジェクトに対する処理が、CRUDではない</li>
<li>APIをオブジェクトとして簡単に表現できない</li>
<li>停止している処理を処理ID、もしくは処理オブジェクトで表現することを選択している</li>
</ul>
<h2 id=configmapとカスタムリソースのどちらを使うべきか>ConfigMapとカスタムリソースのどちらを使うべきか？</h2>
<p>下記のいずれかに該当する場合は、ConfigMapを使ってください:</p>
<ul>
<li><code>mysql.cnf</code>、<code>pom.xml</code>のような、十分に文書化された設定ファイルフォーマットが既に存在している</li>
<li>単一キーのConfigMapに、設定ファイルの内容の全てを格納している</li>
<li>設定ファイルの主な用途は、クラスター上のPodで実行されているプログラムがファイルを読み込み、それ自体を構成することである</li>
<li>ファイルの利用者は、Kubernetes APIよりも、Pod内のファイルまたはPod内の環境変数を介して利用することを好む</li>
<li>ファイルが更新されたときに、Deploymentなどを介してローリングアップデートを行いたい</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> センシティブなデータには、ConfigMapに類似していますがよりセキュアな<a href=/ja/docs/concepts/configuration/secret/>secret</a>を使ってください
</div>
<p>下記のほとんどに該当する場合、カスタムリソース(CRD、またはアグリゲートAPI)を使ってください:</p>
<ul>
<li>新しいリソースを作成、更新するために、Kubernetesのクライアントライブラリー、CLIを使いたい</li>
<li>kubectlのトップレベルサポートが欲しい(例、<code>kubectl get my-object object-name</code>)</li>
<li>新しい自動化の仕組みを作り、新しいオブジェクトの更新をウォッチしたい、その更新を契機に他のオブジェクトのCRUDを実行したい、またはその逆を行いたい</li>
<li>オブジェクトの更新を取り扱う、自動化の仕組みを書きたい</li>
<li><code>.spec</code>、<code>.status</code>、<code>.metadata</code>というような、Kubernetes APIの慣習を使いたい</li>
<li>オブジェクトは、制御されたリソースコレクションの抽象化、または他のリソースのサマリーとしたい</li>
</ul>
<h2 id=カスタムリソースを追加する>カスタムリソースを追加する</h2>
<p>Kubernetesは、クラスターへカスタムリソースを追加する2つの方法を提供しています:</p>
<ul>
<li>CRDはシンプルで、プログラミングなしに作成可能</li>
<li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>APIアグリゲーション</a>は、プログラミングが必要だが、データがどのように格納され、APIバージョン間でどのように変換されるかというような、より詳細なAPIの振る舞いを制御できる</li>
</ul>
<p>Kubernetesは、さまざまなユーザーのニーズを満たすためにこれら2つのオプションを提供しており、使いやすさや柔軟性が損なわれることはありません。</p>
<p>アグリゲートAPIは、プロキシーとして機能するプライマリAPIサーバーの背後にある、下位のAPIServerです。このような配置は<a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>APIアグリゲーション</a>(AA)と呼ばれています。ユーザーにとっては、単にAPIサーバーが拡張されているように見えます。</p>
<p>CRDでは、APIサーバーの追加なしに、ユーザーが新しい種類のリソースを作成できます。CRDを使うには、APIアグリゲーションを理解する必要はありません。</p>
<p>どのようにインストールされたかに関わらず、新しいリソースはカスタムリソースとして参照され、ビルトインのKubernetesリソース(Podなど)とは区別されます。</p>
<h2 id=customresourcedefinition>CustomResourceDefinition</h2>
<p><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>APIリソースは、カスタムリソースを定義します。CRDオブジェクトを定義することで、指定した名前、スキーマで新しいカスタムリソースが作成されます。Kubernetes APIは、作成したカスタムリソースのストレージを提供、および処理します。
CRDオブジェクトの名前は<a href=/ja/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names>DNSサブドメイン名</a>に従わなければなりません。</p>
<p>これはカスタムリソースを処理するために、独自のAPIサーバーを書くことから解放してくれますが、一般的な性質として<a href=#API%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%A2%E3%82%B0%E3%83%AA%E3%82%B2%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3>APIサーバーアグリゲーション</a>と比べると、柔軟性に欠けます。</p>
<p>新しいカスタムリソースをどのように登録するか、新しいリソースタイプとの連携、そしてコントローラーを使いイベントを処理する方法例について、<a href=https://github.com/kubernetes/sample-controller>カスタムコントローラー例</a>を参照してください。</p>
<h2 id=apiサーバーアグリゲーション>APIサーバーアグリゲーション</h2>
<p>通常、Kubernetes APIの各リソースは、RESTリクエストとオブジェクトの永続的なストレージを管理するためのコードが必要です。メインのKubernetes APIサーバーは <em>Pod</em> や <em>Service</em> のようなビルトインのリソースを処理し、またカスタムリソースも<a href=#customresourcedefinition>CRD</a>を通じて同じように管理することができます。</p>
<p><a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>アグリゲーションレイヤー</a>は、独自のスタンドアローンAPIサーバーを書き、デプロイすることで、カスタムリソースに特化した実装の提供を可能にします。メインのAPIサーバーが、処理したいカスタムリソースへのリクエストを委譲することで、他のクライアントからも利用できるようにします。</p>
<h2 id=カスタムリソースの追加方法を選択する>カスタムリソースの追加方法を選択する</h2>
<p>CRDは簡単に使えます。アグリゲートAPIはより柔軟です。ニーズに最も合う方法を選択してください。</p>
<p>通常、CRDは下記の場合に適しています:</p>
<ul>
<li>少数のフィールドしか必要ない</li>
<li>そのリソースは社内のみで利用している、または小さいオープンソースプロジェクトの一部で利用している(商用プロダクトではない)</li>
</ul>
<h3 id=使いやすさの比較>使いやすさの比較</h3>
<p>CRDは、アグリゲートAPIと比べ、簡単に作れます。</p>
<table>
<thead>
<tr>
<th>CRD</th>
<th>アグリゲートAPI</th>
</tr>
</thead>
<tbody>
<tr>
<td>プログラミングが不要で、ユーザーはCRDコントローラーとしてどの言語でも選択可能</td>
<td>Go言語でプログラミングし、バイナリとイメージの作成が必要</td>
</tr>
<tr>
<td>追加のサービスは不要。CRDはAPIサーバーで処理される</td>
<td>追加のサービス作成が必要で、障害が発生する可能性がある</td>
</tr>
<tr>
<td>CRDが作成されると、継続的なサポートは無い。バグ修正は通常のKubernetesマスターのアップグレードで行われる</td>
<td>定期的にアップストリームからバグ修正の取り込み、リビルド、そしてアグリゲートAPIサーバーの更新が必要かもしれない</td>
</tr>
<tr>
<td>複数バージョンのAPI管理は不要。例えば、あるリソースを操作するクライアントを管理していた場合、APIのアップグレードと一緒に更新される</td>
<td>複数バージョンのAPIを管理しなければならない。例えば、世界中に共有されている拡張機能を開発している場合</td>
</tr>
</tbody>
</table>
<h3 id=高度な機能-柔軟性>高度な機能、柔軟性</h3>
<p>アグリゲートAPIは、例えばストレージレイヤーのカスタマイズのような、より高度なAPI機能と他の機能のカスタマイズを可能にします。</p>
<table>
<thead>
<tr>
<th>機能</th>
<th>詳細</th>
<th>CRD</th>
<th>アグリゲートAPI</th>
</tr>
</thead>
<tbody>
<tr>
<td>バリデーション</td>
<td>エラーを予防し、クライアントと無関係にAPIを発達させることができるようになる。これらの機能は多数のクライアントがおり、同時に全てを更新できないときに最も効果を発揮する</td>
<td>はい、ほとんどのバリデーションは<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 validation</a>で、CRDに指定できる。その他のバリデーションは<a href=/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook-alpha-in-1-8-beta-in-1-9>Webhookのバリデーション</a>によりサポートされている</td>
<td>はい、任意のバリデーションが可能</td>
</tr>
<tr>
<td>デフォルト設定</td>
<td>上記を参照</td>
<td>はい、<a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#defaulting>OpenAPI v3.0 validation</a>の<code>default</code>キーワード(1.17でGA)、または<a href=/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook>Mutating Webhook</a>を通じて可能 (ただし、この方法は古いオブジェクトをetcdから読み込む場合には動きません)</td>
<td>はい</td>
</tr>
<tr>
<td>複数バージョニング</td>
<td>同じオブジェクトを、違うAPIバージョンで利用可能にする。フィールドの名前を変更するなどのAPIの変更を簡単に行うのに役立つ。クライアントのバージョンを管理する場合、重要性は下がる</td>
<td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning>はい</a></td>
<td>はい</td>
</tr>
<tr>
<td>カスタムストレージ</td>
<td>異なる性能のストレージが必要な場合(例えば、キーバリューストアの代わりに時系列データベース)または、セキュリティの分離(例えば、機密情報の暗号化、その他)</td>
<td>いいえ</td>
<td>はい</td>
</tr>
<tr>
<td>カスタムビジネスロジック</td>
<td>オブジェクトが作成、読み込み、更新、また削除されるときに任意のチェック、アクションを実行する</td>
<td>はい、<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>Webhooks</a>を利用</td>
<td>はい</td>
</tr>
<tr>
<td>サブリソースのスケール</td>
<td>HorizontalPodAutoscalerやPodDisruptionBudgetなどのシステムが、新しいリソースと連携できるようにする</td>
<td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource>はい</a></td>
<td>はい</td>
</tr>
<tr>
<td>サブリソースの状態</td>
<td>ユーザーがspecセクションに書き込み、コントローラーがstatusセクションに書き込む際に、より詳細なアクセスコントロールができるようにする。カスタムリソースのデータ変換時にオブジェクトの世代を上げられるようにする(リソース内のspecとstatusでセクションが分離している必要がある)</td>
<td><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource>はい</a></td>
<td>はい</td>
</tr>
<tr>
<td>その他のサブリソース</td>
<td>"logs"や"exec"のような、CRUD以外の処理の追加</td>
<td>いいえ</td>
<td>はい</td>
</tr>
<tr>
<td>strategic-merge-patch</td>
<td><code>Content-Type: application/strategic-merge-patch+json</code>で、PATCHをサポートする新しいエンドポイント。ローカル、サーバー、どちらでも更新されうるオブジェクトに有用。さらなる情報は<a href=/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>"APIオブジェクトをkubectl patchで決まった場所で更新"</a>を参照</td>
<td>いいえ</td>
<td>はい</td>
</tr>
<tr>
<td>プロトコルバッファ</td>
<td>プロトコルバッファを使用するクライアントをサポートする新しいリソース</td>
<td>いいえ</td>
<td>はい</td>
</tr>
<tr>
<td>OpenAPIスキーマ</td>
<td>サーバーから動的に取得できる型のOpenAPI(Swagger)スキーマはあるか、許可されたフィールドのみが設定されるようにすることで、ユーザーはフィールド名のスペルミスから保護されているか、型は強制されているか(言い換えると、「文字列」フィールドに「int」を入れさせない)</td>
<td>はい、<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 validation</a> スキーマがベース(1.16でGA)</td>
<td>はい</td>
</tr>
</tbody>
</table>
<h3 id=一般的な機能>一般的な機能</h3>
<p>CRD、またはアグリゲートAPI、どちらを使ってカスタムリソースを作った場合でも、Kubernetesプラットフォーム外でAPIを実装するのに比べ、多数の機能が提供されます:</p>
<table>
<thead>
<tr>
<th>機能</th>
<th>何を実現するか</th>
</tr>
</thead>
<tbody>
<tr>
<td>CRUD</td>
<td>新しいエンドポイントが、HTTP、<code>kubectl</code>を通じて、基本的なCRUD処理をサポート</td>
</tr>
<tr>
<td>Watch</td>
<td>新しいエンドポイントが、HTTPを通じて、KubernetesのWatch処理をサポート</td>
</tr>
<tr>
<td>Discovery</td>
<td><code>kubectl</code>やダッシュボードのようなクライアントが、自動的にリソースの一覧表示、個別表示、フィールドの編集処理を提供</td>
</tr>
<tr>
<td>json-patch</td>
<td>新しいエンドポイントが<code>Content-Type: application/json-patch+json</code>を用いたPATCHをサポート</td>
</tr>
<tr>
<td>merge-patch</td>
<td>新しいエンドポイントが<code>Content-Type: application/merge-patch+json</code>を用いたPATCHをサポート</td>
</tr>
<tr>
<td>HTTPS</td>
<td>新しいエンドポイントがHTTPSを利用</td>
</tr>
<tr>
<td>ビルトイン認証</td>
<td>拡張機能へのアクセスに認証のため、コアAPIサーバー(アグリゲーションレイヤー)を利用</td>
</tr>
<tr>
<td>ビルトイン認可</td>
<td>拡張機能へのアクセスにコアAPIサーバーで使われている認可メカニズムを再利用(例、RBAC)</td>
</tr>
<tr>
<td>ファイナライザー</td>
<td>外部リソースの削除が終わるまで、拡張リソースの削除をブロック</td>
</tr>
<tr>
<td>Admission Webhooks</td>
<td>拡張リソースの作成/更新/削除処理時に、デフォルト値の設定、バリデーションを実施</td>
</tr>
<tr>
<td>UI/CLI 表示</td>
<td>kubectl、ダッシュボードで拡張リソースを表示</td>
</tr>
<tr>
<td>未設定 対 空設定</td>
<td>クライアントは、フィールドの未設定とゼロ値を区別することができる</td>
</tr>
<tr>
<td>クライアントライブラリーの生成</td>
<td>Kubernetesは、一般的なクライアントライブラリーと、タイプ固有のクライアントライブラリーを生成するツールを提供</td>
</tr>
<tr>
<td>ラベルとアノテーション</td>
<td>ツールがコアリソースとカスタムリソースの編集方法を知っているオブジェクト間で、共通のメタデータを提供</td>
</tr>
</tbody>
</table>
<h2 id=カスタムリソースのインストール準備>カスタムリソースのインストール準備</h2>
<p>クラスターにカスタムリソースを追加する前に、いくつか認識しておくべき事項があります。</p>
<h3 id=サードパーティのコードと新しい障害点>サードパーティのコードと新しい障害点</h3>
<p>CRDを作成しても、勝手に新しい障害点が追加されてしまうことはありませんが(たとえば、サードパーティのコードをAPIサーバーで実行することによって)、パッケージ(たとえば、Chart)またはその他のインストールバンドルには、多くの場合、CRDと新しいカスタムリソースのビジネスロジックを実装するサードパーティコードが入ったDeploymentが含まれます。</p>
<p>アグリゲートAPIサーバーのインストールすると、常に新しいDeploymentが付いてきます。</p>
<h3 id=ストレージ>ストレージ</h3>
<p>カスタムリソースは、ConfigMapと同じ方法でストレージの容量を消費します。多数のカスタムリソースを作成すると、APIサーバーのストレージ容量を超えてしまうかもしれません。</p>
<p>アグリゲートAPIサーバーも、メインのAPIサーバーと同じストレージを利用するかもしれません。その場合、同じ問題が発生しえます。</p>
<h3 id=認証-認可-そして監査>認証、認可、そして監査</h3>
<p>CRDでは、APIサーバーのビルトインリソースと同じ認証、認可、そして監査ロギングの仕組みを利用します。</p>
<p>もしRBACを使っている場合、ほとんどのRBACのロールは新しいリソースへのアクセスを許可しません。(クラスター管理者ロール、もしくはワイルドカードで作成されたロールを除く)新しいリソースには、明示的にアクセスを許可する必要があります。多くの場合、CRDおよびアグリゲートAPIには、追加するタイプの新しいロール定義がバンドルされています。</p>
<p>アグリゲートAPIサーバーでは、APIサーバーのビルトインリソースと同じ認証、認可、そして監査の仕組みを使う場合と使わない場合があります。</p>
<h2 id=カスタムリソースへのアクセス>カスタムリソースへのアクセス</h2>
<p>Kubernetesの<a href=/docs/reference/using-api/client-libraries/>クライアントライブラリー</a>を使い、カスタムリソースにアクセスすることが可能です。全てのクライアントライブラリーがカスタムリソースをサポートしているわけでは無いですが、<em>Go</em> と <em>Python</em> のライブラリーはサポートしています。</p>
<p>カスタムリソースは、下記のような方法で操作できます:</p>
<ul>
<li><code>kubectl</code></li>
<li>kubernetesの動的クライアント</li>
<li>自作のRESTクライアント</li>
<li><a href=https://github.com/kubernetes/code-generator>Kubernetesクライアント生成ツール</a>を使い生成したクライアント(生成は高度な作業ですが、一部のプロジェクトは、CRDまたはAAとともにクライアントを提供する場合があります)</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Kubernetes APIをアグリゲーションレイヤーで拡張する方法</a>について学ぶ</li>
<li><a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>Kubernetes APIをCustomResourceDefinitionで拡張する方法</a>について学ぶ</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1ea4977c0ebf97569bf54a477faa7fa5>3.12.2.2 - アグリゲーションレイヤーを使ったKubernetes APIの拡張</h1>
<p>アグリゲーションレイヤーを使用すると、KubernetesのコアAPIで提供されている機能を超えて、追加のAPIでKubernetesを拡張できます。追加のAPIは、<a href=/docs/concepts/extend-kubernetes/service-catalog/>service-catalog</a>のような既製のソリューション、または自分で開発したAPIのいずれかです。</p>
<p>アグリゲーションレイヤーは、<a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>とは異なり、<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a>に新しい種類のオブジェクトを認識させる方法です。</p>
<h2 id=アグリゲーションレイヤー>アグリゲーションレイヤー</h2>
<p>アグリゲーションレイヤーは、kube-apiserverのプロセス内で動きます。拡張リソースが登録されるまでは、アグリゲーションレイヤーは何もしません。APIを登録するには、ユーザーはKubernetes APIで使われるURLのパスを"要求"した、<em>APIService</em> オブジェクトを追加します。それを追加すると、アグリゲーションレイヤーはAPIパス(例、<code>/apis/myextension.mycompany.io/v1/…</code>)への全てのアクセスを、登録されたAPIServiceにプロキシーします。</p>
<p>APIServiceを実装する最も一般的な方法は、クラスター内で実行されるPodで<em>拡張APIサーバー</em> を実行することです。クラスター内のリソース管理に拡張APIサーバーを使用している場合、拡張APIサーバー("extension-apiserver"とも呼ばれます)は通常、1つ以上の<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>とペアになっています。apiserver-builderライブラリは、拡張APIサーバーと関連するコントローラーの両方にスケルトンを提供します。</p>
<h3 id=応答遅延>応答遅延</h3>
<p>拡張APIサーバーは、kube-apiserverとの間の低遅延ネットワーキングが必要です。
kube-apiserverとの間を5秒以内に往復するためには、ディスカバリーリクエストが必要です。</p>
<p>拡張APIサーバーがそのレイテンシ要件を達成できない場合は、その要件を満たすように変更することを検討してください。また、kube-apiserverで<code>EnableAggregatedDiscoveryTimeout=false</code> <a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を設定することで、タイムアウト制限を無効にすることができます。この非推奨のフィーチャーゲートは将来のリリースで削除される予定です。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>アグリゲーターをあなたの環境で動かすには、まず<a href=/docs/tasks/extend-kubernetes/configure-aggregation-layer/>アグリゲーションレイヤーを設定</a>します</li>
<li>そして、アグリゲーションレイヤーと一緒に動作させるために<a href=/docs/tasks/extend-kubernetes/setup-extension-api-server/>extension api-serverをセットアップ</a>します</li>
<li>また、<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>Custom Resource Definitionを使いKubernetes APIを拡張する</a>方法を学んで下さい</li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#apiservice-v1-apiregistration-k8s-io>APIService</a>の仕様をお読み下さい</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3131452556176159fb269593c1a52012>3.12.3 - オペレーターパターン</h1>
<p>オペレーターは<a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>カスタムリソース</a>を使用するKubernetesへのソフトウェア拡張です。
オペレーターは、特に<a href=/ja/docs/concepts/#kubernetes-control-plane>制御ループ</a>のようなKubernetesが持つ仕組みに準拠しています。</p>
<h2 id=モチベーション>モチベーション</h2>
<p>オペレーターパターンはサービス、またはサービス群を管理している運用担当者の主な目的をキャプチャすることが目標です。
特定のアプリケーション、サービスの面倒を見ている運用担当者は、システムがどのように振る舞うべきか、どのようにデプロイをするか、何らかの問題があったときにどのように対応するかについて深い知識を持っています。</p>
<p>Kubernetes上でワークロードを稼働させている人は、しばしば繰り返し可能なタスクを自動化することを好みます。
オペレーターパターンは、Kubernetes自身が提供している機能を超えて、あなたがタスクを自動化するために、どのようにコードを書くかをキャプチャします。</p>
<h2 id=kubernetesにおけるオペレーター>Kubernetesにおけるオペレーター</h2>
<p>Kubernetesは自動化のために設計されています。追加の作業、設定無しに、Kubernetesのコア機能によって多数のビルトインされた自動化機能が提供されます。
ワークロードのデプロイおよび稼働を自動化するためにKubernetesを使うことができます。 <em>さらに</em> Kubernetesがそれをどのように行うかの自動化も可能です。</p>
<p>Kubernetesの<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>コンセプトは、Kubernetesのソースコードを修正すること無く、クラスターの振る舞いを拡張することを可能にします。
オペレーターはKubernetes APIのクライアントで、<a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Custom Resource</a>にとっての、コントローラーのように振る舞います。</p>
<h2 id=example>オペレーターの例</h2>
<p>オペレーターを使い自動化できるいくつかのことは、下記のようなものがあります:</p>
<ul>
<li>必要に応じてアプリケーションをデプロイする</li>
<li>アプリケーションの状態のバックアップを取得、リストアする</li>
<li>アプリケーションコードの更新と同時に、例えばデータベーススキーマ、追加の設定修正など必要な変更の対応を行う</li>
<li>Kubernetes APIをサポートしていないアプリケーションに、サービスを公開してそれらを発見する</li>
<li>クラスターの回復力をテストするために、全て、または一部分の障害をシミュレートする</li>
<li>内部のリーダー選出プロセス無しに、分散アプリケーションのリーダーを選択する</li>
</ul>
<p>オペレーターをもっと詳しく見るとどのように見えるでしょうか？より詳細な例を示します:</p>
<ol>
<li>クラスターに設定可能なSampleDBという名前のカスタムリソース</li>
<li>オペレーターの、コントローラー部分を含むPodが実行されていることを保証するDeployment</li>
<li>オペレーターのコードを含んだコンテナイメージ</li>
<li>設定されているSampleDBのリソースを見つけるために、コントロールプレーンに問い合わせるコントローラーのコード</li>
<li>オペレーターのコアは、現実を、設定されているリソースにどのように合わせるかをAPIサーバーに伝えるコードです。
<ul>
<li>もし新しいSampleDBを追加した場合、オペレーターは永続化データベースストレージを提供するためにPersistentVolumeClaimsをセットアップし、StatefulSetがSampleDBの起動と、初期設定を担うJobを走らせます</li>
<li>もしそれを削除した場合、オペレーターはスナップショットを取り、StatefulSetとVolumeも合わせて削除されたことを確認します</li>
</ul>
</li>
<li>オペレーターは定期的なデータベースのバックアップも管理します。それぞれのSampleDBリソースについて、オペレーターはデータベースに接続可能な、バックアップを取得するPodをいつ作成するかを決定します。これらのPodはデータベース接続の詳細情報、クレデンシャルを保持するConfigMapとSecret、もしくはどちらかに依存するでしょう。</li>
<li>オペレーターは、管理下のリソースの堅牢な自動化を提供することを目的としているため、補助的な追加コードが必要になるかもしれません。この例では、データベースが古いバージョンで動いているかどうかを確認するコードで、その場合、アップグレードを行うJobをあなたに代わり作成します。</li>
</ol>
<h2 id=オペレーターのデプロイ>オペレーターのデプロイ</h2>
<p>オペレーターをデプロイする最も一般的な方法は、Custom Resource Definitionとそれに関連するコントローラーをクラスターに追加することです。
このコントローラーは通常、あなたがコンテナアプリケーションを動かすのと同じように、<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>外で動作します。</p>
<p>例えば、コントローラーをDeploymentとしてクラスター内で動かすことができます。</p>
<h2 id=using-operators>オペレーターを利用する</h2>
<p>一度オペレーターをデプロイすると、そのオペレーターを使って、それ自身が使うリソースの種類を追加、変更、または削除できます。
上記の利用例に従ってオペレーターそのもののためのDeploymentをセットアップし、以下のようなコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get SampleDB                   <span style=color:#080;font-style:italic># 設定したデータベースを発見します</span>

kubectl edit SampleDB/example-database <span style=color:#080;font-style:italic># 手動でいくつかの設定を変更します</span>
</code></pre></div><p>これだけです！オペレーターが変更の適用だけでなく既存のサービスがうまく稼働し続けるように面倒を見てくれます。</p>
<h2 id=writing-operator>自分でオペレーターを書く</h2>
<p>必要な振る舞いを実装したオペレーターがエコシステム内に無い場合、自分で作成することができます。
<a href=#whats-next>次の項目</a>で、自分でクラウドネイティブオペレーターを作るときに利用できるライブラリやツールのリンクを見つけることができます。</p>
<p>オペレーター（すなわち、コントローラー）はどの言語/ランタイムでも実装でき、<a href=/docs/reference/using-api/client-libraries/>Kubernetes APIのクライアント</a>として機能させることができます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Custom Resources</a>をより深く学びます</li>
<li>ユースケースに合わせた、既製のオペレーターを<a href=https://operatorhub.io/>OperatorHub.io</a>から見つけます</li>
<li>自前のオペレーターを書くために既存のツールを使います、例:
<ul>
<li><a href=https://juju.is/>Charmed Operator Framework</a></li>
<li><a href=https://kudo.dev/>KUDO</a>（Kubernetes Universal Declarative Operator）を使います</li>
<li><a href=https://book.kubebuilder.io/>kubebuilder</a>を使います</li>
<li><a href=https://buehler.github.io/dotnet-operator-sdk/>KubeOps</a> (dotnet operator SDK)</li>
<li><a href=https://metacontroller.github.io/metacontroller/intro.html>Metacontroller</a>を自分で実装したWebHooksと一緒に使います</li>
<li><a href=https://operatorframework.io>Operator Framework</a>を使います</li>
<li><a href=https://github.com/flant/shell-operator>shell-operator</a></li>
</ul>
</li>
<li>自前のオペレーターを他のユーザーのために<a href=https://operatorhub.io/>公開</a>します</li>
<li>オペレーターパターンを紹介している<a href=https://coreos.com/blog/introducing-operators.html>CoreOSオリジナル記事</a>を読みます</li>
<li>Google Cloudが出したオペレーター作成のベストプラクティス<a href=https://cloud.google.com/blog/products/containers-kubernetes/best-practices-for-building-kubernetes-operators-and-stateful-apps>記事</a>を読みます</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f8918f697450c2009b75913f9e9317a5>4 - タスク</h1>
<p>Kubernetesドキュメントのこのセクションには、個々のタスクの実行方法を示すページが含まれています。タスクページは、通常、短い手順を実行することにより、1つのことを行う方法を示します。</p>
<p>タスクページを作成したい場合は、<a href=/docs/contribute/new-content/open-a-pr/>ドキュメントのPull Requestの作成</a>を参照してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-57bf66f59d9a642b82eebeabbc66470b>4.1 - ツールのインストール</h1>
<div class=lead>Kubernetesのツールをローカルのコンピュータ上にセットアップします。</div>
<h2 id=kubectl>kubectl</h2>
<p>Kubernetesのコマンドラインツール<code>kubectl</code>を使用すると、Kubernetesクラスターに対してコマンドを実行できるようになります。kubectlは、アプリケーションのデプロイ、クラスターリソースの調査と管理、ログの表示などに使用できます。</p>
<p><code>kubectl</code>のダウンロードとインストールを行い、クラスターへのアクセスをセットアップする方法については、<a href=/ja/docs/tasks/tools/install-kubectl/>kubectlのインストールおよびセットアップ</a>を参照してください。</p>
<p>また、<a href=/ja/docs/reference/kubectl/><code>kubectl</code>リファレンスドキュメント</a>も参照できます。</p>
<h2 id=minikube>Minikube</h2>
<p><a href=https://minikube.sigs.k8s.io/>Minikube</a>は、Kubernetesをローカルで実行するツールです。MinikubeはシングルノードのKubernetesクラスターをパーソナルコンピューター上(Windows、macOS、Linux PCを含む)で実行することで、Kubernetesを試したり、日常的な開発作業のために利用できます。</p>
<p>ツールのインストールについて知りたい場合は、公式の<a href=https://minikube.sigs.k8s.io/docs/start/>Get Started!</a>のガイドに従ってください。</p>
<p>Minikubeが起動したら、<a href=/ja/docs/tutorials/hello-minikube/>サンプルアプリケーションの実行</a>を試すことができます。</p>
<h2 id=kind>kind</h2>
<p>Minikubeと同じように、<a href=https://kind.sigs.k8s.io/docs/>kind</a>もローカルコンピューター上でKubernetesを実行するツールです。Minikubeとは違い、kindは1種類のコンテナランタイム上でしか動作しません。実行には<a href=https://docs.docker.com/get-docker/>Docker</a>のインストールと設定が必要です。</p>
<p><a href=https://kind.sigs.k8s.io/docs/user/quick-start/>Quick Start</a>に、kindの起動に必要な手順が説明されています。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bbdc530b292ab4074d1dfe69feafb3e7>4.1.1 - kubectlのインストールおよびセットアップ</h1>
<p>Kubernetesのコマンドラインツールである<a href=/ja/docs/reference/kubectl/overview/>kubectl</a>を使用して、Kubernetesクラスターに対してコマンドを実行することができます。kubectlによってアプリケーションのデプロイや、クラスターのリソース管理、検査およびログの表示を行うことができます。kubectlの操作に関する完全なリストは、<a href=/ja/docs/reference/kubectl/overview/>kubectlの概要</a>を参照してください。</p>
<h2 id=始める前に>始める前に</h2>
<p>kubectlのバージョンは、クラスターのマイナーバージョンとの差分が1つ以内でなければなりません。たとえば、クライアントがv1.2であれば、v1.1、v1.2、v1.3のマスターで動作するはずです。最新バージョンのkubectlを使うことで、不測の事態を避けることができるでしょう。</p>
<h2 id=install-kubectl-on-linux>Linuxへkubectlをインストールする</h2>
<h3 id=curlを使用してlinuxへkubectlのバイナリをインストールする>curlを使用してLinuxへkubectlのバイナリをインストールする</h3>
<ol>
<li>
<p>次のコマンドにより、最新リリースをダウンロードしてください:</p>
<pre><code>curl -LO &quot;https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl&quot;
</code></pre><p>特定のバージョンをダウンロードする場合、コマンドの<code>$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)</code>の部分を特定のバージョンに書き換えてください。</p>
<p>たとえば、Linuxへv1.22.16のバージョンをダウンロードするには、次のコマンドを入力します:</p>
<pre><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.22.16/bin/linux/amd64/kubectl
</code></pre></li>
<li>
<p>kubectlバイナリを実行可能にしてください。</p>
<pre><code>chmod +x ./kubectl
</code></pre></li>
<li>
<p>バイナリをPATHの中に移動させてください。</p>
<pre><code>sudo mv ./kubectl /usr/local/bin/kubectl
</code></pre></li>
<li>
<p>インストールしたバージョンが最新であることを確認してください:</p>
<pre><code>kubectl version --client
</code></pre></li>
</ol>
<h3 id=ネイティブなパッケージマネージャーを使用してインストールする>ネイティブなパッケージマネージャーを使用してインストールする</h3>
<ul class="nav nav-tabs" id=kubectl-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-install-0 role=tab aria-controls=kubectl-install-0 aria-selected=true>Ubuntu、DebianまたはHypriotOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-install-1 role=tab aria-controls=kubectl-install-1>CentOS、RHELまたはFedora</a></li></ul>
<div class=tab-content id=kubectl-install><div id=kubectl-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-install-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
sudo apt-get update <span style=color:#666>&amp;&amp;</span> sudo apt-get install -y apt-transport-https gnupg2
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;deb https://apt.kubernetes.io/ kubernetes-xenial main&#34;</span> | sudo tee -a /etc/apt/sources.list.d/kubernetes.list
sudo apt-get update
sudo apt-get install -y kubectl
</code></pre></div></div>
<div id=kubectl-install-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-install-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#b44>&lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
</span><span style=color:#b44>[kubernetes]
</span><span style=color:#b44>name=Kubernetes
</span><span style=color:#b44>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
</span><span style=color:#b44>enabled=1
</span><span style=color:#b44>gpgcheck=1
</span><span style=color:#b44>repo_gpgcheck=1
</span><span style=color:#b44>gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</span><span style=color:#b44>EOF</span>
yum install -y kubectl
</code></pre></div></div></div>
<h3 id=他のパッケージマネージャーを使用してインストールする>他のパッケージマネージャーを使用してインストールする</h3>
<ul class="nav nav-tabs" id=other-kubectl-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#other-kubectl-install-0 role=tab aria-controls=other-kubectl-install-0 aria-selected=true>Snap</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#other-kubectl-install-1 role=tab aria-controls=other-kubectl-install-1>Homebrew</a></li></ul>
<div class=tab-content id=other-kubectl-install><div id=other-kubectl-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=other-kubectl-install-0>
<p><p>Ubuntuまたは<a href=https://snapcraft.io/docs/core/install>snap</a>パッケージマネージャーをサポートする別のLinuxディストリビューションを使用している場合、kubectlは<a href=https://snapcraft.io/>snap</a>アプリケーションとして使用できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>snap install kubectl --classic

kubectl version --client
</code></pre></div></div>
<div id=other-kubectl-install-1 class=tab-pane role=tabpanel aria-labelledby=other-kubectl-install-1>
<p><p>Linuxで<a href=https://docs.brew.sh/Homebrew-on-Linux>Homebrew</a>パッケージマネージャーを使用している場合は、kubectlを<a href=https://docs.brew.sh/Homebrew-on-Linux#install>インストール</a>することが可能です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>brew install kubectl

kubectl version --client
</code></pre></div></div></div>
<h2 id=install-kubectl-on-macos>macOSへkubectlをインストールする</h2>
<h3 id=curlを使用してmacosへkubectlのバイナリをインストールする>curlを使用してmacOSへkubectlのバイナリをインストールする</h3>
<ol>
<li>
<p>最新リリースをダウンロードしてください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -LO <span style=color:#b44>&#34;https://storage.googleapis.com/kubernetes-release/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/amd64/kubectl&#34;</span>
</code></pre></div><p>特定のバージョンをダウンロードする場合、コマンドの<code>$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)</code>の部分を特定のバージョンに書き換えてください。</p>
<p>たとえば、macOSへv1.22.16のバージョンをダウンロードするには、次のコマンドを入力します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash> curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.22.16/bin/darwin/amd64/kubectl
</code></pre></div></li>
<li>
<p>kubectlバイナリを実行可能にしてください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>chmod +x ./kubectl
</code></pre></div></li>
<li>
<p>バイナリをPATHの中に移動させてください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo mv ./kubectl /usr/local/bin/kubectl
</code></pre></div></li>
<li>
<p>インストールしたバージョンが最新であることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl version --client
</code></pre></div></li>
</ol>
<h3 id=homebrewを使用してmacosへインストールする>Homebrewを使用してmacOSへインストールする</h3>
<p>macOSで<a href=https://brew.sh/>Homebrew</a>パッケージマネージャーを使用していれば、Homebrewでkubectlをインストールすることもできます。</p>
<ol>
<li>
<p>インストールコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install kubectl
</code></pre></div><p>または</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install kubernetes-cli
</code></pre></div></li>
<li>
<p>インストールしたバージョンが最新であることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl version --client
</code></pre></div></li>
</ol>
<h3 id=macportsを使用してmacosへインストールする>MacPortsを使用してmacOSへインストールする</h3>
<p>macOSで<a href=https://macports.org/>MacPorts</a>パッケージマネージャーを使用していれば、MacPortsでkubectlをインストールすることもできます。</p>
<ol>
<li>
<p>インストールコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo port selfupdate
sudo port install kubectl
</code></pre></div></li>
<li>
<p>インストールしたバージョンが最新であることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl version --client
</code></pre></div></li>
</ol>
<h2 id=install-kubectl-on-windows>Windowsへkubectlをインストールする</h2>
<h3 id=curlを使用してwindowsへkubectlのバイナリをインストールする>curlを使用してWindowsへkubectlのバイナリをインストールする</h3>
<ol>
<li>
<p><a href=https://storage.googleapis.com/kubernetes-release/release/v1.22.16/bin/windows/amd64/kubectl.exe>こちらのリンク</a>から、最新リリースであるv1.22.16をダウンロードしてください。</p>
<p>または、<code>curl</code>をインストールされていれば、次のコマンドも使用できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.22.16/bin/windows/amd64/kubectl.exe
</code></pre></div><p>最新の安定版を入手する際は(たとえばスクリプトで使用する場合)、<a href=https://storage.googleapis.com/kubernetes-release/release/stable.txt>https://storage.googleapis.com/kubernetes-release/release/stable.txt</a>を参照してください。</p>
</li>
<li>
<p>バイナリをPATHに追加します</p>
</li>
<li>
<p><code>kubectl</code>のバージョンがダウンロードしたものと同じであることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl version --client
</code></pre></div></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <a href=https://docs.docker.com/docker-for-windows/#kubernetes>Docker Desktop for Windows</a>は、それ自身のバージョンの<code>kubectl</code>をPATHに追加します。Docker Desktopをすでにインストールしている場合、Docker Desktopインストーラーによって追加されたPATHの前に追加するか、Docker Desktopの<code>kubectl</code>を削除してください。
</div>
<h3 id=psgalleryからpowershellを使用してインストールする>PSGalleryからPowerShellを使用してインストールする</h3>
<p>Windowsで<a href=https://www.powershellgallery.com/>Powershell Gallery</a>パッケージマネージャーを使用していれば、Powershellでkubectlをインストールおよびアップデートすることもできます。</p>
<ol>
<li>
<p>インストールコマンドを実行してください(必ず<code>DownloadLocation</code>を指定してください):</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>Install-Script</span> -Name <span style=color:#b44>&#39;install-kubectl&#39;</span> -Scope CurrentUser -Force
<span style=color:#a2f>install-kubectl</span>.ps1 [-DownloadLocation &lt;path&gt;]
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>DownloadLocation</code>を指定しない場合、<code>kubectl</code>はユーザのTempディレクトリにインストールされます。
</div>
<p>インストーラーは<code>$HOME/.kube</code>を作成し、設定ファイルを作成します。</p>
</li>
<li>
<p>インストールしたバージョンが最新であることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>kubectl version --client
</code></pre></div></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> アップデートする際は、手順1に示した2つのコマンドを再実行してください。
</div>
<h3 id=chocolateyまたはscoopを使用してwindowsへインストールする>ChocolateyまたはScoopを使用してWindowsへインストールする</h3>
<ol>
<li>
<p>Windowsへkubectlをインストールするために、<a href=https://chocolatey.org>Chocolatey</a>パッケージマネージャーや<a href=https://scoop.sh>Scoop</a>コマンドラインインストーラーを使用することもできます。</p>
<ul class="nav nav-tabs" id=kubectl-win-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-win-install-0 role=tab aria-controls=kubectl-win-install-0 aria-selected=true>choco</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-win-install-1 role=tab aria-controls=kubectl-win-install-1>scoop</a></li></ul>
<div class=tab-content id=kubectl-win-install><div id=kubectl-win-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-win-install-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>choco install <span style=color:#a2f>kubernetes-cli</span>
</code></pre></div></div>
<div id=kubectl-win-install-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-win-install-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>scoop install kubectl
</code></pre></div></div></div>
</li>
<li>
<p>インストールしたバージョンが最新であることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>kubectl version --client
</code></pre></div></li>
<li>
<p>ホームディレクトリへ移動してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#080;font-style:italic># cmd.exeを使用している場合は cd %USERPROFILE% を実行してください。</span>
<span style=color:#a2f>cd </span>~
</code></pre></div></li>
<li>
<p><code>.kube</code>ディレクトリを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>mkdir .kube
</code></pre></div></li>
<li>
<p>作成した<code>.kube</code>ディレクトリへ移動してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>cd </span>.kube
</code></pre></div></li>
<li>
<p>リモートのKubernetesクラスターを使うために、kubectlを設定してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>New-Item</span> config -type file
</code></pre></div></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Notepadなどの選択したテキストエディターから設定ファイルを編集してください。
</div>
<h2 id=google-cloud-sdkの一部としてダウンロードする>Google Cloud SDKの一部としてダウンロードする</h2>
<p>Google Cloud SDKの一部として、kubectlをインストールすることもできます。</p>
<ol>
<li>
<p><a href=https://cloud.google.com/sdk/>Google Cloud SDK</a>をインストールしてください。</p>
</li>
<li>
<p><code>kubectl</code>のインストールコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>gcloud components install kubectl
</code></pre></div></li>
<li>
<p>インストールしたバージョンが最新であることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl version --client
</code></pre></div></li>
</ol>
<h2 id=kubectlの設定を検証する>kubectlの設定を検証する</h2>
<p>kubectlがKubernetesクラスターを探索し接続するために、<a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfigファイル</a>が必要になります。これは、<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh>kube-up.sh</a>によりクラスターを作成した際や、Minikubeクラスターを正常にデプロイした際に自動生成されます。デフォルトでは、kubectlの設定は<code>~/.kube/config</code>に格納されています。</p>
<p>クラスターの状態を取得し、kubectlが適切に設定されていることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info
</code></pre></div><p>URLのレスポンスが表示されている場合は、kubectlはクラスターに接続するよう正しく設定されています。</p>
<p>以下のようなメッセージが表示されている場合は、kubectlは正しく設定されていないか、Kubernetesクラスターに接続できていません。</p>
<pre><code>The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?
</code></pre><p>たとえば、ラップトップ上(ローカル環境)でKubernetesクラスターを起動するような場合、Minikubeなどのツールを最初にインストールしてから、上記のコマンドを再実行する必要があります。</p>
<p>kubectl cluster-infoがURLレスポンスを返したにもかかわらずクラスターにアクセスできない場合は、次のコマンドで設定が正しいことを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info dump
</code></pre></div><h2 id=kubectlの任意の設定>kubectlの任意の設定</h2>
<h3 id=シェルの自動補完を有効にする>シェルの自動補完を有効にする</h3>
<p>kubectlはBashおよびZshの自動補完を提供しています。これにより、入力を大幅に削減することができます。</p>
<p>以下にBash(LinuxとmacOSの違いも含む)およびZshの自動補完の設定手順を示します。</p>
<ul class="nav nav-tabs" id=kubectl-autocompletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-autocompletion-0 role=tab aria-controls=kubectl-autocompletion-0 aria-selected=true>LinuxでのBash</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-1 role=tab aria-controls=kubectl-autocompletion-1>macOSでのBash</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-2 role=tab aria-controls=kubectl-autocompletion-2>Zsh</a></li></ul>
<div class=tab-content id=kubectl-autocompletion><div id=kubectl-autocompletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-autocompletion-0>
<p><h3 id=はじめに>はじめに</h3>
<p>Bashにおけるkubectlの補完スクリプトは<code>kubectl completion bash</code>コマンドで生成できます。シェル内で補完スクリプトをsourceすることでkubectlの自動補完が有効になります。</p>
<p>ただし、補完スクリプトは<a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>に依存しているため、このソフトウェアを最初にインストールしておく必要があります(<code>type _init_completion</code>を実行することで、bash-completionがすでにインストールされていることを確認できます)。</p>
<h3 id=bash-completionをインストールする>bash-completionをインストールする</h3>
<p>bash-completionは多くのパッケージマネージャーから提供されています(<a href=https://github.com/scop/bash-completion#installation>こちら</a>を参照してください)。<code>apt-get install bash-completion</code>または<code>yum install bash-completion</code>などでインストールできます。</p>
<p>上記のコマンドでbash-completionの主要スクリプトである<code>/usr/share/bash-completion/bash_completion</code>が作成されます。パッケージマネージャーによっては、このファイルを<code>~/.bashrc</code>にて手動でsourceする必要があります。</p>
<p>これを調べるには、シェルをリロードしてから<code>type _init_completion</code>を実行してください。コマンドが成功していればすでに設定済みです。そうでなければ、<code>~/.bashrc</code>に以下を追記してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> /usr/share/bash-completion/bash_completion
</code></pre></div><p>シェルをリロードし、<code>type _init_completion</code>を実行してbash-completionが正しくインストールされていることを検証してください。</p>
<h3 id=kubectlの自動補完を有効にする>kubectlの自動補完を有効にする</h3>
<p>すべてのシェルセッションにてkubectlの補完スクリプトをsourceできるようにしなければなりません。これを行うには2つの方法があります:</p>
<ul>
<li>
<p>補完スクリプトを<code>~/.bashrc</code>内でsourceしてください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bashrc
</code></pre></div></li>
<li>
<p>補完スクリプトを<code>/etc/bash_completion.d</code>ディレクトリに追加してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl completion bash &gt;/etc/bash_completion.d/kubectl
</code></pre></div></li>
<li>
<p>kubectlにエイリアスを張っている場合は、以下のようにシェルの補完を拡張して使うことができます:</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bashrc
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -F __start_kubectl k&#39;</span> &gt;&gt;~/.bashrc
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> bash-completionは<code>/etc/bash_completion.d</code>内のすべての補完スクリプトをsourceします。
</div>
<p>どちらも同様の手法です。シェルをリロードしたあとに、kubectlの自動補完が機能するはずです。</p>
</div>
<div id=kubectl-autocompletion-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-1>
<p><h3 id=はじめに>はじめに</h3>
<p>Bashにおけるkubectlの補完スクリプトは<code>kubectl completion bash</code>コマンドで生成できます。シェル内で補完スクリプトをsourceすることでkubectlの自動補完が有効になります。</p>
<p>ただし、補完スクリプトは<a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>に依存しているため、事前にインストールする必要があります。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> bash-completionにはv1とv2のバージョンがあり、v1はBash 3.2(macOSのデフォルト)用で、v2はBash 4.1以降向けです。kubectlの補完スクリプトはbash-completionのv1とBash 3.2では正しく<strong>動作しません</strong>。<strong>bash-completion v2</strong>および<strong>Bash 4.1</strong>が必要になります。したがって、macOSで正常にkubectlの補完を使用するには、Bash 4.1以降をインストールする必要があります(<a href=https://itnext.io/upgrading-bash-on-macos-7138bd1066ba><em>手順</em></a>)。以下の手順では、Bash4.1以降(Bashのバージョンが4.1またはそれより新しいことを指します)を使用することを前提とします。
</div>
<h3 id=bashのアップグレード>bashのアップグレード</h3>
<p>ここではBash 4.1以降の使用を前提としています。Bashのバージョンは下記のコマンドで調べることができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b8860b>$BASH_VERSION</span>
</code></pre></div><p>バージョンが古い場合、Homebrewを使用してインストールもしくはアップグレードできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install bash
</code></pre></div><p>シェルをリロードし、希望するバージョンを使用していることを確認してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b8860b>$BASH_VERSION</span> <span style=color:#b8860b>$SHELL</span>
</code></pre></div><p>Homebrewは通常、<code>/usr/local/bin/bash</code>にインストールします。</p>
<h3 id=bash-completionをインストールする>bash-completionをインストールする</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 前述のとおり、この手順ではBash 4.1以降であることが前提のため、bash-completion v2をインストールすることになります(これとは逆に、Bash 3.2およびbash-completion v1の場合ではkubectlの補完は動作しません)。
</div>
<p><code>type _init_completion</code>を実行することで、bash-completionがすでにインストールされていることを確認できます。ない場合は、Homebrewを使用してインストールすることもできます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install bash-completion@2
</code></pre></div><p>このコマンドの出力で示されたように、<code>~/.bash_profile</code>に以下を追記してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>export</span> <span style=color:#b8860b>BASH_COMPLETION_COMPAT_DIR</span><span style=color:#666>=</span><span style=color:#b44>&#34;/usr/local/etc/bash_completion.d&#34;</span>
<span style=color:#666>[[</span> -r <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span> <span style=color:#666>]]</span> <span style=color:#666>&amp;&amp;</span> . <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span>
</code></pre></div><p>シェルをリロードし、<code>type _init_completion</code>を実行してbash-completion v2が正しくインストールされていることを検証してください。</p>
<h3 id=kubectlの自動補完を有効にする>kubectlの自動補完を有効にする</h3>
<p>すべてのシェルセッションにてkubectlの補完スクリプトをsourceできるようにしなければなりません。これを行うには複数の方法があります:</p>
<ul>
<li>
<p>補完スクリプトを<code>~/.bash_profile</code>内でsourceする:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bash_profile
</code></pre></div></li>
<li>
<p>補完スクリプトを<code>/usr/local/etc/bash_completion.d</code>ディレクトリに追加する:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl completion bash &gt;/usr/local/etc/bash_completion.d/kubectl
</code></pre></div></li>
<li>
<p>kubectlにエイリアスを張っている場合は、以下のようにシェルの補完を拡張して使うことができます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bash_profile
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -F __start_kubectl k&#39;</span> &gt;&gt;~/.bash_profile
</code></pre></div></li>
<li>
<p>kubectlをHomwbrewでインストールした場合(<a href=#homebrew%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6macos%E3%81%B8%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B>前述</a>のとおり)、kubectlの補完スクリプトはすでに<code>/usr/local/etc/bash_completion.d/kubectl</code>に格納されているでしょう。この場合、なにも操作する必要はありません。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Homebrewでインストールしたbash-completion v2は<code>BASH_COMPLETION_COMPAT_DIR</code>ディレクトリ内のすべてのファイルをsourceするため、後者の2つの方法が機能します。
</li>
</ul>
</div>
<p>どの場合でも、シェルをリロードしたあとに、kubectlの自動補完が機能するはずです。</p>
</div>
<div id=kubectl-autocompletion-2 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-2>
<p><p>Zshにおけるkubectlの補完スクリプトは<code>kubectl completion zsh</code>コマンドで生成できます。シェル内で補完スクリプトをsourceすることでkubectlの自動補完が有効になります。</p>
<p>すべてのシェルセッションで使用するには、<code>~/.zshrc</code>に以下を追記してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>
</code></pre></div><p>kubectlにエイリアスを張っている場合は、以下のようにシェルの補完を拡張して使うことができます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.zshrc
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;compdef __start_kubectl k&#39;</span> &gt;&gt;~/.zshrc
</code></pre></div><p>シェルをリロードしたあとに、kubectlの自動補完が機能するはずです。</p>
<p><code>complete:13: command not found: compdef</code>のようなエラーが出力された場合は、以下を<code>~/.zshrc</code>の先頭に追記してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>autoload -Uz compinit
compinit
</code></pre></div></div></div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=https://minikube.sigs.k8s.io/docs/start/>Minikubeをインストールする</a></li>
<li>クラスターの作成に関する詳細を<a href=/ja/docs/setup/>スタートガイド</a>で確認する</li>
<li><a href=/ja/docs/tasks/access-application-cluster/service-access-application-cluster/>アプリケーションを起動して公開する方法を学ぶ</a></li>
<li>あなたが作成していないクラスターにアクセスする必要がある場合は、<a href=/ja/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>クラスターアクセスドキュメントの共有</a>を参照してください</li>
<li><a href=/docs/reference/kubectl/kubectl/>kubectlリファレンスドキュメント</a>を参照する</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5da33b976758a9183018c421eb83f58>4.2 - Podとコンテナの設定</h1>
<div class=lead>Podとコンテナの一般的な設定のタスクを行います。</div>
</div>
<div class=td-content>
<h1 id=pg-e6dd9300cf3a955f7cdfe77fb5d15292>4.2.1 - コンテナおよびPodへのメモリーリソースの割り当て</h1>
<p>このページでは、メモリーの <em>要求</em> と <em>制限</em> をコンテナに割り当てる方法について示します。コンテナは要求されたメモリーを確保することを保証しますが、その制限を超えるメモリーの使用は許可されません。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>クラスターの各ノードには、少なくとも300MiBのメモリーが必要になります。</p>
<p>このページのいくつかの手順では、クラスターにて<a href=https://github.com/kubernetes-incubator/metrics-server>metrics-server</a>サービスを実行する必要があります。すでにmetrics-serverが動作している場合、これらの手順をスキップできます。</p>
<p>Minikubeを動作させている場合、以下のコマンドによりmetrics-serverを有効にできます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube addons <span style=color:#a2f>enable</span> metrics-server
</code></pre></div><p>metrics-serverが実行されているか、もしくはリソースメトリクスAPI (<code>metrics.k8s.io</code>) の別のプロバイダが実行されていることを確認するには、以下のコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get apiservices
</code></pre></div><p>リソースメトリクスAPIが利用可能であれば、出力には <code>metrics.k8s.io</code> への参照が含まれます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME
v1beta1.metrics.k8s.io
</code></pre></div>
<h2 id=namespaceの作成>namespaceの作成</h2>
<p>この練習で作成するリソースがクラスター内で分離されるよう、namespaceを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace mem-example
</code></pre></div><h2 id=メモリーの要求と制限を指定する>メモリーの要求と制限を指定する</h2>
<p>コンテナにメモリーの要求を指定するには、コンテナのリソースマニフェストに<code>resources:requests</code>フィールドを追記します。メモリーの制限を指定するには、<code>resources:limits</code>を追記します。</p>
<p>この練習では、一つのコンテナをもつPodを作成します。コンテナに100MiBのメモリー要求と200MiBのメモリー制限を与えます。Podの設定ファイルは次のようになります:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/resource/memory-request-limit.yaml download=pods/resource/memory-request-limit.yaml><code>pods/resource/memory-request-limit.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-memory-request-limit-yaml')" title="Copy pods/resource/memory-request-limit.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-memory-request-limit-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルの<code>args</code>セクションでは、コンテナ起動時の引数を与えます。<code>"--vm-bytes", "150M"</code>という引数では、コンテナに150MiBのメモリーを割り当てます。</p>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit.yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>Podのコンテナが起動していることを検証してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>Podの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>この出力では、Pod内の一つのコンテナに100MiBのメモリー要求と200MiBのメモリー制限があることを示しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p><code>kubectl top</code>を実行し、Podのメトリクスを取得してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl top pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>この出力では、Podが約162,900,000バイト(約150MiB)のメモリーを使用していることを示しています。Podの100MiBの要求を超えていますが、200MiBの制限には収まっています。</p>
<pre><code>NAME                        CPU(cores)   MEMORY(bytes)
memory-demo                 &lt;something&gt;  162856960
</code></pre><p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><h2 id=コンテナのメモリー制限を超える>コンテナのメモリー制限を超える</h2>
<p>ノードに利用可能なメモリーがある場合、コンテナはメモリー要求を超えることができます。しかしながら、メモリー制限を超えて使用することは許可されません。コンテナが制限を超えてメモリーを確保しようとした場合、そのコンテナは終了候補となります。コンテナが制限を超えてメモリーを消費し続ける場合、コンテナは終了されます。終了したコンテナを再起動できる場合、ほかのランタイムの失敗時と同様に、kubeletがコンテナを再起動させます。</p>
<p>この練習では、制限を超えてメモリーを確保しようとするPodを作成します。以下に50MiBのメモリー要求と100MiBのメモリー制限を与えたコンテナを持つ、Podの設定ファイルを示します:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/resource/memory-request-limit-2.yaml download=pods/resource/memory-request-limit-2.yaml><code>pods/resource/memory-request-limit-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-memory-request-limit-2-yaml')" title="Copy pods/resource/memory-request-limit-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-memory-request-limit-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;250M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルの<code>args</code>セクションでは、コンテナに250MiBのメモリーを割り当てており、これは100MiBの制限を十分に超えています。</p>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-2.yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>Podの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>この時点で、コンテナは起動中か強制終了されているでしょう。コンテナが強制終了されるまで上記のコマンドをくり返し実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME            READY     STATUS      RESTARTS   AGE
memory-demo-2   0/1       OOMKilled   <span style=color:#666>1</span>          24s
</code></pre></div><p>コンテナステータスの詳細な情報を取得してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-2 --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>この出力では、コンテナがメモリー不足 (OOM) により強制終了されたことを示しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>lastState:
   terminated:
     containerID: docker://65183c1877aaec2e8427bc95609cc52677a454b56fcb24340dbd22917c23b10f
     exitCode: <span style=color:#666>137</span>
     finishedAt: 2017-06-20T20:52:19Z
     reason: OOMKilled
     startedAt: null
</code></pre></div><p>この練習のコンテナはkubeletによって再起動されます。次のコマンドを数回くり返し実行し、コンテナが強制終了と再起動を続けていることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>この出力では、コンテナが強制終了され、再起動され、再度強制終了および再起動が続いていることを示しています:</p>
<pre><code>kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS      RESTARTS   AGE
memory-demo-2   0/1       OOMKilled   1          37s
</code></pre><pre><code>
kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-2   1/1       Running   2          40s
</code></pre><p>Podの履歴について詳細な情報を確認してください:</p>
<pre><code>kubectl describe pod memory-demo-2 --namespace=mem-example
</code></pre><p>この出力では、コンテナの開始とその失敗が繰り返されていることを示しています:</p>
<pre><code>... Normal  Created   Created container with id 66a3a20aa7980e61be4922780bf9d24d1a1d8b7395c09861225b0eba1b1f8511
... Warning BackOff   Back-off restarting failed container
</code></pre><p>クラスターのノードの詳細な情報を確認してください:</p>
<pre><code>kubectl describe nodes
</code></pre><p>この出力には、メモリー不足の状態のためコンテナが強制終了された記録が含まれます:</p>
<pre><code>Warning OOMKilling Memory cgroup out of memory: Kill process 4481 (stress) score 1994 or sacrifice child
</code></pre><p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><h2 id=ノードよりも大きいメモリー要求を指定する>ノードよりも大きいメモリー要求を指定する</h2>
<p>メモリー要求と制限はコンテナと関連づけられていますが、Podにメモリー要求と制限が与えられていると考えるとわかりやすいでしょう。Podのメモリー要求は、Pod内のすべてのコンテナのメモリー要求の合計となります。同様に、Podのメモリー制限は、Pod内のすべてのコンテナのメモリー制限の合計となります。</p>
<p>Podのスケジューリングは要求に基づいています。Podはノード上で動作するうえで、そのメモリー要求に対してノードに十分利用可能なメモリーがある場合のみスケジュールされます。</p>
<p>この練習では、クラスター内のノードのキャパシティを超える大きさのメモリー要求を与えたPodを作成します。以下に1000GiBのメモリー要求を与えた一つのコンテナを持つ、Podの設定ファイルを示します。これは、クラスター内のノードのキャパシティを超える可能性があります。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/resource/memory-request-limit-3.yaml download=pods/resource/memory-request-limit-3.yaml><code>pods/resource/memory-request-limit-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-memory-request-limit-3-yaml')" title="Copy pods/resource/memory-request-limit-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-memory-request-limit-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-3.yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>Podの状態を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>この出力では、Podのステータスが待機中であることを示しています。つまり、Podがどのノードに対しても実行するようスケジュールされておらず、いつまでも待機状態のままであることを表しています:</p>
<pre><code>kubectl get pod memory-demo-3 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-3   0/1       Pending   0          25s
</code></pre><p>イベントを含むPodの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>この出力では、ノードのメモリー不足のためコンテナがスケジュールされないことを示しています:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Events:
  ...  Reason            Message
       ------            -------
  ...  FailedScheduling  No nodes are available that match all of the following predicates:: Insufficient memory <span style=color:#666>(</span>3<span style=color:#666>)</span>.
</code></pre></div><h2 id=メモリーの単位>メモリーの単位</h2>
<p>メモリーリソースはバイト単位で示されます。メモリーをE、P、T、G、M、K、Ei、Pi、Ti、Gi、Mi、Kiという接尾辞とともに、整数型または固定小数点整数で表現できます。たとえば、以下はおおよそ同じ値を表します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>128974848, 129e6, 129M , 123Mi
</code></pre></div><p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><h2 id=メモリー制限を指定しない場合>メモリー制限を指定しない場合</h2>
<p>コンテナのメモリー制限を指定しない場合、次のいずれかの状態となります:</p>
<ul>
<li>
<p>コンテナのメモリー使用量に上限がない状態となります。コンテナは実行中のノードで利用可能なすべてのメモリーを使用でき、その後OOM Killerが呼び出される可能性があります。さらに、OOM killの場合、リソース制限のないコンテナは強制終了される可能性が高くなります。</p>
</li>
<li>
<p>メモリー制限を与えられたnamespaceでコンテナを実行されると、コンテナにはデフォルトの制限値が自動的に指定されます。クラスターの管理者は<a href=/docs/reference/generated/kubernetes-api/v1.22/#limitrange-v1-core>LimitRange</a>によってメモリー制限のデフォルト値を指定できます。</p>
</li>
</ul>
<h2 id=メモリー要求と制限のモチベーション>メモリー要求と制限のモチベーション</h2>
<p>クラスターで動作するコンテナにメモリー要求と制限を設定することで、クラスターのノードで利用可能なメモリーリソースを効率的に使用することができます。Podのメモリー要求を低く保つことで、Podがスケジュールされやすくなります。メモリー要求よりも大きい制限を与えることで、次の2つを実現できます:</p>
<ul>
<li>Podは利用可能なメモリーを、突発的な活動(バースト)に使用することができます。</li>
<li>バースト中のPodのメモリー使用量は、適切な量に制限されます。</li>
</ul>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>namespaceを削除してください。これにより、今回のタスクで作成したすべてのPodが削除されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace mem-example
</code></pre></div><h2 id=次の項目>次の項目</h2>
<h3 id=アプリケーション開発者向け>アプリケーション開発者向け</h3>
<ul>
<li>
<p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>コンテナとPodにCPUリソースを割り当てる</a></p>
</li>
<li>
<p><a href=/docs/tasks/configure-pod-container/quality-service-pod/>PodのQuality of Serviceを設定する</a></p>
</li>
</ul>
<h3 id=クラスター管理者向け>クラスター管理者向け</h3>
<ul>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>Namespaceにメモリー要求および制限のデフォルト値を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>NamespaceにCPU要求および制限のデフォルト値を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>Namespaceに最小および最大メモリー量の制約を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>Namespaceに最小および最大のCPU使用量の制約を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>NamespaceにメモリーおよびCPUのクォータを設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>NamespaceにPodのクォータを設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/quota-api-object/>APIオブジェクトのクォータを設定する</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8555af270ae7122cc0464bab3f5d1609>4.2.2 - コンテナおよびPodへのCPUリソースの割り当て</h1>
<p>このページでは、CPUの <em>request</em> と <em>limit</em> をコンテナに割り当てる方法について示します。コンテナは設定された制限を超えてCPUを使用することはできません。システムにCPUの空き時間がある場合、コンテナには要求されたCPUを割り当てられます。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>タスク例を実行するには、クラスターに少なくとも利用可能な1 CPUが必要です。</p>
<p>このページのいくつかの手順では、クラスターにて<a href=https://github.com/kubernetes-incubator/metrics-server>metrics-server</a>サービスを実行する必要があります。すでにmetrics-serverが動作している場合、これらの手順をスキップできます。</p>
<p><a class=glossary-tooltip title="A tool for running Kubernetes locally." data-toggle=tooltip data-placement=top href=/docs/setup/learning-environment/minikube/ target=_blank aria-label=Minikube>Minikube</a>を動作させている場合、以下のコマンドによりmetrics-serverを有効にできます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube addons <span style=color:#a2f>enable</span> metrics-server
</code></pre></div><p>metrics-serverが実行されているか、もしくはリソースメトリクスAPI (<code>metrics.k8s.io</code>) の別のプロバイダーが実行されていることを確認するには、以下のコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get apiservices
</code></pre></div><p>リソースメトリクスAPIが利用可能であれば、出力には <code>metrics.k8s.io</code> への参照が含まれます。</p>
<pre><code>NAME
v1beta1.metrics.k8s.io
</code></pre>
<h2 id=namespaceの作成>namespaceの作成</h2>
<p>この練習で作成するリソースがクラスター内で分離されるよう、<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=Namespace>Namespace</a>を作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace cpu-example
</code></pre></div><h2 id=cpuの要求と制限を指定する>CPUの要求と制限を指定する</h2>
<p>コンテナにCPUの要求を指定するには、コンテナのリソースマニフェストに<code>resources:requests</code>フィールドを追記します。CPUの制限を指定するには、<code>resources:limits</code>を追記します。</p>
<p>この練習では、一つのコンテナをもつPodを作成します。コンテナに0.5 CPUの要求と1 CPUの制限を与えます。Podの設定ファイルは次のようになります:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/resource/cpu-request-limit.yaml download=pods/resource/cpu-request-limit.yaml><code>pods/resource/cpu-request-limit.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-cpu-request-limit-yaml')" title="Copy pods/resource/cpu-request-limit.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-cpu-request-limit-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cpu-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0.5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -cpus<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルの<code>args</code>セクションでは、コンテナ起動時の引数を与えます。<code>-cpus "2"</code>という引数では、コンテナに2 CPUを割り当てます。</p>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/cpu-request-limit.yaml --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><p>Podのコンテナが起動していることを検証してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><p>Podの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod cpu-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><p>この出力では、Pod内の一つのコンテナに500ミリCPUの要求と1 CPUの制限があることを示しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></code></pre></div><p><code>kubectl top</code>を実行し、Podのメトリクスを取得してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl top pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><p>この出力では、Podが974ミリCPUを使用していることを示しています。Podの設定で指定した1 CPUの制限よりわずかに小さい値です。</p>
<pre><code>NAME                        CPU(cores)   MEMORY(bytes)
cpu-demo                    974m         &lt;something&gt;
</code></pre><p><code>-cpu "2"</code>を設定することで、コンテナが2 CPU利用しようとすることを思い出してください。しかしながら、コンテナは約1 CPUしか使用することができません。コンテナが制限よりも多くのCPUリソースを利用しようとしているため、コンテナのCPUの利用が抑制されています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> CPUの使用量が1.0未満である理由の可能性して、ノードに利用可能なCPUリソースが十分にないことが挙げられます。この練習における必要条件として、クラスターに少なくとも利用可能な1 CPUが必要であることを思い出してください。1 CPUのノード上でコンテナを実行させる場合、指定したコンテナのCPU制限にかかわらず、コンテナは1 CPU以上使用することはできません。
</div>
<h2 id=cpuの単位>CPUの単位</h2>
<p>CPUリソースは <em>CPU</em> の単位で示されます。Kubernetesにおいて1つのCPUは次に等しくなります:</p>
<ul>
<li>1 AWS vCPU</li>
<li>1 GCPコア</li>
<li>1 Azure vCore</li>
<li>ハイパースレッディングが有効なベアメタルIntelプロセッサーの1スレッド</li>
</ul>
<p>小数値も利用可能です。0.5 CPUを要求するコンテナには、1 CPUを要求するコンテナの半分のCPUが与えられます。mというミリを表す接尾辞も使用できます。たとえば、100m CPU、100 milliCPU、0.1 CPUはすべて同じです。1m以上の精度は指定できません。</p>
<p>CPUはつねに絶対量として要求され、決して相対量としては要求されません。0.1はシングルコア、デュアルコア、48コアCPUのマシンで同じ量となります。</p>
<p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><h2 id=ノードよりも大きいcpu要求を指定する>ノードよりも大きいCPU要求を指定する</h2>
<p>CPU要求と制限はコンテナと関連づけられていますが、PodにCPU要求と制限が与えられていると考えるとわかりやすいでしょう。PodのCPU要求は、Pod内のすべてのコンテナのCPU要求の合計となります。同様に、PodのCPU制限は、Pod内のすべてのコンテナのCPU制限の合計となります。</p>
<p>Podのスケジューリングはリソースの要求量に基づいています。Podはノード上で動作するうえで、そのCPU要求に対してノードに十分利用可能なCPUリソースがある場合のみスケジュールされます。</p>
<p>この練習では、クラスター内のノードのキャパシティを超える大きさのCPU要求を与えたPodを作成します。以下に100 CPUの要求を与えた一つのコンテナを持つ、Podの設定ファイルを示します。これは、クラスター内のノードのキャパシティを超える可能性があります。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/resource/cpu-request-limit-2.yaml download=pods/resource/cpu-request-limit-2.yaml><code>pods/resource/cpu-request-limit-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-cpu-request-limit-2-yaml')" title="Copy pods/resource/cpu-request-limit-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-cpu-request-limit-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cpu-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-ctr-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -cpus<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/cpu-request-limit-2.yaml --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><p>Podの状態を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><p>この出力では、Podのステータスが待機中であることを示しています。つまり、Podがどのノードに対しても実行するようスケジュールされておらず、いつまでも待機状態のままであることを表しています:</p>
<pre><code>NAME         READY     STATUS    RESTARTS   AGE
cpu-demo-2   0/1       Pending   0          7m
</code></pre><p>イベントを含むPodの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><p>この出力では、ノードのCPU不足のためコンテナがスケジュールされないことを示しています:</p>
<pre><code>Events:
  Reason                        Message
  ------                        -------
  FailedScheduling      No nodes are available that match all of the following predicates:: Insufficient cpu (3).
</code></pre><p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><h2 id=cpu制限を指定しない場合>CPU制限を指定しない場合</h2>
<p>コンテナのCPU制限を指定しない場合、次のいずれかの状態となります:</p>
<ul>
<li>
<p>コンテナのCPUリソースの使用量に上限がない状態となります。コンテナは実行中のノードで利用可能なすべてのCPUを使用できます。</p>
</li>
<li>
<p>CPU制限を与えられたnamespaceでコンテナを実行されると、コンテナにはデフォルトの制限値が自動的に指定されます。クラスターの管理者は<a href=/docs/reference/generated/kubernetes-api/v1.22/#limitrange-v1-core>LimitRange</a>によってCPU制限のデフォルト値を指定できます。</p>
</li>
</ul>
<h2 id=cpu要求と制限のモチベーション>CPU要求と制限のモチベーション</h2>
<p>クラスターで動作するコンテナにCPU要求と制限を設定することで、クラスターのノードで利用可能なCPUリソースを効率的に使用することができます。PodのCPU要求を低く保つことで、Podがスケジュールされやすくなります。CPU要求よりも大きい制限を与えることで、次の2つを実現できます:</p>
<ul>
<li>Podは利用可能なCPUリソースを、突発的な活動(バースト)に使用することができます。</li>
<li>バースト中のPodのCPUリソース量は、適切な量に制限されます。</li>
</ul>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>namespaceを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace cpu-example
</code></pre></div><h2 id=次の項目>次の項目</h2>
<h3 id=アプリケーション開発者向け>アプリケーション開発者向け</h3>
<ul>
<li>
<p><a href=/ja/docs/tasks/configure-pod-container/assign-memory-resource/>コンテナおよびPodへのメモリーリソースの割り当て</a></p>
</li>
<li>
<p><a href=/docs/tasks/configure-pod-container/quality-service-pod/>PodのQuality of Serviceを設定する</a></p>
</li>
</ul>
<h3 id=クラスター管理者向け>クラスター管理者向け</h3>
<ul>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>Namespaceにメモリー要求および制限のデフォルト値を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>NamespaceにCPU要求および制限のデフォルト値を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>Namespaceに最小および最大メモリー量の制約を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>Namespaceに最小および最大のCPU使用量の制約を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>NamespaceにメモリーおよびCPUのクォータを設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>NamespaceにPodのクォータを設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/quota-api-object/>APIオブジェクトのクォータを設定する</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-904cea8c8efd5c0d33adbfe579ec2dd2>4.2.3 - PodにQuality of Serviceを設定する</h1>
<p>このページでは、特定のQuality of Service (QoS)クラスをPodに割り当てるための設定方法を示します。Kubernetesは、Podのスケジューリングおよび退役を決定するためにQoSクラスを用います。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=qosクラス>QoSクラス</h2>
<p>KubernetesはPodの作成時に次のいずれかのQoSクラスをPodに割り当てます:</p>
<ul>
<li>Guaranteed</li>
<li>Burstable</li>
<li>BestEffort</li>
</ul>
<h2 id=namespaceの作成>namespaceの作成</h2>
<p>この演習で作成するリソースがクラスター内で分離されるよう、namespaceを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace qos-example
</code></pre></div><h2 id=guaranteedのqosクラスを割り当てたpodを作成する>GuaranteedのQoSクラスを割り当てたPodを作成する</h2>
<p>PodにGuaranteedのQoSクラスを与えるには、以下が必要になります:</p>
<ul>
<li>Pod内のすべてのコンテナにメモリーの制限と要求が与えられており、同じ値であること。</li>
<li>Pod内のすべてのコンテナにCPUの制限と要求が与えられており、同じ値であること。</li>
</ul>
<p>以下に1つのコンテナをもつPodの設定ファイルを示します。コンテナには200MiBのメモリー制限とリクエストを与え、700ミリCPUの制限と要求を与えます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/qos/qos-pod.yaml download=pods/qos/qos-pod.yaml><code>pods/qos/qos-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-yaml')" title="Copy pods/qos/qos-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><p>Podの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div><p>この出力では、KubernetesがPodにGuaranteed QoSクラスを与えたことを示しています。Podのコンテナにメモリー制限と一致するメモリー要求があり、CPU制限と一致するCPU要求があることも確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Guaranteed<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> コンテナにメモリー制限を指定し、メモリー要求を指定していない場合は、Kubernetesは自動的にメモリー制限と一致するメモリー要求を割り当てます。同様に、コンテナにCPU制限を指定し、CPU要求を指定していない場合は、Kubernetesは自動的にCPU制限と一致するCPU要求を割り当てます。
</div>
<p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><h2 id=burstableのqosクラスを割り当てたpodを作成する>BurstableのQoSクラスを割り当てたPodを作成する</h2>
<p>次のような場合に、Burstable QoSクラスがPodに与えられます:</p>
<ul>
<li>PodがGuaranteed QoSクラスの基準に満たない場合。</li>
<li>Pod内の1つ以上のコンテナがメモリーまたはCPUの要求を与えられている場合。</li>
</ul>
<p>以下に1つのコンテナをもつPodの設定ファイルを示します。コンテナには200MiBのメモリー制限と100MiBのメモリー要求を与えます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/qos/qos-pod-2.yaml download=pods/qos/qos-pod-2.yaml><code>pods/qos/qos-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-2-yaml')" title="Copy pods/qos/qos-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-2.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><p>Podの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div><p>この出力では、KubernetesがPodにBurstable QoSクラスを与えたことを示しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></code></pre></div><p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><h2 id=besteffortのqosクラスを割り当てたpodを作成する>BestEffortのQoSクラスを割り当てたPodを作成する</h2>
<p>PodにBestEffort QoSクラスを与えるには、Pod内のコンテナにはメモリーやCPUの制限や要求を指定してはなりません。</p>
<p>以下に1つのコンテナをもつPodの設定ファイルを示します。コンテナにはメモリーやCPUの制限や要求がありません:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/qos/qos-pod-3.yaml download=pods/qos/qos-pod-3.yaml><code>pods/qos/qos-pod-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-3-yaml')" title="Copy pods/qos/qos-pod-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-3.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><p>Podの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div><p>この出力では、KubernetesがPodにBestEffort QoSクラスを与えたことを示しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>BestEffort<span style=color:#bbb>
</span></code></pre></div><p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><h2 id=2つのコンテナを含むpodを作成する>2つのコンテナを含むPodを作成する</h2>
<p>以下に2つのコンテナをもつPodの設定ファイルを示します。一方のコンテナは200MiBのメモリー要求を指定し、もう一方のコンテナには要求や制限を指定しません。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/qos/qos-pod-4.yaml download=pods/qos/qos-pod-4.yaml><code>pods/qos/qos-pod-4.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-4-yaml')" title="Copy pods/qos/qos-pod-4.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-4-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>このPodがBurstable QoSクラスの基準を満たしていることに注目してください。つまり、Guaranteed QoSクラスの基準に満たしておらず、一方のコンテナにはメモリー要求を与えられています。</p>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-4.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><p>Podの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div><p>この出力では、KubernetesがPodにBurstable QoSクラスを与えたことを示しています:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></code></pre></div><p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><h2 id=クリーンアップ>クリーンアップ</h2>
<p>namespaceを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace qos-example
</code></pre></div><h2 id=次の項目>次の項目</h2>
<h3 id=アプリケーション開発者向け>アプリケーション開発者向け</h3>
<ul>
<li>
<p><a href=/ja/docs/tasks/configure-pod-container/assign-memory-resource/>コンテナおよびPodへのメモリーリソースの割り当て</a></p>
</li>
<li>
<p><a href=/ja/docs/tasks/configure-pod-container/assign-cpu-resource/>コンテナとPodにCPUリソースを割り当てる</a></p>
</li>
</ul>
<h3 id=クラスター管理者向け>クラスター管理者向け</h3>
<ul>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>Namespaceにメモリー要求および制限のデフォルト値を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>NamespaceにCPU要求および制限のデフォルト値を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>Namespaceに最小および最大メモリー量の制約を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>Namespaceに最小および最大のCPU使用量の制約を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>NamespaceにメモリーおよびCPUのクォータを設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>NamespaceにPodのクォータを設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/quota-api-object/>APIオブジェクトのクォータを設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/topology-manager/>ノードのトポロジー管理ポリシーを制御する</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4219ac6ab56a3b88d20305083d57d03c>4.2.4 - 拡張リソースをコンテナに割り当てる</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<p>このページでは、拡張リソースをコンテナに割り当てる方法について説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>この練習を始める前に、<a href=/ja/docs/tasks/administer-cluster/extended-resource-node/>Nodeに拡張リソースをアドバタイズする</a>の練習を行ってください。これにより、Nodeの1つがドングルリソースをアドバタイズするように設定されます。</p>
<h2 id=拡張リソースをpodに割り当てる>拡張リソースをPodに割り当てる</h2>
<p>拡張リソースをリクエストするには、コンテナのマニフェストに<code>resources:requests</code>フィールドを含めます。拡張リソースは、<code>*.kubernetes.io/</code>以外の任意のドメインで完全修飾されます。有効な拡張リソース名は、<code>example.com/foo</code>という形式になります。ここで、<code>example.com</code>はあなたの組織のドメインで、<code>foo</code>は記述的なリソース名で置き換えます。</p>
<p>1つのコンテナからなるPodの構成ファイルを示します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/resource/extended-resource-pod.yaml download=pods/resource/extended-resource-pod.yaml><code>pods/resource/extended-resource-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-extended-resource-pod-yaml')" title="Copy pods/resource/extended-resource-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-extended-resource-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>構成ファイルでは、コンテナが3つのdongleをリクエストしていることがわかります。</p>
<p>次のコマンドでPodを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/extended-resource-pod.yaml
</code></pre></div><p>Podが起動したことを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod extended-resource-demo
</code></pre></div><p>Podの説明を表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod extended-resource-demo
</code></pre></div><p>dongleのリクエストが表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>Requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div><h2 id=2つ目のpodの作成を試みる>2つ目のPodの作成を試みる</h2>
<p>以下に、1つのコンテナを持つPodの構成ファイルを示します。コンテナは2つのdongleをリクエストします。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/resource/extended-resource-pod-2.yaml download=pods/resource/extended-resource-pod-2.yaml><code>pods/resource/extended-resource-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-extended-resource-pod-2-yaml')" title="Copy pods/resource/extended-resource-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-extended-resource-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Kubernetesは、2つのdongleのリクエストを満たすことができません。1つ目のPodが、利用可能な4つのdongleのうち3つを使用してしまっているためです。</p>
<p>Podを作成してみます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/extended-resource-pod-2.yaml
</code></pre></div><p>Podの説明を表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod extended-resource-demo-2
</code></pre></div><p>出力にはPodがスケジュールできないことが示されます。2つのdongleが利用できるNodeが存在しないためです。</p>
<pre><code>Conditions:
  Type    Status
  PodScheduled  False
...
Events:
  ...
  ... Warning   FailedScheduling  pod (extended-resource-demo-2) failed to fit in any node
fit failure summary on nodes : Insufficient example.com/dongle (1)
</code></pre><p>Podのステータスを表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod extended-resource-demo-2
</code></pre></div><p>出力には、Podは作成されたものの、Nodeにスケジュールされなかったことが示されています。PodはPending状態になっています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>NAME                       READY     STATUS    RESTARTS   AGE<span style=color:#bbb>
</span><span style=color:#bbb></span>extended-resource-demo-2   0/1       Pending   0          6m<span style=color:#bbb>
</span></code></pre></div><h2 id=クリーンアップ>クリーンアップ</h2>
<p>この練習で作成したPodを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod extended-resource-demo
kubectl delete pod extended-resource-demo-2
</code></pre></div><h2 id=次の項目>次の項目</h2>
<h3 id=アプリケーション開発者向け>アプリケーション開発者向け</h3>
<ul>
<li><a href=/ja/docs/tasks/configure-pod-container/assign-memory-resource/>コンテナおよびPodへのメモリーリソースの割り当て</a></li>
<li><a href=/ja/docs/tasks/configure-pod-container/assign-cpu-resource/>コンテナおよびPodへのCPUリソースの割り当て</a></li>
</ul>
<h3 id=クラスター管理者向け>クラスター管理者向け</h3>
<ul>
<li><a href=/ja/docs/tasks/administer-cluster/extended-resource-node/>Nodeに拡張リソースをアドバタイズする</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-484833fb880d1e179cc2965d15f84da5>4.2.5 - ストレージにボリュームを使用するPodを構成する</h1>
<p>このページでは、ストレージにボリュームを使用するPodを構成する方法を示します。</p>
<p>コンテナのファイルシステムは、コンテナが存在する間のみ存続します。
そのため、コンテナが終了して再起動すると、ファイルシステムの変更は失われます。
コンテナに依存しない、より一貫したストレージを実現するには、<a href=/docs/concepts/storage/volumes/>ボリューム</a>を使用できます。
これは、キーバリューストア(Redisなど)やデータベースなどのステートフルアプリケーションにとって特に重要です。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=podのボリュームを構成する>Podのボリュームを構成する</h2>
<p>この演習では、1つのコンテナを実行するPodを作成します。
今回作成するPodには、コンテナが終了して再起動した場合でもPodの寿命が続く<a href=/docs/concepts/storage/volumes/#emptydir>emptyDir</a>タイプのボリュームがあります。
これがPodの設定ファイルです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/storage/redis.yaml download=pods/storage/redis.yaml><code>pods/storage/redis.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-redis-yaml')" title="Copy pods/storage/redis.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-redis-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/data/redis<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/storage/redis.yaml
</code></pre></div></li>
<li>
<p>Podのコンテナが実行されていることを確認し、Podへの変更を監視します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod redis --watch
</code></pre></div><p>出力は次のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      READY     STATUS    RESTARTS   AGE
redis     1/1       Running   <span style=color:#666>0</span>          13s
</code></pre></div></li>
<li>
<p>別のターミナルで、実行中のコンテナへのシェルを取得します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</code></pre></div></li>
<li>
<p>シェルで、<code>/data/redis</code>に移動し、ファイルを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data# <span style=color:#a2f>cd</span> /data/redis/
root@redis:/data/redis# <span style=color:#a2f>echo</span> Hello &gt; test-file
</code></pre></div></li>
<li>
<p>シェルで、実行中のプロセスを一覧表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data/redis# apt-get update
root@redis:/data/redis# apt-get install procps
root@redis:/data/redis# ps aux
</code></pre></div><p>出力はこのようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
redis        <span style=color:#666>1</span>  0.1  0.1  <span style=color:#666>33308</span>  <span style=color:#666>3828</span> ?        Ssl  00:46   0:00 redis-server *:6379
root        <span style=color:#666>12</span>  0.0  0.0  <span style=color:#666>20228</span>  <span style=color:#666>3020</span> ?        Ss   00:47   0:00 /bin/bash
root        <span style=color:#666>15</span>  0.0  0.0  <span style=color:#666>17500</span>  <span style=color:#666>2072</span> ?        R+   00:48   0:00 ps aux
</code></pre></div></li>
<li>
<p>シェルで、Redisプロセスを終了します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data/redis# <span style=color:#a2f>kill</span> &lt;pid&gt;
</code></pre></div><p>ここで<code>&lt;pid></code>はRedisプロセスID(PID)です。</p>
</li>
<li>
<p>元の端末で、Redis Podへの変更を監視します。最終的には、このようなものが表示されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      READY     STATUS     RESTARTS   AGE
redis     1/1       Running    <span style=color:#666>0</span>          13s
redis     0/1       Completed  <span style=color:#666>0</span>         6m
redis     1/1       Running    <span style=color:#666>1</span>         6m
</code></pre></div></li>
</ol>
<p>この時点で、コンテナは終了して再起動しました。
これは、Redis Podの<a href=/docs/reference/generated/kubernetes-api/v1.22/#podspec-v1-core>restartPolicy</a>が<code>Always</code>であるためです。</p>
<ol>
<li>
<p>再起動されたコンテナへのシェルを取得します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</code></pre></div></li>
<li>
<p>シェルで<code>/data/redis</code>に移動し、<code>test-file</code>がまだ存在することを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data/redis# <span style=color:#a2f>cd</span> /data/redis/
root@redis:/data/redis# ls
test-file
</code></pre></div></li>
<li>
<p>この演習用に作成したPodを削除します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod redis
</code></pre></div></li>
</ol>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#volume-v1-core>Volume</a>参照</p>
</li>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#pod-v1-core>Pod</a>参照</p>
</li>
<li>
<p><code>emptyDir</code>によって提供されるローカルディスクストレージに加えて、Kubernetesは、GCEのPDやEC2のEBSなど、さまざまなネットワーク接続ストレージソリューションをサポートします。これらは、重要なデータに好ましく、ノード上のデバイスのマウントやアンマウントなどの詳細を処理します。詳細は<a href=/docs/concepts/storage/volumes/>ボリューム</a>を参照してください。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4621938ba53c04a77f51b5938a583439>4.2.6 - ストレージにProjectedボリュームを使用するようPodを設定する</h1>
<p>このページでは、<a href=/docs/concepts/storage/volumes/#projected><code>projected</code></a>(投影)ボリュームを使用して、既存の複数のボリュームソースを同一ディレクトリ内にマウントする方法を説明します。
現在、<code>secret</code>、<code>configMap</code>、<code>downwardAPI</code>および<code>serviceAccountToken</code>ボリュームを投影できます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>serviceAccountToken</code>はボリュームタイプではありません。
</div>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=projectedボリュームをpodに設定する>ProjectedボリュームをPodに設定する</h2>
<p>この課題では、ローカルファイルからユーザーネームおよびパスワードの<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>を作成します。
次に、単一のコンテナを実行するPodを作成し、<a href=/docs/concepts/storage/volumes/#projected><code>projected</code></a>ボリュームを使用してそれぞれのSecretを同じ共有ディレクトリにマウントします。</p>
<p>以下にPodの設定ファイルを示します:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/storage/projected.yaml download=pods/storage/projected.yaml><code>pods/storage/projected.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-projected-yaml')" title="Copy pods/storage/projected.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-projected-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-projected-volume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-projected-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;86400&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>user<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pass<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>Secretを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># ユーザーネームおよびパスワードを含むファイルを作成します:</span>
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#34;admin&#34;</span> &gt; ./username.txt
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#34;1f2d1e2e67df&#34;</span> &gt; ./password.txt

<span style=color:#080;font-style:italic># これらのファイルからSecretを作成します:</span>
kubectl create secret generic user --from-file<span style=color:#666>=</span>./username.txt
kubectl create secret generic pass --from-file<span style=color:#666>=</span>./password.txt
</code></pre></div></li>
<li>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/storage/projected.yaml
</code></pre></div></li>
<li>
<p>Pod内のコンテナが実行されていることを確認するため、Podの変更を監視します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get --watch pod test-projected-volume
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>NAME                    READY     STATUS    RESTARTS   AGE
test-projected-volume   1/1       Running   0          14s
</code></pre></li>
<li>
<p>別の端末にて、実行中のコンテナへのシェルを取得します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it test-projected-volume -- /bin/sh
</code></pre></div></li>
<li>
<p>シェル内にて、投影されたソースを含む<code>projected-volume</code>ディレクトリが存在することを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls /projected-volume/
</code></pre></div></li>
</ol>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>PodおよびSecretを削除します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod test-projected-volume
kubectl delete secret user pass
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/concepts/storage/volumes/#projected><code>projected</code></a>ボリュームについてさらに学ぶ</li>
<li><a href=https://github.com/kubernetes/community/blob/v1.22.16/contributors/design-proposals/node/all-in-one-volume.md>all-in-oneボリューム</a>のデザインドキュメントを読む</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eb54daf87df373096b5e830680194dfc>4.2.7 - Liveness Probe、Readiness ProbeおよびStartup Probeを使用する</h1>
<p>このページでは、Liveness Probe、Readiness ProbeおよびStartup Probeの使用方法について説明します。</p>
<p><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>は、Liveness Probeを使用して、コンテナをいつ再起動するかを認識します。
例えば、アプリケーション自体は起動しているが、処理を継続することができないデッドロック状態を検知することができます。
このような状態のコンテナを再起動することで、バグがある場合でもアプリケーションの可用性を高めることができます。</p>
<p>kubeletは、Readiness Probeを使用して、コンテナがトラフィックを受け入れられる状態であるかを認識します。
Podが準備ができていると見なされるのは、Pod内の全てのコンテナの準備が整ったときです。
一例として、このシグナルはServiceのバックエンドとして使用されるPodを制御するときに使用されます。
Podの準備ができていない場合、そのPodはServiceのロードバランシングから切り離されます。</p>
<p>kubeletは、Startup Probeを使用して、コンテナアプリケーションの起動が完了したかを認識します。
Startup Probeを使用している場合、Startup Probeが成功するまでは、Liveness Probeと
Readiness Probeによるチェックを無効にし、これらがアプリケーションの起動に干渉しないようにします。
例えば、これを起動が遅いコンテナの起動チェックとして使用することで、起動する前にkubeletによって
強制終了されることを防ぐことができます。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=define-a-liveness-command>コマンド実行によるLiveness Probeを定義する</h2>
<p>長期間実行されているアプリケーションの多くは、再起動されるまで回復できないような異常な状態になることがあります。
Kubernetesはこのような状況を検知し、回復するためのLiveness Probeを提供します。</p>
<p>この演習では、<code>k8s.gcr.io/busybox</code>イメージのコンテナを起動するPodを作成します。
Podの構成ファイルは次の通りです。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/probe/exec-liveness.yaml download=pods/probe/exec-liveness.yaml><code>pods/probe/exec-liveness.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-probe-exec-liveness-yaml')" title="Copy pods/probe/exec-liveness.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-probe-exec-liveness-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-exec<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- cat<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- /tmp/healthy<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>この構成ファイルでは、Podは一つの<code>Container</code>を起動します。
<code>periodSeconds</code>フィールドは、kubeletがLiveness Probeを5秒おきに行うように指定しています。
<code>initialDelaySeconds</code>フィールドは、kubeletが最初のProbeを実行する前に5秒間待機するように指示しています。
Probeの動作としては、kubeletは<code>cat /tmp/healthy</code>を対象のコンテナ内で実行します。
このコマンドが成功し、リターンコード0が返ると、kubeletはコンテナが問題なく動いていると判断します。
リターンコードとして0以外の値が返ると、kubeletはコンテナを終了し、再起動を行います。</p>
<p>このコンテナは、起動すると次のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/bin/sh -c <span style=color:#b44>&#34;touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600&#34;</span>
</code></pre></div><p>コンテナが起動してから初めの30秒間は<code>/tmp/healthy</code>ファイルがコンテナ内に存在します。
そのため初めの30秒間は<code>cat /tmp/healthy</code>コマンドは成功し、正常なリターンコードが返ります。
その後30秒が経過すると、<code>cat /tmp/healthy</code>コマンドは異常なリターンコードを返します。</p>
<p>このPodを起動してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/probe/exec-liveness.yaml
</code></pre></div><p>30秒間以内に、Podのイベントを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod liveness-exec
</code></pre></div><p>この出力結果は、Liveness Probeがまだ失敗していないことを示しています。</p>
<pre><code>FirstSeen    LastSeen    Count   From            SubobjectPath           Type        Reason      Message
--------- --------    -----   ----            -------------           --------    ------      -------
24s       24s     1   {default-scheduler }                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulling     pulling image &quot;k8s.gcr.io/busybox&quot;
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulled      Successfully pulled image &quot;k8s.gcr.io/busybox&quot;
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Created     Created container with docker id 86849c15382e; Security:[seccomp=unconfined]
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Started     Started container with docker id 86849c15382e
</code></pre><p>35秒後に、Podのイベントをもう一度確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod liveness-exec
</code></pre></div><p>出力結果の最後に、Liveness Probeが失敗していることを示すメッセージが表示されます。これによりコンテナは強制終了し、再作成されました。</p>
<pre><code>FirstSeen LastSeen    Count   From            SubobjectPath           Type        Reason      Message
--------- --------    -----   ----            -------------           --------    ------      -------
37s       37s     1   {default-scheduler }                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulling     pulling image &quot;k8s.gcr.io/busybox&quot;
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulled      Successfully pulled image &quot;k8s.gcr.io/busybox&quot;
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Created     Created container with docker id 86849c15382e; Security:[seccomp=unconfined]
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Started     Started container with docker id 86849c15382e
2s        2s      1   {kubelet worker0}   spec.containers{liveness}   Warning     Unhealthy   Liveness probe failed: cat: can't open '/tmp/healthy': No such file or directory
</code></pre><p>さらに30秒後、コンテナが再起動していることを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod liveness-exec
</code></pre></div><p>出力結果から、<code>RESTARTS</code>がインクリメントされていることを確認します:</p>
<pre><code>NAME            READY     STATUS    RESTARTS   AGE
liveness-exec   1/1       Running   1          1m
</code></pre><h2 id=define-a-liveness-http-request>HTTPリクエストによるLiveness Probeを定義する</h2>
<p>別の種類のLiveness Probeでは、HTTP GETリクエストを使用します。
次の構成ファイルは、<code>k8s.gcr.io/liveness</code>イメージを使用したコンテナを起動するPodを作成します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/probe/http-liveness.yaml download=pods/probe/http-liveness.yaml><code>pods/probe/http-liveness.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-probe-http-liveness-yaml')" title="Copy pods/probe/http-liveness.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-probe-http-liveness-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-http<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/liveness<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /server<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>X-Custom-Header<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>Awesome<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>この構成ファイルでは、Podは一つの<code>Container</code>を起動します。
<code>periodSeconds</code>フィールドは、kubeletがLiveness Probeを3秒おきに行うように指定しています。
<code>initialDelaySeconds</code>フィールドは、kubeletが最初のProbeを実行する前に3秒間待機するように指示しています。
Probeの動作としては、kubeletは8080ポートをリッスンしているコンテナ内のサーバーに対してHTTP GETリクエストを送ります。
サーバー内の<code>/healthz</code>パスに対するハンドラーが正常なリターンコードを応答した場合、
kubeletはコンテナが問題なく動いていると判断します。
異常なリターンコードを応答すると、kubeletはコンテナを終了し、再起動を行います。</p>
<p>200以上400未満のコードは成功とみなされ、その他のコードは失敗とみなされます。</p>
<p><a href=https://github.com/kubernetes/kubernetes/blob/v1.22.16/test/images/agnhost/liveness/server.go>server.go</a>
にてサーバーのソースコードを確認することができます。</p>
<p>コンテナが生きている初めの10秒間は、<code>/healthz</code>ハンドラーが200ステータスを返します。
その後、ハンドラーは500ステータスを返します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>http.<span style=color:#00a000>HandleFunc</span>(<span style=color:#b44>&#34;/healthz&#34;</span>, <span style=color:#a2f;font-weight:700>func</span>(w http.ResponseWriter, r <span style=color:#666>*</span>http.Request) {
    duration <span style=color:#666>:=</span> time.<span style=color:#00a000>Now</span>().<span style=color:#00a000>Sub</span>(started)
    <span style=color:#a2f;font-weight:700>if</span> duration.<span style=color:#00a000>Seconds</span>() &gt; <span style=color:#666>10</span> {
        w.<span style=color:#00a000>WriteHeader</span>(<span style=color:#666>500</span>)
        w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;error: %v&#34;</span>, duration.<span style=color:#00a000>Seconds</span>())))
    } <span style=color:#a2f;font-weight:700>else</span> {
        w.<span style=color:#00a000>WriteHeader</span>(<span style=color:#666>200</span>)
        w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(<span style=color:#b44>&#34;ok&#34;</span>))
    }
})
</code></pre></div><p>kubeletは、コンテナが起動してから3秒後からヘルスチェックを行います。
そのため、初めのいくつかのヘルスチェックは成功します。しかし、10秒経過するとヘルスチェックは失敗し、kubeletはコンテナを終了し、再起動します。</p>
<p>HTTPリクエストのチェックによるLiveness Probeを試すには、以下のようにPodを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/probe/http-liveness.yaml
</code></pre></div><p>10秒後、Podのイベントを表示して、Liveness Probeが失敗し、コンテナが再起動されていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod liveness-http
</code></pre></div><p>v1.13以前(v1.13を含む)のリリースにおいては、Podが起動しているノードに環境変数<code>http_proxy</code>
(または <code>HTTP_PROXY</code>)が設定されている場合、HTTPリクエストのLiveness Probeは設定されたプロキシを使用します。
v1.13より後のリリースにおいては、ローカルHTTPプロキシ環境変数の設定はHTTPリクエストのLiveness Probeに影響しません。</p>
<h2 id=define-a-tcp-liveness-probe>TCPによるLiveness Probeを定義する</h2>
<p>3つ目のLiveness ProbeはTCPソケットを使用するタイプです。
この構成においては、kubeletは指定したコンテナのソケットを開くことを試みます。
コネクションが確立できる場合はコンテナを正常とみなし、失敗する場合は異常とみなします。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/probe/tcp-liveness-readiness.yaml download=pods/probe/tcp-liveness-readiness.yaml><code>pods/probe/tcp-liveness-readiness.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-probe-tcp-liveness-readiness-yaml')" title="Copy pods/probe/tcp-liveness-readiness.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-probe-tcp-liveness-readiness-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/goproxy:0.1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tcpSocket</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tcpSocket</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>20</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>見ての通り、TCPによるチェックの構成はHTTPによるチェックと非常に似ています。
この例では、Readiness ProbeとLiveness Probeを両方使用しています。
kubeletは、コンテナが起動してから5秒後に最初のReadiness Probeを開始します。
これは<code>goproxy</code>コンテナの8080ポートに対して接続を試みます。
このProbeが成功すると、Podは準備ができていると通知されます。kubeletはこのチェックを10秒ごとに行います。</p>
<p>この構成では、Readiness Probeに加えてLiveness Probeが含まれています。
kubeletは、コンテナが起動してから15秒後に最初のLiveness Probeを実行します。
Readiness Probeと同様に、これは<code>goproxy</code>コンテナの8080ポートに対して接続を試みます。
Liveness Probeが失敗した場合、コンテナは再起動されます。</p>
<p>TCPのチェックによるLiveness Probeを試すには、以下のようにPodを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/probe/tcp-liveness-readiness.yaml
</code></pre></div><p>15秒後、Podのイベントを表示し、Liveness Probeが行われていることを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod goproxy
</code></pre></div><h2 id=use-a-named-port>名前付きポートを使用する</h2>
<p>HTTPまたはTCPによるProbeにおいて、<a href=/docs/reference/generated/kubernetes-api/v1.22/#containerport-v1-core>ContainerPort</a>
で定義した名前付きポートを使用することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></code></pre></div><h2 id=define-startup-probes>Startup Probeを使用して、起動の遅いコンテナを保護する</h2>
<p>場合によっては、最初の初期化において追加の起動時間が必要になるようなレガシーアプリケーションを扱う必要があります。
そのような場合、デッドロックに対する迅速な反応を損なうことなくLiveness Probeのパラメーターを設定することは難しい場合があります。</p>
<p>これに対する解決策の一つは、Liveness Probeと同じ構成のコマンドを用いるか、HTTPまたはTCPによるチェックを使用したStartup Probeをセットアップすることです。
その際、<code>failureThreshold * periodSeconds</code>で計算される時間を、起動時間として想定される最も遅いケースをカバーできる十分な長さに設定します。</p>
<p>上記の例は、次のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>startupProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></code></pre></div><p>Startup Probeにより、アプリケーションは起動が完了するまでに最大5分間の猶予(30 * 10 = 300秒)が与えられます。
Startup Probeに一度成功すると、その後はLiveness Probeが引き継ぎ、コンテナのデッドロックに対して迅速に反応します。
Startup Probeが成功しない場合、コンテナは300秒後に終了し、その後はPodの<code>restartPolicy</code>に従います。</p>
<h2 id=define-readiness-probes>Readiness Probeを定義する</h2>
<p>アプリケーションは一時的にトラフィックを処理できないことが起こり得ます。
例えば、アプリケーションは起動時に大きなデータまたは構成ファイルを読み込む必要がある場合や、起動後に外部サービスに依存している場合があります。
このような場合、アプリケーション自体を終了させたくはありませんが、このアプリケーションに対してリクエストも送信したくないと思います。
Kubernetesは、これらの状況を検知して緩和するための機能としてReadiness Probeを提供します。
これにより、準備ができていないことを報告するコンテナを含むPodは、KubernetesのServiceを通してトラフィックを受信しないようになります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Readiness Probeは、コンテナの全てのライフサイクルにおいて実行されます。
</div>
<p>Readiness ProbeはLiveness Probeと同様に構成します。
唯一の違いは<code>readinessProbe</code>フィールドを<code>livenessProbe</code>フィールドの代わりに利用することだけです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- cat<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /tmp/healthy<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div><p>HTTPおよびTCPによるReadiness Probeの構成もLiveness Probeと同じです。</p>
<p>Readiness ProbeとLiveness Probeは同じコンテナで同時に使用できます。
両方使用することで、準備できていないコンテナへのトラフィックが到達しないようにし、コンテナが失敗したときに再起動することができます。</p>
<h2 id=configure-probes>Probeの構成</h2>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#probe-v1-core>Probe</a> には、
Liveness ProbeおよびReadiness Probeのチェック動作をより正確に制御するために使用できるフィールドがあります:</p>
<ul>
<li><code>initialDelaySeconds</code>: コンテナが起動してから、Liveness ProbeまたはReadiness Probeが開始されるまでの秒数。デフォルトは0秒。最小値は0。</li>
<li><code>periodSeconds</code>: Probeが実行される頻度(秒数)。デフォルトは10秒。最小値は1。</li>
<li><code>timeoutSeconds</code>: Probeがタイムアウトになるまでの秒数。デフォルトは1秒。最小値は1。</li>
<li><code>successThreshold</code>: 一度Probeが失敗した後、次のProbeが成功したとみなされるための最小連続成功数。
デフォルトは1。Liveness Probeには1を設定する必要があります。最小値は1。</li>
<li><code>failureThreshold</code>: Probeが失敗した場合、Kubernetesは<code>failureThreshold</code>に設定した回数までProbeを試行します。
Liveness Probeにおいて、試行回数に到達することはコンテナを再起動することを意味します。
Readiness Probeの場合は、Podが準備できていない状態として通知されます。デフォルトは3。最小値は1。</li>
</ul>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#httpgetaction-v1-core>HTTPによるProbe</a>
には、<code>httpGet</code>にて設定できる追加のフィールドがあります:</p>
<ul>
<li><code>host</code>: 接続先ホスト名。デフォルトはPod IP。おそらくはこのフィールドの代わりに<code>httpHeaders</code>内の"Host"を代わりに使用することになります。</li>
<li><code>scheme</code>: ホストへの接続で使用するスキーマ（HTTP または HTTPS）。デフォルトは HTTP。</li>
<li><code>path</code>: HTTPサーバーへアクセスする際のパス</li>
<li><code>httpHeaders</code>: リクエスト内のカスタムヘッダー。HTTPでは重複したヘッダーが許可されています。</li>
<li><code>port</code>: コンテナにアクセスする際のポートの名前または番号。ポート番号の場合、1から65535の範囲内である必要があります。</li>
</ul>
<p>HTTPによるProbeの場合、kubeletは指定したパスとポートに対するHTTPリクエストを送ることでチェックを行います。
<code>httpGet</code>のオプションである<code>host</code>フィールドでアドレスが上書きされない限り、kubeletはPodのIPアドレスに対してProbeを送ります。
<code>scheme</code>フィールドに<code>HTTPS</code>がセットされている場合、kubeletは証明書の検証を行わずにHTTPSリクエストを送ります。
ほとんどのシナリオにおいては、<code>host</code>フィールドを使用する必要はありません。次のシナリオは使用する場合の一例です。
仮にコンテナが127.0.0.1をリッスンしており、かつPodの<code>hostNetwork</code>フィールドがtrueだとします。
その場合においては、<code>httpGet</code>フィールド内の<code>host</code>には127.0.0.1をセットする必要があります。
より一般的なケースにおいてPodが仮想ホストに依存している場合は、おそらく<code>host</code>フィールドではなく、<code>httpHeaders</code>フィールド内の<code>Host</code>ヘッダーを使用する必要があります。</p>
<p>TCPによるProbeの場合、kubeletはPodの中ではなく、ノードに対してコネクションを確立するProbeを実行します。
kubeletはServiceの名前を解決できないため、<code>host</code>パラメーター内でServiceの名前を使用することはできません。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>Container Probes</a>についてもっと学ぶ</li>
</ul>
<p>また、次のAPIリファレンスも参考にしてください:</p>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#pod-v1-core>Pod</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#container-v1-core>Container</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#probe-v1-core>Probe</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fc3f4777ae8ea685d2b54e175277ac01>4.2.8 - Node Affinityを利用してPodをノードに割り当てる</h1>
<p>このページでは、Node Affinityを利用して、PodをKubernetesクラスター内の特定のノードに割り当てる方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.10.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=ノードにラベルを追加する>ノードにラベルを追加する</h2>
<ol>
<li>
<p>クラスター内のノードを一覧表示して、ラベルを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker2
</code></pre></div></li>
<li>
<p>ノードを選択して、ラベルを追加します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl label nodes &lt;your-node-name&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</code></pre></div><p>ここで、<code>&lt;your-node-name></code>は選択したノードの名前で置換します。</p>
</li>
<li>
<p>選択したノードに<code>disktype=ssd</code>ラベルがあることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,disktype=ssd,kubernetes.io/hostname=worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker2
</code></pre><p>この出力を見ると、<code>worker0</code>ノードに<code>disktype=ssd</code>というラベルが追加されたことがわかります。</p>
</li>
</ol>
<h2 id=required-node-affinityを使用してpodをスケジューリングする>required node affinityを使用してPodをスケジューリングする</h2>
<p>以下に示すマニフェストには、<code>requiredDuringSchedulingIgnoredDuringExecution</code>に<code>disktype: ssd</code>というnode affinityを使用したPodが書かれています。このように書くと、Podは<code>disktype=ssd</code>というラベルを持つノードにだけスケジューリングされるようになります。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-nginx-required-affinity.yaml download=pods/pod-nginx-required-affinity.yaml><code>pods/pod-nginx-required-affinity.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-required-affinity-yaml')" title="Copy pods/pod-nginx-required-affinity.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-required-affinity-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- ssd<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>マニフェストを適用して、選択したノード上にスケジューリングされるPodを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/pod-nginx-required-affinity.yaml
</code></pre></div></li>
<li>
<p>Podが選択したノード上で実行されていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li>
</ol>
<h2 id=preferred-node-affinityを使用してpodをスケジューリングする>preferred node affinityを使用してPodをスケジューリングする</h2>
<p>以下に示すマニフェストには、<code>preferredDuringSchedulingIgnoredDuringExecution</code>に<code>disktype: ssd</code>というnode affinityを使用したPodが書かれています。このように書くと、Podは<code>disktype=ssd</code>というラベルを持つノードに優先的にスケジューリングされるようになります。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-nginx-preferred-affinity.yaml download=pods/pod-nginx-preferred-affinity.yaml><code>pods/pod-nginx-preferred-affinity.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-preferred-affinity-yaml')" title="Copy pods/pod-nginx-preferred-affinity.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-preferred-affinity-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>preference</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- ssd<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>マニフェストを適用して、選択したノード上にスケジューリングされるPodを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/pod-nginx-preferred-affinity.yaml
</code></pre></div></li>
<li>
<p>Podが選択したノード上で実行されていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li>
</ol>
<h2 id=次の項目>次の項目</h2>
<p><a href=/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity>Node Affinity</a>についてさらに学ぶ。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bbc17480da6d051c696489654c64064a>4.2.9 - Podをノードに割り当てる</h1>
<p>このページでは、KubernetesのPodをKubernetesクラスター上の特定のノードに割り当てる方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=ラベルをノードに追加する>ラベルをノードに追加する</h2>
<ol>
<li>
<p>クラスター内の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>のリストをラベル付きで表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker2
</code></pre></div></li>
<li>
<p>ノードの1つを選択して、ラベルを追加します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl label nodes &lt;your-node-name&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</code></pre></div><p>ここで、<code>&lt;your-node-name></code>は選択したノードの名前です。</p>
</li>
<li>
<p>選択したノードに<code>disktype=ssd</code>ラベルがあることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,disktype<span style=color:#666>=</span>ssd,kubernetes.io/hostname<span style=color:#666>=</span>worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker2
</code></pre></div><p>上の出力を見ると、<code>worker0</code>に<code>disktype=ssd</code>というラベルがあることがわかります。</p>
</li>
</ol>
<h2 id=選択したノードにスケジューリングされるpodを作成する>選択したノードにスケジューリングされるPodを作成する</h2>
<p>以下のPodの構成ファイルには、nodeSelectorに<code>disktype: ssd</code>を持つPodが書かれています。これにより、Podは<code>disktype: ssd</code>というラベルを持っているノードにスケジューリングされるようになります。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-nginx.yaml download=pods/pod-nginx.yaml><code>pods/pod-nginx.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-yaml')" title="Copy pods/pod-nginx.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>disktype</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>構成ファイルを使用して、選択したノードにスケジューリングされるPodを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/pod-nginx.yaml
</code></pre></div></li>
<li>
<p>Podが選択したノード上で実行されているをことを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   <span style=color:#666>0</span>          13s    10.200.0.4   worker0
</code></pre></div></li>
</ol>
<h2 id=特定のノードにスケジューリングされるpodを作成する>特定のノードにスケジューリングされるPodを作成する</h2>
<p><code>nodeName</code>という設定を使用して、Podを特定のノードにスケジューリングすることもできます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-nginx-specific-node.yaml download=pods/pod-nginx-specific-node.yaml><code>pods/pod-nginx-specific-node.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-specific-node-yaml')" title="Copy pods/pod-nginx-specific-node.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-specific-node-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>foo-node<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 特定のノードにPodをスケジューリングする</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>構成ファイルを使用して、<code>foo-node</code>にだけスケジューリングされるPodを作成します。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベルとセレクター</a>についてさらに学ぶ。</li>
<li><a href=/ja/docs/concepts/architecture/nodes/>ノード</a>についてさらに学ぶ。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-efbc43486296f0439d1a89c12d944d94>4.2.10 - コンテナライフサイクルイベントへのハンドラー紐付け</h1>
<p>このページでは、コンテナのライフサイクルイベントにハンドラーを紐付けする方法を説明します。KubernetesはpostStartとpreStopイベントをサポートしています。Kubernetesはコンテナの起動直後にpostStartイベントを送信し、コンテナの終了直前にpreStopイベントを送信します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=poststartハンドラーとprestopハンドラーを定義する>postStartハンドラーとpreStopハンドラーを定義する</h2>
<p>この課題では、1つのコンテナを持つPodを作成します。コンテナには、postStartイベントとpreStopイベントのハンドラーがあります。</p>
<p>これがPodの設定ファイルです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/lifecycle-events.yaml download=pods/lifecycle-events.yaml><code>pods/lifecycle-events.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-lifecycle-events-yaml')" title="Copy pods/lifecycle-events.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-lifecycle-events-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lifecycle-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lifecycle-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>postStart</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo Hello from the postStart handler &gt; /usr/share/message&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preStop</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/usr/sbin/nginx&#34;</span>,<span style=color:#b44>&#34;-s&#34;</span>,<span style=color:#b44>&#34;quit&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルでは、postStartコマンドが<code>message</code>ファイルをコンテナの<code>/usr/share</code>ディレクトリに書き込むことがわかります。preStopコマンドはnginxを適切にシャットダウンします。これは、障害のためにコンテナが終了している場合に役立ちます。</p>
<p>Podを作成します:</p>
<pre><code>kubectl apply -f https://k8s.io/examples/pods/lifecycle-events.yaml
</code></pre>
<p>Pod内のコンテナが実行されていることを確認します:</p>
<pre><code>kubectl get pod lifecycle-demo
</code></pre>
<p>Pod内で実行されているコンテナでシェルを実行します:</p>
<pre><code>kubectl exec -it lifecycle-demo -- /bin/bash
</code></pre>
<p>シェルで、<code>postStart</code>ハンドラーが<code>message</code>ファイルを作成したことを確認します:</p>
<pre><code>root@lifecycle-demo:/# cat /usr/share/message
</code></pre>
<p>出力は、postStartハンドラーによって書き込まれたテキストを示しています。</p>
<pre><code>Hello from the postStart handler
</code></pre>
<h2 id=議論>議論</h2>
<p>コンテナが作成された直後にKubernetesはpostStartイベントを送信します。
ただし、コンテナのエントリーポイントが呼び出される前にpostStartハンドラーが呼び出されるという保証はありません。postStartハンドラーはコンテナのコードに対して非同期的に実行されますが、postStartハンドラーが完了するまでコンテナのKubernetesによる管理はブロックされます。postStartハンドラーが完了するまで、コンテナのステータスはRUNNINGに設定されません。</p>
<p>Kubernetesはコンテナが終了する直前にpreStopイベントを送信します。
コンテナのKubernetesによる管理は、Podの猶予期間が終了しない限り、preStopハンドラーが完了するまでブロックされます。詳細は<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>を参照してください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Kubernetesは、Podが <em>終了</em> したときにのみpreStopイベントを送信します。
これは、Podが <em>完了</em> したときにpreStopフックが呼び出されないことを意味します。
この制限は<a href=https://github.com/kubernetes/kubernetes/issues/55807>issue #55087</a>で追跡されています。
</div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/containers/container-lifecycle-hooks/>コンテナライフサイクルフック</a>の詳細</li>
<li><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>の詳細</li>
</ul>
<h3 id=参照>参照</h3>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#lifecycle-v1-core>ライフサイクル</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#container-v1-core>コンテナ</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#podspec-v1-core>PodSpec</a>の<code>terminationGracePeriodSeconds</code></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ed34e761c3dbd00fa79577fa78e30020>4.2.11 - Podを構成してConfigMapを使用する</h1>
<p>ConfigMapを使用すると、設定をイメージのコンテンツから切り離して、コンテナ化されたアプリケーションの移植性を維持できます。このページでは、ConfigMapを作成し、ConfigMapに保存されているデータを使用してPodを構成する一連の使用例を示します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=configmapを作成する>ConfigMapを作成する</h2>
<p><code>kubectl create configmap</code>または<code>kustomization.yaml</code>のConfigMap generatorを使用すると、ConfigMapを作成できます。<code>kubectl</code>が<code>kustomization.yaml</code>をサポートをしているのは1.14からである点に注意してください。</p>
<h3 id=kubectl-create-configmapを使用してconfigmapを作成する>kubectl create configmapを使用してConfigMapを作成する</h3>
<p><code>kubectl create configmap</code>を使用してConfigMapを<a href=#create-configmaps-from-directories>ディレクトリ</a>、<a href=#create-configmaps-from-files>ファイル</a>、または<a href=#create-configmaps-from-literal-values>リテラル値</a>から作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap &lt;map-name&gt; &lt;data-source&gt;
</code></pre></div><p>&lt;map-name>の部分はConfigMapに割り当てる名前で、&lt;data-source>はデータを取得するディレクトリ、ファイル、またはリテラル値です。ConfigMapの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<p>ファイルをベースにConfigMapを作成する場合、&lt;data-source> のキーはデフォルトでファイル名になり、値はデフォルトでファイルの中身になります。</p>
<p><a href=/docs/reference/generated/kubectl/kubectl-commands/#describe><code>kubectl describe</code></a>または
<a href=/docs/reference/generated/kubectl/kubectl-commands/#get><code>kubectl get</code></a>を使用すると、ConfigMapに関する情報を取得できます。</p>
<h4 id=create-configmaps-from-directories>ディレクトリからConfigMapを作成する</h4>
<p><code>kubectl create configmap</code>を使用すると、同一ディレクトリ内にある複数のファイルから1つのConfigMapを作成できます。ディレクトリをベースにConfigMapを作成する場合、kubectlはディレクトリ内でベース名が有効なキーであるファイルを識別し、それらのファイルを新たなConfigMapにパッケージ化します。ディレクトリ内にある通常のファイルでないものは無視されます(例: サブディレクトリ、シンボリックリンク、デバイス、パイプなど)。</p>
<p>例えば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># ローカルディレクトリを作成します</span>
mkdir -p configure-pod-container/configmap/

<span style=color:#080;font-style:italic># `configure-pod-container/configmap/`ディレクトリにサンプルファイルをダウンロードします</span>
wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.properties
wget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.properties

<span style=color:#080;font-style:italic># ConfigMapを作成します</span>
kubectl create configmap game-config --from-file<span style=color:#666>=</span>configure-pod-container/configmap/
</code></pre></div><p>上記のコマンドは各ファイルをパッケージ化します。この場合、<code>configure-pod-container/configmap/</code> ディレクトリの<code>game.properties</code> と <code>ui.properties</code>をgame-config ConfigMapにパッケージ化します。 以下のコマンドを使用すると、ConfigMapの詳細を表示できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe configmaps game-config
</code></pre></div><p>出力結果は以下のようになります:</p>
<pre><code>Name:         game-config
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
ui.properties:
----
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
</code></pre><p><code>configure-pod-container/configmap/</code> ディレクトリの<code>game.properties</code> と <code>ui.properties</code> ファイルはConfigMapの<code>data</code>セクションに表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmaps game-config -o yaml
</code></pre></div><p>出力結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T18:52:05Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;516&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>b4952dc3-d670-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    enemies=aliens
</span><span style=color:#b44;font-style:italic>    lives=3
</span><span style=color:#b44;font-style:italic>    enemies.cheat=true
</span><span style=color:#b44;font-style:italic>    enemies.cheat.level=noGoodRotten
</span><span style=color:#b44;font-style:italic>    secret.code.passphrase=UUDDLRLRBABAS
</span><span style=color:#b44;font-style:italic>    secret.code.allowed=true
</span><span style=color:#b44;font-style:italic>    secret.code.lives=30</span><span style=color:#bbb>    
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    color.good=purple
</span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span><span style=color:#b44;font-style:italic>    allow.textmode=true
</span><span style=color:#b44;font-style:italic>    how.nice.to.look=fairlyNice</span><span style=color:#bbb>    
</span></code></pre></div><h4 id=create-configmaps-from-files>ファイルからConfigMapを作成する</h4>
<p><code>kubectl create configmap</code>を使用して、個別のファイルまたは複数のファイルからConfigMapを作成できます。</p>
<p>例えば、</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-2 --from-file<span style=color:#666>=</span>configure-pod-container/configmap/game.properties
</code></pre></div><p>は、以下のConfigMapを生成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe configmaps game-config-2
</code></pre></div><p>出力結果は以下のようになります:</p>
<pre><code>Name:         game-config-2
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
</code></pre><p><code>--from-file</code>引数を複数回渡し、ConfigMapを複数のデータソースから作成できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-2 --from-file<span style=color:#666>=</span>configure-pod-container/configmap/game.properties --from-file<span style=color:#666>=</span>configure-pod-container/configmap/ui.properties
</code></pre></div><p>以下のコマンドを使用すると、ConfigMap<code>game-config-2</code>の詳細を表示できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe configmaps game-config-2
</code></pre></div><p>出力結果は以下のようになります:</p>
<pre><code>Name:         game-config-2
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
ui.properties:
----
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
</code></pre><p><code>--from-env-file</code>オプションを利用してConfigMapをenv-fileから作成します。例えば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Env-filesは環境編集のリストを含んでいます。</span>
<span style=color:#080;font-style:italic># 以下のシンタックスルールが適用されます:</span>
<span style=color:#080;font-style:italic>#   envファイルの各行はVAR=VALの形式である必要がある。</span>
<span style=color:#080;font-style:italic>#   #で始まる行 (例えばコメント)は無視される。</span>
<span style=color:#080;font-style:italic>#   空の行は無視される。</span>
<span style=color:#080;font-style:italic>#   クオーテーションマークは特別な扱いは処理をしない(例えばConfigMapの値の一部になる).</span>

<span style=color:#080;font-style:italic># `configure-pod-container/configmap/`ディレクトリにサンプルファイルをダウンロードします</span>
wget https://kubernetes.io/examples/configmap/game-env-file.properties -O configure-pod-container/configmap/game-env-file.properties

<span style=color:#080;font-style:italic># env-file `game-env-file.properties`は以下のようになります</span>
cat configure-pod-container/configmap/game-env-file.properties
<span style=color:#b8860b>enemies</span><span style=color:#666>=</span>aliens
<span style=color:#b8860b>lives</span><span style=color:#666>=</span><span style=color:#666>3</span>
<span style=color:#b8860b>allowed</span><span style=color:#666>=</span><span style=color:#b44>&#34;true&#34;</span>

<span style=color:#080;font-style:italic># このコメントと上記の空の行は無視されます</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-env-file <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>       --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/game-env-file.properties
</code></pre></div><p>は、以下のConfigMapを生成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmap game-config-env-file -o yaml
</code></pre></div><p>出力結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-12-27T18:36:28Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config-env-file<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;809965&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>d9d1ca5b-eb34-11e7-887b-42010a8002b8<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;&#34;true&#34;&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>enemies</span>:<span style=color:#bbb> </span>aliens<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <code>--from-env-file</code>を複数回渡してConfigMapを複数のデータソースから作成する場合、最後のenv-fileのみが使用されます。
</div>
<p><code>--from-env-file</code>を複数回渡す場合の挙動は以下のように示されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># `configure-pod-container/configmap/`ディレクトリにサンブルファイルをダウンロードします</span>
wget https://kubernetes.io/examples/configmap/ui-env-file.properties -O configure-pod-container/configmap/ui-env-file.properties

<span style=color:#080;font-style:italic># ConfigMapを作成します</span>
kubectl create configmap config-multi-env-files <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/game-env-file.properties <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/ui-env-file.properties
</code></pre></div><p>は、以下のConfigMapを生成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmap config-multi-env-files -o yaml
</code></pre></div><p>出力結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-12-27T18:38:34Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-multi-env-files<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;810136&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>252c4572-eb35-11e7-887b-42010a8002b8<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>color</span>:<span style=color:#bbb> </span>purple<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>how</span>:<span style=color:#bbb> </span>fairlyNice<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>textmode</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></code></pre></div><h4 id=ファイルからconfigmap作成する場合は使用するキーを定義する>ファイルからConfigMap作成する場合は使用するキーを定義する</h4>
<p><code>--from-file</code>引数を使用する場合、ConfigMapの<code>data</code> セクションでキーにファイル名以外を定義できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-3 --from-file<span style=color:#666>=</span>&lt;my-key-name&gt;<span style=color:#666>=</span>&lt;path-to-file&gt;
</code></pre></div><p><code>&lt;my-key-name></code>の部分はConfigMapで使うキー、<code>&lt;path-to-file></code> はキーで表示したいデータソースファイルの場所です。</p>
<p>例えば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-3 --from-file<span style=color:#666>=</span>game-special-key<span style=color:#666>=</span>configure-pod-container/configmap/game.properties
</code></pre></div><p>は、以下のConfigMapを生成します:</p>
<pre><code>kubectl get configmaps game-config-3 -o yaml
</code></pre><p>出力結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T18:54:22Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config-3<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;530&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>05f8da22-d671-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game-special-key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    enemies=aliens
</span><span style=color:#b44;font-style:italic>    lives=3
</span><span style=color:#b44;font-style:italic>    enemies.cheat=true
</span><span style=color:#b44;font-style:italic>    enemies.cheat.level=noGoodRotten
</span><span style=color:#b44;font-style:italic>    secret.code.passphrase=UUDDLRLRBABAS
</span><span style=color:#b44;font-style:italic>    secret.code.allowed=true
</span><span style=color:#b44;font-style:italic>    secret.code.lives=30</span><span style=color:#bbb>    
</span></code></pre></div><h4 id=create-configmaps-from-literal-values>リテラル値からConfigMapを作成する</h4>
<p><code>--from-literal</code>引数を指定して<code>kubectl create configmap</code>を使用すると、コマンドラインからリテラル値を定義できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap special-config --from-literal<span style=color:#666>=</span>special.how<span style=color:#666>=</span>very --from-literal<span style=color:#666>=</span>special.type<span style=color:#666>=</span>charm
</code></pre></div><p>複数のキーバリューペアを渡せます。CLIに提供された各ペアは、ConfigMapの<code>data</code>セクションで別のエントリーとして表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmaps special-config -o yaml
</code></pre></div><p>出力結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T19:14:38Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;651&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>dadce046-d673-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.how</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.type</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></code></pre></div><h3 id=ジェネレーターからconfigmapを作成する>ジェネレーターからConfigMapを作成する</h3>
<p><code>kubectl</code>は<code>kustomization.yaml</code>を1.14からサポートしています。
ジェネレーターからConfigMapを作成して適用すると、APIサーバー上でオブジェクトを作成できます。ジェネレーターはディレクトリ内の<code>kustomization.yaml</code>で指定する必要があリます。</p>
<h4 id=ファイルからconfigmapを生成する>ファイルからConfigMapを生成する</h4>
<p>例えば、ファイル<code>configure-pod-container/configmap/game.properties</code>からConfigMapを生成するには、</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># ConfigMapGeneratorを含むkustomization.yamlファイルを作成する</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: game-config-4
</span><span style=color:#b44>  files:
</span><span style=color:#b44>  - configure-pod-container/configmap/game.properties
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>ConfigMapを作成するためにkustomizationディレクトリを適用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
configmap/game-config-4-m9dm2f92bt created
</code></pre></div><p>ConfigMapが作成されたことを以下のようにチェックできます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmap
NAME                       DATA   AGE
game-config-4-m9dm2f92bt   <span style=color:#666>1</span>      37s


kubectl describe configmaps/game-config-4-m9dm2f92bt
Name:         game-config-4-m9dm2f92bt
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                <span style=color:#666>{</span><span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;data&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;game.properties&#34;</span>:<span style=color:#b44>&#34;enemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.p...
</span><span style=color:#b44>
</span><span style=color:#b44>Data
</span><span style=color:#b44>====
</span><span style=color:#b44>game.properties:
</span><span style=color:#b44>----
</span><span style=color:#b44>enemies=aliens
</span><span style=color:#b44>lives=3
</span><span style=color:#b44>enemies.cheat=true
</span><span style=color:#b44>enemies.cheat.level=noGoodRotten
</span><span style=color:#b44>secret.code.passphrase=UUDDLRLRBABAS
</span><span style=color:#b44>secret.code.allowed=true
</span><span style=color:#b44>secret.code.lives=30
</span><span style=color:#b44>Events:  &lt;none&gt;
</span></code></pre></div><p>生成されたConfigMapの名前は、コンテンツをハッシュ化したサフィックスを持つことに注意してください。これにより、コンテンツが変更されるたびに新しいConfigMapが生成されます。</p>
<h4 id=ファイルからconfigmapを生成する場合に使用するキーを定義する>ファイルからConfigMapを生成する場合に使用するキーを定義する</h4>
<p>ConfigMapジェネレーターで使用するキーはファイルの名前以外を定義できます。
例えば、ファイル<code>configure-pod-container/configmap/game.properties</code>からキー<code>game-special-key</code>を持つConfigMapを作成する場合</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># ConfigMapGeneratorを含むkustomization.yamlファイルを作成する</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: game-config-5
</span><span style=color:#b44>  files:
</span><span style=color:#b44>  - game-special-key=configure-pod-container/configmap/game.properties
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>kustomizationディレクトリを適用してConfigMapを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
configmap/game-config-5-m67dt67794 created
</code></pre></div><h4 id=リテラルからconfigmapを作成する>リテラルからConfigMapを作成する</h4>
<p>リテラル<code>special.type=charm</code>と<code>special.how=very</code>からConfigMapを作成する場合は、
以下のように<code>kustomization.yaml</code>のConfigMapジェネレーターで指定できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># ConfigMapGeneratorを含むkustomization.yamlファイルを作成します</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: special-config-2
</span><span style=color:#b44>  literals:
</span><span style=color:#b44>  - special.how=very
</span><span style=color:#b44>  - special.type=charm
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>kustomizationディレクトリを適用してConfigMapを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
configmap/special-config-2-c92b5mmcf2 created
</code></pre></div><h2 id=configmapデータを使用してコンテナ環境変数を定義する>ConfigMapデータを使用してコンテナ環境変数を定義する</h2>
<h3 id=単一のconfigmapのデータを使用してコンテナ環境変数を定義する>単一のConfigMapのデータを使用してコンテナ環境変数を定義する</h3>
<ol>
<li>
<p>ConfigMapに環境変数をキーバリューペアとして定義します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap special-config --from-literal<span style=color:#666>=</span>special.how<span style=color:#666>=</span>very
</code></pre></div></li>
<li>
<p>ConfigMapに定義された値<code>special.how</code>をPod specificationの環境変数<code>SPECIAL_LEVEL_KEY</code>に割り当てます。</p>
</li>
</ol>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-single-configmap-env-variable.yaml download=pods/pod-single-configmap-env-variable.yaml><code>pods/pod-single-configmap-env-variable.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-single-configmap-env-variable-yaml')" title="Copy pods/pod-single-configmap-env-variable.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-single-configmap-env-variable-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 環境変数を定義します</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:#080;font-style:italic># SPECIAL_LEVEL_KEYに割り当てる値をConfigMapが保持します</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:#080;font-style:italic># 値に紐付けるキーを指定します</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>special.how<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-single-configmap-env-variable.yaml
</code></pre></div><p>すると、Podの出力結果に環境変数<code>SPECIAL_LEVEL_KEY=very</code>が含まれています。</p>
<h3 id=複数のconfigmapのデータを使用してコンテナ環境変数を定義する>複数のConfigMapのデータを使用してコンテナ環境変数を定義する</h3>
<ul>
<li>
<p>先ほどの例の通り、まずはConfigMapを作成します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/configmap/configmaps.yaml download=configmap/configmaps.yaml><code>configmap/configmaps.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('configmap-configmaps-yaml')" title="Copy configmap/configmaps.yaml to clipboard">
</img>
</div>
<div class=includecode id=configmap-configmaps-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.how</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>log_level</span>:<span style=color:#bbb> </span>INFO<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>ConfigMapを作成します:</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/configmap/configmaps.yaml
</code></pre></div><ul>
<li>
<p>Pod specificationの環境変数を定義します</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-multiple-configmap-env-variable.yaml download=pods/pod-multiple-configmap-env-variable.yaml><code>pods/pod-multiple-configmap-env-variable.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-multiple-configmap-env-variable-yaml')" title="Copy pods/pod-multiple-configmap-env-variable.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-multiple-configmap-env-variable-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>special.how<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>LOG_LEVEL<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します:</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-multiple-configmap-env-variable.yaml
</code></pre></div><p>すると、Podの出力結果に環境変数<code>SPECIAL_LEVEL_KEY=very</code> and <code>LOG_LEVEL=INFO</code>が含まれています。</p>
<h2 id=configmapの全てのキーバリューペアをコンテナ環境変数として構成する>ConfigMapの全てのキーバリューペアをコンテナ環境変数として構成する</h2>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> この機能はKubernetes v1.6以降で利用可能です。
</div>
<ul>
<li>
<p>複数のキーバリューペアを含むConfigMapを作成します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/configmap/configmap-multikeys.yaml download=configmap/configmap-multikeys.yaml><code>configmap/configmap-multikeys.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('configmap-configmap-multikeys-yaml')" title="Copy configmap/configmap-multikeys.yaml to clipboard">
</img>
</div>
<div class=includecode id=configmap-configmap-multikeys-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_LEVEL</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_TYPE</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>ConfigMapを作成します:</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml
</code></pre></div><ul>
<li><code>envFrom</code>を利用して全てのConfigMapのデータをコンテナ環境変数として定義します。ConfigMapからのキーがPodの環境変数名になります。</li>
</ul>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-configmap-envFrom.yaml download=pods/pod-configmap-envFrom.yaml><code>pods/pod-configmap-envFrom.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-envfrom-yaml')" title="Copy pods/pod-configmap-envFrom.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-envfrom-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMapRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-envFrom.yaml
</code></pre></div><p>すると、Podの出力結果は環境変数<code>SPECIAL_LEVEL=very</code>と<code>SPECIAL_TYPE=charm</code>が含まれています。</p>
<h2 id=podのコマンドでconfigmapに定義した環境変数を使用する>PodのコマンドでConfigMapに定義した環境変数を使用する</h2>
<p>ConfigMapに環境変数を定義し、Pod specificationの<code>command</code> セクションで<code>$(VAR_NAME)</code>Kubernetes置換構文を介して使用できます。</p>
<p>例えば以下のPod specificationは</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-configmap-env-var-valueFrom.yaml download=pods/pod-configmap-env-var-valueFrom.yaml><code>pods/pod-configmap-env-var-valueFrom.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-env-var-valuefrom-yaml')" title="Copy pods/pod-configmap-env-var-valueFrom.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-env-var-valuefrom-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_TYPE_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_TYPE<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>以下コマンドの実行で作成され、</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-env-var-valueFrom.yaml
</code></pre></div><p><code>test-container</code>コンテナで以下の出力結果を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>very charm
</code></pre></div><h2 id=ボリュームにconfigmapデータを追加する>ボリュームにConfigMapデータを追加する</h2>
<p><a href=#create-configmaps-from-files>ファイルからConfigMapを作成する</a>で説明したように、<code>--from-file</code>を使用してConfigMapを作成する場合は、ファイル名がConfigMapの<code>data</code>セクションに保存されるキーになり、ファイルのコンテンツがキーの値になります。</p>
<p>このセクションの例は以下に示されているspecial-configと名付けれたConfigMapについて言及したものです。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/configmap/configmap-multikeys.yaml download=configmap/configmap-multikeys.yaml><code>configmap/configmap-multikeys.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('configmap-configmap-multikeys-yaml')" title="Copy configmap/configmap-multikeys.yaml to clipboard">
</img>
</div>
<div class=includecode id=configmap-configmap-multikeys-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_LEVEL</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_TYPE</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>ConfigMapを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml
</code></pre></div><h3 id=configmapに保存されているデータをボリュームに入力する>ConfigMapに保存されているデータをボリュームに入力する</h3>
<p>ConfigMap名をPod specificationの<code>volumes</code>セクション配下に追加します。
これによりConfigMapデータが<code>volumeMounts.mountPath</code>で指定されたディレクトリに追加されます (このケースでは、<code>/etc/config</code>に)。<code>command</code>セクションはConfigMapのキーに合致したディレクトリファイルを名前別でリスト表示します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-configmap-volume.yaml download=pods/pod-configmap-volume.yaml><code>pods/pod-configmap-volume.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-volume-yaml')" title="Copy pods/pod-configmap-volume.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-volume-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;ls /etc/config/&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># コンテナに追加するファイルを含むConfigMapの名前を提供する</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume.yaml
</code></pre></div><p>Podが稼働していると、<code>ls /etc/config/</code>は以下の出力結果を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>SPECIAL_LEVEL
SPECIAL_TYPE
</code></pre></div><div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <code>/etc/config/</code>ディレクトリに何かファイルがある場合、それらは削除されます。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> テキストデータはUTF-8文字エンコーディングを使用しているファイルとして公開されます。他の文字エンコーディングを使用する場合は、バイナリデータを使用してください。
</div>
<h3 id=configmapデータをボリュームの特定のパスに追加する>ConfigMapデータをボリュームの特定のパスに追加する</h3>
<p><code>path</code>フィールドを利用して特定のConfigMapのアイテム向けに希望のファイルパスを指定します。
このケースでは<code>SPECIAL_LEVEL</code>アイテムが<code>/etc/config/keys</code>の<code>config-volume</code>ボリュームにマウントされます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-configmap-volume-specific-key.yaml download=pods/pod-configmap-volume-specific-key.yaml><code>pods/pod-configmap-volume-specific-key.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-volume-specific-key-yaml')" title="Copy pods/pod-configmap-volume-specific-key.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-volume-specific-key-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#b44>&#34;cat /etc/config/keys&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>keys<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume-specific-key.yaml
</code></pre></div><p>Podが稼働していると、 <code>cat /etc/config/keys</code>は以下の出力結果を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>very
</code></pre></div><div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> 先ほどのように、<code>/etc/config/</code> ディレクトリのこれまでのファイルは全て削除されます
</div>
<h3 id=キーを特定のパスとファイルアクセス許可に投影する>キーを特定のパスとファイルアクセス許可に投影する</h3>
<p>キーをファイル単位で特定のパスとアクセス許可に投影できます。<a href=/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod>Secret</a>のユーザーガイドで構文が解説されています。</p>
<h3 id=マウントされたconfigmapは自動的に更新される>マウントされたConfigMapは自動的に更新される</h3>
<p>ボリュームで使用されているConfigMapが更新されている場合、投影されているキーも同じく結果的に更新されます。kubeletは定期的な同期ごとにマウントされているConfigMapが更新されているかチェックします。しかし、これはローカルのttlを基にしたキャッシュでConfigMapの現在の値を取得しています。その結果、新しいキーがPodに投影されてからConfigMapに更新されるまでのトータルの遅延はkubeletで、kubeletの同期期間(デフォルトで1分) + ConfigMapキャッシュのttl(デフォルトで1分)の長さになる可能性があります。Podのアノテーションを1つ更新すると即時のリフレッシュをトリガーできます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ConfigMapを<a href=/docs/concepts/storage/volumes/#using-subpath>subPath</a>ボリュームとして利用するコンテナはConfigMapの更新を受け取りません。
</div>
<h2 id=configmapとpodsを理解する>ConfigMapとPodsを理解する</h2>
<p>ConfigMap APIリソースは構成情報をキーバリューペアとして保存します。データはPodで利用したり、コントローラーなどのシステムコンポーネントに提供できます。ConfigMapは<a href=/docs/concepts/configuration/secret/>Secret</a>に似ていますが、機密情報を含まない文字列を含まない操作する手段を提供します。ユーザーとシステムコンポーネントはどちらも構成情報をConfigMapに保存できます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ConfigMapはプロパティーファイルを参照するべきであり、置き換えるべきではありません。ConfigMapをLinuxの<code>/etc</code>ディレクトリとそのコンテンツのように捉えましょう。例えば、<a href=/docs/concepts/storage/volumes/>Kubernetes Volume</a>をConfigMapから作成した場合、ConfigMapのデータアイテムはボリューム内で個別のファイルとして表示されます。
</div>
<p>ConfigMapの<code>data</code>フィールドは構成情報を含みます。下記の例のように、シンプルに個別のプロパティーを<code>--from-literal</code>で定義、または複雑に構成ファイルまたはJSON blobsを<code>--from-file</code>で定義できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T19:14:38Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># --from-literalを使用してシンプルにプロパティーを定義する例</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.1</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.2</span>:<span style=color:#bbb> </span>world<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># --from-fileを使用して複雑にプロパティーを定義する例</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.file</span>:<span style=color:#bbb> </span>|-<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    property.1=value-1
</span><span style=color:#b44;font-style:italic>    property.2=value-2
</span><span style=color:#b44;font-style:italic>    property.3=value-3</span><span style=color:#bbb>    
</span></code></pre></div><h3 id=制限事項>制限事項</h3>
<ul>
<li>
<p>ConfigMapはPod specificationを参照させる前に作成する必要があります(ConfigMapを"optional"として設定しない限り)。存在しないConfigMapを参照させた場合、Podは起動しません。同様にConfigMapに存在しないキーを参照させた場合も、Podは起動しません。</p>
</li>
<li>
<p>ConfigMapで<code>envFrom</code>を使用して環境変数を定義した場合、無効と判断されたキーはスキップされます。Podは起動されますが、無効な名前はイベントログに(<code>InvalidVariableNames</code>)と記録されます。ログメッセージはスキップされたキーごとにリスト表示されます。例えば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events
</code></pre></div><p>出力結果は以下のようになります:</p>
<pre><code>LASTSEEN FIRSTSEEN COUNT NAME          KIND  SUBOBJECT  TYPE      REASON                            SOURCE                MESSAGE
0s       0s        1     dapi-test-pod Pod              Warning   InvalidEnvironmentVariableNames   {kubelet, 127.0.0.1}  Keys [1badkey, 2alsobad] from the EnvFrom configMap default/myconfig were skipped since they are considered invalid environment variable names.
</code></pre></li>
<li>
<p>ConfigMapは特定の<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=Namespace>Namespace</a>に属します。ConfigMapは同じ名前空間に属するPodからのみ参照できます。</p>
</li>
<li>
<p><a class=glossary-tooltip title="A pod managed directly by the kubelet daemon on a specific node." data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label="static pods">static pods</a>はKubeletがサポートしていないため、ConfigMapに使用できません。</p>
</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>実践例<a href=/ja/docs/tutorials/configuration/configure-redis-using-configmap/>ConfigMapを使ったRedisの設定</a>を続けて読む。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3d7b9cb24a647c36ba63f7a02ec49010>4.2.12 - Pod内のコンテナ間でプロセス名前空間を共有する</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>
<p>このページでは、プロセス名前空間を共有するPodを構成する方法を示します。
プロセス名前空間の共有が有効になっている場合、コンテナ内のプロセスは、そのPod内の他のすべてのコンテナに表示されます。</p>
<p>この機能を使用して、ログハンドラーサイドカーコンテナなどの協調コンテナを構成したり、シェルなどのデバッグユーティリティを含まないコンテナイメージをトラブルシューティングしたりできます。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.10.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=podを構成する>Podを構成する</h2>
<p>プロセス名前空間の共有は、<code>v1.PodSpec</code>の<code>shareProcessNamespace</code>フィールドを使用して有効にします。
例:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/share-process-namespace.yaml download=pods/share-process-namespace.yaml><code>pods/share-process-namespace.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-share-process-namespace-yaml')" title="Copy pods/share-process-namespace.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-share-process-namespace-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>shareProcessNamespace</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>capabilities</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>add</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- SYS_PTRACE<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stdin</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tty</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>クラスターにPod <code>nginx</code>を作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/share-process-namespace.yaml
</code></pre></div></li>
<li>
<p><code>shell</code>コンテナにアタッチして<code>ps</code>を実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl attach -it nginx -c shell
</code></pre></div><p>コマンドプロンプトが表示されない場合は、Enterキーを押してみてください。</p>
<pre><code>/ # ps ax
PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    8 root      0:00 nginx: master process nginx -g daemon off;
   14 101       0:00 nginx: worker process
   15 root      0:00 sh
   21 root      0:00 ps ax
</code></pre></li>
</ol>
<p>他のコンテナのプロセスにシグナルを送ることができます。
たとえば、ワーカープロセスを再起動するには、<code>SIGHUP</code>をnginxに送信します。
この操作には<code>SYS_PTRACE</code>機能が必要です。</p>
<pre><code>/ # kill -HUP 8
/ # ps ax
PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    8 root      0:00 nginx: master process nginx -g daemon off;
   15 root      0:00 sh
   22 101       0:00 nginx: worker process
   23 root      0:00 ps ax
</code></pre><p><code>/proc/$pid/root</code>リンクを使用して別のコンテナイメージにアクセスすることもできます。</p>
<pre><code>/ # head /proc/8/root/etc/nginx/nginx.conf

user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
</code></pre>
<h2 id=プロセス名前空間の共有について理解する>プロセス名前空間の共有について理解する</h2>
<p>Podは多くのリソースを共有するため、プロセスの名前空間も共有することになります。
ただし、一部のコンテナイメージは他のコンテナから分離されることが期待されるため、これらの違いを理解することが重要です:</p>
<ol>
<li>
<p><strong>コンテナプロセスは PID 1ではなくなります。</strong>
一部のコンテナイメージは、PID 1なしで起動することを拒否し(たとえば、<code>systemd</code>を使用するコンテナ)、<code>kill -HUP 1</code>などのコマンドを実行してコンテナプロセスにシグナルを送信します。
共有プロセス名前空間を持つPodでは、<code>kill -HUP 1</code>はPodサンドボックスにシグナルを送ります。(上の例では<code>/pause</code>)</p>
</li>
<li>
<p><strong>プロセスはPod内の他のコンテナに表示されます。</strong>
これには、引数または環境変数として渡されたパスワードなど、<code>/proc</code>に表示されるすべての情報が含まれます。
これらは、通常のUnixアクセス許可によってのみ保護されます。</p>
</li>
<li>
<p><strong>コンテナファイルシステムは、<code>/proc/$pid/root</code>リンクを介してPod内の他のコンテナに表示されます。</strong>
これによりデバッグが容易になりますが、ファイルシステム内の秘密情報はファイルシステムのアクセス許可によってのみ保護されることも意味します。</p>
</li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-42a59b878d4c58e5c6f4bb87483dda93>4.2.13 - static Podを作成する</h1>
<p><em>Static Pod</em>とは、<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>が監視せず、特定のノード上のkubeletデーモンによって直接管理されるPodです。コントロールプレーンに管理されるPod(たとえば<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>など)とは異なり、kubeletがそれぞれのstatic Podを監視(および障害時には再起動)します。</p>
<p>Static Podは、常に特定のノード上の1つの<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>に紐付けられます。</p>
<p>kubeletは、各static Podに対して、自動的にKubernetes APIサーバー上に<a class=glossary-tooltip title="kubelet上のstatic Podを追跡するAPIサーバー内のオブジェクトです。" data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-mirror-pod" target=_blank aria-label=ミラーPod>ミラーPod</a>の作成を試みます。つまり、ノード上で実行中のPodはAPIサーバーから検出されますが、APIサーバー自身から制御されることはないということです。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 複数ノードからなるKubernetesクラスターを実行していて、Podをすべてのノード上で実行するためにstatic Podを使用している場合、おそらくstatic Podの代わりに<a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>を使用するべきでしょう。
</div>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>このページの説明では、Podを実行するために<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>を使用しており、ノード上のOSがFedoraであることを前提としています。他のディストリビューションやKubernetesのインストール方法によっては、操作が異なる場合があります。</p>
<h2 id=static-pod-creation>static Podを作成する</h2>
<p>static Podは、<a href=#configuration-files>ファイルシステム上でホストされた設定ファイル</a>または<a href=/#pods-created-via-http>ウェブ上でホストされた設定ファイル</a>を使用して設定できます。</p>
<h3 id=configuration-files>ファイルシステム上でホストされたstatic Podマニフェスト</h3>
<p>マニフェストは、JSONまたはYAML形式の標準のPod定義で、特定のディレクトリに置きます。<a href=/docs/tasks/administer-cluster/kubelet-config-file>kubeletの設定ファイル</a>の中で、<code>staticPodPath: &lt;ディレクトリの場所></code>というフィールドを使用すると、kubeletがこのディレクトリを定期的にスキャンして、YAML/JSONファイルが作成/削除されるたびに、static Podの作成/削除が行われるようになります。指定したディレクトリをスキャンする際、kubeletはドットから始まる名前のファイルを無視することに注意してください。</p>
<p>例として、単純なウェブサーバーをstatic Podとして実行する方法を示します。</p>
<ol>
<li>
<p>static Podを実行したいノードを選択します。この例では、<code>my-node1</code>です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ssh my-node1
</code></pre></div></li>
<li>
<p>ディレクトリを選び(ここでは<code>/etc/kubelet.d</code>とします)、ここにウェブサーバーのPodの定義を置きます。たとえば、<code>/etc/kubelet.d/static-web.yaml</code>に置きます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、kubeletが実行中のノード上で実行してください</span>
mkdir /etc/kubelet.d/
cat <span style=color:#b44>&lt;&lt;EOF &gt;/etc/kubelet.d/static-web.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: static-web
</span><span style=color:#b44>  labels:
</span><span style=color:#b44>    role: myrole
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: web
</span><span style=color:#b44>      image: nginx
</span><span style=color:#b44>      ports:
</span><span style=color:#b44>        - name: web
</span><span style=color:#b44>          containerPort: 80
</span><span style=color:#b44>          protocol: TCP
</span><span style=color:#b44>EOF</span>
</code></pre></div></li>
<li>
<p>ノード上のkubeletがこのディレクトリを使用するようにするために、<code>--pod-manifest-path=/etc/kubelet.d/</code>引数を付けてkubeletを実行するように設定します。Fedoraの場合、次の行が含まれるように<code>/etc/kubernetes/kubelet</code>を編集します。</p>
<pre><code>KUBELET_ARGS=&quot;--cluster-dns=10.254.0.10 --cluster-domain=kube.local --pod-manifest-path=/etc/kubelet.d/&quot;
</code></pre><p>あるいは、<a href=/docs/tasks/administer-cluster/kubelet-config-file>kubeletの設定ファイル</a>に、<code>staticPodPath: &lt;ディレクトリの場所></code>フィールドを追加することでも設定できます。</p>
</li>
<li>
<p>kubeletを再起動します。Fedoraの場合、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、kubeletが実行中のノード上で実行してください</span>
systemctl restart kubelet
</code></pre></div></li>
</ol>
<h3 id=pods-created-via-http>ウェブ上でホストされたstatic Podマニフェスト</h3>
<p>kubeletは、<code>--manifest-url=&lt;URL></code>引数で指定されたファイルを定期的にダウンロードし、Podの定義が含まれたJSON/YAMLファイルとして解釈します。kubeletは、<a href=#configuration-files>ファイルシステム上でホストされたマニフェスト</a>での動作方法と同じように、定期的にマニフェストを再取得します。static Podのリスト中に変更が見つかると、kubeletがその変更を適用します。</p>
<p>このアプローチを採用する場合、次のように設定します。</p>
<ol>
<li>
<p>YAMLファイルを作成し、kubeletにファイルのURLを渡せるようにするために、ウェブサーバー上に保存する。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>static-web<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>myrole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></code></pre></div></li>
<li>
<p>選択したノード上のkubeletを<code>--manifest-url=&lt;manifest-url></code>を使用して実行することで、このウェブ上のマニフェストを使用するように設定する。Fedoraの場合、<code>/etc/kubernetes/kubelet</code>に次の行が含まれるように編集します。</p>
<pre><code>KUBELET_ARGS=&quot;--cluster-dns=10.254.0.10 --cluster-domain=kube.local --manifest-url=&lt;マニフェストのURL&quot;
</code></pre></li>
<li>
<p>kubeletを再起動する。Fedoraの場合、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、kubeletが実行中のノード上で実行してください</span>
systemctl restart kubelet
</code></pre></div></li>
</ol>
<h2 id=behavior-of-static-pods>static Podの動作を観察する</h2>
<p>kubeletが起動すると、定義されたすべてのstatic Podを起動します。ここまででstatic Podを設定してkubeletを再起動したため、すでに新しいstatic Podが実行中になっているはずです。</p>
<p>次のコマンドを(ノード上で)実行することで、(static Podを含む)実行中のコンテナを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、kubeletが実行中のノード上で実行してください</span>
docker ps
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>CONTAINER ID IMAGE         COMMAND  CREATED        STATUS         PORTS     NAMES
f6d05272b57e nginx:latest  &quot;nginx&quot;  8 minutes ago  Up 8 minutes             k8s_web.6f802af4_static-web-fk-node1_default_67e24ed9466ba55986d120c867395f3c_378e5f3c
</code></pre><p>APIサーバー上では、ミラーPodを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME                       READY     STATUS    RESTARTS   AGE
static-web-my-node1        1/1       Running   0          2m
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> kubeletにAPIサーバー上のミラーPodを作成する権限があることを確認してください。もし権限がない場合、APIサーバーによって作成のリクエストが拒否されてしまいます。詳しくは、<a href=/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>を参照してください。
</div>
<p>static Podに付けた<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=ラベル>ラベル</a>はミラーPodに伝搬します。ミラーPodに付けたラベルは、通常のPodと同じように<a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=セレクター>セレクター</a>などから利用できます。</p>
<p>もし<code>kubectl</code>を使用してAPIサーバーからミラーPodを削除しようとしても、kubeletはstatic Podを削除<em>しません</em>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod static-web-my-node1
</code></pre></div><pre><code>pod &quot;static-web-my-node1&quot; deleted
</code></pre><p>Podはまだ実行中であることがわかります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME                       READY     STATUS    RESTARTS   AGE
static-web-my-node1        1/1       Running   0          12s
</code></pre><p>kubeletが実行中のノードに戻り、Dockerコンテナを手動で停止してみることができます。しばらくすると、kubeletが変化に気づき、Podを自動的に再起動することがわかります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、kubeletが実行中のノード上で実行してください</span>
docker stop f6d05272b57e <span style=color:#080;font-style:italic># 実際のコンテナIDと置き換えてください</span>
sleep <span style=color:#666>20</span>
docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE         COMMAND                CREATED       ...
5b920cbaf8b1        nginx:latest  &quot;nginx -g 'daemon of   2 seconds ago ...
</code></pre><h2 id=static-podの動的な追加と削除>static Podの動的な追加と削除</h2>
<p>実行中のkubeletは設定ディレクトリ(この例では<code>/etc/kubelet.d</code>)の変更を定期的にスキャンし、このディレクトリ内にファイルが追加/削除されると、Podの追加/削除を行います。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># This assumes you are using filesystem-hosted static Pod configuration</span>
<span style=color:#080;font-style:italic># このコマンドは、kubeletが実行中のノード上で実行してください</span>
<span style=color:#080;font-style:italic>#</span>
mv /etc/kubelet.d/static-web.yaml /tmp
sleep <span style=color:#666>20</span>
docker ps
<span style=color:#080;font-style:italic># You see that no nginx container is running</span>
mv /tmp/static-web.yaml  /etc/kubelet.d/
sleep <span style=color:#666>20</span>
docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE         COMMAND                CREATED           ...
e7a62e3427f1        nginx:latest  &quot;nginx -g 'daemon of   27 seconds ago
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-34a810f1516ad9d99b2697e36e9b0d0f>4.3 - クラスターの管理</h1>
<div class=lead>クラスターの管理のための一般的なタスクについて学びます。</div>
</div>
<div class=td-content>
<h1 id=pg-adb489b1ab985c9215657b0d4c6ae92b>4.3.1 - Namespaceに対する最小および最大メモリー制約の構成</h1>
<p>このページでは、Namespaceで実行されるコンテナが使用するメモリーの最小値と最大値を設定する方法を説明します。
<a href=/docs/reference/generated/kubernetes-api/v1.22/#limitrange-v1-core>LimitRange</a> で最小値と最大値のメモリー値を指定します。
PodがLimitRangeによって課される制約を満たさない場合、そのNamespaceではPodを作成できません。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>クラスター内の各ノードには、少なくとも1GiBのメモリーが必要です。</p>
<h2 id=namespaceの作成>Namespaceの作成</h2>
<p>この演習で作成したリソースがクラスターの他の部分から分離されるように、Namespaceを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace constraints-mem-example
</code></pre></div><h2 id=limitrangeとpodを作成>LimitRangeとPodを作成</h2>
<p>LimitRangeの設定ファイルです。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/resource/memory-constraints.yaml download=admin/resource/memory-constraints.yaml><code>admin/resource/memory-constraints.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-yaml')" title="Copy admin/resource/memory-constraints.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mem-min-max-demo-lr<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>500Mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>LimitRangeを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><p>LimitRangeの詳細情報を表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get limitrange mem-min-max-demo-lr --namespace<span style=color:#666>=</span>constraints-mem-example --output<span style=color:#666>=</span>yaml
</code></pre></div><p>出力されるのは、予想通りメモリー制約の最小値と最大値を示しています。
しかし、LimitRangeの設定ファイルでデフォルト値を指定していないにもかかわらず、
自動的に作成されていることに気づきます。</p>
<pre><code>  limits:
  - default:
      memory: 1Gi
    defaultRequest:
      memory: 1Gi
    max:
      memory: 1Gi
    min:
      memory: 500Mi
    type: Container
</code></pre><p>constraints-mem-exampleNamespaceにコンテナが作成されるたびに、
Kubernetesは以下の手順を実行するようになっています。</p>
<ul>
<li>
<p>コンテナが独自のメモリー要求と制限を指定しない場合は、デフォルトのメモリー要求と制限をコンテナに割り当てます。</p>
</li>
<li>
<p>コンテナに500MiB以上のメモリー要求があることを確認します。</p>
</li>
<li>
<p>コンテナのメモリー制限が1GiB以下であることを確認します。</p>
</li>
</ul>
<p>以下は、1つのコンテナを持つPodの設定ファイルです。設定ファイルのコンテナ(containers)では、600MiBのメモリー要求と800MiBのメモリー制限が指定されています。これらはLimitRangeによって課される最小と最大のメモリー制約を満たしています。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/resource/memory-constraints-pod.yaml download=admin/resource/memory-constraints-pod.yaml><code>admin/resource/memory-constraints-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-pod-yaml')" title="Copy admin/resource/memory-constraints-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;600Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podの作成</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><p>Podのコンテナが実行されていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod constraints-mem-demo --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><p>Podの詳細情報を見ます</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod constraints-mem-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><p>出力は、コンテナが600MiBのメモリ要求と800MiBのメモリー制限になっていることを示しています。これらはLimitRangeによって課される制約を満たしています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>800Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>600Mi<span style=color:#bbb>
</span></code></pre></div><p>Podを消します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod constraints-mem-demo --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><h2 id=最大メモリ制約を超えるpodの作成の試み>最大メモリ制約を超えるPodの作成の試み</h2>
<p>これは、1つのコンテナを持つPodの設定ファイルです。コンテナは800MiBのメモリー要求と1.5GiBのメモリー制限を指定しています。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/resource/memory-constraints-pod-2.yaml download=admin/resource/memory-constraints-pod-2.yaml><code>admin/resource/memory-constraints-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-pod-2-yaml')" title="Copy admin/resource/memory-constraints-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1.5Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成してみます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-2.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><p>出力は、コンテナが大きすぎるメモリー制限を指定しているため、Podが作成されないことを示しています。</p>
<pre><code>Error from server (Forbidden): error when creating &quot;examples/admin/resource/memory-constraints-pod-2.yaml&quot;:
pods &quot;constraints-mem-demo-2&quot; is forbidden: maximum memory usage per Container is 1Gi, but limit is 1536Mi.
</code></pre><h2 id=最低限のメモリ要求を満たさないpodの作成の試み>最低限のメモリ要求を満たさないPodの作成の試み</h2>
<p>これは、1つのコンテナを持つPodの設定ファイルです。コンテナは100MiBのメモリー要求と800MiBのメモリー制限を指定しています。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/resource/memory-constraints-pod-3.yaml download=admin/resource/memory-constraints-pod-3.yaml><code>admin/resource/memory-constraints-pod-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-pod-3-yaml')" title="Copy admin/resource/memory-constraints-pod-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-pod-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-3-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成してみます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-3.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><p>出力は、コンテナが小さすぎるメモリー要求を指定しているため、Podが作成されないことを示しています。</p>
<pre><code>Error from server (Forbidden): error when creating &quot;examples/admin/resource/memory-constraints-pod-3.yaml&quot;:
pods &quot;constraints-mem-demo-3&quot; is forbidden: minimum memory usage per Container is 500Mi, but request is 100Mi.
</code></pre><h2 id=メモリ要求や制限を指定しないpodの作成>メモリ要求や制限を指定しないPodの作成</h2>
<p>これは、1つのコンテナを持つPodの設定ファイルです。コンテナはメモリー要求を指定しておらず、メモリー制限も指定していません。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/resource/memory-constraints-pod-4.yaml download=admin/resource/memory-constraints-pod-4.yaml><code>admin/resource/memory-constraints-pod-4.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-pod-4-yaml')" title="Copy admin/resource/memory-constraints-pod-4.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-pod-4-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-4<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-4-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-4.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><p>Podの詳細情報を見ます</p>
<pre><code>kubectl get pod constraints-mem-demo-4 --namespace=constraints-mem-example --output=yaml
</code></pre><p>出力を見ると、Podのコンテナのメモリ要求は1GiB、メモリー制限は1GiBであることがわかります。
コンテナはどのようにしてこれらの値を取得したのでしょうか？</p>
<pre><code>resources:
  limits:
    memory: 1Gi
  requests:
    memory: 1Gi
</code></pre><p>コンテナが独自のメモリー要求と制限を指定していなかったため、LimitRangeから与えられのです。
コンテナが独自のメモリー要求と制限を指定していなかったため、LimitRangeから<a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>デフォルトのメモリー要求と制限</a>が与えられたのです。</p>
<p>この時点で、コンテナは起動しているかもしれませんし、起動していないかもしれません。このタスクの前提条件は、ノードが少なくとも1GiBのメモリーを持っていることであることを思い出してください。それぞれのノードが1GiBのメモリーしか持っていない場合、どのノードにも1GiBのメモリー要求に対応するのに十分な割り当て可能なメモリーがありません。たまたま2GiBのメモリーを持つノードを使用しているのであれば、おそらく1GiBのメモリーリクエストに対応するのに十分なスペースを持っていることになります。</p>
<p>Podを削除します。</p>
<pre><code>kubectl delete pod constraints-mem-demo-4 --namespace=constraints-mem-example
</code></pre><h2 id=最小および最大メモリー制約の強制>最小および最大メモリー制約の強制</h2>
<p>LimitRangeによってNamespaceに課される最大および最小のメモリー制約は、Podが作成または更新されたときにのみ適用されます。LimitRangeを変更しても、以前に作成されたPodには影響しません。</p>
<h2 id=最小-最大メモリー制約の動機>最小・最大メモリー制約の動機</h2>
<p>クラスター管理者としては、Podが使用できるメモリー量に制限を課したいと思うかもしれません。</p>
<p>例:</p>
<ul>
<li>
<p>クラスター内の各ノードは2GBのメモリーを持っています。クラスタ内のどのノードもその要求をサポートできないため、2GB以上のメモリーを要求するPodは受け入れたくありません。</p>
</li>
<li>
<p>クラスターは運用部門と開発部門で共有されています。 本番用のワークロードでは最大8GBのメモリーを消費しますが、開発用のワークロードでは512MBに制限したいとします。本番用と開発用に別々のNamespaceを作成し、それぞれのNamespaceにメモリー制限を適用します。</p>
</li>
</ul>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>Namespaceを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace constraints-mem-example
</code></pre></div><h2 id=次の項目>次の項目</h2>
<h3 id=クラスター管理者向け>クラスター管理者向け</h3>
<ul>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>名前空間に対するデフォルトのメモリー要求と制限の構成</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>名前空間に対するデフォルトのCPU要求と制限の構成</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>名前空間に対する最小および最大CPU制約の構成</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>名前空間に対するメモリーとCPUのクォータの構成</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>名前空間に対するPodクォータの設定</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/quota-api-object/>APIオブジェクトのクォータの設定</a></p>
</li>
</ul>
<h3 id=アプリケーション開発者向け>アプリケーション開発者向け</h3>
<ul>
<li>
<p><a href=/docs/tasks/configure-pod-container/assign-memory-resource/>コンテナとPodへのメモリーリソースの割り当て</a></p>
</li>
<li>
<p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>コンテナとPodへのCPUリソースの割り当て</a></p>
</li>
<li>
<p><a href=/docs/tasks/configure-pod-container/quality-service-pod/>PodのQoS(サービス品質)を設定</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9133578f1e75663bb031e5a377ca896d>4.3.2 - Windowsノードの追加</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>Kubernetesを使用してLinuxノードとWindowsノードを混在させて実行できるため、Linuxで実行するPodとWindowsで実行するPodを混在させることができます。このページでは、Windowsノードをクラスターに登録する方法を示します。</p>
<h2 id=始める前に>始める前に</h2>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: 1.17.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
<ul>
<li>
<p>WindowsコンテナをホストするWindowsノードを構成するには、<a href=https://www.microsoft.com/en-us/cloud-platform/windows-server-pricing>Windows Server 2019ライセンス</a>(またはそれ以上)を取得します。
VXLAN/オーバーレイネットワークを使用している場合は、<a href=https://support.microsoft.com/help/4489899>KB4489899</a>もインストールされている必要があります。</p>
</li>
<li>
<p>コントロールプレーンにアクセスできるLinuxベースのKubernetes kubeadmクラスター(<a href=/ja/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>kubeadmを使用したシングルコントロールプレーンクラスターの作成</a>を参照)</p>
</li>
</ul>
<h2 id=目標>目標</h2>
<ul>
<li>Windowsノードをクラスターに登録する</li>
<li>LinuxとWindowsのPodとServiceが相互に通信できるようにネットワークを構成する</li>
</ul>
<h2 id=はじめに-クラスターへのwindowsノードの追加>はじめに: クラスターへのWindowsノードの追加</h2>
<h3 id=ネットワーク構成>ネットワーク構成</h3>
<p>LinuxベースのKubernetesコントロールプレーンノードを取得したら、ネットワーキングソリューションを選択できます。このガイドでは、簡単にするためにVXLANモードでのFlannelの使用について説明します。</p>
<h4 id=flannel構成>Flannel構成</h4>
<ol>
<li>
<p>FlannelのためにKubernetesコントロールプレーンを準備する</p>
<p>クラスター内のKubernetesコントロールプレーンでは、多少の準備が推奨されます。Flannelを使用する場合は、iptablesチェーンへのブリッジIPv4トラフィックを有効にすることをお勧めします。すべてのLinuxノードで次のコマンドを実行する必要があります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo sysctl net.bridge.bridge-nf-call-iptables<span style=color:#666>=</span><span style=color:#666>1</span>
</code></pre></div></li>
<li>
<p>Linux用のFlannelをダウンロードして構成する</p>
<p>最新のFlannelマニフェストをダウンロード:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
</code></pre></div><p>VNIを4096、ポートを4789に設定するために、flannelマニフェストの<code>net-conf.json</code>セクションを変更します。次のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span>net-conf.json:</span> <span>|</span>
    {
      <span style=color:green;font-weight:700>&#34;Network&#34;</span>: <span style=color:#b44>&#34;10.244.0.0/16&#34;</span>,
      <span style=color:green;font-weight:700>&#34;Backend&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;Type&#34;</span>: <span style=color:#b44>&#34;vxlan&#34;</span>,
        <span style=color:green;font-weight:700>&#34;VNI&#34;</span> : <span style=color:#666>4096</span>,
        <span style=color:green;font-weight:700>&#34;Port&#34;</span>: <span style=color:#666>4789</span>
      }
    }
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Linux上のFlannelがWindows上のFlannelと相互運用するには、VNIを4096およびポート4789に設定する必要があります。これらのフィールドの説明については、<a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan>VXLANドキュメント</a>を参照してください。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> L2Bridge/Host-gatewayモードを使用するには、代わりに<code>Type</code>の値を<code>"host-gw"</code>に変更し、<code>VNI</code>と<code>Port</code>を省略します。
</div>
</li>
<li>
<p>Flannelマニフェストを適用して検証する</p>
<p>Flannelの構成を適用しましょう:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f kube-flannel.yml
</code></pre></div><p>数分後、Flannel Podネットワークがデプロイされていれば、すべてのPodが実行されていることがわかります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get pods -n kube-system
</code></pre></div><p>出力結果には、実行中のLinux flannel DaemonSetが含まれているはずです:</p>
<pre><code>NAMESPACE     NAME                                      READY        STATUS    RESTARTS   AGE
...
kube-system   kube-flannel-ds-54954                     1/1          Running   0          1m
</code></pre></li>
<li>
<p>Windows Flannelとkube-proxy DaemonSetを追加する</p>
<p>これで、Windows互換バージョンのFlannelおよびkube-proxyを追加できます。
互換性のあるバージョンのkube-proxyを確実に入手するには、イメージのタグを置換する必要があります。
次の例は、Kubernetesv1.22.16の使用方法を示していますが、
独自のデプロイに合わせてバージョンを調整する必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/kube-proxy.yml | sed <span style=color:#b44>&#39;s/VERSION/v1.22.16/g&#39;</span> | kubectl apply -f -
kubectl apply -f https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-overlay.yml
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ホストゲートウェイを使用している場合は、代わりに <a href=https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-host-gw.yml>https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-host-gw.yml</a> を使用してください。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>Windowsノードでイーサネット(「Ethernet0 2」など)ではなく別のインターフェースを使用している場合は、次の行を変更する必要があります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>wins <span style=color:#a2f>cli </span><span style=color:#a2f;font-weight:700>process</span> run --path /k/flannel/setup.exe --args <span style=color:#b44>&#34;--mode=overlay --interface=Ethernet&#34;</span>
</code></pre></div><p><code>flannel-host-gw.yml</code>または<code>flannel-overlay.yml</code>ファイルで、それに応じてインターフェースを指定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 例</span>
curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-overlay.yml | sed <span style=color:#b44>&#39;s/Ethernet/Ethernet0 2/g&#39;</span> | kubectl apply -f -
</code></pre></div>
</div>
</li>
</ol>
<h3 id=windowsワーカーノードの参加>Windowsワーカーノードの参加</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>Containers</code>機能をインストールし、Dockerをインストールする必要があります。
行うための指示としては、<a href=https://docs.mirantis.com/docker-enterprise/v3.1/dockeree-products/docker-engine-enterprise/dee-windows.html>Dockerエンジンのインストール - Windowsサーバー上のエンタープライズ</a>を利用できます。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Windowsセクションのすべてのコードスニペットは、
Windowsワーカーノードの(管理者)権限を持つPowerShell環境で実行されます。
</div>
<ol>
<li>
<p>wins、kubelet、kubeadmをインストールします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell>curl.exe -LO https<span>:</span>//raw.githubusercontent.com/<span style=color:#a2f>kubernetes-sigs</span>/<span style=color:#a2f>sig-windows</span>-tools/master/kubeadm/scripts/PrepareNode.ps1
.\PrepareNode.ps1 -KubernetesVersion <span style=color:#a2f>
</code></pre></div></li>
<li>
<p><code>kubeadm</code>を実行してノードに参加します</p>
<p>コントロールプレーンホストで<code>kubeadm init</code>を実行したときに提供されたコマンドを使用します。
このコマンドがなくなった場合、またはトークンの有効期限が切れている場合は、<code>kubeadm token create --print-join-command</code>
(コントロールプレーンホスト上で)を実行して新しいトークンを生成します。</p>
</li>
</ol>
<h4 id=インストールの確認>インストールの確認</h4>
<p>次のコマンドを実行して、クラスター内のWindowsノードを表示できるようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get nodes -o wide
</code></pre></div><p>新しいノードが<code>NotReady</code>状態の場合は、flannelイメージがまだダウンロード中の可能性があります。
<code>kube-system</code>名前空間のflannel Podを確認することで、以前と同様に進行状況を確認できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl -n kube-system get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>flannel
</code></pre></div><p>flannel Podが実行されると、ノードは<code>Ready</code>状態になり、ワークロードを処理できるようになります。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/administer-cluster/kubeadm/upgrading-windows-nodes>Windows kubeadmノードのアップグレード</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e805c7d8d4ad6195cb82dbbc843bfc29>4.3.3 - Windowsノードのアップグレード</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>このページでは、<a href=/docs/tasks/administer-cluster/kubeadm/adding-windows-nodes>kubeadmで作られた</a>Windowsノードをアップグレードする方法について説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: 1.17.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<ul>
<li><a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade>残りのkubeadmクラスターをアップグレードするプロセス</a>を理解します。
Windowsノードをアップグレードする前にコントロールプレーンノードをアップグレードしたいと思うかもしれません。</li>
</ul>
<h2 id=ワーカーノードをアップグレード>ワーカーノードをアップグレード</h2>
<h3 id=kubeadmをアップグレード>kubeadmをアップグレード</h3>
<ol>
<li>
<p>Windowsノードから、kubeadmをアップグレードします。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#080;font-style:italic># v1.22.16を目的のバージョンに置き換えます</span>
curl.exe -Lo C:\k\kubeadm.exe https<span>:</span>//dl.k8s.io/<span style=color:#a2f>/bin/windows/amd64/kubeadm.exe
</code></pre></div></li>
</ol>
<h3 id=ノードをドレインする>ノードをドレインする</h3>
<ol>
<li>
<p>Kubernetes APIにアクセスできるマシンから、
ノードをスケジュール不可としてマークして、ワークロードを削除することでノードのメンテナンスを準備します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;をドレインするノードの名前に置き換えます</span>
kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets
</code></pre></div><p>このような出力結果が表示されるはずです:</p>
<pre><code>node/ip-172-31-85-18 cordoned
node/ip-172-31-85-18 drained
</code></pre></li>
</ol>
<h3 id=kubeletの構成をアップグレード>kubeletの構成をアップグレード</h3>
<ol>
<li>
<p>Windowsノードから、次のコマンドを呼び出して新しいkubelet構成を同期します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>kubeadm upgrade node
</code></pre></div></li>
</ol>
<h3 id=kubeletをアップグレード>kubeletをアップグレード</h3>
<ol>
<li>
<p>Windowsノードから、kubeletをアップグレードして再起動します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>stop-service</span> kubelet
curl.exe -Lo C:\k\kubelet.exe https<span>:</span>//dl.k8s.io/<span style=color:#a2f>/bin/windows/amd64/kubelet.exe
<span style=color:#a2f>restart-service</span> kubelet
</code></pre></div></li>
</ol>
<h3 id=ノードをオンライン状態に>ノードをオンライン状態に</h3>
<ol>
<li>
<p>Kubernetes APIにアクセスできるマシンから、
スケジュール可能としてマークして、ノードをオンラインに戻します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;をノードの名前に置き換えます</span>
kubectl uncordon &lt;node-to-drain&gt;
</code></pre></div></li>
</ol>
<h3 id=kube-proxyをアップグレード>kube-proxyをアップグレード</h3>
<ol>
<li>
<p>Kubernetes APIにアクセスできるマシンから、次を実行します、
もう一度v1.22.16を目的のバージョンに置き換えます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/kube-proxy.yml | sed <span style=color:#b44>&#39;s/VERSION/v1.22.16/g&#39;</span> | kubectl apply -f -
</code></pre></div></li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-77351865caa548b0a06694b904dd881c>4.3.4 - EndpointSliceの有効化</h1>
<p>このページはKubernetesのEndpointSliceの有効化の概要を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=概要>概要</h2>
<p>EndpointSliceは、KubernetesのEndpointsに対してスケーラブルで拡張可能な代替手段を提供します。Endpointsが提供する機能のベースの上に構築し、スケーラブルな方法で拡張します。Serviceが多数(100以上)のネットワークエンドポイントを持つ場合、それらは単一の大きなEndpointsリソースではなく、複数の小さなEndpointSliceに分割されます。</p>
<h2 id=endpointsliceの有効化>EndpointSliceの有効化</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> EndpointSliceは、最終的には既存のEndpointsを置き換える可能性がありますが、多くのKubernetesコンポーネントはまだ既存のEndpointsに依存しています。現時点ではEndpointSliceを有効化することは、Endpointsの置き換えではなく、クラスター内のEndpointsへの追加とみなされる必要があります。
</div>
<p>EndpoitSliceはベータ版の機能です。APIとEndpointSlice<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>はデフォルトで有効です。<a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>はデフォルトでEndpointSliceではなくEndpointsを使用します。</p>
<p>スケーラビリティと性能向上のため、kube-proxy上で<code>EndpointSliceProxying</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にできます。この変更はデータソースをEndpointSliceに移します、これはkube-proxyとKubernetes API間のトラフィックの量を削減します。</p>
<h2 id=endpointsliceの使用>EndpointSliceの使用</h2>
<p>クラスター内でEndpointSliceを完全に有効にすると、各Endpointsリソースに対応するEndpointSliceリソースが表示されます。既存のEndpointsの機能をサポートすることに加えて、EndpointSliceはトポロジーなどの新しい情報を含みます。これらにより、クラスター内のネットワークエンドポイントのスケーラビリティと拡張性が大きく向上します。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/concepts/services-networking/endpoint-slices/>EndpointSlice</a>を参照してください。</li>
<li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>サービスとアプリケーションの接続</a>を参照してください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9ceed97f912df7289ed8872e290cfbad>4.3.5 - KubernetesクラスターでNodeLocal DNSキャッシュを使用する</h1>
<p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
このページでは、KubernetesのNodeLocal DNSキャッシュの機能の概要について説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=イントロダクション>イントロダクション</h2>
<p>NodeLocal DNSキャッシュは、クラスターノード上でDNSキャッシュエージェントをDaemonSetで稼働させることで、クラスターのDNSパフォーマンスを向上させます。現在のアーキテクチャーにおいて、ClusterFirstのDNSモードでのPodは、DNSクエリー用にkube-dnsのService IPに疎通します。これにより、kube-proxyによって追加されたiptablesを介してkube-dns/CoreDNSのエンドポイントへ変換されます。この新しいアーキテクチャーによって、Podは同じノード上で稼働するDNSキャッシュエージェントに対して疎通し、それによってiptablesのDNATルールとコネクショントラッキングを回避します。ローカルのキャッシュエージェントはクラスターのホスト名(デフォルトではcluster.localというサフィックス)に対するキャッシュミスがあるときはkube-dnsサービスへ問い合わせます。</p>
<h2 id=動機>動機</h2>
<ul>
<li>
<p>現在のDNSアーキテクチャーでは、ローカルのkube-dns/CoreDNSがないとき、DNSへの秒間クエリー数が最も高いPodは他のノードへ疎通する可能性があります。ローカルでキャッシュを持つことにより、この状況におけるレイテンシーの改善に役立ちます。</p>
</li>
<li>
<p>iptables DNATとコネクショントラッキングをスキップすることは<a href=https://github.com/kubernetes/kubernetes/issues/56903>conntrackの競合</a>を減らし、UDPでのDNSエントリーがconntrackテーブルを満杯にすることを避けるのに役立ちます。</p>
</li>
<li>
<p>ローカルのキャッシュエージェントからkube-dnsサービスへの接続がTCPにアップグレードされます。タイムアウトをしなくてはならないUDPエントリーと比べ、TCPのconntrackエントリーはコネクションクローズ時に削除されます(<a href=https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt>デフォルトの</a> <code>nf_conntrack_udp_timeout</code> は30秒です)。</p>
</li>
<li>
<p>DNSクエリーをUDPからTCPにアップグレードすることで、UDPパケットの欠損や、通常30秒(10秒のタイムアウトで3回再試行する)であるDNSのタイムアウトによるテイルレイテンシーを減少させます。NodeLocalキャッシュはUDPのDNSクエリーを待ち受けるため、アプリケーションを変更する必要はありません。</p>
</li>
<li>
<p>DNSクエリーに対するノードレベルのメトリクスと可視性を得られます。</p>
</li>
<li>
<p>DNSの不在応答のキャッシュも再度有効にされ、それによりkube-dnsサービスに対するクエリー数を減らします。</p>
</li>
</ul>
<h2 id=アーキテクチャー図>アーキテクチャー図</h2>
<p>この図はNodeLocal DNSキャッシュが有効にされた後にDNSクエリーがあったときの流れとなります。</p>
<figure>
<img src=/images/docs/nodelocaldns.svg alt="NodeLocal DNSCache flow"> <figcaption>
<h4>Nodelocal DNSCacheのフロー</h4><p>この図は、NodeLocal DNSキャッシュがDNSクエリーをどう扱うかを表したものです。</p>
</figcaption>
</figure>
<h2 id=設定>設定</h2>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> NodeLocal DNSキャッシュ用のローカルに待ち受けているIPアドレスは、169.254.20.0/16の範囲のIPか、既存のIPと衝突しないことが保証されている他のIPとなります。このドキュメントでは例として169.254.10を使用します。
</div>
<p>この機能は、下記の手順により有効化できます。</p>
<ul>
<li>
<p><a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/dns/nodelocaldns/nodelocaldns.yaml><code>nodelocaldns.yaml</code></a>と同様のマニフェストを用意し、<code>nodelocaldns.yaml</code>という名前で保存してください。</p>
</li>
<li>
<p>マニフェスト内の変数を正しい値に置き換えてください。</p>
<ul>
<li>
<p>kubedns=<code>kubectl get svc kube-dns -n kube-system -o jsonpath={.spec.clusterIP}</code></p>
</li>
<li>
<p>domain=<code>&lt;cluster-domain></code></p>
</li>
<li>
<p>localdns=<code>&lt;node-local-address></code></p>
</li>
</ul>
<p><code>&lt;cluster-domain></code>はデフォルトで"cluster.local"です。<code>&lt;node-local-address></code> はNodeLocal DNSキャッシュ用に確保されたローカルの待ち受けIPアドレスです。</p>
<ul>
<li>
<p>kube-proxyがIPTABLESモードで稼働中のとき:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sed -i <span style=color:#b44>&#34;s/__PILLAR__LOCAL__DNS__/</span><span style=color:#b8860b>$localdns</span><span style=color:#b44>/g; s/__PILLAR__DNS__DOMAIN__/</span><span style=color:#b8860b>$domain</span><span style=color:#b44>/g; s/__PILLAR__DNS__SERVER__/</span><span style=color:#b8860b>$kubedns</span><span style=color:#b44>/g&#34;</span> nodelocaldns.yaml
</code></pre></div><p><code>__PILLAR__CLUSTER__DNS__</code>と<code>__PILLAR__UPSTREAM__SERVERS__</code>はnode-local-dnsというPodによって生成されます。
このモードでは、node-local-dns Podは<code>&lt;node-local-address></code>とkube-dnsのサービスIPの両方で待ち受けるため、PodはIPアドレスでもDNSレコードのルップアップができます。</p>
</li>
<li>
<p>kube-proxyがIPVSモードで稼働中のとき:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash> sed -i <span style=color:#b44>&#34;s/__PILLAR__LOCAL__DNS__/</span><span style=color:#b8860b>$localdns</span><span style=color:#b44>/g; s/__PILLAR__DNS__DOMAIN__/</span><span style=color:#b8860b>$domain</span><span style=color:#b44>/g; s/,__PILLAR__DNS__SERVER__//g; s/__PILLAR__CLUSTER__DNS__/</span><span style=color:#b8860b>$kubedns</span><span style=color:#b44>/g&#34;</span> nodelocaldns.yaml
</code></pre></div><p>このモードでは、node-local-dns Podは<code>&lt;node-local-address></code>上のみで待ち受けます。node-local-dnsのインターフェースはkube-dnsのクラスターIPをバインドしません。なぜならばIPVSロードバランシング用に使われているインターフェースは既にこのアドレスを使用しているためです。
<code>__PILLAR__UPSTREAM__SERVERS__</code> はnode-local-dns Podにより生成されます。</p>
</li>
</ul>
</li>
<li>
<p><code>kubectl create -f nodelocaldns.yaml</code>を実行してください。</p>
</li>
<li>
<p>kube-proxyをIPVSモードで使用しているとき、NodeLocal DNSキャッシュが待ち受けている<code>&lt;node-local-address></code>を使用するため、kubeletに対する<code>--cluster-dns</code>フラグを修正する必要があります。IPVSモード以外のとき、<code>--cluster-dns</code>フラグの値を修正する必要はありません。なぜならNodeLocal DNSキャッシュはkube-dnsのサービスIPと<code>&lt;node-local-address></code>の両方で待ち受けているためです。</p>
</li>
</ul>
<p>一度有効にすると、クラスターの各Node上で、kube-systemという名前空間でnode-local-dns Podが、稼働します。このPodは<a href=https://github.com/coredns/coredns>CoreDNS</a>をキャッシュモードで稼働させるため、異なるプラグインによって公開された全てのCoreDNSのメトリクスがNode単位で利用可能となります。</p>
<p><code>kubectl delete -f &lt;manifest></code>を実行してDaemonSetを削除することによって、この機能を無効にできます。また、kubeletの設定に対して行った全ての変更をリバートすべきです。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-00733cc3747eb3f5fe1c9e0439262967>4.3.6 - Serviceトポロジーを有効にする</h1>
<p>このページでは、Kubernetes上でServiceトポロジーを有効にする方法の概要について説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=はじめに>はじめに</h2>
<p><em>Serviceトポロジー</em>は、クラスターのノードのトポロジーに基づいてトラフィックをルーティングできるようにする機能です。たとえば、あるServiceのトラフィックに対して、できるだけ同じノードや同じアベイラビリティゾーン上にあるエンドポイントを優先してルーティングするように指定できます。</p>
<h2 id=前提>前提</h2>
<p>トポロジーを考慮したServiceのルーティングを有効にするには、以下の前提を満たしている必要があります。</p>
<ul>
<li>Kubernetesバージョン1.17以降である</li>
<li><a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=Kube-proxy>Kube-proxy</a>がiptableモードまたはIPVSモードで稼働している</li>
<li><a href=/docs/concepts/services-networking/endpoint-slices/>Endpoint Slice</a>を有効にしている</li>
</ul>
<h2 id=serviceトポロジーを有効にする>Serviceトポロジーを有効にする</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [alpha]</code>
</div>
<p>Serviceトポロジーを有効にするには、すべてのKubernetesコンポーネントで<code>ServiceTopology</code>と<code>EndpointSlice</code>フィーチャーゲートを有効にする必要があります。</p>
<pre><code>--feature-gates=&quot;ServiceTopology=true,EndpointSlice=true&quot;
</code></pre><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/services-networking/service-topology>Serviceトポロジー</a>のコンセプトについて読む</li>
<li><a href=/docs/concepts/services-networking/endpoint-slices>Endpoint Slice</a>について読む</li>
<li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>サービスとアプリケーションの接続</a>を読む</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ce4cd28c8feb9faa783e79b48af37961>4.3.7 - クラウドコントローラーマネージャーの運用管理</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p>クラウドプロバイダーはKubernetesプロジェクトとは異なるペースで開発およびリリースされるため、プロバイダー固有のコードを<a class=glossary-tooltip title=サードパーティクラウドプロバイダーにKubernetewを結合するコントロールプレーンコンポーネント data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/cloud-controller/ target=_blank aria-label="`cloud-controller-manager`">`cloud-controller-manager`</a>バイナリに抽象化することでクラウドベンダーはKubernetesのコアのコードとは独立して開発が可能となりました。</p>
<p><code>cloud-controller-manager</code>は、<a href=https://github.com/kubernetes/cloud-provider/blob/master/cloud.go>cloudprovider.Interface</a>を満たす任意のクラウドプロバイダーと接続できます。下位互換性のためにKubernetesのコアプロジェクトで提供される<a href=https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager>cloud-controller-manager</a>は<code>kube-controller-manager</code>と同じクラウドライブラリを使用します。Kubernetesのコアリポジトリですでにサポートされているクラウドプロバイダーは、Kubernetesリポジトリにあるcloud-controller-managerを使用してKubernetesのコアから移行することが期待されています。</p>
<h2 id=運用>運用</h2>
<h3 id=要件>要件</h3>
<p>すべてのクラウドには動作させるためにそれぞれのクラウドプロバイダーの統合を行う独自の要件があり、<code>kube-controller-manager</code>を実行する場合の要件とそれほど違わないようにする必要があります。一般的な経験則として、以下のものが必要です。</p>
<ul>
<li>クラウドの認証/認可: クラウドではAPIへのアクセスを許可するためにトークンまたはIAMルールが必要になる場合があります</li>
<li>kubernetesの認証/認可: cloud-controller-managerは、kubernetes apiserverと通信するためにRBACルールの設定を必要とする場合があります</li>
<li>高可用性: kube-controller-managerのように、リーダー選出を使用したクラウドコントローラーマネージャーの高可用性のセットアップが必要になる場合があります(デフォルトでオンになっています)。</li>
</ul>
<h3 id=cloud-controller-managerを動かす>cloud-controller-managerを動かす</h3>
<p>cloud-controller-managerを正常に実行するにはクラスター構成にいくつかの変更が必要です。</p>
<ul>
<li><code>kube-apiserver</code>と<code>kube-controller-manager</code>は**<code>--cloud-provider</code>フラグを指定してはいけません**。これによりクラウドコントローラーマネージャーによって実行されるクラウド固有のループが実行されなくなります。将来このフラグは非推奨になり削除される予定です。</li>
<li><code>kubelet</code>は<code>--cloud-provider=external</code>で実行する必要があります。これは作業をスケジュールする前にクラウドコントローラーマネージャーによって初期化する必要があることをkubeletが認識できるようにするためです。</li>
</ul>
<p>クラウドコントローラーマネージャーを使用するようにクラスターを設定するとクラスターの動作がいくつか変わることに注意してください。</p>
<ul>
<li><code>--cloud-provider=external</code>を指定したkubeletは、初期化時に<code>NoSchedule</code>の<code>node.cloudprovider.kubernetes.io/uninitialized</code>汚染を追加します。これによりノードは作業をスケジュールする前に外部のコントローラーからの2回目の初期化が必要であるとマークされます。クラウドコントローラーマネージャーが使用できない場合クラスター内の新しいノードはスケジュールできないままになることに注意してください。スケジューラーはリージョンやタイプ(高CPU、GPU、高メモリ、スポットインスタンスなど)などのノードに関するクラウド固有の情報を必要とする場合があるためこの汚染は重要です。</li>
<li>クラスター内のノードに関するクラウド情報はローカルメタデータを使用して取得されなくなりましたが、代わりにノード情報を取得するためのすべてのAPI呼び出しはクラウドコントローラーマネージャーを経由して行われるようになります。これはセキュリティを向上させるためにkubeletでクラウドAPIへのアクセスを制限できることを意味します。大規模なクラスターではクラスター内からクラウドのほとんどすべてのAPI呼び出しを行うため、クラウドコントローラーマネージャーがレートリミットに達するかどうかを検討する必要があります。</li>
</ul>
<p>クラウドコントローラーマネージャーは以下を実装できます。</p>
<ul>
<li>ノードコントローラー - クラウドAPIを使用してkubernetesノードを更新し、クラウドで削除されたkubernetesノードを削除します。</li>
<li>サービスコントローラー - タイプLoadBalancerのサービスに対応してクラウド上のロードバランサーを操作します。</li>
<li>ルートコントローラー - クラウド上でネットワークルートを設定します。</li>
<li>Kubernetesリポジトリの外部にあるプロバイダーを実行している場合はその他の機能の実装。</li>
</ul>
<h2 id=例>例</h2>
<p>現在Kubernetesのコアでサポートされているクラウドを使用していて、クラウドコントローラーマネージャーを利用する場合は、<a href=https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager>kubernetesのコアのクラウドコントローラーマネージャー</a>を参照してください。</p>
<p>Kubernetesのコアリポジトリにないクラウドコントローラーマネージャーの場合、クラウドベンダーまたはsigリードが管理するリポジトリでプロジェクトを見つけることができます。</p>
<p>すでにKubernetesのコアリポジトリにあるプロバイダーの場合、クラスター内でデーモンセットとしてKubernetesリポジトリ内部のクラウドコントローラーマネージャーを実行できます。以下をガイドラインとして使用してください。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/cloud/ccm-example.yaml download=admin/cloud/ccm-example.yaml><code>admin/cloud/ccm-example.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-cloud-ccm-example-yaml')" title="Copy admin/cloud/ccm-example.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-cloud-ccm-example-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># This is an example of how to setup cloud-controller-manager as a Daemonset in your cluster.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># It assumes that your masters can run pods and has the role node-role.kubernetes.io/master</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Note that this Daemonset will not work straight out of the box for your cloud, this is</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># meant to be a guideline.</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cluster-admin<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># for in-tree providers we use k8s.gcr.io/cloud-controller-manager</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># this can be replaced with any other image for out-of-tree providers</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/cloud-controller-manager:v1.8.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- /usr/local/bin/cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --cloud-provider=&lt;YOUR_CLOUD_PROVIDER&gt;  <span style=color:#bbb> </span><span style=color:#080;font-style:italic># Add your own cloud provider here!</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --leader-elect=true<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --use-service-account-credentials<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># these flags will vary for every cloud provider</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --allocate-node-cidrs=true<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --configure-cloud-routes=true<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --cluster-cidr=172.17.0.0/16<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># this is required so CCM can bootstrap itself</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node.cloudprovider.kubernetes.io/uninitialized<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># this is to have the daemonset runnable on master nodes</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># the taint may vary depending on your cluster setup</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># this is to restrict CCM to only run on master nodes</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># the node selector may vary depending on your cluster setup</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>node-role.kubernetes.io/master</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h2 id=制限>制限</h2>
<p>クラウドコントローラーマネージャーの実行にはいくつかの制限があります。これらの制限は今後のリリースで対処されますが、本番のワークロードにおいてはこれらの制限を認識することが重要です。</p>
<h3 id=ボリュームのサポート>ボリュームのサポート</h3>
<p>ボリュームの統合にはkubeletとの調整も必要になるためクラウドコントローラーマネージャーは<code>kube-controller-manager</code>にあるボリュームコントローラーを実装しません。CSI(コンテナストレージインターフェイス)が進化してFlexボリュームプラグインの強力なサポートが追加されるにつれ、クラウドがボリュームと完全に統合できるようクラウドコントローラーマネージャーに必要なサポートが追加されます。Kubernetesリポジトリの外部にあるCSIボリュームプラグインの詳細については<a href=https://github.com/kubernetes/features/issues/178>こちら</a>をご覧ください。</p>
<h3 id=スケーラビリティ>スケーラビリティ</h3>
<p>cloud-controller-managerは、クラウドプロバイダーのAPIにクエリーを送信して、すべてのノードの情報を取得します。非常に大きなクラスターの場合、リソース要件やAPIレートリミットなどのボトルネックの可能性を考慮する必要があります。</p>
<h3 id=鶏と卵>鶏と卵</h3>
<p>クラウドコントローラーマネージャープロジェクトの目標はKubernetesのコアプロジェクトからクラウドに関する機能の開発を切り離すことです。残念ながら、Kubernetesプロジェクトの多くの面でクラウドプロバイダーの機能がKubernetesプロジェクトに緊密に結びついているという前提があります。そのため、この新しいアーキテクチャを採用するとクラウドプロバイダーの情報を要求する状況が発生する可能性がありますが、クラウドコントローラーマネージャーはクラウドプロバイダーへのリクエストが完了するまでその情報を返すことができない場合があります。</p>
<p>これの良い例は、KubeletのTLSブートストラップ機能です。TLSブートストラップはKubeletがすべてのアドレスタイプ(プライベート、パブリックなど)をクラウドプロバイダー(またはローカルメタデータサービス)に要求する能力を持っていると仮定していますが、クラウドコントローラーマネージャーは最初に初期化されない限りノードのアドレスタイプを設定できないためapiserverと通信するためにはkubeletにTLS証明書が必要です。</p>
<p>このイニシアチブが成熟するに連れ、今後のリリースでこれらの問題に対処するための変更が行われます。</p>
<h2 id=次の項目>次の項目</h2>
<p>独自のクラウドコントローラーマネージャーを構築および開発するには<a href=/ja/docs/tasks/administer-cluster/developing-cloud-controller-manager/>クラウドコントローラーマネージャーの開発</a>を参照してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9585dc0efb0450fd68728e7511754717>4.3.8 - クラウドコントローラーマネージャーの開発</h1>
<p><p>cloud-controller-managerは クラウド特有の制御ロジックを組み込むKubernetesの<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="control plane">control plane</a>コンポーネントです。クラウドコントロールマネージャーは、クラスターをクラウドプロバイダーAPIをリンクし、クラスタのみで相互作用するコンポーネントからクラウドプラットフォームで相互作用するコンポーネントを分離します。</p></p>
<p>Kubernetesと下のクラウドインフラストラクチャー間の相互運用ロジックを分離することで、cloud-controller-managerコンポーネントはクラウドプロバイダを主なKubernetesプロジェクトと比較し異なるペースで機能をリリース可能にします。</p>
<h2 id=背景>背景</h2>
<p>クラウドプロバイダーはKubernetesプロジェクトとは異なる速度で開発しリリースすることから、プロバイダー特有なコードを<code>cloud-controller-manager</code>バイナリから抽象化することで、クラウドベンダーはコアKubernetesコードから独立して発展することができます。</p>
<p>Kubernetesプロジェクトは、(クラウドプロバイダーの)独自実装を組み込めるGoインターフェースを備えたcloud-controller-managerのスケルトンコードを提供しています。これは、クラウドプロバイダーがKubernetesコアからパッケージをインポートすることでcloud-controller-managerを実装できることを意味します。各クラウドプロバイダーは利用可能なクラウドプロバイダーのグローバル変数を更新するために<code>cloudprovider.RegisterCloudProvider</code>を呼び出し、独自のコードを登録します。</p>
<h2 id=開発>開発</h2>
<h3 id=kubernetesには登録されていない独自クラウドプロバイダー>Kubernetesには登録されていない独自クラウドプロバイダー</h3>
<p>Kubernetesには登録されていない独自のクラウドプロバイダーのクラウドコントローラーマネージャーを構築するには、</p>
<ol>
<li><a href=https://github.com/kubernetes/cloud-provider/blob/master/cloud.go>cloudprovider.Interface</a>を満たす go パッケージを実装します。</li>
<li>Kubernetesのコアにある<a href=https://github.com/kubernetes/kubernetes/blob/master/cmd/cloud-controller-manager/controller-manager.go>cloud-controller-managerの<code>main.go</code></a>をあなたの<code>main.go</code>のテンプレートとして利用します。上で述べたように、唯一の違いはインポートされるクラウドパッケージのみです。</li>
<li>クラウドパッケージを <code>main.go</code> にインポートし、パッケージに <a href=https://github.com/kubernetes/cloud-provider/blob/master/plugins.go><code>cloudprovider.RegisterCloudProvider</code></a> を実行するための <code>init</code> ブロックがあることを確認します。</li>
</ol>
<p>多くのクラウドプロバイダーはオープンソースとしてコントローラーマネージャーのコードを公開しています。新たにcloud-controller-managerをスクラッチから開発する際には、既存のKubernetesには登録されていない独自クラウドプロバイダーのコントローラーマネージャーを開始地点とすることができます。</p>
<h3 id=kubernetesに登録されているクラウドプロバイダー>Kubernetesに登録されているクラウドプロバイダー</h3>
<p>Kubernetesに登録されているクラウドプロバイダーであれば、<a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>を使ってあなたのクラスターで動かすことができます。詳細については<a href=/ja/docs/tasks/administer-cluster/running-cloud-controller/>Kubernetesクラウドコントローラーマネージャー</a>を参照してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e1afcdac8d5e8458274b3c481c5ebcda>4.3.9 - サービスディスカバリーにCoreDNSを使用する</h1>
<p>このページでは、CoreDNSのアップグレードプロセスと、kube-dnsの代わりにCoreDNSをインストールする方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.9.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=about-coredns>CoreDNSについて</h2>
<p><a href=https://coredns.io>CoreDNS</a>は、KubernetesクラスターDNSとして稼働させることができる柔軟で拡張可能なDNSサーバーです。Kubernetesと同様に、CoreDNSプロジェクトは<a class=glossary-tooltip title="Cloud Native Computing Foundation" data-toggle=tooltip data-placement=top href=https://cncf.io/ target=_blank aria-label=CNCF>CNCF</a>によってホストされています。</p>
<p>既存のデプロイでkube-dnsを置き換えるか、クラスターのデプロイとアップグレードを代行してくれるkubeadmのようなツールを使用することで、クラスターでkube-dnsの代わりにCoreDNSを使用することができます。</p>
<h2 id=installing-coredns>CoreDNSのインストール</h2>
<p>kube-dnsの手動デプロイや置き換えについては、<a href=https://github.com/coredns/deployment/tree/master/kubernetes>CoreDNS GitHub project</a>のドキュメントを参照してください。</p>
<h2 id=migrating-to-coredns>CoreDNSへの移行</h2>
<h3 id=upgrading-an-existing-cluster-with-kubeadm>kubeadmを使用した既存のクラスターのアップグレード</h3>
<p>Kubernetesバージョン1.10以降では、<code>kube-dns</code>を使用しているクラスターを<code>kubeadm</code>を使用してアップグレードするときに、CoreDNSに移行することもできます。この場合、<code>kubeadm</code>は、<code>kube-dns</code> ConfigMapをベースにしてCoreDNS設定("Corefile")を生成し、フェデレーション、スタブドメイン、および上流のネームサーバーの設定を保持します。</p>
<p>kube-dnsからCoreDNSに移行する場合は、アップグレード時に必ず<code>CoreDNS</code>フィーチャーゲートを<code>true</code>に設定してください。たとえば、<code>v1.11.0</code>のアップグレードは次のようになります:</p>
<pre><code>kubeadm upgrade apply v1.11.0 --feature-gates=CoreDNS=true
</code></pre><p>Kubernetesバージョン1.13以降では、<code>CoreDNS</code>フィーチャーゲートが削除され、CoreDNSがデフォルトで使用されます。アップグレードしたクラスターでkube-dnsを使用する場合は、<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase#cmd-phase-addon>こちら</a>のガイドに従ってください。</p>
<p>1.11以前のバージョンでは、Corefileはアップグレード中に作成されたものによって<strong>上書き</strong>されます。<strong>カスタマイズしている場合は、既存のConfigMapを保存する必要があります。</strong> 新しいConfigMapが稼働したら、カスタマイズを再適用できます。</p>
<p>Kubernetesバージョン1.11以降でCoreDNSを実行している場合、アップグレード中、既存のCorefileは保持されます。</p>
<h3 id=installing-kube-dns-instead-of-coredns-with-kubeadm>kubeadmを使用してCoreDNSの代わりにkube-dnsをインストールする</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Kubernetes 1.11では、CoreDNSは一般利用可能(GA)にアップグレードされ、デフォルトでインストールされます。
</div>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> Kubernetes 1.18では、kubeadmでのkube-dns使用は非推奨となり、将来のバージョンでは削除されます。
</div>
<p>1.13以前のバージョンにkube-dnsをインストールするには、<code>CoreDNS</code>フィーチャーゲートの値を<code>false</code>に設定します:</p>
<pre><code>kubeadm init --feature-gates=CoreDNS=false
</code></pre><p>バージョン1.13以降の場合は、<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase#cmd-phase-addon>こちら</a>に記載されているガイドに従ってください。</p>
<h2 id=upgrading-coredns>CoreDNSのアップグレード</h2>
<p>CoreDNSはv1.9以降のKubernetesで使用できます。Kubernetesに同梱されているCoreDNSのバージョンと、CoreDNSに加えられた変更は<a href=https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md>こちら</a>で確認できます。</p>
<p>CoreDNSだけをアップグレードしたい場合や、独自のカスタムイメージを使用したい場合は、CoreDNSを手動でアップグレードすることができます。スムーズなアップグレードのために役立つ<a href=https://github.com/coredns/deployment/blob/master/kubernetes/Upgrading_CoreDNS.md>ガイドラインとウォークスルー</a>が用意されています。</p>
<h2 id=tuning-coredns>CoreDNSのチューニング</h2>
<p>リソース使用率が問題になる場合は、CoreDNSの設定を調整すると役立つ場合があります。詳細は、<a href=https://github.com/coredns/deployment/blob/master/kubernetes/Scaling_CoreDNS.md>CoreDNSのスケーリングに関するドキュメント</a>を参照してください。</p>
<h2 id=次の項目>次の項目</h2>
<p><a href=https://coredns.io>CoreDNS</a>は、<code>Corefile</code>を変更することで、kube-dnsよりも多くのユースケースをサポートするように設定することができます。詳細は<a href=https://coredns.io/2017/05/08/custom-dns-entries-for-kubernetes/>CoreDNSサイト</a>を参照してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a3790dfb57271d13517e549dffa805b9>4.3.10 - ネットワークポリシーを宣言する</h1>
<p>このドキュメントでは、Pod同士の通信を制御するネットワークポリシーを定義するための、Kubernetesの<a href=/docs/concepts/services-networking/network-policies/>NetworkPolicy API</a>を使い始める手助けをします。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.8.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>ネットワークポリシーをサポートしているネットワークプロバイダーが設定済みであることを確認してください。さまざまなネットワークプロバイダーがNetworkPolicyをサポートしています。次に挙げるのは一例です。</p>
<ul>
<li><a href=/docs/tasks/administer-cluster/network-policy-provider/calico-network-policy/>Calico</a></li>
<li><a href=/docs/tasks/administer-cluster/network-policy-provider/cilium-network-policy/>Cilium</a></li>
<li><a href=/docs/tasks/administer-cluster/network-policy-provider/kube-router-network-policy/>Kube-router</a></li>
<li><a href=/docs/tasks/administer-cluster/network-policy-provider/romana-network-policy/>Romana</a></li>
<li><a href=/docs/tasks/administer-cluster/network-policy-provider/weave-network-policy/>Weave Net</a></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 上記のリストは製品名のアルファベット順にソートされていて、推奨順や好ましい順にソートされているわけではありません。このページの例は、Kubernetesクラスターでこれらのどのプロバイダーを使用していても有効です。
</div>
<h2 id=nginx-deploymentを作成してservice経由で公開する><code>nginx</code> Deploymentを作成してService経由で公開する</h2>
<p>Kubernetesのネットワークポリシーの仕組みを理解するために、まずは<code>nginx</code> Deploymentを作成することから始めましょう。</p>
<pre><code class=language-console data-lang=console>kubectl create deployment nginx --image=nginx
</code></pre><pre><code class=language-none data-lang=none>deployment.apps/nginx created
</code></pre><p><code>nginx</code>という名前のService経由でDeploymentを公開します。</p>
<pre><code class=language-console data-lang=console>kubectl expose deployment nginx --port=80
</code></pre><pre><code class=language-none data-lang=none>service/nginx exposed
</code></pre><p>上記のコマンドを実行すると、nginx Podを持つDeploymentが作成され、そのDeploymentが<code>nginx</code>という名前のService経由で公開されます。<code>nginx</code>のPodおよびDeploymentは<code>default</code>名前空間の中にあります。</p>
<pre><code class=language-console data-lang=console>kubectl get svc,pod
</code></pre><pre><code class=language-none data-lang=none>NAME                        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGE
service/kubernetes          10.100.0.1    &lt;none&gt;        443/TCP    46m
service/nginx               10.100.0.16   &lt;none&gt;        80/TCP     33s

NAME                        READY         STATUS        RESTARTS   AGE
pod/nginx-701339712-e0qfq   1/1           Running       0          35s
</code></pre><h2 id=もう1つのpodからアクセスしてserviceを検証する>もう1つのPodからアクセスしてServiceを検証する</h2>
<p>これで、新しい<code>nginx</code>サービスに他のPodからアクセスできるようになったはずです。<code>default</code>名前空間内の他のPodから<code>nginx</code> Serviceにアクセスするために、busyboxコンテナを起動します。</p>
<pre><code class=language-console data-lang=console>kubectl run busybox --rm -ti --image=busybox -- /bin/sh
</code></pre><p>シェルの中で、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</code></pre></div><pre><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
remote file exists
</code></pre><h2 id=nginx-serviceへのアクセスを制限する><code>nginx</code> Serviceへのアクセスを制限する</h2>
<p><code>nginx</code> Serviceへのアクセスを制限するために、<code>access: true</code>というラベルが付いたPodだけがクエリできるようにします。次の内容でNetworkPolicyオブジェクトを作成してください。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/nginx-policy.yaml download=service/networking/nginx-policy.yaml><code>service/networking/nginx-policy.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-nginx-policy-yaml')" title="Copy service/networking/nginx-policy.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-nginx-policy-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>access-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>access</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>NetworkPolicyオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>でなければなりません。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このNetworkPolicyには、ポリシーを適用するPodのグループを選択するための<code>podSelector</code>が含まれています。このポリシーは、ラベル<code>app=nginx</code>の付いたPodを選択していることがわかります。このラベルは、<code>nginx</code> Deployment内のPodに自動的に追加されたものです。空の<code>podSelector</code>は、その名前空間内のすべてのPodを選択します。
</div>
<h2 id=serviceにポリシーを割り当てる>Serviceにポリシーを割り当てる</h2>
<p>kubectlを使って、上記の<code>nginx-policy.yaml</code>ファイルからNetworkPolicyを作成します。</p>
<pre><code class=language-console data-lang=console>kubectl apply -f https://k8s.io/examples/service/networking/nginx-policy.yaml
</code></pre><pre><code class=language-none data-lang=none>networkpolicy.networking.k8s.io/access-nginx created
</code></pre><h2 id=accessラベルが定義されていない状態でserviceへのアクセスをテストする>accessラベルが定義されていない状態でServiceへのアクセスをテストする</h2>
<p><code>nginx</code> Serviceに正しいラベルが付いていないPodからアクセスを試してみると、リクエストがタイムアウトします。</p>
<pre><code class=language-console data-lang=console>kubectl run busybox --rm -ti --image=busybox -- /bin/sh
</code></pre><p>シェルの中で、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</code></pre></div><pre><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
wget: download timed out
</code></pre><h2 id=accessラベルを定義して再テストする>accessラベルを定義して再テストする</h2>
<p>正しいラベルが付いたPodを作成すると、リクエストが許可されるようになるのがわかります。</p>
<pre><code class=language-console data-lang=console>kubectl run busybox --rm -ti --labels=&quot;access=true&quot; --image=busybox -- /bin/sh
</code></pre><p>シェルの中で、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</code></pre></div><pre><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
remote file exists
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8060aed5bf1172fa62199a4c306a4cd1>4.3.11 - ノードのトポロジー管理ポリシーを制御する</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>近年、CPUやハードウェア・アクセラレーターの組み合わせによって、レイテンシーが致命的となる実行や高いスループットを求められる並列計算をサポートするシステムが増えています。このようなシステムには、通信、科学技術計算、機械学習、金融サービス、データ分析などの分野のワークロードが含まれます。このようなハイブリッドシステムは、高い性能の環境で構成されます。</p>
<p>最高のパフォーマンスを引き出すために、CPUの分離やメモリーおよびデバイスの位置に関する最適化が求められます。しかしながら、Kubernetesでは、これらの最適化は分断されたコンポーネントによって処理されます。</p>
<p><em>トポロジーマネージャー</em> はKubeletコンポーネントの1つで最適化の役割を担い、コンポーネント群を調和して機能させます。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.18.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=トポロジーマネージャーはどのように機能するか>トポロジーマネージャーはどのように機能するか</h2>
<p>トポロジーマネージャー導入前は、KubernetesにおいてCPUマネージャーやデバイスマネージャーはそれぞれ独立してリソースの割り当てを決定します。
これは、マルチソケットのシステムでは望ましくない割り当てとなり、パフォーマンスやレイテンシーが求められるアプリケーションは、この望ましくない割り当てに悩まされます。
この場合の望ましくない例として、CPUやデバイスが異なるNUMAノードに割り当てられ、それによりレイテンシー悪化を招くことが挙げられます。</p>
<p>トポロジーマネージャーはKubeletコンポーネントであり、信頼できる情報源として振舞います。それによって、他のKubeletコンポーネントはトポロジーに沿ったリソース割り当ての選択を行うことができます。</p>
<p>トポロジーマネージャーは <em>Hint Providers</em> と呼ばれるコンポーネントのインターフェースを提供し、トポロジー情報を送受信します。トポロジーマネージャーは、ノード単位のポリシー群を保持します。ポリシーについて以下で説明します。</p>
<p>トポロジーマネージャーは <em>Hint Providers</em> からトポロジー情報を受け取ります。トポロジー情報は、利用可能なNUMAノードと優先割り当て表示を示すビットマスクです。トポロジーマネージャーのポリシーは、提供されたヒントに対して一連の操作を行い、ポリシーに沿ってヒントをまとめて最適な結果を得ます。もし、望ましくないヒントが保存された場合、ヒントの優先フィールドがfalseに設定されます。現在のポリシーでは、最も狭い優先マスクが優先されます。</p>
<p>選択されたヒントはトポロジーマネージャーの一部として保存されます。設定されたポリシーにしたがい、選択されたヒントに基づいてノードがPodを許可したり、拒否することができます。
トポロジーマネージャーに保存されたヒントは、<em>Hint Providers</em> が使用しリソース割り当てを決定します。</p>
<h3 id=トポロジーマネージャーの機能を有効にする>トポロジーマネージャーの機能を有効にする</h3>
<p>トポロジーマネージャーをサポートするには、<code>TopologyManager</code> <a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にする必要があります。Kubernetes 1.18ではデフォルトで有効です。</p>
<h2 id=トポロジーマネージャーのスコープとポリシー>トポロジーマネージャーのスコープとポリシー</h2>
<p>トポロジーマネージャは現在:</p>
<ul>
<li>全てのQoAクラスのPodを調整する</li>
<li>Hint Providerによって提供されたトポロジーヒントから、要求されたリソースを調整する</li>
</ul>
<p>これらの条件が合致した場合、トポロジーマネージャーは要求されたリソースを調整します。</p>
<p>この調整をどのように実行するかカスタマイズするために、トポロジーマネージャーは2つのノブを提供します: <code>スコープ</code> と<code>ポリシー</code>です。</p>
<p><code>スコープ</code>はリソースの配置を行う粒度を定義します(例:<code>pod</code>や<code>container</code>)。そして、<code>ポリシー</code>は調整を実行するための実戦略を定義します(<code>best-effort</code>, <code>restricted</code>, <code>single-numa-node</code>等)。</p>
<p>現在利用可能な<code>スコープ</code>と<code>ポリシー</code>の値について詳細は以下の通りです。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> PodのSpecにある他の要求リソースとCPUリソースを調整するために、CPUマネージャーを有効にし、適切なCPUマネージャーのポリシーがノードに設定されるべきです。<a href=/docs/tasks/administer-cluster/cpu-management-policies/>CPU管理ポリシー</a>を参照してください。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> PodのSpecにある他の要求リソースとメモリー（およびhugepage）リソースを調整するために、メモリーマネージャーを有効にし、適切なメモリーマネージャーポリシーがノードに設定されるべきです。<a href=/docs/tasks/administer-cluster/memory-manager/>メモリーマネージャー</a> のドキュメントを確認してください。
</div>
<h3 id=トポロジーマネージャーのスコープ>トポロジーマネージャーのスコープ</h3>
<p>トポロジーマネージャーは、以下の複数の異なるスコープでリソースの調整を行う事が可能です:</p>
<ul>
<li><code>container</code> (デフォルト)</li>
<li><code>pod</code></li>
</ul>
<p>いずれのオプションも、<code>--topology-manager-scope</code>フラグによって、kubelet起動時に選択できます。</p>
<h3 id=containerスコープ>containerスコープ</h3>
<p><code>container</code>スコープはデフォルトで使用されます。</p>
<p>このスコープでは、トポロジーマネージャーは連続した複数のリソース調整を実行します。つまり、Pod内の各コンテナは、分離された配置計算がされます。言い換えると、このスコープでは、コンテナを特定のNUMAノードのセットにグループ化するという概念はありません。実際には、トポロジーマネージャーは各コンテナのNUMAノードへの配置を任意に実行します。</p>
<p>コンテナをグループ化するという概念は、以下のスコープで設定・実行されます。例えば、<code>pod</code>スコープが挙げられます。</p>
<h3 id=podスコープ>podスコープ</h3>
<p><code>pod</code>スコープを選択するには、コマンドラインで<code>--topology-manager-scope=pod</code>オプションを指定してkubeletを起動します。</p>
<p>このスコープでは、Pod内全てのコンテナを共通のNUMAノードのセットにグループ化することができます。トポロジーマネージャーはPodをまとめて1つとして扱い、ポッド全体（全てのコンテナ）を単一のNUMAノードまたはNUMAノードの共通セットのいずれかに割り当てようとします。以下の例は、さまざまな場面でトポロジーマネージャーが実行する調整を示します:</p>
<ul>
<li>全てのコンテナは、単一のNUMAノードに割り当てられます。</li>
<li>全てのコンテナは、共有されたNUMAノードのセットに割り当てられます。</li>
</ul>
<p>Pod全体に要求される特定のリソースの総量は<a href=/ja/docs/concepts/workloads/pods/init-containers/#resources>有効なリクエスト／リミット</a>の式に従って計算されるため、この総量の値は以下の最大値となります。</p>
<ul>
<li>全てのアプリケーションコンテナのリクエストの合計。</li>
<li>リソースに対するinitコンテナのリクエストの最大値。</li>
</ul>
<p><code>pod</code>スコープと<code>single-numa-node</code>トポロジーマネージャーポリシーを併用することは、レイテンシーが重要なワークロードやIPCを行う高スループットのアプリケーションに対して特に有効です。両方のオプションを組み合わせることで、Pod内の全てのコンテナを単一のNUMAノードに配置できます。そのため、PodのNUMA間通信によるオーバーヘッドを排除することができます。</p>
<p><code>single-numa-node</code>ポリシーの場合、可能な割り当ての中に適切なNUMAノードのセットが存在する場合にのみ、Podが許可されます。上の例をもう一度考えてみましょう:</p>
<ul>
<li>1つのNUMAノードのみを含むセット - Podが許可されます。</li>
<li>2つ以上のNUMAノードを含むセット - Podが拒否されます(1つのNUMAノードの代わりに、割り当てを満たすために2つ以上のNUMAノードが必要となるため)。</li>
</ul>
<p>要約すると、トポロジーマネージャーはまずNUMAノードのセットを計算し、それをトポロジーマネージャーのポリシーと照合し、Podの拒否または許可を検証します。</p>
<h3 id=トポロジーマネージャーのポリシー>トポロジーマネージャーのポリシー</h3>
<p>トポロジーマネージャーは4つの調整ポリシーをサポートします。<code>--topology-manager-policy</code>というKubeletフラグを通してポリシーを設定できます。
4つのサポートされるポリシーがあります:</p>
<ul>
<li><code>none</code> (デフォルト)</li>
<li><code>best-effort</code></li>
<li><code>restricted</code></li>
<li><code>single-numa-node</code></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> トポロジーマネージャーが <strong>pod</strong> スコープで設定された場合、コンテナはポリシーによって、Pod全体の要求として反映します。
したがって、Podの各コンテナは <strong>同じ</strong> トポロジー調整と同じ結果となります。
</div>
<h3 id=policy-none>none ポリシー</h3>
<p>これはデフォルトのポリシーで、トポロジーの調整を実行しません。</p>
<h3 id=policy-best-effort>best-effort ポリシー</h3>
<p>Pod内の各コンテナに対して、<code>best-effort</code> トポロジー管理ポリシーが設定されたkubeletは、各Hint Providerを呼び出してそれらのリソースの可用性を検出します。
トポロジーマネージャーはこの情報を使用し、そのコンテナの推奨されるNUMAノードのアフィニティーを保存します。アフィニティーが優先されない場合、トポロジーマネージャーはこれを保存し、Podをノードに許可します。</p>
<p><em>Hint Providers</em> はこの情報を使ってリソースの割り当てを決定します。</p>
<h3 id=policy-restricted>restricted ポリシー</h3>
<p>Pod内の各コンテナに対して、<code>restricted</code> トポロジー管理ポリシーが設定されたkubeletは各Hint Providerを呼び出してそれらのリソースの可用性を検出します。
トポロジーマネージャーはこの情報を使用し、そのコンテナの推奨されるNUMAノードのアフィニティーを保存します。アフィニティーが優先されない場合、トポロジーマネージャーはPodをそのノードに割り当てることを拒否します。この結果、PodはPodの受付失敗となり<code>Terminated</code> 状態になります。</p>
<p>Podが一度<code>Terminated</code>状態になると、KubernetesスケジューラーはPodの再スケジューリングを試み <strong>ません</strong> 。Podの再デプロイをするためには、ReplicasetかDeploymenを使用してください。<code>Topology Affinity</code>エラーとなったpodを再デプロイするために、外部のコントロールループを実行することも可能です。</p>
<p>Podが許可されれば、 <em>Hint Providers</em> はこの情報を使ってリソースの割り当てを決定します。</p>
<h3 id=policy-single-numa-node>single-numa-node ポリシー</h3>
<p>Pod内の各コンテナに対して、<code>single-numa-node</code>トポロジー管理ポリシーが設定されたkubeletは各Hint Prociderを呼び出してそれらのリソースの可用性を検出します。
トポロジーマネージャーはこの情報を使用し、単一のNUMAノードアフィニティが可能かどうか決定します。
可能な場合、トポロジーマネージャーは、この情報を保存し、<em>Hint Providers</em> はこの情報を使ってリソースの割り当てを決定します。
不可能な場合、トポロジーマネージャーは、Podをそのノードに割り当てることを拒否します。この結果、Pod は Pod の受付失敗となり<code>Terminated</code>状態になります。</p>
<p>Podが一度<code>Terminated</code>状態になると、KubernetesスケジューラーはPodの再スケジューリングを試み<strong>ません</strong>。Podの再デプロイをするためには、ReplicasetかDeploymentを使用してください。<code>Topology Affinity</code>エラーとなったpodを再デプロイするために、外部のコントロールループを実行することも可能です。</p>
<h3 id=podとトポロジー管理ポリシーの関係>Podとトポロジー管理ポリシーの関係</h3>
<p>以下のようなpodのSpecで定義されるコンテナを考えます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div><p><code>requests</code>も<code>limits</code>も定義されていないため、このPodは<code>BestEffort</code>QoSクラスで実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>requestsがlimitsより小さい値のため、このPodは<code>Burstable</code>QoSクラスで実行します。</p>
<p>選択されたポリシーが<code>none</code>以外の場合、トポロジーマネージャーは、これらのPodのSpecを考慮します。トポロジーマネージャーは、Hint Providersからトポロジーヒントを取得します。CPUマネージャーポリシーが<code>static</code>の場合、デフォルトのトポロジーヒントを返却します。これらのPodは明示的にCPUリソースを要求していないからです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/device</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/device</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>整数値でCPUリクエストを指定されたこのPodは、<code>requests</code>が<code>limits</code>が同じ値のため、<code>Guaranteed</code>QoSクラスで実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;300m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/device</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;300m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/device</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>CPUの一部をリクエストで指定されたこのPodは、<code>requests</code>が<code>limits</code>が同じ値のため、<code>Guaranteed</code>QoSクラスで実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/deviceA</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/deviceB</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/deviceA</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/deviceB</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>CPUもメモリもリクエスト値がないため、このPodは <code>BestEffort</code> QoSクラスで実行します。</p>
<p>トポロジーマネージャーは、上記Podを考慮します。トポロジーマネージャーは、Hint ProvidersとなるCPUマネージャーとデバイスマネージャーに問い合わせ、トポロジーヒントを取得します。</p>
<p>整数値でCPU要求を指定された<code>Guaranteed</code>QoSクラスのPodの場合、<code>static</code>が設定されたCPUマネージャーポリシーは、排他的なCPUに関するトポロジーヒントを返却し、デバイスマネージャーは要求されたデバイスのヒントを返します。</p>
<p>CPUの一部を要求を指定された<code>Guaranteed</code>QoSクラスのPodの場合、排他的ではないCPU要求のため<code>static</code>が設定されたCPUマネージャーポリシーはデフォルトのトポロジーヒントを返却します。デバイスマネージャーは要求されたデバイスのヒントを返します。</p>
<p>上記の<code>Guaranteed</code>QoSクラスのPodに関する2ケースでは、<code>none</code>で設定されたCPUマネージャーポリシーは、デフォルトのトポロジーヒントを返却します。</p>
<p><code>BestEffort</code>QoSクラスのPodの場合、<code>static</code>が設定されたCPUマネージャーポリシーは、CPUの要求がないためデフォルトのトポロジーヒントを返却します。デバイスマネージャーは要求されたデバイスごとのヒントを返します。</p>
<p>トポロジーマネージャーはこの情報を使用してPodに最適なヒントを計算し保存します。保存されたヒントは Hint Providersが使用しリソースを割り当てます。</p>
<h3 id=既知の制限>既知の制限</h3>
<ol>
<li>
<p>トポロジーマネージャーが許容するNUMAノードの最大値は8です。8より多いNUMAノードでは、可能なNUMAアフィニティを列挙しヒントを生成する際に、生成する状態数が爆発的に増加します。</p>
</li>
<li>
<p>スケジューラーはトポロジーを意識しません。そのため、ノードにスケジュールされた後に実行に失敗する可能性があります。</p>
</li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a8f6511197efcd7d0db80ade49620f9d>4.3.12 - 拡張リソースをNodeにアドバタイズする</h1>
<p>このページでは、Nodeに対して拡張リソースを指定する方法を説明します。拡張リソースを利用すると、Kubernetesにとって未知のノードレベルのリソースをクラスター管理者がアドバタイズできるようになります。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=nodeの名前を取得する>Nodeの名前を取得する</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes
</code></pre></div><p>この練習で使いたいNodeを1つ選んでください。</p>
<h2 id=nodeの1つで新しい拡張リソースをアドバタイズする>Nodeの1つで新しい拡張リソースをアドバタイズする</h2>
<p>Node上の新しい拡張リソースをアドバタイズするには、HTTPのPATCHリクエストをKubernetes APIサーバーに送ります。たとえば、Nodeの1つに4つのドングルが接続されているとします。以下に、4つのドングルリソースをNodeにアドバタイズするPATCHリクエストの例を示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>PATCH /api/v1/nodes/&lt;選択したNodeの名前&gt;/status HTTP/1.1
Accept: application/json
Content-Type: application/json-patch+json
Host: k8s-master:8080

<span style=color:#666>[</span>
  <span style=color:#666>{</span>
    <span style=color:#b44>&#34;op&#34;</span>: <span style=color:#b44>&#34;add&#34;</span>,
    <span style=color:#b44>&#34;path&#34;</span>: <span style=color:#b44>&#34;/status/capacity/example.com~1dongle&#34;</span>,
    <span style=color:#b44>&#34;value&#34;</span>: <span style=color:#b44>&#34;4&#34;</span>
  <span style=color:#666>}</span>
<span style=color:#666>]</span>
</code></pre></div><p>Kubernetesは、ドングルとは何かも、ドングルが何に利用できるのかを知る必要もないことに注意してください。上のPATCHリクエストは、ただNodeが4つのドングルと呼ばれるものを持っているとKubernetesに教えているだけです。</p>
<p>Kubernetes APIサーバーに簡単にリクエストを送れるように、プロキシーを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy
</code></pre></div><p>もう1つのコマンドウィンドウを開き、HTTPのPATCHリクエストを送ります。<code>&lt;選択したNodeの名前></code>の部分は、選択したNodeの名前に置き換えてください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1dongle&#34;, &#34;value&#34;: &#34;4&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>http://localhost:8001/api/v1/nodes/&lt;選択したNodeの名前&gt;/status
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 上のリクエストにある<code>~1</code>は、PATCHのパスにおける<code>/</code>という文字をエンコーディングしたものです。JSON-Patch内のoperationのpathはJSON-Pointerとして解釈されます。詳細については、<a href=https://tools.ietf.org/html/rfc6901>IETF RFC 6901</a>のsection 3を読んでください。
</div>
<p>出力には、Nodeがキャパシティー4のdongleを持っていることが示されます。</p>
<pre><code>&quot;capacity&quot;: {
  &quot;cpu&quot;: &quot;2&quot;,
  &quot;memory&quot;: &quot;2049008Ki&quot;,
  &quot;example.com/dongle&quot;: &quot;4&quot;,
</code></pre><p>Nodeの説明を確認します。</p>
<pre><code>kubectl describe node &lt;選択したNodeの名前&gt;
</code></pre><p>出力には、再びdongleリソースが表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb>  </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb>  </span>2049008Ki<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb>  </span><span style=color:#666>4</span><span style=color:#bbb>
</span></code></pre></div><p>これで、アプリケーション開発者は特定の数のdongleをリクエストするPodを作成できるようになりました。詳しくは、<a href=/docs/tasks/configure-pod-container/extended-resource/>拡張リソースをコンテナに割り当てる</a>を読んでください。</p>
<h2 id=議論>議論</h2>
<p>拡張リソースは、メモリやCPUリソースと同様のものです。たとえば、Nodeが持っている特定の量のメモリやCPUがNode上で動作している他のすべてのコンポーネントと共有されるのと同様に、Nodeが搭載している特定の数のdongleが他のすべてのコンポーネントと共有されます。そして、アプリケーション開発者が特定の量のメモリとCPUをリクエストするPodを作成できるのと同様に、Nodeが搭載している特定の数のdongleをリクエストするPodが作成できます。</p>
<p>拡張リソースはKubernetesには詳細を意図的に公開しないため、Kubernetesは拡張リソースの実体をまったく知りません。Kubernetesが知っているのは、Nodeが特定の数の拡張リソースを持っているということだけです。拡張リソースは整数値でアドバタイズしなければなりません。たとえば、Nodeは4つのdongleをアドバタイズできますが、4.5のdongleというのはアドバタイズできません。</p>
<h3 id=storageの例>Storageの例</h3>
<p>Nodeに800GiBの特殊なディスクストレージがあるとします。この特殊なストレージの名前、たとえばexample.com/special-storageという名前の拡張リソースが作れます。そして、そのなかの一定のサイズ、たとえば100GiBのチャンクをアドバタイズできます。この場合、Nodeはexample.com/special-storageという種類のキャパシティ8のリソースを持っているとアドバタイズします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/special-storage</span>:<span style=color:#bbb> </span><span style=color:#666>8</span><span style=color:#bbb>
</span></code></pre></div><p>特殊なストレージに任意のサイズのリクエストを許可したい場合、特殊なストレージを1バイトのサイズのチャンクでアドバタイズできます。その場合、example.com/special-storageという種類の800Giのリソースとしてアドバタイズします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/special-storage</span>:<span style=color:#bbb>  </span>800Gi<span style=color:#bbb>
</span></code></pre></div><p>すると、コンテナは好きなバイト数の特殊なストレージを最大800Giまでリクエストできるようになります。</p>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>以下に、dongleのアドバタイズをNodeから削除するPATCHリクエストを示します。</p>
<pre><code>PATCH /api/v1/nodes/&lt;選択したNodeの名前&gt;/status HTTP/1.1
Accept: application/json
Content-Type: application/json-patch+json
Host: k8s-master:8080

[
  {
    &quot;op&quot;: &quot;remove&quot;,
    &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;,
  }
]
</code></pre><p>Kubernetes APIサーバーに簡単にリクエストを送れるように、プロキシーを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy
</code></pre></div><p>もう1つのコマンドウィンドウで、HTTPのPATCHリクエストを送ります。<code>&lt;選択したNodeの名前></code>の部分は、選択したNodeの名前に置き換えてください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1dongle&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>http://localhost:8001/api/v1/nodes/&lt;選択したNodeの名前&gt;/status
</code></pre></div><p>dongleのアドバタイズが削除されたことを検証します。</p>
<pre><code>kubectl describe node &lt;選択したNodeの名前&gt; | grep dongle
</code></pre><p>(出力には何も表示されないはずです)</p>
<h2 id=次の項目>次の項目</h2>
<h3 id=アプリケーション開発者向け>アプリケーション開発者向け</h3>
<ul>
<li><a href=/ja/docs/tasks/configure-pod-container/extended-resource/>拡張リソースをコンテナに割り当てる</a></li>
</ul>
<h3 id=クラスター管理者向け>クラスター管理者向け</h3>
<ul>
<li><a href=/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>Namespaceに対してメモリの最小値と最大値の制約を設定する</a></li>
<li><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>Namespaceに対してCPUの最小値と最大値の制約を設定する</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-aa0731e8aa8e2f6cc9e3c1a5e9895863>4.4 - Kubernetesオブジェクトの管理</h1>
<div class=lead>Kubernetes APIと対話するための宣言型および命令型のパラダイム。</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-94f49ece137035764368f22a98942872>4.5 - Secretの管理</h1>
<div class=lead>Secretを使用した機密設定データの管理</div>
</div>
<div class=td-content>
<h1 id=pg-0ed63ce3c9665aed7ff5a560ff1da843>4.5.1 - kubectlを使用してSecretを管理する</h1>
<div class=lead>kubectlコマンドラインを使用してSecretを作成する</div>
<h2 id=始める前に>始める前に</h2>
<p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
<h2 id=secretを作成する>Secretを作成する</h2>
<p><code>Secret</code>はデータベースにアクセスするためにPodが必要とするユーザー資格情報を含めることができます。
たとえば、データベース接続文字列はユーザー名とパスワードで構成されます。
ユーザー名はローカルマシンの<code>./username.txt</code>に、パスワードは<code>./password.txt</code>に保存します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> &gt; ./username.txt
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> &gt; ./password.txt
</code></pre></div><p>上記の2つのコマンドの<code>-n</code>フラグは、生成されたファイルにテキスト末尾の余分な改行文字が含まれないようにします。
<code>kubectl</code>がファイルを読み取り、内容をbase64文字列にエンコードすると、余分な改行文字もエンコードされるため、これは重要です。</p>
<p><code>kubectl create secret</code>コマンドはこれらのファイルをSecretにパッケージ化し、APIサーバー上にオブジェクトを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span>./username.txt <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span>./password.txt
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>secret/db-user-pass created
</code></pre><p>ファイル名がデフォルトのキー名になります。オプションで<code>--from-file=[key=]source</code>を使用してキー名を設定できます。たとえば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>./username.txt <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>./password.txt
</code></pre></div><p><code>--from-file</code>に指定したファイルに含まれるパスワードの特殊文字をエスケープする必要はありません。</p>
<p>また、<code>--from-literal=&lt;key>=&lt;value></code>タグを使用してSecretデータを提供することもできます。
このタグは、複数のキーと値のペアを提供するために複数回指定することができます。
<code>$</code>、<code>\</code>、<code>*</code>、<code>=</code>、<code>!</code>などの特殊文字は<a href=https://en.wikipedia.org/wiki/Shell_(computing)>シェル</a>によって解釈されるため、エスケープを必要とすることに注意してください。
ほとんどのシェルでは、パスワードをエスケープする最も簡単な方法は、シングルクォート(<code>'</code>)で囲むことです。
たとえば、実際のパスワードが<code>S!B\*d$zDsb=</code>の場合、次のようにコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;S!B\*d$zDsb=&#39;</span>
</code></pre></div><h2 id=secretを検証する>Secretを検証する</h2>
<p>Secretが作成されたことを確認できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secrets
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>NAME                  TYPE                                  DATA      AGE
db-user-pass          Opaque                                2         51s
</code></pre><p><code>Secret</code>の説明を参照できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe secrets/db-user-pass
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>Name:            db-user-pass
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

Data
====
password:    12 bytes
username:    5 bytes
</code></pre><p><code>kubectl get</code>と<code>kubectl describe</code>コマンドはデフォルトでは<code>Secret</code>の内容を表示しません。
これは、<code>Secret</code>が不用意に他人にさらされたり、ターミナルログに保存されたりしないようにするためです。</p>
<h2 id=decoding-secret>Secretをデコードする </h2>
<p>先ほど作成したSecretの内容を見るには、以下のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secret db-user-pass -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data}&#39;</span>
</code></pre></div><p>出力は次のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;password&#34;</span>:<span style=color:#b44>&#34;MWYyZDFlMmU2N2Rm&#34;</span>,<span style=color:green;font-weight:700>&#34;username&#34;</span>:<span style=color:#b44>&#34;YWRtaW4=&#34;</span>}
</code></pre></div><p><code>password</code>のデータをデコードします:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;MWYyZDFlMmU2N2Rm&#39;</span> | base64 --decode
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>1f2d1e2e67df
</code></pre><h2 id=クリーンアップ>クリーンアップ</h2>
<p>作成したSecretを削除するには次のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete secret db-user-pass
</code></pre></div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/configuration/secret/>Secretのコンセプト</a>を読む</li>
<li><a href=/ja/docs/tasks/configmap-secret/managing-secret-using-config-file/>設定ファイルを使用してSecretを管理する</a>方法を知る</li>
<li><a href=/docs/tasks/configmap-secret/managing-secret-using-kustomize/>kustomizeを使用してSecretを管理する</a>方法を知る</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e841cf91fd3566db1e86143ed7a9e13c>4.5.2 - 設定ファイルを使用してSecretを管理する</h1>
<div class=lead>リソース設定ファイルを使用してSecretを作成する</div>
<h2 id=始める前に>始める前に</h2>
<p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
<h2 id=設定ファイルを作成する>設定ファイルを作成する</h2>
<p>あらかじめYAMLまたはJSON形式でSecretのマニフェストを作成したうえで、オブジェクトを作成することができます。
<a href=/docs/reference/generated/kubernetes-api/v1.22/#secret-v1-core>Secret</a>リソースには、<code>data</code>と<code>stringData</code>の2つのマップが含まれています。
<code>data</code>フィールドは任意のデータを格納するのに使用され、base64でエンコードされます。
<code>stringData</code>フィールドは利便性のために用意されており、Secretデータをエンコードされていない文字列として提供することができます。
<code>data</code>と<code>stringData</code>のキーは、英数字、<code>-</code>、<code>_</code>、<code>.</code>で構成されている必要があります。</p>
<p>たとえば、<code>data</code>フィールドを使用して2つの文字列をSecretに格納するには、次のように文字列をbase64に変換します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> | base64
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>YWRtaW4=
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> | base64
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>MWYyZDFlMmU2N2Rm
</code></pre><p>以下のようなSecret設定ファイルを記述します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></code></pre></div><p>なお、Secretオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> SecretデータのシリアライズされたJSONおよびYAMLの値は、base64文字列としてエンコードされます。
文字列中の改行は不正で、含まれていてはなりません。
Darwin/macOSで<code>base64</code>ユーティリティーを使用する場合、長い行を分割するために<code>-b</code>オプションを使用するのは避けるべきです。
逆に、Linux ユーザーは、<code>base64</code> コマンドにオプション<code>-w 0</code>を追加するか、<code>-w</code>オプションが利用できない場合には、パイプライン<code>base64 | tr -d '\n'</code>を追加する<em>必要があります</em>。
</div>
<p>特定のシナリオでは、代わりに<code>stringData</code>フィールドを使用できます。
このフィールドでは、base64エンコードされていない文字列を直接Secretに入れることができ、Secretの作成時や更新時には、その文字列がエンコードされます。</p>
<p>たとえば、設定ファイルを保存するためにSecretを使用しているアプリケーションをデプロイする際に、デプロイプロセス中に設定ファイルの一部を入力したい場合などが考えられます。</p>
<p>たとえば、次のような設定ファイルを使用しているアプリケーションの場合:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiUrl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my.api.com/api/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;user&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;password&gt;&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>次のような定義でSecretに格納できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    apiUrl: &#34;https://my.api.com/api/v1&#34;
</span><span style=color:#b44;font-style:italic>    username: &lt;user&gt;
</span><span style=color:#b44;font-style:italic>    password: &lt;password&gt;</span><span style=color:#bbb>    
</span></code></pre></div><h2 id=secretを作成する>Secretを作成する</h2>
<p><a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>でSecretを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f ./secret.yaml
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>secret/mysecret created
</code></pre><h2 id=secretを確認する>Secretを確認する</h2>
<p><code>stringData</code>フィールドは、書き込み専用の便利なフィールドです。Secretを取得する際には決して出力されません。たとえば、次のようなコマンドを実行した場合:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secret mysecret -o yaml
</code></pre></div><p>出力は次のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>YXBpVXJsOiAiaHR0cHM6Ly9teS5hcGkuY29tL2FwaS92MSIKdXNlcm5hbWU6IHt7dXNlcm5hbWV9fQpwYXNzd29yZDoge3twYXNzd29yZH19<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:40:59Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7225&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>c280ad2e-e916-11e8-98f2-025000000001<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></code></pre></div><p><code>kubectl get</code>と<code>kubectl describe</code>コマンドはデフォルトではSecretの内容を表示しません。
これは、Secretが不用意に他人にさらされたり、ターミナルログに保存されたりしないようにするためです。
エンコードされたデータの実際の内容を確認するには、<a href=/ja/docs/tasks/configmap-secret/managing-secret-using-kubectl/#decoding-secret>Secretのデコード</a>を参照してください。</p>
<p><code>username</code>などのフィールドが<code>data</code>と<code>stringData</code>の両方に指定されている場合は、<code>stringData</code>の値が使われます。
たとえば、以下のようなSecretの定義の場合:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>administrator<span style=color:#bbb>
</span></code></pre></div><p>結果は以下の通りです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW5pc3RyYXRvcg==<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:46:46Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7579&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>91460ecb-e917-11e8-98f2-025000000001<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></code></pre></div><p><code>YWRtaW5pc3RyYXRvcg==</code>をデコードすると<code>administrator</code>となります。</p>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>作成したSecretを削除するには次のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete secret mysecret
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/configuration/secret/>Secretのコンセプト</a>を読む</li>
<li><a href=/ja/docs/tasks/configmap-secret/managing-secret-using-kubectl/>kubectlを使用してSecretを管理する</a>方法を知る</li>
<li><a href=/docs/tasks/configmap-secret/managing-secret-using-kustomize/>kustomizeを使用してSecretを管理する</a>方法を知る</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a0ff2e3ba8af5670d5dc3d94c4bd0a68>4.5.3 - Kustomizeを使用してSecretを管理する</h1>
<div class=lead>kustomization.yamlを使用してSecretを作成する</div>
<p>Kubernetes v1.14以降、<code>kubectl</code>は<a href=/docs/tasks/manage-kubernetes-objects/kustomization/>Kustomizeを使ったオブジェクト管理</a>をサポートしています。
KustomizeはSecretやConfigMapを作成するためのリソースジェネレーターを提供します。
Kustomizeジェネレーターは、ディレクトリ内の<code>kustomization.yaml</code>ファイルで指定します。
Secretを生成したら、<code>kubectl apply</code>でAPIサーバー上にSecretを作成します。</p>
<h2 id=始める前に>始める前に</h2>
<p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
<h2 id=kustomizationファイルを作成する>Kustomizationファイルを作成する</h2>
<p><code>kustomization.yaml</code>ファイルの中で<code>secretGenerator</code>を定義し、他の既存のファイルを参照することで、Secretを生成することができます。
たとえば、以下のkustomizationファイルは<code>./username.txt</code>と<code>./password.txt</code>を参照しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>secretGenerator</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user-pass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>files</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- username.txt<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- password.txt<span style=color:#bbb>
</span></code></pre></div><p>また、<code>kustomization.yaml</code>ファイルの中でリテラルを指定して<code>secretGenerator</code>を定義することもできます。
たとえば、以下の<code>kustomization.yaml</code>ファイルには<code>username</code>と<code>password</code>の2つのリテラルが含まれています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>secretGenerator</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user-pass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>literals</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- username=admin<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- password=1f2d1e2e67df<span style=color:#bbb>
</span></code></pre></div><p>また、<code>kustomization.yaml</code>ファイルに<code>.env</code>ファイルを用意して<code>secretGenerator</code>を定義することもできます。
たとえば、以下の<code>kustomization.yaml</code>ファイルは、<code>.env.secret</code>ファイルからデータを取り込みます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>secretGenerator</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user-pass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>envs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- .env.secret<span style=color:#bbb>
</span></code></pre></div><p>なお、いずれの場合も、値をbase64エンコードする必要はありません。</p>
<h2 id=secretを作成する>Secretを作成する</h2>
<p><code>kustomization.yaml</code>を含むディレクトリを適用して、Secretを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>secret/db-user-pass-96mffmfh4k created
</code></pre><p>なお、Secretを生成する際には、データをハッシュ化し、そのハッシュ値を付加することでSecret名を生成します。
これにより、データが変更されるたびに、新しいSecretが生成されます。</p>
<h2 id=作成したsecretを確認する>作成したSecretを確認する</h2>
<p>Secretが作成されたことを確認できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secrets
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>NAME                             TYPE                                  DATA      AGE
db-user-pass-96mffmfh4k          Opaque                                2         51s
</code></pre><p>Secretの説明を参照できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe secrets/db-user-pass-96mffmfh4k
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>Name:            db-user-pass-96mffmfh4k
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

Data
====
password.txt:    12 bytes
username.txt:    5 bytes
</code></pre><p><code>kubectl get</code>と<code>kubectl describe</code>コマンドはデフォルトではSecretの内容を表示しません。
これは、Secretが不用意に他人にさらされたり、ターミナルログに保存されたりしないようにするためです。
エンコードされたデータの実際の内容を確認するには、<a href=/ja/docs/tasks/configmap-secret/managing-secret-using-kubectl/#decoding-secret>Secretのデコード</a>を参照してください。</p>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>作成したSecretを削除するには次のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete secret db-user-pass-96mffmfh4k
</code></pre></div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/configuration/secret/>Secretのコンセプト</a>を読む</li>
<li><a href=/ja/docs/tasks/configmap-secret/managing-secret-using-kubectl/>kubectlを使用してSecretを管理する</a>方法を知る</li>
<li><a href=/ja/docs/tasks/configmap-secret/managing-secret-using-config-file/>設定ファイルを使用してSecretを管理する</a>方法を知る</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-866924fa095f897ede8dfdcab9e97942>4.6 - アプリケーションへのデータ注入</h1>
<div class=lead>ワークロードを実行するPodの構成とその他のデータを指定します。</div>
</div>
<div class=td-content>
<h1 id=pg-82c93897176489678232542102daea40>4.6.1 - コンテナの環境変数の定義</h1>
<p>このページでは、Kubernetes Podでコンテナの環境変数を定義する方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=define-an-environment-variable-for-a-container>コンテナの環境変数を定義する</h2>
<p>Podを作成するとき、そのPodで実行するコンテナに環境変数を設定することができます。環境変数を設定するには、設定ファイルに <code>env</code> または <code>envFrom</code> フィールドを含めます。</p>
<p>この演習では、1つのコンテナを実行するPodを作成します。Podの設定ファイルには、名前 <code>DEMO_GREETING</code>、値 <code>"Hello from the environment"</code>を持つ環境変数が定義されています。Podの設定マニフェストを以下に示します:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/inject/envars.yaml download=pods/inject/envars.yaml><code>pods/inject/envars.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-envars-yaml')" title="Copy pods/inject/envars.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-envars-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envar-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>purpose</span>:<span style=color:#bbb> </span>demonstrate-envars<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envar-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>DEMO_GREETING<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Hello from the environment&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>DEMO_FAREWELL<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Such a sweet sorrow&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>マニフェストに基づいてPodを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/inject/envars.yaml
</code></pre></div></li>
<li>
<p>実行中のPodを一覧表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>purpose</span><span style=color:#666>=</span>demonstrate-envars
</code></pre></div><p>出力は以下のようになります:</p>
<pre><code>NAME            READY     STATUS    RESTARTS   AGE
envar-demo      1/1       Running   0          9s
</code></pre></li>
<li>
<p>Podで実行しているコンテナのシェルを取得します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it envar-demo -- /bin/bash
</code></pre></div></li>
<li>
<p>シェルで<code>printenv</code>コマンドを実行すると、環境変数の一覧が表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># コンテナ内のシェルで以下のコマンドを実行します</span>
printenv
</code></pre></div><p>出力は以下のようになります:</p>
<pre><code>NODE_VERSION=4.4.2
EXAMPLE_SERVICE_PORT_8080_TCP_ADDR=10.3.245.237
HOSTNAME=envar-demo
...
DEMO_GREETING=Hello from the environment
DEMO_FAREWELL=Such a sweet sorrow
</code></pre></li>
<li>
<p>シェルを終了するには、<code>exit</code>と入力します。</p>
</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>env</code>または<code>envFrom</code>フィールドを使用して設定された環境変数は、コンテナイメージで指定された環境変数を上書きします。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 環境変数は相互に参照でき、循環して使用可能です。使用する前に順序に注意してください。
</div>
<h2 id=using-environment-variables-inside-of-your-config>設定の中で環境変数を使用する</h2>
<p>Podの設定で定義した環境変数は、Podのコンテナに設定したコマンドや引数など、設定の他の場所で使用することができます。以下の設定例では、環境変数<code>GREETING</code>、<code>HONORORIFIC</code>、<code>NAME</code>にそれぞれ <code>Warm greetings to</code>、<code>The Most Honorable</code>、<code>Kubernetes</code>を設定しています。これらの環境変数は、<code>env-print-demo</code>コンテナに渡されるCLI引数で使われます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>print-greeting<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-print-demo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>bash<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>GREETING<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Warm greetings to&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>HONORIFIC<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;The Most Honorable&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>NAME<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Kubernetes&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;echo&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;$(GREETING) $(HONORIFIC) $(NAME)&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>作成されると、コンテナ上で<code>echo Warm greetings to The Most Honorable Kubernetes</code>というコマンドが実行されます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>環境変数</a>の詳細</li>
<li><a href=/docs/concepts/configuration/secret/#using-secrets-as-environment-variables>Secretを環境変数として使用する</a>詳細</li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#envvarsource-v1-core>EnvVarSource</a>をご覧ください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-66c0456fdbef5e5116dd606d1e6f73cc>4.6.2 - 環境変数によりコンテナにPod情報を共有する</h1>
<p>このページでは、Podが内部で実行しているコンテナに自身の情報を共有する方法を説明します。環境変数ではPodのフィールドとコンテナのフィールドを共有することができます。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=the-downward-api>Downward API</h2>
<p>Podとコンテナのフィールドを実行中のコンテナに共有する方法は2つあります:</p>
<ul>
<li>環境変数</li>
<li><a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#the-downward-api>ボリュームファイル</a></li>
</ul>
<p>これら2つの方法を合わせて、Podとコンテナフィールドを共有する方法を<em>Downward API</em>と呼びます。</p>
<h2 id=use-pod-fields-as-values-for-environment-variables>Podフィールドを環境変数の値として使用する</h2>
<p>この演習では、1つのコンテナを持つPodを作成します。Podの設定ファイルは次のとおりです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/inject/dapi-envars-pod.yaml download=pods/inject/dapi-envars-pod.yaml><code>pods/inject/dapi-envars-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-dapi-envars-pod-yaml')" title="Copy pods/inject/dapi-envars-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-dapi-envars-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-envars-fieldref<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- while true; do<span style=color:#bbb>
</span><span style=color:#bbb>          </span>echo -en &#39;\n&#39;;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>printenv MY_NODE_NAME MY_POD_NAME MY_POD_NAMESPACE;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>printenv MY_POD_IP MY_POD_SERVICE_ACCOUNT;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>sleep 10;<span style=color:#bbb>
</span><span style=color:#bbb>        </span>done;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_NODE_NAME<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>spec.nodeName<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_NAME<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_NAMESPACE<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.namespace<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_IP<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>status.podIP<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_SERVICE_ACCOUNT<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>spec.serviceAccountName<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルには、5つの環境変数があります。<code>env</code>フィールドは<a href=/docs/reference/generated/kubernetes-api/v1.22/#envvar-v1-core>EnvVars</a>の配列です。配列の最初の要素では、環境変数<code>MY_NODE_NAME</code>の値をPodの<code>spec.nodeName</code>フィールドから取得することを指定します。同様に、他の環境変数もPodのフィールドから名前を取得します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> この例のフィールドはPodのフィールドです。これらはPod内のコンテナのフィールドではありません。
</div>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-envars-pod.yaml
</code></pre></div><p>Podのコンテナが実行されていることを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>コンテナのログを表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs dapi-envars-fieldref
</code></pre></div><p>出力には、選択した環境変数の値が表示されます:</p>
<pre><code>minikube
dapi-envars-fieldref
default
172.17.0.4
default
</code></pre><p>これらの値がログにある理由を確認するには、設定ファイルの<code>command</code>および<code>args</code>フィールドを確認してください。コンテナが起動すると、5つの環境変数の値が標準出力に書き込まれます。これを10秒ごとに繰り返します。</p>
<p>次に、Podで実行しているコンテナへのシェルを取得します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it dapi-envars-fieldref -- sh
</code></pre></div><p>シェルで環境変数を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/# printenv
</code></pre></div><p>出力は、特定の環境変数にPodフィールドの値が割り当てられていることを示しています:</p>
<pre><code>MY_POD_SERVICE_ACCOUNT=default
...
MY_POD_NAMESPACE=default
MY_POD_IP=172.17.0.4
...
MY_NODE_NAME=minikube
...
MY_POD_NAME=dapi-envars-fieldref
</code></pre><h2 id=use-container-fields-as-values-for-environment-variables>コンテナフィールドを環境変数の値として使用する</h2>
<p>前の演習では、環境変数の値としてPodフィールドを使用しました。次の演習では、環境変数の値としてコンテナフィールドを使用します。これは、1つのコンテナを持つPodの設定ファイルです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/inject/dapi-envars-container.yaml download=pods/inject/dapi-envars-container.yaml><code>pods/inject/dapi-envars-container.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-dapi-envars-container-yaml')" title="Copy pods/inject/dapi-envars-container.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-dapi-envars-container-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-envars-resourcefieldref<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox:1.24<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- while true; do<span style=color:#bbb>
</span><span style=color:#bbb>          </span>echo -en &#39;\n&#39;;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>printenv MY_CPU_REQUEST MY_CPU_LIMIT;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>printenv MY_MEM_REQUEST MY_MEM_LIMIT;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>sleep 10;<span style=color:#bbb>
</span><span style=color:#bbb>        </span>done;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;32Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;125m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_CPU_REQUEST<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>requests.cpu<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_CPU_LIMIT<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.cpu<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_MEM_REQUEST<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>requests.memory<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_MEM_LIMIT<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.memory<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルには、4つの環境変数があります。<code>env</code>フィールドは<a href=/docs/reference/generated/kubernetes-api/v1.22/#envvar-v1-core>EnvVars</a>の配列です。配列の最初の要素では、環境変数<code>MY_CPU_REQUEST</code>の値を<code>test-container</code>という名前のコンテナの<code>requests.cpu</code>フィールドから取得することを指定します。同様に、他の環境変数もコンテナのフィールドから値を取得します。</p>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-envars-container.yaml
</code></pre></div><p>Podのコンテナが実行されていることを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>コンテナのログを表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs dapi-envars-resourcefieldref
</code></pre></div><p>出力には、選択した環境変数の値が表示されます:</p>
<pre><code>1
1
33554432
67108864
</code></pre><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/tasks/inject-data-application/define-environment-variable-container/>コンテナの環境変数の定義</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#podspec-v1-core>PodSpec</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#container-v1-core>Container</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#envvar-v1-core>EnvVar</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#envvarsource-v1-core>EnvVarSource</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#objectfieldselector-v1-core>ObjectFieldSelector</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#resourcefieldselector-v1-core>ResourceFieldSelector</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a78a5e7e765fd8c49c8f7c0d72499f72>4.7 - アプリケーションの実行</h1>
<div class=lead>ステートレスアプリケーションとステートフルアプリケーションの両方を実行および管理します。</div>
</div>
<div class=td-content>
<h1 id=pg-790ea02857492b3a822e981e93e3a98b>4.7.1 - Deploymentを使用してステートレスアプリケーションを実行する</h1>
<p>このページでは、Kubernetes Deploymentオブジェクトを使用してアプリケーションを実行する方法を説明します。</p>
<h2 id=目標>目標</h2>
<ul>
<li>nginx deploymentを作成します。</li>
<li>kubectlを使ってdeploymentに関する情報を一覧表示します。</li>
<li>deploymentを更新します。</li>
</ul>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.9.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=nginx-deploymentの作成と探検>nginx deploymentの作成と探検</h2>
<p>Kubernetes Deploymentオブジェクトを作成することでアプリケーションを実行できます。また、YAMLファイルでDeploymentを記述できます。例えば、このYAMLファイルはnginx:1.14.2 Dockerイメージを実行するデプロイメントを記述しています:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-deployment-yaml')" title="Copy application/deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>YAMLファイルに基づいてDeploymentを作成します:</p>
<pre><code> kubectl apply -f https://k8s.io/examples/application/deployment.yaml
</code></pre>
</li>
<li>
<p>Deploymentに関する情報を表示します:</p>
<pre><code> kubectl describe deployment nginx-deployment
</code></pre>
<p>出力はこのようになります:</p>
<pre><code> Name:     nginx-deployment
 Namespace:    default
 CreationTimestamp:  Tue, 30 Aug 2016 18:11:37 -0700
 Labels:     app=nginx
 Annotations:    deployment.kubernetes.io/revision=1
 Selector:   app=nginx
 Replicas:   2 desired | 2 updated | 2 total | 2 available | 0 unavailable
 StrategyType:   RollingUpdate
 MinReadySeconds:  0
 RollingUpdateStrategy:  1 max unavailable, 1 max surge
 Pod Template:
   Labels:       app=nginx
   Containers:
    nginx:
     Image:              nginx:1.14.2
     Port:               80/TCP
     Environment:        &lt;none&gt;
     Mounts:             &lt;none&gt;
   Volumes:              &lt;none&gt;
 Conditions:
   Type          Status  Reason
   ----          ------  ------
   Available     True    MinimumReplicasAvailable
   Progressing   True    NewReplicaSetAvailable
 OldReplicaSets:   &lt;none&gt;
 NewReplicaSet:    nginx-deployment-1771418926 (2/2 replicas created)
 No events.
</code></pre>
</li>
<li>
<p>Deploymentによって作成されたPodを一覧表示します:</p>
<pre><code> kubectl get pods -l app=nginx
</code></pre>
<p>出力はこのようになります:</p>
<pre><code> NAME                                READY     STATUS    RESTARTS   AGE
 nginx-deployment-1771418926-7o5ns   1/1       Running   0          16h
 nginx-deployment-1771418926-r18az   1/1       Running   0          16h
</code></pre>
</li>
<li>
<p>Podに関する情報を表示します:</p>
<pre><code> kubectl describe pod &lt;pod-name&gt;
</code></pre>
<p>ここで<code>&lt;pod-name></code>はPodの1つの名前を指定します。</p>
</li>
</ol>
<h2 id=deploymentの更新>Deploymentの更新</h2>
<p>新しいYAMLファイルを適用してDeploymentを更新できます。このYAMLファイルは、Deploymentを更新してnginx 1.16.1を使用するように指定しています。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/deployment-update.yaml download=application/deployment-update.yaml><code>application/deployment-update.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-deployment-update-yaml')" title="Copy application/deployment-update.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-deployment-update-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16.1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Update the version of nginx from 1.14.2 to 1.16.1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>新しいYAMLファイルを適用します:</p>
<pre><code>  kubectl apply -f https://k8s.io/examples/application/deployment-update.yaml
</code></pre>
</li>
<li>
<p>Deploymentが新しい名前でPodを作成し、古いPodを削除するのを監視します:</p>
<pre><code>  kubectl get pods -l app=nginx
</code></pre>
</li>
</ol>
<h2 id=レプリカ数を増やすことによるアプリケーションのスケール>レプリカ数を増やすことによるアプリケーションのスケール</h2>
<p>新しいYAMLファイルを適用することで、Deployment内のPodの数を増やすことができます。このYAMLファイルは<code>replicas</code>を4に設定します。これはDeploymentが4つのPodを持つべきであることを指定します:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/deployment-scale.yaml download=application/deployment-scale.yaml><code>application/deployment-scale.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-deployment-scale-yaml')" title="Copy application/deployment-scale.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-deployment-scale-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Update the replicas from 2 to 4</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>新しいYAMLファイルを適用します:</p>
<pre><code> kubectl apply -f https://k8s.io/examples/application/deployment-scale.yaml
</code></pre>
</li>
<li>
<p>Deploymentに4つのPodがあることを確認します:</p>
<pre><code> kubectl get pods -l app=nginx
</code></pre>
<p>出力はこのようになります:</p>
<pre><code> NAME                               READY     STATUS    RESTARTS   AGE
 nginx-deployment-148880595-4zdqq   1/1       Running   0          25s
 nginx-deployment-148880595-6zgi1   1/1       Running   0          25s
 nginx-deployment-148880595-fxcez   1/1       Running   0          2m
 nginx-deployment-148880595-rwovn   1/1       Running   0          2m
</code></pre>
</li>
</ol>
<h2 id=deploymentの削除>Deploymentの削除</h2>
<p>Deploymentを名前を指定して削除します:</p>
<pre><code>kubectl delete deployment nginx-deployment
</code></pre>
<h2 id=replicationcontrollers-昔のやり方>ReplicationControllers -- 昔のやり方</h2>
<p>複製アプリケーションを作成するための好ましい方法はDeploymentを使用することです。そして、DeploymentはReplicaSetを使用します。 DeploymentとReplicaSetがKubernetesに追加される前は、<a href=/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>を使用して複製アプリケーションを構成していました。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deploymentオブジェクト</a>の詳細</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-43398a6f5dc7ce19df59f5f4c2e7922d>4.7.2 - 単一レプリカのステートフルアプリケーションを実行する</h1>
<p>このページでは、PersistentVolumeとDeploymentを使用して、Kubernetesで単一レプリカのステートフルアプリケーションを実行する方法を説明します。アプリケーションはMySQLです。</p>
<h2 id=目標>目標</h2>
<ul>
<li>自身の環境のディスクを参照するPersistentVolumeを作成します。</li>
<li>MySQLのDeploymentを作成します。</li>
<li>MySQLをDNS名でクラスター内の他のPodに公開します。</li>
</ul>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
</li>
<li>
<p>ここで使用されている<a href=/docs/user-guide/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaims</a>の要件を満たすには、デフォルトの<a href=/docs/concepts/storage/storage-classes/>StorageClass</a>を使用して動的PersistentVolumeプロビジョナーを作成するか、<a href=/docs/user-guide/persistent-volumes/#provisioning>PersistentVolumesを静的にプロビジョニングする</a>必要があります。</p>
</li>
</ul>
<h2 id=mysqlをデプロイする>MySQLをデプロイする</h2>
<p>Kubernetes Deploymentを作成し、PersistentVolumeClaimを使用して既存のPersistentVolumeに接続することで、ステートフルアプリケーションを実行できます。
たとえば、以下のYAMLファイルはMySQLを実行し、PersistentVolumeClaimを参照するDeploymentを記述しています。
このファイルは/var/lib/mysqlのボリュームマウントを定義してから、20Gのボリュームを要求するPersistentVolumeClaimを作成します。
この要求は、要件を満たす既存のボリューム、または動的プロビジョナーによって満たされます。</p>
<p>注：パスワードはYAMLファイル内に定義されており、これは安全ではありません。安全な解決策については<a href=/docs/concepts/configuration/secret/>Kubernetes Secret</a>を参照してください 。</p>
<p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/mysql/mysql-deployment.yaml download=application/mysql/mysql-deployment.yaml><code>application/mysql/mysql-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-deployment-yaml')" title="Copy application/mysql/mysql-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Recreate<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql:5.6<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># Use secret in real usage</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-persistent-storage<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-persistent-storage<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>mysql-pv-claim<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/mysql/mysql-pv.yaml download=application/mysql/mysql-pv.yaml><code>application/mysql/mysql-pv.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-pv-yaml')" title="Copy application/mysql/mysql-pv.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-pv-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-pv-volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>local<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/mnt/data&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-pv-claim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
</p>
<ol>
<li>
<p>YAMLファイルに記述されたPVとPVCをデプロイします。</p>
<pre><code> kubectl create -f https://k8s.io/examples/application/mysql/mysql-pv.yaml
</code></pre>
</li>
<li>
<p>YAMLファイルの内容をデプロイします。</p>
<pre><code> kubectl create -f https://k8s.io/examples/application/mysql/mysql-deployment.yaml
</code></pre>
</li>
<li>
<p>作成したDeploymentの情報を表示します。</p>
<pre><code> kubectl describe deployment mysql

 Name:                 mysql
 Namespace:            default
 CreationTimestamp:    Tue, 01 Nov 2016 11:18:45 -0700
 Labels:               app=mysql
 Annotations:          deployment.kubernetes.io/revision=1
 Selector:             app=mysql
 Replicas:             1 desired | 1 updated | 1 total | 0 available | 1 unavailable
 StrategyType:         Recreate
 MinReadySeconds:      0
 Pod Template:
   Labels:       app=mysql
   Containers:
    mysql:
     Image:      mysql:5.6
     Port:       3306/TCP
     Environment:
       MYSQL_ROOT_PASSWORD:      password
     Mounts:
       /var/lib/mysql from mysql-persistent-storage (rw)
   Volumes:
    mysql-persistent-storage:
     Type:       PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)
     ClaimName:  mysql-pv-claim
     ReadOnly:   false
 Conditions:
   Type          Status  Reason
   ----          ------  ------
   Available     False   MinimumReplicasUnavailable
   Progressing   True    ReplicaSetUpdated
 OldReplicaSets:       &lt;none&gt;
 NewReplicaSet:        mysql-63082529 (1/1 replicas created)
 Events:
   FirstSeen    LastSeen    Count    From                SubobjectPath    Type        Reason            Message
   ---------    --------    -----    ----                -------------    --------    ------            -------
   33s          33s         1        {deployment-controller }             Normal      ScalingReplicaSet Scaled up replica set mysql-63082529 to 1
</code></pre>
</li>
<li>
<p>Deploymentによって作成されたPodを一覧表示します。</p>
<pre><code> kubectl get pods -l app=mysql

 NAME                   READY     STATUS    RESTARTS   AGE
 mysql-63082529-2z3ki   1/1       Running   0          3m
</code></pre>
</li>
<li>
<p>PersistentVolumeClaimを確認します。</p>
<pre><code> kubectl describe pvc mysql-pv-claim

 Name:         mysql-pv-claim
 Namespace:    default
 StorageClass:
 Status:       Bound
 Volume:       mysql-pv-volume
 Labels:       &lt;none&gt;
 Annotations:    pv.kubernetes.io/bind-completed=yes
                 pv.kubernetes.io/bound-by-controller=yes
 Capacity:     20Gi
 Access Modes: RWO
 Events:       &lt;none&gt;
</code></pre>
</li>
</ol>
<h2 id=mysqlインスタンスにアクセスする>MySQLインスタンスにアクセスする</h2>
<p>前述のYAMLファイルは、クラスター内の他のPodがデータベースにアクセスできるようにするServiceを作成します。
Serviceのオプションで<code>clusterIP: None</code>を指定すると、ServiceのDNS名がPodのIPアドレスに直接解決されます。
このオプションは、ServiceのバックエンドのPodが1つのみであり、Podの数を増やす予定がない場合に適しています。</p>
<p>MySQLクライアントを実行してサーバーに接続します。</p>
<pre><code>kubectl run -it --rm --image=mysql:5.6 --restart=Never mysql-client -- mysql -h mysql -ppassword
</code></pre><p>このコマンドは、クラスター内にMySQLクライアントを実行する新しいPodを作成し、Serviceを通じてMySQLサーバーに接続します。
接続できれば、ステートフルなMySQLデータベースが稼働していることが確認できます。</p>
<pre><code>Waiting for pod default/mysql-client-274442439-zyp6i to be running, status is Pending, pod ready: false
If you don't see a command prompt, try pressing enter.

mysql&gt;
</code></pre><h2 id=アップデート>アップデート</h2>
<p>イメージまたはDeploymentの他の部分は、<code>kubectl apply</code>コマンドを使用して通常どおりに更新できます。
ステートフルアプリケーションに固有のいくつかの注意事項を以下に記載します。</p>
<ul>
<li>アプリケーションをスケールしないでください。このセットアップは単一レプリカのアプリケーション専用です。
下層にあるPersistentVolumeは1つのPodにしかマウントできません。
クラスター化されたステートフルアプリケーションについては、<a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSetのドキュメント</a>を参照してください。</li>
<li>Deploymentを定義するYAMLファイルでは<code>strategy: type: Recreate</code>を使用して下さい。
この設定はKubernetesにローリングアップデートを使用 <em>しない</em> ように指示します。
同時に複数のPodを実行することはできないため、ローリングアップデートは使用できません。
<code>Recreate</code>戦略は、更新された設定で新しいPodを作成する前に、最初のPodを停止します。</li>
</ul>
<h2 id=deploymentの削除>Deploymentの削除</h2>
<p>名前を指定してデプロイしたオブジェクトを削除します。</p>
<pre><code>kubectl delete deployment,svc mysql
kubectl delete pvc mysql-pv-claim
kubectl delete pv mysql-pv-volume
</code></pre><p>PersistentVolumeを手動でプロビジョニングした場合は、PersistentVolumeを手動で削除し、また、下層にあるリソースも解放する必要があります。
動的プロビジョニング機能を使用した場合は、PersistentVolumeClaimを削除すれば、自動的にPersistentVolumeも削除されます。
一部の動的プロビジョナー(EBSやPDなど)は、PersistentVolumeを削除すると同時に下層にあるリソースも解放します。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>
<p><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deploymentオブジェクト</a>についてもっと学ぶ</p>
</li>
<li>
<p><a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>アプリケーションのデプロイ</a>についてもっと学ぶ</p>
</li>
<li>
<p><a href=/docs/reference/generated/kubectl/kubectl-commands/#run>kubectl runのドキュメント</a></p>
</li>
<li>
<p><a href=/docs/concepts/storage/volumes/>Volumes</a>と<a href=/docs/concepts/storage/persistent-volumes/>Persistent Volumes</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-95b3d561509c573e53bec2368264cf6a>4.7.3 - レプリカを持つステートフルアプリケーションを実行する</h1>
<p>このページでは、<a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>
コントローラーを使用して、レプリカを持つステートフルアプリケーションを実行する方法を説明します。
ここでの例は、非同期レプリケーションを行う複数のスレーブを持つ、単一マスターのMySQLです。</p>
<p><strong>この例は本番環境向けの構成ではない</strong>ことに注意してください。
具体的には、MySQLの設定が安全ではないデフォルトのままとなっています。
これはKubernetesでステートフルアプリケーションを実行するための一般的なパターンに焦点を当てるためです。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</li>
<li><p>ここで使用されている<a href=/docs/user-guide/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaims</a>の要件を満たすには、デフォルトの<a href=/docs/concepts/storage/storage-classes/>StorageClass</a>を使用して動的PersistentVolumeプロビジョナーを作成するか、<a href=/docs/user-guide/persistent-volumes/#provisioning>PersistentVolumesを静的にプロビジョニングする</a>必要があります。</p>
</li>
<li>このチュートリアルは、あなたが<a href=/ja/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>
と<a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>、
さらには<a href=/ja/docs/concepts/workloads/pods/>Pod</a>、
<a href=/ja/docs/concepts/services-networking/service/>Service</a>、
<a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>などの
他のコアな概念に精通していることを前提としています。</li>
<li>MySQLに関する知識は記事の理解に役立ちますが、
このチュートリアルは他のシステムにも役立つ一般的なパターンを提示することを目的としています。</li>
</ul>
<h2 id=目標>目標</h2>
<ul>
<li>StatefulSetコントローラーを使用して、レプリカを持つMySQLトポロジーをデプロイします。</li>
<li>MySQLクライアントトラフィックを送信します。</li>
<li>ダウンタイムに対する耐性を観察します。</li>
<li>StatefulSetをスケールアップおよびスケールダウンします。</li>
</ul>
<h2 id=mysqlをデプロイする>MySQLをデプロイする</h2>
<p>このMySQLのデプロイの例は、1つのConfigMap、2つのService、および1つのStatefulSetから構成されます。</p>
<h3 id=configmap>ConfigMap</h3>
<p>次のYAML設定ファイルからConfigMapを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-configmap.yaml
</code></pre></div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/mysql/mysql-configmap.yaml download=application/mysql/mysql-configmap.yaml><code>application/mysql/mysql-configmap.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-configmap-yaml')" title="Copy application/mysql/mysql-configmap.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-configmap-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>master.cnf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    # Apply this config only on the master.
</span><span style=color:#b44;font-style:italic>    [mysqld]
</span><span style=color:#b44;font-style:italic>    log-bin</span><span style=color:#bbb>    
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>slave.cnf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    # Apply this config only on slaves.
</span><span style=color:#b44;font-style:italic>    [mysqld]
</span><span style=color:#b44;font-style:italic>    super-read-only</span><span style=color:#bbb>    
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>このConfigMapは、MySQLマスターとスレーブの設定を独立して制御するために、
それぞれの<code>my.cnf</code>を上書きする内容を提供します。
この場合、マスターはスレーブにレプリケーションログを提供するようにし、
スレーブはレプリケーション以外の書き込みを拒否するようにします。</p>
<p>ConfigMap自体に特別なことはありませんが、ConfigMapの各部分は異なるPodに適用されます。
各Podは、StatefulSetコントローラーから提供される情報に基づいて、
初期化時にConfigMapのどの部分を見るかを決定します。</p>
<h3 id=services>Services</h3>
<p>以下のYAML設定ファイルからServiceを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-services.yaml
</code></pre></div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/mysql/mysql-services.yaml download=application/mysql/mysql-services.yaml><code>application/mysql/mysql-services.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-services-yaml')" title="Copy application/mysql/mysql-services.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-services-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># Headless service for stable DNS entries of StatefulSet members.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Client service for connecting to any MySQL instance for reads.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># For writes, you must instead connect to the master: mysql-0.mysql.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-read<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>ヘッドレスサービスは、StatefulSetコントローラーが
StatefulSetの一部であるPodごとに作成するDNSエントリーのベースエントリーを提供します。
この例ではヘッドレスサービスの名前は<code>mysql</code>なので、同じKubernetesクラスタの
同じ名前空間内の他のPodは、<code>&lt;pod-name>.mysql</code>を名前解決することでPodにアクセスできます。</p>
<p><code>mysql-read</code>と呼ばれるクライアントサービスは、独自のクラスタIPを持つ通常のServiceであり、
Ready状態のすべてのMySQL Podに接続を分散します。
Serviceのエンドポイントには、MySQLマスターとすべてのスレーブが含まれる可能性があります。</p>
<p>読み込みクエリーのみが、負荷分散されるクライアントサービスを使用できることに注意してください。
MySQLマスターは1つしかいないため、クライアントが書き込みを実行するためには、
(ヘッドレスサービス内のDNSエントリーを介して)MySQLのマスターPodに直接接続する必要があります。</p>
<h3 id=statefulset>StatefulSet</h3>
<p>最後に、次のYAML設定ファイルからStatefulSetを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-statefulset.yaml
</code></pre></div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/mysql/mysql-statefulset.yaml download=application/mysql/mysql-statefulset.yaml><code>application/mysql/mysql-statefulset.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-statefulset-yaml')" title="Copy application/mysql/mysql-statefulset.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-statefulset-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql:5.7<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- bash<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          set -ex
</span><span style=color:#b44;font-style:italic>          # Generate mysql server-id from pod ordinal index.
</span><span style=color:#b44;font-style:italic>          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1
</span><span style=color:#b44;font-style:italic>          ordinal=${BASH_REMATCH[1]}
</span><span style=color:#b44;font-style:italic>          echo [mysqld] &gt; /mnt/conf.d/server-id.cnf
</span><span style=color:#b44;font-style:italic>          # Add an offset to avoid reserved server-id=0 value.
</span><span style=color:#b44;font-style:italic>          echo server-id=$((100 + $ordinal)) &gt;&gt; /mnt/conf.d/server-id.cnf
</span><span style=color:#b44;font-style:italic>          # Copy appropriate conf.d files from config-map to emptyDir.
</span><span style=color:#b44;font-style:italic>          if [[ $ordinal -eq 0 ]]; then
</span><span style=color:#b44;font-style:italic>            cp /mnt/config-map/master.cnf /mnt/conf.d/
</span><span style=color:#b44;font-style:italic>          else
</span><span style=color:#b44;font-style:italic>            cp /mnt/config-map/slave.cnf /mnt/conf.d/
</span><span style=color:#b44;font-style:italic>          fi</span><span style=color:#bbb>          
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt/conf.d<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-map<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt/config-map<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>clone-mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/xtrabackup:1.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- bash<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          set -ex
</span><span style=color:#b44;font-style:italic>          # Skip the clone if data already exists.
</span><span style=color:#b44;font-style:italic>          [[ -d /var/lib/mysql/mysql ]] &amp;&amp; exit 0
</span><span style=color:#b44;font-style:italic>          # Skip the clone on master (ordinal index 0).
</span><span style=color:#b44;font-style:italic>          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1
</span><span style=color:#b44;font-style:italic>          ordinal=${BASH_REMATCH[1]}
</span><span style=color:#b44;font-style:italic>          [[ $ordinal -eq 0 ]] &amp;&amp; exit 0
</span><span style=color:#b44;font-style:italic>          # Clone data from previous peer.
</span><span style=color:#b44;font-style:italic>          ncat --recv-only mysql-$(($ordinal-1)).mysql 3307 | xbstream -x -C /var/lib/mysql
</span><span style=color:#b44;font-style:italic>          # Prepare the backup.
</span><span style=color:#b44;font-style:italic>          xtrabackup --prepare --target-dir=/var/lib/mysql</span><span style=color:#bbb>          
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/mysql/conf.d<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql:5.7<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ALLOW_EMPTY_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/mysql/conf.d<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;mysqladmin&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;ping&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-style:italic># Check we can execute queries over TCP (skip-networking is off).</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;mysql&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-h&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;127.0.0.1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-e&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;SELECT 1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>xtrabackup<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/xtrabackup:1.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>xtrabackup<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>3307</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- bash<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          set -ex
</span><span style=color:#b44;font-style:italic>          cd /var/lib/mysql
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          # Determine binlog position of cloned data, if any.
</span><span style=color:#b44;font-style:italic>          if [[ -f xtrabackup_slave_info &amp;&amp; &#34;x$(&lt;xtrabackup_slave_info)&#34; != &#34;x&#34; ]]; then
</span><span style=color:#b44;font-style:italic>            # XtraBackup already generated a partial &#34;CHANGE MASTER TO&#34; query
</span><span style=color:#b44;font-style:italic>            # because we&#39;re cloning from an existing slave. (Need to remove the tailing semicolon!)
</span><span style=color:#b44;font-style:italic>            cat xtrabackup_slave_info | sed -E &#39;s/;$//g&#39; &gt; change_master_to.sql.in
</span><span style=color:#b44;font-style:italic>            # Ignore xtrabackup_binlog_info in this case (it&#39;s useless).
</span><span style=color:#b44;font-style:italic>            rm -f xtrabackup_slave_info xtrabackup_binlog_info
</span><span style=color:#b44;font-style:italic>          elif [[ -f xtrabackup_binlog_info ]]; then
</span><span style=color:#b44;font-style:italic>            # We&#39;re cloning directly from master. Parse binlog position.
</span><span style=color:#b44;font-style:italic>            [[ `cat xtrabackup_binlog_info` =~ ^(.*?)[[:space:]]+(.*?)$ ]] || exit 1
</span><span style=color:#b44;font-style:italic>            rm -f xtrabackup_binlog_info xtrabackup_slave_info
</span><span style=color:#b44;font-style:italic>            echo &#34;CHANGE MASTER TO MASTER_LOG_FILE=&#39;${BASH_REMATCH[1]}&#39;,\
</span><span style=color:#b44;font-style:italic>                  MASTER_LOG_POS=${BASH_REMATCH[2]}&#34; &gt; change_master_to.sql.in
</span><span style=color:#b44;font-style:italic>          fi
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          # Check if we need to complete a clone by starting replication.
</span><span style=color:#b44;font-style:italic>          if [[ -f change_master_to.sql.in ]]; then
</span><span style=color:#b44;font-style:italic>            echo &#34;Waiting for mysqld to be ready (accepting connections)&#34;
</span><span style=color:#b44;font-style:italic>            until mysql -h 127.0.0.1 -e &#34;SELECT 1&#34;; do sleep 1; done
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>            echo &#34;Initializing replication from clone position&#34;
</span><span style=color:#b44;font-style:italic>            mysql -h 127.0.0.1 \
</span><span style=color:#b44;font-style:italic>                  -e &#34;$(&lt;change_master_to.sql.in), \
</span><span style=color:#b44;font-style:italic>                          MASTER_HOST=&#39;mysql-0.mysql&#39;, \
</span><span style=color:#b44;font-style:italic>                          MASTER_USER=&#39;root&#39;, \
</span><span style=color:#b44;font-style:italic>                          MASTER_PASSWORD=&#39;&#39;, \
</span><span style=color:#b44;font-style:italic>                          MASTER_CONNECT_RETRY=10; \
</span><span style=color:#b44;font-style:italic>                        START SLAVE;&#34; || exit 1
</span><span style=color:#b44;font-style:italic>            # In case of container restart, attempt this at-most-once.
</span><span style=color:#b44;font-style:italic>            mv change_master_to.sql.in change_master_to.sql.orig
</span><span style=color:#b44;font-style:italic>          fi
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          # Start a server to send backups when requested by peers.
</span><span style=color:#b44;font-style:italic>          exec ncat --listen --keep-open --send-only --max-conns=1 3307 -c \
</span><span style=color:#b44;font-style:italic>            &#34;xtrabackup --backup --slave-info --stream=xbstream --host=127.0.0.1 --user=root&#34;</span><span style=color:#bbb>          
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/mysql/conf.d<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-map<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;ReadWriteOnce&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>次のコマンドを実行して起動の進行状況を確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql --watch
</code></pre></div><p>しばらくすると、3つのPodすべてがRunning状態になるはずです。</p>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
mysql-0   2/2       Running   0          2m
mysql-1   2/2       Running   0          1m
mysql-2   2/2       Running   0          1m
</code></pre><p><strong>Ctrl+C</strong>を押してウォッチをキャンセルします。
起動が進行しない場合は、<a href=#%E5%A7%8B%E3%82%81%E3%82%8B%E5%89%8D%E3%81%AB>始める前に</a>で説明されているように、
PersistentVolumeの動的プロビジョニング機能が有効になっていることを確認してください。</p>
<p>このマニフェストでは、StatefulSetの一部としてステートフルなPodを管理するためにさまざまな手法を使用しています。
次のセクションでは、これらの手法のいくつかに焦点を当て、StatefulSetがPodを作成するときに何が起こるかを説明します。</p>
<h2 id=ステートフルなpodの初期化を理解する>ステートフルなPodの初期化を理解する</h2>
<p>StatefulSetコントローラーは、序数インデックスの順にPodを一度に1つずつ起動します。
各PodがReady状態を報告するまで待機してから、その次のPodの起動が開始されます。</p>
<p>さらに、コントローラーは各Podに <code>&lt;statefulset-name>-&lt;ordinal-index></code>という形式の一意で不変の名前を割り当てます。
この例の場合、Podの名前は<code>mysql-0</code>、<code>mysql-1</code>、そして<code>mysql-2</code>となります。</p>
<p>上記のStatefulSetマニフェスト内のPodテンプレートは、これらのプロパティーを利用して、
MySQLレプリケーションの起動を順序正しく実行します。</p>
<h3 id=構成を生成する>構成を生成する</h3>
<p>Podスペック内のコンテナを起動する前に、Podは最初に
<a href=/ja/docs/concepts/workloads/pods/init-containers/>初期化コンテナ</a>を定義された順序で実行します。</p>
<p>最初の初期化コンテナは<code>init-mysql</code>という名前で、序数インデックスに基づいて特別なMySQL設定ファイルを生成します。</p>
<p>スクリプトは、<code>hostname</code>コマンドによって返されるPod名の末尾から抽出することによって、自身の序数インデックスを特定します。
それから、序数を(予約された値を避けるために数値オフセット付きで)MySQLの<code>conf.d</code>ディレクトリーの<code>server-id.cnf</code>というファイルに保存します。
これは、StatefulSetコントローラーによって提供される一意で不変のIDを、同じ特性を必要とするMySQLサーバーIDの領域に変換します。</p>
<p>さらに、<code>init-mysql</code>コンテナ内のスクリプトは、<code>master.cnf</code>または<code>slave.cnf</code>のいずれかを、
ConfigMapから内容を<code>conf.d</code>にコピーすることによって適用します。
このトポロジー例は単一のMySQLマスターと任意の数のスレーブで構成されているため、
スクリプトは単に序数の<code>0</code>がマスターになるように、それ以外のすべてがスレーブになるように割り当てます。
StatefulSetコントローラーによる
<a href=/ja/docs/concepts/workloads/controllers/statefulset/#%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E3%81%A8%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AE%E4%BF%9D%E8%A8%BC>デプロイ順序の保証</a>と組み合わせると、
スレーブが作成される前にMySQLマスターがReady状態になるため、スレーブはレプリケーションを開始できます。</p>
<h3 id=既存データをクローンする>既存データをクローンする</h3>
<p>一般に、新しいPodがセットにスレーブとして参加するときは、
MySQLマスターにはすでにデータがあるかもしれないと想定する必要があります。
また、レプリケーションログが期間の先頭まで全て揃っていない場合も想定する必要があります。
これらの控えめな仮定は、実行中のStatefulSetのサイズを初期サイズに固定するのではなく、
時間の経過とともにスケールアップまたはスケールダウンできるようにするために重要です。</p>
<p>2番目の初期化コンテナは<code>clone-mysql</code>という名前で、スレーブPodが空のPersistentVolumeで最初に起動したときに、
クローン操作を実行します。
つまり、実行中の別のPodから既存のデータをすべてコピーするので、
そのローカル状態はマスターからレプリケーションを開始するのに十分な一貫性があります。</p>
<p>MySQL自体はこれを行うためのメカニズムを提供していないため、この例ではPercona XtraBackupという人気のあるオープンソースツールを使用しています。
クローンの実行中は、ソースとなるMySQLサーバーのパフォーマンスが低下する可能性があります。
MySQLマスターへの影響を最小限に抑えるために、スクリプトは各Podに序数インデックスが自分より1低いPodからクローンするように指示します。
StatefulSetコントローラーは、<code>N+1</code>のPodを開始する前には必ず<code>N</code>のPodがReady状態であることを保証するので、この方法が機能します。</p>
<h3 id=レプリケーションを開始する>レプリケーションを開始する</h3>
<p>初期化コンテナが正常に完了すると、通常のコンテナが実行されます。
MySQLのPodは実際に<code>mysqld</code>サーバーを実行する<code>mysql</code>コンテナと、
<a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>サイドカー</a>
として機能する<code>xtrabackup</code>コンテナから成ります。</p>
<p><code>xtrabackup</code>サイドカーはクローンされたデータファイルを見て、
スレーブ上でMySQLレプリケーションを初期化する必要があるかどうかを決定します。
もし必要がある場合、<code>mysqld</code>が準備できるのを待ってから、
XtraBackupクローンファイルから抽出されたレプリケーションパラメーターで<code>CHANGE MASTER TO</code>と<code>START SLAVE</code>コマンドを実行します。</p>
<p>スレーブがレプリケーションを開始すると、スレーブはMySQLマスターを記憶し、
サーバーが再起動した場合または接続が停止した場合に、自動的に再接続します。
また、スレーブはその不変のDNS名(<code>mysql-0.mysql</code>)でマスターを探すため、
再スケジュールされたために新しいPod IPを取得したとしても、自動的にマスターを見つけます。</p>
<p>最後に、レプリケーションを開始した後、<code>xtrabackup</code>コンテナはデータのクローンを要求する他のPodからの接続を待ち受けます。
StatefulSetがスケールアップした場合や、次のPodがPersistentVolumeClaimを失ってクローンをやり直す必要がある場合に備えて、
このサーバーは無期限に起動したままになります。</p>
<h2 id=クライアントトラフィックを送信する>クライアントトラフィックを送信する</h2>
<p>テストクエリーをMySQLマスター(ホスト名 <code>mysql-0.mysql</code>)に送信するには、
<code>mysql:5.7</code>イメージを使って一時的なコンテナーを実行し、<code>mysql</code>クライアントバイナリーを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run mysql-client --image<span style=color:#666>=</span>mysql:5.7 -i --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  mysql -h mysql-0.mysql <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>CREATE DATABASE test;
</span><span style=color:#b44>CREATE TABLE test.messages (message VARCHAR(250));
</span><span style=color:#b44>INSERT INTO test.messages VALUES (&#39;hello&#39;);
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>Ready状態を報告したいずれかのサーバーにテストクエリーを送信するには、ホスト名<code>mysql-read</code>を使用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run mysql-client --image<span style=color:#666>=</span>mysql:5.7 -i -t --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  mysql -h mysql-read -e <span style=color:#b44>&#34;SELECT * FROM test.messages&#34;</span>
</code></pre></div><p>次のような出力が得られるはずです。</p>
<pre><code>Waiting for pod default/mysql-client to be running, status is Pending, pod ready: false
+---------+
| message |
+---------+
| hello   |
+---------+
pod &quot;mysql-client&quot; deleted
</code></pre><p><code>mysql-read</code>サービスがサーバー間で接続を分散させることを実証するために、
ループで<code>SELECT @@server_id</code>を実行することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run mysql-client-loop --image<span style=color:#666>=</span>mysql:5.7 -i -t --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  bash -ic <span style=color:#b44>&#34;while sleep 1; do mysql -h mysql-read -e &#39;SELECT @@server_id,NOW()&#39;; done&#34;</span>
</code></pre></div><p>接続の試行ごとに異なるエンドポイントが選択される可能性があるため、
報告される<code>@@server_id</code>はランダムに変更されるはずです。</p>
<pre><code>+-------------+---------------------+
| @@server_id | NOW()               |
+-------------+---------------------+
|         100 | 2006-01-02 15:04:05 |
+-------------+---------------------+
+-------------+---------------------+
| @@server_id | NOW()               |
+-------------+---------------------+
|         102 | 2006-01-02 15:04:06 |
+-------------+---------------------+
+-------------+---------------------+
| @@server_id | NOW()               |
+-------------+---------------------+
|         101 | 2006-01-02 15:04:07 |
+-------------+---------------------+
</code></pre><p>ループを止めたいときは<strong>Ctrl+C</strong>を押すことができますが、別のウィンドウで実行したままにしておくことで、
次の手順の効果を確認できます。</p>
<h2 id=podとnodeのダウンタイムをシミュレーションする>PodとNodeのダウンタイムをシミュレーションする</h2>
<p>単一のサーバーではなくスレーブのプールから読み取りを行うことによって可用性が高まっていることを実証するため、
Podを強制的にReadyではない状態にする間、上記の<code>SELECT @@server_id</code>ループを実行したままにしてください。</p>
<h3 id=readiness-probeを壊す>Readiness Probeを壊す</h3>
<p><code>mysql</code>コンテナに対する
<a href=/ja/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-readiness-probes>readiness probe</a>
は、<code>mysql -h 127.0.0.1 -e 'SELECT 1'</code>コマンドを実行することで、サーバーが起動していてクエリーが実行できることを確認します。</p>
<p>このreadiness probeを失敗させる1つの方法は、そのコマンドを壊すことです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> mysql-2 -c mysql -- mv /usr/bin/mysql /usr/bin/mysql.off
</code></pre></div><p>ここでは、<code>mysql-2</code> Podの実際のコンテナのファイルシステムにアクセスし、
<code>mysql</code>コマンドの名前を変更してreadiness probeがコマンドを見つけられないようにしています。
数秒後、Podはそのコンテナの1つがReadyではないと報告するはずです。以下を実行して確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod mysql-2
</code></pre></div><p><code>READY</code>列の<code>1/2</code>を見てください。</p>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
mysql-2   1/2       Running   0          3m
</code></pre><p>この時点で、<code>SELECT @@server_id</code>ループは実行され続け、しかしもう<code>102</code>が報告されないことが確認できるはずです。
<code>init-mysql</code>スクリプトが<code>server-id</code>を<code>100+$ordinal</code>として定義したことを思い出して下さい。
そのため、サーバーID<code>102</code>はPodの<code>mysql-2</code>に対応します。</p>
<p>それではPodを修復しましょう。すると数秒後にループ出力に再び現れるはずです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> mysql-2 -c mysql -- mv /usr/bin/mysql.off /usr/bin/mysql
</code></pre></div><h3 id=podを削除する>Podを削除する</h3>
<p>StatefulSetは、Podが削除された場合にPodを再作成します。
これはReplicaSetがステートレスなPodに対して行うのと同様です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod mysql-2
</code></pre></div><p>StatefulSetコントローラーは<code>mysql-2</code> Podがもう存在しないことに気付き、
同じ名前で同じPersistentVolumeClaimにリンクされた新しいPodを作成します。
サーバーID<code>102</code>がしばらくの間ループ出力から消えて、また元に戻るのが確認できるはずです。</p>
<h3 id=ノードをdrainする>ノードをdrainする</h3>
<p>Kubernetesクラスタに複数のノードがある場合は、
<a href=/docs/reference/generated/kubectl/kubectl-commands/#drain>drain</a>を発行して
ノードのダウンタイム(例えばノードのアップグレード時など)をシミュレートできます。</p>
<p>まず、あるMySQL Podがどのノード上にいるかを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod mysql-2 -o wide
</code></pre></div><p>ノード名が最後の列に表示されるはずです。</p>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE       IP            NODE
mysql-2   2/2       Running   0          15m       10.244.5.27   kubernetes-minion-group-9l2t
</code></pre><p>その後、次のコマンドを実行してノードをdrainします。
これにより、新しいPodがそのノードにスケジュールされないようにcordonされ、そして既存のPodは強制退去されます。
<code>&lt;node-name></code>は前のステップで確認したノードの名前に置き換えてください。</p>
<p>この操作はノード上の他のアプリケーションに影響を与える可能性があるため、
<strong>テストクラスタでのみこの操作を実行</strong>するのが最善です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl drain &lt;node-name&gt; --force --delete-local-data --ignore-daemonsets
</code></pre></div><p>Podが別のノードに再スケジュールされる様子を確認しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod mysql-2 -o wide --watch
</code></pre></div><p>次のような出力が見られるはずです。</p>
<pre><code>NAME      READY   STATUS          RESTARTS   AGE       IP            NODE
mysql-2   2/2     Terminating     0          15m       10.244.1.56   kubernetes-minion-group-9l2t
[...]
mysql-2   0/2     Pending         0          0s        &lt;none&gt;        kubernetes-minion-group-fjlm
mysql-2   0/2     Init:0/2        0          0s        &lt;none&gt;        kubernetes-minion-group-fjlm
mysql-2   0/2     Init:1/2        0          20s       10.244.5.32   kubernetes-minion-group-fjlm
mysql-2   0/2     PodInitializing 0          21s       10.244.5.32   kubernetes-minion-group-fjlm
mysql-2   1/2     Running         0          22s       10.244.5.32   kubernetes-minion-group-fjlm
mysql-2   2/2     Running         0          30s       10.244.5.32   kubernetes-minion-group-fjlm
</code></pre><p>また、サーバーID<code>102</code>が<code>SELECT @@server_id</code>ループの出力からしばらくの消えて、
そして戻ることが確認できるはずです。</p>
<p>それでは、ノードをuncordonして正常な状態に戻しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl uncordon &lt;node-name&gt;
</code></pre></div><h2 id=スレーブの数をスケーリングする>スレーブの数をスケーリングする</h2>
<p>MySQLレプリケーションでは、スレーブを追加することで読み取りクエリーのキャパシティーをスケールできます。
StatefulSetを使用している場合、単一のコマンドでこれを実行できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale statefulset mysql  --replicas<span style=color:#666>=</span><span style=color:#666>5</span>
</code></pre></div><p>次のコマンドを実行して、新しいPodが起動してくるのを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql --watch
</code></pre></div><p>新しいPodが起動すると、サーバーID<code>103</code>と<code>104</code>が<code>SELECT @@server_id</code>ループの出力に現れます。</p>
<p>また、これらの新しいサーバーが、これらのサーバーが存在する前に追加したデータを持っていることを確認することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run mysql-client --image<span style=color:#666>=</span>mysql:5.7 -i -t --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  mysql -h mysql-3.mysql -e <span style=color:#b44>&#34;SELECT * FROM test.messages&#34;</span>
</code></pre></div><pre><code>Waiting for pod default/mysql-client to be running, status is Pending, pod ready: false
+---------+
| message |
+---------+
| hello   |
+---------+
pod &quot;mysql-client&quot; deleted
</code></pre><p>元の状態へのスケールダウンもシームレスに可能です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale statefulset mysql --replicas<span style=color:#666>=</span><span style=color:#666>3</span>
</code></pre></div><p>ただし、スケールアップすると新しいPersistentVolumeClaimが自動的に作成されますが、
スケールダウンしてもこれらのPVCは自動的には削除されないことに注意して下さい。
このため、初期化されたPVCをそのまま置いておいくことで再スケールアップを速くしたり、
PVを削除する前にデータを抽出するといった選択が可能になります。</p>
<p>次のコマンドを実行してこのことを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql
</code></pre></div><p>StatefulSetを3にスケールダウンしたにもかかわらず、5つのPVCすべてがまだ存在しています。</p>
<pre><code>NAME           STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
data-mysql-0   Bound     pvc-8acbf5dc-b103-11e6-93fa-42010a800002   10Gi       RWO           20m
data-mysql-1   Bound     pvc-8ad39820-b103-11e6-93fa-42010a800002   10Gi       RWO           20m
data-mysql-2   Bound     pvc-8ad69a6d-b103-11e6-93fa-42010a800002   10Gi       RWO           20m
data-mysql-3   Bound     pvc-50043c45-b1c5-11e6-93fa-42010a800002   10Gi       RWO           2m
data-mysql-4   Bound     pvc-500a9957-b1c5-11e6-93fa-42010a800002   10Gi       RWO           2m
</code></pre><p>余分なPVCを再利用するつもりがないのであれば、削除することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pvc data-mysql-3
kubectl delete pvc data-mysql-4
</code></pre></div><h2 id=クリーンアップ>クリーンアップ</h2>
<ol>
<li>
<p><code>SELECT @@server_id</code>ループを実行している端末で<strong>Ctrl+C</strong>を押すか、
別の端末から次のコマンドを実行して、ループをキャンセルします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod mysql-client-loop --now
</code></pre></div></li>
<li>
<p>StatefulSetを削除します。これによってPodの終了も開始されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete statefulset mysql
</code></pre></div></li>
<li>
<p>Podが消えたことを確認します。
Podが終了処理が完了するのには少し時間がかかるかもしれません。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql
</code></pre></div><p>上記のコマンドから以下の出力が戻れば、Podが終了したことがわかります。</p>
<pre><code>No resources found.
</code></pre></li>
<li>
<p>ConfigMap、Services、およびPersistentVolumeClaimを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete configmap,service,pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql
</code></pre></div></li>
<li>
<p>PersistentVolumeを手動でプロビジョニングした場合は、それらを手動で削除し、
また、下層にあるリソースも解放する必要があります。
動的プロビジョニング機能を使用した場合は、PersistentVolumeClaimを削除すれば、自動的にPersistentVolumeも削除されます。
一部の動的プロビジョナー(EBSやPDなど)は、PersistentVolumeを削除すると同時に下層にあるリソースも解放します。</p>
</li>
</ol>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>その他のステートフルアプリケーションの例は、<a href=https://github.com/kubernetes/charts>Helm Charts repository</a>を見てください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7a9b5779e228083ba3fdeaf414fe704e>4.7.4 - StatefulSetのスケール</h1>
<p>このタスクは、StatefulSetをスケールする方法を示します。StatefulSetをスケーリングするとは、レプリカの数を増減することです。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>
<p>StatefulSetはKubernetesバージョン1.5以降でのみ利用可能です。
Kubernetesのバージョンを確認するには、<code>kubectl version</code>を実行してください。</p>
</li>
<li>
<p>すべてのステートフルアプリケーションがうまくスケールできるわけではありません。StatefulSetがスケールするかどうかわからない場合は、<a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSetの概念</a>または<a href=/ja/docs/tutorials/stateful-application/basic-stateful-set/>StatefulSetのチュートリアル</a>を参照してください。</p>
</li>
<li>
<p>ステートフルアプリケーションクラスターが完全に健全であると確信できる場合にのみ、スケーリングを実行してください。</p>
</li>
</ul>
<h2 id=statefulsetのスケール>StatefulSetのスケール</h2>
<h3 id=kubectlを使用したstatefulsetのスケール>kubectlを使用したStatefulSetのスケール</h3>
<p>まず、スケールしたいStatefulSetを見つけます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get statefulsets &lt;stateful-set-name&gt;
</code></pre></div><p>StatefulSetのレプリカ数を変更します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale statefulsets &lt;stateful-set-name&gt; --replicas<span style=color:#666>=</span>&lt;new-replicas&gt;
</code></pre></div><h3 id=statefulsetのインプレースアップデート>StatefulSetのインプレースアップデート</h3>
<p>コマンドライン上でレプリカ数を変更する代わりに、StatefulSetに<a href=/ja/docs/concepts/cluster-administration/manage-deployment/#in-place-updates-of-resources>インプレースアップデート</a>が可能です。</p>
<p>StatefulSetが最初に <code>kubectl apply</code>で作成されたのなら、StatefulSetマニフェストの<code>.spec.replicas</code>を更新してから、<code>kubectl apply</code>を実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f &lt;stateful-set-file-updated&gt;
</code></pre></div><p>そうでなければ、<code>kubectl edit</code>でそのフィールドを編集してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit statefulsets &lt;stateful-set-name&gt;
</code></pre></div><p>あるいは<code>kubectl patch</code>を使ってください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch statefulsets &lt;stateful-set-name&gt; -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;replicas&#34;:&lt;new-replicas&gt;}}&#39;</span>
</code></pre></div><h2 id=トラブルシューティング>トラブルシューティング</h2>
<h3 id=スケールダウンがうまくいかない>スケールダウンがうまくいかない</h3>
<p>管理するステートフルPodのいずれかが異常である場合、StatefulSetをスケールダウンすることはできません。それらのステートフルPodが実行され準備ができた後にのみ、スケールダウンが行われます。</p>
<p>spec.replicas > 1の場合、Kubernetesは不健康なPodの理由を判断できません。それは、永続的な障害または一時的な障害の結果である可能性があります。一時的な障害は、アップグレードまたはメンテナンスに必要な再起動によって発生する可能性があります。</p>
<p>永続的な障害が原因でPodが正常でない場合、障害を修正せずにスケーリングすると、StatefulSetメンバーシップが正しく機能するために必要な特定の最小レプリカ数を下回る状態になる可能性があります。これにより、StatefulSetが利用できなくなる可能性があります。</p>
<p>一時的な障害によってPodが正常でなくなり、Podが再び使用可能になる可能性がある場合は、一時的なエラーがスケールアップまたはスケールダウン操作の妨げになる可能性があります。一部の分散データベースでは、ノードが同時に参加および脱退するときに問題があります。このような場合は、アプリケーションレベルでスケーリング操作を考えることをお勧めします。また、ステートフルアプリケーションクラスタが完全に健全であることが確実な場合にのみスケーリングを実行してください。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/tasks/run-application/delete-stateful-set/>StatefulSetの削除</a>の詳細</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c43537b0ee1da992ecb7488f87e6c934>4.7.5 - StatefulSetの削除</h1>
<p>このタスクでは、StatefulSetを削除する方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>このタスクは、クラスター上で、StatefulSetで表現されるアプリケーションが実行されていることを前提としています。</li>
</ul>
<h2 id=statefulsetの削除>StatefulSetの削除</h2>
<p>Kubernetesで他のリソースを削除するのと同じ方法でStatefulSetを削除することができます。つまり、<code>kubectl delete</code>コマンドを使い、StatefulSetをファイルまたは名前で指定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete -f &lt;file.yaml&gt;
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete statefulsets &lt;statefulset-name&gt;
</code></pre></div><p>StatefulSet自体が削除された後で、関連するヘッドレスサービスを個別に削除する必要があるかもしれません。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete service &lt;service-name&gt;
</code></pre></div><p>kubectlを使ってStatefulSetを削除すると0にスケールダウンされ、すべてのPodが削除されます。PodではなくStatefulSetだけを削除したい場合は、<code>--cascade=orphan</code>を使用してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete -f &lt;file.yaml&gt; --cascade<span style=color:#666>=</span>orphan
</code></pre></div><p><code>--cascade=orphan</code>を<code>kubectl delete</code>に渡すことで、StatefulSetオブジェクト自身が削除された後でも、StatefulSetによって管理されていたPodは残ります。Podに<code>app=myapp</code>というラベルが付いている場合は、次のようにして削除できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp
</code></pre></div><h3 id=永続ボリューム>永続ボリューム</h3>
<p>StatefulSet内のPodを削除しても、関連付けられているボリュームは削除されません。これは、削除する前にボリュームからデータをコピーする機会があることを保証するためです。Podが終了した後にPVCを削除すると、ストレージクラスと再利用ポリシーによっては、背後にある永続ボリュームの削除がトリガーされることがあります。決してクレーム削除後にボリュームにアクセスできると想定しないでください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> データを損失する可能性があるため、PVCを削除するときは注意してください。
</div>
<h3 id=statefulsetの完全削除>StatefulSetの完全削除</h3>
<p>関連付けられたPodを含むStatefulSet内のすべてのものを単純に削除するには、次のような一連のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>grace</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods &lt;stateful-set-pod&gt; --template <span style=color:#b44>&#39;{{.spec.terminationGracePeriodSeconds}}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
kubectl delete statefulset -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp
sleep <span style=color:#b8860b>$grace</span>
kubectl delete pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp

</code></pre></div><p>上の例では、Podは<code>app=myapp</code>というラベルを持っています。必要に応じてご利用のラベルに置き換えてください。</p>
<h3 id=statefulset-podの強制削除>StatefulSet Podの強制削除</h3>
<p>StatefulSet内の一部のPodが長期間<code>Terminating</code>または<code>Unknown</code>状態のままになっていることが判明した場合は、手動でapiserverからPodを強制的に削除する必要があります。これは潜在的に危険な作業です。詳細は<a href=/ja/docs/tasks/run-application/force-delete-stateful-set-pod/>StatefulSet Podの強制削除</a>を参照してください。</p>
<h2 id=次の項目>次の項目</h2>
<p><a href=/ja/docs/tasks/run-application/force-delete-stateful-set-pod/>StatefulSet Podの強制削除</a>の詳細</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5f2f7a74377a9d45325c5253353fa8f>4.7.6 - StatefulSet Podの強制削除</h1>
<p>このページでは、StatefulSetの一部であるPodを削除する方法と、削除する際に考慮すべき事項について説明します。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>これはかなり高度なタスクであり、StatefulSetに固有のいくつかの特性に反する可能性があります。</li>
<li>先に進む前に、以下に列挙されている考慮事項をよく理解してください。</li>
</ul>
<h2 id=statefulsetに関する考慮事項>StatefulSetに関する考慮事項</h2>
<p>StatefulSetの通常の操作では、StatefulSet Podを強制的に削除する必要は<strong>まったく</strong>ありません。StatefulSetコントローラーは、StatefulSetのメンバーの作成、スケール、削除を行います。それは序数0からN-1までの指定された数のPodが生きていて準備ができていることを保証しようとします。StatefulSetは、クラスター内で実行されている特定のIDを持つ最大1つのPodがいつでも存在することを保証します。これは、StatefulSetによって提供される<em>最大1つの</em>セマンティクスと呼ばれます。</p>
<p>手動による強制削除は、StatefulSetに固有の最大1つのセマンティクスに違反する可能性があるため、慎重に行う必要があります。StatefulSetを使用して、安定したネットワークIDと安定した記憶域を必要とする分散型およびクラスター型アプリケーションを実行できます。これらのアプリケーションは、固定IDを持つ固定数のメンバーのアンサンブルに依存する構成を持つことがよくあります。同じIDを持つ複数のメンバーを持つことは悲惨なことになり、データの損失につながる可能性があります(例：定足数ベースのシステムでのスプリットブレインシナリオ)。</p>
<h2 id=podの削除>Podの削除</h2>
<p>次のコマンドで正常なPod削除を実行できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pods &lt;pod&gt;
</code></pre></div><p>上記がグレースフルターミネーションにつながるためには、<code>pod.Spec.TerminationGracePeriodSeconds</code>に0を指定しては<strong>いけません</strong>。<code>pod.Spec.TerminationGracePeriodSeconds</code>を0秒に設定することは安全ではなく、StatefulSet Podには強くお勧めできません。グレースフル削除は安全で、kubeletがapiserverから名前を削除する前にPodが<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#termination-of-pods>適切にシャットダウンする</a>ことを保証します。</p>
<p>Kubernetes(バージョン1.5以降)は、Nodeにアクセスできないという理由だけでPodを削除しません。到達不能なNodeで実行されているPodは、<a href=/ja/docs/concepts/architecture/nodes/#condition>タイムアウト</a>の後に<code>Terminating</code>または<code>Unknown</code>状態になります。到達不能なNode上のPodをユーザーが適切に削除しようとすると、Podはこれらの状態に入ることもあります。そのような状態のPodをapiserverから削除することができる唯一の方法は以下の通りです:</p>
<ul>
<li>(ユーザーまたは<a href=/ja/docs/concepts/architecture/nodes/>Node Controller</a>によって)Nodeオブジェクトが削除されます。</li>
<li>応答していないNodeのkubeletが応答を開始し、Podを終了してapiserverからエントリーを削除します。</li>
<li>ユーザーによりPodを強制削除します。</li>
</ul>
<p>推奨されるベストプラクティスは、1番目または2番目のアプローチを使用することです。Nodeが死んでいることが確認された(例えば、ネットワークから恒久的に切断された、電源が切られたなど)場合、Nodeオブジェクトを削除します。Nodeがネットワークパーティションに苦しんでいる場合は、これを解決するか、解決するのを待ちます。パーティションが回復すると、kubeletはPodの削除を完了し、apiserverでその名前を解放します。</p>
<p>通常、PodがNode上で実行されなくなるか、管理者によってそのNodeが削除されると、システムは削除を完了します。あなたはPodを強制的に削除することでこれを無効にすることができます。</p>
<h3 id=強制削除>強制削除</h3>
<p>強制削除はPodが終了したことをkubeletから確認するまで<strong>待ちません</strong>。強制削除がPodの削除に成功したかどうかに関係なく、apiserverから名前をすぐに解放します。これにより、StatefulSetコントローラーは、同じIDを持つ交換Podを作成できます。これは、まだ実行中のPodの複製につながる可能性があり、そのPodがまだStatefulSetの他のメンバーと通信できる場合、StatefulSetが保証するように設計されている最大1つのセマンティクスに違反します。</p>
<p>StatefulSetのPodを強制的に削除するということは、問題のPodがStatefulSet内の他のPodと再び接触することはなく、代わりのPodを作成するために名前が安全に解放されることを意味します。</p>
<p>バージョン1.5以上のkubectlを使用してPodを強制的に削除する場合は、次の手順を実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pods &lt;pod&gt; --grace-period<span style=color:#666>=</span><span style=color:#666>0</span> --force
</code></pre></div><p>バージョン1.4以下のkubectlを使用している場合、<code>--force</code>オプションを省略する必要があります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pods &lt;pod&gt; --grace-period<span style=color:#666>=</span><span style=color:#666>0</span>
</code></pre></div><p>これらのコマンドを実行した後でもPodが<code>Unknown</code>状態のままになっている場合は、次のコマンドを使用してPodをクラスターから削除します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch pod &lt;pod&gt; -p <span style=color:#b44>&#39;{&#34;metadata&#34;:{&#34;finalizers&#34;:null}}&#39;</span>
</code></pre></div><p>StatefulSet Podの強制削除は、常に慎重に、関連するリスクを完全に把握して実行してください。</p>
<h2 id=次の項目>次の項目</h2>
<p><a href=/docs/tasks/debug-application-cluster/debug-stateful-set/>StatefulSetのデバッグ</a>の詳細</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8138226ce9660ac8e3e82ff86fff8ad2>4.7.7 - Horizontal Pod Autoscalerウォークスルー</h1>
<p>Horizontal Pod Autoscalerは、Deployment、ReplicaSetまたはStatefulSetといったレプリケーションコントローラ内のPodの数を、観測されたCPU使用率（もしくはベータサポートの、アプリケーションによって提供されるその他のメトリクス）に基づいて自動的にスケールさせます。</p>
<p>このドキュメントはphp-apacheサーバーに対しHorizontal Pod Autoscalerを有効化するという例に沿ってウォークスルーで説明していきます。Horizontal Pod Autoscalerの動作についてのより詳細な情報を知りたい場合は、<a href=/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscalerユーザーガイド</a>をご覧ください。</p>
<h2 id=始める前に>始める前に</h2>
<p>この例ではバージョン1.2以上の動作するKubernetesクラスターおよびkubectlが必要です。
<a href=https://github.com/kubernetes/metrics>Metrics API</a>を介してメトリクスを提供するために、<a href=https://github.com/kubernetes-sigs/metrics-server>Metrics server</a>によるモニタリングがクラスター内にデプロイされている必要があります。
Horizontal Pod Autoscalerはメトリクスを収集するためにこのAPIを利用します。metrics-serverをデプロイする方法を知りたい場合は<a href=https://github.com/kubernetes-sigs/metrics-server#deployment>metrics-server ドキュメント</a>をご覧ください。</p>
<p>Horizontal Pod Autoscalerで複数のリソースメトリクスを利用するためには、バージョン1.6以上のKubernetesクラスターおよびkubectlが必要です。カスタムメトリクスを使えるようにするためには、あなたのクラスターがカスタムメトリクスAPIを提供するAPIサーバーと通信できる必要があります。
最後に、Kubernetesオブジェクトと関係のないメトリクスを使うにはバージョン1.10以上のKubernetesクラスターおよびkubectlが必要で、さらにあなたのクラスターが外部メトリクスAPIを提供するAPIサーバーと通信できる必要があります。
詳細については<a href=/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics>Horizontal Pod Autoscaler user guide</a>をご覧ください。</p>
<h2 id=php-apacheの起動と公開>php-apacheの起動と公開</h2>
<p>Horizontal Pod Autoscalerのデモンストレーションのために、php-apacheイメージをもとにしたカスタムのDockerイメージを使います。
このDockerfileは下記のようになっています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#a2f;font-weight:700>FROM</span><span style=color:#b44> php:5-apache</span><span>
</span><span></span><span style=color:#a2f;font-weight:700>COPY</span> index.php /var/www/html/index.php<span>
</span><span></span><span style=color:#a2f;font-weight:700>RUN</span> chmod a+rx index.php<span>
</span></code></pre></div><p>これはCPU負荷の高い演算を行うindex.phpを定義しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=color:#666>&lt;?</span>php
  <span style=color:#b8860b>$x</span> <span style=color:#666>=</span> <span style=color:#666>0.0001</span>;
  <span style=color:#a2f;font-weight:700>for</span> (<span style=color:#b8860b>$i</span> <span style=color:#666>=</span> <span style=color:#666>0</span>; <span style=color:#b8860b>$i</span> <span style=color:#666>&lt;=</span> <span style=color:#666>1000000</span>; <span style=color:#b8860b>$i</span><span style=color:#666>++</span>) {
    <span style=color:#b8860b>$x</span> <span style=color:#666>+=</span> sqrt(<span style=color:#b8860b>$x</span>);
  }
  <span style=color:#a2f;font-weight:700>echo</span> <span style=color:#b44>&#34;OK!&#34;</span>;
<span style=color:#080>?&gt;</span><span>
</span></code></pre></div><p>まず最初に、イメージを動かすDeploymentを起動し、Serviceとして公開しましょう。
下記の設定を使います。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/php-apache.yaml download=application/php-apache.yaml><code>application/php-apache.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-php-apache-yaml')" title="Copy application/php-apache.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-php-apache-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/hpa-example<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>200m<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>以下のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/php-apache.yaml
</code></pre></div><pre><code>deployment.apps/php-apache created
service/php-apache created
</code></pre><h2 id=horizontal-pod-autoscalerを作成する>Horizontal Pod Autoscalerを作成する</h2>
<p>サーバーが起動したら、<a href=/docs/reference/generated/kubectl/kubectl-commands#autoscale>kubectl autoscale</a>を使ってautoscalerを作成しましょう。以下のコマンドで、最初のステップで作成したphp-apache deploymentによって制御されるPodレプリカ数を1から10の間に維持するHorizontal Pod Autoscalerを作成します。
簡単に言うと、HPAは（Deploymentを通じて）レプリカ数を増減させ、すべてのPodにおける平均CPU使用率を50%（それぞれのPodは<code>kubectl run</code>で200 milli-coresを要求しているため、平均CPU使用率100 milli-coresを意味します）に保とうとします。
このアルゴリズムについての詳細は<a href=/docs/tasks/run-application/horizontal-pod-autoscale/#algorithm-details>こちら</a>をご覧ください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl autoscale deployment php-apache --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span> --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>
</code></pre></div><pre><code>horizontalpodautoscaler.autoscaling/php-apache autoscaled
</code></pre><p>以下を実行して現在のAutoscalerの状況を確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get hpa
</code></pre></div><pre><code>NAME         REFERENCE                     TARGET    MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   0% / 50%  1         10        1          18s
</code></pre><p>現在はサーバーにリクエストを送っていないため、CPU使用率が0%になっていることに注意してください（<code>TARGET</code>カラムは対応するDeploymentによって制御される全てのPodの平均値を示しています。）。</p>
<h2 id=負荷の増加>負荷の増加</h2>
<p>Autoscalerがどのように負荷の増加に反応するか見てみましょう。
コンテナを作成し、クエリの無限ループをphp-apacheサーバーに送ってみます（これは別のターミナルで実行してください）。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run -i --tty load-generator --rm --image<span style=color:#666>=</span>busybox --restart<span style=color:#666>=</span>Never -- /bin/sh -c <span style=color:#b44>&#34;while sleep 0.01; do wget -q -O- http://php-apache; done&#34;</span>
</code></pre></div><p>数分以内に、下記を実行することでCPU負荷が高まっていることを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get hpa
</code></pre></div><pre><code>NAME         REFERENCE                     TARGET      MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   305% / 50%  1         10        1          3m
</code></pre><p>ここでは、CPU使用率はrequestの305%にまで高まっています。
結果として、Deploymentはレプリカ数7にリサイズされました。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment php-apache
</code></pre></div><pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
php-apache   7/7      7           7           19m
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> レプリカ数が安定するまでは数分かかることがあります。負荷量は何らかの方法で制御されているわけではないので、最終的なレプリカ数はこの例とは異なる場合があります。
</div>
<h2 id=負荷の停止>負荷の停止</h2>
<p>ユーザー負荷を止めてこの例を終わらせましょう。</p>
<p>私たちが<code>busybox</code>イメージを使って作成したコンテナ内のターミナルで、<code>&lt;Ctrl> + C</code>を入力して負荷生成を終了させます。</p>
<p>そして結果の状態を確認します（数分後）。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get hpa
</code></pre></div><pre><code>NAME         REFERENCE                     TARGET       MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   0% / 50%     1         10        1          11m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment php-apache
</code></pre></div><pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
php-apache   1/1     1            1           27m
</code></pre><p>ここでCPU使用率は0に下がり、HPAによってオートスケールされたレプリカ数は1に戻ります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> レプリカのオートスケールには数分かかることがあります。
</div>
<h2 id=複数のメトリクスやカスタムメトリクスを基にオートスケーリングする>複数のメトリクスやカスタムメトリクスを基にオートスケーリングする</h2>
<p><code>autoscaling/v2beta2</code> APIバージョンと使うと、<code>php-apache</code> Deploymentをオートスケーリングする際に使う追加のメトリクスを導入することが出来ます。</p>
<p>まず、<code>autoscaling/v2beta2</code>内のHorizontalPodAutoscalerのYAMLファイルを入手します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get hpa.v2beta2.autoscaling -o yaml &gt; /tmp/hpa-v2.yaml
</code></pre></div><p><code>/tmp/hpa-v2.yaml</code>ファイルをエディタで開くと、以下のようなYAMLファイルが見えるはずです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v2beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metrics</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lastScaleTime</span>:<span style=color:#bbb> </span>&lt;some-time&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentMetrics</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></code></pre></div><p><code>targetCPUUtilizationPercentage</code>フィールドは<code>metrics</code>と呼ばれる配列に置換されています。
CPU使用率メトリクスは、Podコンテナで定められたリソースの割合として表されるため、<em>リソースメトリクス</em>です。CPU以外のリソースメトリクスを指定することもできます。デフォルトでは、他にメモリだけがリソースメトリクスとしてサポートされています。これらのリソースはクラスター間で名前が変わることはなく、そして<code>metrics.k8s.io</code> APIが利用可能である限り常に利用可能です。</p>
<p>さらに<code>target.type</code>において<code>Utilization</code>の代わりに<code>AverageValue</code>を使い、<code>target.averageUtilization</code>フィールドの代わりに対応する<code>target.averageValue</code>フィールドを設定することで、リソースメトリクスをrequest値に対する割合に代わり、直接的な値に設定することも可能です。</p>
<p>PodメトリクスとObjectメトリクスという2つの異なる種類のメトリクスが存在し、どちらも<em>カスタムメトリクス</em>とみなされます。これらのメトリクスはクラスター特有の名前を持ち、利用するにはより発展的なクラスター監視設定が必要となります。</p>
<p>これらの代替メトリクスタイプのうち、最初のものが<em>Podメトリクス</em>です。これらのメトリクスはPodを説明し、Podを渡って平均され、レプリカ数を決定するためにターゲット値と比較されます。
これらはほとんどリソースメトリクス同様に機能しますが、<code>target</code>の種類としては<code>AverageValue</code><em>のみ</em>をサポートしている点が異なります。</p>
<p>Podメトリクスはmetricブロックを使って以下のように指定されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>packets-per-second<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span>1k<span style=color:#bbb>
</span></code></pre></div><p>2つ目のメトリクスタイプは<em>Objectメトリクス</em>です。これらのメトリクスはPodを説明するかわりに、同一Namespace内の異なったオブジェクトを説明します。このメトリクスはオブジェクトから取得される必要はありません。単に説明するだけです。Objectメトリクスは<code>target</code>の種類として<code>Value</code>と<code>AverageValue</code>をサポートします。<code>Value</code>では、ターゲットはAPIから返ってきたメトリクスと直接比較されます。<code>AverageValue</code>では、カスタムメトリクスAPIから返ってきた値はターゲットと比較される前にPodの数で除算されます。以下の例は<code>requests-per-second</code>メトリクスのYAML表現です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Value<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>2k<span style=color:#bbb>
</span></code></pre></div><p>もしこのようなmetricブロックを複数提供した場合、HorizontalPodAutoscalerはこれらのメトリクスを順番に処理します。
HorizontalPodAutoscalerはそれぞれのメトリクスについて推奨レプリカ数を算出し、その中で最も多いレプリカ数を採用します。</p>
<p>例えば、もしあなたがネットワークトラフィックについてのメトリクスを収集する監視システムを持っているなら、<code>kubectl edit</code>を使って指定を次のように更新することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v2beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metrics</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>packets-per-second<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span>1k<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Value<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>10k<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lastScaleTime</span>:<span style=color:#bbb> </span>&lt;some-time&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentMetrics</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>10k<span style=color:#bbb>
</span></code></pre></div><p>この時、HorizontalPodAutoscalerはそれぞれのPodがCPU requestの50%を使い、1秒当たり1000パケットを送信し、そしてmain-route
Ingressの裏にあるすべてのPodが合計で1秒当たり10000パケットを送信する状態を保持しようとします。</p>
<h3 id=より詳細なメトリクスをもとにオートスケーリングする>より詳細なメトリクスをもとにオートスケーリングする</h3>
<p>多くのメトリクスパイプラインは、名前もしくは <em>labels</em> と呼ばれる追加の記述子の組み合わせによって説明することができます。全てのリソースメトリクス以外のメトリクスタイプ（Pod、Object、そして下で説明されている外部メトリクス）において、メトリクスパイプラインに渡す追加のラベルセレクターを指定することができます。例えば、もしあなたが<code>http_requests</code>メトリクスを<code>verb</code>ラベルとともに収集しているなら、下記のmetricブロックを指定してGETリクエストにのみ基づいてスケールさせることができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http_requests<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb> </span>{<span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb> </span>{<span style=color:green;font-weight:700>verb</span>:<span style=color:#bbb> </span>GET}}<span style=color:#bbb>
</span></code></pre></div><p>このセレクターは完全なKubernetesラベルセレクターと同じ文法を利用します。もし名前とセレクターが複数の系列に一致した場合、この監視パイプラインはどのようにして複数の系列を一つの値にまとめるかを決定します。このセレクターは付加的なもので、ターゲットオブジェクト（<code>Pods</code>タイプの場合は対象Pod、<code>Object</code>タイプの場合は説明されるオブジェクト）では<strong>ない</strong>オブジェクトを説明するメトリクスを選択することは出来ません。</p>
<h3 id=kubernetesオブジェクトと関係ないメトリクスに基づいたオートスケーリング>Kubernetesオブジェクトと関係ないメトリクスに基づいたオートスケーリング</h3>
<p>Kubernetes上で動いているアプリケーションを、Kubernetes Namespaceと直接的な関係がないサービスを説明するメトリクスのような、Kubernetesクラスター内のオブジェクトと明確な関係が無いメトリクスを基にオートスケールする必要があるかもしれません。Kubernetes 1.10以降では、このようなユースケースを<em>外部メトリクス</em>によって解決できます。</p>
<p>外部メトリクスを使うにはあなたの監視システムについての知識が必要となります。この設定はカスタムメトリクスを使うときのものに似ています。外部メトリクスを使うとあなたの監視システムのあらゆる利用可能なメトリクスに基づいてクラスターをオートスケールできるようになります。上記のように<code>metric</code>ブロックで<code>name</code>と<code>selector</code>を設定し、<code>Object</code>のかわりに<code>External</code>メトリクスタイプを使います。
もし複数の時系列が<code>metricSelector</code>により一致した場合は、それらの値の合計がHorizontalPodAutoscalerに使われます。
外部メトリクスは<code>Value</code>と<code>AverageValue</code>の両方のターゲットタイプをサポートしています。これらの機能は<code>Object</code>タイプを利用するときとまったく同じです。</p>
<p>例えばもしあなたのアプリケーションがホストされたキューサービスからのタスクを処理している場合、あなたは下記のセクションをHorizontalPodAutoscalerマニフェストに追記し、未処理のタスク30個あたり1つのワーカーを必要とすることを指定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>External<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>external</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>queue_messages_ready<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;queue=worker_tasks&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></code></pre></div><p>可能なら、クラスター管理者がカスタムメトリクスAPIを保護することを簡単にするため、外部メトリクスのかわりにカスタムメトリクスを用いることが望ましいです。外部メトリクスAPIは潜在的に全てのメトリクスへのアクセスを許可するため、クラスター管理者はこれを公開する際には注意が必要です。</p>
<h2 id=付録-horizontal-pod-autoscaler-status-conditions>付録: Horizontal Pod Autoscaler status conditions</h2>
<p><code>autoscaling/v2beta2</code>形式のHorizontalPodAutoscalerを使っている場合は、KubernetesによるHorizontalPodAutoscaler上の<em>status conditions</em>セットを見ることができます。status conditionsはHorizontalPodAutoscalerがスケール可能かどうか、そして現時点でそれが何らかの方法で制限されているかどうかを示しています。</p>
<p>このconditionsは<code>status.conditions</code>フィールドに現れます。HorizontalPodAutoscalerに影響しているconditionsを確認するために、<code>kubectl describe hpa</code>を利用できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe hpa cm-test
</code></pre></div><pre><code>Name:                           cm-test
Namespace:                      prom
Labels:                         &lt;none&gt;
Annotations:                    &lt;none&gt;
CreationTimestamp:              Fri, 16 Jun 2017 18:09:22 +0000
Reference:                      ReplicationController/cm-test
Metrics:                        ( current / target )
  &quot;http_requests&quot; on pods:      66m / 500m
Min replicas:                   1
Max replicas:                   4
ReplicationController pods:     1 current / 1 desired
Conditions:
  Type                  Status  Reason                  Message
  ----                  ------  ------                  -------
  AbleToScale           True    ReadyForNewScale        the last scale time was sufficiently old as to warrant a new scale
  ScalingActive         True    ValidMetricFound        the HPA was able to successfully calculate a replica count from pods metric http_requests
  ScalingLimited        False   DesiredWithinRange      the desired replica count is within the acceptable range
Events:
</code></pre><p>このHorizontalPodAutoscalerにおいて、いくつかの正常な状態のconditionsを見ることができます。まず最初に、<code>AbleToScale</code>は、HPAがスケール状況を取得し、更新させることが出来るかどうかだけでなく、何らかのbackoffに関連した状況がスケーリングを妨げていないかを示しています。2番目に、<code>ScalingActive</code>は、HPAが有効化されているかどうか（例えば、レプリカ数のターゲットがゼロでないこと）や、望ましいスケールを算出できるかどうかを示します。もしこれが<code>False</code>の場合、大体はメトリクスの取得において問題があることを示しています。最後に、一番最後の状況である<code>ScalingLimited</code>は、HorizontalPodAutoscalerの最大値や最小値によって望ましいスケールがキャップされていることを示しています。この指標を見てHorizontalPodAutoscaler上の最大・最小レプリカ数制限を増やす、もしくは減らす検討ができます。</p>
<h2 id=付録-数量>付録: 数量</h2>
<p>全てのHorizontalPodAutoscalerおよびメトリクスAPIにおけるメトリクスは<a class=glossary-tooltip title="A whole-number representation of small or large numbers using SI suffixes." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-quantity" target=_blank aria-label=quantity>quantity</a>として知られる特殊な整数表記によって指定されます。例えば、<code>10500m</code>という数量は10進数表記で<code>10.5</code>と書くことができます。メトリクスAPIは可能であれば接尾辞を用いない整数を返し、そうでない場合は基本的にミリ単位での数量を返します。これはメトリクス値が<code>1</code>と<code>1500m</code>の間で、もしくは10進法表記で書かれた場合は<code>1</code>と<code>1.5</code>の間で変動するということを意味します。</p>
<h2 id=付録-その他の起きうるシナリオ>付録: その他の起きうるシナリオ</h2>
<h3 id=autoscalerを宣言的に作成する>Autoscalerを宣言的に作成する</h3>
<p><code>kubectl autoscale</code>コマンドを使って命令的にHorizontalPodAutoscalerを作るかわりに、下記のファイルを使って宣言的に作成することができます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/hpa/php-apache.yaml download=application/hpa/php-apache.yaml><code>application/hpa/php-apache.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-hpa-php-apache-yaml')" title="Copy application/hpa/php-apache.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-hpa-php-apache-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>下記のコマンドを実行してAutoscalerを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/application/hpa/php-apache.yaml
</code></pre></div><pre><code>horizontalpodautoscaler.autoscaling/php-apache created
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ca3bc4e31dfe46d5044a3b93eb804ee9>4.8 - Jobの実行</h1>
<div class=lead>並列処理を使用してJobを実行します。</div>
</div>
<div class=td-content>
<h1 id=pg-964bdff888520740e5e221695245678d>4.8.1 - CronJobを使用して自動化タスクを実行する</h1>
<p>CronJobは、Kubernetes v1.21で一般利用(GA)に昇格しました。古いバージョンのKubernetesを使用している場合、正確な情報を参照できるように、使用しているバージョンのKubernetesのドキュメントを参照してください。古いKubernetesのバージョンでは、<code>batch/v1</code> CronJob APIはサポートされていません。</p>
<p><a class=glossary-tooltip title="A repeating task (a Job) that runs on a regular schedule." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/cron-jobs/ target=_blank aria-label=CronJob>CronJob</a>を使用すると、<a class=glossary-tooltip title="A finite or batch task that runs to completion." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>を時間ベースのスケジュールで実行できるようになります。この自動化されたJobは、LinuxまたはUNIXシステム上の<a href=https://ja.wikipedia.org/wiki/Cron>Cron</a>のように実行されます。</p>
<p>CronJobは、バックアップやメールの送信など、定期的なタスクや繰り返しのタスクを作成する時に便利です。CronJobはそれぞれのタスクを、たとえばアクティビティが少ない期間など、特定の時間にスケジューリングすることもできます。</p>
<p>CronJobには制限と特性があります。たとえば、特定の状況下では、1つのCronJobが複数のJobを作成する可能性があるため、Jobは冪等性を持つようにしなければいけません。</p>
<p>制限に関する詳しい情報については、<a href=/ja/docs/concepts/workloads/controllers/cron-jobs/>CronJob</a>を参照してください。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
</li>
</ul>
<h2 id=cronjobを作成する>CronJobを作成する</h2>
<p>CronJobには設定ファイルが必要です。次の例のCronJobの<code>.spec</code>は、現在の時刻とhelloというメッセージを1分ごとに表示します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/job/cronjob.yaml download=application/job/cronjob.yaml><code>application/job/cronjob.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-cronjob-yaml')" title="Copy application/job/cronjob.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-cronjob-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronJob<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*/1 * * * *&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jobTemplate</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- date; echo Hello from the Kubernetes cluster<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>次のコマンドで例のCronJobを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/application/job/cronjob.yaml
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>cronjob.batch/hello created
</code></pre><p>CronJobを作成したら、次のコマンドで状態を取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get cronjob hello
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     0        &lt;none&gt;          10s
</code></pre><p>コマンドの結果からわかるように、CronJobはまだスケジュールされておらず、まだ何のJobも実行していません。約1分以内にJobが作成されるのを見てみましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get <span style=color:#a2f>jobs</span> --watch
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME               COMPLETIONS   DURATION   AGE
hello-4111706356   0/1                      0s
hello-4111706356   0/1           0s         0s
hello-4111706356   1/1           5s         5s
</code></pre><p>"hello"CronJobによってスケジュールされたJobが1つ実行中になっていることがわかります。Jobを見るのをやめて、再度CronJobを表示して、Jobがスケジュールされたことを確認してみます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get cronjob hello
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     0        50s             75s
</code></pre><p>CronJob<code>hello</code>が、<code>LAST SCHEDULE</code>で指定された時間にJobを正しくスケジュールしたことが確認できるはずです。現在、activeなJobの数は0です。つまり、Jobは完了または失敗したことがわかります。</p>
<p>それでは、最後にスケジュールされたJobの作成と、Podの1つの標準出力を表示してみましょう。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Jobの名前とPodの名前は異なります。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># &#34;hello-4111706356&#34; の部分は、あなたのシステム上のJobの名前に置き換えてください。</span>
<span style=color:#b8860b>pods</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span>job-name<span style=color:#666>=</span>hello-4111706356 --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items<span style=color:#666>[</span>*<span style=color:#666>]</span>.metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
</code></pre></div><p>Podのログを表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs <span style=color:#b8860b>$pods</span>
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>Fri Feb 22 11:02:09 UTC 2019
Hello from the Kubernetes cluster
</code></pre><h2 id=cronjobの削除>CronJobの削除</h2>
<p>CronJobが必要なくなったときは、<code>kubectl delete cronjob &lt;cronjob name></code>で削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete cronjob hello
</code></pre></div><p>CronJobを削除すると、すべてのJobと、そのJobが作成したPodが削除され、追加のJobの作成が停止されます。Jobの削除について詳しく知りたい場合は、<a href=/ja/docs/concepts/workloads/controllers/garbage-collection/>ガベージコレクション</a>を読んでください。</p>
<h2 id=writing-a-cron-job-spec>CronJobのspecを書く</h2>
<p>すべてのKubernetesの設定と同じように、CronJobにも<code>apiVersion</code>、<code>kind</code>、<code>metadata</code>のフィールドが必要です。設定ファイルの扱い方についての一般的な情報については、<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>アプリケーションのデプロイ</a>と<a href=/ja/docs/concepts/overview/working-with-objects/object-management/>kubectlを使用してリソースを管理する</a>を読んでください。</p>
<p>CronJobの設定には、<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code>セクション</a>も必要です。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> CronJobの特に<code>spec</code>へのすべての修正は、それ以降の実行にのみ適用されます。
</div>
<h3 id=schedule>Schedule</h3>
<p><code>.spec.schedule</code>は、<code>.spec</code>には必須のフィールドです。<code>0 * * * *</code>や<code>@hourly</code>などの<a href=https://ja.wikipedia.org/wiki/Cron>Cron</a>形式の文字列を取り、Jobの作成と実行のスケジュール時間を指定します。</p>
<p>フォーマットにはVixie cronのステップ値(step value)も指定できます。<a href=https://www.freebsd.org/cgi/man.cgi?crontab%285%29>FreeBSDのマニュアル</a>では次のように説明されています。</p>
<blockquote>
<p>ステップ値は範囲指定と組み合わせて使用できます。範囲の後ろに<code>/&lt;number></code>を付けると、範囲全体で指定したnumberの値ごとにスキップすることを意味します。たとえば、<code>0-23/2</code>をhoursフィールドに指定すると、2時間毎にコマンド実行を指定することになります(V7標準では代わりに<code>0,2,4,6,8,10,12,14,16,18,20,22</code>と指定する必要があります)。ステップはアスタリスクの後ろにつけることもできます。そのため、「2時間毎に実行」したい場合は、単純に<code>*/2</code>と指定できます。</p>
</blockquote>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> スケジュール内の疑問符<code>?</code>はアスタリスク<code>*</code>と同じ意味を持ちます。つまり、与えられたフィールドには任意の値が使えるという意味になります。
</div>
<h3 id=job-template>Job Template</h3>
<p><code>.spec.jobTemplate</code>はJobのテンプレートであり、必須です。<a href=/docs/concepts/workloads/controllers/job/>Job</a>と完全に同一のスキーマを持ちますが、フィールドがネストされている点と、<code>apiVersion</code>と<code>kind</code>が存在しない点だけが異なります。Jobの<code>.spec</code>を書くための情報については、<a href=/docs/concepts/workloads/controllers/job/#writing-a-job-spec>JobのSpecを書く</a>を参照してください。</p>
<h3 id=starting-deadline>Starting Deadline</h3>
<p><code>.spec.startingDeadlineSeconds</code>フィールドはオプションです。何かの理由でスケジュールに間に合わなかった場合に適用される、Jobの開始のデッドライン(締め切り)を秒数で指定します。デッドラインを過ぎると、CronJobはJobを開始しません。この場合にデッドラインに間に合わなかったJobは、失敗したJobとしてカウントされます。もしこのフィールドが指定されなかった場合、Jobはデッドラインを持ちません。</p>
<p><code>.spec.startingDeadlineSeconds</code>フィールドがnull以外に設定された場合、CronJobコントローラーはJobの作成が期待される時間と現在時刻との間の時間を計測します。もしその差が制限よりも大きかった場合、その実行はスキップされます。</p>
<p>たとえば、この値が<code>200</code>に設定された場合、実際のスケジュールの最大200秒後までに作成されるJobだけが許可されます。</p>
<h3 id=concurrency-policy>Concurrency Policy</h3>
<p><code>.spec.concurrencyPolicy</code>フィールドもオプションです。このフィールドは、このCronJobで作成されたJobの並列実行をどのように扱うかを指定します。specには以下のconcurrency policyのいずれかを指定します。</p>
<ul>
<li><code>Allow</code> (デフォルト): CronJobがJobを並列に実行することを許可します。</li>
<li><code>Forbid</code>: CronJobの並列実行を禁止します。もし新しいJobの実行時に過去のJobがまだ完了していなかった場合、CronJobは新しいJobの実行をスキップします。</li>
<li><code>Replace</code>: もし新しいJobの実行の時間になっても過去のJobの実行が完了していなかった場合、CronJobは現在の実行中のJobを新しいJobで置換します。</li>
</ul>
<p>concurrency policyは、同じCronJobが作成したJobにのみ適用されます。もし複数のCronJobがある場合、それぞれのJobの並列実行は常に許可されます。</p>
<h3 id=suspend>Suspend</h3>
<p><code>.spec.suspend</code>フィールドもオプションです。このフィールドを<code>true</code>に設定すると、すべての後続の実行がサスペンド(一時停止)されます。この設定はすでに実行開始したJobには適用されません。デフォルトはfalseです。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> スケジュールされた時間中にサスペンドされた実行は、見逃されたJob(missed job)としてカウントされます。<a href=#starting-deadline>starting deadline</a>が設定されていない既存のCronJob<code>.spec.suspend</code>が<code>true</code>から<code>false</code>に変更されると、見逃されたJobは即座にスケジュールされます。
</div>
<h3 id=job-history-limit>Job History Limit</h3>
<p><code>.spec.successfulJobsHistoryLimit</code>と<code>.spec.failedJobsHistoryLimit</code>フィールドはオプションです。これらのフィールドには、完了したJobと失敗したJobをいくつ保持するかを指定します。デフォルトでは、それぞれ3と1に設定されます。リミットを<code>0</code>に設定すると、対応する種類のJobを実行完了後に何も保持しなくなります。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9e63850014876afaebd1561f70bb8f6b>4.8.2 - 静的な処理の割り当てを使用した並列処理のためのインデックス付きJob</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code>
</div>
<p>この例では、複数の並列ワーカープロセスを使用するKubernetesのJobを実行します。各ワーカーは、それぞれが自分のPod内で実行される異なるコンテナです。Podはコントロールプレーンが自動的に設定する<em>インデックス値</em>を持ち、この値を利用することで、各Podは処理するタスク全体のどの部分を処理するのかを特定できます。</p>
<p>Podのインデックスは、<a class=glossary-tooltip title="A key-value pair that is used to attach arbitrary non-identifying metadata to objects." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/annotations target=_blank aria-label=アノテーション>アノテーション</a>内の<code>batch.kubernetes.io/job-completion-index</code>を整数値の文字列表現として利用できます。コンテナ化されたタスクプロセスがこのインデックスを取得できるようにするために、このアノテーションの値は<a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#the-downward-api>downward API</a>の仕組みを利用することで公開できます。利便性のために、コントロールプレーンは自動的にdownward APIを設定して、<code>JOB_COMPLETION_INDEX</code>環境変数にインデックスを公開します。</p>
<p>以下に、この例で実行するステップの概要を示します。</p>
<ol>
<li><strong>completionのインデックスを使用してJobのマニフェストを定義する</strong>。downward APIはPodのインデックスのアノテーションを環境変数またはファイルとしてコンテナに渡してくれます。</li>
<li><strong>そのマニフェストに基づいてインデックス付き(Indexed)のJobを開始する</strong>。</li>
</ol>
<h2 id=始める前に>始める前に</h2>
<p>あらかじめ基本的な非並列の<a href=/docs/concepts/workloads/controllers/job/>Job</a>の使用に慣れている必要があります。</p>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.21.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>インデックス付きJobを作成できるようにするには、<a href=/docs/reference/command-line-tools-reference/kube-apiserver/>APIサーバー</a>と<a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>コントローラーマネージャー</a>上で<code>IndexedJob</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にしていることを確認してください。</p>
<h2 id=アプローチを選択する>アプローチを選択する</h2>
<p>ワーカープログラムから処理アイテムにアクセスするには、いくつかの選択肢があります。</p>
<ol>
<li><code>JOB_COMPLETION_INDEX</code>環境変数を読み込む。Job<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>は、この変数をcompletion indexを含むアノテーションに自動的にリンクします。</li>
<li>completion indexを含むファイルを読み込む。</li>
<li>プログラムを修正できない場合、プログラムをスクリプトでラップし、上のいずれかの方法でインデックスを読み取り、プログラムが入力として使用できるものに変換する。</li>
</ol>
<p>この例では、3番目のオプションを選択肢して、<a href=https://man7.org/linux/man-pages/man1/rev.1.html>rev</a>ユーティリティを実行したいと考えているとしましょう。このプログラムはファイルを引数として受け取り、内容を逆さまに表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>rev data.txt
</code></pre></div><p><code>rev</code>ツールは<a href=https://hub.docker.com/_/busybox><code>busybox</code></a>コンテナイメージから利用できます。</p>
<p>これは単なる例であるため、各Podはごく簡単な処理(短い文字列を逆にする)をするだけです。現実のワークロードでは、たとえば、シーンデータをもとに60秒の動画を生成するというようなタスクを記述したJobを作成するかもしれません。ビデオレンダリングJobの各処理アイテムは、ビデオクリップの特定のフレームのレンダリングを行うものになるでしょう。その場合、インデックス付きの完了が意味するのは、クリップの最初からフレームをカウントすることで、Job内の各Podがレンダリングと公開をするのがどのフレームであるかがわかるということです。</p>
<h2 id=インデックス付きjobを定義する>インデックス付きJobを定義する</h2>
<p>以下は、completion modeとして<code>Indexed</code>を使用するJobのマニフェストの例です。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/job/indexed-job.yaml download=application/job/indexed-job.yaml><code>application/job/indexed-job.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-indexed-job-yaml')" title="Copy application/job/indexed-job.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-indexed-job-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;indexed-job&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completionMode</span>:<span style=color:#bbb> </span>Indexed<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;input&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/bash&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;bash&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          items=(foo bar baz qux xyz)
</span><span style=color:#b44;font-style:italic>          echo ${items[$JOB_COMPLETION_INDEX]} &gt; /input/data.txt</span><span style=color:#bbb>          
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;worker&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/busybox&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;rev&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;/input/data.txt&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>上記の例では、Jobコントローラーがすべてのコンテナに設定する組み込みの<code>JOB_COMPLETION_INDEX</code>環境変数を使っています。<a href=/ja/docs/concepts/workloads/pods/init-containers/>initコンテナ</a>がインデックスを静的な値にマッピングし、その値をファイルに書き込み、ファイルを<a href=/docs/concepts/storage/volumes/#emptydir>emptyDir volume</a>を介してワーカーを実行しているコンテナと共有します。オプションとして、インデックスとコンテナに公開するために<a href=/ja/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>downward APIを使用して独自の環境変数を定義する</a>こともできます。<a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>環境変数やファイルとして設定したConfigMap</a>から値のリストを読み込むという選択肢もあります。</p>
<p>他には、以下の例のように、直接<a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#store-pod-fields>downward APIを使用してアノテーションの値をボリュームファイルとして渡す</a>こともできます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/job/indexed-job-vol.yaml download=application/job/indexed-job-vol.yaml><code>application/job/indexed-job-vol.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-indexed-job-vol-yaml')" title="Copy application/job/indexed-job-vol.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-indexed-job-vol-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;indexed-job&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completionMode</span>:<span style=color:#bbb> </span>Indexed<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;worker&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/busybox&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;rev&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;/input/data.txt&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;data.txt&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.annotations[&#39;batch.kubernetes.io/job-completion-index&#39;]</code></pre></div>
</div>
</div>
<h2 id=jobを実行する>Jobを実行する</h2>
<p>次のコマンドでJobを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドでは1番目のアプローチを使っています ($JOB_COMPLETION_INDEX に依存しています)</span>
kubectl apply -f https://kubernetes.io/examples/application/job/indexed-job.yaml
</code></pre></div><p>このJobを作成したら、コントロールプレーンは指定した各インデックスごとに一連のPodを作成します。<code>.spec.parallelism</code>の値が同時に実行できるPodの数を決定し、<code>.spec.completions</code>の値がJobが作成するPodの合計数を決定します。</p>
<p><code>.spec.parallelism</code>は<code>.spec.completions</code>より小さいため、コントロールプレーンは別のPodを開始する前に最初のPodの一部が完了するまで待機します。</p>
<p>Jobを作成したら、少し待ってから進行状況を確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe jobs/indexed-job
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>Name:              indexed-job
Namespace:         default
Selector:          controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
Labels:            controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
                   job-name=indexed-job
Annotations:       &lt;none&gt;
Parallelism:       3
Completions:       5
Start Time:        Thu, 11 Mar 2021 15:47:34 +0000
Pods Statuses:     2 Running / 3 Succeeded / 0 Failed
Completed Indexes: 0-2
Pod Template:
  Labels:  controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
           job-name=indexed-job
  Init Containers:
   input:
    Image:      docker.io/library/bash
    Port:       &lt;none&gt;
    Host Port:  &lt;none&gt;
    Command:
      bash
      -c
      items=(foo bar baz qux xyz)
      echo ${items[$JOB_COMPLETION_INDEX]} &gt; /input/data.txt

    Environment:  &lt;none&gt;
    Mounts:
      /input from input (rw)
  Containers:
   worker:
    Image:      docker.io/library/busybox
    Port:       &lt;none&gt;
    Host Port:  &lt;none&gt;
    Command:
      rev
      /input/data.txt
    Environment:  &lt;none&gt;
    Mounts:
      /input from input (rw)
  Volumes:
   input:
    Type:       EmptyDir (a temporary directory that shares a pod's lifetime)
    Medium:
    SizeLimit:  &lt;unset&gt;
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-njkjj
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-9kd4h
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-qjwsz
  Normal  SuccessfulCreate  1s    job-controller  Created pod: indexed-job-fdhq5
  Normal  SuccessfulCreate  1s    job-controller  Created pod: indexed-job-ncslj
</code></pre><p>この例では、各インデックスごとにカスタムの値を使用してJobを実行します。次のコマンドでPodの1つの出力を確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs indexed-job-fdhq5 <span style=color:#080;font-style:italic># これを対象のJobのPodの名前に一致するように変更してください。</span>
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>xuq
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b74b959f5a531003dd0653dfbfc2e88b>4.9 - クラスター内アプリケーションへのアクセス</h1>
<div class=lead>クラスター内アプリケーションへアクセスできるようにするために、ロードバランシングやポートフォワーディングの設定、ファイアウォールやDNS設定のセットアップを行います。</div>
</div>
<div class=td-content>
<h1 id=pg-777447042cd4e81df3fa5beb3357a485>4.9.1 - Web UI (Dashboard)</h1>
<p>ダッシュボードは、WebベースのKubernetesユーザーインターフェイスです。
ダッシュボードを使用して、コンテナ化されたアプリケーションをKubernetesクラスターにデプロイしたり、
コンテナ化されたアプリケーションをトラブルシューティングしたり、クラスターリソースを管理したりすることができます。
ダッシュボードを使用して、クラスター上で実行されているアプリケーションの概要を把握したり、
個々のKubernetesリソース(Deployments、Jobs、DaemonSetsなど)を作成または修正したりすることができます。
たとえば、Deploymentのスケール、ローリングアップデートの開始、Podの再起動、
デプロイウィザードを使用した新しいアプリケーションのデプロイなどが可能です。</p>
<p>ダッシュボードでは、クラスター内のKubernetesリソースの状態や、発生した可能性のあるエラーに関する情報も提供されます。</p>
<p><img src=/images/docs/ui-dashboard.png alt="Kubernetes Dashboard UI"></p>
<h2 id=ダッシュボードuiのデプロイ>ダッシュボードUIのデプロイ</h2>
<p>ダッシュボードUIはデフォルトではデプロイされていません。デプロイするには、以下のコマンドを実行します:</p>
<pre><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml
</code></pre><h2 id=ダッシュボードuiへのアクセス>ダッシュボードUIへのアクセス</h2>
<p>クラスターデータを保護するために、ダッシュボードはデフォルトで最小限のRBAC構成でデプロイします。
現在、ダッシュボードはBearer Tokenによるログインのみをサポートしています。
このデモ用のトークンを作成するには、
<a href=https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md>サンプルユーザーの作成</a>ガイドに従ってください。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> チュートリアルで作成されたサンプルユーザーには管理者権限が与えられ、教育目的のみに使用されます。
</div>
<h3 id=コマンドラインプロキシー>コマンドラインプロキシー</h3>
<p>以下のコマンドを実行することで、kubectlコマンドラインツールを使ってダッシュボードにアクセスすることができます:</p>
<pre><code>kubectl proxy
</code></pre><p>kubectlは、ダッシュボードを http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/ で利用できるようにします。</p>
<p>UIはコマンドを実行しているマシンから <em>のみ</em> アクセスできます。オプションについては<code>kubectl proxy --help</code>を参照してください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Kubeconfigの認証方法は、外部IDプロバイダーやx509証明書ベースの認証には対応していません。
</div>
<h2 id=ウェルカムビュー>ウェルカムビュー</h2>
<p>空のクラスターでダッシュボードにアクセスすると、ウェルカムページが表示されます。
このページには、このドキュメントへのリンクと、最初のアプリケーションをデプロイするためのボタンが含まれています。
さらに、クラスターの<code>kube-system</code><a href=/docs/tasks/administer-cluster/namespaces/>名前空間</a>でデフォルトで実行されているシステムアプリケーション、たとえばダッシュボード自体を見ることができます。</p>
<p><img src=/images/docs/ui-dashboard-zerostate.png alt="Kubernetes Dashboard welcome page"></p>
<h2 id=コンテナ化されたアプリケーションのデプロイ>コンテナ化されたアプリケーションのデプロイ</h2>
<p>ダッシュボードを使用すると、簡単なウィザードでコンテナ化されたアプリケーションをDeploymentとオプションのServiceとして作成してデプロイすることができます。
アプリケーションの詳細を手動で指定するか、アプリケーションの設定を含むYAMLまたはJSONファイルをアップロードすることができます。</p>
<p>任意のページの右上にある<strong>CREATE</strong>ボタンをクリックして開始します。</p>
<h3 id=アプリケーションの詳細の指定>アプリケーションの詳細の指定</h3>
<p>デプロイウィザードでは、以下の情報を入力する必要があります:</p>
<ul>
<li>
<p><strong>App name</strong> (必須): アプリケーションの名前です。
その名前の<a href=/ja/docs/concepts/overview/working-with-objects/labels/>label</a>は、デプロイされるDeploymentとServiceに追加されます。</p>
<p>アプリケーション名は、選択したKubernetes<a href=/docs/tasks/administer-cluster/namespaces/>名前空間</a>内で一意である必要があります。
小文字で始まり、小文字または数字で終わり、小文字、数字、ダッシュ(-)のみを含む必要があります。文字数は24文字に制限されています。先頭と末尾のスペースは無視されます。</p>
</li>
<li>
<p><strong>Container image</strong> (必須): 任意のレジストリ上の公開Docker<a href=/docs/concepts/containers/images/>コンテナイメージ</a>、またはプライベートイメージ(一般的にはGoogle Container RegistryやDocker Hub上でホストされている)のURLです。
コンテナイメージの指定はコロンで終わらせる必要があります。</p>
<p>クラスタ全体で必要な数のPodを維持するために、<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>が作成されます。</p>
</li>
<li>
<p><strong>Service</strong> (任意): アプリケーションのいくつかの部分(たとえばフロントエンド)では、
<a href=/ja/docs/concepts/services-networking/service/>Service</a>をクラスター外の外部、おそらくパブリックIPアドレス(外部サービス)に公開したいと思うかもしれません。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 外部サービスの場合は、そのために1つ以上のポートを開放する必要があるでしょう。
</div>
<p>クラスター内部からしか見えないその他のサービスは、内部サービスと呼ばれます。</p>
<p>サービスの種類にかかわらず、サービスを作成し、コンテナがポート(受信)をリッスンする場合は、
2つのポートを指定する必要があります。
サービスは、ポート(受信)をコンテナから見たターゲットポートにマッピングして作成されます。
このサービスは、デプロイされたPodにルーティングされます。サポートされるプロトコルはTCPとUDPです。
このサービスの内部DNS名は、上記のアプリケーション名として指定した値になります。</p>
</li>
</ul>
<p>必要に応じて、<strong>高度なオプション</strong>セクションを展開して、より多くの設定を指定することができます:</p>
<ul>
<li>
<p><strong>Description</strong>: ここで入力したテキストは、
<a href=/ja/docs/concepts/overview/working-with-objects/annotations/>アノテーション</a>としてDeploymentに追加され、アプリケーションの詳細に表示されます。</p>
</li>
<li>
<p><strong>Labels</strong>: アプリケーションに使用するデフォルトの<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベル</a>は、アプリケーション名とバージョンです。
リリース、環境、ティア、パーティション、リリーストラックなど、Deployment、Service(存在する場合)、Podに適用する追加のラベルを指定できます。</p>
<p>例:</p>
<pre><code class=language-conf data-lang=conf>release=1.0
tier=frontend
environment=pod
track=stable
</code></pre></li>
<li>
<p><strong>Namespace</strong>: Kubernetesは、同じ物理クラスターを基盤とする複数の仮想クラスターをサポートしています。
これらの仮想クラスタは<a href=/docs/tasks/administer-cluster/namespaces/>名前空間</a> と呼ばれます。
これにより、リソースを論理的に名前のついたグループに分割することができます。</p>
<p>ダッシュボードでは、利用可能なすべての名前空間がドロップダウンリストに表示され、新しい名前空間を作成することができます。
名前空間名には、最大63文字の英数字とダッシュ(-)を含めることができますが、大文字を含めることはできません。
名前空間名は数字だけで構成されるべきではありません。
名前が10などの数値として設定されている場合、Podはデフォルトの名前空間に配置されます。</p>
<p>名前空間の作成に成功した場合は、デフォルトで選択されます。
作成に失敗した場合は、最初の名前空間が選択されます。</p>
</li>
<li>
<p><strong>Image Pull Secret</strong>:
指定されたDockerコンテナイメージが非公開の場合、
<a href=/ja/docs/concepts/configuration/secret/>pull secret</a>の認証情報が必要になる場合があります。</p>
<p>ダッシュボードでは、利用可能なすべてのSecretがドロップダウンリストに表示され、新しいSecretを作成できます。
Secret名は DNSドメイン名の構文に従う必要があります。たとえば、<code>new.image-pull.secret</code>です。
Secretの内容はbase64エンコードされ、<a href=/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod><code>.dockercfg</code></a>ファイルで指定されている必要があります。
Secret名は最大253文字で構成されます。</p>
<p>イメージプルシークレットの作成に成功した場合は、デフォルトで選択されています。作成に失敗した場合は、シークレットは適用されません。</p>
</li>
<li>
<p><strong>CPU requirement (cores)<strong>と</strong>Memory requirement (MiB)</strong>:
コンテナの最小<a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>リソース制限</a>を指定することができます。デフォルトでは、PodはCPUとメモリの制限がない状態で実行されます。</p>
</li>
<li>
<p><strong>Run command</strong>と<strong>Run command arguments</strong>:
デフォルトでは、コンテナは指定されたDockerイメージのデフォルトの<a href=/docs/tasks/inject-data-application/define-command-argument-container/>entrypointコマンド</a>を実行します。
コマンドのオプションと引数を使ってデフォルトを上書きすることができます。</p>
</li>
<li>
<p><strong>Run as privileged</strong>: この設定は、<a href=/ja/docs/concepts/workloads/pods/pod/#privileged-mode-for-pod-containers>特権コンテナ</a>内のプロセスが、ホスト上でrootとして実行されているプロセスと同等であるかどうかを決定します。特権コンテナは、
ネットワークスタックの操作やデバイスへのアクセスなどの機能を利用できます。</p>
</li>
<li>
<p><strong>Environment variables</strong>: Kubernetesは<a href=/ja/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>環境変数</a>を介してServiceを公開しています。
環境変数を作成したり、環境変数の値を使ってコマンドに引数を渡したりすることができます。
環境変数の値はServiceを見つけるためにアプリケーションで利用できます。
値は<code>$(VAR_NAME)</code>構文を使用して他の変数を参照できます。</p>
</li>
</ul>
<h3 id=yamlまたはjsonファイルのアップロード>YAMLまたはJSONファイルのアップロード</h3>
<p>Kubernetesは宣言的な設定をサポートしています。
このスタイルでは、すべての設定は Kubernetes <a href=/ja/docs/concepts/overview/kubernetes-api/>API</a>リソーススキーマを使用してYAMLまたは JSON設定ファイルに格納されます。</p>
<p>デプロイウィザードでアプリケーションの詳細を指定する代わりに、
YAMLまたはJSONファイルでアプリケーションを定義し、ダッシュボードを使用してファイルをアップロードできます。</p>
<h2 id=ダッシュボードの使用>ダッシュボードの使用</h2>
<p>以下のセクションでは、Kubernetes Dashboard UIのビュー、それらが提供するものとその使用方法について説明します。</p>
<h3 id=ナビゲーション>ナビゲーション</h3>
<p>クラスターにKubernetesオブジェクトが定義されている場合、ダッシュボードではそれらのオブジェクトが初期表示されます。
デフォルトでは <em>default</em> 名前空間のオブジェクトのみが表示されますが、これはナビゲーションメニューにある名前空間セレクターで変更できます。</p>
<p>ダッシュボードにはほとんどのKubernetesオブジェクトの種類が表示され、いくつかのメニューカテゴリーにグループ化されています。</p>
<h4 id=管理者の概要>管理者の概要</h4>
<p>クラスターと名前空間の管理者向けに、ダッシュボードにはノード、名前空間、永続ボリュームが一覧表示され、それらの詳細ビューが用意されています。
ノードリストビューには、すべてのノードにわたって集計されたCPUとメモリーのメトリクスが表示されます。
詳細ビューには、ノードのメトリクス、仕様、ステータス、割り当てられたリソース、イベント、ノード上で実行されているPodが表示されます。</p>
<h4 id=ワークロード>ワークロード</h4>
<p>選択した名前空間で実行されているすべてのアプリケーションを表示します。
このビューでは、アプリケーションがワークロードの種類(例：Deployment、ReplicaSet、StatefulSetなど)ごとに一覧表示され、各ワークロードの種類を個別に表示することができます。
リストには、ReplicaSetの準備ができたPodの数やPodの現在のメモリ使用量など、ワークロードに関する実用的な情報がまとめられています。</p>
<p>ワークロードの詳細ビューには、ステータスや仕様情報、オブジェクト間の表面関係が表示されます。
たとえば、ReplicaSetが制御しているPodや、新しいReplicaSet、DeploymentのためのHorizontal Pod Autoscalerなどです。</p>
<h4 id=service>Service</h4>
<p>外部の世界にサービスを公開し、クラスター内でサービスを発見できるようにするKubernetesリソースを表示します。
そのため、ServiceとIngressのビューには、それらが対象とするPod、クラスター接続の内部エンドポイント、外部ユーザーの外部エンドポイントが表示されます。</p>
<h4 id=ストレージ>ストレージ</h4>
<p>ストレージビューには、アプリケーションがデータを保存するために使用するPersistentVolumeClaimリソースが表示されます。</p>
<h4 id=configmapとsecret>ConfigMapとSecret</h4>
<p>クラスターで実行されているアプリケーションのライブ設定に使用されているすべてのKubernetesリソースを表示します。
このビューでは、設定オブジェクトの編集と管理が可能で、デフォルトで非表示になっているSecretを表示します。</p>
<h4 id=ログビューアー>ログビューアー</h4>
<p>Podのリストと詳細ページは、ダッシュボードに組み込まれたログビューアーにリンクしています。
このビューアーでは、単一のPodに属するコンテナからログをドリルダウンすることができます。</p>
<p><img src=/images/docs/ui-dashboard-logs-view.png alt="Logs viewer"></p>
<h2 id=次の項目>次の項目</h2>
<p>詳細については<a href=https://github.com/kubernetes/dashboard>Kubernetes Dashboardプロジェクトページ</a>をご覧ください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5a233e14205d77fe1294917d2da6f876>4.9.2 - 複数のクラスターへのアクセスを設定する</h1>
<p>ここでは、設定ファイルを使って複数のクラスターにアクセスする方法を紹介します。クラスター、ユーザー、コンテキストの情報を一つ以上の設定ファイルにまとめることで、<code>kubectl config use-context</code>のコマンドを使ってクラスターを素早く切り替えることができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> クラスターへのアクセスを設定するファイルを、<em>kubeconfig</em> ファイルと呼ぶことがあります。これは設定ファイルの一般的な呼び方です。<code>kubeconfig</code>という名前のファイルが存在するわけではありません。
</div>
<h2 id=始める前に>始める前に</h2>
<p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
<p><a class=glossary-tooltip title="A command line tool for communicating with a Kubernetes API server." data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>がインストールされているか確認するため、<code>kubectl version --client</code>を実行してください。kubectlのバージョンは、クラスターのAPIサーバーの<a href=/ja/docs/setup/release/version-skew-policy/#kubectl>1つのマイナーバージョン内</a>である必要があります。</p>
<h2 id=クラスター-ユーザー-コンテキストを設定する>クラスター、ユーザー、コンテキストを設定する</h2>
<p>例として、開発用のクラスターが一つ、実験用のクラスターが一つ、計二つのクラスターが存在する場合を考えます。<code>development</code>と呼ばれる開発用のクラスター内では、フロントエンドの開発者は<code>frontend</code>というnamespace内で、ストレージの開発者は<code>storage</code>というnamespace内で作業をします。<code>scratch</code>と呼ばれる実験用のクラスター内では、開発者はデフォルトのnamespaceで作業をするか、状況に応じて追加のnamespaceを作成します。開発用のクラスターは証明書を通しての認証を必要とします。実験用のクラスターはユーザーネームとパスワードを通しての認証を必要とします。</p>
<p><code>config-exercise</code>というディレクトリを作成してください。<code>config-exercise</code>ディレクトリ内に、以下を含む<code>config-demo</code>というファイルを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apiVersion: v1
kind: Config
preferences: <span style=color:#666>{}</span>

clusters:
- cluster:
  name: development
- cluster:
  name: scratch

users:
- name: developer
- name: experimenter

contexts:
- context:
  name: dev-frontend
- context:
  name: dev-storage
- context:
  name: exp-scratch
</code></pre></div><p>設定ファイルには、クラスター、ユーザー、コンテキストの情報が含まれています。上記の<code>config-demo</code>設定ファイルには、二つのクラスター、二人のユーザー、三つのコンテキストの情報が含まれています。</p>
<p><code>config-exercise</code>ディレクトリに移動してください。クラスター情報を設定ファイルに追加するために、以下のコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-cluster development --server<span style=color:#666>=</span>https://1.2.3.4 --certificate-authority<span style=color:#666>=</span>fake-ca-file
kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-cluster scratch --server<span style=color:#666>=</span>https://5.6.7.8 --insecure-skip-tls-verify
</code></pre></div><p>ユーザー情報を設定ファイルに追加してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-credentials developer --client-certificate<span style=color:#666>=</span>fake-cert-file --client-key<span style=color:#666>=</span>fake-key-seefile
kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-credentials experimenter --username<span style=color:#666>=</span>exp --password<span style=color:#666>=</span>some-password
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>kubectl --kubeconfig=config-demo config unset users.&lt;name></code>を実行すると、ユーザーを削除することができます。
<code>kubectl --kubeconfig=config-demo config unset clusters.&lt;name></code>を実行すると、クラスターを除去することができます。
<code>kubectl --kubeconfig=config-demo config unset contexts.&lt;name></code>を実行すると、コンテキスト情報を除去することができます。
</div>
<p>コンテキスト情報を設定ファイルに追加してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context dev-frontend --cluster<span style=color:#666>=</span>development --namespace<span style=color:#666>=</span>frontend --user<span style=color:#666>=</span>developer
kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context dev-storage --cluster<span style=color:#666>=</span>development --namespace<span style=color:#666>=</span>storage --user<span style=color:#666>=</span>developer
kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context exp-scratch --cluster<span style=color:#666>=</span>scratch --namespace<span style=color:#666>=</span>default --user<span style=color:#666>=</span>experimenter
</code></pre></div><p>追加した情報を確認するために、<code>config-demo</code>ファイルを開いてください。<code>config-demo</code>ファイルを開く代わりに、<code>config view</code>のコマンドを使うこともできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view
</code></pre></div><p>出力には、二つのクラスター、二人のユーザー、三つのコンテキストが表示されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apiVersion: v1
clusters:
- cluster:
    certificate-authority: fake-ca-file
    server: https://1.2.3.4
  name: development
- cluster:
    insecure-skip-tls-verify: <span style=color:#a2f>true</span>
    server: https://5.6.7.8
  name: scratch
contexts:
- context:
    cluster: development
    namespace: frontend
    user: developer
  name: dev-frontend
- context:
    cluster: development
    namespace: storage
    user: developer
  name: dev-storage
- context:
    cluster: scratch
    namespace: default
    user: experimenter
  name: exp-scratch
current-context: <span style=color:#b44>&#34;&#34;</span>
kind: Config
preferences: <span style=color:#666>{}</span>
users:
- name: developer
  user:
    client-certificate: fake-cert-file
    client-key: fake-key-file
- name: experimenter
  user:
    password: some-password
    username: exp
</code></pre></div><p>上記の<code>fake-ca-file</code>、<code>fake-cert-file</code>、<code>fake-key-file</code>は、証明書ファイルの実際のパスのプレースホルダーです。環境内にある証明書ファイルの実際のパスに変更してください。</p>
<p>証明書ファイルのパスの代わりにbase64にエンコードされたデータを使用したい場合は、キーに<code>-data</code>の接尾辞を加えてください。例えば、<code>certificate-authority-data</code>、<code>client-certificate-data</code>、<code>client-key-data</code>とできます。</p>
<p>それぞれのコンテキストは、クラスター、ユーザー、namespaceの三つ組からなっています。例えば、<code>dev-frontend</code>は、<code>developer</code>ユーザーの認証情報を使って<code>development</code>クラスターの<code>frontend</code>namespaceへのアクセスを意味しています。</p>
<p>現在のコンテキストを設定してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context dev-frontend
</code></pre></div><p>これ以降実行される<code>kubectl</code>コマンドは、<code>dev-frontend</code>に設定されたクラスターとnamespaceに適用されます。また、<code>dev-frontend</code>に設定されたユーザーの認証情報を使用します。</p>
<p>現在のコンテキストの設定情報のみを確認するには、<code>--minify</code>フラグを使用してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</code></pre></div><p>出力には、<code>dev-frontend</code>の設定情報が表示されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apiVersion: v1
clusters:
- cluster:
    certificate-authority: fake-ca-file
    server: https://1.2.3.4
  name: development
contexts:
- context:
    cluster: development
    namespace: frontend
    user: developer
  name: dev-frontend
current-context: dev-frontend
kind: Config
preferences: <span style=color:#666>{}</span>
users:
- name: developer
  user:
    client-certificate: fake-cert-file
    client-key: fake-key-file
</code></pre></div><p>今度は、実験用のクラスター内でしばらく作業する場合を考えます。</p>
<p>現在のコンテキストを<code>exp-scratch</code>に切り替えてください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context exp-scratch
</code></pre></div><p>これ以降実行される<code>kubectl</code>コマンドは、<code>scratch</code>クラスター内のデフォルトnamespaceに適用されます。また、<code>exp-scratch</code>に設定されたユーザーの認証情報を使用します。</p>
<p>新しく切り替えた<code>exp-scratch</code>の設定を確認してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</code></pre></div><p>最後に、<code>development</code>クラスター内の<code>storage</code>namespaceでしばらく作業する場合を考えます。</p>
<p>現在のコンテキストを<code>dev-storage</code>に切り替えてください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context dev-storage
</code></pre></div><p>新しく切り替えた<code>dev-storage</code>の設定を確認してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</code></pre></div><h2 id=二つ目の設定ファイルを作成する>二つ目の設定ファイルを作成する</h2>
<p><code>config-exercise</code>ディレクトリ内に、以下を含む<code>config-demo-2</code>というファイルを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apiVersion: v1
kind: Config
preferences: <span style=color:#666>{}</span>

contexts:
- context:
    cluster: development
    namespace: ramp
    user: developer
  name: dev-ramp-up
</code></pre></div><p>上記の設定ファイルは、<code>dev-ramp-up</code>というコンテキストを表します。</p>
<h2 id=set-the-kubeconfig-environment-variable>KUBECONFIG環境変数を設定する</h2>
<p><code>KUBECONFIG</code>という環境変数が存在するかを確認してください。もし存在する場合は、後で復元できるようにバックアップしてください。例えば:</p>
<h3 id=linux>Linux</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG_SAVED</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>
</code></pre></div><h3 id=windows-powershell>Windows PowerShell</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>$Env</span>:KUBECONFIG_SAVED<span style=color:#666>=</span><span style=color:#b8860b>$ENV</span>:KUBECONFIG
</code></pre></div><p><code>KUBECONFIG</code>環境変数は、設定ファイルのパスのリストです。リスト内のパスはLinuxとMacではコロンで区切られ、Windowsではセミコロンで区切られます。<code>KUBECONFIG</code>環境変数が存在する場合は、リスト内の設定ファイルの内容を確認してください。</p>
<p>一時的に<code>KUBECONFIG</code>環境変数に以下の二つのパスを追加してください。例えば:<br></p>
<h3 id=linux-1>Linux</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>:config-demo:config-demo-2
</code></pre></div><h3 id=windows-powershell-1>Windows PowerShell</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>$Env</span>:KUBECONFIG<span style=color:#666>=(</span><span style=color:#b44>&#34;config-demo;config-demo-2&#34;</span><span style=color:#666>)</span>
</code></pre></div><p><code>config-exercise</code>ディレクトリ内から、以下のコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div><p>出力には、<code>KUBECONFIG</code>環境変数に含まれる全てのファイルの情報がまとめて表示されます。<code>config-demo-2</code>ファイルに設定された<code>dev-ramp-up</code>の情報と、<code>config-demo</code>に設定された三つのコンテキストの情報がまとめてあることに注目してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>contexts:
- context:
    cluster: development
    namespace: frontend
    user: developer
  name: dev-frontend
- context:
    cluster: development
    namespace: ramp
    user: developer
  name: dev-ramp-up
- context:
    cluster: development
    namespace: storage
    user: developer
  name: dev-storage
- context:
    cluster: scratch
    namespace: default
    user: experimenter
  name: exp-scratch
</code></pre></div><p>kubeconfigファイルに関するさらなる情報を参照するには、<a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfigファイルを使ってクラスターへのアクセスを管理する</a>を参照してください。</p>
<h2 id=home-kubeディレクトリの内容を確認する>$HOME/.kubeディレクトリの内容を確認する</h2>
<p>既にクラスターを所持していて、<code>kubectl</code>を使ってクラスターを操作できる場合は、<code>$HOME/.kube</code>ディレクトリ内に<code>config</code>というファイルが存在する可能性が高いです。</p>
<p><code>$HOME/.kube</code>に移動して、そこに存在するファイルを確認してください。<code>config</code>という設定ファイルが存在するはずです。他の設定ファイルも存在する可能性があります。全てのファイルの中身を確認してください。</p>
<h2 id=home-kube-configをkubeconfig環境変数に追加する>$HOME/.kube/configをKUBECONFIG環境変数に追加する</h2>
<p>もし<code>$HOME/.kube/config</code>ファイルが存在していて、既に<code>KUBECONFIG</code>環境変数に追加されていない場合は、<code>KUBECONFIG</code>環境変数に追加してください。例えば:</p>
<h3 id=linux-2>Linux</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>:<span style=color:#b8860b>$HOME</span>/.kube/config
</code></pre></div><h3 id=windows-powershell-2>Windows Powershell</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>$Env</span>:KUBECONFIG<span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$Env</span><span style=color:#b44>:KUBECONFIG;</span><span style=color:#b8860b>$HOME</span><span style=color:#b44>/.kube/config&#34;</span>
</code></pre></div><p><code>KUBECONFIG</code>環境変数内のファイルからまとめられた設定情報を確認してください。<code>config-exercise</code>ディレクトリ内から、以下のコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div><h2 id=クリーンアップ>クリーンアップ</h2>
<p><code>KUBECONFIG</code>環境変数を元に戻してください。例えば:</p>
<h3 id=linux-3>Linux:</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG_SAVED</span>
</code></pre></div><h3 id=windows-powershell-3>Windows PowerShell</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>$Env</span>:KUBECONFIG<span style=color:#666>=</span><span style=color:#b8860b>$ENV</span>:KUBECONFIG_SAVED
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfigファイルを使ってクラスターへのアクセスを管理する</a></li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#config>kubectl config</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-312f29f850826b74618634cd877aa065>4.9.3 - Serviceを利用したクラスター内のアプリケーションへのアクセス</h1>
<p>ここでは、クラスター内で稼働しているアプリケーションに外部からアクセスするために、KubernetesのServiceオブジェクトを作成する方法を紹介します。
例として、2つのインスタンスから成るアプリケーションへのロードバランシングを扱います。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=目標>目標</h2>
<ul>
<li>2つのHello Worldアプリケーションを稼働させる。</li>
<li>Nodeのポートを公開するServiceオブジェクトを作成する。</li>
<li>稼働しているアプリケーションにアクセスするためにServiceオブジェクトを使用する。</li>
</ul>
<h2 id=2つのpodから成るアプリケーションのserviceを作成>2つのPodから成るアプリケーションのServiceを作成</h2>
<p>アプリケーションDeploymentの設定ファイルは以下の通りです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/access/hello-application.yaml download=service/access/hello-application.yaml><code>service/access/hello-application.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-hello-application-yaml')" title="Copy service/access/hello-application.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-access-hello-application-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-world<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-world<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>クラスタでHello Worldアプリケーションを稼働させます:
上記のファイルを使用し、アプリケーションのDeploymentを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/access/hello-application.yaml
</code></pre></div><p>このコマンドは<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>オブジェクトとそれに紐付く<a class=glossary-tooltip title="ReplicaSet ensures that a specified number of Pod replicas are running at one time" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSet>ReplicaSet</a>オブジェクトを作成します。ReplicaSetは、Hello Worldアプリケーションが稼働している2つの<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>から構成されます。</p>
</li>
<li>
<p>Deploymentの情報を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployments hello-world
kubectl describe deployments hello-world
</code></pre></div></li>
<li>
<p>ReplicaSetオブジェクトの情報を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get replicasets
kubectl describe replicasets
</code></pre></div></li>
<li>
<p>Deploymentを公開するServiceオブジェクトを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment hello-world --type<span style=color:#666>=</span>NodePort --name<span style=color:#666>=</span>example-service
</code></pre></div></li>
<li>
<p>Serviceに関する情報を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe services example-service
</code></pre></div><p>出力例は以下の通りです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Name:                   example-service
Namespace:              default
Labels:                 <span style=color:#b8860b>run</span><span style=color:#666>=</span>load-balancer-example
Annotations:            &lt;none&gt;
Selector:               <span style=color:#b8860b>run</span><span style=color:#666>=</span>load-balancer-example
Type:                   NodePort
IP:                     10.32.0.16
Port:                   &lt;unset&gt; 8080/TCP
TargetPort:             8080/TCP
NodePort:               &lt;unset&gt; 31496/TCP
Endpoints:              10.200.1.4:8080,10.200.2.5:8080
Session Affinity:       None
Events:                 &lt;none&gt;
</code></pre></div><p>NodePortの値を記録しておきます。上記の例では、31496です。</p>
</li>
<li>
<p>Hello Worldアプリーションが稼働しているPodを表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b44>&#34;run=load-balancer-example&#34;</span> --output<span style=color:#666>=</span>wide
</code></pre></div><p>出力例は以下の通りです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                           READY   STATUS    ...  IP           NODE
hello-world-2895499144-bsbk5   1/1     Running   ...  10.200.1.4   worker1
hello-world-2895499144-m1pwt   1/1     Running   ...  10.200.2.5   worker2
</code></pre></div></li>
<li>
<p>Hello World podが稼働するNodeのうち、いずれか1つのパブリックIPアドレスを確認します。
確認方法は、使用している環境により異なります。
例として、Minikubeの場合は<code>kubectl cluster-info</code>、Google Compute Engineの場合は<code>gcloud compute instances list</code>によって確認できます。</p>
</li>
<li>
<p>選択したノード上で、NodePortの値でのTCP通信を許可するファイヤーウォールを作成します。
NodePortの値が31568の場合、31568番のポートを利用したTCP通信を許可するファイヤーウォールを作成します。
クラウドプロバイダーによって設定方法が異なります。</p>
</li>
<li>
<p>Hello World applicationにアクセスするために、Nodeのアドレスとポート番号を使用します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl http://&lt;public-node-ip&gt;:&lt;node-port&gt;
</code></pre></div><p>ここで <code>&lt;public-node-ip></code> はNodeのパブリックIPアドレス、
<code>&lt;node-port></code> はNodePort Serviceのポート番号の値を表しています。
リクエストが成功すると、下記のメッセージが表示されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Hello Kubernetes!
</code></pre></div></li>
</ol>
<h2 id=service-configuration-fileの利用>service configuration fileの利用</h2>
<p><code>kubectl expose</code>コマンドの代わりに、
<a href=/ja/docs/concepts/services-networking/service/>service configuration file</a>
を使用してServiceを作成することもできます。</p>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>Serviceを削除するには、以下のコマンドを実行します:</p>
<pre><code>kubectl delete services example-service
</code></pre>
<p>Hello Worldアプリケーションが稼働しているDeployment、ReplicaSet、Podを削除するには、以下のコマンドを実行します:</p>
<pre><code>kubectl delete deployment hello-world
</code></pre>
<h2 id=次の項目>次の項目</h2>
<p>詳細は
<a href=/docs/concepts/services-networking/connect-applications-service/>serviceを利用してアプリケーションと接続する</a>
を確認してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f3dac629bea950fc026d920306f09fb4>4.9.4 - Serviceを使用してフロントエンドをバックエンドに接続する</h1>
<p>このタスクでは、フロントエンドとバックエンドのマイクロサービスを作成する方法を示します。
バックエンドのマイクロサービスは挨拶です。
フロントエンドとバックエンドは、Kubernetes <a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>オブジェクトを使用して接続されます。</p>
<h2 id=目標>目標</h2>
<ul>
<li><a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>オブジェクトを使用してマイクロサービスを作成および実行します。</li>
<li>フロントエンドを経由してトラフィックをバックエンドにルーティングします。</li>
<li>Serviceオブジェクトを使用して、フロントエンドアプリケーションをバックエンドアプリケーションに接続します。</li>
</ul>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>このタスクでは<a href=/docs/tasks/access-application-cluster/create-external-load-balancer/>Serviceで外部ロードバランサー</a>を使用しますが、外部ロードバランサーの使用がサポートされている環境である必要があります。
ご使用の環境がこれをサポートしていない場合は、代わりにタイプ<a href=/ja/docs/concepts/services-networking/service/#nodeport>NodePort</a>のServiceを使用できます。</p>
<h2 id=deploymentを使用したバックエンドの作成>Deploymentを使用したバックエンドの作成</h2>
<p>バックエンドは、単純な挨拶マイクロサービスです。
バックエンドのDeploymentの構成ファイルは次のとおりです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/access/hello.yaml download=service/access/hello.yaml><code>service/access/hello.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-hello-yaml')" title="Copy service/access/hello.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-access-hello-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>7</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;gcr.io/google-samples/hello-go-gke:1.0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>バックエンドのDeploymentを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/access/hello.yaml
</code></pre></div><p>バックエンドのDeploymentに関する情報を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployment hello
</code></pre></div><p>出力はこのようになります:</p>
<pre><code>Name:                           hello
Namespace:                      default
CreationTimestamp:              Mon, 24 Oct 2016 14:21:02 -0700
Labels:                         app=hello
                                tier=backend
                                track=stable
Annotations:                    deployment.kubernetes.io/revision=1
Selector:                       app=hello,tier=backend,track=stable
Replicas:                       7 desired | 7 updated | 7 total | 7 available | 0 unavailable
StrategyType:                   RollingUpdate
MinReadySeconds:                0
RollingUpdateStrategy:          1 max unavailable, 1 max surge
Pod Template:
  Labels:       app=hello
                tier=backend
                track=stable
  Containers:
   hello:
    Image:              &quot;gcr.io/google-samples/hello-go-gke:1.0&quot;
    Port:               80/TCP
    Environment:        &lt;none&gt;
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
OldReplicaSets:                 &lt;none&gt;
NewReplicaSet:                  hello-3621623197 (7/7 replicas created)
Events:
...
</code></pre><h2 id=バックエンドserviceオブジェクトの作成>バックエンドServiceオブジェクトの作成</h2>
<p>フロントエンドをバックエンドに接続する鍵は、バックエンドServiceです。
Serviceは、バックエンドマイクロサービスに常に到達できるように、永続的なIPアドレスとDNS名のエントリを作成します。
Serviceは<a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=セレクター>セレクター</a>を使用して、トラフィックをルーティングするPodを見つけます。</p>
<p>まず、Service構成ファイルを調べます:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/access/hello-service.yaml download=service/access/hello-service.yaml><code>service/access/hello-service.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-hello-service-yaml')" title="Copy service/access/hello-service.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-access-hello-service-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルで、Serviceが<code>app：hello</code>および<code>tier：backend</code>というラベルを持つPodにトラフィックをルーティングしていることがわかります。</p>
<p><code>hello</code> Serviceを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/access/hello-service.yaml
</code></pre></div><p>この時点で、バックエンドのDeploymentが実行され、そちらにトラフィックをルーティングできるServiceがあります。</p>
<h2 id=フロントエンドの作成>フロントエンドの作成</h2>
<p>バックエンドができたので、バックエンドに接続するフロントエンドを作成できます。
フロントエンドは、バックエンドServiceに指定されたDNS名を使用して、バックエンドワーカーPodに接続します。
DNS名は<code>hello</code>です。これは、前のサービス設定ファイルの<code>name</code>フィールドの値です。</p>
<p>フロントエンドDeploymentのPodは、helloバックエンドServiceを見つけるように構成されたnginxイメージを実行します。
これはnginx設定ファイルです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/access/frontend.conf download=service/access/frontend.conf><code>service/access/frontend.conf</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-frontend-conf')" title="Copy service/access/frontend.conf to clipboard">
</img>
</div>
<div class=includecode id=service-access-frontend-conf>
<pre tabindex=0><code class=language-conf data-lang=conf>upstream hello {
    server hello;
}

server {
    listen 80;

    location / {
        proxy_pass http://hello;
    }
}
</code></pre>
</div>
</div>
<p>バックエンドと同様に、フロントエンドにはDeploymentとServiceがあります。
Serviceの設定には<code>type：LoadBalancer</code>があります。これは、Serviceがクラウドプロバイダーのデフォルトのロードバランサーを使用することを意味します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/access/frontend.yaml download=service/access/frontend.yaml><code>service/access/frontend.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-frontend-yaml')" title="Copy service/access/frontend.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-access-frontend-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;TCP&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;gcr.io/google-samples/hello-frontend:1.0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>preStop</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/usr/sbin/nginx&#34;</span>,<span style=color:#b44>&#34;-s&#34;</span>,<span style=color:#b44>&#34;quit&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>フロントエンドのDeploymentとServiceを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/access/frontend.yaml
</code></pre></div><p>出力結果から両方のリソースが作成されたことを確認します:</p>
<pre><code>deployment.apps/frontend created
service/frontend created
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> nginxの構成は、<a href=/examples/service/access/Dockerfile>コンテナイメージ</a>に焼き付けられます。
これを行うためのより良い方法は、<a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>を使用して、構成をより簡単に変更できるようにすることです。
</div>
<h2 id=フロントエンドserviceと対話>フロントエンドServiceと対話</h2>
<p>LoadBalancerタイプのServiceを作成したら、このコマンドを使用して外部IPを見つけることができます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service frontend --watch
</code></pre></div><p>これにより<code>frontend</code> Serviceの設定が表示され、変更が監視されます。
最初、外部IPは<code>&lt;pending></code>としてリストされます:</p>
<pre><code>NAME       TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)  AGE
frontend   LoadBalancer   10.51.252.116   &lt;pending&gt;     80/TCP   10s
</code></pre><p>ただし、外部IPがプロビジョニングされるとすぐに、<code>EXTERNAL-IP</code>という見出しの下に新しいIPが含まれるように構成が更新されます:</p>
<pre><code>NAME       TYPE           CLUSTER-IP      EXTERNAL-IP        PORT(S)  AGE
frontend   LoadBalancer   10.51.252.116   XXX.XXX.XXX.XXX    80/TCP   1m
</code></pre><p>このIPを使用して、クラスターの外部から<code>frontend</code> Serviceとやり取りできるようになりました。</p>
<h2 id=フロントエンドを介するトラフィック送信>フロントエンドを介するトラフィック送信</h2>
<p>フロントエンドとバックエンドが接続されました。
フロントエンドServiceの外部IPに対してcurlコマンドを使用して、エンドポイントにアクセスできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl http://<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>EXTERNAL_IP</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#080;font-style:italic># これを前に見たEXTERNAL-IPに置き換えます</span>
</code></pre></div><p>出力には、バックエンドによって生成されたメッセージが表示されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;message&#34;</span>:<span style=color:#b44>&#34;Hello&#34;</span>}
</code></pre></div><h2 id=クリーンアップ>クリーンアップ</h2>
<p>Serviceを削除するには、このコマンドを入力してください：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete services frontend hello
</code></pre></div><p>バックエンドとフロントエンドアプリケーションを実行しているDeploymentとReplicaSetとPodを削除するために、このコマンドを入力してください：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment frontend hello
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/services-networking/service/>Service</a>の詳細</li>
<li><a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>の詳細</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1839d8468a083839ed1cc8d18fe1142e>4.9.5 - Minikube上でNGINX Ingressコントローラーを使用してIngressをセットアップする</h1>
<p><a href=/ja/docs/concepts/services-networking/ingress/>Ingress</a>とは、クラスター内のServiceに外部からのアクセスを許可するルールを定義するAPIオブジェクトです。<a href=/ja/docs/concepts/services-networking/ingress-controllers/>Ingressコントローラー</a>はIngress内に設定されたルールを満たすように動作します。</p>
<p>このページでは、簡単なIngressをセットアップして、HTTPのURIに応じてwebまたはweb2というServiceにリクエストをルーティングする方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=minikubeクラスターを作成する>Minikubeクラスターを作成する</h2>
<ol>
<li>
<p><strong>Launch Terminal</strong>をクリックします。</p>
<script defer src=https://katacoda.com/embed.js></script>
<button class=button onclick=window.katacoda.init()>Launch Terminal</button>
</li>
<li>
<p>(オプション) Minikubeをローカル環境にインストールした場合は、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube start
</code></pre></div></li>
</ol>
<h2 id=ingressコントローラーを有効化する>Ingressコントローラーを有効化する</h2>
<ol>
<li>
<p>NGINX Ingressコントローラーを有効にするために、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube addons <span style=color:#a2f>enable</span> ingress
</code></pre></div></li>
<li>
<p>NGINX Ingressコントローラーが起動したことを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -n kube-system
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このコマンドの実行には数分かかる場合があります。
</div>
<p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                                        READY     STATUS    RESTARTS   AGE
default-http-backend-59868b7dd6-xb8tq       1/1       Running   <span style=color:#666>0</span>          1m
kube-addon-manager-minikube                 1/1       Running   <span style=color:#666>0</span>          3m
kube-dns-6dcb57bcc8-n4xd4                   3/3       Running   <span style=color:#666>0</span>          2m
kubernetes-dashboard-5498ccf677-b8p5h       1/1       Running   <span style=color:#666>0</span>          2m
nginx-ingress-controller-5984b97644-rnkrg   1/1       Running   <span style=color:#666>0</span>          1m
storage-provisioner                         1/1       Running   <span style=color:#666>0</span>          2m
</code></pre></div></li>
</ol>
<h2 id=hello-worldアプリをデプロイする>Hello Worldアプリをデプロイする</h2>
<ol>
<li>
<p>次のコマンドを実行して、Deploymentを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment web --image<span style=color:#666>=</span>gcr.io/google-samples/hello-app:1.0
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps/web created
</code></pre></div></li>
<li>
<p>Deploymentを公開します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment web --type<span style=color:#666>=</span>NodePort --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>service/web exposed
</code></pre></div></li>
<li>
<p>Serviceが作成され、NodePort上で利用できるようになったことを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service web
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      TYPE       CLUSTER-IP       EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>          AGE
web       NodePort   10.104.133.249   &lt;none&gt;        8080:31637/TCP   12m
</code></pre></div></li>
<li>
<p>NodePort経由でServiceを訪問します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube service web --url
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>http://172.17.0.15:31637
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Katacoda環境の場合のみ: 上部のterminalパネルでプラスのアイコンをクリックして、<strong>Select port to view on Host 1</strong>(Host 1を表示するポートを選択)をクリックします。NodePort(上の例では<code>31637</code>)を入力して、<strong>Display Port</strong>(ポートを表示)をクリックしてください。
</div>
<p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre></div><p>これで、MinikubeのIPアドレスとNodePort経由で、サンプルアプリにアクセスできるようになりました。次のステップでは、Ingressリソースを使用してアプリにアクセスできるように設定します。</p>
</li>
</ol>
<h2 id=ingressリソースを作成する>Ingressリソースを作成する</h2>
<p>以下に示すファイルは、hello-world.info経由で送られたトラフィックをServiceに送信するIngressリソースです。</p>
<ol>
<li>
<p>以下の内容で<code>example-ingress.yaml</code>を作成します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/example-ingress.yaml download=service/networking/example-ingress.yaml><code>service/networking/example-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-example-ingress-yaml')" title="Copy service/networking/example-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-example-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-ingress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/$1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>hello-world.info<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span></code></pre></div>
</div>
</div>
</li>
<li>
<p>次のコマンドを実行して、Ingressリソースを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://kubernetes.io/examples/service/networking/example-ingress.yaml
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ingress.networking.k8s.io/example-ingress created
</code></pre></div></li>
<li>
<p>次のコマンドで、IPアドレスが設定されていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get ingress
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このコマンドの実行には数分かかる場合があります。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME              CLASS    HOSTS              ADDRESS        PORTS   AGE
example-ingress   &lt;none&gt;   hello-world.info   172.17.0.15    <span style=color:#666>80</span>      38s
</code></pre></div></li>
<li>
<p>次の行を<code>/etc/hosts</code>ファイルの最後に書きます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Minikubeをローカル環境で実行している場合、<code>minikube ip</code>コマンドを使用すると外部のIPが取得できます。Ingressのリスト内に表示されるIPアドレスは、内部のIPになるはずです。
</div>
<pre><code>172.17.0.15 hello-world.info
</code></pre><p>この設定により、リクエストがhello-world.infoからMinikubeに送信されるようになります。</p>
</li>
<li>
<p>Ingressコントローラーがトラフィックを制御していることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl hello-world.info
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Minikubeをローカル環境で実行している場合、ブラウザからhello-world.infoにアクセスできます。
</div>
</li>
</ol>
<h2 id=2番目のdeploymentを作成する>2番目のDeploymentを作成する</h2>
<ol>
<li>
<p>次のコマンドを実行して、v2のDeploymentを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment web2 --image<span style=color:#666>=</span>gcr.io/google-samples/hello-app:2.0
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps/web2 created
</code></pre></div></li>
<li>
<p>Deploymentを公開します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment web2 --port<span style=color:#666>=</span><span style=color:#666>8080</span> --type<span style=color:#666>=</span>NodePort
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>service/web2 exposed
</code></pre></div></li>
</ol>
<h2 id=ingressを編集する>Ingressを編集する</h2>
<ol>
<li>
<p>既存の<code>example-ingress.yaml</code>を編集して、以下の行を追加します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/v2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></code></pre></div></li>
<li>
<p>次のコマンドで変更を適用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f example-ingress.yaml
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ingress.networking/example-ingress configured
</code></pre></div></li>
</ol>
<h2 id=ingressを試す>Ingressを試す</h2>
<ol>
<li>
<p>Hello Worldアプリの1番目のバージョンにアクセスします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl hello-world.info
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre></div></li>
<li>
<p>Hello Worldアプリの2番目のバージョンにアクセスします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl hello-world.info/v2
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Hello, world!
Version: 2.0.0
Hostname: web2-75cd47646f-t8cjk
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Minikubeをローカル環境で実行している場合、ブラウザからhello-world.infoおよびhello-world.info/v2にアクセスできます。
</div>
</li>
</ol>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/services-networking/ingress/>Ingress</a>についてさらに学ぶ。</li>
<li><a href=/ja/docs/concepts/services-networking/ingress-controllers/>Ingressコントローラー</a>についてさらに学ぶ。</li>
<li><a href=/ja/docs/concepts/services-networking/service/>Service</a>についてさらに学ぶ。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-48e8f306f919c5b81265e265a2b76ab4>4.9.6 - クラスターで実行されているすべてのコンテナイメージを一覧表示する</h1>
<p>このページでは、kubectlを使用して、クラスターで実行されているPodのすべてのコンテナイメージを一覧表示する方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>この演習では、kubectlを使用してクラスターで実行されているすべてのPodを取得し、出力をフォーマットしてそれぞれのコンテナの一覧を取得します。</p>
<h2 id=list-all-container-images-in-all-namespaces>すべての名前空間のコンテナイメージを一覧表示する</h2>
<ul>
<li><code>kubectl get pods --all-namespaces</code>を使用して、すべての名前空間のPodを取得します</li>
<li><code>-o jsonpath={.. image}</code>を使用して、コンテナイメージ名のリストのみが含まれるように出力をフォーマットします。これは、返されたjsonの<code>image</code>フィールドを再帰的に解析します。
<ul>
<li>jsonpathの使い方については、<a href=/docs/reference/kubectl/jsonpath/>jsonpathリファレンス</a>を参照してください。</li>
</ul>
</li>
<li><code>tr</code>、<code>sort</code>、<code>uniq</code>などの標準ツールを使用して出力をフォーマットします。
<ul>
<li><code>tr</code>を使用してスペースを改行に置換します。</li>
<li><code>sort</code>を使用して結果を並べ替えます。</li>
<li><code>uniq</code>を使用してイメージ数を集計します。</li>
</ul>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{..image}&#34;</span> |<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>tr -s <span style=color:#b44>&#39;[[:space:]]&#39;</span> <span style=color:#b44>&#39;\n&#39;</span> |<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>sort |<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>uniq -c
</code></pre></div><p>上記のコマンドは、返されるすべてのアイテムについて、<code>image</code>という名前のすべてのフィールドを再帰的に返します。</p>
<p>別の方法として、Pod内のimageフィールドへの絶対パスを使用することができます。これにより、フィールド名が繰り返されている場合でも正しいフィールドが取得されます。多くのフィールドは与えられたアイテム内で<code>name</code>と呼ばれます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span>
</code></pre></div><p>jsonpathは次のように解釈されます:</p>
<ul>
<li><code>.items[*]</code>: 各戻り値</li>
<li><code>.spec</code>: 仕様の取得</li>
<li><code>.containers[*]</code>: 各コンテナ</li>
<li><code>.image</code>: イメージの取得</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 例えば<code>kubectl get pod nginx</code>のように名前を指定して単一のPodを取得する場合、アイテムのリストではなく単一のPodが返されるので、パスの<code>.items[*]</code>部分は省略してください。
</div>
<h2 id=list-container-images-by-pod>Podごとにコンテナイメージを一覧表示する</h2>
<p><code>range</code>を使用して要素を個別に繰り返し処理することにより、フォーマットをさらに制御できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{&#34;\n&#34;}{.metadata.name}{&#34;:\t&#34;}{range .spec.containers[*]}{.image}{&#34;, &#34;}{end}{end}&#39;</span> |<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>sort
</code></pre></div><h2 id=list-container-images-filtering-by-pod-namespace>Podのラベルを使用してコンテナイメージ一覧をフィルタリングする</h2>
<p>特定のラベルに一致するPodのみを対象とするには、-lフラグを使用します。以下は、<code>app=nginx</code>に一致するラベルを持つPodのみに一致します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{..image}&#34;</span> -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><h2 id=list-container-images-filtering-by-pod-namespace>Podの名前空間でコンテナイメージ一覧をフィルタリングする</h2>
<p>特定の名前空間のPodのみを対象とするには、namespaceフラグを使用します。以下は<code>kube-system</code>名前空間のPodのみに一致します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --namespace kube-system -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{..image}&#34;</span>
</code></pre></div><h2 id=list-container-images-using-a-go-template-instead-of-jsonpath>jsonpathの代わりにgo-templateを使用してコンテナイメージを一覧表示する</h2>
<p>jsonpathの代わりに、kubectlは<a href=https://golang.org/pkg/text/template/>go-templates</a>を使用した出力のフォーマットをサポートしています:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#34;{{range .items}}{{range .spec.containers}}{{.image}} {{end}}{{end}}&#34;</span>
</code></pre></div>
<h2 id=次の項目>次の項目</h2>
<h3 id=参照>参照</h3>
<ul>
<li><a href=/docs/reference/kubectl/jsonpath/>jsonpath</a>参照ガイド</li>
<li><a href=https://golang.org/pkg/text/template/>Go template</a>参照ガイド</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7c319a9981586e5fbcfa21b392720650>4.9.7 - 共有ボリュームを使用して同じPod内のコンテナ間で通信する</h1>
<p>このページでは、ボリュームを使用して、同じPodで実行されている2つのコンテナ間で通信する方法を示します。
コンテナ間で<a href=/ja/docs/tasks/configure-pod-container/share-process-namespace/>プロセス名前空間を共有する</a>ことにより、プロセスが通信できるようにする方法も参照してください。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=2つのコンテナを実行するpodの作成>2つのコンテナを実行するPodの作成</h2>
<p>この演習では、2つのコンテナを実行するPodを作成します。
2つのコンテナは、通信に使用できるボリュームを共有します。
これがPodの設定ファイルです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/two-container-pod.yaml download=pods/two-container-pod.yaml><code>pods/two-container-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-two-container-pod-yaml')" title="Copy pods/two-container-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-two-container-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>two-containers<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>debian-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/pod-data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo Hello from the debian container &gt; /pod-data/index.html&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルで、Podに<code>shared-data</code>という名前のボリュームがあることがわかります。</p>
<p>設定ファイルにリストされている最初のコンテナは、nginxサーバーを実行します。
共有ボリュームのマウントパスは<code>/usr/share/nginx/html</code>です。
2番目のコンテナはdebianイメージをベースとしており、<code>/pod-data</code>のマウントパスを持っています。
2番目のコンテナは次のコマンドを実行してから終了します。</p>
<pre><code>echo Hello from the debian container &gt; /pod-data/index.html
</code></pre>
<p>2番目のコンテナがnginxサーバーのルートディレクトリに<code>index.html</code>ファイルを書き込むことに注意してください。</p>
<p>Podと2つのコンテナを作成します:</p>
<pre><code>kubectl apply -f https://k8s.io/examples/pods/two-container-pod.yaml
</code></pre>
<p>Podとコンテナに関する情報を表示します:</p>
<pre><code>kubectl get pod two-containers --output=yaml
</code></pre>
<p>こちらは出力の一部です:</p>
<pre><code>apiVersion: v1
kind: Pod
metadata:
  ...
  name: two-containers
  namespace: default
  ...
spec:
  ...
  containerStatuses:

  - containerID: docker://c1d8abd1 ...
    image: debian
    ...
    lastState:
      terminated:
        ...
    name: debian-container
    ...

  - containerID: docker://96c1ff2c5bb ...
    image: nginx
    ...
    name: nginx-container
    ...
    state:
      running:
    ...
</code></pre>
<p>debianコンテナが終了し、nginxコンテナがまだ実行されていることがわかります。</p>
<p>nginxコンテナへのシェルを取得します:</p>
<pre><code>kubectl exec -it two-containers -c nginx-container -- /bin/bash
</code></pre>
<p>シェルで、nginxが実行されていることを確認します:</p>
<pre><code>root@two-containers:/# apt-get update
root@two-containers:/# apt-get install curl procps
root@two-containers:/# ps aux
</code></pre>
<p>出力はこのようになります:</p>
<pre><code>USER       PID  ...  STAT START   TIME COMMAND
root         1  ...  Ss   21:12   0:00 nginx: master process nginx -g daemon off;
</code></pre>
<p>debianコンテナがnginxルートディレクトリに<code>index.html</code>ファイルを作成したことを思い出してください。
<code>curl</code>を使用して、GETリクエストをnginxサーバーに送信します:</p>
<pre><code>root@two-containers:/# curl localhost
</code></pre><p>出力は、nginxがdebianコンテナによって書かれたWebページを提供することを示しています:</p>
<pre><code>Hello from the debian container
</code></pre>
<h2 id=議論>議論</h2>
<p>Podが複数のコンテナを持つことができる主な理由は、プライマリアプリケーションを支援するヘルパーアプリケーションをサポートするためです。
ヘルパーアプリケーションの典型的な例は、データプラー、データプッシャー、およびプロキシです。
多くの場合、ヘルパーアプリケーションとプライマリアプリケーションは互いに通信する必要があります。
通常、これは、この演習に示すように共有ファイルシステムを介して、またはループバックネットワークインターフェイスであるlocalhostを介して行われます。
このパターンの例は、新しい更新のためにGitリポジトリをポーリングするヘルパープログラムを伴うWebサーバーです。</p>
<p>この演習のボリュームは、コンテナがポッドの寿命中に通信する方法を提供します。
Podを削除して再作成すると、共有ボリュームに保存されているデータはすべて失われます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>
<p><a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>複合コンテナのパターン</a>の詳細</p>
</li>
<li>
<p><a href=http://www.slideshare.net/Docker/slideshare-burns>モジュラーアーキテクチャ用の複合コンテナ</a>について学ぶ</p>
</li>
<li>
<p><a href=/ja/docs/tasks/configure-pod-container/configure-volume-storage/>ストレージにボリュームを使用するPodの構成</a>を参照</p>
</li>
<li>
<p><a href=/ja/docs/tasks/configure-pod-container/share-process-namespace/>Pod内のコンテナ間でプロセス名前空間を共有するPodの構成</a>を参照</p>
</li>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#volume-v1-core>Volume</a>を参照</p>
</li>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#pod-v1-core>Pod</a>を参照</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f6a755efe831d24956501e4bcd49ff96>4.10 - 監視、ログ、デバッグ</h1>
<div class=lead>クラスターのトラブルシューティングや、コンテナ化したアプリケーションのデバッグのために、監視とログをセットアップします。</div>
</div>
<div class=td-content>
<h1 id=pg-06bb252f25983de12f635c806d180d30>4.10.1 - Initコンテナのデバッグ</h1>
<p>このページでは、Initコンテナの実行に関連する問題を調査する方法を説明します。以下のコマンドラインの例では、Podを<code>&lt;pod-name></code>、Initコンテナを<code>&lt;init-container-1></code>および<code>&lt;init-container-2></code>として参照しています。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<ul>
<li><a href=/ja/docs/concepts/workloads/pods/init-containers/>Initコンテナ</a>の基本を理解しておきましょう。</li>
<li><a href=/docs/tasks/configure-pod-container/configure-pod-initialization/#creating-a-pod-that-has-an-init-container/>Initコンテナを設定</a>しておきましょう。</li>
</ul>
<h2 id=initコンテナのステータスを確認する>Initコンテナのステータスを確認する</h2>
<p>Podのステータスを表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod &lt;pod-name&gt;
</code></pre></div><p>たとえば、<code>Init：1/2</code>というステータスは、2つのInitコンテナのうちの1つが正常に完了したことを示します。</p>
<pre><code>NAME         READY     STATUS     RESTARTS   AGE
&lt;pod-name&gt;   0/1       Init:1/2   0          7s
</code></pre><p>ステータス値とその意味の例については、<a href=#understanding-pod-status>Podのステータスを理解する</a>を参照してください。</p>
<h2 id=initコンテナの詳細を取得する>Initコンテナの詳細を取得する</h2>
<p>Initコンテナの実行に関する詳細情報を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod &lt;pod-name&gt;
</code></pre></div><p>たとえば、2つのInitコンテナを持つPodでは、次のように表示されます:</p>
<pre><code>Init Containers:
  &lt;init-container-1&gt;:
    Container ID:    ...
    ...
    State:           Terminated
      Reason:        Completed
      Exit Code:     0
      Started:       ...
      Finished:      ...
    Ready:           True
    Restart Count:   0
    ...
  &lt;init-container-2&gt;:
    Container ID:    ...
    ...
    State:           Waiting
      Reason:        CrashLoopBackOff
    Last State:      Terminated
      Reason:        Error
      Exit Code:     1
      Started:       ...
      Finished:      ...
    Ready:           False
    Restart Count:   3
    ...
</code></pre><p>また、Pod Specの<code>status.initContainerStatuses</code>フィールドを読むことでプログラムでInitコンテナのステータスにアクセスすることもできます。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod nginx --template <span style=color:#b44>&#39;{{.status.initContainerStatuses}}&#39;</span>
</code></pre></div><p>このコマンドは生のJSONで上記と同じ情報を返します。</p>
<h2 id=initコンテナのログにアクセスする>Initコンテナのログにアクセスする</h2>
<p>ログにアクセスするには、Initコンテナ名とPod名を渡します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs &lt;pod-name&gt; -c &lt;init-container-2&gt;
</code></pre></div><p>シェルスクリプトを実行するInitコンテナは、実行時にコマンドを出力します。たとえば、スクリプトの始めに<code>set -x</code>を実行することでBashで同じことができます。</p>
<h2 id=understanding-pod-status>Podのステータスを理解する</h2>
<p><code>Init：</code>で始まるPodステータスはInitコンテナの実行ステータスを要約します。以下の表は、Initコンテナのデバッグ中に表示される可能性のあるステータス値の例をいくつか示しています。</p>
<table>
<thead>
<tr>
<th>ステータス</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Init:N/M</code></td>
<td>Podは<code>M</code>個のInitコンテナを持ち、これまでに<code>N</code>個完了しました。</td>
</tr>
<tr>
<td><code>Init:Error</code></td>
<td>Initコンテナが実行に失敗しました。</td>
</tr>
<tr>
<td><code>Init:CrashLoopBackOff</code></td>
<td>Initコンテナが繰り返し失敗しました。</td>
</tr>
<tr>
<td><code>Pending</code></td>
<td>PodはまだInitコンテナの実行を開始していません。</td>
</tr>
<tr>
<td><code>PodInitializing</code> or <code>Running</code></td>
<td>PodはすでにInitコンテナの実行を終了しています。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-858517cd46a1b5a1fd2e650edd785cea>4.10.2 - PodとReplicationControllerのデバッグ</h1>
<p>このページでは、PodとReplicationControllerをデバッグする方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<ul>
<li><a href=/ja/docs/concepts/workloads/pods/pod/>Pod</a>と<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>の基本を理解している必要があります。</li>
</ul>
<h2 id=podのデバッグ>Podのデバッグ</h2>
<p>Podのデバッグの最初のステップは、Podを調べることです。
次のコマンドで、Podの現在の状態と最近のイベントを確認して下さい。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pods <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div><p>Pod内のコンテナの状態を確認します。
コンテナはすべて<code>Running</code>状態ですか？最近再起動はしましたか？</p>
<p>Podの状態に応じてデバッグを続けます。</p>
<h3 id=podがpending状態にとどまっている>PodがPending状態にとどまっている</h3>
<p>Podが<code>Pending</code>状態でスタックしている場合、ノードにスケジュールできていないことを意味します。
一般的に、これは、何らかのタイプのリソースが不足しており、それによってスケジューリングを妨げられているためです。
上述の<code>kubectl describe...</code>コマンドの出力を確認してください。
Podをスケジュールできない理由に関するスケジューラーからのメッセージがあるはずです。
理由としては以下のようなものがあります。</p>
<h4 id=リソースが不十分>リソースが不十分</h4>
<p>クラスター内のCPUまたはメモリーの供給を使い果たした可能性があります。
この場合、いくつかのことを試すことができます。</p>
<ul>
<li>
<p>クラスターにノードを追加します。</p>
</li>
<li>
<p><a href=/docs/concepts/workloads/pods/#pod-termination>不要なPodを終了</a>して、
<code>Pending</code>状態のPodのための空きリソースを作ります。</p>
</li>
<li>
<p>Podがノードよりも大きくないことを確認します。
例えば、すべてのノードのキャパシティーが<code>cpu: 1</code>の場合、<code>cpu: 1.1</code>を要求するPodは決してスケジュールされません。</p>
<p><code>kubectl get nodes -o &lt;format></code>コマンドでノードのキャパシティーを確認できます。
必要な情報を抽出するコマンドラインの例を以下に示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes -o yaml | egrep <span style=color:#b44>&#39;\sname:|cpu:|memory:&#39;</span>
kubectl get nodes -o json | jq <span style=color:#b44>&#39;.items[] | {name: .metadata.name, cap: .status.capacity}&#39;</span>
</code></pre></div><p><a href=/docs/concepts/policy/resource-quotas/>リソースクォータ</a>機能では、
消費できるリソースの合計量を制限するように構成できます。
Namespaceと組み合わせて使用すると、1つのチームがすべてのリソースを占有することを防ぐことができます。</p>
</li>
</ul>
<h4 id=hostportの使用>hostPortの使用</h4>
<p>Podを<code>hostPort</code>にバインドすると、Podをスケジュールできる場所の数が制限されます。
ほとんどの場合、<code>hostPort</code>は不要です。Serviceオブジェクトを使用してPodを公開してください。
どうしても<code>hostPort</code>が必要な場合は、コンテナクラスター内のノードと同じ数のPodのみをスケジュールできます。</p>
<h3 id=podがwaiting状態にとどまっている>PodがWaiting状態にとどまっている</h3>
<p>Podが<code>Waiting</code>状態でスタックしている場合、Podはワーカーノードにスケジュールされていますが、そのマシンでは実行できない状態です。
この場合も、<code>kubectl describe ...</code>の情報が参考になるはずです。
Podが<code>Waiting</code>状態となる最も一般的な原因は、イメージをプルできないことです。
確認すべき事項が3つあります。</p>
<ul>
<li>イメージの名前が正しいことを確認して下さい。</li>
<li>イメージはリポジトリーにプッシュしましたか？</li>
<li>マシンで手動で<code>docker pull &lt;image></code>を実行し、イメージをプルできるかどうかを確認して下さい。</li>
</ul>
<h3 id=podがクラッシュする-あるいはunhealthy状態>Podがクラッシュする、あるいはUnhealthy状態</h3>
<p>Podがスケジュールされると、<a href=/docs/tasks/debug-application-cluster/debug-running-pod/>動作中のPodをデバッグする</a>に説明されている方法がデバッグに使用可能です。</p>
<h2 id=replicationcontrollerのデバッグ>ReplicationControllerのデバッグ</h2>
<p>ReplicationControllerはかなり明快です。Podを作成できるか、できないかのどちらかです。
Podを作成できない場合は、<a href=#Pod%E3%81%AE%E3%83%87%E3%83%90%E3%83%83%E3%82%B0>上述の手順</a>を参照してPodをデバッグしてください。</p>
<p><code>kubectl describe rc ${CONTROLLER_NAME}</code>を使用して、レプリケーションコントローラーに関連するイベントを調べることもできます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ef360b1f8e65236251826db478cfcab3>4.10.3 - Pod障害の原因を特定する</h1>
<p>このページでは、コンテナ終了メッセージの読み書き方法を説明します。</p>
<p>終了メッセージは、致命的なイベントに関する情報を、ダッシュボードや監視ソフトウェアなどのツールで簡単に取得して表示できる場所にコンテナが書き込むための手段を提供します。 ほとんどの場合、終了メッセージに入力した情報も一般的な<a href=/docs/concepts/cluster-administration/logging/>Kubernetesログ</a>に書き込まれるはずです。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=終了メッセージの書き込みと読み取り>終了メッセージの書き込みと読み取り</h2>
<p>この課題では、1つのコンテナを実行するPodを作成します。
設定ファイルには、コンテナの開始時に実行されるコマンドを指定します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/debug/termination.yaml download=debug/termination.yaml><code>debug/termination.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('debug-termination-yaml')" title="Copy debug/termination.yaml to clipboard">
</img>
</div>
<div class=includecode id=debug-termination-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>termination-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>termination-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep 10 &amp;&amp; echo Sleep expired &gt; /dev/termination-log&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>YAML設定ファイルに基づいてPodを作成します:</p>
<pre><code> kubectl apply -f https://k8s.io/examples/debug/termination.yaml
</code></pre>
<p>YAMLファイルの<code>command</code>フィールドと<code>args</code>フィールドで、コンテナが10秒間スリープしてから<code>/dev/termination-log</code>ファイルに「Sleep expired」と書いているのがわかります。コンテナが「Sleep expired」メッセージを書き込んだ後、コンテナは終了します。</p>
</li>
<li>
<p>Podに関する情報を表示します:</p>
<pre><code> kubectl get pod termination-demo
</code></pre>
<p>Podが実行されなくなるまで、上記のコマンドを繰り返します。</p>
</li>
<li>
<p>Podに関する詳細情報を表示します:</p>
<pre><code> kubectl get pod termination-demo --output=yaml
</code></pre>
<p>出力には「Sleep expired」メッセージが含まれています:</p>
<pre><code> apiVersion: v1
 kind: Pod
 ...
     lastState:
       terminated:
         containerID: ...
         exitCode: 0
         finishedAt: ...
         message: |
           Sleep expired
         ...
</code></pre>
</li>
<li>
<p>Goテンプレートを使用して、終了メッセージのみが含まれるように出力をフィルタリングします:</p>
<pre><code> kubectl get pod termination-demo -o go-template=&quot;{{range .status.containerStatuses}}{{.lastState.terminated.message}}{{end}}&quot;
</code></pre>
</li>
</ol>
<h2 id=終了メッセージのカスタマイズ>終了メッセージのカスタマイズ</h2>
<p>Kubernetesは、コンテナの<code>terminationMessagePath</code>フィールドで指定されている終了メッセージファイルから終了メッセージを取得します。デフォルト値は<code>/dev/termination-log</code>です。このフィールドをカスタマイズすることで、Kubernetesに別のファイルを使うように指示できます。Kubernetesは指定されたファイルの内容を使用して、成功と失敗の両方についてコンテナのステータスメッセージを入力します。</p>
<p>終了メッセージはアサーションエラーメッセージのように、最終状態を簡潔に示します。kubeletは4096バイトより長いメッセージは切り詰めます。全コンテナの合計メッセージの長さの上限は12キビバイトです。デフォルトの終了メッセージのパスは<code>/dev/termination-log</code>です。Pod起動後に終了メッセージのパスを設定することはできません。</p>
<p>次の例では、コンテナはKubernetesが取得するために終了メッセージを<code>/tmp/my-log</code>に書き込みます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>msg-path-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>msg-path-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>terminationMessagePath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp/my-log&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>さらに、ユーザーは追加のカスタマイズをするためにContainerの<code>terminationMessagePolicy</code>フィールドを設定できます。このフィールドのデフォルト値は<code>File</code>です。これは、終了メッセージが終了メッセージファイルからのみ取得されることを意味します。<code>terminationMessagePolicy</code>を<code>FallbackToLogsOnError</code>に設定することで、終了メッセージファイルが空でコンテナがエラーで終了した場合に、コンテナログ出力の最後のチャンクを使用するようにKubernetesに指示できます。ログ出力は、2048バイトまたは80行のどちらか小さい方に制限されています。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#container-v1-core>コンテナ</a>の<code>terminationMessagePath</code>フィールド参照</li>
<li><a href=/docs/concepts/cluster-administration/logging/>ログ取得</a>について</li>
<li><a href=https://golang.org/pkg/text/template/>Goテンプレート</a>について</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f79645981e310858111bd5673614cab6>4.10.4 - Serviceのデバッグ</h1>
<p>新規にKubernetesをインストールした環境でかなり頻繁に発生する問題は、Serviceが適切に機能しないというものです。Deployment(または他のワークロードコントローラー)を通じてPodを実行し、サービスを作成したにもかかわらず、アクセスしようとしても応答がありません。何が問題になっているのかを理解するのに、このドキュメントがきっと役立つでしょう。</p>
<h2 id=pod内でコマンドを実行する>Pod内でコマンドを実行する</h2>
<p>ここでの多くのステップでは、クラスターで実行されているPodが見ているものを確認する必要があります。これを行う最も簡単な方法は、インタラクティブなalpineのPodを実行することです。</p>
<pre><code class=language-none data-lang=none>kubectl run -it --rm --restart=Never alpine --image=alpine sh
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> コマンドプロンプトが表示されない場合は、Enterキーを押してみてください。
</div>
<p>使用したい実行中のPodがすでにある場合は、以下のようにしてそのPod内でコマンドを実行できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> &lt;POD-NAME&gt; -c &lt;CONTAINER-NAME&gt; -- &lt;COMMAND&gt;
</code></pre></div><h2 id=セットアップ>セットアップ</h2>
<p>このドキュメントのウォークスルーのために、いくつかのPodを実行しましょう。おそらくあなた自身のServiceをデバッグしているため、あなた自身の詳細に置き換えることもできますし、これに沿って2番目のデータポイントを取得することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment hostnames --image<span style=color:#666>=</span>k8s.gcr.io/serve_hostname
</code></pre></div><pre><code class=language-none data-lang=none>deployment.apps/hostnames created
</code></pre><p><code>kubectl</code>コマンドは作成、変更されたリソースのタイプと名前を出力するため、この後のコマンドで使用することもできます。</p>
<p>Deploymentを3つのレプリカにスケールさせてみましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment hostnames --replicas<span style=color:#666>=</span><span style=color:#666>3</span>
</code></pre></div><pre><code class=language-none data-lang=none>deployment.apps/hostnames scaled
</code></pre><p>これは、次のYAMLでDeploymentを開始した場合と同じです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/serve_hostname<span style=color:#bbb>
</span></code></pre></div><p>"app"ラベルは<code>kubectl create deployment</code>によって、Deploymentの名前に自動的にセットされます。</p>
<p>Podが実行されていることを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME                        READY     STATUS    RESTARTS   AGE
hostnames-632524106-bbpiw   1/1       Running   0          2m
hostnames-632524106-ly40y   1/1       Running   0          2m
hostnames-632524106-tlaok   1/1       Running   0          2m
</code></pre><p>Podが機能していることも確認できます。Pod IP アドレスリストを取得し、直接テストできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .items}}{{.status.podIP}}{{&#34;\n&#34;}}{{end}}&#39;</span>
</code></pre></div><pre><code class=language-none data-lang=none>10.244.0.5
10.244.0.6
10.244.0.7
</code></pre><p>このウォークスルーに使用されるサンプルコンテナは、ポート9376でHTTPを介して独自のホスト名を提供するだけですが、独自のアプリをデバッグする場合は、Podがリッスンしているポート番号を使用する必要があります。</p>
<p>Pod内から実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> ep in 10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376; <span style=color:#a2f;font-weight:700>do</span>
    wget -qO- <span style=color:#b8860b>$ep</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><p>次のように表示されます。</p>
<pre><code>hostnames-632524106-bbpiw
hostnames-632524106-ly40y
hostnames-632524106-tlaok
</code></pre><p>この時点で期待通りの応答が得られない場合、Podが正常でないか、想定しているポートでリッスンしていない可能性があります。なにが起きているかを確認するために<code>kubectl logs</code>が役立ちます。Podに直接に入りデバッグする場合は<code>kubectl exec</code>が必要になります。</p>
<p>これまでにすべての計画が完了していると想定すると、Serviceが機能しない理由を調査することができます。</p>
<h2 id=serviceは存在するか>Serviceは存在するか？</h2>
<p>賢明な読者は、Serviceをまだ実際に作成していないことにお気付きかと思いますが、これは意図的です。これは時々忘れられるステップであり、最初に確認すべきことです。</p>
<p>存在しないServiceにアクセスしようとするとどうなるでしょうか？このServiceを名前で利用する別のPodがあると仮定すると、次のような結果が得られます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget -O- hostnames
</code></pre></div><pre><code class=language-none data-lang=none>Resolving hostnames (hostnames)... failed: Name or service not known.
wget: unable to resolve host address 'hostnames'
</code></pre><p>最初に確認するのは、そのServiceが実際に存在するかどうかです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc hostnames
</code></pre></div><pre><code class=language-none data-lang=none>No resources found.
Error from server (NotFound): services &quot;hostnames&quot; not found
</code></pre><p>Serviceを作成しましょう。前と同様に、これはウォークスルー用です。ご自身のServiceの詳細を使用することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment hostnames --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>9376</span>
</code></pre></div><pre><code class=language-none data-lang=none>service/hostnames exposed
</code></pre><p>そして、念のため内容を確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME        TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
hostnames   ClusterIP   10.0.1.175   &lt;none&gt;        80/TCP    5s
</code></pre><p>これで、Serviceが存在することがわかりました。</p>
<p>前と同様に、これは次のようなYAMLでServiceを開始した場合と同じです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></code></pre></div><p>構成の全範囲をハイライトするため、ここで作成したServiceはPodとは異なるポート番号を使用します。多くの実際のServiceでは、これらのポートは同じになる場合があります。</p>
<h2 id=サービスはdns名によって機能しているか>サービスはDNS名によって機能しているか？</h2>
<p>クライアントがサービスを使用する最も一般的な方法の1つは、DNS名を使用することです。同じNamespaceのPodから次のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre><p>これが失敗した場合、おそらくPodとServiceが異なるNamespaceにあるため、ネームスペースで修飾された名前を試してください。(Podの中からもう一度)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames.default
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre><p>これが機能する場合、クロスネームスペース名を使用するようにアプリケーションを調整するか、同じNamespaceでアプリとServiceを実行する必要があります。これでも失敗する場合は、完全修飾名を試してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default.svc.cluster.local
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames.default.svc.cluster.local
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre><p>ここでのサフィックス"default.svc.cluster.local"に注意してください。"default"は、操作しているNamespaceです。"svc"は、これがServiceであることを示します。"cluster.local"はクラスタードメインであり、あなたのクラスターでは異なる場合があります。</p>
<p>クラスター内のノードからも試すこともできます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 10.0.0.10はクラスターのDNSサービスのIPであり、あなたのクラスターでは異なるかもしれません。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default.svc.cluster.local 10.0.0.10
</code></pre></div><pre><code class=language-none data-lang=none>Server:         10.0.0.10
Address:        10.0.0.10#53

Name:   hostnames.default.svc.cluster.local
Address: 10.0.1.175
</code></pre><p>完全修飾名では検索できるのに、相対名ではできない場合、Podの<code>/etc/resolv.conf</code>ファイルが正しいことを確認する必要があります。Pod内から実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /etc/resolv.conf
</code></pre></div><p>次のように表示されます。</p>
<pre><code>nameserver 10.0.0.10
search default.svc.cluster.local svc.cluster.local cluster.local example.com
options ndots:5
</code></pre><p>nameserver行はクラスターのDNS Serviceを示さなければなりません。これは、<code>--cluster-dns</code>フラグで<code>kubelet</code>に渡されます。</p>
<p><code>search</code>行には、<code>Service</code>名を見つけるための適切なサフィックスを含める必要があります。この場合、ローカルの<code>Namespace</code>で<code>Service</code>を見つけるためのサフィックス(<code>default.svc.cluster.local</code>)、すべての<code>Namespaces</code>で<code>Service</code>を見つけるためのサフィックス(<code>svc.cluster.local</code>)、およびクラスターのサフィックス(<code>cluster.local</code>)です。インストール方法によっては、その後に追加のレコードがある場合があります(合計6つまで)。クラスターのサフィックスは、<code>--cluster-domain</code>フラグを使用して<code>kubelet</code>に渡されます。このドキュメントではそれが"cluster.local"であると仮定していますが、あなたのクラスターでは異なる場合があります。その場合は、上記のすべてのコマンドでクラスターのサフィックスを変更する必要があります。</p>
<p><code>options</code>行では、DNSクライアントライブラリーが検索パスをまったく考慮しないように<code>ndots</code>を十分に高く設定する必要があります。Kubernetesはデフォルトでこれを5に設定します。これは、生成されるすべてのDNS名をカバーするのに十分な大きさです。</p>
<h3 id=does-any-service-exist-in-dns>DNS名で機能するServiceはあるか？</h3>
<p>上記がまだ失敗する場合、DNSルックアップがServiceに対して機能していません。一歩離れて、他の何が機能していないかを確認しましょう。KubernetesマスターのServiceは常に機能するはずです。Pod内から実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup kubernetes.default
</code></pre></div><pre><code class=language-none data-lang=none>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      kubernetes.default
Address 1: 10.0.0.1 kubernetes.default.svc.cluster.local
</code></pre><p>これが失敗する場合は、このドキュメントの<a href=#is-the-kube-proxy-working>kube-proxy</a>セクションを参照するか、このドキュメントの先頭に戻って最初からやり直してください。ただし、あなた自身のServiceをデバッグするのではなく、DNSサービスをデバッグします。</p>
<h2 id=serviceはipでは機能するか>ServiceはIPでは機能するか？</h2>
<p>DNSサービスが正しく動作できると仮定すると、次にテストするのはIPによってServiceが動作しているかどうかです。上述の<code>kubectl get</code>で確認できるIPに、クラスター内のPodからアクセスします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#a2f;font-weight:700>$(</span>seq <span style=color:#666>1</span> 3<span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
    wget -qO- 10.0.1.175:80
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><p>次のように表示されます。</p>
<pre><code>hostnames-0uton
hostnames-bvc05
hostnames-yp2kp
</code></pre><p>Serviceが機能している場合は、正しい応答が得られるはずです。そうでない場合、おかしい可能性のあるものがいくつかあるため、続けましょう。</p>
<h2 id=serviceは正しく定義されているか>Serviceは正しく定義されているか？</h2>
<p>馬鹿げているように聞こえるかもしれませんが、Serviceが正しく定義されPodのポートとマッチすることを二度、三度と確認すべきです。Serviceを読み返して確認しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service hostnames -o json
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Service&#34;</span>,
    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;428c8b6c-24bc-11e5-936d-42010af0a9bc&#34;</span>,
        <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>: <span style=color:#b44>&#34;347189&#34;</span>,
        <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>: <span style=color:#b44>&#34;2015-07-07T15:24:29Z&#34;</span>,
        <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;app&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>
        }
    },
    <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;ports&#34;</span>: [
            {
                <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
                <span style=color:green;font-weight:700>&#34;protocol&#34;</span>: <span style=color:#b44>&#34;TCP&#34;</span>,
                <span style=color:green;font-weight:700>&#34;port&#34;</span>: <span style=color:#666>80</span>,
                <span style=color:green;font-weight:700>&#34;targetPort&#34;</span>: <span style=color:#666>9376</span>,
                <span style=color:green;font-weight:700>&#34;nodePort&#34;</span>: <span style=color:#666>0</span>
            }
        ],
        <span style=color:green;font-weight:700>&#34;selector&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;app&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>
        },
        <span style=color:green;font-weight:700>&#34;clusterIP&#34;</span>: <span style=color:#b44>&#34;10.0.1.175&#34;</span>,
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;ClusterIP&#34;</span>,
        <span style=color:green;font-weight:700>&#34;sessionAffinity&#34;</span>: <span style=color:#b44>&#34;None&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;loadBalancer&#34;</span>: {}
    }
}
</code></pre></div><ul>
<li>アクセスしようとしているServiceポートは<code>spec.ports[]</code>のリストのなかに定義されていますか？</li>
<li><code>targetPort</code>はPodに対して適切ですか(いくつかのPodはServiceとは異なるポートを使用します)？</li>
<li><code>targetPort</code>を数値で定義しようとしている場合、それは数値(9376)、文字列"9376"のどちらですか？</li>
<li><code>targetPort</code>を名前で定義しようとしている場合、Podは同じ名前でポートを公開していますか？</li>
<li>ポートの<code>protocol</code>はPodに適切ですか？</li>
</ul>
<h2 id=serviceにendpointsがあるか>ServiceにEndpointsがあるか？</h2>
<p>ここまで来たということは、Serviceは正しく定義され、DNSによって名前解決できることが確認できているでしょう。ここでは、実行したPodがServiceによって実際に選択されていることを確認しましょう。</p>
<p>以前に、Podが実行されていることを確認しました。再確認しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME                        READY     STATUS    RESTARTS   AGE
hostnames-632524106-bbpiw   1/1       Running   0          1h
hostnames-632524106-ly40y   1/1       Running   0          1h
hostnames-632524106-tlaok   1/1       Running   0          1h
</code></pre><p><code>-l app=hostnames</code>引数はラベルセレクターで、ちょうど私たちの<code>Service</code>に定義されているものと同じです。</p>
<p>"AGE"列は、これらのPodが約1時間前のものであることを示しており、それらが正常に実行され、クラッシュしていないことを意味します。</p>
<p>"RESTARTS"列は、これらのポッドが頻繁にクラッシュしたり、再起動されていないことを示しています。頻繁に再起動すると、断続的な接続性の問題が発生する可能性があります。再起動回数が多い場合は、<a href=/ja/docs/tasks/debug-application-cluster/debug-pod-replication-controller/#pod%E3%81%AE%E3%83%87%E3%83%90%E3%83%83%E3%82%B0>ポッドをデバッグする</a>を参照してください。</p>
<p>Kubernetesシステム内には、すべてのServiceのセレクターを評価し、結果をEndpointsオブジェクトに保存するコントロールループがあります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get endpoints hostnames

NAME        ENDPOINTS
hostnames   10.244.0.5:9376,10.244.0.6:9376,10.244.0.7:9376
</code></pre></div><p>これにより、EndpointsコントローラーがServiceの正しいPodを見つけていることを確認できます。<code>ENDPOINTS</code>列が<code>&lt;none></code>の場合、Serviceの<code>spec.selector</code>フィールドが実際にPodの<code>metadata.labels</code>値を選択していることを確認する必要があります。よくある間違いは、タイプミスやその他のエラー、たとえばDeployment作成にも<code>kubectl run</code>が使われた1.18以前のバージョンのように、Serviceが<code>app=hostnames</code>を選択しているのにDeploymentが<code>run=hostnames</code>を指定していることです。</p>
<h2 id=podは機能しているか>Podは機能しているか？</h2>
<p>この時点で、Serviceが存在し、Podを選択していることがわかります。このウォークスルーの最初に、Pod自体を確認しました。Podが実際に機能していることを確認しましょう。Serviceメカニズムをバイパスして、上記EndpointsにリストされているPodに直接アクセスすることができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> これらのコマンドは、Serviceポート(80)ではなく、Podポート(9376)を使用します。
</div>
<p>Pod内から実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> ep in 10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376; <span style=color:#a2f;font-weight:700>do</span>
    wget -qO- <span style=color:#b8860b>$ep</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><p>次のように表示されます。</p>
<pre><code>hostnames-632524106-bbpiw
hostnames-632524106-ly40y
hostnames-632524106-tlaok
</code></pre><p>Endpointsリスト内の各Podは、それぞれの自身のホスト名を返すはずです。そうならない(または、あなた自身のPodの正しい振る舞いにならない)場合は、そこで何が起こっているのかを調査する必要があります。</p>
<h2 id=is-the-kube-proxy-working>kube-proxyは機能しているか？</h2>
<p>ここに到達したのなら、Serviceは実行され、Endpointsがあり、Podが実際にサービスを提供しています。この時点で、Serviceのプロキシーメカニズム全体が疑わしいです。ひとつひとつ確認しましょう。</p>
<p>Serviceのデフォルト実装、およびほとんどのクラスターで使用されるものは、kube-proxyです。kube-proxyはそれぞれのノードで実行され、Serviceの抽象化を提供するための小さなメカニズムセットの1つを構成するプログラムです。クラスターがkube-proxyを使用しない場合、以下のセクションは適用されず、使用しているServiceの実装を調査する必要があります。</p>
<h3 id=kube-proxyは実行されているか>kube-proxyは実行されているか？</h3>
<p><code>kube-proxy</code>がノード上で実行されていることを確認しましょう。ノードで実行されていれば、以下のような結果が得られるはずです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps auxw | grep kube-proxy
</code></pre></div><pre><code class=language-none data-lang=none> root  4194  0.4  0.1 101864 17696 ?    Sl Jul04  25:43 /usr/local/bin/kube-proxy --master=https://kubernetes-master --kubeconfig=/var/lib/kube-proxy/kubeconfig --v=2
</code></pre><p>次に、マスターとの接続など、明らかな失敗をしていないことを確認します。これを行うには、ログを確認する必要があります。ログへのアクセス方法は、ノードのOSに依存します。一部のOSでは/var/log/kube-proxy.logのようなファイルですが、他のOSでは<code>journalctl</code>を使用してログにアクセスします。次のように表示されます。</p>
<pre><code class=language-none data-lang=none>I1027 22:14:53.995134    5063 server.go:200] Running in resource-only container &quot;/kube-proxy&quot;
I1027 22:14:53.998163    5063 server.go:247] Using iptables Proxier.
I1027 22:14:53.999055    5063 server.go:255] Tearing down userspace rules. Errors here are acceptable.
I1027 22:14:54.038140    5063 proxier.go:352] Setting endpoints for &quot;kube-system/kube-dns:dns-tcp&quot; to [10.244.1.3:53]
I1027 22:14:54.038164    5063 proxier.go:352] Setting endpoints for &quot;kube-system/kube-dns:dns&quot; to [10.244.1.3:53]
I1027 22:14:54.038209    5063 proxier.go:352] Setting endpoints for &quot;default/kubernetes:https&quot; to [10.240.0.2:443]
I1027 22:14:54.038238    5063 proxier.go:429] Not syncing iptables until Services and Endpoints have been received from master
I1027 22:14:54.040048    5063 proxier.go:294] Adding new service &quot;default/kubernetes:https&quot; at 10.0.0.1:443/TCP
I1027 22:14:54.040154    5063 proxier.go:294] Adding new service &quot;kube-system/kube-dns:dns&quot; at 10.0.0.10:53/UDP
I1027 22:14:54.040223    5063 proxier.go:294] Adding new service &quot;kube-system/kube-dns:dns-tcp&quot; at 10.0.0.10:53/TCP
</code></pre><p>マスターに接続できないことに関するエラーメッセージが表示された場合、ノードの設定とインストール手順をダブルチェックする必要があります。</p>
<p><code>kube-proxy</code>が正しく実行できない理由の可能性の1つは、必須の<code>conntrack</code>バイナリが見つからないことです。これは、例えばKubernetesをスクラッチからインストールするなど、クラスターのインストール方法に依存して、一部のLinuxシステムで発生する場合があります。これが該当する場合は、<code>conntrack</code>パッケージを手動でインストール(例: Ubuntuでは<code>sudo apt install conntrack</code>)する必要があり、その後に再試行する必要があります。</p>
<p>kube-proxyは、いくつかのモードのいずれかで実行できます。上記のログの<code>Using iptables Proxier</code>という行は、kube-proxyが「iptables」モードで実行されていることを示しています。最も一般的な他のモードは「ipvs」です。古い「ユーザースペース」モードは、主にこれらに置き換えられました。</p>
<h4 id=iptables-mode>Iptables mode</h4>
<p>「iptables」モードでは、ノードに次のようなものが表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>iptables-save | grep hostnames
</code></pre></div><pre><code class=language-none data-lang=none>-A KUBE-SEP-57KPRZ3JQVENLNBR -s 10.244.3.6/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-57KPRZ3JQVENLNBR -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.3.6:9376
-A KUBE-SEP-WNBA2IHDGP2BOBGZ -s 10.244.1.7/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-WNBA2IHDGP2BOBGZ -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.1.7:9376
-A KUBE-SEP-X3P2623AGDH6CDF3 -s 10.244.2.3/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-X3P2623AGDH6CDF3 -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.2.3:9376
-A KUBE-SERVICES -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames: cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-NWV5X2332I4OT4T3
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-WNBA2IHDGP2BOBGZ
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-X3P2623AGDH6CDF3
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -j KUBE-SEP-57KPRZ3JQVENLNBR
</code></pre><p>各サービスのポートごとに、<code>KUBE-SERVICES</code>に1つのルールと1つの<code>KUBE-SVC- &lt;hash></code>チェーンが必要です。Podエンドポイントごとに、その<code>KUBE-SVC- &lt;hash></code>に少数のルールがあり、少数のルールが含まれる1つの<code>KUBE-SEP- &lt;hash></code>チェーンがあるはずです。正確なルールは、正確な構成(NodePortとLoadBalancerを含む)に基づいて異なります。</p>
<h4 id=ipvs-mode>IPVS mode</h4>
<p>「ipvs」モードでは、ノードに次のようなものが表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ipvsadm -ln
</code></pre></div><pre><code class=language-none data-lang=none>Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
...
TCP  10.0.1.175:80 rr
  -&gt; 10.244.0.5:9376               Masq    1      0          0
  -&gt; 10.244.0.6:9376               Masq    1      0          0
  -&gt; 10.244.0.7:9376               Masq    1      0          0
...
</code></pre><p>各Serviceの各ポートに加えて、NodePort、External IP、およびLoad Balancer IPに対して、kube-proxyは仮想サーバーを作成します。Pod endpointごとに、対応する実サーバーが作成されます。この例では、サービスhostnames(<code>10.0.1.175:80</code>)は3つのendpoints(<code>10.244.0.5:9376</code>、<code>10.244.0.6:9376</code>、<code>10.244.0.7:9376</code>)を持っています。</p>
<p>IPVSプロキシーは、各Serviceアドレス(Cluster IP、External IP、NodePort IP、Load Balancer IPなど)毎の仮想サーバーと、Serviceのエンドポイントが存在する場合に対応する実サーバーを作成します。この例では、hostnames Service(<code>10.0.1.175:80</code>)は3つのエンドポイント(<code>10.244.0.5:9376</code>、<code>10.244.0.6:9376</code>、<code>10.244.0.7:9376</code>)を持ち、上と似た結果が得られるはずです。</p>
<h4 id=userspace-mode>Userspace mode</h4>
<p>まれに、「userspace」モードを使用している場合があります。</p>
<p>ノードから実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>iptables-save | grep hostnames
</code></pre></div><pre><code class=language-none data-lang=none>-A KUBE-PORTALS-CONTAINER -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames:default&quot; -m tcp --dport 80 -j REDIRECT --to-ports 48577
-A KUBE-PORTALS-HOST -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames:default&quot; -m tcp --dport 80 -j DNAT --to-destination 10.240.115.247:48577
</code></pre><p>サービスの各ポートには2つのルールが必要です(この例では1つだけ)-「KUBE-PORTALS-CONTAINER」と「KUBE-PORTALS-HOST」です。</p>
<p>「userspace」モードを使用する必要はほとんどないので、ここでこれ以上時間を費やすことはありません。</p>
<h3 id=kube-proxyはプロキシしているか>kube-proxyはプロキシしているか？</h3>
<p>上記のいずれかが発生したと想定して、いずれかのノードからIPでサービスにアクセスをしています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl 10.0.1.175:80
</code></pre></div><pre><code class=language-none data-lang=none>hostnames-632524106-bbpiw
</code></pre><p>もしこれが失敗し、あなたがuserspaceプロキシーを使用している場合、プロキシーへの直接アクセスを試してみてください。もしiptablesプロキシーを使用している場合、このセクションはスキップしてください。</p>
<p>上記の<code>iptables-save</code>の出力を振り返り、<code>kube-proxy</code>がServiceに使用しているポート番号を抽出します。上記の例では"48577"です。このポートに接続してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl localhost:48577
</code></pre></div><pre><code class=language-none data-lang=none>hostnames-632524106-tlaok
</code></pre><p>もしまだ失敗する場合は、<code>kube-proxy</code>ログで次のような特定の行を探してください。</p>
<pre><code class=language-none data-lang=none>Setting endpoints for default/hostnames:default to [10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376]
</code></pre><p>これらが表示されない場合は、<code>-v</code>フラグを4に設定して<code>kube-proxy</code>を再起動してから、再度ログを確認してください。</p>
<h3 id=a-pod-fails-to-reach-itself-via-the-service-ip>エッジケース: PodがService IP経由で自身に到達できない</h3>
<p>これはありそうに聞こえないかもしれませんが、実際には起こり、動作するはずです。これはネットワークが"hairpin"トラフィック用に適切に設定されていない場合、通常は<code>kube-proxy</code>が<code>iptables</code>モードで実行され、Podがブリッジネットワークに接続されている場合に発生します。<code>Kubelet</code>は<code>hairpin-mode</code><a href=/docs/reference/command-line-tools-reference/kubelet/>フラグ</a>を公開します。これにより、Serviceのエンドポイントが自身のServiceのVIPにアクセスしようとした場合に、自身への負荷分散を可能にします。<code>hairpin-mode</code>フラグは<code>hairpin-veth</code>または<code>promiscuous-bridge</code>に設定する必要があります。</p>
<p>この問題をトラブルシューティングする一般的な手順は次のとおりです。</p>
<ul>
<li><code>hairpin-mode</code>が<code>hairpin-veth</code>または<code>promiscuous-bridge</code>に設定されていることを確認します。次のような表示がされるはずです。この例では、<code>hairpin-mode</code>は<code>promiscuous-bridge</code>に設定されています。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps auxw | grep kubelet
</code></pre></div><pre><code class=language-none data-lang=none>root      3392  1.1  0.8 186804 65208 ?        Sl   00:51  11:11 /usr/local/bin/kubelet --enable-debugging-handlers=true --config=/etc/kubernetes/manifests --allow-privileged=True --v=4 --cluster-dns=10.0.0.10 --cluster-domain=cluster.local --configure-cbr0=true --cgroup-root=/ --system-cgroups=/system --hairpin-mode=promiscuous-bridge --runtime-cgroups=/docker-daemon --kubelet-cgroups=/kubelet --babysit-daemons=true --max-pods=110 --serialize-image-pulls=false --outofdisk-transition-frequency=0
</code></pre><ul>
<li>実際に使われている<code>hairpin-mode</code>を確認します。これを行うには、kubeletログを確認する必要があります。ログへのアクセス方法は、ノードのOSによって異なります。一部のOSでは/var/log/kubelet.logなどのファイルですが、他のOSでは<code>journalctl</code>を使用してログにアクセスします。互換性のために、実際に使われている<code>hairpin-mode</code>が<code>--hairpin-mode</code>フラグと一致しない場合があることに注意してください。kubelet.logにキーワード<code>hairpin</code>を含むログ行があるかどうかを確認してください。実際に使われている<code>hairpin-mode</code>を示す以下のようなログ行があるはずです。</li>
</ul>
<pre><code class=language-none data-lang=none>I0629 00:51:43.648698    3252 kubelet.go:380] Hairpin mode set to &quot;promiscuous-bridge&quot;
</code></pre><ul>
<li>実際に使われている<code>hairpin-mode</code>が<code>hairpin-veth</code>の場合、<code>Kubelet</code>にノードの<code>/sys</code>で操作する権限があることを確認します。すべてが正常に機能している場合、次のようなものが表示されます。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> intf in /sys/devices/virtual/net/cbr0/brif/*; <span style=color:#a2f;font-weight:700>do</span> cat <span style=color:#b8860b>$intf</span>/hairpin_mode; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><pre><code class=language-none data-lang=none>1
1
1
1
</code></pre><p>実際に使われている<code>hairpin-mode</code>が<code>promiscuous-bridge</code>の場合、<code>Kubelet</code>にノード上のLinuxブリッジを操作する権限があることを確認してください。<code>cbr0</code>ブリッジが使用され適切に構成されている場合、以下が表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ifconfig cbr0 |grep PROMISC
</code></pre></div><pre><code class=language-none data-lang=none>UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1460  Metric:1
</code></pre><ul>
<li>上記のいずれも解決しない場合、助けを求めてください。</li>
</ul>
<h2 id=助けを求める>助けを求める</h2>
<p>ここまでたどり着いたということは、とてもおかしなことが起こっています。Serviceは実行中で、Endpointsがあり、Podは実際にサービスを提供しています。DNSは動作していて、<code>kube-proxy</code>も誤動作していないようです。それでも、あなたのServiceは機能していません。おそらく私たちにお知らせ頂いた方がよいでしょう。調査をお手伝いします！</p>
<p><a href=/docs/tasks/debug-application-cluster/troubleshooting/#slack>Slack</a>、<a href=https://discuss.kubernetes.io>Forum</a>または<a href=https://github.com/kubernetes/kubernetes>GitHub</a>でお問い合わせください。</p>
<h2 id=次の項目>次の項目</h2>
<p>詳細については、<a href=/docs/tasks/debug-application-cluster/troubleshooting/>トラブルシューティングドキュメント</a>をご覧ください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a070b1250ee142402d492b505a56ca83>4.10.5 - StatefulSetのデバッグ</h1>
<p>このタスクでは、StatefulSetをデバッグする方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>Kubernetesクラスターが必要です。また、kubectlコマンドラインツールがクラスターと通信するように設定されている必要があります。</li>
<li>調べたいStatefulSetを実行しておきましょう。</li>
</ul>
<h2 id=statefulsetのデバッグ>StatefulSetのデバッグ</h2>
<p>StatefulSetに属し、ラベル<code>app=myapp</code>が設定されているすべてのPodを一覧表示するには、以下のコマンドを利用できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp
</code></pre></div><p>Podが長期間<code>Unknown</code>または<code>Terminating</code>の状態になっていることがわかった場合は、それらを処理する方法について<a href=/ja/docs/tasks/run-application/delete-stateful-set/>StatefulSetの削除</a>タスクを参照してください。
<a href=/docs/tasks/debug-application-cluster/debug-pod-replication-controller/>Podのデバッグ</a>ガイドを使用して、StatefulSet内の個々のPodをデバッグできます。</p>
<h2 id=次の項目>次の項目</h2>
<p><a href=/ja/docs/tasks/debug-application-cluster/debug-init-containers/>Initコンテナのデバッグ</a>の詳細</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9713ac27b6d9e3034033200d968221f2>4.10.6 - 実行中のコンテナへのシェルを取得する</h1>
<p>このページは<code>kubectl exec</code>を使用して実行中のコンテナへのシェルを取得する方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=コンテナへのシェルの取得>コンテナへのシェルの取得</h2>
<p>このエクササイズでは、1つのコンテナを持つPodを作成します。
コンテナはnginxのイメージを実行します。以下がそのPodの設定ファイルです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/shell-demo.yaml download=application/shell-demo.yaml><code>application/shell-demo.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-shell-demo-yaml')" title="Copy application/shell-demo.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-shell-demo-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/shell-demo.yaml
</code></pre></div><p>コンテナが実行中であることを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod shell-demo
</code></pre></div><p>実行中のコンテナへのシェルを取得します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> --stdin --tty shell-demo -- /bin/bash
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ダブルダッシュの記号 <code>--</code> はコマンドに渡す引数とkubectlの引数を分離します。
</div>
<p>シェル内で、ルートディレクトリーのファイル一覧を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドをコンテナ内で実行します</span>
ls /
</code></pre></div><p>シェル内で、他のコマンドを試しましょう。以下がいくつかの例です:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># これらのサンプルコマンドをコンテナ内で実行することができます</span>
ls /
cat /proc/mounts
cat /proc/1/maps
apt-get update
apt-get install -y tcpdump
tcpdump
apt-get install -y lsof
lsof
apt-get install -y procps
ps aux
ps aux | grep nginx
</code></pre></div><h2 id=nginxのルートページへの書き込み>nginxのルートページへの書き込み</h2>
<p>Podの設定ファイルを再度確認します。Podは<code>emptyDir</code>ボリュームを持ち、
コンテナは<code>/usr/share/nginx/html</code>ボリュームをマウントします。</p>
<p>シェル内で、<code>/usr/share/nginx/html</code>ディレクトリに<code>index.html</code>を作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドをコンテナ内で実行します</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;Hello shell demo&#39;</span> &gt; /usr/share/nginx/html/index.html
</code></pre></div><p>シェル内で、nginxサーバーにGETリクエストを送信します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># これらのコマンドをコンテナ内のシェルで実行します</span>
apt-get update
apt-get install curl
curl http://localhost/
</code></pre></div><p>出力に<code>index.html</code>ファイルに書き込んだ文字列が表示されます:</p>
<pre><code>Hello shell demo
</code></pre><p>シェルを終了する場合、<code>exit</code>を入力します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>exit</span> <span style=color:#080;font-style:italic># コンテナ内のシェルを終了する</span>
</code></pre></div><h2 id=コンテナ内での各コマンドの実行>コンテナ内での各コマンドの実行</h2>
<p>シェルではない通常のコマンドウインドウ内で、実行中のコンテナの環境変数の一覧を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> shell-demo env
</code></pre></div><p>他のコマンドを試します。以下がいくつかの例です:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> shell-demo -- ps aux
kubectl <span style=color:#a2f>exec</span> shell-demo -- ls /
kubectl <span style=color:#a2f>exec</span> shell-demo -- cat /proc/1/mounts
</code></pre></div>
<h2 id=podが1つ以上のコンテナを持つ場合にシェルを開く>Podが1つ以上のコンテナを持つ場合にシェルを開く</h2>
<p>Podが1つ以上のコンテナを持つ場合、<code>--container</code>か<code>-c</code>を使用して、<code>kubectl exec</code>コマンド内でコンテナを指定します。
例えば、my-podという名前のPodがあり、そのPodが <em>main-app</em> と <em>helper-app</em> という2つのコンテナを持つとします。
以下のコマンドは <em>main-app</em> のコンテナへのシェルを開きます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -i -t my-pod --container main-app -- /bin/bash
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ショートオプションの<code>-i</code>と<code>-t</code>は、ロングオプションの<code>--stdin</code>と<code>--tty</code>と同様です。
</div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>について読む</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d3c88a8663f58e9ec0bed73faff5b670>4.11 - TLS</h1>
<div class=lead>Transport Layer Security(TLS)を使用して、クラスター内のトラフィックを保護する方法について理解します。</div>
</div>
<div class=td-content>
<h1 id=pg-1272b18ac0c008f6ffc2c62a29fa929f>4.11.1 - Kubeletの証明書のローテーションを設定する</h1>
<p>このページでは、kubeletの証明書のローテーションを設定する方法を説明します。</p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.8 [beta]</code>
</div>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>Kubernetesはバージョン1.8.0以降である必要があります。</li>
</ul>
<h2 id=概要>概要</h2>
<p>kubeletは、Kubernetes APIへの認証のために証明書を使用します。デフォルトでは、証明書は1年間の有効期限付きで発行されるため、頻繁に更新する必要はありません。</p>
<p>Kubernetes 1.8にはベータ機能の<a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet certificate rotation</a>が含まれているため、現在の証明書の有効期限が近づいたときに自動的に新しい鍵を生成して、Kubernetes APIに新しい証明書をリクエストできます。新しい証明書が利用できるようになると、Kubernetes APIへの接続の認証に利用されます。</p>
<h2 id=クライアント証明書のローテーションを有効にする>クライアント証明書のローテーションを有効にする</h2>
<p><code>kubelet</code>プロセスは<code>--rotate-certificates</code>という引数を受け付けます。この引数によって、現在使用している証明書の有効期限が近づいたときに、kubeletが自動的に新しい証明書をリクエストするかどうかを制御できます。証明書のローテーションはベータ機能であるため、<code>--feature-gates=RotateKubeletClientCertificate=true</code>を使用してフィーチャーフラグを有効にする必要もあります。</p>
<p><code>kube-controller-manager</code>プロセスは、<code>--experimental-cluster-signing-duration</code>という引数を受け付け、この引数で証明書が発行される期間を制御できます。</p>
<h2 id=証明書のローテーションの設定を理解する>証明書のローテーションの設定を理解する</h2>
<p>kubeletが起動すると、ブートストラップが設定されている場合(<code>--bootstrap-kubeconfig</code>フラグを使用した場合)、初期証明書を使用してKubernetes APIに接続して、証明書署名リクエスト(certificate signing request、CSR)を発行します。証明書署名リクエストのステータスは、次のコマンドで表示できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl get csr
</code></pre></div><p>ノード上のkubeletから発行された証明書署名リクエストは、初めは<code>Pending</code>状態です。証明書署名リクエストが特定の条件を満たすと、コントローラーマネージャーに自動的に承認され、<code>Approved</code>状態になります。次に、コントローラーマネージャーは<code>--experimental-cluster-signing-duration</code>パラメーターで指定された有効期限で発行された証明書に署名を行い、署名された証明書が証明書署名リクエストに添付されます。</p>
<p>kubeletは署名された証明書をKubernetes APIから取得し、ディスク上の<code>--cert-dir</code>で指定された場所に書き込みます。その後、kubeletは新しい証明書を使用してKubernetes APIに接続するようになります。</p>
<p>署名された証明書の有効期限が近づくと、kubeletはKubernetes APIを使用して新しい証明書署名リクエストを自動的に発行します。再び、コントローラーマネージャーは証明書のリクエストを自動的に承認し、署名された証明書を証明書署名リクエストに添付します。kubeletは新しい署名された証明書をKubernetes APIから取得してディスクに書き込みます。その後、kubeletは既存のコネクションを更新して、新しい証明書でKubernetes APIに再接続します。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5266308e17490aeee8b018316bf47e03>4.12 - サービスカタログ</h1>
<div class=lead>サービスカタログ拡張APIをインストールする</div>
</div>
<div class=td-content>
<h1 id=pg-f741b6fc36e27a6f79c1c3d02a40d8f9>4.12.1 - Helmを使用したサービスカタログのインストール</h1>
<p><p>サービスカタログは kubernetesクラスターで稼働するアプリケーションが、クラウドプロバイダーによって提供されるデータストアサービスのように、外部のマネージドソフトウェアを容易に使えるようにするための拡張APIです。</p></p>
<p>サービスカタログを使用することで<a class=glossary-tooltip title="An endpoint for a set of Managed Services offered and maintained by a third-party." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-service-broker" target=_blank aria-label=サービスブローカー>サービスブローカー</a>が提供する<a class=glossary-tooltip title="A software offering maintained by a third-party provider." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-managed-service" target=_blank aria-label=マネージドサービス>マネージドサービス</a>を、それらのサービスがどのように作成されるか、また管理されるかについての知識を無しに、一覧表示したり、プロビジョニングや使用をすることができます。</p>
<p><a href=https://helm.sh/>Helm</a>を使用してKubernetesクラスターにサービスカタログをインストールします。手順の最新情報は<a href=https://github.com/kubernetes-sigs/service-catalog/blob/master/docs/install.md>kubernetes-sigs/service-catalog</a>リポジトリーを参照してください。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li><a href=/docs/concepts/extend-kubernetes/service-catalog/>サービスカタログ</a>の基本概念を理解してください。</li>
<li>サービスカタログを使用するには、Kubernetesクラスターのバージョンが1.7以降である必要があります。</li>
<li>KubernetesクラスターのクラスターDNSを有効化する必要があります。
<ul>
<li>クラウド上のKubernetesクラスター、または<a class=glossary-tooltip title="A tool for running Kubernetes locally." data-toggle=tooltip data-placement=top href=/docs/setup/learning-environment/minikube/ target=_blank aria-label=Minikube>Minikube</a>を使用している場合、クラスターDNSはすでに有効化されています。</li>
<li><code>hack/local-up-cluster.sh</code>を使用している場合は、環境変数<code>KUBE_ENABLE_CLUSTER_DNS</code>が設定されていることを確認し、インストールスクリプトを実行してください。</li>
</ul>
</li>
<li><a href=/ja/docs/tasks/tools/install-kubectl/>kubectlのインストールおよびセットアップ</a>を参考に、v1.7以降のkubectlをインストールし、設定を行ってください。</li>
<li>v2.7.0以降の<a href=https://helm.sh/>Helm</a>をインストールしてください。
<ul>
<li><a href=https://helm.sh/docs/intro/install/>Helm install instructions</a>を参考にしてください。</li>
<li>上記のバージョンのHelmをすでにインストールしている場合は、<code>helm init</code>を実行し、HelmのサーバーサイドコンポーネントであるTillerをインストールしてください。</li>
</ul>
</li>
</ul>
<h2 id=helmリポジトリーにサービスカタログを追加>Helmリポジトリーにサービスカタログを追加</h2>
<p>Helmをインストールし、以下のコマンドを実行することでローカルマシンに<em>service-catalog</em>のHelmリポジトリーを追加します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm repo add svc-cat https://kubernetes-sigs.github.io/service-catalog
</code></pre></div><p>以下のコマンドを実行し、インストールに成功していることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm search service-catalog
</code></pre></div><p>インストールが成功していれば、出力は以下のようになります:</p>
<pre><code>NAME                	CHART VERSION	APP VERSION	DESCRIPTION                                                 
svc-cat/catalog     	0.2.1        	           	service-catalog API server and controller-manager helm chart
svc-cat/catalog-v0.2	0.2.2        	           	service-catalog API server and controller-manager helm chart
</code></pre><h2 id=rbacの有効化>RBACの有効化</h2>
<p>KubernetesクラスターのRBACを有効化することで、Tiller Podに<code>cluster-admin</code>アクセスを持たせます。</p>
<p>v0.25以前のMinikubeを使用している場合は、明示的にRBACを有効化して起動する必要があります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube start --extra-config<span style=color:#666>=</span>apiserver.Authorization.Mode<span style=color:#666>=</span>RBAC
</code></pre></div><p>v0.26以降のMinikubeを使用している場合は、以下のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube start
</code></pre></div><p>v0.26以降のMinikubeを使用している場合、<code>--extra-config</code>を指定しないでください。
このフラグは--extra-config=apiserver.authorization-modeを指定するものに変更されており、現在MinikubeではデフォルトでRBACが有効化されています。
古いフラグを指定すると、スタートコマンドが応答しなくなることがあります。</p>
<p><code>hack/local-up-cluster.sh</code>を使用している場合、環境変数<code>AUTHORIZATION_MODE</code>を以下の値に設定してください:</p>
<pre><code>AUTHORIZATION_MODE=Node,RBAC hack/local-up-cluster.sh -O
</code></pre><p><code>helm init</code>は、デフォルトで<code>kube-system</code>のnamespaceにTiller Podをインストールし、Tillerは<code>default</code>のServiceAccountを使用するように設定されています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>helm init</code>を実行する際に<code>--tiller-namespace</code>または<code>--service-account</code>のフラグを使用する場合、以下のコマンドの<code>--serviceaccount</code>フラグには適切なnamespaceとServiceAccountを指定する必要があります。
</div>
<p>Tillerに<code>cluster-admin</code>アクセスを設定する場合:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding tiller-cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --serviceaccount<span style=color:#666>=</span>kube-system:default
</code></pre></div><h2 id=kubernetesクラスターにサービスカタログをインストール>Kubernetesクラスターにサービスカタログをインストール</h2>
<p>以下のコマンドを使用して、Helmリポジトリーのrootからサービスカタログをインストールします:</p>
<ul class="nav nav-tabs" id=helm-versions role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#helm-versions-0 role=tab aria-controls=helm-versions-0 aria-selected=true>Helm バージョン3</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#helm-versions-1 role=tab aria-controls=helm-versions-1>Helm バージョン2</a></li></ul>
<div class=tab-content id=helm-versions><div id=helm-versions-0 class="tab-pane show active" role=tabpanel aria-labelledby=helm-versions-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm install catalog svc-cat/catalog --namespace catalog
</code></pre></div></div>
<div id=helm-versions-1 class=tab-pane role=tabpanel aria-labelledby=helm-versions-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm install svc-cat/catalog --name catalog --namespace catalog
</code></pre></div></div></div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=https://github.com/openservicebrokerapi/servicebroker/blob/master/gettingStarted.md#sample-service-brokers>sample service brokers</a></li>
<li><a href=https://github.com/kubernetes-sigs/service-catalog>kubernetes-sigs/service-catalog</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d85a30635b5c3578487b9f6f214c07ea>4.12.2 - SCを使用したサービスカタログのインストール</h1>
<p><p>サービスカタログは kubernetesクラスターで稼働するアプリケーションが、クラウドプロバイダーによって提供されるデータストアサービスのように、外部のマネージドソフトウェアを容易に使えるようにするための拡張APIです。</p></p>
<p>サービスカタログを使用することで<a class=glossary-tooltip title="An endpoint for a set of Managed Services offered and maintained by a third-party." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-service-broker" target=_blank aria-label=サービスブローカー>サービスブローカー</a>が提供する<a class=glossary-tooltip title="A software offering maintained by a third-party provider." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-managed-service" target=_blank aria-label=マネージドサービス>マネージドサービス</a>を、それらのサービスがどのように作成されるか、また管理されるかについての知識を無しに、一覧表示したり、プロビジョニングや使用をすることができます。</p>
<p>GCPの<a href=https://github.com/GoogleCloudPlatform/k8s-service-catalog#installation>Service Catalog Installer</a>ツールを使うと、Kubernetesクラスター上にサービスカタログを簡単にインストール・アンインストールして、Google Cloudのプロジェクトに紐付けることもできます。</p>
<p>サービスカタログ自体は、Google Cloudだけではなく、どのような種類のマネージドサービスでも動作します。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>
<p><a href=/docs/concepts/extend-kubernetes/service-catalog/>サービスカタログ</a>の基本概念を理解してください。</p>
</li>
<li>
<p><a href=https://golang.org/dl/>Go 1.6+</a>をインストールして、<code>GOPATH</code>を設定してください。</p>
</li>
<li>
<p>SSLに関するファイルを生成するために必要な<a href=https://github.com/cloudflare/cfssl>cfssl</a>ツールをインストールしてください。</p>
</li>
<li>
<p>サービスカタログを使用するには、Kubernetesクラスターのバージョンが1.7以降である必要があります。</p>
</li>
<li>
<p><a href=/ja/docs/tasks/tools/install-kubectl/>kubectlのインストールおよびセットアップ</a>を参考に、v1.7以降のkubectlをインストールし、設定を行ってください。</p>
</li>
<li>
<p>サービスカタログをインストールするためには、kubectlのユーザーが<em>cluster-admin</em>ロールにバインドされている必要があります。正しくバインドされていることを確認するには、次のコマンドを実行します。</p>
<pre><code>  kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=&lt;user-name&gt;
</code></pre>
</li>
</ul>
<h2 id=ローカル環境に-sc-をインストールする>ローカル環境に<code>sc</code>をインストールする</h2>
<p>インストーラーは、ローカルのコンピューター上で<code>sc</code>と呼ばれるCLIツールとして実行します。</p>
<p><code>go get</code>を使用してインストールします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>go get github.com/GoogleCloudPlatform/k8s-service-catalog/installer/cmd/sc
</code></pre></div><p>これで、<code>sc</code>が<code>GOPATH/bin</code>ディレクトリー内にインストールされたはずです。</p>
<h2 id=kubernetesクラスターにサービスカタログをインストールする>Kubernetesクラスターにサービスカタログをインストールする</h2>
<p>まず、すべての依存関係がインストールされていることを確認します。次のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sc check
</code></pre></div><p>チェックが成功したら、次のように表示されるはずです。</p>
<pre><code>Dependency check passed. You are good to go.
</code></pre><p>次に、バックアップに使用したい<code>storageclass</code>を指定して、installコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sc install --etcd-backup-storageclass <span style=color:#b44>&#34;standard&#34;</span>
</code></pre></div><h2 id=サービスカタログのアンインストール>サービスカタログのアンインストール</h2>
<p>Kubernetesクラスターからサービスカタログをアンインストールしたい場合は、<code>sc</code>ツールを使って次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sc uninstall
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=https://github.com/openservicebrokerapi/servicebroker/blob/master/gettingStarted.md#sample-service-brokers>サービスブローカーのサンプル</a>を読む。</li>
<li><a href=https://github.com/kubernetes-incubator/service-catalog>kubernetes-incubator/service-catalog</a>プロジェクトを探索する。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a701e71f3b32dae474c63ae4c596c856>4.13 - ネットワーク</h1>
<div class=lead>クラスターのネットワークの設定方法を学びます。</div>
</div>
<div class=td-content>
<h1 id=pg-2edb5b02ea1e646c333c9fe4d5f02ff1>4.13.1 - HostAliasesを使用してPodの/etc/hostsにエントリーを追加する</h1>
<p>Podの<code>/etc/hosts</code>ファイルにエントリーを追加すると、DNSやその他の選択肢を利用できない場合に、Podレベルでホスト名の名前解決を上書きできるようになります。このようなカスタムエントリーは、PodSpecのHostAliasesフィールドに追加できます。</p>
<p>HostAliasesを使用せずにファイルを修正することはおすすめできません。このファイルはkubeletが管理しており、Podの作成や再起動時に上書きされる可能性があるためです。</p>
<h2 id=デフォルトのhostsファイルの内容>デフォルトのhostsファイルの内容</h2>
<p>Nginx Podを実行すると、Pod IPが割り当てられます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run nginx --image nginx
</code></pre></div><pre><code>pod/nginx created
</code></pre><p>Pod IPを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div><pre><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre><p>hostsファイルの内容は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> nginx -- cat /etc/hosts
</code></pre></div><pre><code># Kubernetes-managed hosts file.
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
fe00::0	ip6-mcastprefix
fe00::1	ip6-allnodes
fe00::2	ip6-allrouters
10.200.0.4	nginx
</code></pre><p>デフォルトでは、<code>hosts</code>ファイルには、<code>localhost</code>やPod自身のホスト名などのIPv4とIPv6のボイラープレートだけが含まれています。</p>
<h2 id=追加エントリーをhostaliasesに追加する>追加エントリーをhostAliasesに追加する</h2>
<p>デフォルトのボイラープレートに加えて、<code>hosts</code>ファイルに追加エントリーを追加できます。たとえば、<code>foo.local</code>と<code>bar.local</code>を<code>127.0.0.1</code>に、<code>foo.remote</code>と<code>bar.remote</code>を<code>10.1.2.3</code>にそれぞれ解決するためには、PodのHostAliasesを<code>.spec.hostAliases</code>以下に設定します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/hostaliases-pod.yaml download=service/networking/hostaliases-pod.yaml><code>service/networking/hostaliases-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-hostaliases-pod-yaml')" title="Copy service/networking/hostaliases-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-hostaliases-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostaliases-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostAliases</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;127.0.0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostnames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;foo.local&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;bar.local&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostnames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;foo.remote&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;bar.remote&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cat-hosts<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- cat<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/hosts&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>この設定を使用したPodを開始するには、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/networking/hostaliases-pod.yaml
</code></pre></div><pre><code>pod/hostaliases-pod created
</code></pre><p>Podの詳細情報を表示して、IPv4アドレスと状態を確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod --output<span style=color:#666>=</span>wide
</code></pre></div><pre><code>NAME                           READY     STATUS      RESTARTS   AGE       IP              NODE
hostaliases-pod                0/1       Completed   0          6s        10.200.0.5      worker0
</code></pre><p><code>hosts</code>ファイルの内容は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs hostaliases-pod
</code></pre></div><pre><code># Kubernetes-managed hosts file.
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
fe00::0	ip6-mcastprefix
fe00::1	ip6-allnodes
fe00::2	ip6-allrouters
10.200.0.5	hostaliases-pod

# Entries added by HostAliases.
127.0.0.1	foo.local	bar.local
10.1.2.3	foo.remote	bar.remote
</code></pre><p>ファイルの最後に追加エントリーが指定されています。</p>
<h2 id=why-does-kubelet-manage-the-hosts-file>kubeletがhostsファイルを管理するのはなぜですか？</h2>
<p>kubeletがPodの各コンテナの<code>hosts</code>ファイルを<a href=https://github.com/kubernetes/kubernetes/issues/14633>管理する</a>のは、コンテナ起動後にDockerがファイルを<a href=https://github.com/moby/moby/issues/17190>編集する</a>のを防ぐためです。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <p>コンテナ内部でhostsファイルを手動で変更するのは控えてください。</p>
<p>hostsファイルを手動で変更すると、コンテナが終了したときに変更が失われてしまいます。</p>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eebac062766222247063d6513f95c7b2>4.13.2 - IPv4/IPv6デュアルスタックの検証</h1>
<p>このドキュメントでは、IPv4/IPv6デュアルスタックが有効化されたKubernetesクラスターを検証する方法について共有します。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>プロバイダーがデュアルスタックのネットワークをサポートしていること (クラウドプロバイダーか、ルーティングできるIPv4/IPv6ネットワークインターフェイスを持つKubernetesノードが提供できること)</li>
<li>(KubenetやCalicoなど)デュアルスタックをサポートする<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a></li>
<li><a href=/ja/docs/concepts/services-networking/dual-stack/>デュアルスタックを有効化</a>したクラスター</li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.20.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
<h2 id=アドレスの検証>アドレスの検証</h2>
<h3 id=ノードアドレスの検証>ノードアドレスの検証</h3>
<p>各デュアルスタックのノードは、1つのIPv4ブロックと1つのIPv6ブロックを割り当てる必要があります。IPv4/IPv6のPodアドレスの範囲が設定されていることを検証するには、次のコマンドを実行します。例の中のノード名は、自分のクラスターの有効なデュアルスタックのノードの名前に置換してください。この例では、ノードの名前は<code>k8s-linuxpool1-34450317-0</code>になっています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes k8s-linuxpool1-34450317-0 -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .spec.podCIDRs}}{{printf &#34;%s\n&#34; .}}{{end}}&#39;</span>
</code></pre></div><pre><code>10.244.1.0/24
a00:100::/24
</code></pre><p>IPv4ブロックとIPv6ブロックがそれぞれ1つずつ割り当てられているはずです。</p>
<p>ノードが検出されたIPv4とIPv6のインターフェイスを持っていることを検証します。ノード名は自分のクラスター内の有効なノード名に置換してください。この例では、ノード名は<code>k8s-linuxpool1-34450317-0</code>になっています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes k8s-linuxpool1-34450317-0 -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .status.addresses}}{{printf &#34;%s: %s\n&#34; .type .address}}{{end}}&#39;</span>
</code></pre></div><pre><code>Hostname: k8s-linuxpool1-34450317-0
InternalIP: 10.240.0.5
InternalIP: 2001:1234:5678:9abc::5
</code></pre><h3 id=podアドレスの検証>Podアドレスの検証</h3>
<p>PodにIPv4とIPv6のアドレスが割り当てられていることを検証します。Podの名前は自分のクラスター内の有効なPodの名前と置換してください。この例では、Podの名前は<code>pod01</code>になっています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods pod01 -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .status.podIPs}}{{printf &#34;%s\n&#34; .ip}}{{end}}&#39;</span>
</code></pre></div><pre><code>10.244.1.4
a00:100::4
</code></pre><p>Downward APIを使用して、<code>status.podIPs</code>のfieldPath経由でPod IPを検証することもできます。次のスニペットは、Pod IPを<code>MY_POD_IPS</code>という名前の環境変数経由でコンテナ内に公開する方法を示しています。</p>
<pre><code>        env:
        - name: MY_POD_IPS
          valueFrom:
            fieldRef:
              fieldPath: status.podIPs
</code></pre><p>次のコマンドを実行すると、<code>MY_POD_IPS</code>環境変数の値をコンテナ内から表示できます。値はカンマ区切りのリストであり、PodのIPv4とIPv6のアドレスに対応しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it pod01 -- <span style=color:#a2f>set</span> | grep MY_POD_IPS
</code></pre></div><pre><code>MY_POD_IPS=10.244.1.4,a00:100::4
</code></pre><p>PodのIPアドレスは、コンテナ内の<code>/etc/hosts</code>にも書き込まれます。次のコマンドは、デュアルスタックのPod上で<code>/etc/hosts</code>に対してcatコマンドを実行します。出力を見ると、Pod用のIPv4およびIPv6のIPアドレスの両方が確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it pod01 -- cat /etc/hosts
</code></pre></div><pre><code># Kubernetes-managed hosts file.
127.0.0.1    localhost
::1    localhost ip6-localhost ip6-loopback
fe00::0    ip6-localnet
fe00::0    ip6-mcastprefix
fe00::1    ip6-allnodes
fe00::2    ip6-allrouters
10.244.1.4    pod01
a00:100::4    pod01
</code></pre><h2 id=serviceの検証>Serviceの検証</h2>
<p><code>.spec.isFamilyPolicy</code>を明示的に定義していない、以下のようなServiceを作成してみます。Kubernetesは最初に設定した<code>service-cluster-ip-range</code>の範囲からServiceにcluster IPを割り当てて、<code>.spec.ipFamilyPolicy</code>を<code>SingleStack</code>に設定します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/dual-stack-default-svc.yaml download=service/networking/dual-stack-default-svc.yaml><code>service/networking/dual-stack-default-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-default-svc-yaml')" title="Copy service/networking/dual-stack-default-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-default-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p><code>kubectl</code>を使ってServiceのYAMLを表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-service -o yaml
</code></pre></div><p>Serviceの<code>.spec.ipFamilyPolicy</code>は<code>SingleStack</code>に設定され、<code>.spec.clusterIP</code>にはkube-controller-manager上の<code>--service-cluster-ip-range</code>フラグで最初に設定した範囲から1つのIPv4アドレスが設定されているのがわかります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.217.164</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIPs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#666>10.0.217.164</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>SingleStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sessionAffinity</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ClusterIP<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div><p><code>.spec.ipFamilies</code>内の配列の1番目の要素に<code>IPv6</code>を明示的に指定した、次のようなServiceを作成してみます。Kubernetesは<code>service-cluster-ip-range</code>で設定したIPv6の範囲からcluster IPを割り当てて、<code>.spec.ipFamilyPolicy</code>を<code>SingleStack</code>に設定します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/dual-stack-ipfamilies-ipv6.yaml download=service/networking/dual-stack-ipfamilies-ipv6.yaml><code>service/networking/dual-stack-ipfamilies-ipv6.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-ipfamilies-ipv6-yaml')" title="Copy service/networking/dual-stack-ipfamilies-ipv6.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-ipfamilies-ipv6-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv6<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p><code>kubectl</code>を使ってServiceのYAMLを表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-service -o yaml
</code></pre></div><p>Serviceの<code>.spec.ipFamilyPolicy</code>は<code>SingleStack</code>に設定され、<code>.spec.clusterIP</code>には、kube-controller-manager上の<code>--service-cluster-ip-range</code>フラグで指定された最初の設定範囲から1つのIPv6アドレスが設定されているのがわかります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>fd00::5118<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIPs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- fd00::5118<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv6<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>SingleStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sessionAffinity</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ClusterIP<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div><p><code>.spec.ipFamiliePolicy</code>に<code>PreferDualStack</code>を明示的に指定した、次のようなServiceを作成してみます。Kubernetesは(クラスターでデュアルスタックを有効化しているため)IPv4およびIPv6のアドレスの両方を割り当て、<code>.spec.ClusterIPs</code>のリストから、<code>.spec.ipFamilies</code>配列の最初の要素のアドレスファミリーに基づいた<code>.spec.ClusterIP</code>を設定します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/dual-stack-preferred-svc.yaml download=service/networking/dual-stack-preferred-svc.yaml><code>service/networking/dual-stack-preferred-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-preferred-svc-yaml')" title="Copy service/networking/dual-stack-preferred-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-preferred-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>PreferDualStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p><code>kubectl get svc</code>コマンドは、<code>CLUSTER-IP</code>フィールドにプライマリーのIPだけしか表示しません。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>MyApp

NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>   AGE
my-service   ClusterIP   10.0.216.242   &lt;none&gt;        80/TCP    5s
</code></pre></div>
</div>
<p><code>kubectl describe</code>を使用して、ServiceがIPv4およびIPv6アドレスのブロックからcluster IPを割り当てられていることを検証します。その後、ServiceにIPアドレスとポートを使用してアクセスできることを検証することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe svc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>MyApp
</code></pre></div><pre><code>Name:              my-service
Namespace:         default
Labels:            app=MyApp
Annotations:       &lt;none&gt;
Selector:          app=MyApp
Type:              ClusterIP
IP Family Policy:  PreferDualStack
IP Families:       IPv4,IPv6
IP:                10.0.216.242
IPs:               10.0.216.242,fd00::af55
Port:              &lt;unset&gt;  80/TCP
TargetPort:        9376/TCP
Endpoints:         &lt;none&gt;
Session Affinity:  None
Events:            &lt;none&gt;
</code></pre><h3 id=デュアルスタックのloadbalancer-serviceを作成する>デュアルスタックのLoadBalancer Serviceを作成する</h3>
<p>クラウドプロバイダーがIPv6を有効化した外部ロードバランサーのプロビジョニングをサポートする場合、<code>.spec.ipFamilyPolicy</code>に<code>PreferDualStack</code>を指定し、<code>.spec.ipFamilies</code>の最初の要素を<code>IPv6</code>にして、<code>type</code>フィールドに<code>LoadBalancer</code>を指定したServiceを作成できます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/dual-stack-prefer-ipv6-lb-svc.yaml download=service/networking/dual-stack-prefer-ipv6-lb-svc.yaml><code>service/networking/dual-stack-prefer-ipv6-lb-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-prefer-ipv6-lb-svc-yaml')" title="Copy service/networking/dual-stack-prefer-ipv6-lb-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-prefer-ipv6-lb-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>PreferDualStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv6<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Serviceを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>MyApp
</code></pre></div><p>ServiceがIPv6アドレスブロックから<code>CLUSTER-IP</code>のアドレスと<code>EXTERNAL-IP</code>を割り当てられていることを検証します。その後、IPとポートを用いたServiceへのアクセスを検証することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME         TYPE           CLUSTER-IP   EXTERNAL-IP        PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>        AGE
my-service   LoadBalancer   fd00::7ebc   2603:1030:805::5   80:30790/TCP   35s
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5ab7bc7f14942c5c4b29d19f4a87271c>4.14 - GPUのスケジューリング</h1>
<div class=lead>クラスター内のノードのリソースとしてGPUを設定してスケジューリングします</div>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code>
</div>
<p>Kubernetesには、複数ノードに搭載されたAMDおよびNVIDIAのGPU(graphical processing unit)を管理するための<strong>実験的な</strong>サポートが含まれています。</p>
<p>このページでは、異なるバージョンのKubernetesを横断してGPUを使用する方法と、現時点での制限について説明します。</p>
<h2 id=デバイスプラグインを使用する>デバイスプラグインを使用する</h2>
<p>Kubernetesでは、GPUなどの特別なハードウェアの機能にPodがアクセスできるようにするために、<a class=glossary-tooltip title="Software extensions to let Pods access devices that need vendor-specific initialization or setup" data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/ target=_blank aria-label=デバイスプラグイン>デバイスプラグイン</a>が実装されています。</p>
<p>管理者として、ノード上に対応するハードウェアベンダーのGPUドライバーをインストールして、以下のような対応するGPUベンダーのデバイスプラグインを実行する必要があります。</p>
<ul>
<li><a href=#deploying-amd-gpu-device-plugin>AMD</a></li>
<li><a href=#deploying-nvidia-gpu-device-plugin>NVIDIA</a></li>
</ul>
<p>上記の条件を満たしていれば、Kubernetesは<code>amd.com/gpu</code>または<code>nvidia.com/gpu</code>をスケジュール可能なリソースとして公開します。</p>
<p>これらのGPUをコンテナから使用するには、<code>cpu</code>や<code>memory</code>をリクエストするのと同じように<code>&lt;vendor>.com/gpu</code>というリソースをリクエストするだけです。ただし、GPUを使用するときにはリソースのリクエストの指定方法にいくつか制限があります。</p>
<ul>
<li>GPUは<code>limits</code>セクションでのみ指定されることが想定されている。この制限は、次のことを意味します。
<ul>
<li>Kubernetesはデフォルトでlimitの値をrequestの値として使用するため、GPUの<code>requests</code>を省略して<code>limits</code>を指定できる。</li>
<li>GPUを<code>limits</code>と<code>requests</code>の両方で指定できるが、これら2つの値は等しくなければならない。</li>
<li>GPUの<code>limits</code>を省略して<code>requests</code>だけを指定することはできない。</li>
</ul>
</li>
<li>コンテナ(およびPod)はGPUを共有しない。GPUのオーバーコミットは起こらない。</li>
<li>各コンテナは1つ以上のGPUをリクエストできる。1つのGPUの一部だけをリクエストすることはできない。</li>
</ul>
<p>以下に例を示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># https://github.com/kubernetes/kubernetes/blob/v1.7.11/test/images/nvidia-cuda/Dockerfile</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 1 GPUをリクエストしています</span><span style=color:#bbb>
</span></code></pre></div><h3 id=deploying-amd-gpu-device-plugin>AMDのGPUデバイスプラグインをデプロイする</h3>
<p><a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>AMD公式のGPUデバイスプラグイン</a>には以下の要件があります。</p>
<ul>
<li>Kubernetesのノードに、AMDのGPUのLinuxドライバーがあらかじめインストール済みでなければならない。</li>
</ul>
<p>クラスターが起動して上記の要件が満たされれば、以下のコマンドを実行することでAMDのデバイスプラグインをデプロイできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://raw.githubusercontent.com/RadeonOpenCompute/k8s-device-plugin/v1.10/k8s-ds-amdgpu-dp.yaml
</code></pre></div><p>このサードパーティーのデバイスプラグインに関する問題は、<a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>RadeonOpenCompute/k8s-device-plugin</a>で報告できます。</p>
<h3 id=deploying-nvidia-gpu-device-plugin>NVIDIAのGPUデバイスプラグインをデプロイする</h3>
<p>現在、NVIDIAのGPU向けのデバイスプラグインの実装は2種類あります。</p>
<h4 id=nvidia公式のgpuデバイスプラグイン>NVIDIA公式のGPUデバイスプラグイン</h4>
<p><a href=https://github.com/NVIDIA/k8s-device-plugin>NVIDIA公式のGPUデバイスプラグイン</a>には以下の要件があります。</p>
<ul>
<li>Kubernetesのノードに、NVIDIAのドライバーがあらかじめインストール済みでなければならない。</li>
<li>Kubernetesのノードに、<a href=https://github.com/NVIDIA/nvidia-docker>nvidia-docker 2.0</a>があらかじめインストール済みでなければならない。</li>
<li>KubeletはコンテナランタイムにDockerを使用しなければならない。</li>
<li>runcの代わりにDockerの<a href=https://github.com/NVIDIA/k8s-device-plugin#preparing-your-gpu-nodes>デフォルトランタイム</a>として、<code>nvidia-container-runtime</code>を設定しなければならない。</li>
<li>NVIDIAのドライバーのバージョンが次の条件を満たさなければならない ~= 384.81。</li>
</ul>
<p>クラスターが起動して上記の要件が満たされれば、以下のコマンドを実行することでNVIDIAのデバイスプラグインがデプロイできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/1.0.0-beta4/nvidia-device-plugin.yml
</code></pre></div><p>このサードパーティーのデバイスプラグインに関する問題は、<a href=https://github.com/NVIDIA/k8s-device-plugin>NVIDIA/k8s-device-plugin</a>で報告できます。</p>
<h4 id=gceで使用されるnvidiaのgpuデバイスプラグイン>GCEで使用されるNVIDIAのGPUデバイスプラグイン</h4>
<p><a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators/tree/master/cmd/nvidia_gpu>GCEで使用されるNVIDIAのGPUデバイスプラグイン</a>は、nvidia-dockerを必要としないため、KubernetesのContainer Runtime Interface(CRI)と互換性のある任意のコンテナランタイムで動作するはずです。このデバイスプラグインは<a href=https://cloud.google.com/container-optimized-os/>Container-Optimized OS</a>でテストされていて、1.9以降ではUbuntu向けの実験的なコードも含まれています。</p>
<p>以下のコマンドを実行すると、NVIDIAのドライバーとデバイスプラグインをインストールできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># NVIDIAドライバーをContainer-Optimized OSにインストールする</span>
kubectl create -f https://raw.githubusercontent.com/GoogleCloudPlatform/container-engine-accelerators/stable/daemonset.yaml

<span style=color:#080;font-style:italic># NVIDIAドライバーをUbuntuにインストールする(実験的)</span>
kubectl create -f https://raw.githubusercontent.com/GoogleCloudPlatform/container-engine-accelerators/stable/nvidia-driver-installer/ubuntu/daemonset.yaml

<span style=color:#080;font-style:italic># デバイスプラグインをインストールする</span>
kubectl create -f https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.14/cluster/addons/device-plugins/nvidia-gpu/daemonset.yaml
</code></pre></div><p>このサードパーティーのデバイスプラグインの使用やデプロイに関する問題は、<a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators>GoogleCloudPlatform/container-engine-accelerators</a>で報告できます。</p>
<p>Googleは、GKE上でNVIDIAのGPUを使用するための<a href=https://cloud.google.com/kubernetes-engine/docs/how-to/gpus>手順</a>も公開しています。</p>
<h2 id=異なる種類のgpuを搭載するクラスター>異なる種類のGPUを搭載するクラスター</h2>
<p>クラスター上の別のノードに異なる種類のGPUが搭載されている場合、<a href=/docs/tasks/configure-pod-container/assign-pods-nodes/>NodeラベルとNodeセレクター</a>を使用することで、Podを適切なノードにスケジューリングできます。</p>
<p>以下に例を示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># アクセラレーターを搭載したノードにラベルを付けます。</span>
kubectl label nodes &lt;node-with-k80&gt; <span style=color:#b8860b>accelerator</span><span style=color:#666>=</span>nvidia-tesla-k80
kubectl label nodes &lt;node-with-p100&gt; <span style=color:#b8860b>accelerator</span><span style=color:#666>=</span>nvidia-tesla-p100
</code></pre></div><h2 id=node-labeller>自動的なNodeラベルの付加</h2>
<p>AMDのGPUデバイスを使用している場合、<a href=https://github.com/RadeonOpenCompute/k8s-device-plugin/tree/master/cmd/k8s-node-labeller>Node Labeller</a>をデプロイできます。Node Labellerは<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>の1種で、GPUデバイスのプロパティを持つノードに自動的にラベルを付けてくれます。</p>
<p>現在は、このコントローラーは以下のプロパティに基づいてラベルを追加できます。</p>
<ul>
<li>デバイスID(-device-id)</li>
<li>VRAMのサイズ(-vram)</li>
<li>SIMDの数(-simd-count)</li>
<li>Compute Unitの数(-cu-count)</li>
<li>ファームウェアとフィーチャーのバージョン(-firmware)</li>
<li>2文字の頭字語で表されたGPUファミリー(-family)
<ul>
<li>SI - Southern Islands</li>
<li>CI - Sea Islands</li>
<li>KV - Kaveri</li>
<li>VI - Volcanic Islands</li>
<li>CZ - Carrizo</li>
<li>AI - Arctic Islands</li>
<li>RV - Raven</li>
</ul>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe node cluster-node-23
</code></pre></div><pre><code>    Name:               cluster-node-23
    Roles:              &lt;none&gt;
    Labels:             beta.amd.com/gpu.cu-count.64=1
                        beta.amd.com/gpu.device-id.6860=1
                        beta.amd.com/gpu.family.AI=1
                        beta.amd.com/gpu.simd-count.256=1
                        beta.amd.com/gpu.vram.16G=1
                        beta.kubernetes.io/arch=amd64
                        beta.kubernetes.io/os=linux
                        kubernetes.io/hostname=cluster-node-23
    Annotations:        kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock
                        node.alpha.kubernetes.io/ttl: 0
    …
</code></pre><p>Node Labellerを使用すると、GPUの種類をPodのspec内で指定できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># https://github.com/kubernetes/kubernetes/blob/v1.7.11/test/images/nvidia-cuda/Dockerfile</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb> </span><span style=color:#080;font-style:italic># または nvidia-tesla-k80 など</span><span style=color:#bbb>
</span></code></pre></div><p>これにより、指定した種類のGPUを搭載したノードにPodがスケジューリングされることを保証できます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fdfb2a2cba62a1e624897eaebac0168e>4.15 - huge pageを管理する</h1>
<div class=lead>クラスター内のスケジュール可能なリソースとしてhuge pageの設定と管理を行います。</div>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<p>Kubernetesでは、事前割り当てされたhuge pageをPod内のアプリケーションに割り当てたり利用したりすることをサポートしています。このページでは、ユーザーがhuge pageを利用できるようにする方法について説明します。</p>
<h2 id=始める前に>始める前に</h2>
<ol>
<li>Kubernetesのノードがhuge pageのキャパシティを報告するためには、ノード上でhuge pageを事前割り当てしておく必要があります。1つのノードでは複数のサイズのhuge pageが事前割り当てできます。</li>
</ol>
<p>ノードは、すべてのhuge pageリソースを、スケジュール可能なリソースとして自動的に探索・報告してくれます。</p>
<h2 id=api>API</h2>
<p>huge pageはコンテナレベルのリソース要求で<code>hugepages-&lt;size></code>という名前のリソースを指定することで利用できます。ここで、<code>&lt;size></code>は、特定のノード上でサポートされている整数値を使った最も小さなバイナリ表記です。たとえば、ノードが2048KiBと1048576KiBのページサイズをサポートしている場合、ノードはスケジュール可能なリソースとして、<code>hugepages-2Mi</code>と<code>hugepages-1Gi</code>の2つのリソースを公開します。CPUやメモリとは違い、huge pageはオーバーコミットをサポートしません。huge pageリソースをリクエストするときには、メモリやCPUリソースを同時にリクエストしなければならないことに注意してください。</p>
<p>1つのPodのspec内に書くことで、Podから複数のサイズのhuge pageを利用することもできます。その場合、すべてのボリュームマウントで<code>medium: HugePages-&lt;hugepagesize></code>という表記を使う必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>huge-pages-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:latest<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- inf<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/hugepages-2Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-2mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/hugepages-1Gi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-1gi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hugepages-2Mi</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hugepages-1Gi</span>:<span style=color:#bbb> </span>2Gi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-2mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>medium</span>:<span style=color:#bbb> </span>HugePages-2Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-1gi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>medium</span>:<span style=color:#bbb> </span>HugePages-1Gi<span style=color:#bbb>
</span></code></pre></div><p>Podで1種類のサイズのhuge pageをリクエストするときだけは、<code>medium: HugePages</code>という表記を使うこともできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>huge-pages-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:latest<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- inf<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/hugepages<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hugepages-2Mi</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>medium</span>:<span style=color:#bbb> </span>HugePages<span style=color:#bbb>
</span></code></pre></div><ul>
<li>huge pageのrequestsはlimitsと等しくなければなりません。limitsを指定した場合にはこれがデフォルトですが、requestsを指定しなかった場合にはデフォルトではありません。</li>
<li>huge pageはコンテナのスコープで隔離されるため、各コンテナにはそれぞれのcgroupサンドボックスの中でcontainer specでリクエストされた通りのlimitが設定されます。</li>
<li>huge pageベースのEmptyDirボリュームは、Podがリクエストしたよりも大きなサイズのページメモリーを使用できません。</li>
<li><code>shmget()</code>に<code>SHM_HUGETLB</code>を指定して取得したhuge pageを使用するアプリケーションは、<code>/proc/sys/vm/hugetlb_shm_group</code>に一致する補助グループ(supplemental group)を使用して実行する必要があります。</li>
<li>namespace内のhuge pageの使用量は、ResourceQuotaに対して<code>cpu</code>や<code>memory</code>のような他の計算リソースと同じように<code>hugepages-&lt;size></code>というトークンを使用することで制御できます。</li>
<li>複数のサイズのhuge pageのサポートはフィーチャーゲートによる設定が必要です。<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>と<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a>上で、<code>HugePageStorageMediumSize</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を使用すると有効にできます(<code>--feature-gates=HugePageStorageMediumSize=true</code>)。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-68ec2370d0409cc27325be36693f9368>5 - チュートリアル</h1>
<p>本セクションにはチュートリアルが含まれています。チュートリアルでは、単一の<a href=/docs/tasks/>タスク</a>よりも大きな目標を達成する方法を示します。通常、チュートリアルにはいくつかのセクションがあり、各セクションには一連のステップがあります。各チュートリアルを進める前に、後で参照できるように<a href=/docs/reference/glossary/>標準化された用語集</a>ページをブックマークしておくことをお勧めします。</p>
<h2 id=基本>基本</h2>
<ul>
<li>
<p><a href=/ja/docs/tutorials/kubernetes-basics/>Kubernetesの基本</a>は、Kubernetesのシステムを理解し、基本的な機能を試すのに役立つ、詳細な対話式のチュートリアルです。</p>
</li>
<li>
<p><a href=https://www.edx.org/course/introduction-kubernetes-linuxfoundationx-lfs158x#>Introduction to Kubernetes (edX)</a></p>
</li>
<li>
<p><a href=/ja/docs/tutorials/hello-minikube/>Hello Minikube</a></p>
</li>
</ul>
<h2 id=設定>設定</h2>
<ul>
<li><a href=/docs/tutorials/configuration/configure-redis-using-configmap/>ConfigMapを用いたRedisの設定</a></li>
</ul>
<h2 id=ステートレスアプリケーション>ステートレスアプリケーション</h2>
<ul>
<li>
<p><a href=/ja/docs/tutorials/stateless-application/expose-external-ip-address/>クラスター内のアプリケーションにアクセスするために外部IPアドレスを公開する</a></p>
</li>
<li>
<p><a href=/docs/tutorials/stateless-application/guestbook/>例: Redisを使用したPHPゲストブックアプリケーションのデプロイ</a></p>
</li>
</ul>
<h2 id=ステートフルアプリケーション>ステートフルアプリケーション</h2>
<ul>
<li>
<p><a href=/docs/tutorials/stateful-application/basic-stateful-set/>StatefulSetの基本</a></p>
</li>
<li>
<p><a href=/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/>例: 永続ボリュームを使ったWordPressとMySQLのデプロイ</a></p>
</li>
<li>
<p><a href=/docs/tutorials/stateful-application/cassandra/>例: Stateful Setsを使ったCassandraのデプロイ</a></p>
</li>
<li>
<p><a href=/docs/tutorials/stateful-application/zookeeper/>CP(一貫性＋分断耐性)分散システムZooKeeperの実行</a></p>
</li>
</ul>
<h2 id=クラスター>クラスター</h2>
<ul>
<li>
<p><a href=/docs/tutorials/clusters/apparmor/>AppArmor</a></p>
</li>
<li>
<p><a href=/docs/tutorials/clusters/seccomp/>seccomp</a></p>
</li>
</ul>
<h2 id=サービス>サービス</h2>
<ul>
<li><a href=/docs/tutorials/services/source-ip/>Source IPを使う</a></li>
</ul>
<h2 id=次の項目>次の項目</h2>
<p>チュートリアルのページタイプについての情報は、<a href=/docs/contribute/style/page-content-types/>Content Page Types</a>を参照してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5e3051fff9e84735871d9fb5e7b93f33>5.1 - Hello Minikube</h1>
<p>このチュートリアルでは、<a href=/ja/docs/setup/learning-environment/minikube>Minikube</a>とKatacodaを使用して、Kubernetes上でサンプルアプリケーションを動かす方法を紹介します。Katacodaはブラウザで無償のKubernetes環境を提供します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <a href=https://minikube.sigs.k8s.io/docs/start/>Minikubeをローカルにインストール</a>している場合もこのチュートリアルを進めることが可能です。
</div>
<h2 id=目標>目標</h2>
<ul>
<li>Minikubeへのサンプルアプリケーションのデプロイ</li>
<li>アプリケーションの実行</li>
<li>アプリケーションログの確認</li>
</ul>
<h2 id=始める前に>始める前に</h2>
<p>このチュートリアルはNGINXを利用してすべての要求をエコーバックするコンテナイメージを提供します。</p>
<h2 id=minikubeクラスターの作成>Minikubeクラスターの作成</h2>
<ol>
<li>
<p><strong>Launch Terminal</strong> をクリックしてください</p>
<script defer src=https://katacoda.com/embed.js></script>
<button class=button onclick=window.katacoda.init()>Launch Terminal</button>
</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Minikubeをローカルにインストール済みの場合は、<code>minikube start</code>を実行してください。
</div>
<ol start=2>
<li>
<p>ブラウザーでKubernetesダッシュボードを開いてください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube dashboard
</code></pre></div></li>
<li>
<p>Katacoda環境のみ：ターミナルペーン上部の+ボタンをクリックしてから <strong>Select port to view on Host 1</strong> をクリックしてください。</p>
</li>
<li>
<p>Katacoda環境のみ：<code>30000</code>を入力し、<strong>Display Port</strong>をクリックしてください。</p>
</li>
</ol>
<h2 id=deploymentの作成>Deploymentの作成</h2>
<p>Kubernetesの<a href=/ja/docs/concepts/workloads/pods/><em>Pod</em></a> は、コンテナの管理やネットワーキングの目的でまとめられた、1つ以上のコンテナのグループです。このチュートリアルのPodがもつコンテナは1つのみです。Kubernetesの <a href=/ja/docs/concepts/workloads/controllers/deployment/><em>Deployment</em></a> はPodの状態を確認し、Podのコンテナが停止した場合には再起動します。DeploymentはPodの作成やスケールを管理するために推奨される方法(手段)です。</p>
<ol>
<li>
<p><code>kubectl create</code> コマンドを使用してPodを管理するDeploymentを作成してください。Podは提供されたDockerイメージを元にコンテナを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment hello-node --image<span style=color:#666>=</span>k8s.gcr.io/echoserver:1.4
</code></pre></div></li>
<li>
<p>Deploymentを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployments
</code></pre></div><p>出力は下記のようになります:</p>
<pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
hello-node   1/1     1            1           1m
</code></pre></li>
<li>
<p>Podを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>出力は下記のようになります:</p>
<pre><code>NAME                          READY     STATUS    RESTARTS   AGE
hello-node-5f76cf6ccf-br9b5   1/1       Running   0          1m
</code></pre></li>
<li>
<p>クラスターイベントを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events
</code></pre></div></li>
<li>
<p><code>kubectl</code> で設定を確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>kubectl</code>コマンドの詳細な情報は<a href=/ja/docs/reference/kubectl/overview/>kubectl overview</a>を参照してください。
</div>
<h2 id=serviceの作成>Serviceの作成</h2>
<p>通常、PodはKubernetesクラスター内部のIPアドレスからのみアクセスすることができます。<code>hello-node</code>コンテナをKubernetesの仮想ネットワークの外部からアクセスするためには、Kubernetesの<a href=/ja/docs/concepts/services-networking/service/><em>Service</em></a>としてPodを公開する必要があります。</p>
<ol>
<li>
<p><code>kubectl expose</code> コマンドを使用してPodをインターネットに公開します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment hello-node --type<span style=color:#666>=</span>LoadBalancer --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</code></pre></div><p><code>--type=LoadBalancer</code>フラグはServiceをクラスター外部に公開したいことを示しています。</p>
</li>
<li>
<p>作成したServiceを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get services
</code></pre></div><p>出力は下記のようになります:</p>
<pre><code>NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
hello-node   LoadBalancer   10.108.144.78   &lt;pending&gt;     8080:30369/TCP   21s
kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          23m
</code></pre><p>ロードバランサーをサポートするクラウドプロバイダーでは、Serviceにアクセスするための外部IPアドレスが提供されます。
Minikube では、<code>LoadBalancer</code>タイプは<code>minikube service</code>コマンドを使用した接続可能なServiceを作成します。</p>
</li>
<li>
<p>次のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube service hello-node
</code></pre></div></li>
<li>
<p>Katacoda環境のみ：ターミナル画面上部の+ボタンをクリックして <strong>Select port to view on Host 1</strong> をクリックしてください。</p>
</li>
<li>
<p>Katacoda環境のみ：<code>8080</code>の反対側のService出力に、5桁のポート番号が表示されます。このポート番号はランダムに生成されるため、ここで使用するポート番号と異なる場合があります。ポート番号テキストボックスに番号を入力し、ポートの表示をクリックしてください。前の例の場合は、<code>30369</code>と入力します。</p>
<p>アプリケーションとその応答が表示されるブラウザーウィンドウが開きます。</p>
</li>
</ol>
<h2 id=アドオンの有効化>アドオンの有効化</h2>
<p>Minikubeはビルトインの<a class=glossary-tooltip title="Resources that extend the functionality of Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=アドオン>アドオン</a>があり、有効化、無効化、あるいはローカルのKubernetes環境に公開することができます。</p>
<ol>
<li>
<p>サポートされているアドオンをリストアップします:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube addons list
</code></pre></div><p>出力は下記のようになります:</p>
<pre><code>addon-manager: enabled
dashboard: enabled
default-storageclass: enabled
efk: disabled
freshpod: disabled
gvisor: disabled
helm-tiller: disabled
ingress: disabled
ingress-dns: disabled
logviewer: disabled
metrics-server: disabled
nvidia-driver-installer: disabled
nvidia-gpu-device-plugin: disabled
registry: disabled
registry-creds: disabled
storage-provisioner: enabled
storage-provisioner-gluster: disabled
</code></pre></li>
<li>
<p>ここでは例として<code>metrics-server</code>のアドオンを有効化します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube addons <span style=color:#a2f>enable</span> metrics-server
</code></pre></div><p>出力は下記のようになります:</p>
<pre><code>metrics-server was successfully enabled
</code></pre></li>
<li>
<p>作成されたPodとサービスを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod,svc -n kube-system
</code></pre></div><p>出力:</p>
<pre><code>NAME                                        READY     STATUS    RESTARTS   AGE
pod/coredns-5644d7b6d9-mh9ll                1/1       Running   0          34m
pod/coredns-5644d7b6d9-pqd2t                1/1       Running   0          34m
pod/metrics-server-67fb648c5                1/1       Running   0          26s
pod/etcd-minikube                           1/1       Running   0          34m
pod/influxdb-grafana-b29w8                  2/2       Running   0          26s
pod/kube-addon-manager-minikube             1/1       Running   0          34m
pod/kube-apiserver-minikube                 1/1       Running   0          34m
pod/kube-controller-manager-minikube        1/1       Running   0          34m
pod/kube-proxy-rnlps                        1/1       Running   0          34m
pod/kube-scheduler-minikube                 1/1       Running   0          34m
pod/storage-provisioner                     1/1       Running   0          34m

NAME                           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE
service/metrics-server         ClusterIP   10.96.241.45    &lt;none&gt;        80/TCP              26s
service/kube-dns               ClusterIP   10.96.0.10      &lt;none&gt;        53/UDP,53/TCP       34m
service/monitoring-grafana     NodePort    10.99.24.54     &lt;none&gt;        80:30002/TCP        26s
service/monitoring-influxdb    ClusterIP   10.111.169.94   &lt;none&gt;        8083/TCP,8086/TCP   26s
</code></pre></li>
<li>
<p><code>metrics-server</code>を無効化します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube addons disable metrics-server
</code></pre></div><p>出力は下記のようになります:</p>
<pre><code>metrics-server was successfully disabled
</code></pre></li>
</ol>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>クラスターに作成したリソースをクリーンアップします:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete service hello-node
kubectl delete deployment hello-node
</code></pre></div><p>(オプション)Minikubeの仮想マシン(VM)を停止します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube stop
</code></pre></div><p>(オプション)MinikubeのVMを削除します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube delete
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deploymentオブジェクト</a>について学ぶ.</li>
<li><a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>アプリケーションのデプロイ</a>について学ぶ.</li>
<li><a href=/ja/docs/concepts/services-networking/service/>Serviceオブジェクト</a>について学ぶ.</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3c83f53a74233ace9b289ac5e24c3e62>5.2 - Kubernetesの基本を学ぶ</h1><!doctype html>
<html lang=ja>
<body>
<link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet>
<div class=layout id=top>
<main class=content>
<div class=row>
<div class=col-md-9>
<h2>Kubernetesの基本</h2>
<p>このチュートリアルでは、Kubernetesクラスターオーケストレーションシステムの基本について学びます。各モジュールには、Kubernetesの主な機能と概念に関する背景情報と、インタラクティブなオンラインチュートリアルが含まれています。これらの対話型チュートリアルでは、簡単なクラスターとそのコンテナ化されたアプリケーションを自分で管理できます。</p>
<p>この対話型のチュートリアルでは、以下のことを学ぶことができます:</p>
<ul>
<li>コンテナ化されたアプリケーションをクラスターにデプロイ</li>
<li>Deploymentのスケーリング</li>
<li>新しいソフトウェアのバージョンでコンテナ化されたアプリケーションをアップデート</li>
<li>コンテナ化されたアプリケーションのデバッグ</li>
</ul>
<p>このチュートリアルでは、Katacodaを使用して、Webブラウザ上の仮想ターミナルでMinikubeを実行します。Minikubeは、どこでも実行できるKubernetesの小規模なローカル環境です。ソフトウェアをインストールしたり、何かを設定したりする必要はありません。各対話型チュートリアルは、Webブラウザ自体の上で直接実行されます</p>
</div>
</div>
<br>
<div class=row>
<div class=col-md-9>
<h2>Kubernetesはどんなことができるの？</h2>
<p>モダンなWebサービスでは、ユーザはアプリケーションが24時間365日利用可能であることを期待しており、開発者はそれらのアプリケーションの新しいバージョンを1日に数回デプロイすることを期待しています。コンテナ化は、パッケージソフトウェアがこれらの目標を達成するのを助け、アプリケーションをダウンタイムなしで簡単かつ迅速にリリース、アップデートできるようにします。Kubernetesを使用すると、コンテナ化されたアプリケーションをいつでもどこでも好きなときに実行できるようになり、それらが機能するために必要なリソースとツールを見つけやすくなります。Kubernetesは、コンテナオーケストレーションにおけるGoogleのこれまでの経験と、コミュニティから得られた最善のアイデアを組み合わせて設計された、プロダクションレディなオープンソースプラットフォームです。</p>
</div>
</div>
<div id=basics-modules class=content__modules>
<h2>Kubernetesの基本モジュール</h2>
<div class=row>
<div class=col-md-12>
<div class=row>
<div class=col-md-4>
<div class=thumbnail>
<a href=/ja/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_01.svg?v=1469803628347" alt></a>
<div class=caption>
<a href=/ja/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/><h5>1. Kubernetesクラスターの作成</h5></a>
</div>
</div>
</div>
<div class=col-md-4>
<div class=thumbnail>
<a href=/ja/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_02.svg?v=1469803628347" alt></a>
<div class=caption>
<a href=/ja/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/><h5>2. アプリケーションのデプロイ</h5></a>
</div>
</div>
</div>
<div class=col-md-4>
<div class=thumbnail>
<a href=/ja/docs/tutorials/kubernetes-basics/explore/explore-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_03.svg?v=1469803628347" alt></a>
<div class=caption>
<a href=/ja/docs/tutorials/kubernetes-basics/explore/explore-intro/><h5>3. デプロイしたアプリケーションの探索</h5></a>
</div>
</div>
</div>
</div>
</div>
<div class=col-md-12>
<div class=row>
<div class=col-md-4>
<div class=thumbnail>
<a href=/ja/docs/tutorials/kubernetes-basics/expose/expose-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_04.svg?v=1469803628347" alt></a>
<div class=caption>
<a href=/ja/docs/tutorials/kubernetes-basics/expose/expose-intro/><h5>4. アプリケーションの公開</h5></a>
</div>
</div>
</div>
<div class=col-md-4>
<div class=thumbnail>
<a href=/ja/docs/tutorials/kubernetes-basics/scale/scale-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_05.svg?v=1469803628347" alt></a>
<div class=caption>
<a href=/ja/docs/tutorials/kubernetes-basics/scale/scale-intro/><h5>5. アプリケーションのスケールアップ</h5></a>
</div>
</div>
</div>
<div class=col-md-4>
<div class=thumbnail>
<a href=/ja/docs/tutorials/kubernetes-basics/update/update-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_06.svg?v=1469803628347" alt></a>
<div class=caption>
<a href=/ja/docs/tutorials/kubernetes-basics/update/update-intro/><h5>6. アプリケーションのアップデート</h5></a>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class=row>
<div class=col-md-12>
<a class="btn btn-lg btn-success" href=/ja/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/ role=button>チュートリアルを始める<span class=btn__next>›</span></a>
</div>
</div>
</main>
</div>
</body>
</html>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7df66040311338d6098ebeab43ba9afb>5.2.1 - クラスターの作成</h1>
</div>
<div class=td-content>
<h1 id=pg-de49316920e97a82e36763cb66781ada>5.2.1.1 - Minikubeを使ったクラスターの作成</h1><!doctype html>
<html lang=ja>
<body>
<link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet>
<div class=layout id=top>
<main class=content>
<div class=row>
<div class=col-md-8>
<h3>目標</h3>
<ul>
<li>Kubernetesクラスターとは何かを学ぶ</li>
<li>Minikubeとは何かを学ぶ</li>
<li>Kubernetesクラスターを、オンラインのターミナルを使って動かす</li>
</ul>
</div>
<div class=col-md-8>
<h3>Kubernetesクラスター</h3>
<p>
<b>Kubernetesは、単一のユニットとして機能するように接続された、可用性の高いコンピュータのクラスターをまとめあげます。</b>Kubernetesの抽象化により、コンテナ化されたアプリケーションを個々のマシンに特に結び付けることなくクラスターにデプロイできます。この新しいデプロイモデルを利用するには、アプリケーションを個々のホストから切り離す方法でアプリケーションをパッケージ化(つまり、コンテナ化)する必要があります。コンテナ化されたアプリケーションは、アプリケーションがホストに深く統合されたパッケージとして特定のマシンに直接インストールされていた従来のデプロイモデルよりも柔軟で、より迅速に利用可能です。<b>Kubernetesはより効率的な方法で、クラスター全体のアプリケーションコンテナの配布とスケジューリングを自動化します。</b>Kubernetesはオープンソースのプラットフォームであり、プロダクションレディです。
</p>
<p>Kubernetesクラスターは以下の2種類のリソースで構成されています:
<ul>
<li><b>マスター</b>がクラスターを管理する</li>
<li><b>ノード</b>がアプリケーションを動かすワーカーとなる</li>
</ul>
</p>
</div>
<div class=col-md-4>
<div class="content__box content__box_lined">
<h3>まとめ:</h3>
<ul>
<li>Kubernetesクラスター</li>
<li>Minikube</li>
</ul>
</div>
<div class="content__box content__box_fill">
<p><i>
Kubernetesは、コンピュータクラスター内およびコンピュータクラスター間でのアプリケーションコンテナの配置(スケジューリング)および実行を調整する、プロダクショングレードのオープンソースプラットフォームです。
</i></p>
</div>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<h2 style=color:#3771e3>クラスターダイアグラム</h2>
</div>
</div>
<div class=row>
<div class=col-md-8>
<p><img src=/docs/tutorials/kubernetes-basics/public/images/module_01_cluster.svg></p>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<p><b>マスターはクラスターの管理を担当します。</b>マスターは、アプリケーションのスケジューリング、望ましい状態の維持、アプリケーションのスケーリング、新しい更新のロールアウトなど、クラスター内のすべての動作をまとめあげます。</p>
<p><b>ノードは、Kubernetesクラスターのワーカーマシンとして機能するVMまたは物理マシンです。</b>各ノードにはKubeletがあり、これはノードを管理し、Kubernetesマスターと通信するためのエージェントです。ノードにはDockerやrktなどのコンテナ操作を処理するためのツールもあるはずです。プロダクションのトラフィックを処理するKubernetesクラスターには、最低3つのノードが必要です。</p>
</div>
<div class=col-md-4>
<div class="content__box content__box_fill">
<p><i>マスターは実行中のアプリケーションをホストするために使用されるノードとクラスターを管理します。</i></p>
</div>
</div>
</div>
<div class=row>
<div class=col-md-8>
<p>Kubernetesにアプリケーションをデプロイするときは、マスターにアプリケーションコンテナを起動するように指示します。マスターはコンテナがクラスターのノードで実行されるようにスケジュールします。<b>ノードは、マスターが公開している<a href=/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>を使用してマスターと通信します。</b>エンドユーザーは、Kubernetes APIを直接使用して対話することもできます。</p>
<p>Kubernetesクラスターは、物理マシンまたは仮想マシンのどちらにも配置できます。Kubernetes開発を始めるためにMinikubeを使うことができます。Minikubeは、ローカルマシン上にVMを作成し、1つのノードのみを含む単純なクラスターをデプロイする軽量なKubernetes実装です。Minikubeは、Linux、macOS、およびWindowsシステムで利用可能です。Minikube CLIは、起動、停止、ステータス、削除など、クラスターを操作するための基本的なブートストラップ操作を提供します。ただし、このチュートリアルでは、Minikubeがプリインストールされた状態で提供されているオンラインのターミナルを使用します。</p>
<p>Kubernetesが何であるかがわかったので、オンラインチュートリアルに行き、最初のクラスターを動かしましょう！</p>
</div>
</div>
<br>
<div class=row>
<div class=col-md-12>
<a class="btn btn-lg btn-success" href=/ja/docs/tutorials/kubernetes-basics/create-cluster/cluster-interactive/ role=button>対話型のチュートリアルを始める <span class=btn__next>›</span></a>
</div>
</div>
</main>
</div>
</body>
</html>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-323b75976001e8dfe35d67d61bc74f1a>5.2.1.2 - 対話型チュートリアル - クラスターの作成</h1><!doctype html>
<html lang=ja>
<body>
<link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet>
<link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet>
<script src=https://katacoda.com/embed.js></script>
<div class=layout id=top>
<main class="content katacoda-content">
<div class=katacoda>
<div class=katacoda__alert>
ターミナルを使うにはスクリーンが狭い場合は、PCまたはタブレットをお使いください
</div>
<div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/1 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div>
</div>
<div class=row>
<div class=col-md-12>
<a class="btn btn-lg btn-success" href=/ja/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/ role=button>モジュール2へ進む<span class=btn__next>›</span></a>
</div>
</div>
</main>
</div>
</body>
</html>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-76d78b3fba507f7ed33cef14a35b631d>5.2.2 - アプリケーションのデプロイ</h1>
</div>
<div class=td-content>
<h1 id=pg-2b1bba431989008c7493109a0f049ece>5.2.2.1 - kubectlを使ったDeploymentの作成</h1><!doctype html>
<html lang=ja>
<body>
<link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet>
<div class=layout id=top>
<main class=content>
<div class=row>
<div class=col-md-8>
<h3>目標</h3>
<ul>
<li>アプリケーションのデプロイについて学ぶ</li>
<li>kubectlを使って、Kubernetes上にはじめてのアプリケーションをデプロイする</li>
</ul>
</div>
<div class=col-md-8>
<h3>Kubernetes Deployments</h3>
<p>
実行中のKubernetesクラスターを入手すると、その上にコンテナ化アプリケーションをデプロイすることができます。そのためには、Kubernetesの<b>Deployment</b> の設定を作成します。DeploymentはKubernetesにあなたのアプリケーションのインスタンスを作成し、更新する方法を指示します。Deploymentを作成すると、KubernetesマスターはDeployment内に含まれるアプリケーションインスタンスをクラスター内の個々のノードで実行するようにスケジュールします。
</p>
<p>アプリケーションインスタンスが作成されると、Kubernetes Deploymentコントローラーは、それらのインスタンスを継続的に監視します。インスタンスをホストしているノードが停止、削除された場合、Deploymentコントローラーはそのインスタンスをクラスター内の別のノード上のインスタンスと置き換えます。<b>これは、マシンの故障やメンテナンスに対処するためのセルフヒーリングの仕組みを提供しています。</b></p>
<p>オーケストレーションが入る前の世界では、インストールスクリプトを使用してアプリケーションを起動することはよくありましたが、マシン障害が発生した場合に復旧する事はできませんでした。アプリケーションのインスタンスを作成し、それらをノード間で実行し続けることで、Kubernetes Deploymentsはアプリケーションの管理に根本的に異なるアプローチを提供します。</p>
</div>
<div class=col-md-4>
<div class="content__box content__box_lined">
<h3>まとめ:</h3>
<ul>
<li>Deployments</li>
<li>kubectl</li>
</ul>
</div>
<div class="content__box content__box_fill">
<p><i>
Deploymentは、アプリケーションのインスタンスを作成および更新する責務があります。
</i></p>
</div>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<h2 style=color:#3771e3>Kubernetes上にはじめてのアプリケーションをデプロイする</h2>
</div>
</div>
<div class=row>
<div class=col-md-8>
<p><img src=/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg></p>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<p>Kubernetesのコマンドラインインターフェイスである<b>kubectl</b>を使用して、Deploymentを作成、管理できます。kubectlはKubernetes APIを使用してクラスターと対話します。このモジュールでは、Kubernetesクラスターでアプリケーションを実行するDeploymentを作成するために必要な、最も一般的なkubectlコマンドについて学びます。</p>
<p>Deploymentを作成するときは、アプリケーションのコンテナイメージと実行するレプリカの数を指定する必要があります。Deploymentを更新することで、あとでその情報を変更できます。チュートリアルのモジュール<a href=/ja/docs/tutorials/kubernetes-basics/scale/scale-intro/>5</a>と<a href=/ja/docs/tutorials/kubernetes-basics/update/update-intro/>6</a>では、Deploymentをどのようにスケール、更新できるかについて説明します。</p>
</div>
<div class=col-md-4>
<div class="content__box content__box_fill">
<p><i>Kubernetesにデプロイするには、アプリケーションをサポートされているコンテナ形式のいずれかにパッケージ化する必要があります。</i></p>
</div>
</div>
</div>
<div class=row>
<div class=col-md-8>
<p>最初のDeploymentには、DockerコンテナにパッケージされたNode.jsアプリケーションを使用します。(まだNode.jsアプリケーションを作成してデプロイしていない場合、<a href=/ja/docs/tutorials/hello-minikube/>Hello Minikubeチュートリアル</a>の通りにやってみましょう。)</p>
<p>Deploymentが何であるかがわかったので、オンラインチュートリアルに行き、最初のアプリケーションをデプロイしましょう！</p>
</div>
</div>
<br>
<div class=row>
<div class=col-md-12>
<a class="btn btn-lg btn-success" href=/ja/docs/tutorials/kubernetes-basics/deploy-app/deploy-interactive/ role=button>対話型のチュートリアルを始める <span class=btn__next>›</span></a>
</div>
</div>
</main>
</div>
</body>
</html>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f8997ec143b382fa6c9621941ea62ca3>5.2.2.2 - 対話型チュートリアル - アプリケーションのデプロイ</h1><!doctype html>
<html lang=ja>
<body>
<link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet>
<link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet>
<script src=https://katacoda.com/embed.js></script>
<div class=layout id=top>
<main class="content katacoda-content">
<div class=row>
<div class=col-md-12>
<p>
Podは、Kubernetesアプリケーションの基本的な実行単位です。各Podは、クラスターで実行されているワークロードの一部を表します。<a href=/ja/docs/concepts/workloads/pods/>Podの詳細はこちらです</a>。
</p>
</div>
</div>
<br>
<div class=katacoda>
<div class=katacoda__alert>
ターミナルを使うには、PCまたはタブレットをお使いください
</div>
<div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/7 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px>
</div>
</div>
<div class=row>
<div class=col-md-12>
<a class="btn btn-lg btn-success" href=/ja/docs/tutorials/kubernetes-basics/explore/explore-intro/ role=button>モジュール3へ進む<span class=btn__next>›</span></a>
</div>
</div>
</main>
</div>
</body>
</html>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-250d620a73ec8be7e1f7d835574c4596>5.2.3 - アプリケーションの探索</h1>
</div>
<div class=td-content>
<h1 id=pg-2771f4e8c45321b17cb0114a2d266453>5.2.3.1 - Podとノードについて</h1><!doctype html>
<html lang=ja>
<body>
<link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet>
<div class=layout id=top>
<main class=content>
<div class=row>
<div class=col-md-8>
<h3>目標</h3>
<ul>
<li>KubernetesのPodについて学ぶ</li>
<li>Kubernetesのノードについて学ぶ</li>
<li>デプロイされたアプリケーションのトラブルシューティング</li>
</ul>
</div>
<div class=col-md-8>
<h2>Kubernetes Pod</h2>
<p>モジュール<a href=/ja/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/>2</a>でDeploymentを作成したときに、KubernetesはアプリケーションインスタンスをホストするためのPodを作成しました。Podは、1つ以上のアプリケーションコンテナ(Dockerなど)のグループとそれらのコンテナの共有リソースを表すKubernetesの抽象概念です。 Podには以下のものが含まれます:</p>
<ul>
<li>共有ストレージ(ボリューム)</li>
<li>ネットワーキング(クラスターに固有のIPアドレス)</li>
<li>コンテナのイメージバージョンや使用するポートなどの、各コンテナをどう動かすかに関する情報</li>
</ul>
<p>Podは、アプリケーション固有の「論理ホスト」をモデル化し、比較的密接に結合されたさまざまなアプリケーションコンテナを含むことができます。 たとえば、Podには、Node.jsアプリケーションを含むコンテナと、Node.js Webサーバによって公開されるデータを供給する別のコンテナの両方を含めることができます。Pod内のコンテナはIPアドレスとポートスペースを共有し、常に同じ場所に配置され、同じスケジュールに入れられ、同じノード上の共有コンテキストで実行されます。</p>
<p>Podは、Kubernetesプラットフォームの原子単位です。 Kubernetes上にDeploymentを作成すると、そのDeploymentはその中にコンテナを持つPodを作成します(コンテナを直接作成するのではなく)。 各Podは、スケジュールされているノードに関連付けられており、終了(再起動ポリシーに従って)または削除されるまでそこに残ります。 ノードに障害が発生した場合、同じPodがクラスター内の他の使用可能なノードにスケジュールされます。</p>
</div>
<div class=col-md-4>
<div class="content__box content__box_lined">
<h3>まとめ:</h3>
<ul>
<li>Pod</li>
<li>ノード</li>
<li>kubectlの主要なコマンド</li>
</ul>
</div>
<div class="content__box content__box_fill">
<p><i>
Podは1つ以上のアプリケーションコンテナ(Dockerなど)のグループであり、共有ストレージ(ボリューム)、IPアドレス、それらの実行方法に関する情報が含まれています。
</i></p>
</div>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<h2 style=color:#3771e3>Podの概要</h2>
</div>
</div>
<div class=row>
<div class=col-md-8>
<p><img src=/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg></p>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<h2>ノード</h2>
<p>Podは常に<b>ノード</b>上で動作します。ノードはKubernetesではワーカーマシンであり、クラスターによって仮想、物理マシンのどちらであってもかまいません。各ノードはマスターによって管理されます。ノードは複数のPodを持つことができ、Kubernetesマスターはクラスター内のノード間でPodのスケジュールを自動的に処理します。マスターの自動スケジューリングは各ノードで利用可能なリソースを考慮に入れます。</p>
<p>すべてのKubernetesノードでは少なくとも以下のものが動作します。</p>
<ul>
<li>Kubelet: Kubernetesマスターとノード間の通信を担当するプロセス。マシン上で実行されているPodとコンテナを管理します。</li>
<li>レジストリからコンテナイメージを取得し、コンテナを解凍し、アプリケーションを実行することを担当する、Dockerのようなコンテナランタイム。</li>
</ul>
</div>
<div class=col-md-4>
<div class="content__box content__box_fill">
<p><i> コンテナ同士が密接に結合され、ディスクなどのリソースを共有する必要がある場合は、コンテナを1つのPodにまとめてスケジュールする必要があります。 </i></p>
</div>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<h2 style=color:#3771e3>ノードの概要</h2>
</div>
</div>
<div class=row>
<div class=col-md-8>
<p><img src=/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg></p>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<h2>kubectlを使ったトラブルシューティング</h2>
<p>モジュール<a href=/ja/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/>2</a>では、kubectlのコマンドラインインターフェースを使用しました。モジュール3でもこれを使用して、デプロイされたアプリケーションとその環境に関する情報を入手します。最も一般的な操作は、次のkubectlコマンドで実行できます。</p>
<ul>
<li><b>kubectl get</b> - リソースの一覧を表示</li>
<li><b>kubectl describe</b> - 単一リソースに関する詳細情報を表示</li>
<li><b>kubectl logs</b> - 単一Pod上の単一コンテナ内のログを表示</li>
<li><b>kubectl exec</b> - 単一Pod上の単一コンテナ内でコマンドを実行</li>
</ul>
<p>これらのコマンドを使用して、アプリケーションがいつデプロイされたか、それらの現在の状況、実行中の場所、および構成を確認することができます。</p>
<p>クラスターのコンポーネントとコマンドラインの詳細についてわかったので、次にデプロイしたアプリケーションを探索してみましょう。</p>
</div>
<div class=col-md-4>
<div class="content__box content__box_fill">
<p><i> ノードはKubernetesではワーカーマシンであり、クラスターに応じてVMまたは物理マシンになります。 複数のPodを1つのノードで実行できます。 </i></p>
</div>
</div>
</div>
<br>
<div class=row>
<div class=col-md-12>
<a class="btn btn-lg btn-success" href=/ja/docs/tutorials/kubernetes-basics/explore/explore-interactive/ role=button>対話型のチュートリアルを始める <span class=btn__next>›</span></a>
</div>
</div>
</main>
</div>
</body>
</html>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4b01eab98a9844ad91131079654199dd>5.2.3.2 - 対話型チュートリアル - デプロイしたアプリケーションの探索</h1><!doctype html>
<html lang=ja>
<body>
<link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet>
<link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet>
<script src=https://katacoda.com/embed.js></script>
<div class=layout id=top>
<main class="content katacoda-content">
<br>
<div class=katacoda>
<div class=katacoda__alert>
ターミナルを使うには、PCまたはタブレットをお使いください
</div>
<div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/4 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px>
</div>
</div>
<div class=row>
<div class=col-md-12>
<a class="btn btn-lg btn-success" href=/ja/docs/tutorials/kubernetes-basics/expose/expose-intro/ role=button>モジュール4へ進む<span class=btn__next>›</span></a>
</div>
</div>
</main>
</div>
</body>
</html>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4b0e31c9e0eae68bbb0a358b4042ada9>5.2.4 - アプリケーションの公開</h1>
</div>
<div class=td-content>
<h1 id=pg-8ef4dad8f743b191a9e8c6f891cb191a>5.2.4.1 - Serviceを使ったアプリケーションの公開</h1><!doctype html>
<html lang=ja>
<body>
<link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet>
<div class=layout id=top>
<main class=content>
<div class=row>
<div class=col-md-8>
<h3>目標</h3>
<ul>
<li>KubernetesにおけるServiceについて理解する</li>
<li>ラベルとLabelSelectorオブジェクトがServiceにどう関係しているかを理解する</li>
<li>Serviceを使って、Kubernetesクラスターの外にアプリケーションを公開する</li>
</ul>
</div>
<div class=col-md-8>
<h3>Kubernetes Serviceの概要</h3>
<p>Kubernetes Podの寿命は永続的ではありません。実際、<a href=/ja/docs/concepts/workloads/pods/pod/>Pod</a>には<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>ライフサイクル</a>があります。ワーカーのノードが停止すると、そのノードで実行されているPodも失われます。そうなると、<a href=/ja/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>は、新しいPodを作成してアプリケーションを実行し続けるために、クラスターを動的に目的の状態に戻すことができます。別の例として、3つのレプリカを持つ画像処理バックエンドを考えます。それらのレプリカは交換可能です。フロントエンドシステムはバックエンドのレプリカを気にしたり、Podが失われて再作成されたとしても配慮すべきではありません。ただし、Kubernetesクラスター内の各Podは、同じノード上のPodであっても一意のIPアドレスを持っているため、アプリケーションが機能し続けるように、Pod間の変更を自動的に調整する方法が必要です。</p>
<p>KubernetesのServiceは、Podの論理セットと、それらにアクセスするためのポリシーを定義する抽象概念です。Serviceによって、依存Pod間の疎結合が可能になります。Serviceは、すべてのKubernetesオブジェクトのように、YAML<a href=/docs/concepts/configuration/overview/#general-configuration-tips>(推奨)</a>またはJSONを使って定義されます。Serviceが対象とするPodのセットは通常、<i>LabelSelector</i>によって決定されます(なぜ仕様に<code>セレクタ</code>を含めずにServiceが必要になるのかについては下記を参照してください)。</p>
<p>各Podには固有のIPアドレスがありますが、それらのIPは、Serviceなしではクラスターの外部に公開されません。Serviceによって、アプリケーションはトラフィックを受信できるようになります。ServiceSpecで<code>type</code>を指定することで、Serviceをさまざまな方法で公開することができます。</p>
<ul>
<li><i>ClusterIP</i> (既定値) - クラスター内の内部IPでServiceを公開します。この型では、Serviceはクラスター内からのみ到達可能になります。</li>
<li><i>NodePort</i> - NATを使用して、クラスター内の選択された各ノードの同じポートにServiceを公開します。<code>&lt;NodeIP>:&lt;NodePort></code>を使用してクラスターの外部からServiceにアクセスできるようにします。これはClusterIPのスーパーセットです。</li>
<li><i>LoadBalancer</i> - 現在のクラウドに外部ロードバランサを作成し(サポートされている場合)、Serviceに固定の外部IPを割り当てます。これはNodePortのスーパーセットです。</li>
<li><i>ExternalName</i> - 仕様の<code>externalName</code>で指定した名前のCNAMEレコードを返すことによって、任意の名前を使ってServiceを公開します。プロキシは使用されません。このタイプはv1.7以上の<code>kube-dns</code>を必要とします。</li>
</ul>
<p>さまざまな種類のServiceに関する詳細情報は<a href=/docs/tutorials/services/source-ip/>Using Source IP</a> tutorialにあります。<a href=/docs/concepts/services-networking/connect-applications-service>アプリケーションとServiceの接続</a>も参照してください。</p>
<p>加えて、Serviceには、仕様に<code>selector</code>を定義しないというユースケースがいくつかあります。<code>selector</code>を指定せずに作成したServiceについて、対応するEndpointsオブジェクトは作成されません。これによって、ユーザーは手動でServiceを特定のエンドポイントにマッピングできます。セレクタがない可能性があるもう1つの可能性は、<code>type：ExternalName</code>を厳密に使用していることです。</p>
</div>
<div class=col-md-4>
<div class="content__box content__box_lined">
<h3>まとめ</h3>
<ul>
<li>Podを外部トラフィックに公開する</li>
<li>複数のPod間でトラフィックを負荷分散する</li>
<li>ラベルを使う</li>
</ul>
</div>
<div class="content__box content__box_fill">
<p><i>Kubernetes Serviceは、Podの論理セットを定義し、それらのPodに対する外部トラフィックの公開、負荷分散、およびサービス検出を可能にする抽象化層です。</i></p>
</div>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<h3>Serviceとラベル</h3>
</div>
</div>
<div class=row>
<div class=col-md-8>
<p><img src=/docs/tutorials/kubernetes-basics/public/images/module_04_services.svg width=150% height=150%></p>
</div>
</div>
<div class=row>
<div class=col-md-8>
<p>Serviceは、一連のPodにトラフィックをルーティングします。Serviceは、アプリケーションに影響を与えることなく、KubernetesでPodが死んだり複製したりすることを可能にする抽象概念です。(アプリケーションのフロントエンドおよびバックエンドコンポーネントなどの)依存Pod間の検出とルーティングは、Kubernetes Serviceによって処理されます。</p>
<p>Serviceは、ラベルとセレクタを使用して一連のPodを照合します。これは、Kubernetes内のオブジェクトに対する論理操作を可能にするグループ化のプリミティブです。ラベルはオブジェクトに付けられたkey/valueのペアであり、さまざまな方法で使用できます。</p>
<ul>
<li>開発、テスト、および本番用のオブジェクトを指定する</li>
<li>バージョンタグを埋め込む</li>
<li>タグを使用してオブジェクトを分類する</li>
</ul>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<p><img src=/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg></p>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<p>ラベルは、作成時またはそれ以降にオブジェクトにアタッチでき、いつでも変更可能です。Serviceを使用してアプリケーションを公開し、いくつかのラベルを適用してみましょう。</p>
</div>
</div>
<br>
<div class=row>
<div class=col-md-12>
<a class="btn btn-lg btn-success" href=/ja/docs/tutorials/kubernetes-basics/expose/expose-interactive/ role=button>対話型のチュートリアルを始める<span class=btn__next>›</span></a>
</div>
</div>
</main>
</div>
</body>
</html>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-352241d22effe0714772d21c7d1b512d>5.2.4.2 - 対話型チュートリアル - アプリケーションの公開</h1><!doctype html>
<html lang=ja>
<body>
<link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet>
<link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet>
<script src=https://katacoda.com/embed.js></script>
<div class=layout id=top>
<main class="content katacoda-content">
<div class=katacoda>
<div class=katacoda__alert>
ターミナルを使うには、PCまたはタブレットをお使いください
</div>
<div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/8 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px>
</div>
</div>
<div class=row>
<div class=col-md-12>
<a class="btn btn-lg btn-success" href=/ja/docs/tutorials/kubernetes-basics/scale/scale-intro/ role=button>モジュール5へ進む<span class=btn__next>›</span></a>
</div>
</div>
</main>
</div>
</body>
</html>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-be4996c93fb39c459a30b6669569d423>5.2.5 - アプリケーションのスケーリング</h1>
</div>
<div class=td-content>
<h1 id=pg-d1c15c9bd4f625adbc13149b1475287c>5.2.5.1 - アプリケーションの複数インスタンスを実行</h1><!doctype html>
<html lang=ja>
<body>
<link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet>
<div class=layout id=top>
<main class=content>
<div class=row>
<div class=col-md-8>
<h3>目標</h3>
<ul>
<li>kubectlを使用してアプリケーションをスケールする</li>
</ul>
</div>
<div class=col-md-8>
<h3>アプリケーションのスケーリング</h3>
<p>前回のモジュールでは、<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>を作成し、それを<a href=/ja/docs/concepts/services-networking/service/>Service</a>経由で公開しました。該当のDeploymentでは、アプリケーションを実行するためのPodを1つだけ作成しました。トラフィックが増加した場合、ユーザーの需要に対応するためにアプリケーションをスケールする必要があります。</p>
<p><b>スケーリング</b>は、Deploymentのレプリカの数を変更することによって実現可能です。</p>
</div>
<div class=col-md-4>
<div class="content__box content__box_lined">
<h3>まとめ</h3>
<ul>
<li>Deploymentのスケーリング</li>
</ul>
</div>
<div class="content__box content__box_fill">
<p><i>kubectl create deploymentコマンドの--replicasパラメーターを使用することで、最初から複数のインスタンスを含むDeploymentを作成できます。</i></p>
</div>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<h2 style=color:#3771e3>スケーリングの概要</h2>
</div>
</div>
<div class=row>
<div class=col-md-1></div>
<div class=col-md-8>
<div id=myCarousel class=carousel data-ride=carousel data-interval=3000>
<ol class=carousel-indicators>
<li data-target=#myCarousel data-slide-to=0 class=active></li>
<li data-target=#myCarousel data-slide-to=1></li>
</ol>
<div class=carousel-inner role=listbox>
<div class="item carousel-item active">
<img src=/docs/tutorials/kubernetes-basics/public/images/module_05_scaling1.svg>
</div>
<div class="item carousel-item">
<img src=/docs/tutorials/kubernetes-basics/public/images/module_05_scaling2.svg>
</div>
</div>
<a class="left carousel-control" href=#myCarousel role=button data-slide=prev>
<span class=sr-only>前</span>
</a>
<a class="right carousel-control" href=#myCarousel role=button data-slide=next>
<span class=sr-only>次</span>
</a>
</div>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<p>Deploymentをスケールアウトすると、新しいPodが作成され、使用可能なリソースを持つノードにスケジュールされます。スケールすると、Podの数が増えて新たな望ましい状態になります。KubernetesはPodの<a href=/docs/user-guide/horizontal-pod-autoscaling/>オートスケーリング</a>もサポートしていますが、このチュートリアルでは範囲外です。スケーリングを0に設定することも可能で、指定された配置のすべてのPodを終了させます。</p>
<p>アプリケーションの複数インスタンスを実行するには、それらすべてにトラフィックを分散する方法が必要になります。Serviceには、公開されたDeploymentのすべてのPodにネットワークトラフィックを分散する統合ロードバランサがあります。Serviceは、エンドポイントを使用して実行中のPodを継続的に監視し、トラフィックが使用可能なPodにのみ送信されるようにします。</p>
</div>
<div class=col-md-4>
<div class="content__box content__box_fill">
<p><i>スケーリングは、Deploymentのレプリカの数を変更することによって実現可能です。</i></p>
</div>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<p>アプリケーションの複数のインスタンスを実行すると、ダウンタイムなしでローリングアップデートを実行できます。それについては、次のモジュールで学習します。それでは、オンラインのターミナルを使って、アプリケーションをデプロイしてみましょう。</p>
</div>
</div>
<br>
<div class=row>
<div class=col-md-12>
<a class="btn btn-lg btn-success" href=/ja/docs/tutorials/kubernetes-basics/scale/scale-interactive/ role=button>対話型のチュートリアルを始める <span class=btn__next>›</span></a>
</div>
</div>
</main>
</div>
</body>
</html>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7bdb3fbaa1177ff5dfa3fe86bd35ef59>5.2.5.2 - 対話型チュートリアル - アプリケーションのスケーリング</h1><!doctype html>
<html lang=ja>
<body>
<link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet>
<link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet>
<script src=https://katacoda.com/embed.js></script>
<div class=layout id=top>
<main class="content katacoda-content">
<div class=katacoda>
<div class=katacoda__alert>
ターミナルを使うには、PCまたはタブレットをお使いください
</div>
<div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/5 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px>
</div>
</div>
<div class=row>
<div class=col-md-12>
<a class="btn btn-lg btn-success" href=/ja/docs/tutorials/kubernetes-basics/update/update-intro/ role=button>モジュール6へ進む<span class=btn__next>›</span></a>
</div>
</div>
</main>
<a class=scrolltop href=#top></a>
</div>
</body>
</html>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-62b8b17dadfb55f1801cf8439e944e58>5.2.6 - アプリケーションのアップデート</h1>
</div>
<div class=td-content>
<h1 id=pg-12e04355145afad615ca3c38335ba019>5.2.6.1 - ローリングアップデートの実行</h1><!doctype html>
<html lang=ja>
<body>
<link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet>
<div class=layout id=top>
<main class=content>
<div class=row>
<div class=col-md-8>
<h3>目標</h3>
<ul>
<li>kubectlを使ってローリングアップデートを実行する</li>
</ul>
</div>
<div class=col-md-8>
<h3>アプリケーションのアップデート</h3>
<p>ユーザーはアプリケーションが常に利用可能であることを期待し、開発者はそれらの新しいバージョンを1日に数回デプロイすることが期待されます。Kubernetesでは、アプリケーションのアップデートをローリングアップデートで行います。<b>ローリングアップデート</b>では、Podインスタンスを新しいインスタンスで段階的にアップデートすることで、ダウンタイムなしでDeploymentをアップデートできます。新しいPodは、利用可能なリソースを持つノードにスケジュールされます。</p>
<p>前回のモジュールでは、複数のインスタンスを実行するようにアプリケーションをデプロイしました。これは、アプリケーションの可用性に影響を与えずにアップデートを行うための要件です。デフォルトでは、アップデート中に使用できなくなる可能性があるPodの最大数と作成できる新しいPodの最大数は1です。どちらのオプションも、Podの数または全体数に対する割合(%)のいずれかに設定できます。Kubernetesでは、アップデートはバージョン管理されており、Deploymentにおけるアップデートは以前の(stable)バージョンに戻すことができます。</p>
</div>
<div class=col-md-4>
<div class="content__box content__box_lined">
<h3>まとめ</h3>
<ul>
<li>アプリケーションのアップデート</li>
</ul>
</div>
<div class="content__box content__box_fill">
<p><i>ローリングアップデートでは、Podを新しいインスタンスで段階的にアップデートすることで、ダウンタイムなしDeploymentをアップデートできます。</i></p>
</div>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<h2 style=color:#3771e3>ローリングアップデートの概要</h2>
</div>
</div>
<div class=row>
<div class=col-md-1></div>
<div class=col-md-8>
<div id=myCarousel class=carousel data-ride=carousel data-interval=3000>
<ol class=carousel-indicators>
<li data-target=#myCarousel data-slide-to=0 class=active></li>
<li data-target=#myCarousel data-slide-to=1></li>
<li data-target=#myCarousel data-slide-to=2></li>
<li data-target=#myCarousel data-slide-to=3></li>
</ol>
<div class=carousel-inner role=listbox>
<div class="item carousel-item active">
<img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates1.svg>
</div>
<div class="item carousel-item">
<img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates2.svg>
</div>
<div class="item carousel-item">
<img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates3.svg>
</div>
<div class="item carousel-item">
<img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates4.svg>
</div>
</div>
<a class="left carousel-control" href=#myCarousel role=button data-slide=prev>
<span class=sr-only>Previous</span>
</a>
<a class="right carousel-control" href=#myCarousel role=button data-slide=next>
<span class=sr-only>Next</span>
</a>
</div>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<p>アプリケーションのスケーリングと同様に、Deploymentがパブリックに公開されている場合、Serviceはアップデート中に利用可能なPodのみにトラフィックを負荷分散します。 利用可能なPodは、アプリケーションのユーザーが利用できるインスタンスです。</p>
<p>ローリングアップデートでは、次の操作が可能です。</p>
<ul>
<li>コンテナイメージのアップデートを介した、ある環境から別の環境へのアプリケーションの昇格</li>
<li>以前のバージョンへのロールバック</li>
<li>ダウンタイムなしでのアプリケーションのCI/CD</li>
</ul>
</div>
<div class=col-md-4>
<div class="content__box content__box_fill">
<p><i>Deploymentがパブリックに公開されている場合、Serviceはアップデート中に利用可能なPodにのみトラフィックを負荷分散します。 </i></p>
</div>
</div>
</div>
<br>
<div class=row>
<div class=col-md-8>
<p>次の対話型チュートリアルでは、アプリケーションを新しいバージョンにアップデートし、ロールバックも実行します。</p>
</div>
</div>
<br>
<div class=row>
<div class=col-md-12>
<a class="btn btn-lg btn-success" href=/ja/docs/tutorials/kubernetes-basics/update/update-interactive/ role=button>対話型のチュートリアルを始める <span class=btn__next>›</span></a>
</div>
</div>
</main>
</div>
</body>
</html>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-dddc0cb356c280e0339bcf42776987dc>5.2.6.2 - 対話型チュートリアル - アプリケーションのアップデート</h1><!doctype html>
<html lang=ja>
<body>
<link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet>
<link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet>
<script src=https://katacoda.com/embed.js></script>
<div class=layout id=top>
<main class="content katacoda-content">
<div class=katacoda>
<div class=katacoda__alert>
ターミナルを使うには、PCまたはタブレットをお使いください
</div>
<div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/6 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px>
</div>
</div>
<div class=row>
<div class=col-md-12>
<a class="btn btn-lg btn-success" href=/ja/docs/tutorials/kubernetes-basics/ role=button>Kubernetesの基本に戻る<span class=btn__next>›</span></a>
</div>
</div>
</main>
</div>
</body>
</html>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a3a0f1c6af19fc89ce24d8cd42c0249f>5.3 - 設定</h1>
</div>
<div class=td-content>
<h1 id=pg-2efe621cc085b350c8c4574e6f7f1311>5.3.1 - ConfigMapを使ったRedisの設定</h1>
<p>本ページでは、<a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMapを使ったコンテナの設定</a>に基づき、ConfigMapを使ってRedisの設定を行う実践的な例を提供します。</p>
<h2 id=目標>目標</h2>
<ul>
<li>以下の要素を含む<code>kustomization.yaml</code>ファイルを作成する:
<ul>
<li>ConfigMapGenerator</li>
<li>ConfigMapを使ったPodリソースの設定</li>
</ul>
</li>
<li><code>kubectl apply -k ./</code>コマンドにてディレクトリ全体を適用する</li>
<li>設定が正しく反映されていることを確認する</li>
</ul>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<ul>
<li>この例は、バージョン1.14以上での動作を確認しています。</li>
<li><a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMapを使ったコンテナの設定</a>を読んで理解しておいてください。</li>
</ul>
<h2 id=実践例-configmapを使ったredisの設定>実践例: ConfigMapを使ったRedisの設定</h2>
<p>以下の手順に従って、ConfigMapに保存されているデータを使用してRedisキャッシュを設定できます。</p>
<p>最初に、<code>redis-config</code>ファイルからConfigMapを含む<code>kustomization.yaml</code>を作成します:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/config/redis-config download=pods/config/redis-config><code>pods/config/redis-config</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-config-redis-config')" title="Copy pods/config/redis-config to clipboard">
</img>
</div>
<div class=includecode id=pods-config-redis-config>
<pre tabindex=0><code>maxmemory 2mb
maxmemory-policy allkeys-lru
</code></pre>
</div>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -OL https://k8s.io/examples/pods/config/redis-config

cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: example-redis-config
</span><span style=color:#b44>  files:
</span><span style=color:#b44>  - redis-config
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>Podリソースの設定を<code>kustomization.yaml</code>に入れます:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/config/redis-pod.yaml download=pods/config/redis-pod.yaml><code>pods/config/redis-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-config-redis-pod-yaml')" title="Copy pods/config/redis-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-config-redis-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>kubernetes/redis:v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MASTER<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/redis-master-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/redis-master<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-redis-config<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>redis-config<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>redis.conf<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -OL https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/pods/config/redis-pod.yaml

cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt;./kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>- redis-pod.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>kustomizationディレクトリを反映して、ConfigMapオブジェクトとPodオブジェクトの両方を作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
</code></pre></div><p>作成されたオブジェクトを確認します</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>&gt; kubectl get -k .
NAME                                        DATA   AGE
configmap/example-redis-config-dgh9dg555m   <span style=color:#666>1</span>      52s

NAME        READY   STATUS    RESTARTS   AGE
pod/redis   1/1     Running   <span style=color:#666>0</span>          52s
</code></pre></div><p>この例では、設定ファイルのボリュームは<code>/redis-master</code>にマウントされています。
<code>path</code>を使って<code>redis-config</code>キーを<code>redis.conf</code>という名前のファイルに追加します。
したがって、redisコンフィグのファイルパスは<code>/redis-master/redis.conf</code>です。
ここが、コンテナイメージがredisマスターの設定ファイルを探す場所です。</p>
<p><code>kubectl exec</code>を使ってPodに入り、<code>redis-cli</code>ツールを実行して設定が正しく適用されたことを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it redis -- redis-cli
127.0.0.1:6379&gt; CONFIG GET maxmemory
1<span style=color:#666>)</span> <span style=color:#b44>&#34;maxmemory&#34;</span>
2<span style=color:#666>)</span> <span style=color:#b44>&#34;2097152&#34;</span>
127.0.0.1:6379&gt; CONFIG GET maxmemory-policy
1<span style=color:#666>)</span> <span style=color:#b44>&#34;maxmemory-policy&#34;</span>
2<span style=color:#666>)</span> <span style=color:#b44>&#34;allkeys-lru&#34;</span>
</code></pre></div><p>作成したPodを削除します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod redis
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>について学ぶ</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1efbbc2c3015389f835b1661d5effb29>5.4 - ステートレスアプリケーション</h1>
</div>
<div class=td-content>
<h1 id=pg-62caf420877232190a7404b8d93c6724>5.4.1 - クラスター内のアプリケーションにアクセスするために外部IPアドレスを公開する</h1>
<p>このページでは、外部IPアドレスを公開するKubernetesのServiceオブジェクトを作成する方法を示します。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>
<p><a href=/ja/docs/tasks/tools/install-kubectl/>kubectl</a>をインストールしてください。</p>
</li>
<li>
<p>Kubernetesクラスターを作成する際に、Google Kubernetes EngineやAmazon Web Servicesのようなクラウドプロバイダーを使用します。このチュートリアルでは、クラウドプロバイダーを必要とする<a href=/docs/tasks/access-application-cluster/create-external-load-balancer/>外部ロードバランサー</a>を作成します。</p>
</li>
<li>
<p>Kubernetes APIサーバーと通信するために、<code>kubectl</code>を設定してください。手順については、各クラウドプロバイダーのドキュメントを参照してください。</p>
</li>
</ul>
<h2 id=目標>目標</h2>
<ul>
<li>5つのインスタンスで実際のアプリケーションを起動します。</li>
<li>外部IPアドレスを公開するServiceオブジェクトを作成します。</li>
<li>起動中のアプリケーションにアクセスするためにServiceオブジェクトを使用します。</li>
</ul>
<h2 id=5つのpodで起動しているアプリケーションへのserviceの作成>5つのPodで起動しているアプリケーションへのServiceの作成</h2>
<ol>
<li>クラスターにてHello Worldアプリケーションを実行してください。</li>
</ol>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/load-balancer-example.yaml download=service/load-balancer-example.yaml><code>service/load-balancer-example.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-load-balancer-example-yaml')" title="Copy service/load-balancer-example.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-load-balancer-example-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-world<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-world<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/load-balancer-example.yaml
</code></pre></div><p>上記のコマンドにより、 <a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>を作成し、<a class=glossary-tooltip title="ReplicaSet ensures that a specified number of Pod replicas are running at one time" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSet>ReplicaSet</a>を関連づけます。ReplicaSetには5つの<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>があり、それぞれHello Worldアプリケーションが起動しています。</p>
<ol>
<li>
<p>Deploymentに関する情報を表示します:</p>
<pre><code> kubectl get deployments hello-world
 kubectl describe deployments hello-world
</code></pre>
</li>
<li>
<p>ReplicaSetオブジェクトに関する情報を表示します:</p>
<pre><code> kubectl get replicasets
 kubectl describe replicasets
</code></pre>
</li>
<li>
<p>Deploymentを公開するServiceオブジェクトを作成します。</p>
<pre><code> kubectl expose deployment hello-world --type=LoadBalancer --name=my-service
</code></pre>
</li>
<li>
<p>Serviceに関する情報を表示します:</p>
<pre><code> kubectl get services my-service
</code></pre>
<p>出力は次のようになります:</p>
<pre><code> NAME         TYPE           CLUSTER-IP     EXTERNAL-IP      PORT(S)    AGE
 my-service   LoadBalancer   10.3.245.137   104.198.205.71   8080/TCP   54s
</code></pre>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>type=LoadBalancer</code>のServiceは外部のクラウドプロバイダーによってサポートされており、ここでは扱いません。詳細は<a href=/ja/docs/concepts/services-networking/service/#loadbalancer>こちらのページ</a>を参照してください。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 外部IPアドレスが&lt;pending>と表示されている場合は、しばらく待ってから同じコマンドを実行してください。
</div>
</li>
<li>
<p>Serviceに関する詳細な情報を表示します:</p>
<pre><code> kubectl describe services my-service
</code></pre>
<p>出力は次のようになります:</p>
<pre><code> Name:           my-service
 Namespace:      default
 Labels:         app.kubernetes.io/name=load-balancer-example
 Annotations:    &lt;none&gt;
 Selector:       app.kubernetes.io/name=load-balancer-example
 Type:           LoadBalancer
 IP:             10.3.245.137
 LoadBalancer Ingress:   104.198.205.71
 Port:           &lt;unset&gt; 8080/TCP
 NodePort:       &lt;unset&gt; 32377/TCP
 Endpoints:      10.0.0.6:8080,10.0.1.6:8080,10.0.1.7:8080 + 2 more...
 Session Affinity:   None
 Events:         &lt;none&gt;
</code></pre>
<p>Serviceによって公開された外部IPアドレス(<code>LoadBalancer Ingress</code>)を記録しておいてください。
この例では、外部IPアドレスは104.198.205.71です。
また、<code>Port</code>および<code>NodePort</code>の値も控えてください。
この例では、<code>Port</code>は8080、<code>NodePort</code>は32377です。</p>
</li>
<li>
<p>先ほどの出力にて、Serviceにはいくつかのエンドポイントがあることを確認できます: 10.0.0.6:8080、
10.0.1.6:8080、10.0.1.7:8080、その他2つです。
これらはHello Worldアプリケーションが動作しているPodの内部IPアドレスです。
これらのPodのアドレスを確認するには、次のコマンドを実行します:</p>
<pre><code> kubectl get pods --output=wide
</code></pre>
<p>出力は次のようになります:</p>
<pre><code> NAME                         ...  IP         NODE
 hello-world-2895499144-1jaz9 ...  10.0.1.6   gke-cluster-1-default-pool-e0b8d269-1afc
 hello-world-2895499144-2e5uh ...  10.0.1.8   gke-cluster-1-default-pool-e0b8d269-1afc
 hello-world-2895499144-9m4h1 ...  10.0.0.6   gke-cluster-1-default-pool-e0b8d269-5v7a
 hello-world-2895499144-o4z13 ...  10.0.1.7   gke-cluster-1-default-pool-e0b8d269-1afc
 hello-world-2895499144-segjf ...  10.0.2.5   gke-cluster-1-default-pool-e0b8d269-cpuc
</code></pre>
</li>
<li>
<p>Hello Worldアプリケーションにアクセスするために、外部IPアドレス(<code>LoadBalancer Ingress</code>)を使用します:</p>
<pre><code> curl http://&lt;external-ip&gt;:&lt;port&gt;
</code></pre>
<p>ここで、<code>&lt;external-ip></code>はServiceの外部IPアドレス(<code>LoadBalancer Ingress</code>)で、
<code>&lt;port></code>はServiceの詳細出力における<code>Port</code>です。minikubeを使用している場合、<code>minikube service my-service</code>を実行することでHello Worldアプリケーションをブラウザで自動的に
開かれます。</p>
<p>正常なリクエストに対するレスポンスは、helloメッセージです:</p>
<pre><code> Hello Kubernetes!
</code></pre>
</li>
</ol>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>Serviceを削除する場合、次のコマンドを実行します:</p>
<pre><code>kubectl delete services my-service
</code></pre>
<p>Deployment、ReplicaSet、およびHello Worldアプリケーションが動作しているPodを削除する場合、次のコマンドを実行します:</p>
<pre><code>kubectl delete deployment hello-world
</code></pre>
<h2 id=次の項目>次の項目</h2>
<p><a href=/docs/concepts/services-networking/connect-applications-service/>connecting applications with services</a>にて詳細を学ぶことができます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8c56795c6614cc5f52434ecc756448ac>5.4.2 - 例: Redisを使用したPHPのゲストブックアプリケーションのデプロイ</h1>
<p>このチュートリアルでは、Kubernetesと<a href=https://www.docker.com/>Docker</a>を使用した、シンプルなマルチティアのウェブアプリケーションのビルドとデプロイの方法を紹介します。この例は、以下のコンポーネントから構成されています。</p>
<ul>
<li>ゲストブックのエントリーを保存するための、シングルインスタンスの<a href=https://redis.io/>Redis</a>マスター</li>
<li>読み込みデータ配信用の、複数の<a href=https://redis.io/topics/replication>レプリケーションされたRedis</a>インスタンス</li>
<li>複数のウェブフロントエンドのインスタンス</li>
</ul>
<h2 id=目標>目標</h2>
<ul>
<li>Redisのマスターを起動する。</li>
<li>Redisのスレーブを起動する。</li>
<li>ゲストブックのフロントエンドを起動する。</li>
<li>フロントエンドのServiceを公開して表示を確認する。</li>
<li>クリーンアップする。</li>
</ul>
<h2 id=始める前に>始める前に</h2>
<p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
<h2 id=redisのマスターを起動する>Redisのマスターを起動する</h2>
<p>ゲストブックアプリケーションでは、データを保存するためにRedisを使用します。ゲストブックはRedisのマスターインスタンスにデータを書き込み、複数のRedisのスレーブインスタンスからデータを読み込みます。</p>
<h3 id=redisのマスターのdeploymentを作成する>RedisのマスターのDeploymentを作成する</h3>
<p>以下のマニフェストファイルは、シングルレプリカのRedisのマスターPodを実行するDeploymentコントローラーを指定しています。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/guestbook/redis-master-deployment.yaml download=application/guestbook/redis-master-deployment.yaml><code>application/guestbook/redis-master-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-guestbook-redis-master-deployment-yaml')" title="Copy application/guestbook/redis-master-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-guestbook-redis-master-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-master<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image: k8s.gcr.io/redis:e2e  # or just image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>マニフェストファイルをダウンロードしたディレクトリ内で、ターミナルウィンドウを起動します。</p>
</li>
<li>
<p><code>redis-master-deployment.yaml</code>ファイルから、RedisのマスターのDeploymentを適用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/guestbook/redis-master-deployment.yaml
</code></pre></div></li>
<li>
<p>Podのリストを問い合わせて、RedisのマスターのPodが実行中になっていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>結果は次のようになるはずです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                            READY     STATUS    RESTARTS   AGE
redis-master-1068406935-3lswp   1/1       Running   <span style=color:#666>0</span>          28s
</code></pre></div></li>
<li>
<p>次のコマンドを実行して、RedisのマスターのPodからログを表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs -f POD-NAME
</code></pre></div></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> POD-NAMEの部分を実際のPodの名前に書き換えてください。
</div>
<h3 id=redisのマスターのserviceを作成する>RedisのマスターのServiceを作成する</h3>
<p>ゲストブックアプリケーションは、データを書き込むためにRedisのマスターと通信する必要があります。そのためには、<a href=/ja/docs/concepts/services-networking/service/>Service</a>を適用して、トラフィックをRedisのマスターのPodへプロキシーしなければなりません。Serviceは、Podにアクセスするためのポリシーを指定します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/guestbook/redis-master-service.yaml download=application/guestbook/redis-master-service.yaml><code>application/guestbook/redis-master-service.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-guestbook-redis-master-service-yaml')" title="Copy application/guestbook/redis-master-service.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-guestbook-redis-master-service-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-master<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>次の<code>redis-master-service.yaml</code>から、RedisのマスターのServiceを適用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/guestbook/redis-master-service.yaml
</code></pre></div></li>
<li>
<p>Serviceのリストを問い合わせて、RedisのマスターのServiceが実行中になっていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service
</code></pre></div><p>The response should be similar to this:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME           TYPE        CLUSTER-IP   EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>    AGE
kubernetes     ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP    1m
redis-master   ClusterIP   10.0.0.151   &lt;none&gt;        6379/TCP   8s
</code></pre></div></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このマニフェストファイルは、<code>redis-master</code>という名前のServiceを、前に定義したラベルにマッチする一連のラベル付きで作成します。これにより、ServiceはネットワークトラフィックをRedisのマスターのPodへとルーティングできるようになります。
</div>
<h2 id=redisのスレーブを起動する>Redisのスレーブを起動する</h2>
<p>Redisのマスターは1つのPodですが、レプリカのRedisのスレーブを追加することで、トラフィックの需要を満たすための高い可用性を持たせることができます。</p>
<h3 id=redisのスレーブのdeploymentを作成する>RedisのスレーブのDeploymentを作成する</h3>
<p>Deploymentはマニフェストファイル内に書かれた設定に基づいてスケールします。ここでは、Deploymentオブジェクトは2つのレプリカを指定しています。</p>
<p>もし1つもレプリカが実行されていなければ、このDeploymentは2つのレプリカをコンテナクラスター上で起動します。逆に、もしすでに2つ以上のレプリカが実行されていれば、実行中のレプリカが2つになるようにスケールダウンします。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/guestbook/redis-slave-deployment.yaml download=application/guestbook/redis-slave-deployment.yaml><code>application/guestbook/redis-slave-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-guestbook-redis-slave-deployment-yaml')" title="Copy application/guestbook/redis-slave-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-guestbook-redis-slave-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-slave<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>slave<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>slave<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slave<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_samples/gb-redisslave:v3<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>GET_HOSTS_FROM<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>dns<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># Using `GET_HOSTS_FROM=dns` requires your cluster to</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># provide a dns service. As of Kubernetes 1.3, DNS is a built-in</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># service launched automatically. However, if the cluster you are using</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># does not have a built-in DNS service, you can instead</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># access an environment variable to find the master</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># service&#39;s host. To do so, comment out the &#39;value: dns&#39; line above, and</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># uncomment the line below:</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># value: env</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p><code>redis-slave-deployment.yaml</code>ファイルから、RedisのスレーブのDeploymentを適用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/guestbook/redis-slave-deployment.yaml
</code></pre></div></li>
<li>
<p>Podのリストを問い合わせて、RedisのスレーブのPodが実行中になっていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>結果は次のようになるはずです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                            READY     STATUS              RESTARTS   AGE
redis-master-1068406935-3lswp   1/1       Running             <span style=color:#666>0</span>          1m
redis-slave-2005841000-fpvqc    0/1       ContainerCreating   <span style=color:#666>0</span>          6s
redis-slave-2005841000-phfv9    0/1       ContainerCreating   <span style=color:#666>0</span>          6s
</code></pre></div></li>
</ol>
<h3 id=redisのスレーブのserviceを作成する>RedisのスレーブのServiceを作成する</h3>
<p>ゲストブックアプリケーションは、データを読み込むためにRedisのスレーブと通信する必要があります。Redisのスレーブが発見できるようにするためには、Serviceをセットアップする必要があります。Serviceは一連のPodに対する透過的なロードバランシングを提供します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/guestbook/redis-slave-service.yaml download=application/guestbook/redis-slave-service.yaml><code>application/guestbook/redis-slave-service.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-guestbook-redis-slave-service-yaml')" title="Copy application/guestbook/redis-slave-service.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-guestbook-redis-slave-service-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-slave<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>slave<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>slave<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>次の<code>redis-slave-service.yaml</code>ファイルから、RedisのスレーブのServiceを適用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/guestbook/redis-slave-service.yaml
</code></pre></div></li>
<li>
<p>Serviceのリストを問い合わせて、RedisのスレーブのServiceが実行中になっていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get services
</code></pre></div><p>結果は次のようになるはずです。</p>
<pre><code>NAME           TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
kubernetes     ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP    2m
redis-master   ClusterIP   10.0.0.151   &lt;none&gt;        6379/TCP   1m
redis-slave    ClusterIP   10.0.0.223   &lt;none&gt;        6379/TCP   6s
</code></pre></li>
</ol>
<h2 id=ゲストブックのフロントエンドをセットアップして公開する>ゲストブックのフロントエンドをセットアップして公開する</h2>
<p>ゲストブックアプリケーションには、HTTPリクエストをサーブするPHPで書かれたウェブフロントエンドがあります。このアプリケーションは、書き込みリクエストに対しては<code>redis-master</code> Serviceに、読み込みリクエストに対しては<code>redis-slave</code> Serviceに接続するように設定されています。</p>
<h3 id=ゲストブックのフロントエンドのdeploymentを作成する>ゲストブックのフロントエンドのDeploymentを作成する</h3>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/guestbook/frontend-deployment.yaml download=application/guestbook/frontend-deployment.yaml><code>application/guestbook/frontend-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-guestbook-frontend-deployment-yaml')" title="Copy application/guestbook/frontend-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-guestbook-frontend-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-redis<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/gb-frontend:v4<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>GET_HOSTS_FROM<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>dns<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># Using `GET_HOSTS_FROM=dns` requires your cluster to</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># provide a dns service. As of Kubernetes 1.3, DNS is a built-in</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># service launched automatically. However, if the cluster you are using</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># does not have a built-in DNS service, you can instead</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># access an environment variable to find the master</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># service&#39;s host. To do so, comment out the &#39;value: dns&#39; line above, and</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># uncomment the line below:</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># value: env</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p><code>frontend-deployment.yaml</code>ファイルから、フロントエンドのDeploymentを適用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/guestbook/frontend-deployment.yaml
</code></pre></div></li>
<li>
<p>Podのリストを問い合わせて、3つのフロントエンドのレプリカが実行中になっていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l app.kubernetes.io/name<span style=color:#666>=</span>guestbook -l app.kubernetes.io/component<span style=color:#666>=</span>frontend
</code></pre></div><p>結果は次のようになるはずです。</p>
<pre><code>NAME                        READY     STATUS    RESTARTS   AGE
frontend-3823415956-dsvc5   1/1       Running   0          54s
frontend-3823415956-k22zn   1/1       Running   0          54s
frontend-3823415956-w9gbt   1/1       Running   0          54s
</code></pre></li>
</ol>
<h3 id=フロントエンドのserviceを作成する>フロントエンドのServiceを作成する</h3>
<p>適用した<code>redis-slave</code>および<code>redis-master</code> Serviceは、コンテナクラスター内部からのみアクセス可能です。これは、デフォルトのServiceのtypeが<a href=/ja/docs/concepts/services-networking/service/#publishing-services-service-types>ClusterIP</a>であるためです。<code>ClusterIP</code>は、Serviceが指している一連のPodに対して1つのIPアドレスを提供します。このIPアドレスはクラスター内部からのみアクセスできます。</p>
<p>もしゲストの人にゲストブックにアクセスしてほしいのなら、フロントエンドServiceを外部から見えるように設定しなければなりません。そうすれば、クライアントはコンテナクラスターの外部からServiceにリクエストを送れるようになります。Minikubeでは、Serviceを<code>NodePort</code>でのみ公開できます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 一部のクラウドプロバイダーでは、Google Compute EngineやGoogle Kubernetes Engineなど、外部のロードバランサーをサポートしているものがあります。もしクラウドプロバイダーがロードバランサーをサポートしていて、それを使用したい場合は、<code>type: NodePort</code>という行を単に削除またはコメントアウトして、<code>type: LoadBalancer</code>のコメントアウトを外せば使用できます。
</div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/guestbook/frontend-service.yaml download=application/guestbook/frontend-service.yaml><code>application/guestbook/frontend-service.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-guestbook-frontend-service-yaml')" title="Copy application/guestbook/frontend-service.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-guestbook-frontend-service-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># comment or delete the following line if you want to use a LoadBalancer</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort <span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># if your cluster supports it, uncomment the following to automatically create</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># an external load-balanced IP for the frontend service.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># type: LoadBalancer</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p><code>frontend-service.yaml</code>ファイルから、フロントエンドのServiceを提供します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/guestbook/frontend-service.yaml
</code></pre></div></li>
<li>
<p>Serviceのリストを問い合わせて、フロントエンドのServiceが実行中であることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get services
</code></pre></div><p>結果は次のようになるはずです。</p>
<pre><code>NAME           TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE
frontend       NodePort    10.0.0.112   &lt;none&gt;       80:31323/TCP   6s
kubernetes     ClusterIP   10.0.0.1     &lt;none&gt;        443/TCP        4m
redis-master   ClusterIP   10.0.0.151   &lt;none&gt;        6379/TCP       2m
redis-slave    ClusterIP   10.0.0.223   &lt;none&gt;        6379/TCP       1m
</code></pre></li>
</ol>
<h3 id=フロントエンドのserviceを-nodeport-経由で表示する>フロントエンドのServiceを<code>NodePort</code>経由で表示する</h3>
<p>このアプリケーションをMinikubeやローカルのクラスターにデプロイした場合、ゲストブックを表示するためのIPアドレスを見つける必要があります。</p>
<ol>
<li>
<p>次のコマンドを実行すると、フロントエンドServiceに対するIPアドレスを取得できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube service frontend --url
</code></pre></div><p>結果は次のようになるはずです。</p>
<pre><code>http://192.168.99.100:31323
</code></pre></li>
<li>
<p>IPアドレスをコピーして、ブラウザー上でページを読み込み、ゲストブックを表示しましょう。</p>
</li>
</ol>
<h3 id=フロントエンドのserviceを-loadbalancer-経由で表示する>フロントエンドのServiceを<code>LoadBalancer</code>経由で表示する</h3>
<p>もし<code>frontend-service.yaml</code>マニフェストを<code>type: LoadBalancer</code>でデプロイした場合、ゲストブックを表示するためのIPアドレスを見つける必要があります。</p>
<ol>
<li>
<p>次のコマンドを実行すると、フロントエンドServiceに対するIPアドレスを取得できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service frontend
</code></pre></div><p>結果は次のようになるはずです。</p>
<pre><code>NAME       TYPE        CLUSTER-IP      EXTERNAL-IP        PORT(S)        AGE
frontend   ClusterIP   10.51.242.136   109.197.92.229     80:32372/TCP   1m
</code></pre></li>
<li>
<p>外部IPアドレス(EXTERNAL-IP)をコピーして、ブラウザー上でページを読み込み、ゲストブックを表示しましょう。</p>
</li>
</ol>
<h2 id=ウェブフロントエンドをスケールする>ウェブフロントエンドをスケールする</h2>
<p>サーバーがDeploymentコントローラーを使用するServiceとして定義されているため、スケールアップやスケールダウンは簡単です。</p>
<ol>
<li>
<p>次のコマンドを実行すると、フロントエンドのPodの数をスケールアップできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment frontend --replicas<span style=color:#666>=</span><span style=color:#666>5</span>
</code></pre></div></li>
<li>
<p>Podのリストを問い合わせて、実行中のフロントエンドのPodの数を確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>結果は次のようになるはずです。</p>
<pre><code>NAME                            READY     STATUS    RESTARTS   AGE
frontend-3823415956-70qj5       1/1       Running   0          5s
frontend-3823415956-dsvc5       1/1       Running   0          54m
frontend-3823415956-k22zn       1/1       Running   0          54m
frontend-3823415956-w9gbt       1/1       Running   0          54m
frontend-3823415956-x2pld       1/1       Running   0          5s
redis-master-1068406935-3lswp   1/1       Running   0          56m
redis-slave-2005841000-fpvqc    1/1       Running   0          55m
redis-slave-2005841000-phfv9    1/1       Running   0          55m
</code></pre></li>
<li>
<p>次のコマンドを実行すると、フロントエンドのPodの数をスケールダウンできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment frontend --replicas<span style=color:#666>=</span><span style=color:#666>2</span>
</code></pre></div></li>
<li>
<p>Podのリストを問い合わせて、実行中のフロントエンドのPodの数を確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>結果は次のようになるはずです。</p>
<pre><code>NAME                            READY     STATUS    RESTARTS   AGE
frontend-3823415956-k22zn       1/1       Running   0          1h
frontend-3823415956-w9gbt       1/1       Running   0          1h
redis-master-1068406935-3lswp   1/1       Running   0          1h
redis-slave-2005841000-fpvqc    1/1       Running   0          1h
redis-slave-2005841000-phfv9    1/1       Running   0          1h
</code></pre></li>
</ol>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>DeploymentとServiceを削除すると、実行中のPodも削除されます。ラベルを使用すると、複数のリソースを1つのコマンドで削除できます。</p>
<ol>
<li>
<p>次のコマンドを実行すると、すべてのPod、Deployment、Serviceが削除されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>redis
kubectl delete service -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>redis
kubectl delete deployment -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook
kubectl delete service -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook
</code></pre></div><p>結果は次のようになるはずです。</p>
<pre><code>deployment.apps &quot;redis-master&quot; deleted
deployment.apps &quot;redis-slave&quot; deleted
service &quot;redis-master&quot; deleted
service &quot;redis-slave&quot; deleted
deployment.apps &quot;frontend&quot; deleted
service &quot;frontend&quot; deleted
</code></pre></li>
<li>
<p>Podのリストを問い合わせて、実行中のPodが存在しないことを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>結果は次のようになるはずです。</p>
<pre><code>No resources found.
</code></pre></li>
</ol>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>ゲストブックアプリケーションに対する<a href=/ja/docs/tutorials/stateless-application/guestbook-logs-metrics-with-elk/>ELKによるロギングとモニタリング</a></li>
<li><a href=/ja/docs/tutorials/kubernetes-basics/>Kubernetesの基本</a>のインタラクティブチュートリアルを終わらせる</li>
<li>Kubernetesを使って、<a href=/ja/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/#visit-your-new-wordpress-blog>MySQLとWordpressのためにPersistent Volume</a>を使用したブログを作成する</li>
<li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>サービスとアプリケーションの接続</a>についてもっと読む</li>
<li><a href=/ja/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively>リソースの管理</a>についてもっと読む</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ed6259076813e1eeeda484708812055b>5.4.3 - 例: PHP / Redisを使用したゲストブックの例にロギングとメトリクスを追加する</h1>
<p>このチュートリアルは、<a href=/ja/docs/tutorials/stateless-application/guestbook>Redisを使用したPHPのゲストブック</a>のチュートリアルを前提に作られています。Elasticが開発したログ、メトリクス、ネットワークデータを転送するオープンソースの軽量データシッパーである<em>Beats</em>を、ゲストブックと同じKubernetesクラスターにデプロイします。BeatsはElasticsearchに対してデータの収集、分析、インデックス作成を行うため、結果の運用情報をKibana上で表示・分析できるようになります。この例は、以下のコンポーネントから構成されます。</p>
<ul>
<li><a href=/ja/docs/tutorials/stateless-application/guestbook>Redisを使用したPHPのゲストブック</a>の実行中のインスタンス</li>
<li>ElasticsearchとKibana</li>
<li>Filebeat</li>
<li>Metricbeat</li>
<li>Packetbeat</li>
</ul>
<h2 id=目標>目標</h2>
<ul>
<li>Redisを使用したPHPのゲストブックを起動する。</li>
<li>kube-state-metricsをインストールする。</li>
<li>KubernetesのSecretを作成する。</li>
<li>Beatsをデプロイする。</li>
<li>ログとメトリクスのダッシュボードを表示する。</li>
</ul>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>追加で以下の作業が必要です。</p>
<ul>
<li>
<p><a href=/ja/docs/tutorials/stateless-application/guestbook>Redisを使用したPHPのゲストブック</a>チュートリアルの実行。</p>
</li>
<li>
<p>ElasticsearchとKibanaのdeploymentの実行。<a href=https://cloud.elastic.co>Elastic Cloud上のElasticsearchサービス</a>を使用するか、<a href=https://www.elastic.co/guide/en/elastic-stack-get-started/current/get-started-elastic-stack.html>ファイルをダウンロード</a>してワークステーションやサーバー上で実行するか、または<a href=https://github.com/elastic/helm-charts>Elastic Helm Chart</a>が使用できます。</p>
</li>
</ul>
<h2 id=redisを使用したphpのゲストブックを起動する>Redisを使用したPHPのゲストブックを起動する</h2>
<p>このチュートリアルは、<a href=/ja/docs/tutorials/stateless-application/guestbook>Redisを使用したPHPのゲストブック</a>のチュートリアルを前提に作られています。もしゲストブックアプリケーションが実行中なら、そのアプリケーションを監視できます。もしまだ実行中のアプリケーションがなければ、ゲストブックのデプロイの手順を行い、<strong>クリーンアップ</strong>のステップは実行しないでください。ゲストブックが起動したら、このページに戻ってきてください。</p>
<h2 id=cluster-role-bindingを追加する>Cluster role bindingを追加する</h2>
<p><a href=/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding>クラスターレベルのrole binding</a>を作成して、kube-state-metricsとBeatsをクラスターレベルで(kube-system内に)デプロイできるようにします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding cluster-admin-binding <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span> --clusterrole<span style=color:#666>=</span>cluster-admin --user<span style=color:#666>=</span>&lt;k8sのプロバイダーアカウントと紐付いたあなたのメールアドレス&gt;
</code></pre></div><h2 id=kube-state-metricsをインストールする>kube-state-metricsをインストールする</h2>
<p>Kubernetesの<a href=https://github.com/kubernetes/kube-state-metrics><em>kube-state-metrics</em></a>は、Kubernetes APIサーバーをlistenして、オブジェクトの状態に関するメトリクスを生成する単純なサービスです。Metricbeatはこれらのメトリクスを報告します。kube-state-metricsをゲストブックが実行されているKubernetesクラスターに追加しましょう。</p>
<h3 id=kube-state-metricsが起動しているか確認する>kube-state-metricsが起動しているか確認する</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --namespace<span style=color:#666>=</span>kube-system | grep kube-state
</code></pre></div><h3 id=必要に応じてkube-state-metricsをインストールする>必要に応じてkube-state-metricsをインストールする</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>git clone https://github.com/kubernetes/kube-state-metrics.git kube-state-metrics
kubectl apply -f kube-state-metrics/examples/standard
kubectl get pods --namespace<span style=color:#666>=</span>kube-system | grep kube-state-metrics
</code></pre></div><p>kube-state-metricsがRunningかつreadyの状態になっていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -n kube-system -l app.kubernetes.io/name<span style=color:#666>=</span>kube-state-metrics
</code></pre></div><p>結果は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                                 READY   STATUS    RESTARTS   AGE
kube-state-metrics-89d656bf8-vdthm   1/1     Running     <span style=color:#666>0</span>          21s
</code></pre></div><h2 id=githubリポジトリのelasticの例をクローンする>GitHubリポジトリのElasticの例をクローンする</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>git clone https://github.com/elastic/examples.git
</code></pre></div><p>これ以降のコマンドは<code>examples/beats-k8s-send-anywhere</code>ディレクトリ内のファイルを参照するため、カレントディレクトリを変更します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>cd</span> examples/beats-k8s-send-anywhere
</code></pre></div><h2 id=kubernetesのsecretを作成する>KubernetesのSecretを作成する</h2>
<p>Kubernetesの<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>とは、パスワード、トークン、または鍵などの小さなサイズの機密データを含んだオブジェクトのことです。このような機密情報はPodのspecやイメージの中に置くことも不可能ではありませんが、Secretオブジェクトの中に置くことで、情報の使用方法を適切に制御したり、誤って公開してしまうリスクを減らすことができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ここでは2種類の手順を紹介します。1つは<em>セルフマネージド</em>な(自分のサーバーで実行中またはElastic Helm Chartを使用して構築された)ElasticsearchおよびKibanaのためのもので、もう1つは<em>マネージドサービス</em>のElastic CloudのElasticsearch Serviceのための別の手順です。このチュートリアルで使う種類のElasticsearchおよびKibanaのシステムのためのSecretだけを作成してください。
</div>
<ul class="nav nav-tabs" id=tab-with-md role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-with-md-0 role=tab aria-controls=tab-with-md-0 aria-selected=true>セルフマネージド</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#tab-with-md-1 role=tab aria-controls=tab-with-md-1>マネージドサービス</a></li></ul>
<div class=tab-content id=tab-with-md><div id=tab-with-md-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-with-md-0>
<p><h3 id=セルフマネージド>セルフマネージド</h3>
<p>Elastic Cloud上のElasticsearch Serviceに接続する場合は、<strong>マネージドサービス</strong>タブに切り替えてください。</p>
<h3 id=クレデンシャルを設定する>クレデンシャルを設定する</h3>
<p>セルフマネージドのElasticsearchとKibanaへ接続する場合、KubernetesのSecretを作成するために編集するべきファイルは4つあります(セルフマネージドとは、事実上Elastic Cloud以外で実行されているElasticsearch Serviceを指します)。ファイルは次の4つです。</p>
<ol>
<li>ELASTICSEARCH_HOSTS</li>
<li>ELASTICSEARCH_PASSWORD</li>
<li>ELASTICSEARCH_USERNAME</li>
<li>KIBANA_HOST</li>
</ol>
<p>これらのファイルにElasticsearchクラスターとKibanaホストの情報を設定してください。ここでは例をいくつか示します(<a href=https://stackoverflow.com/questions/59892896/how-to-connect-from-minikube-to-elasticsearch-installed-on-host-local-developme/59892897#59892897><em>こちらの設定</em></a>も参照してください)。</p>
<h4 id=elasticsearch-hosts><code>ELASTICSEARCH_HOSTS</code></h4>
<ol>
<li>
<p>Elastic Elasticsearch Helm Chartで作成したnodeGroupの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#666>[</span><span style=color:#b44>&#34;http://elasticsearch-master.default.svc.cluster.local:9200&#34;</span><span style=color:#666>]</span>
</code></pre></div></li>
<li>
<p>Mac上で単一のElasticsearchノードが実行されており、BeatsがDocker for Macで実行中の場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#666>[</span><span style=color:#b44>&#34;http://host.docker.internal:9200&#34;</span><span style=color:#666>]</span>
</code></pre></div></li>
<li>
<p>2ノードのElasticsearchがVM上または物理ハードウェア上で実行中の場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#666>[</span><span style=color:#b44>&#34;http://host1.example.com:9200&#34;</span>, <span style=color:#b44>&#34;http://host2.example.com:9200&#34;</span><span style=color:#666>]</span>
</code></pre></div></li>
</ol>
<p><code>ELASTICSEARCH_HOSTS</code>を編集します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>vi ELASTICSEARCH_HOSTS
</code></pre></div><h4 id=elasticsearch-password><code>ELASTICSEARCH_PASSWORD</code></h4>
<p>パスワードだけを書きます。空白、クォート、&lt;>などの文字は書かないでください。</p>
<pre><code>&lt;yoursecretpassword&gt;
</code></pre>
<p><code>ELASTICSEARCH_PASSWORD</code>を編集します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>vi ELASTICSEARCH_PASSWORD
</code></pre></div><h4 id=elasticsearch-username><code>ELASTICSEARCH_USERNAME</code></h4>
<p>ユーザー名だけを書きます。空白、クォート、&lt;>などの文字は書かないでください。</p>
<pre><code>&lt;Elasticsearchに追加するユーザー名&gt;
</code></pre>
<p><code>ELASTICSEARCH_USERNAME</code>を編集します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>vi ELASTICSEARCH_USERNAME
</code></pre></div><h4 id=kibana-host><code>KIBANA_HOST</code></h4>
<ol>
<li>
<p>Elastic Kibana Helm Chartで作成したKibanaインスタンスが実行中の場合。<code>default</code>というサブドメインは、default Namespaceを指します。もしHelm Chartを別のNamespaceにデプロイした場合、サブドメインは異なります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b44>&#34;kibana-kibana.default.svc.cluster.local:5601&#34;</span>
</code></pre></div></li>
<li>
<p>Mac上でKibanaインスタンスが実行中で、BeatsがDocker for Macで実行中の場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b44>&#34;host.docker.internal:5601&#34;</span>
</code></pre></div></li>
<li>
<p>2つのElasticsearchノードが、VMまたは物理ハードウェア上で実行中の場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b44>&#34;host1.example.com:5601&#34;</span>
</code></pre></div></li>
</ol>
<p><code>KIBANA_HOST</code>を編集します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>vi KIBANA_HOST
</code></pre></div><h3 id=kubernetesのsecretを作成する>KubernetesのSecretを作成する</h3>
<p>次のコマンドを実行すると、KubernetesのシステムレベルのNamespace(kube-system)に、たった今編集したファイルを元にSecretが作成されます。</p>
<pre><code>kubectl create secret generic dynamic-logging \
  --from-file=./ELASTICSEARCH_HOSTS \
  --from-file=./ELASTICSEARCH_PASSWORD \
  --from-file=./ELASTICSEARCH_USERNAME \
  --from-file=./KIBANA_HOST \
  --namespace=kube-system
</code></pre>
</div>
<div id=tab-with-md-1 class=tab-pane role=tabpanel aria-labelledby=tab-with-md-1>
<p><h2 id=マネージドサービス>マネージドサービス</h2>
<p>このタブは、Elastic Cloud上のElasticsearch Serviceの場合のみ必要です。もしセルフマネージドのElasticsearchとKibanaのDeployment向けにSecretをすでに作成した場合、<a href=#deploy-the-beats>Beatsをデプロイする</a>に進んでください。</p>
<h3 id=クレデンシャルを設定する>クレデンシャルを設定する</h3>
<p>Elastic Cloud上のマネージドElasticsearch Serviceに接続する場合、KubernetesのSecretを作成するために編集する必要があるのは、次の2つのファイルです。</p>
<ol>
<li>ELASTIC_CLOUD_AUTH</li>
<li>ELASTIC_CLOUD_ID</li>
</ol>
<p>Deploymentを作成するときに、Elasticsearch Serviceのコンソールから提供された情報を設定してください。以下に例を示します。</p>
<h4 id=elastic-cloud-id>ELASTIC_CLOUD_ID</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>devk8s:ABC123def456ghi789jkl123mno456pqr789stu123vwx456yza789bcd012efg345hijj678klm901nop345zEwOTJjMTc5YWQ0YzQ5OThlN2U5MjAwYTg4NTIzZQ<span style=color:#666>==</span>
</code></pre></div><h4 id=elastic-cloud-auth>ELASTIC_CLOUD_AUTH</h4>
<p>ユーザー名、コロン(<code>:</code>)、パスワードだけを書きます。空白やクォートは書かないでください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>elastic:VFxJJf9Tjwer90wnfTghsn8w
</code></pre></div><h3 id=必要なファイルを編集する>必要なファイルを編集する</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>vi ELASTIC_CLOUD_ID
vi ELASTIC_CLOUD_AUTH
</code></pre></div><h3 id=kubernetesのsecretを作成する>KubernetesのSecretを作成する</h3>
<p>次のコマンドを実行すると、KubernetesのシステムレベルのNamespace(kube-system)に、たった今編集したファイルを元にSecretが作成されます。</p>
<pre><code>kubectl create secret generic dynamic-logging \
  --from-file=./ELASTIC_CLOUD_ID \
  --from-file=./ELASTIC_CLOUD_AUTH \
  --namespace=kube-system
</code></pre>
</div></div>
<h2 id=deploy-the-beats>Beatsをデプロイする</h2>
<p>マニフェストファイルはBeatごとに提供されます。これらのマニフェストファイルは、上で作成したSecretを使用して、BeatsをElasticsearchおよびKibanaサーバーに接続するように設定します。</p>
<h3 id=filebeatについて>Filebeatについて</h3>
<p>Filebeatは、Kubernetesのノードと、ノード上で実行している各Pod内のコンテナから、ログを収集します。Filebeatは<a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>としてデプロイされます。FilebeatはKubernetesクラスター上で実行されているアプリケーションを自動検出することもできます。起動時にFilebeatは既存のコンテナをスキャンし、それらに対して適切な設定を立ち上げ、その後、新しいstart/stopイベントを監視します。</p>
<p>Filebeatが、ゲストブックアプリケーションでデプロイしたRedisコンテナからRedisのログを特定・解析できるように自動検出を設定する例を示します。この設定は<code>filebeat-kubernetes.yaml</code>ファイル内にあります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>- <span style=color:green;font-weight:700>condition.contains</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.labels.app</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>module</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>log</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>input</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>docker<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containers.ids</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- ${data.kubernetes.container.id}<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>slowlog</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>enabled</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>var.hosts</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;${data.host}:${data.port}&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>この設定により、Filebeatは、<code>app</code>ラベルに<code>redis</code>という文字列が含まれるコンテナを検出したときに<code>redis</code> Filebeatモジュールを適用するようになります。redisモジュールには、input typeとしてdockerを使用することで(このRedisコンテナの標準出力のストリームと関連付けられた、Kubernetesノード上のファイルを読み取ることで)コンテナから<code>log</code>ストリームを収集する機能があります。さらに、このモジュールには、コンテナのメタデータとして提供された適切なPodのホストとポートと接続することにより、Redisの<code>slowlog</code>エントリーを収集する機能もあります。</p>
<h3 id=filebeatをデプロイする>Filebeatをデプロイする</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f filebeat-kubernetes.yaml
</code></pre></div><h4 id=検証する>検証する</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -n kube-system -l k8s-app<span style=color:#666>=</span>filebeat-dynamic
</code></pre></div><h3 id=metricbeatについて>Metricbeatについて</h3>
<p>Metricbeatの自動検出はFilebeatと同じ方法で設定します。以下にMetricbeatにおけるRedisコンテナの自動検出の設定を示します。この設定は<code>metricbeat-kubernetes.yaml</code>ファイル内にあります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>- <span style=color:green;font-weight:700>condition.equals</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.labels.tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>module</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metricsets</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;info&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;keyspace&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>period</span>:<span style=color:#bbb> </span>10s<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Redis hosts</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hosts</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;${data.host}:${data.port}&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>この設定により、Metricbeatは、<code>tier</code>ラベルに<code>backend</code>という文字列が含まれるコンテナを検出したときに<code>redis</code> Metricbeatモジュールを適用するようになります。redisモジュールには、コンテナのメタデータとして提供された適切なPodのホストとポートと接続することにより、コンテナから<code>info</code>および<code>keyspace</code>メトリクスを収集する機能があります。</p>
<h3 id=metricbeatをデプロイする>Metricbeatをデプロイする</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f metricbeat-kubernetes.yaml
</code></pre></div><h4 id=検証する-1>検証する</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -n kube-system -l k8s-app<span style=color:#666>=</span>metricbeat
</code></pre></div><h3 id=packetbeatについて>Packetbeatについて</h3>
<p>Packetbeatの設定は、FilebeatやMetricbeatとは異なります。コンテナのラベルに対するパターンマッチを指定する代わりに、関連するプロトコルとポート番号に基づいた設定を書きます。以下に示すのは、ポート番号のサブセットです。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> サービスを標準ポート以外で実行している場合、そのポート番号を<code>filebeat.yaml</code>内の適切なtypeに追加し、PacketbeatのDaemonSetを削除・再作成してください。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>packetbeat.interfaces.device</span>:<span style=color:#bbb> </span>any<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>packetbeat.protocols</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>dns<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb> </span>[<span style=color:#666>53</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>include_authorities</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>include_additionals</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb> </span>[<span style=color:#666>80</span>,<span style=color:#bbb> </span><span style=color:#666>8000</span>,<span style=color:#bbb> </span><span style=color:#666>8080</span>,<span style=color:#bbb> </span><span style=color:#666>9200</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb> </span>[<span style=color:#666>3306</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb> </span>[<span style=color:#666>6379</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>packetbeat.flows</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>timeout</span>:<span style=color:#bbb> </span>30s<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>period</span>:<span style=color:#bbb> </span>10s<span style=color:#bbb>
</span></code></pre></div><h4 id=packetbeatをデプロイする>Packetbeatをデプロイする</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f packetbeat-kubernetes.yaml
</code></pre></div><h4 id=検証する-2>検証する</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -n kube-system -l k8s-app<span style=color:#666>=</span>packetbeat-dynamic
</code></pre></div><h2 id=kibanaで表示する>Kibanaで表示する</h2>
<p>ブラウザでKibanaを開き、<strong>Dashboard</strong>アプリケーションを開きます。検索バーでKubernetesと入力して、KubernetesのためのMetricbeatダッシュボードを開きます。このダッシュボードでは、NodeやDeploymentなどの状態のレポートが表示されます。</p>
<p>DashboardページでPacketbeatと検索し、Packetbeat overviewを表示します。</p>
<p>同様に、ApacheおよびRedisのためのDashboardを表示します。それぞれに対してログとメトリクスのDashboardが表示されます。Apache Metricbeat dashboardには何も表示されていないはずです。Apache Filebeat dashboardを表示して、ページの最下部までスクロールしてApacheのエラーログを確認します。ログを読むと、Apacheのメトリクスが表示されない理由が分かります。</p>
<p>Metricbeatを有効にしてApacheのメトリクスを取得するには、mod-status設定ファイルを含んだConfigMapを追加してゲストブックを再デプロイすることで、server-statusを有効にします。</p>
<h2 id=deploymentをスケールして新しいpodが監視されるのを確認する>Deploymentをスケールして新しいPodが監視されるのを確認する</h2>
<p>存在するDeploymentを一覧します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployments
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME            READY   UP-TO-DATE   AVAILABLE   AGE
frontend        3/3     <span style=color:#666>3</span>            <span style=color:#666>3</span>           3h27m
redis-master    1/1     <span style=color:#666>1</span>            <span style=color:#666>1</span>           3h27m
redis-slave     2/2     <span style=color:#666>2</span>            <span style=color:#666>2</span>           3h27m
</code></pre></div><p>frontendのPodを2つにスケールダウンします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>2</span> deployment/frontend
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.extensions/frontend scaled
</code></pre></div><p>frontendのPodを再び3つにスケールアップします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> deployment/frontend
</code></pre></div><h2 id=kibana上で変更を表示する>Kibana上で変更を表示する</h2>
<p>スクリーンショットを確認し、指定されたフィルターを追加して、ビューにカラムを追加します。赤い枠の右下を見ると、ScalingReplicaSetというエントリーが確認できます。そこからリストを上に見てゆくと、イメージのpull、ボリュームのマウント、Podのスタートなどのイベントが確認できます。</p>
<p><img src=https://raw.githubusercontent.com/elastic/examples/master/beats-k8s-send-anywhere/scaling-up.png alt="Kibana Discover"></p>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>DeploymentとServiceを削除すると、実行中のすべてのPodも削除されます。ラベルを使って複数のリソースを1つのコマンドで削除します。</p>
<ol>
<li>
<p>次のコマンドを実行して、すべてのPod、Deployment、Serviceを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>redis
kubectl delete service -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>redis
kubectl delete deployment -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook
kubectl delete service -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook
kubectl delete -f filebeat-kubernetes.yaml
kubectl delete -f metricbeat-kubernetes.yaml
kubectl delete -f packetbeat-kubernetes.yaml
kubectl delete secret dynamic-logging -n kube-system
</code></pre></div></li>
<li>
<p>Podの一覧を問い合わせて、実行中のPodがなくなったことを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>結果は次のようになるはずです。</p>
<pre><code>No resources found.
</code></pre></li>
</ol>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>リソースを監視するためのツール</a>について学ぶ。</li>
<li><a href=/docs/concepts/cluster-administration/logging/>ロギングのアーキテクチャ</a>についてもっと読む。</li>
<li><a href=/ja/docs/tasks/debug-application-cluster/>アプリケーションのイントロスペクションとデバッグ</a>についてもっと読む。</li>
<li><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>アプリケーションのトラブルシューティング</a>についてもっと読む。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d6336d9712aa433eb5f0fb8cbed6bef7>5.5 - ステートフルアプリケーション</h1>
</div>
<div class=td-content>
<h1 id=pg-42e39658021b706bcc9478c8cc73c4a3>5.5.1 - StatefulSetの基本</h1>
<p>このチュートリアルでは、<a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>を使用したアプリケーションを管理するための基本を説明します。StatefulSetのPodを作成、削除、スケール、そして更新する方法について紹介します。</p>
<h2 id=始める前に>始める前に</h2>
<p>このチュートリアルを始める前に、以下のKubernetesの概念について理解しておく必要があります。</p>
<ul>
<li><a href=/ja/docs/concepts/workloads/pods/>Pod</a></li>
<li><a href=/ja/docs/concepts/services-networking/dns-pod-service/>Cluster DNS</a></li>
<li><a href=/ja/docs/concepts/services-networking/service/#headless-services>Headless Service</a></li>
<li><a href=/ja/docs/concepts/storage/persistent-volumes/>PersistentVolume</a></li>
<li><a href=https://github.com/kubernetes/examples/tree/v1.22.16/staging/persistent-volume-provisioning/>PersistentVolumeのプロビジョニング</a></li>
<li><a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li>
<li><a href=/docs/reference/kubectl/kubectl/>kubectl</a>コマンドラインツール</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このチュートリアルでは、クラスターがPersistentVolumeの動的なプロビジョニングが行われるように設定されていることを前提としています。クラスターがそのように設定されていない場合、チュートリアルを始める前に1GiBのボリュームを2つ手動でプロビジョニングする必要があります。
</div>
<h2 id=目標>目標</h2>
<p>StatefulSetはステートフルアプリケーションや分散システムで使用するために存在します。しかし、Kubernetes上のステートフルアプリケーションや分散システムは、広範で複雑なトピックです。StatefulSetの基本的な機能を示すという目的のため、また、ステートフルアプリケーションを分散システムと混同しないようにするために、ここでは、Statefulsetを使用する単純なウェブアプリケーションのデプロイを行います。</p>
<p>このチュートリアルを終えると、以下のことが理解できるようになります。</p>
<ul>
<li>StatefulSetの作成方法</li>
<li>StatefulSetがどのようにPodを管理するのか</li>
<li>StatefulSetの削除方法</li>
<li>StatefulSetのスケール方法</li>
<li>StatefulSetが管理するPodの更新方法</li>
</ul>
<h2 id=ordered-pod-creation>StatefulSetを作成する</h2>
<p>はじめに、以下の例を使ってStatefulSetを作成しましょう。これは、コンセプトの<a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>のページで使ったものと同じような例です。<code>nginx</code>という<a href=/ja/docs/concepts/services-networking/service/#headless-services>headless Service</a>を作成し、<code>web</code>というStatefulSet内のPodのIPアドレスを公開します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/web/web.yaml download=application/web/web.yaml><code>application/web/web.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-web-web-yaml')" title="Copy application/web/web.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-web-web-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginx&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/nginx-slim:0.8<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>上の例をダウンロードして、<code>web.yaml</code>という名前で保存します。</p>
<p>ここでは、ターミナルウィンドウを2つ使う必要があります。1つ目のターミナルでは、<a href=/docs/reference/generated/kubectl/kubectl-commands/#get><code>kubectl get</code></a>を使って、StatefulSetのPodの作成を監視します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><p>2つ目のターミナルでは、<a href=/docs/reference/generated/kubectl/kubectl-commands/#apply><code>kubectl apply</code></a>を使って、<code>web.yaml</code>に定義されたheadless ServiceとStatefulSetを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f web.yaml
</code></pre></div><pre><code>service/nginx created
statefulset.apps/web created
</code></pre><p>上のコマンドを実行すると、2つのPodが作成され、それぞれのPodで<a href=https://www.nginx.com>NGINX</a>ウェブサーバーが実行されます。<code>nginx</code>Serviceを取得してみましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service nginx
</code></pre></div><pre><code>NAME      TYPE         CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
nginx     ClusterIP    None         &lt;none&gt;        80/TCP    12s
</code></pre><p>そして、<code>web</code>StatefulSetを取得して、2つのリソースの作成が成功したことも確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get statefulset web
</code></pre></div><pre><code>NAME      DESIRED   CURRENT   AGE
web       2         1         20s
</code></pre><h3 id=順序付きpodの作成>順序付きPodの作成</h3>
<p><em>n</em> 個のレプリカを持つStatefulSetは、Podをデプロイするとき、1つずつ順番に作成し、 <em>{0..n-1}</em> という順序付けを行います。1つ目のターミナルで<code>kubectl get</code>コマンドの出力を確認しましょう。最終的に、以下の例のような出力が表示されるはずです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     0/1       Pending   0          0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         19s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         18s
</code></pre><p><code>web-0</code>Podが <em>Running</em> (<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase>Pod Phase</a>を参照)かつ <em>Ready</em> (<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions>Pod Conditions</a>の<code>type</code>を参照)の状態になるまでは、<code>web-1</code>Podが起動していないことに注目してください。</p>
<h2 id=statefulset内のpod>StatefulSet内のPod</h2>
<p>StatefulSet内のPodは、ユニークな順序インデックスと安定したネットワーク識別子を持ちます。</p>
<h3 id=podの順序インデックスを確かめる>Podの順序インデックスを確かめる</h3>
<p>StatefulSetのPodを取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          1m
web-1     1/1       Running   0          1m
</code></pre><p><a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>のコンセプトで説明したように、StatefulSet内のPodは安定したユニークな識別子を持ちます。この識別子は、StatefulSet<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>によって各Podに割り当てられる、ユニークな順序インデックスに基づいて付けられます。Podの名前は、<code>&lt;statefulsetの名前>-&lt;順序インデックス></code>という形式です。<code>web</code>StatefulSetは2つのレプリカを持つため、<code>web-0</code>と<code>web-1</code>という2つのPodを作成します。</p>
<h3 id=安定したネットワーク識別子の使用>安定したネットワーク識別子の使用</h3>
<p>各Podは、順序インデックスに基づいた安定したホスト名を持ちます。<a href=/docs/reference/generated/kubectl/kubectl-commands/#exec><code>kubectl exec</code></a>を使用して、各Pod内で<code>hostname</code>コマンドを実行してみましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>0</span> 1; <span style=color:#a2f;font-weight:700>do</span> kubectl <span style=color:#a2f>exec</span> <span style=color:#b44>&#34;web-</span><span style=color:#b8860b>$i</span><span style=color:#b44>&#34;</span> -- sh -c <span style=color:#b44>&#39;hostname&#39;</span>; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><pre><code>web-0
web-1
</code></pre><p><a href=/docs/reference/generated/kubectl/kubectl-commands/#run><code>kubectl run</code></a>を使用して、<code>dnsutils</code>パッケージの<code>nslookup</code>コマンドを提供するコンテナを実行します。Podのホスト名に対して<code>nslookup</code>を実行すると、クラスター内のDNSアドレスが確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run -i --tty --image busybox:1.28 dns-test --restart<span style=color:#666>=</span>Never --rm
</code></pre></div><p>これにより、新しいシェルが起動します。新しいシェルで、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、dns-testコンテナのシェルで実行してください</span>
nslookup web-0.nginx
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-0.nginx
Address 1: 10.244.1.6

nslookup web-1.nginx
Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-1.nginx
Address 1: 10.244.2.6
</code></pre><p>(コンテナのシェルを終了するために、<code>exit</code>コマンドを実行してください。)</p>
<p>headless serviceのCNAMEは、SRVレコードを指しています(1つのレコードがRunningかつReadyのPodに対応します)。SRVレコードは、PodのIPアドレスを含むAレコードを指します。</p>
<p>1つ目のターミナルで、StatefulSetのPodを監視します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><p>2つ目のターミナルで、<a href=/docs/reference/generated/kubectl/kubectl-commands/#delete><code>kubectl delete</code></a>を使用して、StatefulSetのすべてのPodを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><pre><code>pod &quot;web-0&quot; deleted
pod &quot;web-1&quot; deleted
</code></pre><p>StatefulSetがPodを再起動して、2つのPodがRunningかつReadyの状態に移行するのを待ちます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><pre><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     0/1       ContainerCreating   0          0s
NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          2s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         34s
</code></pre><p><code>kubectl exec</code>と<code>kubectl run</code>コマンドを使用して、Podのホスト名とクラスター内DNSエントリーを確認します。まず、Podのホスト名を見てみましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>0</span> 1; <span style=color:#a2f;font-weight:700>do</span> kubectl <span style=color:#a2f>exec</span> web-<span style=color:#b8860b>$i</span> -- sh -c <span style=color:#b44>&#39;hostname&#39;</span>; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><pre><code>web-0
web-1
</code></pre><p>その後、次のコマンドを実行します。</p>
<pre><code>kubectl run -i --tty --image busybox:1.28 dns-test --restart=Never --rm /bin/sh
</code></pre><p>これにより、新しいシェルが起動します。新しいシェルで、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、dns-testコンテナのシェルで実行してください</span>
nslookup web-0.nginx
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-0.nginx
Address 1: 10.244.1.7

nslookup web-1.nginx
Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-1.nginx
Address 1: 10.244.2.8
</code></pre><p>(コンテナのシェルを終了するために、<code>exit</code>コマンドを実行してください。)</p>
<p>Podの順序インデックス、ホスト名、SRVレコード、そしてAレコード名は変化していませんが、Podに紐付けられたIPアドレスは変化する可能性があります。このチュートリアルで使用しているクラスターでは、IPアドレスは変わりました。このようなことがあるため、他のアプリケーションがStatefulSet内のPodに接続するときには、IPアドレスで指定しないことが重要です。</p>
<p>StatefulSetの有効なメンバーを探して接続する必要がある場合は、headless ServiceのCNAME(<code>nginx.default.svc.cluster.local</code>)をクエリしなければなりません。CNAMEに紐付けられたSRVレコードには、StatefulSet内のRunnningかつReadyなPodだけが含まれます。</p>
<p>アプリケーションがlivenessとreadinessをテストするコネクションのロジックをすでに実装している場合、PodのSRVレコード(<code>web-0.nginx.default.svc.cluster.local</code>、<code>web-1.nginx.default.svc.cluster.local</code>)をPodが安定しているものとして使用できます。PodがRunning and Readyな状態に移行すれば、アプリケーションはPodのアドレスを発見できるようになります。</p>
<h3 id=writing-to-stable-storage>安定したストレージへの書き込み</h3>
<p><code>web-0</code>および<code>web-1</code>のためのPersistentVolumeClaimを取得しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           48s
www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           48s
</code></pre><p>StatefulSetコントローラーは、2つの<a class=glossary-tooltip title=クラスター内のストレージの一部を表すAPIオブジェクトです。通常利用可能で、個々のPodのライフサイクルの先にあるプラグイン形式のリソースです。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PersistentVolume>PersistentVolume</a>にバインドされた2つの<a class=glossary-tooltip title=コンテナ内でボリュームとしてマウントするためにPersistentVolume内で定義されたストレージリソースを要求します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PersistentVolumeClaim>PersistentVolumeClaim</a>を作成しています。</p>
<p>このチュートリアルで使用しているクラスターでは、PersistentVolumeの動的なプロビジョニングが設定されているため、PersistentVolumeが自動的に作成されてバインドされています。</p>
<p>デフォルトでは、NGINXウェブサーバーは<code>/usr/share/nginx/html/index.html</code>に置かれたindexファイルを配信します。StatefulSetの<code>spec</code>内の<code>volumeMounts</code>フィールドによって、<code>/usr/share/nginx/html</code>ディレクトリがPersistentVolume上にあることが保証されます。</p>
<p>Podのホスト名を<code>index.html</code>ファイルに書き込むことで、NGINXウェブサーバーがホスト名を配信することを検証しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>0</span> 1; <span style=color:#a2f;font-weight:700>do</span> kubectl <span style=color:#a2f>exec</span> <span style=color:#b44>&#34;web-</span><span style=color:#b8860b>$i</span><span style=color:#b44>&#34;</span> -- sh -c <span style=color:#b44>&#39;echo &#34;$(hostname)&#34; &gt; /usr/share/nginx/html/index.html&#39;</span>; <span style=color:#a2f;font-weight:700>done</span>

<span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>0</span> 1; <span style=color:#a2f;font-weight:700>do</span> kubectl <span style=color:#a2f>exec</span> -i -t <span style=color:#b44>&#34;web-</span><span style=color:#b8860b>$i</span><span style=color:#b44>&#34;</span> -- curl http://localhost/; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><pre><code>web-0
web-1
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>上記のcurlコマンドに対して代わりに<strong>403 Forbidden</strong>というレスポンスが返ってくる場合、<code>volumeMounts</code>でマウントしたディレクトリのパーミッションを修正する必要があります(これは、<a href=https://github.com/kubernetes/kubernetes/issues/2630>hostPathボリュームを使用したときに起こるバグ</a>が原因です)。この問題に対処するには、上の<code>curl</code>コマンドを再実行する前に、次のコマンドを実行します。</p>
<p><code>for i in 0 1; do kubectl exec web-$i -- chmod 755 /usr/share/nginx/html; done</code></p>
</div>
<p>1つ目のターミナルで、StatefulSetのPodを監視します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><p>2つ目のターミナルで、StatefulSetのすべてのPodを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><pre><code>pod &quot;web-0&quot; deleted
pod &quot;web-1&quot; deleted
</code></pre><p>1つ目のターミナルで<code>kubectl get</code>コマンドの出力を確認して、すべてのPodがRunningかつReadyの状態に変わるまで待ちます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><pre><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     0/1       ContainerCreating   0          0s
NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          2s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         34s
</code></pre><p>ウェブサーバーがホスト名を配信し続けていることを確認します。</p>
<pre><code>for i in 0 1; do kubectl exec -i -t &quot;web-$i&quot; -- curl http://localhost/; done
</code></pre><pre><code>web-0
web-1
</code></pre><p>もし<code>web-0</code>および<code>web-1</code>が再スケジュールされたとしても、Podは同じホスト名を配信し続けます。これは、PodのPersistentVolumeClaimに紐付けられたPersistentVolumeが、Podの<code>volumeMounts</code>に再マウントされるためです。<code>web-0</code>と<code>web-1</code>がどんなノードにスケジュールされたとしても、PodのPersistentVolumeは適切なマウントポイントにマウントされます。</p>
<h2 id=statefulsetをスケールする>StatefulSetをスケールする</h2>
<p>StatefulSetのスケールとは、レプリカ数を増減することを意味します。これは、<code>replicas</code>フィールドを更新することによって実現できます。StatefulSetのスケールには、<a href=/docs/reference/generated/kubectl/kubectl-commands/#scale><code>kubectl scale</code></a>と
<a href=/docs/reference/generated/kubectl/kubectl-commands/#patch><code>kubectl patch</code></a>のどちらも使用できます。</p>
<h3 id=スケールアップ>スケールアップ</h3>
<p>1つ目のターミナルで、StatefulSet内のPodを監視します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><p>2つ目のターミナルで、<code>kubectl scale</code>を使って、レプリカ数を5にスケールします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale sts web --replicas<span style=color:#666>=</span><span style=color:#666>5</span>
</code></pre></div><pre><code>statefulset.apps/web scaled
</code></pre><p>1つ目のターミナルの<code>kubectl get</code>コマンドの出力を確認して、3つの追加のPodがRunningかつReadyの状態に変わるまで待ちます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          2h
web-1     1/1       Running   0          2h
NAME      READY     STATUS    RESTARTS   AGE
web-2     0/1       Pending   0          0s
web-2     0/1       Pending   0         0s
web-2     0/1       ContainerCreating   0         0s
web-2     1/1       Running   0         19s
web-3     0/1       Pending   0         0s
web-3     0/1       Pending   0         0s
web-3     0/1       ContainerCreating   0         0s
web-3     1/1       Running   0         18s
web-4     0/1       Pending   0         0s
web-4     0/1       Pending   0         0s
web-4     0/1       ContainerCreating   0         0s
web-4     1/1       Running   0         19s
</code></pre><p>StatefulSetコントローラーはレプリカ数をスケールします。
<a href=#ordered-pod-creation>StatefulSetを作成する</a>で説明したように、StatefulSetコントローラーは各Podを順序インデックスに従って1つずつ作成し、次のPodを起動する前に、1つ前のPodがRunningかつReadyの状態になるまで待ちます。</p>
<h3 id=scaling-down>スケールダウン</h3>
<p>1つ目のターミナルで、StatefulSetのPodを監視します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><p>2つ目のターミナルで、<code>kubectl patch</code>コマンドを使用して、StatefulSetを3つのレプリカにスケールダウンします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch sts web -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;replicas&#34;:3}}&#39;</span>
</code></pre></div><pre><code>statefulset.apps/web patched
</code></pre><p><code>web-4</code>および<code>web-3</code>がTerminatingの状態になるまで待ちます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><pre><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          3h
web-1     1/1       Running             0          3h
web-2     1/1       Running             0          55s
web-3     1/1       Running             0          36s
web-4     0/1       ContainerCreating   0          18s
NAME      READY     STATUS    RESTARTS   AGE
web-4     1/1       Running   0          19s
web-4     1/1       Terminating   0         24s
web-4     1/1       Terminating   0         24s
web-3     1/1       Terminating   0         42s
web-3     1/1       Terminating   0         42s
</code></pre><h3 id=順序付きpodを削除する>順序付きPodを削除する</h3>
<p>コントローラーは、順序インデックスの逆順に1度に1つのPodを削除し、次のPodを削除する前には、各Podが完全にシャットダウンするまで待機しています。</p>
<p>StatefulSetのPersistentVolumeClaimを取得しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><pre><code>NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-2   Bound     pvc-e1125b27-b508-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-3   Bound     pvc-e1176df6-b508-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-4   Bound     pvc-e11bb5f8-b508-11e6-932f-42010a800002   1Gi        RWO           13h

</code></pre><p>まだ、5つのPersistentVolumeClaimと5つのPersistentVolumeが残っています。<a href=#writing-to-stable-storage>安定したストレージへの書き込み</a>を読むと、StatefulSetのPodが削除されても、StatefulSetのPodにマウントされたPersistentVolumeは削除されないと書かれています。このことは、StatefulSetのスケールダウンによってPodが削除された場合にも当てはまります。</p>
<h2 id=updating-statefulsets>StatefulSetsを更新する</h2>
<p>Kubernetes 1.7以降では、StatefulSetコントローラーは自動アップデートをサポートしています。使われる戦略は、StatefulSet APIオブジェクトの<code>spec.updateStrategy</code>フィールドによって決まります。この機能はコンテナイメージのアップグレード、リソースのrequestsやlimits、ラベル、StatefulSet内のPodのアノテーションの更新時に利用できます。有効なアップデートの戦略は、<code>RollingUpdate</code>と<code>OnDelete</code>の2種類です。</p>
<p><code>RollingUpdate</code>は、StatefulSetのデフォルトのアップデート戦略です。</p>
<h3 id=rollingupdate>RollingUpdate</h3>
<p><code>RollingUpdate</code>アップデート戦略は、StatefulSetの保証を尊重しながら、順序インデックスの逆順にStatefulSet内のすべてのPodをアップデートします。</p>
<p><code>web</code>StatefulSetにpatchを当てて、<code>RollingUpdate</code>アップデート戦略を適用しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch statefulset web -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;updateStrategy&#34;:{&#34;type&#34;:&#34;RollingUpdate&#34;}}}&#39;</span>
</code></pre></div><pre><code>statefulset.apps/web patched
</code></pre><p>1つ目のターミナルで、<code>web</code>StatefulSetに再度patchを当てて、コンテナイメージを変更します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch statefulset web --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/image&#34;, &#34;value&#34;:&#34;gcr.io/google_containers/nginx-slim:0.8&#34;}]&#39;</span>
</code></pre></div><pre><code>statefulset.apps/web patched
</code></pre><p>2つ目のターミナルで、StatefulSet内のPodを監視します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          7m
web-1     1/1       Running   0          7m
web-2     1/1       Running   0          8m
web-2     1/1       Terminating   0         8m
web-2     1/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Pending   0         0s
web-2     0/1       Pending   0         0s
web-2     0/1       ContainerCreating   0         0s
web-2     1/1       Running   0         19s
web-1     1/1       Terminating   0         8m
web-1     0/1       Terminating   0         8m
web-1     0/1       Terminating   0         8m
web-1     0/1       Terminating   0         8m
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         6s
web-0     1/1       Terminating   0         7m
web-0     1/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Pending   0         0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         10s
</code></pre><p>StatefulSet内のPodは、順序インデックスの逆順に更新されました。StatefulSetコントローラーは各Podを終了させ、次のPodを更新する前に、新しいPodがRunningかつReadyの状態に変わるまで待機します。ここで、StatefulSetコントローラーは順序インデックスの前のPodがRunningかつReadyの状態になるまで次のPodの更新を始めず、現在の状態へのアップデートに失敗したPodがあった場合、そのPodをリストアすることに注意してください。</p>
<p>すでにアップデートを受け取ったPodは、アップデートされたバージョンにリストアされます。まだアップデートを受け取っていないPodは、前のバージョンにリストアされます。このような方法により、もし途中で失敗が起こっても、コントローラはアプリケーションが健全な状態を保ち続けられるようにし、更新が一貫したものになるようにします。</p>
<p>Podを取得して、コンテナイメージを確認してみましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> p in <span style=color:#666>0</span> <span style=color:#666>1</span> 2; <span style=color:#a2f;font-weight:700>do</span> kubectl get pod <span style=color:#b44>&#34;web-</span><span style=color:#b8860b>$p</span><span style=color:#b44>&#34;</span> --template <span style=color:#b44>&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>; echo; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><pre><code>k8s.gcr.io/nginx-slim:0.8
k8s.gcr.io/nginx-slim:0.8
k8s.gcr.io/nginx-slim:0.8

</code></pre><p>現在、StatefulSet内のすべてのPodは、前のコンテナイメージを実行しています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>kubectl rollout status sts/&lt;name></code>を使って、StatefulSetへのローリングアップデートの状態を確認することもできます。
</div>
<h4 id=staging-an-update>ステージングアップデート</h4>
<p><code>RollingUpdate</code>アップデート戦略に<code>partition</code>パラメーターを使用すると、StatefulSetへのアップデートをステージングすることができます。ステージングアップデートを利用すれば、StatefulSet内のすべてのPodを現在のバージョンにしたまま、StatefulSetの<code>.spec.template</code>を変更することが可能になります。</p>
<p><code>web</code>StatefulSetにpatchを当てて、<code>updateStrategy</code>フィールドにpartitionを追加しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch statefulset web -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;updateStrategy&#34;:{&#34;type&#34;:&#34;RollingUpdate&#34;,&#34;rollingUpdate&#34;:{&#34;partition&#34;:3}}}}&#39;</span>
</code></pre></div><pre><code>statefulset.apps/web patched
</code></pre><p>StatefulSetに再度patchを当てて、コンテナイメージを変更します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch statefulset web --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/image&#34;, &#34;value&#34;:&#34;k8s.gcr.io/nginx-slim:0.7&#34;}]&#39;</span>
</code></pre></div><pre><code>statefulset.apps/web patched
</code></pre><p>StatefulSet内のPodを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod web-2
</code></pre></div><pre><code>pod &quot;web-2&quot; deleted
</code></pre><p>PodがRunningかつReadyになるまで待ちます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</code></pre></div><pre><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          4m
web-1     1/1       Running             0          4m
web-2     0/1       ContainerCreating   0          11s
web-2     1/1       Running   0         18s
</code></pre><p>Podのコンテナイメージを取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod web-2 --template <span style=color:#b44>&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>
</code></pre></div><pre><code>k8s.gcr.io/nginx-slim:0.8
</code></pre><p>アップデート戦略が<code>RollingUpdate</code>であっても、StatefulSetが元のコンテナを持つPodをリストアしたことがわかります。これは、Podの順序インデックスが<code>updateStrategy</code>で指定した<code>partition</code>より小さいためです。</p>
<h4 id=rolling-out-a-canary>カナリア版をロールアウトする</h4>
<p><a href=#staging-an-update>ステージングアップデート</a>のときに指定した<code>partition</code>を小さくすることで、変更をテストするためのカナリア版をロールアウトできます。</p>
<p>StatefulSetにpatchを当てて、partitionを小さくします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch statefulset web -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;updateStrategy&#34;:{&#34;type&#34;:&#34;RollingUpdate&#34;,&#34;rollingUpdate&#34;:{&#34;partition&#34;:2}}}}&#39;</span>
</code></pre></div><pre><code>statefulset.apps/web patched
</code></pre><p><code>web-2</code>がRunningかつReadyの状態になるまで待ちます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</code></pre></div><pre><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          4m
web-1     1/1       Running             0          4m
web-2     0/1       ContainerCreating   0          11s
web-2     1/1       Running   0         18s
</code></pre><p>Podのコンテナを取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod web-2 --template <span style=color:#b44>&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>
</code></pre></div><pre><code>k8s.gcr.io/nginx-slim:0.7

</code></pre><p><code>partition</code>を変更すると、StatefulSetコントローラーはPodを自動的に更新します。Podの順序インデックスが<code>partition</code>以上の値であるためです。</p>
<p><code>web-1</code>Podを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod web-1
</code></pre></div><pre><code>pod &quot;web-1&quot; deleted
</code></pre><p><code>web-1</code>PodがRunningかつReadyになるまで待ちます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME      READY     STATUS        RESTARTS   AGE
web-0     1/1       Running       0          6m
web-1     0/1       Terminating   0          6m
web-2     1/1       Running       0          2m
web-1     0/1       Terminating   0         6m
web-1     0/1       Terminating   0         6m
web-1     0/1       Terminating   0         6m
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         18s
</code></pre><p><code>web-1</code>Podのコンテナイメージを取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod web-1 --template <span style=color:#b44>&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>
</code></pre></div><pre><code>k8s.gcr.io/nginx-slim:0.8
</code></pre><p>Podの順序インデックスがpartitionよりも小さいため、<code>web-1</code>は元の設定のコンテナイメージにリストアされました。partitionを指定すると、StatefulSetの<code>.spec.template</code>が更新されたときに、順序インデックスがそれ以上の値を持つすべてのPodがアップデートされます。partitionよりも小さな順序インデックスを持つPodが削除されたり終了されたりすると、元の設定のPodにリストアされます。</p>
<h4 id=フェーズロールアウト>フェーズロールアウト</h4>
<p><a href=#rolling-out-a-canary>カナリア版</a>をロールアウトするのと同じような方法でパーティションされたローリングアップデートを使用すると、フェーズロールアウト(例: 線形、幾何級数的、指数関数的ロールアウト)を実行できます。フェーズロールアウトを実行するには、コントローラーがアップデートを途中で止めてほしい順序インデックスを<code>partition</code>に設定します。</p>
<p>現在、partitionは<code>2</code>に設定されています。partitionを<code>0</code>に設定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch statefulset web -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;updateStrategy&#34;:{&#34;type&#34;:&#34;RollingUpdate&#34;,&#34;rollingUpdate&#34;:{&#34;partition&#34;:0}}}}&#39;</span>
</code></pre></div><pre><code>statefulset.apps/web patched
</code></pre><p>StatefulSet内のすべてのPodがRunningかつReadyの状態になるまで待ちます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          3m
web-1     0/1       ContainerCreating   0          11s
web-2     1/1       Running             0          2m
web-1     1/1       Running   0         18s
web-0     1/1       Terminating   0         3m
web-0     1/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Pending   0         0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         3s
</code></pre><p>StatefulSet内のPodのコンテナイメージの詳細を取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> p in <span style=color:#666>0</span> <span style=color:#666>1</span> 2; <span style=color:#a2f;font-weight:700>do</span> kubectl get pod <span style=color:#b44>&#34;web-</span><span style=color:#b8860b>$p</span><span style=color:#b44>&#34;</span> --template <span style=color:#b44>&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>; echo; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><pre><code>k8s.gcr.io/nginx-slim:0.7
k8s.gcr.io/nginx-slim:0.7
k8s.gcr.io/nginx-slim:0.7
</code></pre><p><code>partition</code>を<code>0</code>に移動することで、StatefulSetがアップデート処理を続けられるようにできます。</p>
<h3 id=ondelete>OnDelete</h3>
<p><code>OnDelete</code>アップデート戦略は、(1.6以前の)レガシーな動作を実装しています。このアップデート戦略を選択すると、StatefulSetの<code>.spec.template</code>フィールドへ変更を加えても、StatefulSetコントローラーが自動的にPodを更新しなくなります。この戦略を選択するには、<code>.spec.template.updateStrategy.type</code>に<code>OnDelete</code>を設定します。</p>
<h2 id=statefulsetを削除する>StatefulSetを削除する</h2>
<p>StatefulSetは、非カスケードな削除とカスケードな削除の両方をサポートしています。非カスケードな削除では、StatefulSetが削除されても、StatefulSet内のPodは削除されません。カスケードな削除では、StatefulSetとPodが一緒に削除されます。</p>
<h3 id=非カスケードな削除>非カスケードな削除</h3>
<p>1つ目のターミナルで、StatefulSet内のPodを監視します</p>
<pre><code>kubectl get pods -w -l app=nginx
</code></pre><p><a href=/docs/reference/generated/kubectl/kubectl-commands/#delete><code>kubectl delete</code></a>を使用して、StatefulSetを削除します。このとき、<code>--cascade=orphan</code>パラメーターをコマンドに与えてください。このパラメーターは、Kubernetesに対して、StatefulSetだけを削除して配下のPodは削除しないように指示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete statefulset web --cascade<span style=color:#666>=</span>orphan
</code></pre></div><pre><code>statefulset.apps &quot;web&quot; deleted
</code></pre><p>Podを取得して、ステータスを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          6m
web-1     1/1       Running   0          7m
web-2     1/1       Running   0          5m
</code></pre><p><code>web</code>が削除されても、すべてのPodはまだRunningかつReadyの状態のままです。<code>web-0</code>を削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod web-0
</code></pre></div><pre><code>pod &quot;web-0&quot; deleted
</code></pre><p>StatefulSetのPodを取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-1     1/1       Running   0          10m
web-2     1/1       Running   0          7m
</code></pre><p><code>web</code>StatefulSetはすでに削除されているため、<code>web-0</code>は再起動しません。</p>
<p>1つ目のターミナルで、StatefulSetのPodを監視します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><p>2つ目のターミナルで、StatefulSetを再作成します。もし<code>nginx</code>Serviceを削除しなかった場合(この場合は削除するべきではありませんでした)、Serviceがすでに存在することを示すエラーが表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f web.yaml
</code></pre></div><pre><code>statefulset.apps/web created
service/nginx unchanged
</code></pre><p>このエラーは無視してください。このメッセージは、すでに存在する <em>nginx</em> というheadless Serviceを作成しようと試みたということを示しているだけです。</p>
<p>1つ目のターミナルで、<code>kubectl get</code>コマンドの出力を確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-1     1/1       Running   0          16m
web-2     1/1       Running   0          2m
NAME      READY     STATUS    RESTARTS   AGE
web-0     0/1       Pending   0          0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         18s
web-2     1/1       Terminating   0         3m
web-2     0/1       Terminating   0         3m
web-2     0/1       Terminating   0         3m
web-2     0/1       Terminating   0         3m
</code></pre><p><code>web</code>StatefulSetが再作成されると、最初に<code>web-0</code>を再実行します。<code>web-1</code>はすでにRunningかつReadyの状態であるため、<code>web-0</code>がRunningかつReadyの状態に移行すると、StatefulSetは単純にこのPodを選びます。StatefulSetを<code>replicas</code>を2にして再作成したため、一度<code>web-0</code>が再作成されて、<code>web-1</code>がすでにRunningかつReadyの状態であることが判明したら、<code>web-2</code>は停止されます。</p>
<p>Podのウェブサーバーが配信している<code>index.html</code>ファイルのコンテンツをもう一度見てみましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>0</span> 1; <span style=color:#a2f;font-weight:700>do</span> kubectl <span style=color:#a2f>exec</span> -i -t <span style=color:#b44>&#34;web-</span><span style=color:#b8860b>$i</span><span style=color:#b44>&#34;</span> -- curl http://localhost/; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><pre><code>web-0
web-1
</code></pre><p>たとえStatefulSetと<code>web-0</code>Podの両方が削除されても、Podは最初に<code>index.html</code>ファイルに書き込んだホスト名をまだ配信しています。これは、StatefulSetがPodに紐付けられたPersistentVolumeを削除しないためです。StatefulSetを再作成して<code>web-0</code>を再実行すると、元のPersistentVolumeが再マウントされます。</p>
<h3 id=カスケードな削除>カスケードな削除</h3>
<p>1つ目のターミナルで、StatefulSet内のPodを監視します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><p>2つ目のターミナルで、StatefulSetをもう一度削除します。今回は、<code>--cascade=orphan</code>パラメーターを省略します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete statefulset web
</code></pre></div><pre><code>statefulset.apps &quot;web&quot; deleted
</code></pre><p>1つ目のターミナルで実行している<code>kubectl get</code>コマンドの出力を確認し、すべてのPodがTerminatingの状態に変わるまで待ちます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          11m
web-1     1/1       Running   0          27m
NAME      READY     STATUS        RESTARTS   AGE
web-0     1/1       Terminating   0          12m
web-1     1/1       Terminating   0         29m
web-0     0/1       Terminating   0         12m
web-0     0/1       Terminating   0         12m
web-0     0/1       Terminating   0         12m
web-1     0/1       Terminating   0         29m
web-1     0/1       Terminating   0         29m
web-1     0/1       Terminating   0         29m

</code></pre><p><a href=#scaling-down>スケールダウン</a>のセクションで見たように、順序インデックスの逆順に従って、Podは一度に1つずつ終了します。StatefulSetコントローラーは、次のPodを終了する前に、前のPodが完全に終了するまで待ちます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> カスケードな削除ではStatefulSetがPodとともに削除されますが、StatefulSetと紐付けられたheadless Serviceは削除されません。そのため、<code>nginx</code>Serviceは手動で削除する必要があります。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete service nginx
</code></pre></div><pre><code>service &quot;nginx&quot; deleted
</code></pre><p>さらにもう一度、StatefulSetとheadless Serviceを再作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f web.yaml
</code></pre></div><pre><code>service/nginx created
statefulset.apps/web created
</code></pre><p>StatefulSet上のすべてのPodがRunningかつReadyの状態に変わったら、Pod上の<code>index.html</code>ファイルのコンテンツを取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>0</span> 1; <span style=color:#a2f;font-weight:700>do</span> kubectl <span style=color:#a2f>exec</span> -i -t <span style=color:#b44>&#34;web-</span><span style=color:#b8860b>$i</span><span style=color:#b44>&#34;</span> -- curl http://localhost/; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><pre><code>web-0
web-1
</code></pre><p>StatefulSetを完全に削除して、すべてのPodが削除されたとしても、PersistentVolumeがマウントされたPodが再生成されて、<code>web-0</code>と<code>web-1</code>はホスト名の配信を続けます。</p>
<p>最後に、<code>web</code>StatefulSetを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete service nginx
</code></pre></div><pre><code>service &quot;nginx&quot; deleted
</code></pre><p>そして、<code>nginx</code>Serviceも削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete statefulset web
</code></pre></div><pre><code>statefulset &quot;web&quot; deleted
</code></pre><h2 id=pod管理ポリシー>Pod管理ポリシー</h2>
<p>分散システムによっては、StatefulSetの順序の保証が不必要であったり望ましくない場合もあります。こうしたシステムでは、一意性と同一性だけが求められます。この問題に対処するために、Kubernetes 1.7でStatefulSet APIオブジェクトに<code>.spec.podManagementPolicy</code>が導入されました。</p>
<h3 id=orderedreadyのpod管理>OrderedReadyのPod管理</h3>
<p><code>OrderedReady</code>のPod管理はStatefulSetのデフォルトの設定です。StatefulSetコントローラーに対して、これまでに紹介したような順序の保証を尊重するように指示します。</p>
<h3 id=parallelのpod管理>ParallelのPod管理</h3>
<p><code>Parallel</code>のPod管理では、StatefulSetコントローラーに対して、PodがRunningかつReadyの状態や完全に停止するまで待たないように指示し、すべてのPodを並列に起動または停止させるようにします。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/web/web-parallel.yaml download=application/web/web-parallel.yaml><code>application/web/web-parallel.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-web-web-parallel-yaml')" title="Copy application/web/web-parallel.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-web-web-parallel-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginx&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podManagementPolicy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Parallel&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/nginx-slim:0.8<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>上の例をダウンロードして、<code>web-parallel.yaml</code>という名前でファイルに保存してください。</p>
<p>このマニフェストは、<code>.spec.podManagementPolicy</code>が<code>Parallel</code>に設定されている以外は、前にダウンロードした<code>web</code>StatefulSetと同一です。</p>
<p>1つ目のターミナルで、StatefulSet内のPodを監視します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</code></pre></div><p>2つ目のターミナルで、マニフェスト内のStatefulSetとServiceを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f web-parallel.yaml
</code></pre></div><pre><code>service/nginx created
statefulset.apps/web created
</code></pre><p>1つ目のターミナルで実行した<code>kubectl get</code>コマンドの出力を確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</code></pre></div><pre><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     0/1       Pending   0          0s
web-0     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-1     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         10s
web-1     1/1       Running   0         10s
</code></pre><p>StatefulSetコントローラーは<code>web-0</code>と<code>web-1</code>を同時に起動しています。</p>
<p>2つ目のターミナルで、StatefulSetをスケールしてみます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale statefulset/web --replicas<span style=color:#666>=</span><span style=color:#666>4</span>
</code></pre></div><pre><code>statefulset.apps/web scaled
</code></pre><p><code>kubectl get</code>コマンドを実行しているターミナルの出力を確認します。</p>
<pre><code>web-3     0/1       Pending   0         0s
web-3     0/1       Pending   0         0s
web-3     0/1       Pending   0         7s
web-3     0/1       ContainerCreating   0         7s
web-2     1/1       Running   0         10s
web-3     1/1       Running   0         26s
</code></pre><p>StatefulSetが2つのPodを実行し、1つ目のPodがRunningかつReadyの状態になるのを待たずに2つ目のPodを実行しているのがわかります。</p>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>2つのターミナルが開かれているはずなので、クリーンアップの一部として<code>kubectl</code>コマンドを実行する準備ができています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete sts web
<span style=color:#080;font-style:italic># stsは、statefulsetの略です。</span>
</code></pre></div><p><code>kubectl get</code>を監視すると、Podが削除されていく様子を確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</code></pre></div><pre><code>web-3     1/1       Terminating   0         9m
web-2     1/1       Terminating   0         9m
web-3     1/1       Terminating   0         9m
web-2     1/1       Terminating   0         9m
web-1     1/1       Terminating   0         44m
web-0     1/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-3     0/1       Terminating   0         9m
web-2     0/1       Terminating   0         9m
web-1     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-2     0/1       Terminating   0         9m
web-2     0/1       Terminating   0         9m
web-2     0/1       Terminating   0         9m
web-1     0/1       Terminating   0         44m
web-1     0/1       Terminating   0         44m
web-1     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-3     0/1       Terminating   0         9m
web-3     0/1       Terminating   0         9m
web-3     0/1       Terminating   0         9m
</code></pre><p>削除の間、StatefulSetはすべてのPodを並列に削除し、順序インデックスが1つ前のPodが停止するのを待つことはありません。</p>
<p><code>kubectl get</code>コマンドを実行しているターミナルを閉じて、<code>nginx</code>Serviceを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete svc nginx
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>このチュートリアルで使用したPersistentVolumeのための永続ストレージも削除する必要があります。</p>
<p>すべてのストレージが再利用できるようにするために、環境、ストレージの設定、プロビジョニング方法に基づいて必要な手順に従ってください。</p>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-27580b3f65f3c2da07fc0f83be69da75>5.5.2 - 例: Persistent Volumeを使用したWordpressとMySQLをデプロイする</h1>
<p>このチュートリアルでは、WordPressのサイトとMySQLデータベースをMinikubeを使ってデプロイする方法を紹介します。2つのアプリケーションとも、データを保存するためにPersistentVolumeとPersistentVolumeClaimを使用します。</p>
<p><a href=/ja/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>(PV)とは、管理者が手動でプロビジョニングを行うか、<a href=/docs/concepts/storage/storage-classes>StorageClass</a>を使ってKubernetesによって動的にプロビジョニングされた、クラスター内のストレージの一部です。<a href=/ja/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaim</a>(PVC)は、PVによって満たすことができる、ユーザーによるストレージへのリクエストのことです。PersistentVolumeとPersistentVolumeClaimは、Podのライフサイクルからは独立していて、Podの再起動、Podの再スケジューリング、さらにはPodの削除が行われたとしても、その中のデータは削除されずに残ります。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> シングルインスタンスのWordPressとMySQLのPodを使用しているため、ここで行うデプロイは本番のユースケースには適しません。WordPressを本番環境にデプロイするときは、<a href=https://github.com/kubernetes/charts/tree/master/stable/wordpress>WordPress Helm Chart</a>を使用することを検討してください。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このチュートリアルで提供されるファイルは、GAとなっているDeployment APIを使用しているため、Kubernetesバージョン1.9以降のためのものになっています。もしこのチュートリアルを古いバージョンのKubernetesで使いたい場合は、APIのバージョンを適切にアップデートするか、このチュートリアルの古いバージョンを参照してください。
</div>
<h2 id=目標>目標</h2>
<ul>
<li>PersistentVolumeClaimとPersistentVolumeを作成する</li>
<li>以下を含む<code>kustomization.yaml</code>を作成する
<ul>
<li>Secret generator</li>
<li>MySQLリソースの設定</li>
<li>WordPressリソースの設定</li>
</ul>
</li>
<li>kustomizationディレクトリを<code>kubectl apply -k ./</code>で適用する</li>
<li>クリーンアップする</li>
</ul>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
このページで示された例は、<code>kubectl</code> 1.14以降で動作します。</p>
<p>以下の設定ファイルをダウンロードします。</p>
<ol>
<li>
<p><a href=/examples/application/wordpress/mysql-deployment.yaml>mysql-deployment.yaml</a></p>
</li>
<li>
<p><a href=/examples/application/wordpress/wordpress-deployment.yaml>wordpress-deployment.yaml</a></p>
</li>
</ol>
<h2 id=persistentvolumeclaimとpersistentvolumeを作成する>PersistentVolumeClaimとPersistentVolumeを作成する</h2>
<p>MySQLとWordpressはそれぞれ、データを保存するためのPersistentVolumeを必要とします。各PersistentVolumeClaimはデプロイの段階で作成されます。</p>
<p>多くのクラスタ環境では、デフォルトのStorageClassがインストールされています。StorageClassがPersistentVolumeClaim中で指定されていなかった場合、クラスターのデフォルトのStorageClassが代わりに使われます。</p>
<p>PersistentVolumeClaimが作成されるとき、StorageClassの設定に基づいてPersistentVolumeが動的にプロビジョニングされます。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> ローカルのクラスターでは、デフォルトのStorageClassには<code>hostPath</code>プロビジョナーが使われます。<code>hostPath</code>ボリュームは開発およびテストにのみ適しています。<code>hostPath</code>ボリュームでは、データはPodがスケジュールされたノード上の<code>/tmp</code>内に保存されます。そのため、もしPodが死んだり、クラスター上の他のノードにスケジュールされたり、ノードが再起動すると、データは失われます。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>hostPath</code>プロビジョナーを使用する必要があるクラスターを立ち上げたい場合は、<code>--enable-hostpath-provisioner</code>フラグを <code>controller-manager</code> コンポーネントで設定する必要があります。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Google Kubernetes Engine上で動作するKubernetesクラスターを使っている場合は、<a href="https://cloud.google.com/kubernetes-engine/docs/tutorials/persistent-disk?hl=ja">このガイド</a>に従ってください。
</div>
<h2 id=kustomization-yamlを作成する>kustomization.yamlを作成する</h2>
<h3 id=secret-generatorを追加する>Secret generatorを追加する</h3>
<p><a href=/docs/concepts/configuration/secret/>Secret</a>とは、パスワードやキーのような機密性の高いデータ片を保存するためのオブジェクトです。バージョン1.14からは、<code>kubectl</code>がkustomizationファイルを使用したKubernetesオブジェクトの管理をサポートしています。<code>kustomization.yaml</code>内のgeneratorによってSecretを作成することができます。</p>
<p>以下のコマンドを実行して、<code>kustomization.yaml</code>の中にSecret generatorを追加します。<code>YOUR_PASSWORD</code>の部分を使いたいパスワードに置換してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>secretGenerator:
</span><span style=color:#b44>- name: mysql-pass
</span><span style=color:#b44>  literals:
</span><span style=color:#b44>  - password=YOUR_PASSWORD
</span><span style=color:#b44>EOF</span>
</code></pre></div><h2 id=mysqlとwordpressのためのリソースの設定を追加する>MySQLとWordPressのためのリソースの設定を追加する</h2>
<p>以下のマニフェストには、シングルインスタンスのMySQLのDeploymentが書かれています。MySQLコンテナはPersistentVolumeを<code>/var/lib/mysql</code>にマウントします。<code>MYSQL_ROOT_PASSWORD</code>環境変数には、Secretから得られたデータベースのパスワードが設定されます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/wordpress/mysql-deployment.yaml download=application/wordpress/mysql-deployment.yaml><code>application/wordpress/mysql-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-wordpress-mysql-deployment-yaml')" title="Copy application/wordpress/mysql-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-wordpress-mysql-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wordpress-mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-pv-claim<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wordpress-mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Recreate<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql:5.6<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-pass<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-persistent-storage<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-persistent-storage<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>mysql-pv-claim<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>以下のマニフェストには、シングルインスタンスのWordPressのDeploymentが書かれています。WordPressコンテナはPersistentVolumeをウェブサイトのデータファイルのために<code>/var/www/html</code>にマウントします。<code>WORDPRESS_DB_HOST</code>環境変数に上で定義したMySQLのServiceの名前を設定すると、WordPressはServiceによってデータベースにアクセスします。<code>WORDPRESS_DB_PASSWORD</code>環境変数には、kustomizeが生成したSecretから得たデータベースのパスワードが設定されます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/wordpress/wordpress-deployment.yaml download=application/wordpress/wordpress-deployment.yaml><code>application/wordpress/wordpress-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-wordpress-wordpress-deployment-yaml')" title="Copy application/wordpress/wordpress-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-wordpress-wordpress-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wp-pv-claim<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Recreate<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>wordpress:4.8-apache<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>WORDPRESS_DB_HOST<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>wordpress-mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>WORDPRESS_DB_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-pass<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wordpress-persistent-storage<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/www/html<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wordpress-persistent-storage<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>wp-pv-claim<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>MySQLのDeploymentの設定ファイルをダウンロードします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -LO https://k8s.io/examples/application/wordpress/mysql-deployment.yaml
</code></pre></div></li>
<li>
<p>WordPressの設定ファイルをダウンロードします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -LO https://k8s.io/examples/application/wordpress/wordpress-deployment.yaml
</code></pre></div></li>
<li>
<p>これらを<code>kustomization.yaml</code>ファイルに追加します。</p>
</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt;./kustomization.yaml
</span><span style=color:#b44>resources:
</span><span style=color:#b44>  - mysql-deployment.yaml
</span><span style=color:#b44>  - wordpress-deployment.yaml
</span><span style=color:#b44>EOF</span>
</code></pre></div><h2 id=適用と確認>適用と確認</h2>
<p><code>kustomization.yaml</code>には、WordPressのサイトとMySQLデータベースのためのすべてのリソースが含まれています。次のコマンドでこのディレクトリを適用できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k ./
</code></pre></div><p>これで、すべてのオブジェクトが存在していることを確認できます。</p>
<ol>
<li>
<p>次のコマンドを実行して、Secretが存在していることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secrets
</code></pre></div><p>結果は次のようになるはずです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                    TYPE                                  DATA   AGE
mysql-pass-c57bb4t7mf   Opaque                                <span style=color:#666>1</span>      9s
</code></pre></div></li>
<li>
<p>次のコマンドを実行して、PersistentVolumeが動的にプロビジョニングされていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pvc
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> PVがプロビジョニングされてバインドされるまでに、最大で数分かかる場合があります。
</div>
<p>結果は次のようになるはずです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME             STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS       AGE
mysql-pv-claim   Bound     pvc-8cbd7b2e-4044-11e9-b2bb-42010a800002   20Gi       RWO            standard           77s
wp-pv-claim      Bound     pvc-8cd0df54-4044-11e9-b2bb-42010a800002   20Gi       RWO            standard           77s
</code></pre></div></li>
<li>
<p>次のコマンドを実行して、Podが実行中であることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> PodのStatusが<code>Running</code>の状態になる前に、最大で数分かかる場合があります。
</div>
<p>結果は次のようになるはずです。</p>
<pre><code>NAME                               READY     STATUS    RESTARTS   AGE
wordpress-mysql-1894417608-x5dzt   1/1       Running   0          40s
</code></pre></li>
<li>
<p>次のコマンドを実行して、Serviceが実行中であることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get services wordpress
</code></pre></div><p>結果は次のようになるはずです。</p>
<pre><code>NAME        TYPE            CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE
wordpress   LoadBalancer    10.0.0.89    &lt;pending&gt;     80:32406/TCP   4m
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> MinikubeではServiceを<code>NodePort</code>経由でしか公開できません。EXTERNAL-IPは常にpendingのままになります。
</div>
</li>
<li>
<p>次のコマンドを実行して、WordPress ServiceのIPアドレスを取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube service wordpress --url
</code></pre></div><p>結果は次のようになるはずです。</p>
<pre><code>http://1.2.3.4:32406
</code></pre></li>
<li>
<p>IPアドレスをコピーして、ブラウザーで読み込み、サイトを表示しましょう。</p>
<p>WordPressによりセットアップされた次のスクリーンショットのようなページが表示されるはずです。</p>
<p><img src=https://raw.githubusercontent.com/kubernetes/examples/master/mysql-wordpress-pd/WordPress.png alt=wordpress-init></p>
</li>
</ol>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> WordPressのインストールをこのページのまま放置してはいけません。もしほかのユーザーがこのページを見つけた場合、その人はインスタンス上にウェブサイトをセットアップして、悪意のあるコンテンツの配信に利用できてしまいます。<br><br>ユーザー名とパスワードを決めてWordPressをインストールするか、このインスタンスを削除してください。
</div>
<h2 id=クリーンアップ>クリーンアップ</h2>
<ol>
<li>
<p>次のコマンドを実行して、Secret、Deployment、Service、およびPersistentVolumeClaimを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete -k ./
</code></pre></div></li>
</ol>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/debug-application-cluster/debug-application-introspection/>イントロスペクションとデバッグ</a>についてさらに学ぶ</li>
<li><a href=/docs/concepts/workloads/controllers/job/>Job</a>についてさらに学ぶ</li>
<li><a href=/docs/tasks/access-application-cluster/port-forward-access-application-cluster/>Portフォワーディング</a>についてさらに学ぶ</li>
<li><a href=/ja/docs/tasks/debug-application-cluster/get-shell-running-container/>コンテナへのシェルを取得する</a>方法について学ぶ</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bf0d8e08fddd6e0282709b9fef8b5f67>5.5.3 - 例: StatefulSetを使用したCassandraのデプロイ</h1>
<p>このチュートリアルでは、<a href=http://cassandra.apache.org/>Apache Cassandra</a>をKubernetes上で実行する方法を紹介します。
データベースの一種であるCassandraには、データの耐久性(アプリケーションの <em>状態</em>)を提供するために永続ストレージが必要です。
この例では、カスタムのCassandraのseed providerにより、Cassandraクラスターに参加した新しいCassandraインスタンスを検出できるようにします。</p>
<p><em>StatefulSet</em>を利用すると、ステートフルなアプリケーションをKubernetesクラスターにデプロイするのが簡単になります。
このチュートリアルで使われている機能のより詳しい情報は、<a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>を参照してください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>CassandraとKubernetesは、ともにクラスターのメンバーを表すために <em>ノード</em> という用語を使用しています。このチュートリアルでは、StatefulSetに属するPodはCassandraのノードであり、Cassandraクラスター( <em>ring</em> と呼ばれます)のメンバーでもあります。これらのPodがKubernetesクラスター内で実行されるとき、Kubernetesのコントロールプレーンは、PodをKubernetesの<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>上にスケジュールします。</p>
<p>Cassandraノードが開始すると、 <em>シードリスト</em> を使ってring上の他のノードの検出が始まります。
このチュートリアルでは、Kubernetesクラスター内に現れた新しいCassandra Podを検出するカスタムのCassandraのseed providerをデプロイします。</p>
</div>
<h2 id=目標>目標</h2>
<ul>
<li>Cassandraのheadless <a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>を作成して検証する。</li>
<li><a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>を使用してCassandra ringを作成する。</li>
<li>StatefulSetを検証する。</li>
<li>StatefulSetを編集する。</li>
<li>StatefulSetと<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>を削除する。</li>
</ul>
<h2 id=始める前に>始める前に</h2>
<p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
<p>このチュートリアルを完了するには、<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>、<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>、<a class=glossary-tooltip title=StatefulSetはDeploymentとPodのセットのスケーリングを管理し、永続化ストレージと各Podの永続的な識別子を備えています。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>の基本についてすでに知っている必要があります。</p>
<h3 id=minikubeのセットアップに関する追加の設定手順>Minikubeのセットアップに関する追加の設定手順</h3>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <p><a href=/ja/docs/getting-started-guides/minikube/>Minikube</a>は、デフォルトでは1024MiBのメモリと1CPUに設定されます。
デフォルトのリソース設定で起動したMinikubeでは、このチュートリアルの実行中にリソース不足のエラーが発生してしまいます。このエラーを回避するためにはMinikubeを次の設定で起動してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube start --memory <span style=color:#666>5120</span> --cpus<span style=color:#666>=</span><span style=color:#666>4</span>
</code></pre></div>
</div>
<h2 id=creating-a-cassandra-headless-service>Cassandraのheadless Serviceを作成する</h2>
<p>Kubernetesでは、<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>は同じタスクを実行する<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>の集合を表します。</p>
<p>以下のServiceは、Cassandra Podとクラスター内のクライアント間のDNSルックアップに使われます:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/cassandra/cassandra-service.yaml download=application/cassandra/cassandra-service.yaml><code>application/cassandra/cassandra-service.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-cassandra-cassandra-service-yaml')" title="Copy application/cassandra/cassandra-service.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-cassandra-cassandra-service-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>cassandra<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cassandra<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>9042</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>cassandra<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p><code>cassandra-service.yaml</code>ファイルから、Cassandra StatefulSetのすべてのメンバーをトラッキングするServiceを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/cassandra/cassandra-service.yaml
</code></pre></div><h3 id=validating>検証 (オプション)</h3>
<p>Cassandra Serviceを取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc cassandra
</code></pre></div><p>結果は次のようになります。</p>
<pre><code>NAME        TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
cassandra   ClusterIP   None         &lt;none&gt;        9042/TCP   45s
</code></pre><p><code>cassandra</code>という名前のServiceが表示されない場合、作成に失敗しています。よくある問題のトラブルシューティングについては、<a href=/ja/docs/tasks/debug-application-cluster/debug-service/>Serviceのデバッグ</a>を読んでください。</p>
<h2 id=statefulsetを使ってcassandra-ringを作成する>StatefulSetを使ってCassandra ringを作成する</h2>
<p>以下に示すStatefulSetマニフェストは、3つのPodからなるCassandra ringを作成します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> この例ではMinikubeのデフォルトのプロビジョナーを使用しています。
クラウドを使用している場合、StatefulSetを更新してください。
</div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/cassandra/cassandra-statefulset.yaml download=application/cassandra/cassandra-statefulset.yaml><code>application/cassandra/cassandra-statefulset.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-cassandra-cassandra-statefulset-yaml')" title="Copy application/cassandra/cassandra-statefulset.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-cassandra-cassandra-statefulset-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cassandra<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>cassandra<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>cassandra<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>cassandra<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>cassandra<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>1800</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cassandra<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/cassandra:v13<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>7000</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>intra-node<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>7001</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>tls-intra-node<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>7199</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jmx<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>9042</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>capabilities</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>add</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- IPC_LOCK<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>preStop</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> 
</span><span style=color:#bbb>              </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>              </span>- nodetool drain<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MAX_HEAP_SIZE<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>512M<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>HEAP_NEWSIZE<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>100M<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>CASSANDRA_SEEDS<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;cassandra-0.cassandra.default.svc.cluster.local&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>CASSANDRA_CLUSTER_NAME<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;K8Demo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>CASSANDRA_DC<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;DC1-K8Demo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>CASSANDRA_RACK<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Rack1-K8Demo&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>POD_IP<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>status.podIP<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- /bin/bash<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- /ready-probe.sh<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># These volume mounts are persistent. They are like inline claims,</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># but not exactly because the names need to match exactly one of</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># the stateful pod volumes.</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cassandra-data<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/cassandra_data<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># These are converted to volume claims by the controller</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># and mounted at the paths mentioned above.</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># do not use these in production until ssd GCEPersistentDisk or other ssd pd</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cassandra-data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>k8s.io/minikube-hostpath<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-ssd<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p><code>cassandra-statefulset.yaml</code>ファイルから、CassandraのStatefulSetを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># cassandra-statefulset.yaml を編集せずにapplyできる場合は、このコマンドを使用してください</span>
kubectl apply -f https://k8s.io/examples/application/cassandra/cassandra-statefulset.yaml
</code></pre></div><p>クラスターに合わせて<code>cassandra-statefulset.yaml</code>を編集する必要がある場合、 <a href=https://k8s.io/examples/application/cassandra/cassandra-statefulset.yaml>https://k8s.io/examples/application/cassandra/cassandra-statefulset.yaml</a> をダウンロードして、修正したバージョンを保存したフォルダからマニフェストを適用してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># cassandra-statefulset.yaml をローカルで編集する必要がある場合、このコマンドを使用してください</span>
kubectl apply -f cassandra-statefulset.yaml
</code></pre></div><h2 id=cassandraのstatefulsetを検証する>CassandraのStatefulSetを検証する</h2>
<ol>
<li>
<p>CassandraのStatefulSetを取得します</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get statefulset cassandra
</code></pre></div><p>結果は次のようになるはずです:</p>
<pre><code>NAME        DESIRED   CURRENT   AGE
cassandra   3         0         13s
</code></pre><p><code>StatefulSet</code>リソースがPodを順番にデプロイします。</p>
</li>
<li>
<p>Podを取得して順序付きの作成ステータスを確認します</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l<span style=color:#666>=</span><span style=color:#b44>&#34;app=cassandra&#34;</span>
</code></pre></div><p>結果は次のようになるはずです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME          READY     STATUS              RESTARTS   AGE
cassandra-0   1/1       Running             <span style=color:#666>0</span>          1m
cassandra-1   0/1       ContainerCreating   <span style=color:#666>0</span>          8s
</code></pre></div><p>3つすべてのPodのデプロイには数分かかる場合があります。デプロイが完了すると、同じコマンドは次のような結果を返します:</p>
<pre><code>NAME          READY     STATUS    RESTARTS   AGE
cassandra-0   1/1       Running   0          10m
cassandra-1   1/1       Running   0          9m
cassandra-2   1/1       Running   0          8m
</code></pre></li>
<li>
<p>1番目のPodの中でCassandraの<a href=https://cwiki.apache.org/confluence/display/CASSANDRA2/NodeTool>nodetool</a>を実行して、ringのステータスを表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it cassandra-0 -- nodetool status
</code></pre></div><p>結果は次のようになるはずです:</p>
<pre><code>Datacenter: DC1-K8Demo
======================
Status=Up/Down
|/ State=Normal/Leaving/Joining/Moving
--  Address     Load       Tokens       Owns (effective)  Host ID                               Rack
UN  172.17.0.5  83.57 KiB  32           74.0%             e2dd09e6-d9d3-477e-96c5-45094c08db0f  Rack1-K8Demo
UN  172.17.0.4  101.04 KiB  32           58.8%             f89d6835-3a42-4419-92b3-0e62cae1479c  Rack1-K8Demo
UN  172.17.0.6  84.74 KiB  32           67.1%             a6a1e8c2-3dc5-4417-b1a0-26507af2aaad  Rack1-K8Demo
</code></pre></li>
</ol>
<h2 id=cassandraのstatefulsetを変更する>CassandraのStatefulSetを変更する</h2>
<p><code>kubectl edit</code>を使うと、CassandraのStatefulSetのサイズを変更できます。</p>
<ol>
<li>
<p>次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit statefulset cassandra
</code></pre></div><p>このコマンドを実行すると、ターミナルでエディタが起動します。変更が必要な行は<code>replicas</code>フィールドです。
以下の例は、StatefulSetファイルの抜粋です:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># Please edit the object below. Lines beginning with a &#39;#&#39; will be ignored,</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># and an empty file will abort the edit. If an error occurs while saving this file will be</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># reopened with the relevant failures.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-08-13T18:40:58Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>generation</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>cassandra<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cassandra<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;323&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>7a219483-6185-11e6-a910-42010a8a0fc0<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div></li>
<li>
<p>レプリカ数を4に変更し、マニフェストを保存します。</p>
<p>これで、StatefulSetが4つのPodを実行するようにスケールされました。</p>
</li>
<li>
<p>CassandraのStatefulSetを取得して、変更を確かめます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get statefulset cassandra
</code></pre></div><p>結果は次のようになるはずです:</p>
<pre><code>NAME        DESIRED   CURRENT   AGE
cassandra   4         4         36m
</code></pre></li>
</ol>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>StatefulSetを削除したりスケールダウンしても、StatefulSetに関係するボリュームは削除されません。
StatefulSetに関連するすべてのリソースを自動的に破棄するよりも、データの方がより貴重であるため、安全のためにこのような設定になっています。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> ストレージクラスやreclaimポリシーによっては、<em>PersistentVolumeClaim</em>を削除すると、関連するボリュームも削除される可能性があります。PersistentVolumeClaimの削除後にもデータにアクセスできるとは決して想定しないでください。
</div>
<ol>
<li>
<p>次のコマンドを実行して(単一のコマンドにまとめています)、CassandraのStatefulSetに含まれるすべてのリソースを削除します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>grace</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pod cassandra-0 -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.terminationGracePeriodSeconds}&#39;</span><span style=color:#a2f;font-weight:700>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> kubectl delete statefulset -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;Sleeping </span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>grace</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44> seconds&#34;</span> 1&gt;&amp;<span style=color:#666>2</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> sleep <span style=color:#b8860b>$grace</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> kubectl delete persistentvolumeclaim -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra
</code></pre></div></li>
<li>
<p>次のコマンドを実行して、CassandraをセットアップしたServiceを削除します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete service -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra
</code></pre></div></li>
</ol>
<h2 id=cassandraコンテナの環境変数>Cassandraコンテナの環境変数</h2>
<p>このチュートリアルのPodでは、Googleの<a href=https://cloud.google.com/container-registry/docs/>コンテナレジストリ</a>の<a href=https://github.com/kubernetes/examples/blob/master/cassandra/image/Dockerfile><code>gcr.io/google-samples/cassandra:v13</code></a>イメージを使用しました。このDockerイメージは<a href=https://github.com/kubernetes/release/tree/master/images/build/debian-base>debian-base</a>をベースにしており、OpenJDK 8が含まれています。</p>
<p>このイメージには、Apache Debianリポジトリの標準のCassandraインストールが含まれます。
環境変数を利用すると、<code>cassandra.yaml</code>に挿入された値を変更できます。</p>
<table>
<thead>
<tr>
<th>環境変数</th>
<th style=text-align:center>デフォルト値</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CASSANDRA_CLUSTER_NAME</code></td>
<td style=text-align:center><code>'Test Cluster'</code></td>
</tr>
<tr>
<td><code>CASSANDRA_NUM_TOKENS</code></td>
<td style=text-align:center><code>32</code></td>
</tr>
<tr>
<td><code>CASSANDRA_RPC_ADDRESS</code></td>
<td style=text-align:center><code>0.0.0.0</code></td>
</tr>
</tbody>
</table>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/tasks/run-application/scale-stateful-set/>StatefulSetのスケール</a>を行う方法を学ぶ。</li>
<li><a href=https://github.com/kubernetes/examples/blob/master/cassandra/java/src/main/java/io/k8s/cassandra/KubernetesSeedProvider.java><em>KubernetesSeedProvider</em></a>についてもっと学ぶ。</li>
<li>カスタムの<a href=https://git.k8s.io/examples/cassandra/java/README.md>Seed Providerの設定</a>についてもっと学ぶ。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1ea281893eade34904c0cbd26b4228cb>5.6 - クラスター</h1>
</div>
<div class=td-content>
<h1 id=pg-18353c97948b94e2272afa0f11a58bec>5.6.1 - AppArmorを使用してコンテナのリソースへのアクセスを制限する</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.4 [beta]</code>
</div>
<p>AppArmorは、Linux標準のユーザー・グループをベースとしたパーミッションを補完するLinuxカーネルのセキュリティモジュールであり、プログラムのアクセスを限定されたリソースセットに制限するために利用されます。AppArmorを設定することで、任意のアプリケーションの攻撃サーフェイスとなりうる面を減らしたり、より優れた多重の防御を提供できます。AppArmorは、たとえばLinuxのcapability、ネットワークアクセス、ファイルのパーミッションなど、特定のプログラムやコンテナに必要なアクセスを許可するようにチューニングされたプロファイルにより設定を行います。各プロファイルは、許可されなかったリソースへのアクセスをブロックする<em>enforcing</em>モードと、ルール違反を報告するだけの<em>complain</em>モードのいずれかで実行できます。</p>
<p>AppArmorを利用すれば、コンテナに許可することを制限したりシステムログを通してよりよい監査を提供することで、デプロイをよりセキュアにする助けになります。しかし、AppArmorは銀の弾丸ではなく、アプリケーションコードの悪用からの防御を強化できるだけであることを心に留めておくことが重要です。制限の強い優れたプロファイルを提供し、アプリケーションとクラスターを別の角度から強化することが重要です。</p>
<h2 id=目標>目標</h2>
<ul>
<li>プロファイルをノードに読み込む方法の例を見る</li>
<li>Pod上でプロファイルを矯正する方法を学ぶ</li>
<li>プロファイルが読み込まれたかを確認する方法を学ぶ</li>
<li>プロファイルに違反した場合に何が起こるのかを見る</li>
<li>プロファイルが読み込めなかった場合に何が起こるのかを見る</li>
</ul>
<h2 id=始める前に>始める前に</h2>
<p>以下のことを確認してください。</p>
<ol>
<li>
<p>Kubernetesのバージョンがv1.4以上であること。KubernetesのAppArmorのサポートはv1.4で追加されました。v1.4より古いバージョンのKubernetesのコンポーネントは、新しいAppArmorのアノテーションを認識できないため、AppArmorの設定を与えたとしても<strong>黙って無視されてしまいます</strong>。Podが期待した保護を確実に受けられるようにするためには、次のようにノードのKubeletのバージョンを確認することが重要です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>$&#39;{range .items[*]}{@.metadata.name}: {@.status.nodeInfo.kubeletVersion}\n{end}&#39;</span>
</code></pre></div><pre><code>gke-test-default-pool-239f5d02-gyn2: v1.4.0
gke-test-default-pool-239f5d02-x1kf: v1.4.0
gke-test-default-pool-239f5d02-xwux: v1.4.0
</code></pre></li>
<li>
<p>AppArmorカーネルモジュールが有効であること。LinuxカーネルがAppArmorプロファイルを強制するためには、AppArmorカーネルモジュールのインストールと有効化が必須です。UbuntuやSUSEなどのディストリビューションではデフォルトで有効化されますが、他の多くのディストリビューションでのサポートはオプションです。モジュールが有効になっているかチェックするには、次のように<code>/sys/module/apparmor/parameters/enabled</code>ファイルを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /sys/module/apparmor/parameters/enabled
Y
</code></pre></div><p>KubeletがAppArmorをサポートしていれば(>= v1.4)、カーネルモジュールが有効になっていない場合にはAppArmorオプションが付いたPodを拒否します。</p>
</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> UbuntuはAppArmorに対して、アップストリームのLinuxにマージしていない多数のパッチを当てています。その中には、追加のフックや機能を加えるパッチも含まれます。Kubernetesはアップストリームのバージョンでのみテストされており、その他の機能に対するサポートを約束していません。
</div>
<ol start=3>
<li>
<p>コンテナランタイムがAppArmorをサポートしていること。現在、Kubernetesがサポートするすべての一般的なコンテナランタイム、<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>、<a class=glossary-tooltip title="A lightweight container runtime specifically for Kubernetes" data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>、<a class=glossary-tooltip title="A container runtime with an emphasis on simplicity, robustness and portability" data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>などは、AppArmorをサポートしています。関連するランタイムのドキュメントを参照して、クラスターがAppArmorを利用するための要求を満たしているかどうかを検証してください。</p>
</li>
<li>
<p>プロファイルが読み込まれていること。AppArmorがPodに適用されるのは、各コンテナが実行されるべきAppArmorプロファイルを指定したときです。もし指定されたプロファイルがまだカーネルに読み込まれていなければ、Kubelet(>= v1.4)はPodを拒否します。どのプロファイルがノードに読み込まれているのかを確かめるには、次のようなコマンドを実行して<code>/sys/kernel/security/apparmor/profiles</code>をチェックします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ssh gke-test-default-pool-239f5d02-gyn2 <span style=color:#b44>&#34;sudo cat /sys/kernel/security/apparmor/profiles | sort&#34;</span>
</code></pre></div><pre><code>apparmor-test-deny-write (enforce)
apparmor-test-audit-write (enforce)
docker-default (enforce)
k8s-nginx (enforce)
</code></pre><p>ノード上でのプロファイルの読み込みの詳細については、<a href=#setting-up-nodes-with-profiles>プロファイルを使用したノードのセットアップ</a>を参照してください。</p>
</li>
</ol>
<p>KubeletのバージョンがAppArmorサポートに対応しているもの(>= v1.4)である限り、Kubeletは必要条件を1つでも満たさないAppArmorオプションが付けられたPodをリジェクトします。また、ノード上のAppArmorのサポートは、次のようにready conditionのメッセージで確認することもできます(ただし、この機能は将来のリリースで削除される可能性があります)。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>$&#39;{range .items[*]}{@.metadata.name}: {.status.conditions[?(@.reason==&#34;KubeletReady&#34;)].message}\n{end}&#39;</span>
</code></pre></div><pre><code>gke-test-default-pool-239f5d02-gyn2: kubelet is posting ready status. AppArmor enabled
gke-test-default-pool-239f5d02-x1kf: kubelet is posting ready status. AppArmor enabled
gke-test-default-pool-239f5d02-xwux: kubelet is posting ready status. AppArmor enabled
</code></pre>
<h2 id=podをセキュアにする>Podをセキュアにする</h2>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> AppArmorは現在beta版であるため、オプションはアノテーションとして指定します。将来サポートが一般利用可能(GA)になれば、アノテーションは第1級のフィールドで置き換えられます(詳細については、<a href=#upgrade-path-to-general-availability>一般利用可能(General Availability)への更新パス</a>を参照してください)。
</div>
<p>AppArmorのプロファイルは<em>各コンテナごとに</em>指定します。Podのコンテナで実行するAppArmorのプロファイルを指定するには、Podのメタデータに次のようなアノテーションを追加します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>container.apparmor.security.beta.kubernetes.io/&lt;container_name&gt;</span>:<span style=color:#bbb> </span>&lt;profile_ref&gt;<span style=color:#bbb>
</span></code></pre></div><p>ここで、<code>&lt;container_name></code>はプロファイルを適用するコンテナの名前であり、<code>&lt;profile_ref></code>には適用するプロファイルを指定します。<code>profile_ref</code>は次の値のうち1つを指定します。</p>
<ul>
<li><code>runtime/default</code>: ランタイムのデフォルトのプロファイルを適用する</li>
<li><code>localhost/&lt;profile_name></code>: <code>&lt;profile_name></code>という名前でホストにロードされたプロファイルを適用する</li>
<li><code>unconfined</code>: いかなるプロファイルもロードされないことを示す</li>
</ul>
<p>アノテーションとプロファイルの名前のフォーマットの詳細については、<a href=#api-reference>APIリファレンス</a>を参照してください。</p>
<p>KubernetesのAppArmorの強制では、まずはじめにすべての前提条件が満たされているかどうかをチェックします。その後、強制を行うためにプロファイルの選択をコンテナランタイムに委ねます。前提条件が満たされなかった場合、Podはリジェクトされ、実行されません。</p>
<p>プロファイルが適用されたかどうか確認するには、AppArmor securityオプションがコンテナ作成イベントに一覧されているかどうかを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events | grep Created
</code></pre></div><pre><code>22s        22s         1         hello-apparmor     Pod       spec.containers{hello}   Normal    Created     {kubelet e2e-test-stclair-node-pool-31nt}   Created container with docker id 269a53b202d3; Security:[seccomp=unconfined apparmor=k8s-apparmor-example-deny-write]
</code></pre><p>proc attrを調べることで、コンテナのルートプロセスが正しいプロファイルで実行されているかどうかを直接確認することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> &lt;pod_name&gt; cat /proc/1/attr/current
</code></pre></div><pre><code>k8s-apparmor-example-deny-write (enforce)
</code></pre><h2 id=example>例</h2>
<p><em>この例は、クラスターがすでにAppArmorのサポート付きでセットアップ済みであることを前提としています。</em></p>
<p>まず、使用したいプロファイルをノード上に読み込む必要があります。このプロファイルは、すべてのファイル書き込みを拒否します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic>#include &lt;tunables/global&gt;</span>

profile k8s-apparmor-example-deny-write <span style=color:#b8860b>flags</span><span style=color:#666>=(</span>attach_disconnected<span style=color:#666>)</span> <span style=color:#666>{</span>
  <span style=color:#080;font-style:italic>#include &lt;abstractions/base&gt;</span>

  file,

  <span style=color:#080;font-style:italic># Deny all file writes.</span>
  deny /** w,
<span style=color:#666>}</span>
</code></pre></div><p>Podがどのノードにスケジュールされるかは予測できないため、プロファイルはすべてのノードに読み込ませる必要があります。この例では、単純にSSHを使ってプロファイルをインストールしますが、<a href=#setting-up-nodes-with-profiles>プロファイルを使用したノードのセットアップ</a>では、他のアプローチについて議論しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>NODES</span><span style=color:#666>=(</span>
    <span style=color:#080;font-style:italic># SSHでアクセス可能なノードのドメイン名</span>
    gke-test-default-pool-239f5d02-gyn2.us-central1-a.my-k8s
    gke-test-default-pool-239f5d02-x1kf.us-central1-a.my-k8s
    gke-test-default-pool-239f5d02-xwux.us-central1-a.my-k8s<span style=color:#666>)</span>
<span style=color:#a2f;font-weight:700>for</span> NODE in <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>NODES</span>[*]<span style=color:#b68;font-weight:700>}</span>; <span style=color:#a2f;font-weight:700>do</span> ssh <span style=color:#b8860b>$NODE</span> <span style=color:#b44>&#39;sudo apparmor_parser -q &lt;&lt;EOF
</span><span style=color:#b44>#include &lt;tunables/global&gt;
</span><span style=color:#b44>
</span><span style=color:#b44>profile k8s-apparmor-example-deny-write flags=(attach_disconnected) {
</span><span style=color:#b44>  #include &lt;abstractions/base&gt;
</span><span style=color:#b44>
</span><span style=color:#b44>  file,
</span><span style=color:#b44>
</span><span style=color:#b44>  # Deny all file writes.
</span><span style=color:#b44>  deny /** w,
</span><span style=color:#b44>}
</span><span style=color:#b44>EOF&#39;</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><p>次に、deny-writeプロファイルを使用した単純な "Hello AppArmor" Podを実行します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/security/hello-apparmor.yaml download=pods/security/hello-apparmor.yaml><code>pods/security/hello-apparmor.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-security-hello-apparmor-yaml')" title="Copy pods/security/hello-apparmor.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-security-hello-apparmor-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-apparmor<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Tell Kubernetes to apply the AppArmor profile &#34;k8s-apparmor-example-deny-write&#34;.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Note that this is ignored if the Kubernetes node is not running version 1.4 or greater.</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>container.apparmor.security.beta.kubernetes.io/hello</span>:<span style=color:#bbb> </span>localhost/k8s-apparmor-example-deny-write<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo &#39;Hello AppArmor!&#39; &amp;&amp; sleep 1h&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f ./hello-apparmor.yaml
</code></pre></div><p>Podイベントを確認すると、PodコンテナがAppArmorプロファイル "k8s-apparmor-example-deny-write" を使用して作成されたことがわかります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events | grep hello-apparmor
</code></pre></div><pre><code>14s        14s         1         hello-apparmor   Pod                                Normal    Scheduled   {default-scheduler }                           Successfully assigned hello-apparmor to gke-test-default-pool-239f5d02-gyn2
14s        14s         1         hello-apparmor   Pod       spec.containers{hello}   Normal    Pulling     {kubelet gke-test-default-pool-239f5d02-gyn2}   pulling image &quot;busybox&quot;
13s        13s         1         hello-apparmor   Pod       spec.containers{hello}   Normal    Pulled      {kubelet gke-test-default-pool-239f5d02-gyn2}   Successfully pulled image &quot;busybox&quot;
13s        13s         1         hello-apparmor   Pod       spec.containers{hello}   Normal    Created     {kubelet gke-test-default-pool-239f5d02-gyn2}   Created container with docker id 06b6cd1c0989; Security:[seccomp=unconfined apparmor=k8s-apparmor-example-deny-write]
13s        13s         1         hello-apparmor   Pod       spec.containers{hello}   Normal    Started     {kubelet gke-test-default-pool-239f5d02-gyn2}   Started container with docker id 06b6cd1c0989
</code></pre><p>コンテナがこのプロファイルで実際に実行されていることを確認するために、コンテナのproc attrをチェックします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> hello-apparmor -- cat /proc/1/attr/current
</code></pre></div><pre><code>k8s-apparmor-example-deny-write (enforce)
</code></pre><p>最後に、ファイルへの書き込みを行おうとすることで、プロファイルに違反すると何が起こるか見てみましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> hello-apparmor touch -- /tmp/test
</code></pre></div><pre><code>touch: /tmp/test: Permission denied
error: error executing remote command: command terminated with non-zero exit code: Error executing in Docker Container: 1
</code></pre><p>まとめとして、読み込まれていないプロファイルを指定しようとするとどうなるのか見てみましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f /dev/stdin &lt;&lt;EOF
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-apparmor-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>container.apparmor.security.beta.kubernetes.io/hello</span>:<span style=color:#bbb> </span>localhost/k8s-apparmor-example-allow-write<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo &#39;Hello AppArmor!&#39; &amp;&amp; sleep 1h&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>EOF<span style=color:#bbb>
</span><span style=color:#bbb></span>pod/hello-apparmor-2 created<span style=color:#bbb>
</span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod hello-apparmor-2
</code></pre></div><pre><code>Name:          hello-apparmor-2
Namespace:     default
Node:          gke-test-default-pool-239f5d02-x1kf/
Start Time:    Tue, 30 Aug 2016 17:58:56 -0700
Labels:        &lt;none&gt;
Annotations:   container.apparmor.security.beta.kubernetes.io/hello=localhost/k8s-apparmor-example-allow-write
Status:        Pending
Reason:        AppArmor
Message:       Pod Cannot enforce AppArmor: profile &quot;k8s-apparmor-example-allow-write&quot; is not loaded
IP:
Controllers:   &lt;none&gt;
Containers:
  hello:
    Container ID:
    Image:     busybox
    Image ID:
    Port:
    Command:
      sh
      -c
      echo 'Hello AppArmor!' &amp;&amp; sleep 1h
    State:              Waiting
      Reason:           Blocked
    Ready:              False
    Restart Count:      0
    Environment:        &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-dnz7v (ro)
Conditions:
  Type          Status
  Initialized   True
  Ready         False
  PodScheduled  True
Volumes:
  default-token-dnz7v:
    Type:    Secret (a volume populated by a Secret)
    SecretName:    default-token-dnz7v
    Optional:   false
QoS Class:      BestEffort
Node-Selectors: &lt;none&gt;
Tolerations:    &lt;none&gt;
Events:
  FirstSeen    LastSeen    Count    From                        SubobjectPath    Type        Reason        Message
  ---------    --------    -----    ----                        -------------    --------    ------        -------
  23s          23s         1        {default-scheduler }                         Normal      Scheduled     Successfully assigned hello-apparmor-2 to e2e-test-stclair-node-pool-t1f5
  23s          23s         1        {kubelet e2e-test-stclair-node-pool-t1f5}             Warning        AppArmor    Cannot enforce AppArmor: profile &quot;k8s-apparmor-example-allow-write&quot; is not loaded
</code></pre><p>PodのステータスはPendingとなり、<code>Pod Cannot enforce AppArmor: profile "k8s-apparmor-example-allow-write" is not loaded</code>(PodはAppArmorを強制できません: プロファイル "k8s-apparmor-example-allow-write" はロードされていません)という役に立つエラーメッセージが表示されています。同じメッセージのイベントも記録されています。</p>
<h2 id=管理>管理</h2>
<h3 id=setting-up-nodes-with-profiles>プロファイルを使用したノードのセットアップ</h3>
<p>現在、KubernetesはAppArmorのプロファイルをノードに読み込むネイティブの仕組みは提供していません。しかし、プロファイルをセットアップする方法は、以下のように様々な方法があります。</p>
<ul>
<li>各ノード上に正しいプロファイルがロードされていることを保証するPodを実行する<a href=/ja/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a>を利用する方法。<a href=https://git.k8s.io/kubernetes/test/images/apparmor-loader>ここ</a>に実装例があります。</li>
<li>ノードの初期化時に初期化スクリプト(例: Salt、Ansibleなど)や初期化イメージを使用する。</li>
<li><a href=#example>例</a>で示したような方法で、プロファイルを各ノードにコピーし、SSHで読み込む。</li>
</ul>
<p>スケジューラーはどのプロファイルがどのノードに読み込まれているのかがわからないため、すべてのプロファイルがすべてのノードに読み込まれていなければなりません。もう1つのアプローチとしては、各プロファイル(あるいはプロファイルのクラス)ごとにノードラベルを追加し、<a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/>node selector</a>を用いてPodが必要なプロファイルを読み込んだノードで実行されるようにする方法もあります。</p>
<h3 id=podsecuritypolicyを使用したプロファイルの制限>PodSecurityPolicyを使用したプロファイルの制限</h3>
<p>PodSecurityPolicy extensionが有効になっている場合、クラスタ全体でAppArmorn制限が適用されます。PodSecurityPolicyを有効にするには、<code>apiserver</code>上で次のフラグを設定する必要があります。</p>
<pre><code>--enable-admission-plugins=PodSecurityPolicy[,others...]
</code></pre><p>AppArmorのオプションはPodSecurityPolicy上でアノテーションとして指定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apparmor.security.beta.kubernetes.io/defaultProfileName</span>:<span style=color:#bbb> </span>&lt;profile_ref&gt;<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apparmor.security.beta.kubernetes.io/allowedProfileNames</span>:<span style=color:#bbb> </span>&lt;profile_ref&gt;[,others...]<span style=color:#bbb>
</span></code></pre></div><p>defaultProfileNameオプションには、何も指定されなかった場合にコンテナにデフォルトで適用されるプロファイルを指定します。allowedProfileNamesオプションには、Podコンテナの実行が許可されるプロファイルのリストを指定します。両方のオプションが指定された場合、デフォルトは許可されなければいけません。プロファイルはコンテナ上で同じフォーマットで指定されます。完全な仕様については、<a href=#api-reference>APIリファレンス</a>を参照してください。</p>
<h3 id=apparmorの無効化>AppArmorの無効化</h3>
<p>クラスタ上でAppArmorを利用可能にしたくない場合、次のコマンドラインフラグで無効化できます。</p>
<pre><code>--feature-gates=AppArmor=false
</code></pre><p>無効化すると、AppArmorプロファイルを含むPodは"Forbidden"エラーで検証に失敗します。ただし、デフォルトのdockerは非特権Pod上では"docker-default"というプロファイルを常に有効化し(AppArmorカーネルモジュールが有効である場合)、フィーチャーゲートで無効化したとしても有効化し続けることに注意してください。AppArmorを無効化するオプションは、AppArmorが一般利用(GA)になったときに削除される予定です。</p>
<h3 id=apparmorを使用するkubernetes-v1-4にアップグレードする>AppArmorを使用するKubernetes v1.4にアップグレードする</h3>
<p>クラスタをv1.4にアップグレードするために、AppArmorに関する操作は必要ありません。ただし、既存のPodがAppArmorのアノテーションを持っている場合、検証(またはPodSecurityPolicy admission)は行われません。もしpermissiveなプロファイルがノードに読み込まれていた場合、悪意のあるユーザーがPodの権限を上述のdocker-defaultより昇格させるために、permissiveなプロファイルを再適用する恐れがあります。これが問題となる場合、<code>apparmor.security.beta.kubernetes.io</code>のアノテーションを含むすべてのPodのクラスターをクリーンアップすることを推奨します。</p>
<h3 id=upgrade-path-to-general-availability>一般利用可能(General Availability)への更新パス</h3>
<p>AppArmorが一般利用可能(GA)になったとき、現在アノテーションで指定しているオプションはフィールドに変換されます。移行中のすべてのアップグレードとダウングレードの経路をサポートするのは非常に微妙であるため、以降が必要になったときに詳細に説明する予定です。最低2リリースの間はフィールドとアノテーションの両方がサポートされるようにする予定です。最低2リリースの後は、アノテーションは明示的に拒否されるようになります。</p>
<h2 id=profilesの作成>Profilesの作成</h2>
<p>AppArmorのプロファイルを正しく指定するのはやっかいな作業です。幸い、その作業を補助するツールがいくつかあります。</p>
<ul>
<li><code>aa-genprof</code>および<code>aa-logprof</code>は、アプリケーションの動作とログを監視することによりプロファイルのルールを生成します。詳しい説明については、<a href=https://gitlab.com/apparmor/apparmor/wikis/Profiling_with_tools>AppArmor documentation</a>を参照してください。</li>
<li><a href=https://github.com/jfrazelle/bane>bane</a>は、Docker向けのAppArmorのプロファイル・ジェネレータです。簡略化されたプロファイル言語を使用しています。</li>
</ul>
<p>プロファイルの生成には、アプリケーションを開発用ワークステーション上でDockerで実行することを推奨します。しかし、実際にPodが実行されるKubernetesノード上でツールを実行してはいけない理由はありません。</p>
<p>AppArmorに関する問題をデバッグするには、システムログをチェックして、特に何が拒否されたのかを確認できます。AppArmorのログは<code>dmesg</code>にverboseメッセージを送り、エラーは通常システムログまたは<code>journalctl</code>で確認できます。詳しい情報は、<a href=https://gitlab.com/apparmor/apparmor/wikis/AppArmor_Failures>AppArmor failures</a>で提供されています。</p>
<h2 id=api-reference>APIリファレンス</h2>
<h3 id=podアノテーション>Podアノテーション</h3>
<p>コンテナが実行するプロファイルを指定します。</p>
<ul>
<li><strong>key</strong>: <code>container.apparmor.security.beta.kubernetes.io/&lt;container_name></code>
ここで、<code>&lt;container_name></code>はPod内のコンテナの名前を一致させます。Pod内の各コンテナごとに別々のプロファイルを指定できます。</li>
<li><strong>value</strong>: 下で説明するプロファイルのリファレンス</li>
</ul>
<h3 id=プロファイルのリファレンス>プロファイルのリファレンス</h3>
<ul>
<li><code>runtime/default</code>: デフォルトのランタイムプロファイルを指します。
<ul>
<li>(PodSecurityPolicyのデフォルトを設定せずに)プロファイルを指定しない場合と同等ですが、AppArmorを有効化する必要があります。</li>
<li>Dockerの場合、非特権コンテナでは<a href=https://docs.docker.com/engine/security/apparmor/><code>docker-default</code></a>プロファイルが選択され、特権コンテナではunconfined(プロファイルなし)が選択されます。</li>
</ul>
</li>
<li><code>localhost/&lt;profile_name></code>: 名前で指定されたノード(localhost)に読み込まれたプロファイルを指します。
<ul>
<li>利用できるプロファイル名の詳細は<a href=https://gitlab.com/apparmor/apparmor/wikis/AppArmor_Core_Policy_Reference#profile-names-and-attachment-specifications>core policy reference</a>で説明されています。</li>
</ul>
</li>
<li><code>unconfined</code>: これは実質的にコンテナ上のAppArmorを無効化します。</li>
</ul>
<p>これ以外のプロファイルリファレンスはすべて無効です。</p>
<h3 id=podsecuritypolicyアノテーション>PodSecurityPolicyアノテーション</h3>
<p>何も指定されなかった場合にコンテナに適用するデフォルトのプロファイルは、以下のように指定します。</p>
<ul>
<li><strong>key</strong>: <code>apparmor.security.beta.kubernetes.io/defaultProfileName</code></li>
<li><strong>value</strong>: 上で説明したプロファイルのリファレンス</li>
</ul>
<p>Podコンテナが指定することを許可するプロファイルのリストは、以下のように指定します。</p>
<ul>
<li><strong>key</strong>: <code>apparmor.security.beta.kubernetes.io/allowedProfileNames</code></li>
<li><strong>value</strong>: カンマ区切りの上述のプロファイルリファレンスのリスト
<ul>
<li>プロファイル名ではエスケープしたカンマは不正な文字ではありませんが、ここでは明示的に許可されません。</li>
</ul>
</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<p>追加のリソースとしては以下のものがあります。</p>
<ul>
<li><a href=https://gitlab.com/apparmor/apparmor/wikis/QuickProfileLanguage>Quick guide to the AppArmor profile language</a></li>
<li><a href=https://gitlab.com/apparmor/apparmor/wikis/Policy_Layout>AppArmor core policy reference</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-97489f0aa8ac2df31a0d6b444a7bde62>5.7 - Service</h1>
</div>
<div class=td-content>
<h1 id=pg-5642e8c51749e4fe2e6a2ccc207f1fab>5.7.1 - 送信元IPを使用する</h1>
<p>Kubernetesクラスター内で実行されているアプリケーションは、Serviceという抽象化を経由して、他のアプリケーションや外の世界との発見や通信を行います。このドキュメントでは、異なる種類のServiceに送られたパケットの送信元IPに何が起こるのか、そして必要に応じてこの振る舞いを切り替える方法について説明します。</p>
<h2 id=始める前に>始める前に</h2>
<h3 id=用語>用語</h3>
<p>このドキュメントでは、以下の用語を使用します。</p>
<dl>
<dt><a href=https://ja.wikipedia.org/wiki/%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E5%A4%89%E6%8F%9B>NAT</a></dt>
<dd>ネットワークアドレス変換(network address translation)</dd>
<dt><a href=https://en.wikipedia.org/wiki/Network_address_translation#SNAT>送信元NAT</a></dt>
<dd>パケットの送信元のIPを置換します。このページでは、通常ノードのIPアドレスを置換することを意味します。</dd>
<dt><a href=https://en.wikipedia.org/wiki/Network_address_translation#DNAT>送信先NAT</a></dt>
<dd>パケットの送信先のIPを置換します。このページでは、通常<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>のIPアドレスを置換することを意味します。</dd>
<dt><a href=/ja/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>VIP</a></dt>
<dd>Kubernetes内のすべての<a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>などに割り当てられる仮想IPアドレス(virtual IP address)です。</dd>
<dt><a href=/ja/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>kube-proxy</a></dt>
<dd>すべてのノード上でServiceのVIPを管理するネットワークデーモンです。</dd>
</dl>
<h3 id=前提条件>前提条件</h3>
<p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
<p>以下の例では、HTTPヘッダー経由で受け取ったリクエストの送信元IPをエコーバックする、小さなnginxウェブサーバーを使用します。次のコマンドでウェブサーバーを作成できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment source-ip-app --image<span style=color:#666>=</span>k8s.gcr.io/echoserver:1.4
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>deployment.apps/source-ip-app created
</code></pre><h2 id=目標>目標</h2>
<ul>
<li>単純なアプリケーションを様々な種類のService経由で公開する</li>
<li>それぞれの種類のServiceがどのように送信元IPのNATを扱うかを理解する</li>
<li>送信元IPを保持することに関わるトレードオフを理解する</li>
</ul>
<h2 id=type-clusterip-を使用したserviceでの送信元ip><code>Type=ClusterIP</code>を使用したServiceでの送信元IP</h2>
<p>kube-proxyが<a href=/ja/docs/concepts/services-networking/service/#proxy-mode-iptables>iptablesモード</a>(デフォルト)で実行されている場合、クラスター内部からClusterIPに送られたパケットに送信元のNATが行われることは決してありません。kube-proxyが実行されているノード上で<code>http://localhost:10249/proxyMode</code>にリクエストを送って、kube-proxyのモードを問い合わせてみましょう。</p>
<pre><code class=language-console data-lang=console>kubectl get nodes
</code></pre><p>出力は次のようになります。</p>
<pre><code>NAME                           STATUS     ROLES    AGE     VERSION
kubernetes-node-6jst   Ready      &lt;none&gt;   2h      v1.13.0
kubernetes-node-cx31   Ready      &lt;none&gt;   2h      v1.13.0
kubernetes-node-jj1t   Ready      &lt;none&gt;   2h      v1.13.0
</code></pre><p>これらのノードの1つでproxyモードを取得します(kube-proxyはポート10249をlistenしています)。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、問い合わせを行いたいノード上のシェルで実行してください。</span>
curl http://localhost:10249/proxyMode
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>iptables
</code></pre><p>source IPアプリのServiceを作成することで、送信元IPが保持されているかテストできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment source-ip-app --name<span style=color:#666>=</span>clusterip --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8080</span>
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>service/clusterip exposed
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc clusterip
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE
clusterip    ClusterIP   10.0.170.92   &lt;none&gt;        80/TCP    51s
</code></pre><p>そして、同じクラスター上のPodから<code>ClusterIP</code>にアクセスします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run busybox -it --image<span style=color:#666>=</span>busybox --restart<span style=color:#666>=</span>Never --rm
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>Waiting for pod default/busybox to be running, status is Pending, pod ready: false
If you don't see a command prompt, try pressing enter.

</code></pre><p>これで、Podの内部でコマンドが実行できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、&#34;kubectl run&#34; のターミナルの内部で実行してください</span>
ip addr
</code></pre></div><pre><code>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
3: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1460 qdisc noqueue
    link/ether 0a:58:0a:f4:03:08 brd ff:ff:ff:ff:ff:ff
    inet 10.244.3.8/24 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::188a:84ff:feb0:26a5/64 scope link
       valid_lft forever preferred_lft forever
</code></pre><p>そして、<code>wget</code>を使用してローカルのウェブサーバーに問い合わせます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># &#34;10.0.170.92&#34; の部分をService名が&#34;clusterip&#34;のIPv4アドレスに置き換えてください</span>
wget -qO - 10.0.170.92
</code></pre></div><pre><code>CLIENT VALUES:
client_address=10.244.3.8
command=GET
...
</code></pre><p><code>client_address</code>は常にクライアントのPodのIPアドレスになります。これは、クライアントのPodとサーバーのPodが同じノード内にあっても異なるノードにあっても変わりません。</p>
<h2 id=type-nodeport-を使用したserviceでの送信元ip><code>Type=NodePort</code>を使用したServiceでの送信元IP</h2>
<p><a href=/ja/docs/concepts/services-networking/service/#nodeport><code>Type=NodePort</code></a>を使用したServiceに送られたパケットは、デフォルトで送信元のNATが行われます。<code>NodePort</code> Serviceを作ることでテストできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment source-ip-app --name<span style=color:#666>=</span>nodeport --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8080</span> --type<span style=color:#666>=</span>NodePort
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>service/nodeport exposed
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>NODEPORT</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.spec.ports[0].nodePort}&#34;</span> services nodeport<span style=color:#a2f;font-weight:700>)</span>
<span style=color:#b8860b>NODES</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{ $.items[*].status.addresses[?(@.type==&#34;InternalIP&#34;)].address }&#39;</span><span style=color:#a2f;font-weight:700>)</span>
</code></pre></div><p>クラウドプロバイダーで実行する場合、上に示した<code>nodes:nodeport</code>に対してファイアウォールのルールを作成する必要があるかもしれません。それでは、上で割り当てたノードポート経由で、クラスターの外部からServiceにアクセスしてみましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> node in <span style=color:#b8860b>$NODES</span>; <span style=color:#a2f;font-weight:700>do</span> curl -s <span style=color:#b8860b>$node</span>:<span style=color:#b8860b>$NODEPORT</span> | grep -i client_address; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>client_address=10.180.1.1
client_address=10.240.0.5
client_address=10.240.0.3
</code></pre><p>これらは正しいクライアントIPではなく、クラスターのinternal IPであることがわかります。ここでは、次のようなことが起こっています。</p>
<ul>
<li>クライアントがパケットを<code>node2:nodePort</code>に送信する</li>
<li><code>node2</code>は、パケット内の送信元IPアドレスを自ノードのIPアドレスに置換する(SNAT)</li>
<li><code>node2</code>は、パケット内の送信先IPアドレスをPodのIPアドレスに置換する</li>
<li>パケットはnode1にルーティングされ、endpointにルーティングされる</li>
<li>Podからの応答がnode2にルーティングされて戻ってくる</li>
<li>Podからの応答がクライアントに送り返される</li>
</ul>
<p>図で表すと次のようになります。</p>
<div class=mermaid>
graph LR;
client(client)-->node2[Node 2];
node2-->client;
node2-. SNAT .->node1[Node 1];
node1-. SNAT .->node2;
node1-->endpoint(Endpoint);
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
class node1,node2,endpoint k8s;
class client plain;
</div>
<noscript>
<style type=text/css>.mermaid{display:none}</style>
<h4>[JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view content]</h4>
</noscript>
<p>クライアントのIPが失われることを回避するために、Kubernetesには<a href=/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip>クライアントの送信元IPを保持する</a>機能があります。<code>service.spec.externalTrafficPolicy</code>の値を<code>Local</code>に設定すると、kube-proxyはローカルに存在するエンドポイントへのプロキシーリクエストだけをプロキシーし、他のノードへはトラフィックを転送しなくなります。このアプローチでは、オリジナルの送信元IPアドレスが保持されます。ローカルにエンドポイントが存在しない場合には、そのノードに送信されたパケットは損失します。そのため、エンドポイントに到達するパケットに適用する可能性のあるパケット処理ルールでは、送信元IPが正しいことを信頼できます。</p>
<p>次のようにして<code>service.spec.externalTrafficPolicy</code>フィールドを設定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch svc nodeport -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;externalTrafficPolicy&#34;:&#34;Local&#34;}}&#39;</span>
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>service/nodeport patched
</code></pre><p>そして、再度テストしてみます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> node in <span style=color:#b8860b>$NODES</span>; <span style=color:#a2f;font-weight:700>do</span> curl --connect-timeout <span style=color:#666>1</span> -s <span style=color:#b8860b>$node</span>:<span style=color:#b8860b>$NODEPORT</span> | grep -i client_address; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>client_address=198.51.100.79
</code></pre><p>今度は、<em>正しい</em>クライアントIPが含まれる応答が1つだけ得られました。これは、エンドポイントのPodが実行されているノードから来たものです。</p>
<p>ここでは、次のようなことが起こっています。</p>
<ul>
<li>クライアントがパケットをエンドポイントが存在しない<code>node2:nodePort</code>に送信する</li>
<li>パケットが損失する</li>
<li>クライアントがパケットをエンドポイントが<em>存在する</em><code>node1:nodePort</code>に送信する</li>
<li>node1は、正しい送信元IPを持つパケットをエンドポイントにルーティングする</li>
</ul>
<p>図で表すと次のようになります。</p>
<div class=mermaid>
graph TD;
client --> node1[Node 1];
client(client) --x node2[Node 2];
node1 --> endpoint(endpoint);
endpoint --> node1;
classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;
classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;
class node1,node2,endpoint k8s;
class client plain;
</div>
<noscript>
<style type=text/css>.mermaid{display:none}</style>
<h4>[JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view content]</h4>
</noscript>
<h2 id=type-loadbalancer-を使用したserviceでの送信元ip><code>Type=LoadBalancer</code>を使用したServiceでの送信元IP</h2>
<p><a href=/ja/docs/concepts/services-networking/service/#loadbalancer><code>Type=LoadBalancer</code></a>を使用したServiceに送られたパケットは、デフォルトで送信元のNATが行われます。<code>Ready</code>状態にあるすべてのスケジュール可能なKubernetesのNodeは、ロードバランサーからのトラフィックを受付可能であるためです。そのため、エンドポイントが存在しないノードにパケットが到達した場合、システムはエンドポイントが<em>存在する</em>ノードにパケットをプロシキーします。このとき、(前のセクションで説明したように)パケットの送信元IPがノードのIPに置換されます。</p>
<p>ロードバランサー経由でsource-ip-appを公開することで、これをテストできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment source-ip-app --name<span style=color:#666>=</span>loadbalancer --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8080</span> --type<span style=color:#666>=</span>LoadBalancer
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>service/loadbalancer exposed
</code></pre><p>ServiceのIPアドレスを表示します。</p>
<pre><code class=language-console data-lang=console>kubectl get svc loadbalancer
</code></pre><p>出力は次のようになります。</p>
<pre><code>NAME           TYPE           CLUSTER-IP    EXTERNAL-IP       PORT(S)   AGE
loadbalancer   LoadBalancer   10.0.65.118   203.0.113.140     80/TCP    5m
</code></pre><p>次に、Serviceのexternal-ipにリクエストを送信します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl 203.0.113.140
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>CLIENT VALUES:
client_address=10.240.0.5
...
</code></pre><p>しかし、Google Kubernetes EngineやGCE上で実行している場合、同じ<code>service.spec.externalTrafficPolicy</code>フィールドを<code>Local</code>に設定すると、ロードバランサーからのトラフィックを受け付け可能なノードのリストから、Serviceエンドポイントが<em>存在しない</em>ノードが強制的に削除されます。この動作は、ヘルスチェックを意図的に失敗させることによって実現されています。</p>
<p>図で表すと次のようになります。</p>
<p><img src=/images/docs/sourceip-externaltrafficpolicy.svg alt="Source IP with externalTrafficPolicy"></p>
<p>アノテーションを設定することで動作をテストできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch svc loadbalancer -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;externalTrafficPolicy&#34;:&#34;Local&#34;}}&#39;</span>
</code></pre></div><p>Kubernetesにより割り当てられた<code>service.spec.healthCheckNodePort</code>フィールドをすぐに確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc loadbalancer -o yaml | grep -i healthCheckNodePort
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>  </span><span style=color:green;font-weight:700>healthCheckNodePort</span>:<span style=color:#bbb> </span><span style=color:#666>32122</span><span style=color:#bbb>
</span></code></pre></div><p><code>service.spec.healthCheckNodePort</code>フィールドは、<code>/healthz</code>でhealth checkを配信しているすべてのノード上のポートを指しています。次のコマンドでテストできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod -o wide -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>source-ip-app
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME                            READY     STATUS    RESTARTS   AGE       IP             NODE
source-ip-app-826191075-qehz4   1/1       Running   0          20h       10.180.1.136   kubernetes-node-6jst
</code></pre><p><code>curl</code>を使用して、さまざまなノード上の<code>/healthz</code>エンドポイントからデータを取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは選んだノードのローカル上で実行してください</span>
curl localhost:32122/healthz
</code></pre></div><pre><code>1 Service Endpoints found
</code></pre><p>ノードが異なると、得られる結果も異なる可能性があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、選んだノード上でローカルに実行してください</span>
curl localhost:32122/healthz
</code></pre></div><pre><code>No Service Endpoints Found
</code></pre><p><a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>上で実行中のコントローラーは、クラウドのロードバランサーを割り当てる責任があります。同じコントローラーは、各ノード上のポートやパスを指すHTTPのヘルスチェックも割り当てます。エンドポイントが存在しない2つのノードがヘルスチェックに失敗するまで約10秒待った後、<code>curl</code>を使用してロードバランサーのIPv4アドレスに問い合わせます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl 203.0.113.140
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>CLIENT VALUES:
client_address=198.51.100.79
...
</code></pre><h2 id=クロスプラットフォームのサポート>クロスプラットフォームのサポート</h2>
<p><code>Type=LoadBalancer</code>を使用したServiceで送信元IPを保持する機能を提供しているのは一部のクラウドプロバイダだけです。実行しているクラウドプロバイダによっては、以下のように異なる方法でリクエストを満たす場合があります。</p>
<ol>
<li>
<p>クライアントとのコネクションをプロキシーが終端し、ノードやエンドポイントとの接続には新しいコネクションが開かれる。このような場合、送信元IPは常にクラウドのロードバランサーのものになり、クライアントのIPにはなりません。</p>
</li>
<li>
<p>クライアントからロードバランサーのVIPに送信されたリクエストが、中間のプロキシーではなく、クライアントの送信元IPとともにノードまで到達するようなパケット転送が使用される。</p>
</li>
</ol>
<p>1つめのカテゴリーのロードバランサーの場合、真のクライアントIPと通信するために、 HTTPの<a href=https://tools.ietf.org/html/rfc7239#section-5.2>Forwarded</a>ヘッダーや<a href=https://ja.wikipedia.org/wiki/X-Forwarded-For>X-FORWARDED-FOR</a>ヘッダー、<a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>proxy protocol</a>などの、ロードバランサーとバックエンドの間で合意されたプロトコルを使用する必要があります。2つ目のカテゴリーのロードバランサーの場合、Serviceの<code>service.spec.healthCheckNodePort</code>フィールドに保存されたポートを指すHTTPのヘルスチェックを作成することで、上記の機能を活用できます。</p>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>Serviceを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete svc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>source-ip-app
</code></pre></div><p>Deployment、ReplicaSet、Podを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment source-ip-app
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>Service経由でアプリケーションに接続する</a>方法についてさらに学ぶ。</li>
<li><a href=/docs/tasks/access-application-cluster/create-external-load-balancer/>External Load Balancerを作成する</a>方法について学ぶ。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b00a88a07ceb21b1a83e5822e0c86c1d>6 - リファレンス</h1>
<p>本セクションには、Kubernetesのドキュメントのリファレンスが含まれています。</p>
<h2 id=apiリファレンス>APIリファレンス</h2>
<ul>
<li><a href=/docs/reference/using-api/>Kubernetes API概要</a> - Kubernetes APIの概要です。</li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.26/>Kubernetes APIリファレンス v1.26</a></li>
</ul>
<h2 id=apiクライアントライブラリー>APIクライアントライブラリー</h2>
<p>プログラミング言語からKubernetesのAPIを呼ぶためには、<a href=/docs/reference/using-api/client-libraries/>クライアントライブラリー</a>を使うことができます。公式にサポートしているクライアントライブラリー:</p>
<ul>
<li><a href=https://github.com/kubernetes/client-go/>Kubernetes Go client library</a></li>
<li><a href=https://github.com/kubernetes-client/python>Kubernetes Python client library</a></li>
<li><a href=https://github.com/kubernetes-client/java>Kubernetes Java client library</a></li>
<li><a href=https://github.com/kubernetes-client/javascript>Kubernetes JavaScript client library</a></li>
</ul>
<h2 id=cliリファレンス>CLIリファレンス</h2>
<ul>
<li><a href=/ja/docs/reference/kubectl/overview/>kubectl</a> - コマンドの実行やKubernetesクラスターの管理に使う主要なCLIツールです。
<ul>
<li><a href=/ja/docs/reference/kubectl/jsonpath/>JSONPath</a> - kubectlで<a href=https://goessner.net/articles/JsonPath/>JSONPath記法</a>を使うための構文ガイドです。</li>
</ul>
</li>
<li><a href=ja/docs/reference/setup-tools/kubeadm/>kubeadm</a> - セキュアなKubernetesクラスターを簡単にプロビジョニングするためのCLIツールです。</li>
</ul>
<h2 id=コンポーネントリファレンス>コンポーネントリファレンス</h2>
<ul>
<li><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> - 各ノード上で動作する最も重要なノードエージェントです。kubeletは一通りのPodSpecを受け取り、コンテナーが実行中で正常であることを確認します。</li>
<li><a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a> - Pod、Service、Replication Controller等、APIオブジェクトのデータを検証・設定するREST APIサーバーです。</li>
<li><a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a> - Kubernetesに同梱された、コアのコントロールループを埋め込むデーモンです。</li>
<li><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> - 単純なTCP/UDPストリームのフォワーディングや、一連のバックエンド間でTCP/UDPのラウンドロビンでのフォワーディングを実行できます。</li>
<li><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a> - 可用性、パフォーマンス、およびキャパシティを管理するスケジューラーです。
<ul>
<li><a href=/docs/reference/scheduling/policies>kube-schedulerポリシー</a></li>
<li><a href=/docs/reference/scheduling/profiles>kube-schedulerプロファイル</a></li>
</ul>
</li>
</ul>
<h2 id=設計のドキュメント>設計のドキュメント</h2>
<p>Kubernetesの機能に関する設計ドキュメントのアーカイブです。<a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md>Kubernetesアーキテクチャ</a> と<a href=https://git.k8s.io/community/contributors/design-proposals>Kubernetesデザイン概要</a>から読み始めると良いでしょう。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2b03679960950df772fb4fe7d78427b9>6.1 - 標準化用語集</h1>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b>6.2 - 認証</h1>
<p>このページでは、認証の概要について説明します。</p>
<h2 id=kubernetesにおけるユーザー>Kubernetesにおけるユーザー</h2>
<p>すべてのKubernetesクラスターには、2種類のユーザーがあります。Kubernetesによって管理されるサービスアカウントと、通常のユーザーです。</p>
<p>クラスターから独立したサービスは通常のユーザーを以下の方法で管理することを想定されています。</p>
<ul>
<li>秘密鍵を配布する管理者</li>
<li>KeystoneやGoogle Accountsのようなユーザーストア</li>
<li>ユーザー名とパスワードのリストを持つファイル</li>
</ul>
<p>これを考慮すると、 <em>Kubernetesは通常のユーザーアカウントを表すオブジェクトを持ちません。</em> APIコールを介して、通常のユーザーをクラスターに追加することはできません。</p>
<p>APIコールを介して通常のユーザーを追加できませんが、クラスターの認証局(CA)に署名された有効な証明書で表すユーザーは認証済みと判断されます。この構成では、Kubernetesは証明書の‘subject’内にある一般的な名前フィールド(例えば、“/CN=bob”)からユーザー名を特定します。そこから、ロールベースアクセス制御(RBAC)サブシステムは、ユーザーがあるリソースにおける特定の操作を実行するために認証済みかどうか特定します。詳細は、 <a href=/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user>証明書要求</a>内の通常のユーザーの題目を参照してください。</p>
<p>対照的に、サービスアカウントはKubernetes APIによって管理されるユーザーです。サービスアカウントは特定の名前空間にバインドされており、APIサーバーによって自動的に作成されるか、APIコールによって手動で作成されます。サービスアカウントは、<code>Secrets</code>として保存された資格情報の集合に紐付けられています。これをPodにマウントすることで、クラスター内のプロセスがKubernetes APIと通信できるようにします。</p>
<p>APIリクエストは、通常のユーザーかサービスアカウントに紐付けられているか、<a href=#anonymous-requests>匿名リクエスト</a>として扱われます。つまり、ワークステーションで<code>kubectl</code>を入力する人間のユーザーから、ノード上の<code>kubelets</code>やコントロールプレーンのメンバーまで、クラスター内外の全てのプロセスは、APIサーバーへのリクエストを行う際に認証を行うか匿名ユーザーとして扱われる必要があります。</p>
<h2 id=認証戦略>認証戦略</h2>
<p>Kubernetesは、クライアント証明書、Bearerトークン、認証プロキシー、HTTP Basic認証を使い、認証プラグインを通してAPIリクエストを認証します。APIサーバーにHTTPリクエストが送信されると、プラグインは以下の属性をリクエストに関連付けようとします。</p>
<ul>
<li>ユーザー名: エンドユーザーを識別する文字列です。一般的にな値は、<code>kube-admin</code>や<code>jane@example.com</code>です。</li>
<li>UID: エンドユーザーを識別する文字列であり、ユーザー名よりも一貫性と一意性を持たせようとするものです。</li>
<li>グループ: 各要素がユーザーの役割を示すような意味を持つ文字列の集合です。<code>system:masters</code>や<code>devops-team</code>といった値が一般的です。</li>
<li>追加フィールド: 認証者が有用と思われる追加情報を保持する文字列のリストに対する、文字列のマップです。</li>
</ul>
<p>すべての値は認証システムに対して非透過であり、<a href=/docs/reference/access-authn-authz/authorization/>認可機能</a>が解釈した場合にのみ意味を持ちます。</p>
<p>一度に複数の認証方法を有効にすることができます。通常は、以下のように少なくとも2つの方法を使用するべきです。</p>
<ul>
<li>サービスアカウント用のサービスアカウントトークン</li>
<li>ユーザー認証のための、少なくとも1つの他の方法</li>
</ul>
<p>複数の認証モジュールが有効化されている場合、リクエストの認証に成功した最初のモジュールが、評価が簡略化します。APIサーバーは、認証の実行順序を保証しません。</p>
<p><code>system:authenticated</code>グループには、すべての認証済みユーザーのグループのリストが含まれます。</p>
<p>他の認証プロトコル(LDAP、SAML、Kerberos、X509スキームなど)との統合は、<a href=#authenticating-proxy>認証プロキシー</a>や<a href=#webhook-token-authentication>認証Webhook</a>を使用して実施できます。</p>
<h3 id=x509クライアント証明書>X509クライアント証明書</h3>
<p>クライアント証明書認証は、APIサーバーに<code>--client-ca-file=SOMEFILE</code>オプションを渡すことで有効になります。参照されるファイルには、APIサーバーに提示されたクライアント証明書を検証するために使用する1つ以上の認証局が含まれている必要があります。クライアント証明書が提示され、検証された場合、サブジェクトのCommon Nameがリクエストのユーザー名として使用されます。Kubernetes1.4時点では、クライアント証明書は、証明書のOrganizationフィールドを使用して、ユーザーのグループメンバーシップを示すこともできます。あるユーザーに対して複数のグループメンバーシップを含めるには、証明書に複数のOrganizationフィールドを含めます。</p>
<p>例えば、証明書署名要求を生成するために、<code>openssl</code>コマンドラインツールを使用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>openssl req -new -key jbeda.pem -out jbeda-csr.pem -subj <span style=color:#b44>&#34;/CN=jbeda/O=app1/O=app2&#34;</span>
</code></pre></div><p>これにより、"app1"と"app2"の2つのグループに属するユーザー名"jbeda"の証明書署名要求が作成されます。</p>
<p>クライアント証明書の生成方法については、<a href=/ja/docs/concepts/cluster-administration/certificates/>証明書の管理</a>を参照してください。</p>
<h3 id=静的なトークンファイル>静的なトークンファイル</h3>
<p>コマンドラインで<code>--token-auth-file=SOMEFILE</code>オプションを指定すると、APIサーバーはファイルからBearerトークンを読み込みます。現在のところ、トークンの有効期限は無く、APIサーバーを再起動しない限りトークンのリストを変更することはできません。</p>
<p>トークンファイルは、トークン、ユーザー名、ユーザーUIDの少なくとも3つの列を持つcsvファイルで、その後にオプションでグループ名が付きます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>複数のグループがある場合はダブルクォートで囲む必要があります。</p>
<pre><code class=language-conf data-lang=conf>token,user,uid,&quot;group1,group2,group3&quot;
</code></pre>
</div>
<h4 id=putting-a-bearer-token-in-a-request>リクエストにBearerトークンを含める</h4>
<p>HTTPクライアントからBearerトークン認証を利用する場合、APIサーバーは<code>Bearer THETOKEN</code>という値を持つ<code>Authorization</code>ヘッダーを待ち受けます。Bearerトークンは、HTTPのエンコーディングとクォート機能を利用してHTTPヘッダーの値に入れることができる文字列でなければなりません。例えば、Bearerトークンが<code>31ada4fd-adec-460c-809a-9e56ceb75269</code>であれば、HTTPのヘッダを以下のようにします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269
</span></code></pre></div><h3 id=ブートストラップトークン>ブートストラップトークン</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>新しいクラスタの効率的なブートストラップを可能にするために、Kubernetesには<em>ブートストラップトークン</em>と呼ばれる動的に管理されたBearerトークンタイプが含まれています。これらのトークンは、<code>kube-system</code>名前空間にSecretsとして格納され、動的に管理したり作成したりすることができます。コントローラーマネージャーには、TokenCleanerコントローラーが含まれており、ブートストラップトークンの有効期限が切れると削除します。</p>
<p>トークンの形式は<code>[a-z0-9]{6}.[a-z0-9]{16}</code>です。最初のコンポーネントはトークンIDであり、第2のコンポーネントはToken Secretです。以下のように、トークンをHTTPヘッダーに指定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Authorization: Bearer 781292.db7bc3a58fc5f07e
</span></code></pre></div><p>APIサーバーの<code>--enable-bootstrap-token-auth</code>フラグで、Bootstrap Token Authenticatorを有効にする必要があります。TokenCleanerコントローラーを有効にするには、コントローラーマネージャーの<code>--controllers</code>フラグを使います。<code>--controllers=*,tokencleaner</code>のようにして行います。クラスターをブートストラップするために<code>kubeadm</code>を使用している場合は、<code>kubeadm</code>がこれを代行してくれます。</p>
<p>認証機能は<code>system:bootstrap:&lt;Token ID></code>という名前で認証します。これは<code>system:bootstrappers</code>グループに含まれます。名前とグループは意図的に制限されており、ユーザーがブートストラップ後にこれらのトークンを使わないようにしています。ユーザー名とグループは、クラスタのブートストラップをサポートする適切な認可ポリシーを作成するために使用され、<code>kubeadm</code>によって使用されます。</p>
<p>ブートストラップトークンの認証機能やコントローラーについての詳細な説明、<code>kubeadm</code>でこれらのトークンを管理する方法については、<a href=/docs/reference/access-authn-authz/bootstrap-tokens/>ブートストラップトークン</a>を参照してください。</p>
<h3 id=サービスアカウントトークン>サービスアカウントトークン</h3>
<p>サービスアカウントは、自動的に有効化される認証機能で、署名されたBearerトークンを使ってリクエストを検証します。このプラグインは、オプションとして2つのフラグを取ります。</p>
<ul>
<li><code>--service-account-key-file</code>: Bearerトークンに署名するためのPEMエンコードされた鍵を含むファイルです。指定しない場合は、APIサーバーのTLS秘密鍵が使われます。</li>
<li><code>--service-account-lookup</code>: 有効にすると、APIから削除されたトークンは取り消されます。</li>
</ul>
<p>サービスアカウントは通常、APIサーバーによって自動的に作成され、<code>ServiceAccount</code><a href=/docs/reference/access-authn-authz/admission-controllers/>Admission Controller</a>を介してクラスター内のPodに関連付けられます。Bearerトークンは、Podのよく知られた場所にマウントされ、これによりクラスター内のプロセスがAPIサーバー通信できるようになります。アカウントは<code>PodSpec</code>の<code>serviceAccountName</code>フィールドを使って、明示的にPodに関連付けることができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 自動で行われるため、通常<code>serviceAccountName</code>は省略します。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># このapiVersionは、Kubernetes1.9時点で適切です</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>bob-the-bot<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></code></pre></div><p>サービスアカウントのBearerトークンは、クラスター外で使用するために完全に有効であり、Kubernetes APIと通信したい長期的なジョブのアイデンティティを作成するために使用することができます。サービスアカウントを手動で作成するには、単に<code>kubectl create serviceaccount (NAME)</code>コマンドを使用します。これにより、現在の名前空間にサービスアカウントと関連するSecretが作成されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl create serviceaccount jenkins
</code></pre></div><pre><code class=language-none data-lang=none>serviceaccount &quot;jenkins&quot; created
</code></pre><p>以下のように、関連するSecretを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get serviceaccounts jenkins -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>secrets</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jenkins-token-1yvwg<span style=color:#bbb>
</span></code></pre></div><p>作成されたSecretは、APIサーバーのパブリック認証局と署名されたJSON Web Token(JWT)を保持します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get secret jenkins-token-1yvwg -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ca.crt</span>:<span style=color:#bbb> </span>(base64でエンコードされたAPIサーバーの認証局)<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>ZGVmYXVsdA==<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token</span>:<span style=color:#bbb> </span>(base64でエンコードされたBearerトークン)<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Secretは常にbase64でエンコードされるため、これらの値もbase64でエンコードされています。
</div>
<p>署名されたJWTは、与えられたサービスアカウントとして認証するためのBearerトークンとして使用できます。トークンをリクエストに含める方法については、<a href=#putting-a-bearer-token-in-a-request>リクエストにBearerトークンを含める</a>を参照してください。通常、これらのSecretはAPIサーバーへのクラスタ内アクセス用にPodにマウントされますが、クラスター外からも使用することができます。</p>
<p>サービスアカウントは、ユーザー名<code>system:serviceaccount:(NAMESPACE):(SERVICEACCOUNT)</code>で認証され、グループ<code>system:serviceaccounts</code>と<code>system:serviceaccounts:(NAMESPACE)</code>に割り当てられます。</p>
<p>警告: サービスアカウントトークンはSecretに保持されているため、Secretにアクセスできるユーザーは誰でもサービスアカウントとして認証することができます。サービスアカウントに権限を付与したり、Secretの読み取り機能を付与したりする際には注意が必要です。</p>
<h3 id=openid-connectトークン>OpenID Connectトークン</h3>
<p><a href=https://openid.net/connect/>OpenID Connect</a>は、Azure Active Directory、Salesforce、Googleなど、いくつかのOAuth2プロバイダーでサポートされているOAuth2の一種です。
このプロトコルのOAuth2の主な拡張機能は、<a href=https://openid.net/specs/openid-connect-core-1_0.html#IDToken>ID Token</a>と呼ばれる、アクセストークンとアクセストークンと一緒に返される追加フィールドです。
このトークンは、ユーザーの電子メールなどのよく知られたフィールドを持つJSON Web Token(JWT)であり、サーバーによって署名されています。トークンをリクエストに含める方法については、<a href=#putting-a-bearer-token-in-a-request>リクエストにBearerトークンを含める</a>を参照してください。</p>
<p><img src=/images/docs/admin/k8s_oidc_login.svg alt="Kubernetes OpenID Connect Flow"></p>
<ol>
<li>IDプロバイダーにログインします</li>
<li>IDプロバイダーは、<code>access_token</code>、<code>id_token</code>、<code>refresh_token</code>を提供します</li>
<li><code>kubectl</code>を使う場合は、<code>--token</code>フラグで<code>id_token</code>を使うか、<code>kubeconfig</code>に直接追加してください</li>
<li><code>kubectl</code>は、<code>id_token</code>をAuthorizationと呼ばれるヘッダーでAPIサーバーに送ります</li>
<li>APIサーバーは、設定で指定された証明書と照合することで、JWT署名が有効であることを確認します</li>
<li><code>id_token</code>の有効期限が切れていないことを確認します</li>
<li>ユーザーが認可されていることを確認します</li>
<li>認可されると、APIサーバーは<code>kubectl</code>にレスポンスを返します</li>
<li><code>kubectl</code>はユーザーにフィードバックを提供します</li>
</ol>
<p>自分が誰であるかを確認するために必要なデータはすべて<code>id_token</code>の中にあるので、KubernetesはIDプロバイダーと通信する必要がありません。すべてのリクエストがステートレスであるモデルでは、これは非常に認証のためのスケーラブルなソリューションを提供します。一方で、以下のようにいくつか課題があります。</p>
<ol>
<li>Kubernetesには、認証プロセスを起動するための"Webインターフェース"がありません。クレデンシャルを収集するためのブラウザやインターフェースがないため、まずIDプロバイダに認証を行う必要があります。</li>
<li><code>id_token</code>は、取り消すことができません。これは証明書のようなもので、有効期限が短い(数分のみ)必要があるので、数分ごとに新しいトークンを取得しなければならないのは非常に面倒です。</li>
<li>Kubernetesダッシュボードへの認証において、<code>kubectl proxy</code>コマンドや<code>id_token</code>を注入するリバースプロキシーを使う以外に、簡単な方法はありません。</li>
</ol>
<h4 id=apiサーバーの設定>APIサーバーの設定</h4>
<p>プラグインを有効にするには、APIサーバーで以下のフラグを設定します。</p>
<table>
<thead>
<tr>
<th>パラメーター</th>
<th>説明</th>
<th>例</th>
<th>必須か</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--oidc-issuer-url</code></td>
<td>APIサーバーが公開署名鍵を発見できるようにするプロバイダーのURLです。 <code>https://</code>スキームを使用するURLのみが受け入れられます。これは通常、"https://accounts.google.com"や"https://login.salesforce.com"のようにパスを持たないプロバイダのディスカバリーURLです。このURLは、<code>.well-known/openid-configuration</code>の下のレベルを指す必要があります。</td>
<td>ディスカバリーURLが<code>https://accounts.google.com/.well-known/openid-configuration</code>である場合、値は<code>https://accounts.google.com</code>とします。</td>
<td>はい</td>
</tr>
<tr>
<td><code>--oidc-client-id</code></td>
<td>すべてのトークンが発行されなければならないクライアントIDです。</td>
<td>kubernetes</td>
<td>はい</td>
</tr>
<tr>
<td><code>--oidc-username-claim</code></td>
<td>ユーザー名として使用するJWTのクレームを指定します。デフォルトでは<code>sub</code>が使用されますが、これはエンドユーザーの一意の識別子であることが期待されます。管理者はプロバイダーに応じて<code>email</code>や<code>name</code>などの他のクレームを選択することができます。ただし、他のプラグインとの名前の衝突を防ぐために、<code>email</code>以外のクレームには、プレフィックスとして発行者のURLが付けられます。</td>
<td>sub</td>
<td>いいえ</td>
</tr>
<tr>
<td><code>--oidc-username-prefix</code></td>
<td>既存の名前(<code>system:</code>ユーザーなど)との衝突を防ぐために、ユーザー名の前にプレフィックスを付加します。例えば<code>oidc:</code>という値は、<code>oidc:jane.doe</code>のようなユーザー名を生成します。このフラグが指定されておらず、<code>--oidc-username-claim</code>が<code>email</code>以外の値である場合、プレフィックスのデフォルトは<code>(Issuer URL)#</code>で、<code>(Issuer URL)</code>は<code>--oidc-issuer-url</code>の値です。すべてのプレフィックスを無効にするためには、<code>-</code>という値を使用できます。</td>
<td><code>oidc:</code></td>
<td>いいえ</td>
</tr>
<tr>
<td><code>--oidc-groups-claim</code></td>
<td>ユーザーのグループとして使用するJWTのクレームです。クレームがある場合は、文字列の配列である必要があります。</td>
<td>groups</td>
<td>いいえ</td>
</tr>
<tr>
<td><code>--oidc-groups-prefix</code></td>
<td>既存の名前(<code>system:</code>グループなど)との衝突を防ぐために、グループ名の前にプレフィックスを付加します。例えば<code>oidc:</code>という値は、<code>oidc:engineering</code>や<code>oidc:infra</code>のようなグループ名を生成します。</td>
<td><code>oidc:</code></td>
<td>いいえ</td>
</tr>
<tr>
<td><code>--oidc-required-claim</code></td>
<td>IDトークンの中の必須クレームを記述するkey=valueのペアです。設定されている場合、クレームが一致する値でIDトークンに存在することが検証されます。このフラグを繰り返して複数のクレームを指定します。</td>
<td><code>claim=value</code></td>
<td>いいえ</td>
</tr>
<tr>
<td><code>--oidc-ca-file</code></td>
<td>IDプロバイダーのWeb証明書に署名した認証局の証明書へのパスです。デフォルトはホストのルート認証局が指定されます。</td>
<td><code>/etc/kubernetes/ssl/kc-ca.pem</code></td>
<td>いいえ</td>
</tr>
</tbody>
</table>
<p>重要なのは、APIサーバーはOAuth2クライアントではなく、ある単一の発行者を信頼するようにしか設定できないことです。これにより、サードパーティーに発行されたクレデンシャルを信頼せずに、Googleのようなパブリックプロバイダーを使用することができます。複数のOAuthクライアントを利用したい管理者は、<code>azp</code>クレームをサポートしているプロバイダや、あるクライアントが別のクライアントに代わってトークンを発行できるような仕組みを検討する必要があります。</p>
<p>KubernetesはOpenID Connect IDプロバイダーを提供していません。既存のパブリックなOpenID Connect IDプロバイダー(Googleや<a href=https://connect2id.com/products/nimbus-oauth-openid-connect-sdk/openid-connect-providers>その他</a>など)を使用できます。もしくは、CoreOS <a href=https://github.com/coreos/dex>dex</a>、<a href=https://github.com/keycloak/keycloak>Keycloak</a>、CloudFoundry<a href=https://github.com/cloudfoundry/uaa>UAA</a>、Tremolo Securityの<a href=https://github.com/tremolosecurity/openunison>OpenUnison</a>など、独自のIDプロバイダーを実行することもできます。</p>
<p>IDプロバイダーがKubernetesと連携するためには、以下のことが必要です。</p>
<ol>
<li>すべてではないが、[OpenID Connect Discovery](<a href=https://openid.net/specs/openid-connect-discovery-1_0.html>https://openid.net/specs/openid-connect-discovery-1_0.html</a>）をサポートしていること</li>
<li>廃れていない暗号を用いたTLSで実行されていること</li>
<li>認証局が署名した証明書を持っていること(認証局が商用ではない場合や、自己署名の場合も可)</li>
</ol>
<p>上述の要件#3、認証局署名付き証明書を必要とすることについて、注意事項があります。GoogleやMicrosoftなどのクラウドプロバイダーではなく、独自のIDプロバイダーをデプロイする場合は、たとえ自己署名されていても、<code>CA</code>フラグが<code>TRUE</code>に設定されている証明書によって署名されたIDプロバイダーのWebサーバー証明書を持っていなければなりません。これは、Go言語のTLSクライアント実装が、証明書検証に関する標準に対して非常に厳格であるためです。認証局をお持ちでない場合は、CoreOSチームの<a href=https://github.com/coreos/dex/blob/1ee5920c54f5926d6468d2607c728b71cfe98092/examples/k8s/gencert.sh>このスクリプト</a>を使用して、シンプルな認証局と署名付きの証明書と鍵のペアを作成することができます。
または、<a href=https://raw.githubusercontent.com/TremoloSecurity/openunison-qs-kubernetes/master/src/main/bash/makessl.sh>この類似のスクリプト</a>を使って、より寿命が長く、よりキーサイズの大きいSHA256証明書を生成できます。</p>
<p>特定のシステム用のセットアップ手順は、以下を参照してください。</p>
<ul>
<li><a href=https://docs.cloudfoundry.org/concepts/architecture/uaa.html>UAA</a></li>
<li><a href=https://dexidp.io/docs/kubernetes/>Dex</a></li>
<li><a href=https://www.tremolosecurity.com/orchestra-k8s/>OpenUnison</a></li>
</ul>
<h4 id=kubectlの使用>kubectlの使用</h4>
<h5 id=選択肢1-oidc認証機能>選択肢1 - OIDC認証機能</h5>
<p>最初の選択肢は、kubectlの<code>oidc</code>認証機能を利用することです。これはすべてのリクエストのBearerトークンとして<code>id_token</code>を設定し、有効期限が切れるとトークンを更新します。プロバイダーにログインした後、kubectlを使って<code>id_token</code>、<code>refresh_token</code>、<code>client_id</code>、<code>client_secret</code>を追加してプラグインを設定します。</p>
<p>リフレッシュトークンのレスポンスの一部として<code>id_token</code>を返さないプロバイダーは、このプラグインではサポートされていないので、以下の"選択肢2"を使用してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config set-credentials USER_NAME <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider<span style=color:#666>=</span>oidc <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>idp-issuer-url<span style=color:#666>=(</span> issuer url <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>client-id<span style=color:#666>=(</span> your client id <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>client-secret<span style=color:#666>=(</span> your client secret <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>refresh-token<span style=color:#666>=(</span> your refresh token <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>idp-certificate-authority<span style=color:#666>=(</span> path to your ca certificate <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>id-token<span style=color:#666>=(</span> your id_token <span style=color:#666>)</span>
</code></pre></div><p>例として、IDプロバイダーに認証した後に以下のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config set-credentials mmosley  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider<span style=color:#666>=</span>oidc  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>idp-issuer-url<span style=color:#666>=</span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>client-id<span style=color:#666>=</span>kubernetes  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>client-secret<span style=color:#666>=</span>1db158f6-177d-4d9c-8a8b-d36869918ec5  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>refresh-token<span style=color:#666>=</span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXqHega4GAXlF+ma+vmYpFcHe5eZR+slBFpZKtQA<span style=color:#666>=</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>idp-certificate-authority<span style=color:#666>=</span>/root/ca.pem <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>id-token<span style=color:#666>=</span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw
</code></pre></div><p>これは以下のような構成になります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mmosley<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>auth-provider</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>config</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>client-id</span>:<span style=color:#bbb> </span>kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>client-secret</span>:<span style=color:#bbb> </span>1db158f6-177d-4d9c-8a8b-d36869918ec5<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>id-token</span>:<span style=color:#bbb> </span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>idp-certificate-authority</span>:<span style=color:#bbb> </span>/root/ca.pem<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>idp-issuer-url</span>:<span style=color:#bbb> </span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>refresh-token</span>:<span style=color:#bbb> </span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXq<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>oidc<span style=color:#bbb>
</span></code></pre></div><p><code>id_token</code>の有効期限が切れると、<code>kubectl</code>は<code>refresh_token</code>と<code>client_secret</code>を用いて<code>id_token</code>の更新しようとします。<code>refresh_token</code>と<code>id_token</code>の新しい値は、<code>.kube/config</code>に格納されます。</p>
<h5 id=選択肢2-token-オプションの使用>選択肢2 - <code>--token</code>オプションの使用</h5>
<p><code>kubectl</code>コマンドでは、<code>--token</code>オプションを使ってトークンを渡すことができる。以下のように、このオプションに<code>id_token</code>をコピーして貼り付けるだけです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl --token<span style=color:#666>=</span>eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJodHRwczovL21sYi50cmVtb2xvLmxhbjo4MDQzL2F1dGgvaWRwL29pZGMiLCJhdWQiOiJrdWJlcm5ldGVzIiwiZXhwIjoxNDc0NTk2NjY5LCJqdGkiOiI2RDUzNXoxUEpFNjJOR3QxaWVyYm9RIiwiaWF0IjoxNDc0NTk2MzY5LCJuYmYiOjE0NzQ1OTYyNDksInN1YiI6Im13aW5kdSIsInVzZXJfcm9sZSI6WyJ1c2VycyIsIm5ldy1uYW1lc3BhY2Utdmlld2VyIl0sImVtYWlsIjoibXdpbmR1QG5vbW9yZWplZGkuY29tIn0.f2As579n9VNoaKzoF-dOQGmXkFKf1FMyNV0-va_B63jn-_n9LGSCca_6IVMP8pO-Zb4KvRqGyTP0r3HkHxYy5c81AnIh8ijarruczl-TK_yF5akjSTHFZD-0gRzlevBDiH8Q79NAr-ky0P4iIXS8lY9Vnjch5MF74Zx0c3alKJHJUnnpjIACByfF2SCaYzbWFMUNat-K1PaUk5-ujMBG7yYnr95xD-63n8CO8teGUAAEMx6zRjzfhnhbzX-ajwZLGwGUBT4WqjMs70-6a7_8gZmLZb2az1cZynkFRj2BaCkVT3A2RrjeEwZEtGXlMqKJ1_I2ulrOVsYx01_yD35-rw get nodes
</code></pre></div><h3 id=webhook-token-authentication>Webhookトークン認証</h3>
<p>Webhook認証は、Bearerトークンを検証するためのフックです。</p>
<ul>
<li><code>--authentication-token-webhook-config-file</code>: リモートのWebhookサービスへのアクセス方法を記述した設定ファイルです</li>
<li><code>--authentication-token-webhook-cache-ttl</code>: 認証をキャッシュする時間を決定します。デフォルトは2分です</li>
</ul>
<p>設定ファイルは、<a href=/ja/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>のファイル形式を使用します。
ファイル内で、<code>clusters</code>はリモートサービスを、<code>users</code>はAPIサーバーのWebhookを指します。例えば、以下のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># Kubernetes APIのバージョン</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># APIオブジェクトの種類</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># clustersは、リモートサービスを指します。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-remote-authn-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/path/to/ca.pem        <span style=color:#bbb> </span><span style=color:#080;font-style:italic># リモートサービスを検証するためのCA</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://authn.example.com/authenticate<span style=color:#bbb> </span><span style=color:#080;font-style:italic># クエリするリモートサービスのURL。&#39;https&#39;を使用する必要があります。</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># usersは、APIサーバーのWebhook設定を指します。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/path/to/cert.pem<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Webhookプラグインを使うための証明書</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/path/to/key.pem         <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 証明書に合致する鍵</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kubeconfigファイルにはコンテキストが必要です。APIサーバー用のものを用意してください。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>name-of-remote-authn-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>name-of-api-sever<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span></code></pre></div><p>クライアントが<a href=#putting-a-bearer-token-in-a-request>上記</a>のようにBearerトークンを使用してAPIサーバーとの認証を試みた場合、認証Webhookはトークンを含むJSONでシリアライズされた<code>authentication.k8s.io/v1beta1</code> <code>TokenReview</code>オブジェクトをリモートサービスにPOSTします。Kubernetesはそのようなヘッダーが不足しているリクエストを作成しようとはしません。</p>
<p>Webhook APIオブジェクトは、他のKubernetes APIオブジェクトと同じように、<a href=/ja/docs/concepts/overview/kubernetes-api/>Versioning Compatibility Rule</a>に従うことに注意してください。実装者は、ベータオブジェクトで保証される互換性が緩いことに注意し、正しいデシリアライゼーションが使用されるようにリクエストの"apiVersion"フィールドを確認する必要があります。さらにAPIサーバーは、API拡張グループ<code>authentication.k8s.io/v1beta1</code>を有効にしなければなりません(<code>--runtime config=authentication.k8s.io/v1beta1=true</code>)。</p>
<p>POSTボディは、以下の形式になります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;TokenReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;(Bearerトークン)&#34;</span>
  }
}
</code></pre></div><p>リモートサービスはログインの成功を示すために、リクエストの<code>status</code>フィールドを埋めることが期待されます。レスポンスボディの<code>spec</code>フィールドは無視され、省略することができます。Bearerトークンの検証に成功すると、以下のようにBearerトークンが返されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;TokenReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;authenticated&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
    <span style=color:green;font-weight:700>&#34;user&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;janedoe@example.com&#34;</span>,
      <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;42&#34;</span>,
      <span style=color:green;font-weight:700>&#34;groups&#34;</span>: [
        <span style=color:#b44>&#34;developers&#34;</span>,
        <span style=color:#b44>&#34;qa&#34;</span>
      ],
      <span style=color:green;font-weight:700>&#34;extra&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;extrafield1&#34;</span>: [
          <span style=color:#b44>&#34;extravalue1&#34;</span>,
          <span style=color:#b44>&#34;extravalue2&#34;</span>
        ]
      }
    }
  }
}
</code></pre></div><p>リクエストに失敗した場合は、以下のように返されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;TokenReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;authenticated&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>
  }
}
</code></pre></div><p>HTTPステータスコードは、追加のエラーコンテキストを提供するために使うことができます。</p>
<h3 id=authenticating-proxy>認証プロキシー</h3>
<p>APIサーバーは、<code>X-Remote-User</code>のようにリクエストヘッダの値からユーザーを識別するように設定することができます。
これは、リクエストヘッダの値を設定する認証プロキシーと組み合わせて使用するために設計です。</p>
<ul>
<li><code>--requestheader-username-headers</code>: 必須であり、大文字小文字を区別しません。ユーザーのIDをチェックするためのヘッダー名を順番に指定します。値を含む最初のヘッダーが、ユーザー名として使われます。</li>
<li><code>--requestheader-group-headers</code>: バージョン1.6以降で任意であり、大文字小文字を区別しません。"X-Remote-Group"を推奨します。ユーザーのグループをチェックするためのヘッダー名を順番に指定します。指定されたヘッダーの全ての値が、グループ名として使われます。</li>
<li><code>--requestheader-extra-headers-prefix</code> バージョン1.6以降で任意であり、大文字小文字を区別しません。"X-Remote-Extra-"を推奨します。ユーザーに関する追加情報を判断するために検索するヘッダーのプレフィックスです。通常、設定された認可プラグインによって使用されます。指定されたプレフィックスのいずれかで始まるヘッダーは、プレフィックスが削除されます。ヘッダー名の残りの部分は小文字化され<a href=https://tools.ietf.org/html/rfc3986#section-2.1>パーセントデコーディング</a>されて追加のキーとなり、ヘッダーの値が追加の値となります。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 1.11.3(および1.10.7、1.9.11)よりも前のバージョンでは、追加のキーには<a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>HTTPヘッダーラベルで使用可能な文字</a>のみを含めることができました。
</div>
<p>例えば、このような設定を行います。</p>
<pre><code>--requestheader-username-headers=X-Remote-User
--requestheader-group-headers=X-Remote-Group
--requestheader-extra-headers-prefix=X-Remote-Extra-
</code></pre><p>以下のようなリクエストを考えます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#00a000>GET</span> <span style=color:#00f;font-weight:700>/</span> <span style=color:#a2f;font-weight:700>HTTP</span><span style=color:#666>/</span><span style=color:#666>1.1</span>
X-Remote-User<span style=color:#666>:</span> fido
X-Remote-Group<span style=color:#666>:</span> dogs
X-Remote-Group<span style=color:#666>:</span> dachshunds
X-Remote-Extra-Acme.com%2Fproject<span style=color:#666>:</span> some-project
X-Remote-Extra-Scopes<span style=color:#666>:</span> openid
X-Remote-Extra-Scopes<span style=color:#666>:</span> profile
</code></pre></div><p>このリクエストは、このユーザー情報を取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fido<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>groups</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- dogs<span style=color:#bbb>
</span><span style=color:#bbb></span>- dachshunds<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>acme.com/project</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- some-project<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- openid<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- profile<span style=color:#bbb>
</span></code></pre></div><p>ヘッダーのスプーフィングを防ぐため、認証プロキシーはリクエストヘッダーがチェックされる前に、指定された認証局に対する検証のために有効なクライアント証明書をAPIサーバーへ提示する必要があります。</p>
<ul>
<li><code>--requestheader-client-ca-file</code>: 必須です。PEMエンコードされた証明書バンドルです。有効なクライアント証明書を提示し、リクエストヘッダーでユーザー名がチェックされる前に、指定されたファイル内の認証局に対して検証する必要があります。</li>
<li><code>--requestheader-allowed-names</code>: 任意です。Common Name(CN)の値のリストです。設定されている場合、リクエストヘッダーでユーザー名がチェックされる前に、指定されたリストのCNを持つ有効なクライアント証明書を提示する必要があります。空の場合は、任意のCNが許可されます。</li>
</ul>
<h2 id=anonymous-requests>匿名リクエスト</h2>
<p>この機能を有効にすると、他の設定された認証方法で拒否されなかったリクエストは匿名リクエストとして扱われ、 <code>system:anonymous</code>というユーザー名と<code>system:unauthenticated</code>というグループが与えられます。</p>
<p>例えば、トークン認証が設定されており、匿名アクセスが有効になっているサーバー上で、無効なBearerトークンを提供するリクエストは<code>401 Unauthorized</code>エラーを受け取ります。Bearerトークンを提供しないリクエストは匿名リクエストとして扱われます。</p>
<p>バージョン1.5.1から1.5.xでは、匿名アクセスはデフォルトでは無効になっており、APIサーバーに <code>--anonymous-auth=true</code>オプションを渡すことで有効にすることができます。</p>
<p>バージョン1.6以降では、<code>AlwaysAllow</code>以外の認証モードが使用されている場合、匿名アクセスがデフォルトで有効であり、<code>--anonymous-auth=false</code>オプションをAPIサーバーに渡すことで無効にできます。
1.6以降、ABACおよびRBAC認可機能は、<code>system:anonymous</code>ユーザーまたは<code>system:unauthenticated</code>グループの明示的な認証を必要とするようになったため、<code>*</code>ユーザーまたは<code>*</code>グループへのアクセスを許可する従来のポリシールールには匿名ユーザーは含まれません。</p>
<h2 id=ユーザーの偽装>ユーザーの偽装</h2>
<p>ユーザーは偽装ヘッダーを使って別のユーザーとして振る舞うことができます。これにより、リクエストが認証したユーザー情報を手動で上書きすることが可能です。例えば、管理者はこの機能を使って一時的に別のユーザーに偽装、リクエストが拒否されたかどうかを確認することで認可ポリシーをデバッグすることができます。</p>
<p>偽装リクエストは最初にリクエスト中のユーザーとして認証を行い、次に偽装ユーザー情報に切り替えます。</p>
<ul>
<li>ユーザーは、認証情報と偽装ヘッダーを使ってAPIコールを行います。</li>
<li>APIサーバーはユーザーを認証します。</li>
<li>APIサーバーは、認証されたユーザーが偽装した権限を持っていることを確認します。</li>
<li>リクエストされたユーザー情報は、偽装した値に置き換えられます。</li>
<li>リクエストが評価され、認可は偽装されたユーザー情報に基づいて実行されます。</li>
</ul>
<p>偽装リクエストを実行する際には、以下のHTTPヘッダを使用することができます。</p>
<ul>
<li><code>Impersonate-User</code>: ユーザー名を指定します。このユーザーとして振る舞います。</li>
<li><code>Impersonate-Group</code>: グループ名を指定します。このグループとして振る舞います。複数回指定して複数のグループを設定することができます。任意であり、"Impersonate-User"が必要です。</li>
<li><code>Impersonate-Extra-( extra name )</code>: 追加フィールドをユーザーに関連付けるために使用される動的なヘッダーです。任意であり、"Impersonate-User"が必要です。一貫して保存されるためには、<code>( extra name )</code>は小文字である必要があり、<a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>HTTPヘッダーラベルで使用可能な文字</a>以外の文字は、UTF-8であり、<a href=https://tools.ietf.org/html/rfc3986#section-2.1>パーセントエンコーディング</a>されている必要があります.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 1.11.3(および1.10.7、1.9.11)よりも前のバージョンでは、<code>( extra name )</code>には<a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>HTTPヘッダーラベルで使用可能な文字</a>のみを含めることができました。
</div>
<p>以下が、ヘッダーの例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Impersonate-User: jane.doe@example.com
</span><span>Impersonate-Group: developers
</span><span>Impersonate-Group: admins
</span><span>Impersonate-Extra-dn: cn=jane,ou=engineers,dc=example,dc=com
</span><span>Impersonate-Extra-acme.com%2Fproject: some-project
</span><span>Impersonate-Extra-scopes: view
</span><span>Impersonate-Extra-scopes: development
</span></code></pre></div><p><code>kubectl</code>を使う場合は、<code>--as</code>フラグに<code>Impersonate-User</code>ヘッダーを、<code>--as-group</code>フラグに<code>Impersonate-Group</code>ヘッダーを設定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl drain mynode
</code></pre></div><pre><code class=language-none data-lang=none>Error from server (Forbidden): User &quot;clark&quot; cannot get nodes at the cluster scope. (get nodes mynode)
</code></pre><p><code>--as</code>フラグと<code>--as-group</code>フラグを設定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl drain mynode --as<span style=color:#666>=</span>superman --as-group<span style=color:#666>=</span>system:masters
</code></pre></div><pre><code class=language-none data-lang=none>node/mynode cordoned
node/mynode drained
</code></pre><p>ユーザー、グループ、または追加フィールドを偽装するために、偽装ユーザーは偽装される属性の種類("user"、"group"など)に対して、"偽装した"操作を行う能力を持っている必要があります。RBAC認可プラグインが有効なクラスターの場合、以下のClusterRoleは、ユーザーとグループの偽装ヘッダーを設定するために必要なルールを網羅しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;users&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;groups&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;serviceaccounts&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>追加フィールドは、"userextras"リソースのサブリソースとして評価されます。ユーザーが追加フィールド"scopes"に偽装ヘッダーを使用できるようにするには、ユーザーに以下のようなロールを付与する必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scopes-impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># &#34;Impersonate-Extra-scopes&#34;ヘッダーを設定できます。</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;userextras/scopes&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>偽装ヘッダーの値は、リソースが取り得る<code>resourceNames</code>の集合を制限することで、管理することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>limited-impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># &#34;jane.doe@example.com&#34;というユーザーを偽装できます。</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;users&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;jane.doe@example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># &#34;developers&#34;と&#34;admins&#34;というグループを偽装できます。</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;groups&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;developers&#34;</span>,<span style=color:#b44>&#34;admins&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># &#34;view&#34;と&#34;development&#34;を値に持つ&#34;scopes&#34;という追加フィールドを偽装できます。</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;userextras/scopes&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;view&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;development&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><h2 id=client-goクレデンシャルプラグイン>client-goクレデンシャルプラグイン</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p><code>k8s.io/client-go</code>と、それを使用する<code>kubectl</code>や<code>kubelet</code>のようなツールは、外部コマンドを実行してユーザーの認証情報を受け取ることができます。</p>
<p>この機能は<code>k8s.io/client-go</code>がネイティブにサポートしていない認証プロトコル(LDAP、Kerberos、OAuth2、SAMLなど)とクライアントサイドで統合するためのものです。プラグインはプロトコル固有のロジックを実装し、使用する不透明なクレデンシャルを返します。ほとんどすべてのクレデンシャルプラグインのユースケースでは、クライアントプラグインが生成するクレデンシャルフォーマットを解釈するために、<a href=#webhook-token-authentication>Webhookトークン認証</a>をサポートするサーバーサイドコンポーネントが必要です。</p>
<h3 id=使用例>使用例</h3>
<p>ある組織は、LDAPクレデンシャルをユーザー固有の署名済みトークンと交換する外部サービスを実行すると仮定します。このサービスは、トークンを検証するために<a href=#webhook-token-authentication>Webhookトークン認証</a>リクエストに応答することもできます。ユーザーはワークステーションにクレデンシャルプラグインをインストールする必要があります。</p>
<p>以下のようにして、APIに対して認証を行います。</p>
<ul>
<li>ユーザーは<code>kubectl</code>コマンドを発行します。</li>
<li>クレデンシャルプラグインは、LDAPクレデンシャルの入力をユーザーに要求し、クレデンシャルを外部サービスとトークンと交換します。</li>
<li>クレデンシャルプラグインはトークンを<code>client-go</code>に返します。これはAPIサーバーに対するBearerトークンとして使用されます。</li>
<li>APIサーバーは、<a href=#webhook-token-authentication>Webhookトークン認証</a>を使用して、<code>TokenReview</code>を外部サービスに送信します。</li>
<li>外部サービスはトークンの署名を検証し、ユーザーのユーザー名とグループを返します。</li>
</ul>
<h3 id=設定>設定</h3>
<p>クレデンシャルプラグインの設定は、userフィールドの一部として<a href=/ja/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubectlの設定ファイル</a>で行います。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 実行するコマンドです。必須です。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ExecCredentialsリソースをデコードする際に使用するAPIのバージョン。必須です。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># プラグインが返すAPIのバージョンは、ここに記載されているバージョンと一致しなければなりません</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 複数のバージョンをサポートするツール(client.authentication.k8s.io/v1alpha1など)と統合するには、</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 環境変数を設定するか、execプラグインが期待するバージョンを示す引数をツールに渡します。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># プラグインを実行する際に設定する環境変数です。任意です。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;FOO&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;bar&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># プラグインを実行する際に渡す引数です。任意です。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;arg1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;arg2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/ca.pem&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></code></pre></div><p>相対的なコマンドパスは、設定ファイルのディレクトリーからの相対的なものとして解釈されます。KUBECONFIGが<code>/home/jane/kubeconfig</code>に設定されていて、execコマンドが<code>./bin/example-client-go-exec-plugin</code>の場合、バイナリー<code>/home/jane/bin/example-client-go-exec-plugin</code>が実行されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># kubeconfigのディレクトリーへの相対パス</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;./bin/example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=入出力フォーマット>入出力フォーマット</h3>
<p>実行されたコマンドは<code>ExecCredential</code>オブジェクトを<code>stdout</code>に出力します。<code>k8s.io/client-go</code>は<code>status</code>で返された認証情報を用いて、Kubernetes APIに対して認証を行ういます。</p>
<p>対話的なセッションから実行する場合、<code>stdin</code>はプラグインに直接公開されます。プラグインは<a href=https://godoc.org/golang.org/x/crypto/ssh/terminal#IsTerminal>TTYチェック</a>を使って、対話的にユーザーにプロンプトを出すことが適切かどうかを判断する必要があります。</p>
<p>Bearerトークンのクレデンシャルを使用するために、プラグインは<code>ExecCredential</code>のステータスにトークンを返します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>
  }
}
</code></pre></div><p>あるいは、PEMエンコードされたクライアント証明書と鍵を返して、TLSクライアント認証を使用することもできます。
プラグインが後続の呼び出しで異なる証明書と鍵を返すと、<code>k8s.io/client-go</code>はサーバーとの既存の接続を閉じて、新しいTLSハンドシェイクを強制します</p>
<p>指定された場合、<code>clientKeyData</code>と<code>clientCertificateData</code>両方が存在しなければなりません。</p>
<p><code>clientCertificateData</code>には、サーバーに送信するための中間証明書を含めることができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;clientCertificateData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----&#34;</span>,
    <span style=color:green;font-weight:700>&#34;clientKeyData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----&#34;</span>
  }
}
</code></pre></div><p>オプションで、レスポンスにはRFC3339のタイムスタンプとしてフォーマットされたクレデンシャルの有効期限を含めることができます。有効期限の有無には、以下のような影響あります。</p>
<ul>
<li>有効期限が含まれている場合、BearerトークンとTLSクレデンシャルは有効期限に達するまで、またはサーバーがHTTPステータスコード401で応答したとき、またはプロセスが終了するまでキャッシュされます。</li>
<li>有効期限が省略された場合、BearerトークンとTLSクレデンシャルはサーバーがHTTPステータスコード401で応答したとき、またはプロセスが終了するまでキャッシュされます。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>,
    <span style=color:green;font-weight:700>&#34;expirationTimestamp&#34;</span>: <span style=color:#b44>&#34;2018-03-05T17:30:20-08:00&#34;</span>
  }
}
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5bbbc5163b35431b3bff029ab9ec57d3>6.3 - セットアップツールのリファレンス</h1>
</div>
<div class=td-content>
<h1 id=pg-f351ced098abbb076bc8c4be1053672b>6.3.1 - Kubeadm</h1>
<p><img src=/images/kubeadm-stacked-color.png align=right width=150px>kubeadmは、<code>kubeadm init</code>や<code>kubeadm join</code>などのコマンドを提供するツールで、Kubernetesクラスターを構築する上でのベストプラクティスを反映した「近道」を提供するものとして開発されました。</p>
<p>kubeadmは実用最小限のクラスターをセットアップするための処理を実行します。設計上、kubeadmはブートストラップのみを行い、マシンのプロビジョニングは行いません。同様に、Kubernetesダッシュボード、モニタリングソリューション、クラウド向けのアドオンなど、あれば便利でもなくても支障のない各種アドオンのインストールも範囲外です。</p>
<p>その代わりに、高度な特定用途向けのツールはkubeadmをベースに構築されることが期待されています。理想的には、すべてのデプロイのベースとしてkubeadmを使用することで、適合テストに通るクラスターを簡単に作れるようになります。</p>
<h2 id=インストール方法>インストール方法</h2>
<p>kubeadmをインストールするには、<a href=/ja/docs/setup/production-environment/tools/kubeadm/install-kubeadm>インストールガイド</a>を参照してください。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init>kubeadm init</a>を使用して、Kubernetesのコントロールプレーンノードをブートストラップする</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join>kubeadm join</a>を使用して、Kubernetesのワーカーノードをブートストラップし、クラスターに参加させる</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-upgrade>kubeadm upgrade</a>で、Kubernetesクラスターを新しいバージョンにアップグレードする</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-config>kubeadm config</a>を使用して、kubeadm v1.7.x以前で初期化されたクラスターを、<code>kubeadm upgrade</code>を利用できるように設定する</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-token>kubeadm token</a>で、<code>kubeadm join</code>のためのトークンを管理する</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset>kubeadm reset</a>を使用して、<code>kubeadm init</code>または<code>kubeadm join</code>でホストに行われた変更を元に戻す</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-version>kubeadm version</a>で、kubeadmのバージョンを表示する</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-alpha>kubeadm alpha</a>で、コミュニティからのフィードバックを集めるために有効にされた各種機能を試用する</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-03460a7254c6c73eb2a1bb3dd7d25910>6.4 - kubectl CLI</h1>
</div>
<div class=td-content>
<h1 id=pg-f14fe15ecc2d41b5e901ef5e872ca657>6.4.1 - kubectlの概要</h1>
<p><code>kubectl</code>コマンドラインツールを使うと、Kubernetesクラスターを制御できます。環境設定のために、<code>kubectl</code>は、<code>$HOME/.kube</code>ディレクトリにある<code>config</code>という名前のファイルを探します。他の<a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>ファイルは、<code>KUBECONFIG</code>環境変数を設定するか、<a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/><code>--kubeconfig</code></a>フラグを設定することで指定できます。
この概要では、<code>kubectl</code>の構文を扱い、コマンド操作を説明し、一般的な例を示します。サポートされているすべてのフラグやサブコマンドを含め、各コマンドの詳細については、<a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a>リファレンスドキュメントを参照してください。インストール方法については、<a href=/ja/docs/tasks/tools/install-kubectl/>kubectlのインストールおよびセットアップ</a>をご覧ください。</p>
<h2 id=構文>構文</h2>
<p>ターミナルウィンドウから<code>kubectl</code>コマンドを実行するには、以下の構文を使用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> <span style=color:#666>[</span>flags<span style=color:#666>]</span>
</code></pre></div><p>ここで、<code>command</code>、<code>TYPE</code>、<code>NAME</code>、<code>flags</code>は、以下を表します。</p>
<ul>
<li>
<p><code>command</code>: 1つ以上のリソースに対して実行したい操作を指定します。例えば、<code>create</code>、<code>get</code>、<code>describe</code>、<code>delete</code>です。</p>
</li>
<li>
<p><code>TYPE</code>: <a href=#resource-types>リソースタイプ</a>を指定します。リソースタイプは大文字と小文字を区別せず、単数形や複数形、省略形を指定できます。例えば、以下のコマンドは同じ出力を生成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod pod1
kubectl get pods pod1
kubectl get po pod1
</code></pre></div></li>
<li>
<p><code>NAME</code>: リソースの名前を指定します。名前は大文字と小文字を区別します。<code>kubectl get pods</code>のように名前が省略された場合は、すべてのリソースの詳細が表示されます。</p>
<p>複数のリソースに対して操作を行う場合は、各リソースをタイプと名前で指定するか、1つまたは複数のファイルを指定することができます。</p>
<ul>
<li>
<p>リソースをタイプと名前で指定する場合</p>
<ul>
<li>
<p>タイプがすべて同じとき、リソースをグループ化するには<code>TYPE1 name1 name2 name&lt;#></code>とします。<br>
例: <code>kubectl get pod example-pod1 example-pod2</code></p>
</li>
<li>
<p>複数のリソースタイプを個別に指定するには、<code>TYPE1/name1 TYPE1/name2 TYPE2/name3 TYPE&lt;#>/name&lt;#></code>とします。<br>
例: <code>kubectl get pod/example-pod1 replicationcontroller/example-rc1</code></p>
</li>
</ul>
</li>
<li>
<p>リソースを1つ以上のファイルで指定する場合は、<code>-f file1 -f file2 -f file&lt;#></code>とします。</p>
<ul>
<li>特に設定ファイルについては、YAMLの方がより使いやすいため、<a href=/ja/docs/concepts/configuration/overview/#%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E8%A8%AD%E5%AE%9A%E3%81%AEtips>JSONではなくYAMLを使用してください</a>。<br>
例: <code>kubectl get pod -f ./pod.yaml</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>flags</code>: オプションのフラグを指定します。例えば、<code>-s</code>または<code>--server</code>フラグを使って、Kubernetes APIサーバーのアドレスやポートを指定できます。<br></p>
</li>
</ul>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> コマンドラインから指定したフラグは、デフォルト値および対応する任意の環境変数を上書きします。
</div>
<p>ヘルプが必要な場合は、ターミナルウィンドウから<code>kubectl help</code>を実行してください。</p>
<h2 id=操作>操作</h2>
<p>以下の表に、<code>kubectl</code>のすべての操作の簡単な説明と一般的な構文を示します。</p>
<table>
<thead>
<tr>
<th>操作                </th>
<th>構文</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alpha</code></td>
<td><code>kubectl alpha SUBCOMMAND [flags]</code></td>
<td>アルファ機能に該当する利用可能なコマンドを一覧表示します。これらの機能は、デフォルトではKubernetesクラスターで有効になっていません。</td>
</tr>
<tr>
<td><code>annotate</code></td>
<td><code>kubectl annotate (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td>
<td>1つ以上のリソースのアノテーションを、追加または更新します。</td>
</tr>
<tr>
<td><code>api-resources</code></td>
<td><code>kubectl api-resources [flags]</code></td>
<td>利用可能なAPIリソースを一覧表示します。</td>
</tr>
<tr>
<td><code>api-versions</code></td>
<td><code>kubectl api-versions [flags]</code></td>
<td>利用可能なAPIバージョンを一覧表示します。</td>
</tr>
<tr>
<td><code>apply</code></td>
<td><code>kubectl apply -f FILENAME [flags]</code></td>
<td>ファイルまたは標準出力から、リソースの設定変更を適用します。</td>
</tr>
<tr>
<td><code>attach</code></td>
<td><code>kubectl attach POD -c CONTAINER [-i] [-t] [flags]</code></td>
<td>実行中のコンテナにアタッチして、出力ストリームを表示するか、コンテナ(標準入力)と対話します。</td>
</tr>
<tr>
<td><code>auth</code></td>
<td><code>kubectl auth [flags] [options]</code></td>
<td>認可を検査します。</td>
</tr>
<tr>
<td><code>autoscale</code></td>
<td><code>kubectl autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]</code></td>
<td>ReplicationControllerで管理されているPodのセットを、自動的にスケールします。</td>
</tr>
<tr>
<td><code>certificate</code></td>
<td><code>kubectl certificate SUBCOMMAND [options]</code></td>
<td>証明書のリソースを変更します。</td>
</tr>
<tr>
<td><code>cluster-info</code></td>
<td><code>kubectl cluster-info [flags]</code></td>
<td>クラスター内のマスターとサービスに関するエンドポイント情報を表示します。</td>
</tr>
<tr>
<td><code>completion</code></td>
<td><code>kubectl completion SHELL [options]</code></td>
<td>指定されたシェル(bashまたはzsh)のシェル補完コードを出力します。</td>
</tr>
<tr>
<td><code>config</code></td>
<td><code>kubectl config SUBCOMMAND [flags]</code></td>
<td>kubeconfigファイルを変更します。詳細は、個々のサブコマンドを参照してください。</td>
</tr>
<tr>
<td><code>convert</code></td>
<td><code>kubectl convert -f FILENAME [options]</code></td>
<td>異なるAPIバージョン間で設定ファイルを変換します。YAMLとJSONに対応しています。</td>
</tr>
<tr>
<td><code>cordon</code></td>
<td><code>kubectl cordon NODE [options]</code></td>
<td>Nodeをスケジュール不可に設定します。</td>
</tr>
<tr>
<td><code>cp</code></td>
<td><code>kubectl cp &lt;file-spec-src> &lt;file-spec-dest> [options]</code></td>
<td>コンテナとの間でファイルやディレクトリをコピーします。</td>
</tr>
<tr>
<td><code>create</code></td>
<td><code>kubectl create -f FILENAME [flags]</code></td>
<td>ファイルまたは標準出力から、1つ以上のリソースを作成します。</td>
</tr>
<tr>
<td><code>delete</code></td>
<td><code>kubectl delete (-f FILENAME | TYPE [NAME | /NAME | -l label | --all]) [flags]</code></td>
<td>ファイル、標準出力、またはラベルセレクター、リソースセレクター、リソースを指定して、リソースを削除します。</td>
</tr>
<tr>
<td><code>describe</code></td>
<td><code>kubectl describe (-f FILENAME | TYPE [NAME_PREFIX | /NAME | -l label]) [flags]</code></td>
<td>1つ以上のリソースの詳細な状態を表示します。</td>
</tr>
<tr>
<td><code>diff</code></td>
<td><code>kubectl diff -f FILENAME [flags]</code></td>
<td>ファイルまたは標準出力と、現在の設定との差分を表示します。</td>
</tr>
<tr>
<td><code>drain</code></td>
<td><code>kubectl drain NODE [options]</code></td>
<td>メンテナンスの準備のためにNodeをdrainします。</td>
</tr>
<tr>
<td><code>edit</code></td>
<td><code>kubectl edit (-f FILENAME | TYPE NAME | TYPE/NAME) [flags]</code></td>
<td>デファルトのエディタを使い、サーバー上の1つ以上のリソースリソースの定義を編集し、更新します。</td>
</tr>
<tr>
<td><code>exec</code></td>
<td><code>kubectl exec POD [-c CONTAINER] [-i] [-t] [flags] [-- COMMAND [args...]]</code></td>
<td>Pod内のコンテナに対して、コマンドを実行します。</td>
</tr>
<tr>
<td><code>explain</code></td>
<td><code>kubectl explain [--recursive=false] [flags]</code></td>
<td>様々なリソースのドキュメントを取得します。例えば、Pod、Node、Serviceなどです。</td>
</tr>
<tr>
<td><code>expose</code></td>
<td><code>kubectl expose (-f FILENAME | TYPE NAME | TYPE/NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type] [flags]</code></td>
<td>ReplicationController、Service、Podを、新しいKubernetesサービスとして公開します。</td>
</tr>
<tr>
<td><code>get</code></td>
<td><code>kubectl get (-f FILENAME | TYPE [NAME | /NAME | -l label]) [--watch] [--sort-by=FIELD] [[-o | --output]=OUTPUT_FORMAT] [flags]</code></td>
<td>1つ以上のリソースを表示します。</td>
</tr>
<tr>
<td><code>kustomize</code></td>
<td><code>kubectl kustomize &lt;dir> [flags] [options]</code></td>
<td>kustomization.yamlファイル内の指示から生成されたAPIリソースのセットを一覧表示します。引数はファイルを含むディレクトリのPath，またはリポジトリルートに対して同じ場所を示すパスサフィックス付きのgitリポジトリのURLを指定しなければなりません。</td>
</tr>
<tr>
<td><code>label</code></td>
<td><code>kubectl label (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td>
<td>1つ以上のリソースのラベルを、追加または更新します。</td>
</tr>
<tr>
<td><code>logs</code></td>
<td><code>kubectl logs POD [-c CONTAINER] [--follow] [flags]</code></td>
<td>Pod内のコンテナのログを表示します。</td>
</tr>
<tr>
<td><code>options</code></td>
<td><code>kubectl options</code></td>
<td>すべてのコマンドに適用されるグローバルコマンドラインオプションを一覧表示します。</td>
</tr>
<tr>
<td><code>patch</code></td>
<td><code>kubectl patch (-f FILENAME | TYPE NAME | TYPE/NAME) --patch PATCH [flags]</code></td>
<td>Strategic Merge Patchの処理を使用して、リソースの1つ以上のフィールドを更新します。</td>
</tr>
<tr>
<td><code>plugin</code></td>
<td><code>kubectl plugin [flags] [options]</code></td>
<td>プラグインと対話するためのユーティリティを提供します。</td>
</tr>
<tr>
<td><code>port-forward</code></td>
<td><code>kubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N] [flags]</code></td>
<td>1つ以上のローカルポートを、Podに転送します。</td>
</tr>
<tr>
<td><code>proxy</code></td>
<td><code>kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]</code></td>
<td>Kubernetes APIサーバーへのプロキシーを実行します。</td>
</tr>
<tr>
<td><code>replace</code></td>
<td><code>kubectl replace -f FILENAME</code></td>
<td>ファイルや標準出力から、リソースを置き換えます。</td>
</tr>
<tr>
<td><code>rollout</code></td>
<td><code>kubectl rollout SUBCOMMAND [options]</code></td>
<td>リソースのロールアウトを管理します。有効なリソースには、Deployment、DaemonSetとStatefulSetが含まれます。</td>
</tr>
<tr>
<td><code>run</code></td>
<td><code>kubectl run NAME --image=image [--env="key=value"] [--port=port] [--dry-run=server|client|none] [--overrides=inline-json] [flags]</code></td>
<td>指定したイメージを、クラスタ上で実行します。</td>
</tr>
<tr>
<td><code>scale</code></td>
<td><code>kubectl scale (-f FILENAME | TYPE NAME | TYPE/NAME) --replicas=COUNT [--resource-version=version] [--current-replicas=count] [flags]</code></td>
<td>指定したReplicationControllerのサイズを更新します。</td>
</tr>
<tr>
<td><code>set</code></td>
<td><code>kubectl set SUBCOMMAND [options]</code></td>
<td>アプリケーションリソースを設定します。</td>
</tr>
<tr>
<td><code>taint</code></td>
<td><code>kubectl taint NODE NAME KEY_1=VAL_1:TAINT_EFFECT_1 ... KEY_N=VAL_N:TAINT_EFFECT_N [options]</code></td>
<td>1つ以上のNodeのtaintを更新します。</td>
</tr>
<tr>
<td><code>top</code></td>
<td><code>kubectl top [flags] [options]</code></td>
<td>リソース(CPU/メモリー/ストレージ)の使用量を表示します。</td>
</tr>
<tr>
<td><code>uncordon</code></td>
<td><code>kubectl uncordon NODE [options]</code></td>
<td>Nodeをスケジュール可に設定します。</td>
</tr>
<tr>
<td><code>version</code></td>
<td><code>kubectl version [--client] [flags]</code></td>
<td>クライアントとサーバーで実行中のKubernetesのバージョンを表示します。</td>
</tr>
<tr>
<td><code>wait</code></td>
<td><code>kubectl wait ([-f FILENAME] | resource.group/resource.name | resource.group [(-l label | --all)]) [--for=delete|--for condition=available] [options]</code></td>
<td>実験中の機能: 1つ以上のリソースが特定の状態になるまで待ちます。</td>
</tr>
</tbody>
</table>
<p>コマンド操作について詳しく知りたい場合は、<a href=/docs/reference/kubectl/kubectl/>kubectl</a>リファレンスドキュメントを参照してください。</p>
<h2 id=resource-types>リソースタイプ</h2>
<p>以下の表に、サポートされているすべてのリソースと、省略されたエイリアスの一覧を示します。</p>
<p>(この出力は<code>kubectl api-resources</code>から取得でき、Kubernetes 1.13.3時点で正確でした。)</p>
<table>
<thead>
<tr>
<th>リソース名</th>
<th>短縮名</th>
<th>APIグループ</th>
<th>名前空間に属するか</th>
<th>リソースの種類</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bindings</code></td>
<td></td>
<td></td>
<td>true</td>
<td>Binding</td>
</tr>
<tr>
<td><code>componentstatuses</code></td>
<td><code>cs</code></td>
<td></td>
<td>false</td>
<td>ComponentStatus</td>
</tr>
<tr>
<td><code>configmaps</code></td>
<td><code>cm</code></td>
<td></td>
<td>true</td>
<td>ConfigMap</td>
</tr>
<tr>
<td><code>endpoints</code></td>
<td><code>ep</code></td>
<td></td>
<td>true</td>
<td>Endpoints</td>
</tr>
<tr>
<td><code>limitranges</code></td>
<td><code>limits</code></td>
<td></td>
<td>true</td>
<td>LimitRange</td>
</tr>
<tr>
<td><code>namespaces</code></td>
<td><code>ns</code></td>
<td></td>
<td>false</td>
<td>Namespace</td>
</tr>
<tr>
<td><code>nodes</code></td>
<td><code>no</code></td>
<td></td>
<td>false</td>
<td>Node</td>
</tr>
<tr>
<td><code>persistentvolumeclaims</code></td>
<td><code>pvc</code></td>
<td></td>
<td>true</td>
<td>PersistentVolumeClaim</td>
</tr>
<tr>
<td><code>persistentvolumes</code></td>
<td><code>pv</code></td>
<td></td>
<td>false</td>
<td>PersistentVolume</td>
</tr>
<tr>
<td><code>pods</code></td>
<td><code>po</code></td>
<td></td>
<td>true</td>
<td>Pod</td>
</tr>
<tr>
<td><code>podtemplates</code></td>
<td></td>
<td></td>
<td>true</td>
<td>PodTemplate</td>
</tr>
<tr>
<td><code>replicationcontrollers</code></td>
<td><code>rc</code></td>
<td></td>
<td>true</td>
<td>ReplicationController</td>
</tr>
<tr>
<td><code>resourcequotas</code></td>
<td><code>quota</code></td>
<td></td>
<td>true</td>
<td>ResourceQuota</td>
</tr>
<tr>
<td><code>secrets</code></td>
<td></td>
<td></td>
<td>true</td>
<td>Secret</td>
</tr>
<tr>
<td><code>serviceaccounts</code></td>
<td><code>sa</code></td>
<td></td>
<td>true</td>
<td>ServiceAccount</td>
</tr>
<tr>
<td><code>services</code></td>
<td><code>svc</code></td>
<td></td>
<td>true</td>
<td>Service</td>
</tr>
<tr>
<td><code>mutatingwebhookconfigurations</code></td>
<td></td>
<td>admissionregistration.k8s.io</td>
<td>false</td>
<td>MutatingWebhookConfiguration</td>
</tr>
<tr>
<td><code>validatingwebhookconfigurations</code></td>
<td></td>
<td>admissionregistration.k8s.io</td>
<td>false</td>
<td>ValidatingWebhookConfiguration</td>
</tr>
<tr>
<td><code>customresourcedefinitions</code></td>
<td><code>crd</code>, <code>crds</code></td>
<td>apiextensions.k8s.io</td>
<td>false</td>
<td>CustomResourceDefinition</td>
</tr>
<tr>
<td><code>apiservices</code></td>
<td></td>
<td>apiregistration.k8s.io</td>
<td>false</td>
<td>APIService</td>
</tr>
<tr>
<td><code>controllerrevisions</code></td>
<td></td>
<td>apps</td>
<td>true</td>
<td>ControllerRevision</td>
</tr>
<tr>
<td><code>daemonsets</code></td>
<td><code>ds</code></td>
<td>apps</td>
<td>true</td>
<td>DaemonSet</td>
</tr>
<tr>
<td><code>deployments</code></td>
<td><code>deploy</code></td>
<td>apps</td>
<td>true</td>
<td>Deployment</td>
</tr>
<tr>
<td><code>replicasets</code></td>
<td><code>rs</code></td>
<td>apps</td>
<td>true</td>
<td>ReplicaSet</td>
</tr>
<tr>
<td><code>statefulsets</code></td>
<td><code>sts</code></td>
<td>apps</td>
<td>true</td>
<td>StatefulSet</td>
</tr>
<tr>
<td><code>tokenreviews</code></td>
<td></td>
<td>authentication.k8s.io</td>
<td>false</td>
<td>TokenReview</td>
</tr>
<tr>
<td><code>localsubjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>true</td>
<td>LocalSubjectAccessReview</td>
</tr>
<tr>
<td><code>selfsubjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SelfSubjectAccessReview</td>
</tr>
<tr>
<td><code>selfsubjectrulesreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SelfSubjectRulesReview</td>
</tr>
<tr>
<td><code>subjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SubjectAccessReview</td>
</tr>
<tr>
<td><code>horizontalpodautoscalers</code></td>
<td><code>hpa</code></td>
<td>autoscaling</td>
<td>true</td>
<td>HorizontalPodAutoscaler</td>
</tr>
<tr>
<td><code>cronjobs</code></td>
<td><code>cj</code></td>
<td>batch</td>
<td>true</td>
<td>CronJob</td>
</tr>
<tr>
<td><code>jobs</code></td>
<td></td>
<td>batch</td>
<td>true</td>
<td>Job</td>
</tr>
<tr>
<td><code>certificatesigningrequests</code></td>
<td><code>csr</code></td>
<td>certificates.k8s.io</td>
<td>false</td>
<td>CertificateSigningRequest</td>
</tr>
<tr>
<td><code>leases</code></td>
<td></td>
<td>coordination.k8s.io</td>
<td>true</td>
<td>Lease</td>
</tr>
<tr>
<td><code>events</code></td>
<td><code>ev</code></td>
<td>events.k8s.io</td>
<td>true</td>
<td>Event</td>
</tr>
<tr>
<td><code>ingresses</code></td>
<td><code>ing</code></td>
<td>extensions</td>
<td>true</td>
<td>Ingress</td>
</tr>
<tr>
<td><code>networkpolicies</code></td>
<td><code>netpol</code></td>
<td>networking.k8s.io</td>
<td>true</td>
<td>NetworkPolicy</td>
</tr>
<tr>
<td><code>poddisruptionbudgets</code></td>
<td><code>pdb</code></td>
<td>policy</td>
<td>true</td>
<td>PodDisruptionBudget</td>
</tr>
<tr>
<td><code>podsecuritypolicies</code></td>
<td><code>psp</code></td>
<td>policy</td>
<td>false</td>
<td>PodSecurityPolicy</td>
</tr>
<tr>
<td><code>clusterrolebindings</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>false</td>
<td>ClusterRoleBinding</td>
</tr>
<tr>
<td><code>clusterroles</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>false</td>
<td>ClusterRole</td>
</tr>
<tr>
<td><code>rolebindings</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>true</td>
<td>RoleBinding</td>
</tr>
<tr>
<td><code>roles</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>true</td>
<td>Role</td>
</tr>
<tr>
<td><code>priorityclasses</code></td>
<td><code>pc</code></td>
<td>scheduling.k8s.io</td>
<td>false</td>
<td>PriorityClass</td>
</tr>
<tr>
<td><code>csidrivers</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>CSIDriver</td>
</tr>
<tr>
<td><code>csinodes</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>CSINode</td>
</tr>
<tr>
<td><code>storageclasses</code></td>
<td><code>sc</code></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>StorageClass</td>
</tr>
<tr>
<td><code>volumeattachments</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>VolumeAttachment</td>
</tr>
</tbody>
</table>
<h2 id=出力オプション>出力オプション</h2>
<p>ある特定のコマンドの出力に対してフォーマットやソートを行う方法については、以下の節を参照してください。どのコマンドが様々な出力オプションをサポートしているかについては、<a href=/docs/reference/kubectl/kubectl/>kubectl</a>リファレンスドキュメントをご覧ください。</p>
<h3 id=出力のフォーマット>出力のフォーマット</h3>
<p>すべての<code>kubectl</code>コマンドのデフォルトの出力フォーマットは、人間が読みやすいプレーンテキスト形式です。特定のフォーマットで、詳細をターミナルウィンドウに出力するには、サポートされている<code>kubectl</code>コマンドに<code>-o</code>または<code>--output</code>フラグのいずれかを追加します。</p>
<h4 id=構文-1>構文</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> -o &lt;output_format&gt;
</code></pre></div><p><code>kubectl</code>の操作に応じて、以下の出力フォーマットがサポートされています。</p>
<table>
<thead>
<tr>
<th>出力フォーマット</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o custom-columns=&lt;spec></code></td>
<td><a href=#custom-columns>カスタムカラム</a>のコンマ区切りのリストを使用して、テーブルを表示します。</td>
</tr>
<tr>
<td><code>-o custom-columns-file=&lt;filename></code></td>
<td><code>&lt;filename></code>ファイル内の<a href=#custom-columns>カスタムカラム</a>のテンプレートを使用して、テーブルを表示します。</td>
</tr>
<tr>
<td><code>-o json</code></td>
<td>JSON形式のAPIオブジェクトを出力します。</td>
</tr>
<tr>
<td><code>-o jsonpath=&lt;template></code></td>
<td><a href=/ja/docs/reference/kubectl/jsonpath/>jsonpath</a>式で定義されたフィールドを表示します。</td>
</tr>
<tr>
<td><code>-o jsonpath-file=&lt;filename></code></td>
<td><code>&lt;filename></code>ファイル内の<a href=/ja/docs/reference/kubectl/jsonpath/>jsonpath</a>式で定義されたフィールドを表示します。</td>
</tr>
<tr>
<td><code>-o name</code></td>
<td>リソース名のみを表示します。</td>
</tr>
<tr>
<td><code>-o wide</code></td>
<td>追加情報を含めて、プレーンテキスト形式で出力します。Podの場合は、Node名が含まれます。</td>
</tr>
<tr>
<td><code>-o yaml</code></td>
<td>YAML形式のAPIオブジェクトを出力します。</td>
</tr>
</tbody>
</table>
<h5 id=例>例</h5>
<p>この例において、以下のコマンドは1つのPodの詳細を、YAML形式のオブジェクトとして出力します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod web-pod-13je7 -o yaml
</code></pre></div><p>各コマンドでサポートされている出力フォーマットの詳細については、<a href=/docs/reference/kubectl/kubectl/>kubectl</a>リファレンスドキュメントを参照してください。</p>
<h4 id=custom-columns>カスタムカラム</h4>
<p>カスタムカラムを定義して、必要な詳細のみをテーブルに出力するには、<code>custom-columns</code>オプションを使います。カスタムカラムをインラインで定義するか、<code>-o custom-columns=&lt;spec></code>または<code>-o custom-columns-file=&lt;filename></code>のようにテンプレートファイルを使用するかを選択できます。</p>
<h5 id=例-1>例</h5>
<p>インラインで定義する例は、以下の通りです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; -o custom-columns<span style=color:#666>=</span>NAME:.metadata.name,RSRC:.metadata.resourceVersion
</code></pre></div><p>テンプレートファイルを使用して定義する例は、以下の通りです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; -o custom-columns-file<span style=color:#666>=</span>template.txt
</code></pre></div><p>ここで、<code>template.txt</code>には以下の内容が含まれます。</p>
<pre><code>NAME          RSRC
metadata.name metadata.resourceVersion
</code></pre><p>どちらのコマンドを実行した場合でも、以下の結果を得ます。</p>
<pre><code>NAME           RSRC
submit-queue   610995
</code></pre><h4 id=サーバーサイドカラム>サーバーサイドカラム</h4>
<p><code>kubectl</code>は、サーバーからオブジェクトに関する特定のカラム情報を受け取ることをサポートしています。
つまり、与えられた任意のリソースについて、サーバーはそのリソースに関連する列や行を返し、クライアントが表示できるようにします。
これにより、サーバーが表示の詳細をカプセル化することで、同一クラスターに対して使用されているクライアント間で、一貫した人間が読みやすい出力が可能です。</p>
<p>この機能は、デフォルトで有効になっています。無効にするには、<code>kubectl get</code>コマンドに<code>--server-print=false</code>フラグを追加します。</p>
<h5 id=例-2>例</h5>
<p>Podの状態に関する情報を表示するには、以下のようなコマンドを使用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; --server-print<span style=color:#666>=</span><span style=color:#a2f>false</span>
</code></pre></div><p>以下のように出力されます。</p>
<pre><code>NAME       AGE
pod-name   1m
</code></pre><h3 id=オブジェクトリストのソート>オブジェクトリストのソート</h3>
<p>ターミナルウィンドウで、オブジェクトをソートされたリストに出力するには、サポートされている<code>kubectl</code>コマンドに<code>--sort-by</code>フラグを追加します。<code>--sort-by</code>フラグで任意の数値フィールドや文字列フィールドを指定することで、オブジェクトをソートします。フィールドの指定には、<a href=/ja/docs/reference/kubectl/jsonpath/>jsonpath</a>式を使用します。</p>
<h4 id=構文-2>構文</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> --sort-by<span style=color:#666>=</span>&lt;jsonpath_exp&gt;
</code></pre></div><h5 id=例-3>例</h5>
<p>名前でソートしたPodのリストを表示するには、以下のように実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --sort-by<span style=color:#666>=</span>.metadata.name
</code></pre></div><h2 id=例-一般的な操作>例: 一般的な操作</h2>
<p>よく使われる<code>kubectl</code>の操作に慣れるために、以下の例を使用してください。</p>
<p><code>kubectl apply</code> - ファイルや標準出力から、リソースの適用や更新を行います。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># example-service.yaml内の定義を使用して、Serviceを作成します。</span>
kubectl apply -f example-service.yaml

<span style=color:#080;font-style:italic># example-controller.yaml内の定義を使用して、ReplicationControllerを作成します。</span>
kubectl apply -f example-controller.yaml

<span style=color:#080;font-style:italic># &lt;directory&gt;ディレクトリ内の、任意の.yaml、.yml、.jsonファイルで定義されているオブジェクトを作成します。</span>
kubectl apply -f &lt;directory&gt;
</code></pre></div><p><code>kubectl get</code> - 1つ以上のリソースの一覧を表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># すべてのPodの一覧をプレーンテキスト形式で表示します。</span>
kubectl get pods

<span style=color:#080;font-style:italic># すべてのPodの一覧を、ノード名などの追加情報を含めて、プレーンテキスト形式で表示します。</span>
kubectl get pods -o wide

<span style=color:#080;font-style:italic># 指定した名前のReplicationControllerの一覧をプレーンテキスト形式で表示します。&#39;replicationcontroller&#39;リソースタイプを短縮して、エイリアス&#39;rc&#39;で置き換えることもできます。</span>
kubectl get replicationcontroller &lt;rc-name&gt;

<span style=color:#080;font-style:italic># すべてのReplicationControllerとServiceの一覧をまとめてプレーンテキスト形式で表示します。</span>
kubectl get rc,services

<span style=color:#080;font-style:italic># すべてのDaemonSetの一覧をプレーンテキスト形式で表示します。</span>
kubectl get ds

<span style=color:#080;font-style:italic># server01ノードで実行中のPodの一覧をプレーンテキスト形式で表示します。</span>
kubectl get pods --field-selector<span style=color:#666>=</span>spec.nodeName<span style=color:#666>=</span>server01
</code></pre></div><p><code>kubectl describe</code> - 1つ以上のリソースの詳細な状態を、デフォルトでは初期化されないものも含めて表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Node &lt;node-name&gt;の詳細を表示します。</span>
kubectl describe nodes &lt;node-name&gt;

<span style=color:#080;font-style:italic># Pod &lt;pod-name&gt;の詳細を表示します。</span>
kubectl describe pods/&lt;pod-name&gt;

<span style=color:#080;font-style:italic># ReplicationController &lt;rc-name&gt;が管理しているすべてのPodの詳細を表示します。</span>
<span style=color:#080;font-style:italic># ReplicationControllerによって作成された任意のPodには、ReplicationControllerの名前がプレフィックスとして付与されます。</span>
kubectl describe pods &lt;rc-name&gt;

<span style=color:#080;font-style:italic># すべてのPodの詳細を表示します。</span>
kubectl describe pods
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>kubectl get</code>コマンドは通常、同じリソースタイプの1つ以上のリソースを取得するために使用します。豊富なフラグが用意されており、例えば<code>-o</code>や<code>--output</code>フラグを使って、出力フォーマットをカスタマイズできます。<code>-w</code>や<code>--watch</code>フラグを指定することで、特定のオブジェクトの更新を監視できます。<code>kubectl describe</code>コマンドは、指定されたリソースに関する多くの側面を説明することに重点を置いています。ユーザーに対してビューを構築するために、APIサーバーへ複数のAPIコールを呼び出すことができます。例えば、<code>kubectl describe node</code>コマンドは、Nodeに関する情報だけでなく、その上で動いているPodやNodeで生成されたイベントなどをまとめて表示します。
</div>
<p><code>kubectl delete</code> - ファイル、標準出力、または指定したラベルセレクター、名前、リソースセレクター、リソースを指定して、リソースを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># pod.yamlファイルで指定されたタイプと名前を用いて、Podを削除します。</span>
kubectl delete -f pod.yaml

<span style=color:#080;font-style:italic># &#39;&lt;label-key&gt;=&lt;label-value&gt;&#39;というラベルを持つPodとServiceをすべて削除します。</span>
kubectl delete pods,services -l &lt;label-key&gt;<span style=color:#666>=</span>&lt;label-value&gt;

<span style=color:#080;font-style:italic># 初期化されていないPodを含む、すべてのPodを削除します。</span>
kubectl delete pods --all
</code></pre></div><p><code>kubectl exec</code> - Pod内のコンテナに対してコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Pod &lt;pod-name&gt;から、&#39;date&#39;を実行している時の出力を取得します。デフォルトでは、最初のコンテナから出力されます。</span>
kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -- date

<span style=color:#080;font-style:italic># Pod &lt;pod-name&gt;のコンテナ &lt;container-name&gt;から、&#39;date&#39;を実行している時の出力を取得します。</span>
kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -c &lt;container-name&gt; -- date

<span style=color:#080;font-style:italic># インタラクティブな TTY を取得し、Pod &lt;pod-name&gt;から/bin/bashを実行します。デフォルトでは、最初のコンテナから出力されます。</span>
kubectl <span style=color:#a2f>exec</span> -ti &lt;pod-name&gt; -- /bin/bash
</code></pre></div><p><code>kubectl logs</code> - Pod内のコンテナのログを表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Pod &lt;pod-name&gt;のログのスナップショットを返します。</span>
kubectl logs &lt;pod-name&gt;

<span style=color:#080;font-style:italic># Pod &lt;pod-name&gt;から、ログのストリーミングを開始します。Linuxの&#39;tail -f&#39;コマンドと似ています。</span>
kubectl logs -f &lt;pod-name&gt;
</code></pre></div><p><code>kubectl diff</code> - 提案されたクラスタに対する更新の差分を表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># pod.jsonに含まれるリソースの差分を表示します。</span>
kubectl diff -f pod.json

<span style=color:#080;font-style:italic># 標準出力から読み込んだファイルの差分を表示します。</span>
cat service.yaml | kubectl diff -f -
</code></pre></div><h2 id=例-プラグインの作成と使用>例: プラグインの作成と使用</h2>
<p><code>kubectl</code>プラグインの書き方や使い方に慣れるために、以下の例を使用してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 任意の言語でシンプルなプラグインを作成し、生成される実行可能なファイルに</span>
<span style=color:#080;font-style:italic># プレフィックス&#34;kubectl-&#34;で始まる名前を付けます。</span>
cat ./kubectl-hello
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080>#!/bin/sh
</span><span style=color:#080></span>
<span style=color:#080;font-style:italic># このプラグインは、&#34;hello world&#34;という単語を表示します。</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;hello world&#34;</span>
</code></pre></div><p>プラグインを書いたら、実行可能にします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>chmod a+x ./kubectl-hello

<span style=color:#080;font-style:italic># さらに、PATH内の場所に移動させます。</span>
sudo mv ./kubectl-hello /usr/local/bin
sudo chown root:root /usr/local/bin

<span style=color:#080;font-style:italic># これでkubectlプラグインを作成し、&#34;インストール&#34;できました。</span>
<span style=color:#080;font-style:italic># 通常のコマンドのようにkubectlから呼び出すことで、プラグインを使用できます。</span>
kubectl hello
</code></pre></div><pre><code>hello world
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 配置したPATHのフォルダから削除することで、プラグインを&#34;アンインストール&#34;できます。</span>
sudo rm /usr/local/bin/kubectl-hello
</code></pre></div><p><code>kubectl</code>で利用可能なプラグインをすべて表示するには、<code>kubectl plugin list</code>サブコマンドを使用してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl plugin list
</code></pre></div><p>出力は以下のようになります。</p>
<pre><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
/usr/local/bin/kubectl-bar
</code></pre><p><code>kubectl plugin list</code>コマンドは、実行不可能なプラグインや、他のプラグインの影に隠れてしまっているプラグインなどについて、警告することもできます。例えば、以下のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo chmod -x /usr/local/bin/kubectl-foo <span style=color:#080;font-style:italic># 実行権限を削除します。</span>
kubectl plugin list
</code></pre></div><pre><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
  - warning: /usr/local/bin/kubectl-foo identified as a plugin, but it is not executable
/usr/local/bin/kubectl-bar

error: one plugin warning was found
</code></pre><p>プラグインは、既存の<code>kubectl</code>コマンドの上に、より複雑な機能を構築するための手段であると考えることができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat ./kubectl-whoami
</code></pre></div><p>次の例では、下記の内容を含んだ<code>kubectl-whoami</code>が既に作成済であることを前提としています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080>#!/bin/bash
</span><span style=color:#080></span>
<span style=color:#080;font-style:italic># このプラグインは、`kubectl config`コマンドを使って</span>
<span style=color:#080;font-style:italic># 現在選択されているコンテキストに基づいて、現在のユーザーに関する情報を提供します。</span>
kubectl config view --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{ range .contexts }}{{ if eq .name &#34;&#39;</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config current-context<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#39;&#34; }}Current user: {{ printf &#34;%s\n&#34; .context.user }}{{ end }}{{ end }}&#39;</span>
</code></pre></div><p>上記のコマンドを実行すると、KUBECONFIGファイル内のカレントコンテキストのユーザーを含んだ出力を得られます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># ファイルを実行可能にします。</span>
sudo chmod +x ./kubectl-whoami

<span style=color:#080;font-style:italic># さらに、ファイルをPATHに移動します。</span>
sudo mv ./kubectl-whoami /usr/local/bin

kubectl whoami
Current user: plugins-user
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li>
<p><a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a>を使い始めてください。</p>
</li>
<li>
<p>プラグインについてより詳しく知りたい場合は, <a href=https://github.com/kubernetes/sample-cli-plugin>example cli plugin</a>を御覧ください。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a938176c695852fe70362c29cf615f1c>6.4.2 - JSONPathのサポート</h1>
<p>kubectlはJSONPathのテンプレートをサポートしています。</p>
<p>JSONPathのテンプレートは、波括弧<code>{}</code>によって囲まれたJSONPathの式によって構成されています。
kubectlでは、JSONPathの式を使うことで、JSONオブジェクトの特定のフィールドをフィルターしたり、出力のフォーマットを変更することができます。
本来のJSONPathのテンプレートの構文に加え、以下の機能と構文が使えます:</p>
<ol>
<li>JSONPathの式の内部でテキストをクォートするために、ダブルクォーテーションを使用します。</li>
<li>リストを反復するために、<code>range</code>、<code>end</code>オペレーターを使用します。</li>
<li>リストを末尾側から参照するために、負の数のインデックスを使用します。負の数のインデックスはリストを「周回」せず、<code>-index + listLength >= 0</code>が満たされる限りにおいて有効になります。</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <ul>
<li>
<p>式は常にルートのオブジェクトから始まるので、<code>$</code>オペレーターの入力は任意になります。</p>
</li>
<li>
<p>結果のオブジェクトはString()関数を適用した形で表示されます。</p>
</li>
</ul>
</div>
<p>以下のようなJSONの入力が与えられたとします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;List&#34;</span>,
  <span style=color:green;font-weight:700>&#34;items&#34;</span>:[
    {
      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>},
      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;4&#34;</span>},
        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[{<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>}]
      }
    },
    {
      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;8&#34;</span>},
        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[
          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;another&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.3&#34;</span>}
        ]
      }
    }
  ],
  <span style=color:green;font-weight:700>&#34;users&#34;</span>:[
    {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;myself&#34;</span>,
      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {}
    },
    {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;e2e&#34;</span>,
      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {<span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;admin&#34;</span>, <span style=color:green;font-weight:700>&#34;password&#34;</span>: <span style=color:#b44>&#34;secret&#34;</span>}
    }
  ]
}
</code></pre></div><table>
<thead>
<tr>
<th>機能</th>
<th>説明</th>
<th>例</th>
<th>結果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>text</code></td>
<td>プレーンテキスト</td>
<td><code>kind is {.kind}</code></td>
<td><code>kind is List</code></td>
</tr>
<tr>
<td><code>@</code></td>
<td>現在のオブジェクト</td>
<td><code>{@}</code></td>
<td>入力した値と同じ値</td>
</tr>
<tr>
<td><code>.</code> or <code>[]</code></td>
<td>子要素</td>
<td><code>{.kind}</code>, <code>{['kind']}</code> or <code>{['name\.type']}</code></td>
<td><code>List</code></td>
</tr>
<tr>
<td><code>..</code></td>
<td>子孫要素を再帰的に探す</td>
<td><code>{..name}</code></td>
<td><code>127.0.0.1 127.0.0.2 myself e2e</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>ワイルドカード。すべてのオブジェクトを取得する</td>
<td><code>{.items[*].metadata.name}</code></td>
<td><code>[127.0.0.1 127.0.0.2]</code></td>
</tr>
<tr>
<td><code>[start:end:step]</code></td>
<td>添字</td>
<td><code>{.users[0].name}</code></td>
<td><code>myself</code></td>
</tr>
<tr>
<td><code>[,]</code></td>
<td>和集合</td>
<td><code>{.items[*]['metadata.name', 'status.capacity']}</code></td>
<td><code>127.0.0.1 127.0.0.2 map[cpu:4] map[cpu:8]</code></td>
</tr>
<tr>
<td><code>?()</code></td>
<td>フィルター</td>
<td><code>{.users[?(@.name=="e2e")].user.password}</code></td>
<td><code>secret</code></td>
</tr>
<tr>
<td><code>range</code>, <code>end</code></td>
<td>リストの反復</td>
<td><code>{range .items[*]}[{.metadata.name}, {.status.capacity}] {end}</code></td>
<td><code>[127.0.0.1, map[cpu:4]] [127.0.0.2, map[cpu:8]]</code></td>
</tr>
<tr>
<td><code>''</code></td>
<td>解釈済みの文字列をクォートする</td>
<td><code>{range .items[*]}{.metadata.name}{'\t'}{end}</code></td>
<td><code>127.0.0.1 127.0.0.2</code></td>
</tr>
</tbody>
</table>
<p><code>kubectl</code>とJSONPathの式を使った例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -o json
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{@}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0]}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0].metadata.name}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*][&#39;metadata.name&#39;, &#39;status.capacity&#39;]}&#34;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{.metadata.name}{&#34;\t&#34;}{.status.startTime}{&#34;\n&#34;}{end}&#39;</span>
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>Windowsでは、空白が含まれるJSONPathのテンプレートをクォートする場合は(上記のようにシングルクォーテーションを使うのではなく)、ダブルクォーテーションを使わなければなりません。
また、テンプレート内のリテラルをクォートする際には、シングルクォーテーションか、エスケープされたダブルクォーテーションを使わなければなりません。例えば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd>kubectl get pods -o=jsonpath=<span style=color:#b44>&#34;{range .items[*]}{.metadata.name}{&#39;\t&#39;}{.status.startTime}{&#39;\n&#39;}{end}&#34;</span>
kubectl get pods -o=jsonpath=<span style=color:#b44>&#34;{range .items[*]}{.metadata.name}{\&#34;</span>\t\<span style=color:#b44>&#34;}{.status.startTime}{\&#34;</span>\n\<span style=color:#b44>&#34;}{end}&#34;</span>
</code></pre></div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>JSONPathの正規表現はサポートされていません。正規表現を利用した検索を行いたい場合は、<code>jq</code>のようなツールを使ってください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># kubectlはJSONpathの出力として正規表現をサポートしていないので、以下のコマンドは動作しない</span>
kubectl get pods -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[?(@.metadata.name=~/^test$/)].metadata.name}&#39;</span>

<span style=color:#080;font-style:italic># 上のコマンドに期待される結果が欲しい場合、以下のコマンドを使うとよい</span>
kubectl get pods -o json | jq -r <span style=color:#b44>&#39;.items[] | select(.metadata.name | test(&#34;test-&#34;)).spec.containers[].image&#39;</span>
</code></pre></div>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8aba901ac13f124e5782b90ddb166ee2>6.4.3 - kubectlチートシート</h1>
<p>このページには、一般的によく使われる<code>kubectl</code>コマンドとフラグのリストが含まれています。</p>
<h2 id=kubectlコマンドの補完>Kubectlコマンドの補完</h2>
<h3 id=bash>BASH</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion bash<span style=color:#666>)</span> <span style=color:#080;font-style:italic># 現在のbashシェルにコマンド補完を設定するには、最初にbash-completionパッケージをインストールする必要があります。</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;source &lt;(kubectl completion bash)&#34;</span> &gt;&gt; ~/.bashrc <span style=color:#080;font-style:italic># bashシェルでのコマンド補完を永続化するために.bashrcに追記します。</span>
</code></pre></div><p>また、エイリアスを使用している場合にも<code>kubectl</code>コマンドを補完できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>alias</span> <span style=color:#b8860b>k</span><span style=color:#666>=</span>kubectl
<span style=color:#a2f>complete</span> -F __start_kubectl k
</code></pre></div><h3 id=zsh>ZSH</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>  <span style=color:#080;font-style:italic># 現在のzshシェルにコマンド補完を設定します</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;[[ </span><span style=color:#b8860b>$commands</span><span style=color:#b44>[kubectl] ]] &amp;&amp; source &lt;(kubectl completion zsh)&#34;</span> &gt;&gt; ~/.zshrc <span style=color:#080;font-style:italic># zshシェルでのコマンド補完を永続化するために.zshrcに追記します。</span>
</code></pre></div><h2 id=kubectlコンテキストの設定>Kubectlコンテキストの設定</h2>
<p><code>kubectl</code>がどのKubernetesクラスターと通信するかを設定します。
設定ファイル詳細については<a href=/ja/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfigを使用した複数クラスターとの認証</a>をご覧ください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config view <span style=color:#080;font-style:italic># マージされたkubeconfigの設定を表示します。</span>

<span style=color:#080;font-style:italic># 複数のkubeconfigファイルを同時に読み込む場合はこのように記述します。</span>
<span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>~/.kube/config:~/.kube/kubconfig2 

kubectl config view

<span style=color:#080;font-style:italic># e2eユーザのパスワードを取得します。</span>
kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[?(@.name == &#34;e2e&#34;)].user.password}&#39;</span>

kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[].name}&#39;</span>    <span style=color:#080;font-style:italic># 最初のユーザー名を表示します</span>
kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[*].name}&#39;</span>   <span style=color:#080;font-style:italic># ユーザー名のリストを表示します</span>
kubectl config get-contexts                          <span style=color:#080;font-style:italic># コンテキストのリストを表示します</span>
kubectl config current-context                       <span style=color:#080;font-style:italic># 現在のコンテキストを表示します</span>
kubectl config use-context my-cluster-name           <span style=color:#080;font-style:italic># デフォルトのコンテキストをmy-cluster-nameに設定します</span>

<span style=color:#080;font-style:italic># basic認証をサポートする新たなユーザーをkubeconfigに追加します</span>
kubectl config set-credentials kubeuser/foo.kubernetes.com --username<span style=color:#666>=</span>kubeuser --password<span style=color:#666>=</span>kubepassword

<span style=color:#080;font-style:italic># 現在のコンテキストでkubectlのサブコマンドの名前空間を永続的に変更します</span>
kubectl config set-context --current --namespace<span style=color:#666>=</span>ggckad-s2

<span style=color:#080;font-style:italic># 特定のユーザー名と名前空間を使用してコンテキストを設定します</span>
kubectl config set-context gce --user<span style=color:#666>=</span>cluster-admin --namespace<span style=color:#666>=</span>foo <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> kubectl config use-context gce
 
kubectl config <span style=color:#a2f>unset</span> users.foo    <span style=color:#080;font-style:italic># ユーザーfooを削除します</span>
</code></pre></div><h2 id=kubectl-apply>Kubectl Apply</h2>
<p><code>apply</code>はKubernetesリソースを定義するファイルを通じてアプリケーションを管理します。<code>kubectl apply</code>を実行して、クラスター内のリソースを作成および更新します。これは、本番環境でKubernetesアプリケーションを管理する推奨方法です。
詳しくは<a href=https://kubectl.docs.kubernetes.io>Kubectl Book</a>をご覧ください。</p>
<h2 id=objectの作成>Objectの作成</h2>
<p>Kubernetesのマニフェストファイルは、JSONまたはYAMLで定義できます。ファイル拡張子として、<code>.yaml</code>や<code>.yml</code>、<code>.json</code>が使えます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f ./my-manifest.yaml            <span style=color:#080;font-style:italic># リソースを作成します</span>
kubectl apply -f ./my1.yaml -f ./my2.yaml      <span style=color:#080;font-style:italic># 複数のファイルからリソースを作成します</span>
kubectl apply -f ./dir                         <span style=color:#080;font-style:italic># dirディレクトリ内のすべてのマニフェストファイルからリソースを作成します</span>
kubectl apply -f https://git.io/vPieo          <span style=color:#080;font-style:italic># urlで公開されているファイルからリソースを作成します</span>
kubectl create deployment nginx --image<span style=color:#666>=</span>nginx  <span style=color:#080;font-style:italic># 単一のnginx Deploymentを作成します</span>
kubectl explain pods                           <span style=color:#080;font-style:italic># Podマニフェストのドキュメントを取得します</span>

<span style=color:#080;font-style:italic># 標準入力から複数のYAMLオブジェクトを作成します</span>

cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: busybox-sleep
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>  - name: busybox
</span><span style=color:#b44>    image: busybox
</span><span style=color:#b44>    args:
</span><span style=color:#b44>    - sleep
</span><span style=color:#b44>    - &#34;1000000&#34;
</span><span style=color:#b44>---
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: busybox-sleep-less
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>  - name: busybox
</span><span style=color:#b44>    image: busybox
</span><span style=color:#b44>    args:
</span><span style=color:#b44>    - sleep
</span><span style=color:#b44>    - &#34;1000&#34;
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># いくつかの鍵を含むSecretを作成します</span>

cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Secret
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: mysecret
</span><span style=color:#b44>type: Opaque
</span><span style=color:#b44>data:
</span><span style=color:#b44>  password: $(echo -n &#34;s33msi4&#34; | base64 -w0)
</span><span style=color:#b44>  username: $(echo -n &#34;jane&#34; | base64 -w0)
</span><span style=color:#b44>EOF</span>

</code></pre></div><h2 id=リソースの検索と閲覧>リソースの検索と閲覧</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># Getコマンドで基本的な情報を確認します</span>
kubectl get services                          <span style=color:#080;font-style:italic># 現在の名前空間上にあるすべてのサービスのリストを表示します</span>
kubectl get pods --all-namespaces             <span style=color:#080;font-style:italic># すべての名前空間上にあるすべてのPodのリストを表示します</span>
kubectl get pods -o wide                      <span style=color:#080;font-style:italic># 現在の名前空間上にあるすべてのPodについてより詳細なリストを表示します</span>
kubectl get deployment my-dep                 <span style=color:#080;font-style:italic># 特定のDeploymentを表示します</span>
kubectl get pods                              <span style=color:#080;font-style:italic># 現在の名前空間上にあるすべてのPodのリストを表示します</span>
kubectl get pod my-pod -o yaml                <span style=color:#080;font-style:italic># PodのYAMLを表示します</span>

<span style=color:#080;font-style:italic># Describeコマンドで詳細な情報を確認します</span>
kubectl describe nodes my-node
kubectl describe pods my-pod

<span style=color:#080;font-style:italic># 名前順にソートしたServiceのリストを表示します</span>
kubectl get services --sort-by<span style=color:#666>=</span>.metadata.name

<span style=color:#080;font-style:italic># Restartカウント順にPodのリストを表示します</span>
kubectl get pods --sort-by<span style=color:#666>=</span><span style=color:#b44>&#39;.status.containerStatuses[0].restartCount&#39;</span>

<span style=color:#080;font-style:italic># capacity順にソートしたPersistentVolumeのリストを表示します</span>
kubectl get pv --sort-by<span style=color:#666>=</span>.spec.capacity.storage

<span style=color:#080;font-style:italic># app=cassandraラベルのついたすべてのPodのversionラベルを表示します</span>
kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra -o <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.labels.version}&#39;</span>

<span style=color:#080;font-style:italic># &#39;ca.crt&#39;のようなピリオドが含まれるキーの値を取得します</span>
kubectl get configmap myconfig <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.ca\.crt}&#39;</span>

<span style=color:#080;font-style:italic># すべてのワーカーノードを取得します（セレクターを使用して、</span>
<span style=color:#080;font-style:italic># 「node-role.kubernetes.io/master」という名前のラベルを持つ結果を除外します）</span>
kubectl get node --selector<span style=color:#666>=</span><span style=color:#b44>&#39;!node-role.kubernetes.io/master&#39;</span>

<span style=color:#080;font-style:italic># 現在の名前空間でrunning状態のPodのリストを表示します</span>
kubectl get pods --field-selector<span style=color:#666>=</span>status.phase<span style=color:#666>=</span>Running

<span style=color:#080;font-style:italic># すべてのノードのExternal IPのリストを表示します</span>
kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].status.addresses[?(@.type==&#34;ExternalIP&#34;)].address}&#39;</span>

<span style=color:#080;font-style:italic># 特定のRCに属するPodの名前のリストを表示します</span>
<span style=color:#080;font-style:italic># `jq`コマンドは複雑なjsonpathを変換する場合に便利であり、https://stedolan.github.io/jq/で見つけることが可能です</span>
<span style=color:#b8860b>sel</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get rc my-rc --output<span style=color:#666>=</span>json | jq -j <span style=color:#b44>&#39;.spec.selector | to_entries | .[] | &#34;\(.key)=\(.value),&#34;&#39;</span><span style=color:#a2f;font-weight:700>)</span>%?<span style=color:#b68;font-weight:700>}</span>
<span style=color:#a2f>echo</span> <span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>$sel</span> --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>

<span style=color:#080;font-style:italic># すべてのPod(またはラベル付けをサポートする他のKubernetesオブジェクト)のラベルのリストを表示します</span>
kubectl get pods --show-labels

<span style=color:#080;font-style:italic># どのノードがready状態か確認します</span>
<span style=color:#b8860b>JSONPATH</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span> <span style=color:#666>&amp;&amp;</span> kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$JSONPATH</span><span style=color:#b44>&#34;</span> | grep <span style=color:#b44>&#34;Ready=True&#34;</span>

<span style=color:#080;font-style:italic># Podで現在使用中のSecretをすべて表示します</span>
kubectl get pods -o json | jq <span style=color:#b44>&#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39;</span> | grep -v null | sort | uniq

<span style=color:#080;font-style:italic># すべてのPodのInitContainerのコンテナIDのリストを表示します</span>
<span style=color:#080;font-style:italic># initContainerの削除を回避しながら、停止したコンテナを削除するときに役立つでしょう</span>
kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*].status.initContainerStatuses[*]}{.containerID}{&#34;\n&#34;}{end}&#39;</span> | cut -d/ -f3

<span style=color:#080;font-style:italic># タイムスタンプでソートされたEventのリストを表示します</span>
kubectl get events --sort-by<span style=color:#666>=</span>.metadata.creationTimestamp

<span style=color:#080;font-style:italic># クラスターの現在の状態を、マニフェストが適用された場合のクラスターの状態と比較します。</span>
kubectl diff -f ./my-manifest.yaml

<span style=color:#080;font-style:italic># Nodeから返されるすべてのキーをピリオド区切りの階層表記で生成します。</span>
<span style=color:#080;font-style:italic># 複雑にネストされたJSON構造をもつキーを指定したい時に便利です</span>
kubectl get nodes -o json | jq -c <span style=color:#b44>&#39;path(..)|[.[]|tostring]|join(&#34;.&#34;)&#39;</span>

<span style=color:#080;font-style:italic># Pod等から返されるすべてのキーをピリオド区切り階層表記で生成します。</span>
kubectl get pods -o json | jq -c <span style=color:#b44>&#39;path(..)|[.[]|tostring]|join(&#34;.&#34;)&#39;</span>
</code></pre></div><h2 id=リソースのアップデート>リソースのアップデート</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl <span style=color:#a2f>set</span> image deployment/frontend <span style=color:#b8860b>www</span><span style=color:#666>=</span>image:v2               <span style=color:#080;font-style:italic># frontend Deploymentのwwwコンテナイメージをv2にローリングアップデートします</span>
kubectl rollout <span style=color:#a2f>history</span> deployment/frontend                      <span style=color:#080;font-style:italic># frontend Deploymentの改訂履歴を確認します</span>
kubectl rollout undo deployment/frontend                         <span style=color:#080;font-style:italic># 1つ前のDeploymentにロールバックします</span>
kubectl rollout undo deployment/frontend --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>         <span style=color:#080;font-style:italic># 特定のバージョンにロールバックします</span>
kubectl rollout status -w deployment/frontend                    <span style=color:#080;font-style:italic># frontend Deploymentのローリングアップデートを状態をwatchします</span>
kubectl rollout restart deployment/frontend                      <span style=color:#080;font-style:italic># frontend Deployment を再起動します</span>


cat pod.json | kubectl replace -f -                              <span style=color:#080;font-style:italic># 標準入力から渡されたJSONに基づいてPodを置き換えます</span>

<span style=color:#080;font-style:italic># リソースを強制的に削除してから再生成し、置き換えます。サービスの停止が発生します</span>
kubectl replace --force -f ./pod.json

<span style=color:#080;font-style:italic># ReplicaSetリソースで作られたnginxについてServiceを作成します。これは、ポート80で提供され、コンテナへはポート8000で接続します</span>
kubectl expose rc nginx --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8000</span>

<span style=color:#080;font-style:italic># 単一コンテナのPodイメージのバージョン(タグ)をv4に更新します</span>
kubectl get pod mypod -o yaml | sed <span style=color:#b44>&#39;s/\(image: myimage\):.*$/\1:v4/&#39;</span> | kubectl replace -f -

kubectl label pods my-pod new-label<span style=color:#666>=</span>awesome                      <span style=color:#080;font-style:italic># ラベルを追加します</span>
kubectl annotate pods my-pod icon-url<span style=color:#666>=</span>http://goo.gl/XXBTWq       <span style=color:#080;font-style:italic># アノテーションを追加します</span>
kubectl autoscale deployment foo --min<span style=color:#666>=</span><span style=color:#666>2</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>                <span style=color:#080;font-style:italic># &#34;foo&#34; Deploymentのオートスケーリングを行います</span>
</code></pre></div><h2 id=リソースへのパッチ適用>リソースへのパッチ適用</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># ノードを部分的に更新します</span>
kubectl patch node k8s-node-1 -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;unschedulable&#34;:true}}&#39;</span>

<span style=color:#080;font-style:italic># コンテナのイメージを更新します。spec.containers[*].nameはマージキーであるため必須です</span>
kubectl patch pod valid-pod -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;kubernetes-serve-hostname&#34;,&#34;image&#34;:&#34;new image&#34;}]}}&#39;</span>

<span style=color:#080;font-style:italic># ポテンシャル配列を含むJSONパッチを使用して、コンテナのイメージを更新します</span>
kubectl patch pod valid-pod --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/containers/0/image&#34;, &#34;value&#34;:&#34;new image&#34;}]&#39;</span>

<span style=color:#080;font-style:italic># ポテンシャル配列のJSONパッチを使用してDeploymentのlivenessProbeを無効にします</span>
kubectl patch deployment valid-deployment  --type json   -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/livenessProbe&#34;}]&#39;</span>

<span style=color:#080;font-style:italic># ポテンシャル配列に新たな要素を追加します</span>
kubectl patch sa default --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/secrets/1&#34;, &#34;value&#34;: {&#34;name&#34;: &#34;whatever&#34; } }]&#39;</span>
</code></pre></div><h2 id=リソースの編集>リソースの編集</h2>
<p>任意のエディターでAPIリソースを編集します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl edit svc/docker-registry                      <span style=color:#080;font-style:italic># docker-registryという名前のサービスを編集します</span>
<span style=color:#b8860b>KUBE_EDITOR</span><span style=color:#666>=</span><span style=color:#b44>&#34;nano&#34;</span> kubectl edit svc/docker-registry   <span style=color:#080;font-style:italic># エディターを指定します</span>
</code></pre></div><h2 id=リソースのスケーリング>リソースのスケーリング</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> rs/foo                                 <span style=color:#080;font-style:italic># 「foo」という名前のレプリカセットを3にスケーリングします</span>
kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> -f foo.yaml                            <span style=color:#080;font-style:italic># 「foo.yaml」で指定されたリソースを3にスケーリングします</span>
kubectl scale --current-replicas<span style=color:#666>=</span><span style=color:#666>2</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span> deployment/mysql  <span style=color:#080;font-style:italic># mysqlと名付けられたdeploymentの現在のサイズが2であれば、mysqlを3にスケーリングします</span>
kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>5</span> rc/foo rc/bar rc/baz                   <span style=color:#080;font-style:italic># 複数のReplication controllerをスケーリングします</span>
</code></pre></div><h2 id=リソースの削除>リソースの削除</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl delete -f ./pod.json                                              <span style=color:#080;font-style:italic># pod.jsonで指定されたタイプと名前を使用してPodを削除します</span>
kubectl delete pod,service baz foo                                        <span style=color:#080;font-style:italic># 「baz」と「foo」の名前を持つPodとServiceを削除します</span>
kubectl delete pods,services -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                              <span style=color:#080;font-style:italic># name=myLabelラベルを持つのPodとServiceを削除します</span>
kubectl -n my-ns delete pod,svc --all                                     <span style=color:#080;font-style:italic># 名前空間my-ns内のすべてのPodとServiceを削除します</span>
<span style=color:#080;font-style:italic># awkコマンドのpattern1またはpattern2に一致するすべてのPodを削除します。</span>
kubectl get pods  -n mynamespace --no-headers<span style=color:#666>=</span><span style=color:#a2f>true</span> | awk <span style=color:#b44>&#39;/pattern1|pattern2/{print $1}&#39;</span> | xargs  kubectl delete -n mynamespace pod
</code></pre></div><h2 id=実行中のポッドとの対話処理>実行中のポッドとの対話処理</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl logs my-pod                                 <span style=color:#080;font-style:italic># Podのログをダンプします(標準出力)</span>
kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                        <span style=color:#080;font-style:italic># name=myLabelラベルの持つPodのログをダンプします(標準出力)</span>
kubectl logs my-pod --previous                      <span style=color:#080;font-style:italic># 以前に存在したコンテナのPodログをダンプします(標準出力)</span>
kubectl logs my-pod -c my-container                 <span style=color:#080;font-style:italic># 複数コンテナがあるPodで、特定のコンテナのログをダンプします(標準出力)</span>
kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel -c my-container        <span style=color:#080;font-style:italic># name=mylabelラベルを持つPodのログをダンプします(標準出力) </span>
kubectl logs my-pod -c my-container --previous      <span style=color:#080;font-style:italic># 複数コンテナがあるPodで、以前に作成した特定のコンテナのログをダンプします(標準出力)</span>
kubectl logs -f my-pod                              <span style=color:#080;font-style:italic># Podのログをストリームで確認します(標準出力)</span>
kubectl logs -f my-pod -c my-container              <span style=color:#080;font-style:italic># 複数のコンテナがあるPodで、特定のコンテナのログをストリームで確認します(標準出力)</span>
kubectl logs -f -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel --all-containers    <span style=color:#080;font-style:italic># name-myLabelラベルを持つすべてのコンテナのログをストリームで確認します(標準出力)</span>
kubectl run -i --tty busybox --image<span style=color:#666>=</span>busybox -- sh  <span style=color:#080;font-style:italic># Podをインタラクティブシェルとして実行します</span>
kubectl run nginx --image<span style=color:#666>=</span>nginx -n 
mynamespace                                         <span style=color:#080;font-style:italic># 特定の名前空間でnginx Podを実行します</span>
kubectl run nginx --image<span style=color:#666>=</span>nginx                     <span style=color:#080;font-style:italic># nginx Podを実行し、マニフェストファイルをpod.yamlという名前で書き込みます</span>
--dry-run<span style=color:#666>=</span>client -o yaml &gt; pod.yaml
kubectl attach my-pod -i                            <span style=color:#080;font-style:italic># 実行中のコンテナに接続します</span>
kubectl port-forward my-pod 5000:6000               <span style=color:#080;font-style:italic># ローカルマシンのポート5000を、my-podのポート6000に転送します</span>
kubectl <span style=color:#a2f>exec</span> my-pod -- ls /                         <span style=color:#080;font-style:italic># 既存のPodでコマンドを実行(単一コンテナの場合)</span>
kubectl <span style=color:#a2f>exec</span> my-pod -c my-container -- ls /         <span style=color:#080;font-style:italic># 既存のPodでコマンドを実行(複数コンテナがある場合)</span>
kubectl top pod POD_NAME --containers               <span style=color:#080;font-style:italic># 特定のPodとそのコンテナのメトリクスを表示します</span>
</code></pre></div><h2 id=ノードおよびクラスターとの対話処理>ノードおよびクラスターとの対話処理</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl cordon my-node                                                <span style=color:#080;font-style:italic># my-nodeをスケーリングされないように設定します</span>
kubectl drain my-node                                                 <span style=color:#080;font-style:italic># メンテナンスの準備としてmy-nodeで動作中のPodを空にします</span>
kubectl uncordon my-node                                              <span style=color:#080;font-style:italic># my-nodeをスケーリングされるように設定します</span>
kubectl top node my-node                                              <span style=color:#080;font-style:italic># 特定のノードのメトリクスを表示します</span>
kubectl cluster-info                                                  <span style=color:#080;font-style:italic># Kubernetesクラスターのマスターとサービスのアドレスを表示します</span>
kubectl cluster-info dump                                             <span style=color:#080;font-style:italic># 現在のクラスター状態を標準出力にダンプします</span>
kubectl cluster-info dump --output-directory<span style=color:#666>=</span>/path/to/cluster-state   <span style=color:#080;font-style:italic># 現在のクラスター状態を/path/to/cluster-stateにダンプします</span>

<span style=color:#080;font-style:italic># special-userキーとNoScheduleエフェクトを持つTaintがすでに存在する場合、その値は指定されたとおりに置き換えられます</span>
kubectl taint nodes foo <span style=color:#b8860b>dedicated</span><span style=color:#666>=</span>special-user:NoSchedule
</code></pre></div><h3 id=リソースタイプ>リソースタイプ</h3>
<p>サポートされているすべてのリソースタイプを、それらが<a href=/ja/docs/concepts/overview/kubernetes-api/#api-groups>API group</a>か<a href=/ja/docs/concepts/overview/working-with-objects/namespaces>Namespaced</a>、<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects>Kind</a>に関わらずその短縮名をリストします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl api-resources
</code></pre></div><p>APIリソースを探索するためのその他の操作:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>      <span style=color:#080;font-style:italic># 名前空間付きのすべてのリソースを表示します</span>
kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>     <span style=color:#080;font-style:italic># 名前空間のないすべてのリソースを表示します</span>
kubectl api-resources -o name                <span style=color:#080;font-style:italic># すべてのリソースを単純な出力(リソース名のみ)で表示します</span>
kubectl api-resources -o wide                <span style=color:#080;font-style:italic># すべてのリソースを拡張された形(別名 &#34;wide&#34;)で表示します</span>
kubectl api-resources --verbs<span style=color:#666>=</span>list,get       <span style=color:#080;font-style:italic># &#34;list&#34;および&#34;get&#34;操作をサポートするすべてのリソースを表示します</span>
kubectl api-resources --api-group<span style=color:#666>=</span>extensions <span style=color:#080;font-style:italic># &#34;extensions&#34; APIグループのすべてのリソースを表示します</span>
</code></pre></div><h3 id=出力のフォーマット>出力のフォーマット</h3>
<p>特定の形式で端末ウィンドウに詳細を出力するには、サポートされている<code>kubectl</code>コマンドに<code>-o</code>(または<code>--output</code>)フラグを追加します。</p>
<table>
<thead>
<tr>
<th>出力フォーマット</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o=custom-columns=&lt;spec></code></td>
<td>コンマ区切りされたカスタムカラムのリストを指定してテーブルを表示します</td>
</tr>
<tr>
<td><code>-o=custom-columns-file=&lt;filename></code></td>
<td><code>&lt;filename></code>ファイル内のカスタムカラムテンプレートを使用してテーブルを表示します</td>
</tr>
<tr>
<td><code>-o=json</code></td>
<td>JSON形式のAPIオブジェクトを出力します</td>
</tr>
<tr>
<td><code>-o=jsonpath=&lt;template></code></td>
<td><a href=/docs/reference/kubectl/jsonpath>jsonpath</a>式で定義されたフィールドを出力します</td>
</tr>
<tr>
<td><code>-o=jsonpath-file=&lt;filename></code></td>
<td><code>&lt;filename></code>ファイル内の<a href=/docs/reference/kubectl/jsonpath>jsonpath</a>式で定義されたフィールドを出力します</td>
</tr>
<tr>
<td><code>-o=name</code></td>
<td>リソース名のみを出力し、それ以外は何も出力しません。</td>
</tr>
<tr>
<td><code>-o=wide</code></td>
<td>追加の情報を含むプレーンテキスト形式で出力します。Podの場合、Node名が含まれます。</td>
</tr>
<tr>
<td><code>-o=yaml</code></td>
<td>YAML形式のAPIオブジェクトを出力します</td>
</tr>
</tbody>
</table>
<p><code>-o=custom-columns</code>を使用したサンプル:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># クラスター内で実行中のすべてのイメージ名を表示する</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[*].image&#39;</span>

<span style=color:#080;font-style:italic># &#34;k8s.gcr.io/coredns:1.6.2&#34;を除いたすべてのイメージ名を表示する</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[?(@.image!=&#34;k8s.gcr.io/coredns:1.6.2&#34;)].image&#39;</span>

<span style=color:#080;font-style:italic># 名前に関係なくmetadata以下のすべてのフィールドを表示する</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:metadata.*&#39;</span>
</code></pre></div><p>kubectlに関するより多くのサンプルは<a href=/ja/docs/reference/kubectl/overview/#custom-columns>カスタムカラムのリファレンス</a>を参照してください。</p>
<h3 id=kubectlのログレベルとデバッグ>Kubectlのログレベルとデバッグ</h3>
<p>kubectlのログレベルは、レベルを表す整数が後に続く<code>-v</code>または<code>--v</code>フラグで制御されます。一般的なKubernetesのログ記録規則と関連するログレベルについて、<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>こちら</a>で説明します。</p>
<table>
<thead>
<tr>
<th>ログレベル</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--v=0</code></td>
<td>これは、クラスターオペレーターにログレベルが0であることを"常に"見えるようにするために役立ちます</td>
</tr>
<tr>
<td><code>--v=1</code></td>
<td>ログレベルが必要ない場合に、妥当なデフォルトのログレベルです</td>
</tr>
<tr>
<td><code>--v=2</code></td>
<td>サービスに関する重要な定常状態情報と、システムの重要な変更に関連する可能性がある重要なログメッセージを表示します。 これは、ほとんどのシステムで推奨されるデフォルトのログレベルです。</td>
</tr>
<tr>
<td><code>--v=3</code></td>
<td>変更に関するより詳細なログレベルを表示します</td>
</tr>
<tr>
<td><code>--v=4</code></td>
<td>デバックにむいたログレベルで表示します</td>
</tr>
<tr>
<td><code>--v=6</code></td>
<td>要求されたリソースを表示します</td>
</tr>
<tr>
<td><code>--v=7</code></td>
<td>HTTPリクエストのヘッダを表示します</td>
</tr>
<tr>
<td><code>--v=8</code></td>
<td>HTTPリクエストのコンテンツを表示します</td>
</tr>
<tr>
<td><code>--v=9</code></td>
<td>HTTPリクエストのコンテンツをtruncationなしで表示します</td>
</tr>
</tbody>
</table>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>
<p>kubectlについてより深く学びたい方は<a href=/ja/docs/reference/kubectl/overview/>kubectl概要</a>や<a href=/docs/reference/kubectl/jsonpath>JsonPath</a>をご覧ください。</p>
</li>
<li>
<p>オプションについては<a href=/docs/reference/kubectl/kubectl/>kubectl</a> optionsをご覧ください。</p>
</li>
<li>
<p>また<a href=/docs/reference/kubectl/conventions/>kubectlの利用パターン</a>では再利用可能なスクリプトでkubectlを利用する方法を学べます。</p>
</li>
<li>
<p>コミュニティ版<a href=https://github.com/dennyzhang/cheatsheet-kubernetes-A4>kubectlチートシート</a>もご覧ください。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-54e562dd1441d0195970a6526b0055cc>6.5 - コマンドラインツールのリファレンス</h1>
</div>
<div class=td-content>
<h1 id=pg-ca5d01a42c486d535539d3038aa67eb9>6.5.1 - フィーチャーゲート</h1>
<p>このページでは管理者がそれぞれのKubernetesコンポーネントで指定できるさまざまなフィーチャーゲートの概要について説明しています。</p>
<p>各機能におけるステージの説明については、<a href=#feature-stages>機能のステージ</a>を参照してください。</p>
<h2 id=概要>概要</h2>
<p>フィーチャーゲートはアルファ機能または実験的機能を記述するkey=valueのペアのセットです。管理者は各コンポーネントで<code>--feature-gates</code>コマンドラインフラグを使用することで機能をオンまたはオフにできます。</p>
<p>各コンポーネントはそれぞれのコンポーネント固有のフィーチャーゲートの設定をサポートします。すべてのコンポーネントのフィーチャーゲートの全リストを表示するには<code>-h</code>フラグを使用します。kubeletなどのコンポーネントにフィーチャーゲートを設定するには以下のようにリストの機能ペアを<code>--feature-gates</code>フラグを使用して割り当てます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--feature-gates<span style=color:#666>=</span><span style=color:#b44>&#34;...,DynamicKubeletConfig=true&#34;</span>
</code></pre></div><p>次の表は各Kubernetesコンポーネントに設定できるフィーチャーゲートの概要です。</p>
<ul>
<li>「導入開始バージョン」列は機能が導入されたとき、またはリリース段階が変更されたときのKubernetesリリースバージョンとなります。</li>
<li>「最終利用可能バージョン」列は空ではない場合はフィーチャーゲートを使用できる最後のKubernetesリリースバージョンとなります。</li>
<li>アルファまたはベータ状態の機能は<a href=#feature-gates-for-alpha-or-beta-features>AlphaまたはBetaのフィーチャーゲート</a>に載っています。</li>
<li>安定している機能は、<a href=#feature-gates-for-graduated-or-deprecated-features>graduatedまたはdeprecatedのフィーチャーゲート</a>に載っています。</li>
<li>graduatedまたはdeprecatedのフィーチャーゲートには、非推奨および廃止された機能もリストされています。</li>
</ul>
<h3 id=feature-gates-for-alpha-or-beta-features>AlphaまたはBetaのフィーチャーゲート</h3>
<table><caption style=display:none>AlphaまたはBetaのフィーチャーゲート</caption>
<thead>
<tr>
<th>機能名</th>
<th>デフォルト値</th>
<th>ステージ</th>
<th>導入開始バージョン</th>
<th>最終利用可能バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AnyVolumeDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>APIListChunking</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>APIListChunking</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.9</td>
<td></td>
</tr>
<tr>
<td><code>APIPriorityAndFairness</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>APIResponseCompression</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td></td>
</tr>
<tr>
<td><code>AppArmor</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.4</td>
<td></td>
</tr>
<tr>
<td><code>BalanceAttachedNodeVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>BoundServiceAccountTokenVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td></td>
</tr>
<tr>
<td><code>CPUManager</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CPUManager</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>CRIContainerLogRotation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>CRIContainerLogRotation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>CSIInlineVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CSIInlineVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigration</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSIMigration</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAWS</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAWS</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAWSComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAzureDisk</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAzureDiskComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAzureFile</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAzureFileComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationGCE</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSIMigrationGCE</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationGCEComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationOpenStack</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationOpenStackComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>ConfigurableFSGroupPolicy</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>CustomCPUCFSQuotaPeriod</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>CustomResourceDefaulting</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceDefaulting</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>DevicePlugins</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>DevicePlugins</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>DryRun</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.12</td>
</tr>
<tr>
<td><code>DryRun</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td></td>
</tr>
<tr>
<td><code>DynamicAuditing</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td></td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.4</td>
<td>1.10</td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>EndpointSliceProxying</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>EphemeralContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>ExpandCSIVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ExpandCSIVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>ExpandInUsePersistentVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.14</td>
</tr>
<tr>
<td><code>ExpandInUsePersistentVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>ExpandPersistentVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.10</td>
</tr>
<tr>
<td><code>ExpandPersistentVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>ExperimentalHostUserNamespaceDefaulting</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.5</td>
<td></td>
</tr>
<tr>
<td><code>EvenPodsSpread</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>EvenPodsSpread</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>HPAScaleToZero</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>HyperVContainer</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>ImmutableEphemeralVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>KubeletPodResources</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.14</td>
</tr>
<tr>
<td><code>KubeletPodResources</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>LegacyNodeRoleBehavior</code></td>
<td><code>true</code></td>
<td>Alpha</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.9</td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolationFSQuotaMonitoring</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>MountContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td></td>
</tr>
<tr>
<td><code>NodeDisruptionExclusion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>NonPreemptingPriority</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>PodDisruptionBudget</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.3</td>
<td>1.4</td>
</tr>
<tr>
<td><code>PodDisruptionBudget</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.5</td>
<td></td>
</tr>
<tr>
<td><code>PodOverhead</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>ProcMountType</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>QOSReserved</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>RemainingItemCount</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>ResourceLimitsPriorityFunction</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td></td>
</tr>
<tr>
<td><code>RotateKubeletClientCertificate</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.8</td>
<td></td>
</tr>
<tr>
<td><code>RotateKubeletServerCertificate</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.11</td>
</tr>
<tr>
<td><code>RotateKubeletServerCertificate</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>RunAsGroup</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>RuntimeClass</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>RuntimeClass</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>SCTPSupport</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>ServerSideApply</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ServerSideApply</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>ServiceAccountIssuerDiscovery</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>ServiceAppProtocol</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>ServiceNodeExclusion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td></td>
</tr>
<tr>
<td><code>ServiceTopology</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>StartupProbe</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>StartupProbe</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>StorageVersionHash</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>StorageVersionHash</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.5</td>
<td>1.5</td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.6</td>
<td></td>
</tr>
<tr>
<td><code>SupportNodePidsLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>SupportNodePidsLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>SupportPodPidsLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>SupportPodPidsLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>Sysctls</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>TokenRequest</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TokenRequest</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>TokenRequestProjection</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TokenRequestProjection</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>TTLAfterFinished</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.20</td>
</tr>
<tr>
<td><code>TTLAfterFinished</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>TopologyManager</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>TopologyManager</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>ValidateProxyRedirects</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>ValidateProxyRedirects</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>VolumeSnapshotDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>VolumeSnapshotDataSource</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>WinDSR</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>WinOverlay</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id=feature-gates-for-graduated-or-deprecated-features>GraduatedまたはDeprecatedのフィーチャーゲート</h3>
<table><caption style=display:none>GraduatedまたはDeprecatedのフィーチャーゲート</caption>
<thead>
<tr>
<th>機能名</th>
<th>デフォルト値</th>
<th>ステージ</th>
<th>導入開始バージョン</th>
<th>最終利用可能バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Accelerators</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.10</td>
</tr>
<tr>
<td><code>Accelerators</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.7</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.8</td>
<td>1.11</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>AffinityInAnnotations</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.7</td>
</tr>
<tr>
<td><code>AffinityInAnnotations</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.8</td>
<td>-</td>
</tr>
<tr>
<td><code>AllowExtTrafficLocalEndpoints</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.4</td>
<td>1.6</td>
</tr>
<tr>
<td><code>AllowExtTrafficLocalEndpoints</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.7</td>
<td>-</td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.12</td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td>1.17</td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.17</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.17</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.9</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.14</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicProvisioningScheduling</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>DynamicProvisioningScheduling</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicVolumeProvisioning</code></td>
<td><code>true</code></td>
<td>Alpha</td>
<td>1.3</td>
<td>1.7</td>
</tr>
<tr>
<td><code>DynamicVolumeProvisioning</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.8</td>
<td>-</td>
</tr>
<tr>
<td><code>EnableAggregatedDiscoveryTimeout</code></td>
<td><code>true</code></td>
<td>Deprecated</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>EnableEquivalenceClassCache</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.14</td>
</tr>
<tr>
<td><code>EnableEquivalenceClassCache</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.15</td>
<td>-</td>
</tr>
<tr>
<td><code>ExperimentalCriticalPodAnnotation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.5</td>
<td>1.12</td>
</tr>
<tr>
<td><code>ExperimentalCriticalPodAnnotation</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>GCERegionalPersistentDisk</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>GCERegionalPersistentDisk</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>Initializers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.13</td>
</tr>
<tr>
<td><code>Initializers</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>KubeletConfigFile</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>KubeletConfigFile</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.10</td>
<td>-</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.12</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.9</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.10</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>PVCProtection</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>PVCProtection</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.10</td>
<td>-</td>
</tr>
<tr>
<td><code>RequestManagement</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>StorageObjectInUseProtection</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>StorageObjectInUseProtection</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.12</td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td>1.17</td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeSubpath</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.16</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td>1.17</td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id=機能を使用する>機能を使用する</h2>
<h3 id=feature-stages>機能のステージ</h3>
<p>機能には<em>Alpha</em> 、<em>Beta</em> 、<em>GA</em> の段階があります。<em>Alpha</em> 機能とは：</p>
<ul>
<li>デフォルトでは無効になっています。</li>
<li>バグがあるかもしれません。機能を有効にするとバグが発生する可能性があります。</li>
<li>機能のサポートは予告無しにいつでも削除される場合があります。</li>
<li>APIは今後のソフトウェアリリースで予告なく互換性の無い変更が行われる場合があります。</li>
<li>バグが発生するリスクが高く長期的なサポートはないため、短期間のテストクラスターでのみ使用することをお勧めします。</li>
</ul>
<p><em>Beta</em> 機能とは：</p>
<ul>
<li>デフォルトで有効になっています。</li>
<li>この機能は十分にテストされていて、有効にすることは安全と考えられます。</li>
<li>詳細は変更される可能性がありますが、機能全体のサポートは削除されません。</li>
<li>オブジェクトのスキーマやセマンティックは、その後のベータ版または安定版リリースで互換性の無い変更が行われる場合があります。互換性の無い変更が行われた場合には次のバージョンへの移行手順を提供します。これにはAPIオブジェクトの削除、編集、および再作成が必要になる場合があります。バージョンアップにはいくつかの対応が必要な場合があります。これには機能に依存するアプリケーションのダウンタイムが発生する場合があります。</li>
<li>今後のリリースで互換性の無い変更が行われる可能性があるため、ビジネスクリティカルでない使用のみが推奨されます。個別にアップグレードできる複数のクラスターがある場合はこの制限を緩和できる場合があります。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <em>ベータ版</em> の機能を試してフィードバックをお寄せください！
GAになってからさらなる変更を加えることは現実的ではない場合があります。
</div>
<p><em>GA</em> 機能とは(<em>GA</em> 機能は<em>安定版</em> 機能とも呼ばれます):</p>
<ul>
<li>機能は常に有効となり、無効にすることはできません。</li>
<li>フィーチャーゲートの設定は不要になります。</li>
<li>機能の安定版は後続バージョンでリリースされたソフトウェアで使用されます。</li>
</ul>
<h3 id=フィーチャーゲート>フィーチャーゲート</h3>
<p>各フィーチャーゲートは特定の機能を有効/無効にするように設計されています。</p>
<ul>
<li><code>Accelerators</code>: DockerでのNvidia GPUのサポートを有効にします。</li>
<li><code>AdvancedAuditing</code>: <a href=/docs/tasks/debug-application-cluster/audit/#advanced-audit>高度な監査機能</a>を有効にします。</li>
<li><code>AffinityInAnnotations</code>(<em>非推奨</em>): <a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity>Podのアフィニティまたはアンチアフィニティ</a>を有効にします。</li>
<li><code>AnyVolumeDataSource</code>: <a class=glossary-tooltip title=コンテナ内でボリュームとしてマウントするためにPersistentVolume内で定義されたストレージリソースを要求します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PVC>PVC</a>の<code>DataSource</code>としてカスタムリソースの使用を有効にします。</li>
<li><code>AllowExtTrafficLocalEndpoints</code>: サービスが外部へのリクエストをノードのローカルエンドポイントにルーティングできるようにします。</li>
<li><code>APIListChunking</code>: APIクライアントがAPIサーバーからチャンク単位で（<code>LIST</code>や<code>GET</code>の）リソースを取得できるようにします。
<code>APIPriorityAndFairness</code>: 各サーバーで優先順位付けと公平性を備えた要求の並行性を管理できるようにします(<code>RequestManagement</code>から名前が変更されました)。</li>
<li><code>APIResponseCompression</code>:<code>LIST</code>や<code>GET</code>リクエストのAPIレスポンスを圧縮します。</li>
<li><code>AppArmor</code>: Dockerを使用する場合にLinuxノードでAppArmorによる強制アクセスコントロールを有効にします。詳細は<a href=/docs/tutorials/clusters/apparmor/>AppArmorチュートリアル</a>で確認できます。</li>
<li><code>AttachVolumeLimit</code>: ボリュームプラグインを有効にすることでノードにアタッチできるボリューム数の制限を設定できます。</li>
<li><code>BalanceAttachedNodeVolumes</code>: スケジューリング中にバランスのとれたリソース割り当てを考慮するノードのボリュームカウントを含めます。判断を行う際に、CPU、メモリー使用率、およびボリュームカウントが近いノードがスケジューラーによって優先されます。</li>
<li><code>BlockVolume</code>: PodでRawブロックデバイスの定義と使用を有効にします。詳細は<a href=/docs/concepts/storage/persistent-volumes/#raw-block-volume-support>Rawブロックボリュームのサポート</a>で確認できます。</li>
<li><code>BoundServiceAccountTokenVolume</code>: ServiceAccountTokenVolumeProjectionによって構成される計画ボリュームを使用するにはServiceAccountボリュームを移行します。詳細は<a href=https://git.k8s.io/community/contributors/design-proposals/storage/svcacct-token-volume-source.md>Service Account Token Volumes</a>で確認できます。</li>
<li><code>ConfigurableFSGroupPolicy</code>: Podにボリュームをマウントするときに、ユーザーがfsGroupsのボリューム権限変更ポリシーを設定できるようにします。詳細については、<a href=/docs/tasks/configure-pod-container/security-context/#configure-volume-permission-and-ownership-change-policy-for-pods>Podのボリューム権限と所有権変更ポリシーの設定</a>をご覧ください。</li>
<li><code>CPUManager</code>: コンテナレベルのCPUアフィニティサポートを有効します。<a href=/docs/tasks/administer-cluster/cpu-management-policies/>CPUマネジメントポリシー</a>を見てください。</li>
<li><code>CRIContainerLogRotation</code>: criコンテナランタイムのコンテナログローテーションを有効にします。</li>
<li><code>CSIBlockVolume</code>: 外部CSIボリュームドライバーを有効にしてブロックストレージをサポートします。詳細は<a href=/docs/concepts/storage/volumes/#csi-raw-block-volume-support><code>csi</code>Rawブロックボリュームのサポート</a>で確認できます。</li>
<li><code>CSIDriverRegistry</code>: csi.storage.k8s.ioのCSIDriver APIオブジェクトに関連するすべてのロジックを有効にします。</li>
<li><code>CSIInlineVolume</code>: PodのCSIインラインボリュームサポートを有効にします。</li>
<li><code>CSIMigration</code>: シムと変換ロジックを有効にしてボリューム操作をKubernetesリポジトリー内のプラグインから対応した事前インストール済みのCSIプラグインにルーティングします。</li>
<li><code>CSIMigrationAWS</code>: シムと変換ロジックを有効にしてボリューム操作をKubernetesリポジトリー内のAWS-EBSプラグインからEBS CSIプラグインにルーティングします。ノードにEBS CSIプラグインがインストールおよび設定されていない場合、ツリー内のEBSプラグインへのフォールバックをサポートします。CSIMigration機能フラグを有効にする必要があります。</li>
<li><code>CSIMigrationAWSComplete</code>: EBSツリー内プラグインのkubeletおよびボリュームコントローラーへの登録を停止し、シムと変換ロジックを有効にして、AWS-EBSツリー内プラグインからEBS CSIプラグインにボリューム操作をルーティングします。CSIMigrationおよびCSIMigrationAWS機能フラグを有効にし、クラスター内のすべてのノードにEBS CSIプラグインをインストールおよび設定する必要があります。</li>
<li><code>CSIMigrationAzureDisk</code>: シムと変換ロジックを有効にしてボリューム操作をKubernetesリポジトリー内のAzure-DiskプラグインからAzure Disk CSIプラグインにルーティングします。ノードにAzureDisk CSIプラグインがインストールおよび設定されていない場合、ツリー内のAzureDiskプラグインへのフォールバックをサポートします。CSIMigration機能フラグを有効にする必要があります。</li>
<li><code>CSIMigrationAzureDiskComplete</code>: Azure-Diskツリー内プラグインのkubeletおよびボリュームコントローラーへの登録を停止し、シムと変換ロジックを有効にして、Azure-Diskツリー内プラグインからAzureDisk CSIプラグインにボリューム操作をルーティングします。CSIMigrationおよびCSIMigrationAzureDisk機能フラグを有効にし、クラスター内のすべてのノードにAzureDisk CSIプラグインをインストールおよび設定する必要があります。</li>
<li><code>CSIMigrationAzureFile</code>: シムと変換ロジックを有効にしてボリューム操作をKubernetesリポジトリー内のAzure-FileプラグインからAzure File CSIプラグインにルーティングします。ノードにAzureFile CSIプラグインがインストールおよび設定されていない場合、ツリー内のAzureFileプラグインへのフォールバックをサポートします。CSIMigration機能フラグを有効にする必要があります。</li>
<li><code>CSIMigrationAzureFileComplete</code>: Azure-Fileツリー内プラグインのkubeletおよびボリュームコントローラーへの登録を停止し、シムと変換ロジックを有効にして、Azure-Fileツリー内プラグインからAzureFile CSIプラグインにボリューム操作をルーティングします。CSIMigrationおよびCSIMigrationAzureFile機能フラグを有効にし、クラスター内のすべてのノードにAzureFile CSIプラグインをインストールおよび設定する必要があります。</li>
<li><code>CSIMigrationGCE</code>: シムと変換ロジックを有効にしてボリューム操作をKubernetesリポジトリー内のGCE-PDプラグインからPD CSIプラグインにルーティングします。ノードにPD CSIプラグインがインストールおよび設定されていない場合、ツリー内のGCEプラグインへのフォールバックをサポートします。CSIMigration機能フラグを有効にする必要があります。</li>
<li><code>CSIMigrationGCEComplete</code>: GCE-PDのツリー内プラグインのkubeletおよびボリュームコントローラーへの登録を停止し、シムと変換ロジックがGCE-PDのツリー内プラグインからPD CSIプラグインにボリューム操作をルーティングできるようにします。CSIMigrationおよびCSIMigrationGCE機能フラグを有効にし、クラスター内のすべてのノードにPD CSIプラグインをインストールおよび設定する必要があります。</li>
<li><code>CSIMigrationOpenStack</code>: シムと変換ロジックを有効にしてボリューム操作をKubernetesリポジトリー内のCinderプラグインからCinder CSIプラグインにルーティングします。ノードにCinder CSIプラグインがインストールおよび設定されていない場合、ツリー内のCinderプラグインへのフォールバックをサポートします。CSIMigration機能フラグを有効にする必要があります。</li>
<li><code>CSIMigrationOpenStackComplete</code>: Cinderのツリー内プラグインのkubeletおよびボリュームコントローラーへの登録を停止し、シムと変換ロジックがCinderのツリー内プラグインからCinder CSIプラグインにボリューム操作をルーティングできるようにします。CSIMigrationおよびCSIMigrationOpenStack機能フラグを有効にし、クラスター内のすべてのノードにCinder CSIプラグインをインストールおよび設定する必要があります。</li>
<li><code>CSINodeInfo</code>: csi.storage.k8s.ioのCSINodeInfo APIオブジェクトに関連するすべてのロジックを有効にします。</li>
<li><code>CSIPersistentVolume</code>: <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md>CSI(Container Storage Interface)</a>互換のボリュームプラグインを通してプロビジョニングされたボリュームの検出とマウントを有効にします。
詳細については<a href=/docs/concepts/storage/volumes/#csi><code>csi</code>ボリュームタイプ</a>ドキュメントを確認してください。</li>
<li><code>CustomCPUCFSQuotaPeriod</code>: ノードがCPUCFSQuotaPeriodを変更できるようにします。</li>
<li><code>CustomPodDNS</code>: <code>dnsConfig</code>プロパティを使用したPodのDNS設定のカスタマイズを有効にします。詳細は<a href=/ja/docs/concepts/services-networking/dns-pod-service/#pods-dns-config>PodのDNS構成</a>で確認できます。</li>
<li><code>CustomResourceDefaulting</code>: OpenAPI v3バリデーションスキーマにおいて、デフォルト値のCRDサポートを有効にします。</li>
<li><code>CustomResourcePublishOpenAPI</code>: CRDのOpenAPI仕様での公開を有効にします。</li>
<li><code>CustomResourceSubresources</code>: <a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>CustomResourceDefinition</a>から作成されたリソースの<code>/status</code>および<code>/scale</code>サブリソースを有効にします。</li>
<li><code>CustomResourceValidation</code>: <a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>CustomResourceDefinition</a>から作成されたリソースのスキーマによる検証を有効にします。</li>
<li><code>CustomResourceWebhookConversion</code>: <a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>CustomResourceDefinition</a>から作成されたリソースのWebhookベースの変換を有効にします。</li>
<li><code>DevicePlugins</code>: <a href=/docs/concepts/cluster-administration/device-plugins/>device-plugins</a>によるノードでのリソースプロビジョニングを有効にします。</li>
<li><code>DryRun</code>: サーバーサイドでの<a href=/docs/reference/using-api/api-concepts/#dry-run>dry run</a>リクエストを有効にします。</li>
<li><code>DynamicAuditing</code>: <a href=/docs/tasks/debug-application-cluster/audit/#dynamic-backend>動的監査</a>を有効にします。</li>
<li><code>DynamicKubeletConfig</code>: kubeletの動的構成を有効にします。<a href=/docs/tasks/administer-cluster/reconfigure-kubelet/>kubeletの再設定</a>を参照してください。</li>
<li><code>DynamicProvisioningScheduling</code>: デフォルトのスケジューラーを拡張してボリュームトポロジーを認識しPVプロビジョニングを処理します。この機能は、v1.12の<code>VolumeScheduling</code>機能に完全に置き換えられました。</li>
<li><code>DynamicVolumeProvisioning</code>(<em>非推奨</em>): Podへの永続ボリュームの<a href=/ja/docs/concepts/storage/dynamic-provisioning/>動的プロビジョニング</a>を有効にします。</li>
<li><code>EnableAggregatedDiscoveryTimeout</code> (<em>非推奨</em>): 集約されたディスカバリーコールで5秒のタイムアウトを有効にします。</li>
<li><code>EnableEquivalenceClassCache</code>: Podをスケジュールするときにスケジューラーがノードの同等をキャッシュできるようにします。</li>
<li><code>EphemeralContainers</code>: 稼働するPodに<a class=glossary-tooltip title="A type of container type that you can temporarily run inside a Pod" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ephemeral-containers/ target=_blank aria-label="ephemeral containers">ephemeral containers</a>を追加する機能を有効にします。</li>
<li><code>EvenPodsSpread</code>: Podをトポロジードメイン全体で均等にスケジュールできるようにします。<a href=/docs/concepts/configuration/even-pods-spread>Even Pods Spread</a>をご覧ください。</li>
<li><code>ExpandInUsePersistentVolumes</code>: 使用中のPVCのボリューム拡張を有効にします。<a href=/docs/concepts/storage/persistent-volumes/#resizing-an-in-use-persistentvolumeclaim>使用中のPersistentVolumeClaimのサイズ変更</a>を参照してください。</li>
<li><code>ExpandPersistentVolumes</code>: 永続ボリュームの拡張を有効にします。<a href=/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims>永続ボリューム要求の拡張</a>を参照してください。</li>
<li><code>ExperimentalCriticalPodAnnotation</code>: <a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/>スケジューリングが保証されるよう</a>に特定のPodへの <em>クリティカル</em> の注釈を加える設定を有効にします。</li>
<li><code>ExperimentalHostUserNamespaceDefaultingGate</code>: ホストするデフォルトのユーザー名前空間を有効にします。これは他のホストの名前空間やホストのマウントを使用しているコンテナ、特権を持つコンテナ、または名前空間のない特定の機能（たとえば<code>MKNODE</code>、<code>SYS_MODULE</code>など）を使用しているコンテナ用です。これはDockerデーモンでユーザー名前空間の再マッピングが有効になっている場合にのみ有効にすべきです。</li>
<li><code>EndpointSlice</code>: よりスケーラブルで拡張可能なネットワークエンドポイントのエンドポイントスライスを有効にします。<a href=/docs/tasks/administer-cluster/enabling-endpointslices/>Enabling Endpoint Slices</a>をご覧ください。</li>
<li><code>EndpointSliceProxying</code>: このフィーチャーゲートを有効にすると、kube-proxyはエンドポイントの代わりにエンドポイントスライスをプライマリデータソースとして使用し、スケーラビリティとパフォーマンスの向上を実現します。<a href=/docs/tasks/administer-cluster/enabling-endpointslices/>Enabling Endpoint Slices</a>.をご覧ください。</li>
<li><code>GCERegionalPersistentDisk</code>: GCEでリージョナルPD機能を有効にします。</li>
<li><code>HugePages</code>: 事前に割り当てられた<a href=/docs/tasks/manage-hugepages/scheduling-hugepages/>huge pages</a>の割り当てと消費を有効にします。</li>
<li><code>HugePageStorageMediumSize</code>: 事前に割り当てられた複数のサイズの<a href=/docs/tasks/manage-hugepages/scheduling-hugepages/>huge pages</a>のサポートを有効にします。</li>
<li><code>HyperVContainer</code>: Windowsコンテナの<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container>Hyper-Vによる分離</a>を有効にします。</li>
<li><code>HPAScaleToZero</code>: カスタムメトリクスまたは外部メトリクスを使用するときに、<code>HorizontalPodAutoscaler</code>リソースの<code>minReplicas</code>を0に設定できるようにします。</li>
<li><code>ImmutableEphemeralVolumes</code>: 安全性とパフォーマンスを向上させるために、個々のSecretとConfigMapが不変となるように指定できるようにします。</li>
<li><code>KubeletConfigFile</code>: 設定ファイルを使用して指定されたファイルからのkubelet設定の読み込みを有効にします。詳細は<a href=/docs/tasks/administer-cluster/kubelet-config-file/>設定ファイルによるkubeletパラメーターの設定</a>で確認できます。</li>
<li><code>KubeletPluginsWatcher</code>: 調査ベースのプラグイン監視ユーティリティを有効にしてkubeletが<a href=/docs/concepts/storage/volumes/#csi>CSIボリュームドライバー</a>などのプラグインを検出できるようにします。</li>
<li><code>KubeletPodResources</code>: kubeletのPodのリソースgrpcエンドポイントを有効にします。詳細は<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/compute-device-assignment.md>デバイスモニタリングのサポート</a>で確認できます。</li>
<li><code>LegacyNodeRoleBehavior</code>: 無効にすると、サービスロードバランサーの従来の動作とノードの中断により機能固有のラベルが優先され、<code>node-role.kubernetes.io/master</code>ラベルが無視されます。</li>
<li><code>LocalStorageCapacityIsolation</code>: <a href=/docs/concepts/configuration/manage-resources-containers/>ローカルの一時ストレージ</a>の消費を有効にして、<a href=/docs/concepts/storage/volumes/#emptydir>emptyDirボリューム</a>の<code>sizeLimit</code>プロパティも有効にします。</li>
<li><code>LocalStorageCapacityIsolationFSQuotaMonitoring</code>: <code>LocalStorageCapacityIsolation</code>が<a href=/docs/concepts/configuration/manage-resources-containers/>ローカルの一時ストレージ</a>で有効になっていて、<a href=/docs/concepts/storage/volumes/#emptydir>emptyDirボリューム</a>のbacking filesystemがプロジェクトクォータをサポートし有効になっている場合、プロジェクトクォータを使用して、パフォーマンスと精度を向上させるために、ファイルシステムへのアクセスではなく<a href=/docs/concepts/storage/volumes/#emptydir>emptyDirボリューム</a>ストレージ消費を監視します。</li>
<li><code>MountContainers</code>: ホスト上のユーティリティコンテナをボリュームマウンターとして使用できるようにします。</li>
<li><code>MountPropagation</code>: あるコンテナによってマウントされたボリュームを他のコンテナまたはPodに共有できるようにします。詳細は<a href=/docs/concepts/storage/volumes/#mount-propagation>マウントの伝播</a>で確認できます。</li>
<li><code>NodeDisruptionExclusion</code>: ノードラベル<code>node.kubernetes.io/exclude-disruption</code>の使用を有効にします。これにより、ゾーン障害時にノードが退避するのを防ぎます。</li>
<li><code>NodeLease</code>: 新しいLease APIを有効にしてノードヘルスシグナルとして使用できるノードのハートビートをレポートします。</li>
<li><code>NonPreemptingPriority</code>: PriorityClassとPodのNonPreemptingオプションを有効にします。</li>
<li><code>PersistentLocalVolumes</code>: Podで<code>local</code>ボリュームタイプの使用を有効にします。<code>local</code>ボリュームを要求する場合、Podアフィニティを指定する必要があります。</li>
<li><code>PodOverhead</code>: <a href=/docs/concepts/configuration/pod-overhead/>PodOverhead</a>機能を有効にして、Podのオーバーヘッドを考慮するようにします。</li>
<li><code>PodDisruptionBudget</code>: <a href=/docs/tasks/run-application/configure-pdb/>PodDisruptionBudget</a>機能を有効にします。</li>
<li><code>PodPriority</code>: <a href=/docs/concepts/configuration/pod-priority-preemption/>優先度</a>に基づいてPodの再スケジューリングとプリエンプションを有効にします。</li>
<li><code>PodReadinessGates</code>: Podのreadinessの評価を拡張するために<code>PodReadinessGate</code>フィールドの設定を有効にします。詳細は<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate>Pod readiness gate</a>で確認できます。</li>
<li><code>PodShareProcessNamespace</code>: Podで実行されているコンテナ間で単一のプロセス名前空間を共有するには、Podで<code>shareProcessNamespace</code>の設定を有効にします。詳細については、<a href=/docs/tasks/configure-pod-container/share-process-namespace/>Pod内のコンテナ間でプロセス名前空間を共有する</a>をご覧ください。</li>
<li><code>ProcMountType</code>: コンテナのProcMountTypeの制御を有効にします。</li>
<li><code>PVCProtection</code>: 永続ボリューム要求（PVC）がPodでまだ使用されているときに削除されないようにします。詳細は<a href=/docs/tasks/administer-cluster/storage-object-in-use-protection/>ここ</a>で確認できます。</li>
<li><code>QOSReserved</code>: QoSレベルでのリソース予約を許可して、低いQoSレベルのポッドが高いQoSレベルで要求されたリソースにバーストするのを防ぎます（現時点ではメモリのみ）。</li>
<li><code>ResourceLimitsPriorityFunction</code>: 入力したPodのCPU制限とメモリ制限の少なくとも1つを満たすノードに対して最低スコアを1に割り当てるスケジューラー優先機能を有効にします。その目的は同じスコアを持つノード間の関係を断つことです。</li>
<li><code>ResourceQuotaScopeSelectors</code>: リソース割当のスコープセレクターを有効にします。</li>
<li><code>RotateKubeletClientCertificate</code>: kubeletでクライアントTLS証明書のローテーションを有効にします。詳細は<a href=/docs/tasks/administer-cluster/storage-object-in-use-protection/>kubeletの設定</a>で確認できます。</li>
<li><code>RotateKubeletServerCertificate</code>: kubeletでサーバーTLS証明書のローテーションを有効にします。詳細は<a href=/docs/tasks/administer-cluster/storage-object-in-use-protection/>kubeletの設定</a>で確認できます。</li>
<li><code>RunAsGroup</code>: コンテナの初期化プロセスで設定されたプライマリグループIDの制御を有効にします。</li>
<li><code>RuntimeClass</code>: コンテナのランタイム構成を選択するには<a href=/docs/concepts/containers/runtime-class/>RuntimeClass</a>機能を有効にします。</li>
<li><code>ScheduleDaemonSetPods</code>: DaemonSetのPodをDaemonSetコントローラーではなく、デフォルトのスケジューラーによってスケジュールされるようにします。</li>
<li><code>SCTPSupport</code>: <code>Service</code>、<code>Endpoints</code>、<code>NetworkPolicy</code>、<code>Pod</code>の定義で<code>protocol</code>の値としてSCTPを使用できるようにします</li>
<li><code>ServerSideApply</code>: APIサーバーで<a href=/docs/reference/using-api/api-concepts/#server-side-apply>サーバーサイドApply(SSA)</a>のパスを有効にします。</li>
<li><code>ServiceAccountIssuerDiscovery</code>: APIサーバーにてサービスアカウント発行者のOIDC検出エンドポイント（発行者とJWKS URL）を有効にします。詳細については、<a href=/docs/tasks/configure-pod-container/configure-service-account/#service-account-issuer-discovery>Podのサービスアカウント設定</a>をご覧ください。</li>
<li><code>ServiceAppProtocol</code>: サービスとエンドポイントで<code>AppProtocol</code>フィールドを有効にします。</li>
<li><code>ServiceLoadBalancerFinalizer</code>: サービスロードバランサーのファイナライザー保護を有効にします。</li>
<li><code>ServiceNodeExclusion</code>: クラウドプロバイダーによって作成されたロードバランサーからのノードの除外を有効にします。"<code>alpha.service-controller.kubernetes.io/exclude-balancer</code>"キーまたは<code>node.kubernetes.io/exclude-from-external-load-balancers</code>でラベル付けされている場合ノードは除外の対象となります。</li>
<li><code>ServiceTopology</code>: クラスタのノードトポロジーに基づいてトラフィックをルーティングするサービスを有効にします。詳細については、<a href=/ja/docs/concepts/services-networking/service-topology/>Serviceトポロジー</a>を参照してください。</li>
<li><code>StartupProbe</code>: kubeletで<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#when-should-you-use-a-startup-probe>startup</a>プローブを有効にします。</li>
<li><code>StorageObjectInUseProtection</code>: PersistentVolumeまたはPersistentVolumeClaimオブジェクトがまだ使用されている場合、それらの削除を延期します。</li>
<li><code>StorageVersionHash</code>: apiserversがディスカバリーでストレージのバージョンハッシュを公開できるようにします。</li>
<li><code>StreamingProxyRedirects</code>: ストリーミングリクエストのバックエンド(kubelet)からのリダイレクトをインターセプト（およびフォロー）するようAPIサーバーに指示します。ストリーミングリクエストの例には<code>exec</code>、<code>attach</code>、<code>port-forward</code>リクエストが含まれます。</li>
<li><code>SupportIPVSProxyMode</code>: IPVSを使用したクラスター内サービスの負荷分散の提供を有効にします。詳細は<a href=/ja/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>サービスプロキシー</a>で確認できます。</li>
<li><code>SupportPodPidsLimit</code>: PodのPID制限のサポートを有効にします。</li>
<li><code>Sysctls</code>: 各Podに設定できる名前空間付きのカーネルパラメーター(sysctl)のサポートを有効にします。詳細は<a href=/docs/tasks/administer-cluster/sysctl-cluster/>sysctls</a>で確認できます。</li>
<li><code>TaintBasedEvictions</code>: ノードのTaintとPodのTolerationに基づいてノードからPodを排除できるようにします。。詳細は<a href=/docs/concepts/scheduling-eviction/taint-and-toleration/>TaintとToleration</a>で確認できます。</li>
<li><code>TaintNodesByCondition</code>: <a href=/ja/docs/concepts/architecture/nodes/#condition>ノードの条件</a>に基づいてノードの自動Taintを有効にします。</li>
<li><code>TokenRequest</code>: サービスアカウントリソースで<code>TokenRequest</code>エンドポイントを有効にします。</li>
<li><code>TokenRequestProjection</code>: <a href=/docs/concepts/storage/volumes/#projected>Projectedボリューム</a>を使用したPodへのサービスアカウントのトークンの注入を有効にします。</li>
<li><code>TTLAfterFinished</code>: <a href=/docs/concepts/workloads/controllers/ttlafterfinished/>TTLコントローラー</a>が実行終了後にリソースをクリーンアップできるようにします。</li>
<li><code>VolumePVCDataSource</code>: 既存のPVCをデータソースとして指定するサポートを有効にします。</li>
<li><code>VolumeScheduling</code>: ボリュームトポロジー対応のスケジューリングを有効にし、PersistentVolumeClaim（PVC）バインディングにスケジューリングの決定を認識させます。また<code>PersistentLocalVolumes</code>フィーチャーゲートと一緒に使用すると<a href=/docs/concepts/storage/volumes/#local><code>local</code></a>ボリュームタイプの使用が可能になります。</li>
<li><code>VolumeSnapshotDataSource</code>: ボリュームスナップショットのデータソースサポートを有効にします。</li>
<li><code>VolumeSubpathEnvExpansion</code>: 環境変数を<code>subPath</code>に展開するための<code>subPathExpr</code>フィールドを有効にします。</li>
<li><code>WatchBookmark</code>: ブックマークイベントの監視サポートを有効にします。</li>
<li><code>WindowsGMSA</code>: GMSA資格仕様をPodからコンテナランタイムに渡せるようにします。</li>
<li><code>WindowsRunAsUserName</code>: デフォルト以外のユーザーでWindowsコンテナアプリケーションを実行するためのサポートを有効にします。詳細については、<a href=/docs/tasks/configure-pod-container/configure-runasusername>RunAsUserNameの設定</a>を参照してください。</li>
<li><code>WinDSR</code>: kube-proxyがWindows用のDSRロードバランサーを作成できるようにします。</li>
<li><code>WinOverlay</code>: kube-proxyをWindowsのオーバーレイモードで実行できるようにします。</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>Kubernetesの<a href=/docs/reference/using-api/deprecation-policy/>非推奨ポリシー</a>では、機能とコンポーネントを削除するためのプロジェクトのアプローチを説明しています。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1715b765e2ff39feffd103d59ec0ef07>6.5.2 - Kubelet 認証/認可</h1>
<h2 id=概要>概要</h2>
<p>kubeletのHTTPSエンドポイントは、さまざまな感度のデータへのアクセスを提供するAPIを公開し、
ノードとコンテナ内のさまざまなレベルの権限でタスクを実行できるようにします。</p>
<p>このドキュメントでは、kubeletのHTTPSエンドポイントへのアクセスを認証および承認する方法について説明します。</p>
<h2 id=kubelet-認証>Kubelet 認証</h2>
<p>デフォルトでは、他の構成済み認証方法によって拒否されないkubeletのHTTPSエンドポイントへのリクエストは
匿名リクエストとして扱われ、ユーザー名は<code>system:anonymous</code>、
グループは<code>system:unauthenticated</code>になります。</p>
<p>匿名アクセスを無効にし、認証されていないリクエストに対して<code>401 Unauthorized</code>応答を送信するには：</p>
<ul>
<li><code>--anonymous-auth=false</code>フラグでkubeletを開始します。</li>
</ul>
<p>kubeletのHTTPSエンドポイントに対するX509クライアント証明書認証を有効にするには：</p>
<ul>
<li><code>--client-ca-file</code>フラグでkubeletを起動し、クライアント証明書を確認するためのCAバンドルを提供します。</li>
<li><code>--kubelet-client-certificate</code>および<code>--kubelet-client-key</code>フラグを使用してapiserverを起動します。</li>
<li>詳細については、<a href=/ja/docs/reference/access-authn-authz/authentication/#x509-client-certs>apiserver認証ドキュメント</a>を参照してください。</li>
</ul>
<p>APIベアラートークン(サービスアカウントトークンを含む)を使用して、kubeletのHTTPSエンドポイントへの認証を行うには：</p>
<ul>
<li>APIサーバーで<code>authentication.k8s.io/v1beta1</code>グループが有効になっていることを確認します。</li>
<li><code>--authentication-token-webhook</code>および<code>--kubeconfig</code>フラグを使用してkubeletを開始します。</li>
<li>kubeletは、構成済みのAPIサーバーで <code>TokenReview</code> APIを呼び出して、ベアラートークンからユーザー情報を判別します。</li>
</ul>
<h2 id=kubelet-承認>Kubelet 承認</h2>
<p>認証に成功した要求(匿名要求を含む)はすべて許可されます。デフォルトの認可モードは、すべての要求を許可する<code>AlwaysAllow</code>です。</p>
<p>kubelet APIへのアクセスを細分化するのは、次のような多くの理由が考えられます:</p>
<ul>
<li>匿名認証は有効になっていますが、匿名ユーザーがkubeletのAPIを呼び出す機能は制限する必要があります。</li>
<li>ベアラートークン認証は有効になっていますが、kubeletのAPIを呼び出す任意のAPIユーザー(サービスアカウントなど)の機能を制限する必要があります。</li>
<li>クライアント証明書の認証は有効になっていますが、構成されたCAによって署名されたクライアント証明書の一部のみがkubeletのAPIの使用を許可されている必要があります。</li>
</ul>
<p>kubeletのAPIへのアクセスを細分化するには、APIサーバーに承認を委任します:</p>
<ul>
<li>APIサーバーで<code>authorization.k8s.io/v1beta1</code> APIグループが有効になっていることを確認します。</li>
<li><code>--authorization-mode=Webhook</code>と<code>--kubeconfig</code>フラグでkubeletを開始します。</li>
<li>kubeletは、構成されたAPIサーバーで<code>SubjectAccessReview</code> APIを呼び出して、各リクエストが承認されているかどうかを判断します。</li>
</ul>
<p>kubeletは、apiserverと同じ<a href=/docs/reference/access-authn-authz/authorization/#review-your-request-attributes>リクエスト属性</a>アプローチを使用してAPIリクエストを承認します。</p>
<p>動詞は、受けとったリクエストのHTTP動詞から決定されます:</p>
<table>
<thead>
<tr>
<th>HTTP動詞</th>
<th>要求 動詞</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>create</td>
</tr>
<tr>
<td>GET, HEAD</td>
<td>get</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
</tr>
<tr>
<td>PATCH</td>
<td>patch</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete</td>
</tr>
</tbody>
</table>
<p>リソースとサブリソースは、受けとったリクエストのパスから決定されます:</p>
<table>
<thead>
<tr>
<th>Kubelet API</th>
<th>リソース</th>
<th>サブリソース</th>
</tr>
</thead>
<tbody>
<tr>
<td>/stats/*</td>
<td>nodes</td>
<td>stats</td>
</tr>
<tr>
<td>/metrics/*</td>
<td>nodes</td>
<td>metrics</td>
</tr>
<tr>
<td>/logs/*</td>
<td>nodes</td>
<td>log</td>
</tr>
<tr>
<td>/spec/*</td>
<td>nodes</td>
<td>spec</td>
</tr>
<tr>
<td><em>all others</em></td>
<td>nodes</td>
<td>proxy</td>
</tr>
</tbody>
</table>
<p>名前空間とAPIグループの属性は常に空の文字列であり、
リソース名は常にkubeletの<code>Node</code> APIオブジェクトの名前です。</p>
<p>このモードで実行する場合は、apiserverに渡される<code>--kubelet-client-certificate</code>フラグと<code>--kubelet-client-key</code>
フラグで識別されるユーザーが次の属性に対して許可されていることを確認します:</p>
<ul>
<li>verb=*, resource=nodes, subresource=proxy</li>
<li>verb=*, resource=nodes, subresource=stats</li>
<li>verb=*, resource=nodes, subresource=log</li>
<li>verb=*, resource=nodes, subresource=spec</li>
<li>verb=*, resource=nodes, subresource=metrics</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-954776b47f2d90515f375623a0ce98e1>6.6 - RBAC認可を使用する</h1>
<p>Role Based Access Control(RBAC)は、組織内の個々のユーザーのRoleをベースに、コンピューターまたはネットワークリソースへのアクセスを制御する方法です。</p>
<p>RBAC認可は<a class=glossary-tooltip title="A set of related paths in the Kubernetes API." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label="API Group">API Group</a> <code>rbac.authorization.k8s.io</code>を使用して認可の決定を行い、Kubernetes APIを介して動的にポリシーを構成できるようにします。</p>
<p>RBACを有効にするには、以下の例のように<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API server">API server</a>の<code>--authorization-mode</code> フラグをコンマ区切りの<code>RBAC</code>を含むリストでスタートします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kube-apiserver --authorization-mode<span style=color:#666>=</span>Example,RBAC --other-options --more-options
</code></pre></div><h2 id=api-overview>APIオブジェクト</h2>
<p>RBAC APIは4種類のKubernetesオブジェクト(<em>Role</em>、 <em>ClusterRole</em>、 <em>RoleBinding</em> そして <em>ClusterRoleBinding</em>)を宣言します。他のKubernetesオブジェクトのように<code>kubectl</code>のようなツールを使って、<a href=https://kubernetes.io/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>オブジェクトを記述</a>、または変更できます。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> これらのオブジェクトは設計上、アクセス制限を課します。学んできたように変更を行っている場合、
<a href=#%E7%89%B9%E6%A8%A9%E6%98%87%E6%A0%BC%E3%81%AE%E9%98%B2%E6%AD%A2%E3%81%A8%E3%83%96%E3%83%BC%E3%83%88%E3%82%B9%E3%83%88%E3%83%A9%E3%83%83%E3%83%97>特権エスカレーション防止とブートストラップ</a>
を参照し、これらの制限がどのようにいつかの変更を防止するのかを理解しましょう。
</div>
<h3 id=roleとclusterrole>RoleとClusterRole</h3>
<p>RBACの <em>Role</em> または <em>ClusterRole</em> には、一連の権限を表すルールが含まれて言います。
権限は完全な追加方式です(「deny」のルールはありません)。</p>
<p>Roleは常に特定の<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>で権限を設定します。
つまり、Roleを作成する時は、Roleが属するNamespaceを指定する必要があります。</p>
<p>対照的にClusterRoleは、Namespaceに属さないリソースです。Kubernetesオブジェクトは常にNamespaceに属するか、属さないかのいずれかである必要があり、リソースは異なる名前(RoleとClusterRole)を持っています。つまり、両方であることは不可能です。</p>
<p>ClusterRolesにはいくつかの用途があります。ClusterRoleを利用して、以下のことができます。</p>
<ol>
<li>Namespaceに属するリソースに対する権限を定義し、個々のNamespace内で付与する</li>
<li>Namespaceに属するリソースに対する権限を定義し、すべてのNamespaceにわたって付与する</li>
<li>クラスター単位でスコープされているリソースに対するアクセス許可を定義する</li>
</ol>
<p>NamespaceでRoleを定義する場合は、Roleを使用します。クラスター全体でRoleを定義する場合は、ClusterRoleを使用します</p>
<h4 id=roleの例>Roleの例</h4>
<p>以下はNamespace「default」にあるRoleの例で、
<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>への読み取りアクセス権の付与に使用できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-reader<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#34;&#34; はコアのAPIグループを示します</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><h4 id=clusterroleの例>ClusterRoleの例</h4>
<p>ClusterRoleを使用してRoleと同じ権限を付与できます。
ClusterRolesはクラスター単位でスコープされているため、以下へのアクセスの許可もできます。</p>
<ul>
<li>クラスター単位でスコープされているリソースに(<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=node>node</a>など)</li>
<li>非リソースエンドポイントに(<code>/healthz</code>など)</li>
<li>すべてのNamespaceに渡ってNamespaceに属するリソースに(Podなど)。
例えば、ClusterRoleを使用して特定のユーザーに<code>kubectl get pods --all-namespaces</code>の実行を許可できます。</li>
</ul>
<p>以下は特定のNamespace、またはすべてのNamespace(<a href=#rolebinding%E3%81%A8clusterrolebinding>バインド</a>方法によります)で<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=secrets>secrets</a>への読み取りアクセス権を付与するClusterRoleの例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 「namespace」はClusterRolesがNamespaceに属していないため、省略されています</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、Secretにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;secrets&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;secrets&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>RoleまたはClusterRoleオブジェクトの名前は有効な
<a href=https://kubernetes.io/ja/docs/concepts/overview/working-with-objects/names/>パスセグメント名</a>である必要があります。</p>
<h3 id=rolebindingとclusterrolebinding>RoleBindingとClusterRoleBinding</h3>
<p>RoleBindingはRoleで定義された権限をユーザーまたはユーザのセットに付与します。
RoleBindingは<em>subjects</em> (ユーザー、グループ、サービスアカウント)のリストと、付与されるRoleへの参照を保持します。
RoleBindingは特定のNamespace内の権限を付与しますが、ClusterRoleBindingはクラスター全体にアクセスする権限を付与します。</p>
<p>RoleBindingは、同じNamespace内の任意のRoleを参照できます。
または、RoleBindingはClusterRoleを参照し、そのClusterRoleをRoleBindingのNamespaceにバインドできます。
ClusterRoleをクラスター内のすべてのNamespaceにバインドする場合は、ClusterRoleBindingを使用します。</p>
<p>RoleBindingまたはClusterRoleBindingオブジェクトは有効な
<a href=https://kubernetes.io/ja/docs/concepts/overview/working-with-objects/names/>パスセグメント名</a>である必要があります。</p>
<h4 id=rolebinding-example>RoleBindingの例</h4>
<p>以下はNamespace「default」内でユーザー「jane」に「pod-reader」のRoleを付与するRoleBindingの例です。
これにより、「jane」にNamespace「default」のポッドの読み取り許可されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># このRoleBindingは「jane」にNamespace「default」のポッドの読み取りを許可する</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># そのNamespaceでRole「pod-reader」を既に持っている必要があります。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-pods<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 一つ以上の「subject」を指定する必要があります</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jane<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 「name」は大文字と小文字が区別されます</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 「roleRef」はRole/ClusterRoleへのバインドを指定します</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb> </span><span style=color:#080;font-style:italic>#RoleまたはClusterRoleである必要があります</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-reader<span style=color:#bbb> </span><span style=color:#080;font-style:italic># これはバインドしたいRole名またはClusterRole名とマッチする必要があります</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p>RoleBindingはClusterRoleを参照し、ClusterRoleで定義されている権限をRoleBinding内のNamespaceのリソースに権限付与もできます。この種類の参照を利用すると、クラスター全体で共通のRoleのセットを定義して、それらを複数のNamespace内での再利用できます。</p>
<p>例えば、以下のRoleBindingがClusterRoleを参照している場合でも、
「dave」(大文字と小文字が区別されるsubject)はRoleBindingのNamespace(メタデータ内)が「development」のため、Namespace「development」のSecretsのみの読み取りができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># このRoleBindingは「dave」にNamespace「development」のSecretsの読み取りを許可する</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># ClusterRole「secret-reader」を既に持っている必要があります。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-secrets<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RoleBindingのNamespaceが、どこの権限が付与されるかを決定する。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># これはNamespace「development」内の権限のみ付与する。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dave<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nameは大文字、小文字を区別する</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><h4 id=clusterrolebindingの例>ClusterRoleBindingの例</h4>
<p>クラスター全体に権限を付与するには、ClusterRoleBindingを使用できます。
以下のClusterRoleBindingはグループ「manager」のすべてのユーザーに
Secretsの読み取りを許可します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># このClusterRoleBindingはグループ「manager」のすべてのユーザーに任意のNamespaceのSecretsの読み取りを許可します。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-secrets-global<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>manager<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nameは大文字、小文字を区別します</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p>Bindingを作成後は、それが参照するRoleまたはClusterRoleを変更できません。
Bindingの<code>roleRef</code>を変更しようとすると、バリデーションエラーが発生します。Bindingの<code>roleRef</code>を変更する場合は、Bindingのオブジェクトを削除して、代わりのオブジェクトを作成する必要があります。</p>
<p>この制限には２つの理由があります。</p>
<ol>
<li><code>roleRef</code>をイミュータブルにすることで、誰かに既存のオブジェクトに対する<code>update</code>権限を付与します。それにより、subjectsに付与されたRoleの変更ができなくても、subjectsのリストを管理できるようになります。</li>
<li>異なるRoleへのBindingは根本的に異なるBindingです。
<code>roleRef</code>を変更するためにBindingの削除/再作成を要求することによって、(すべての既存のsubjectsを確認せずに、roleRefだけを誤って変更できるようにするのとは対照的に)Binding内のsubjectsのリストのすべてが意図された新しいRoleが付与されることを担保します。</li>
</ol>
<p><code>kubectl auth reconcile</code> コマンドラインユーティリティーはRBACオブジェクトを含んだマニフェストファイルを作成または更新します。また、それらが参照しているRoleへの変更を要求されると、Bindingオブジェクトの削除と再作成を取り扱います。
詳細は<a href=#kubectl-auth-reconcile>command usage and examples</a>を確認してください。</p>
<h3 id=リソースを参照する>リソースを参照する</h3>
<p>KubernetesのAPIでは、ほとんどのリソースはPodであれば<code>pods</code>のように、オブジェクト名の文字列表現を使用して表されます。RBACは、関連するAPIエンドポイントのURLに表示されるものとまったく同じ名前を使用するリソースを参照します。
一部のKubernetes APIには、Podのログなどの
<em>subresource</em>　が含まれます。Podのログのリクエストは次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>GET /api/v1/namespaces/{namespace}/pods/{name}/log
</span></code></pre></div><p>この場合、<code>pods</code> はPodリソースのNamespaceに属するリソースであり、<code>log</code>は<code>pods</code>のサブリソースです。これをRBACRoleで表すには、スラッシュ(<code>/</code>)を使用してリソースとサブリソースを区切ります。サブジェクトへの<code>pods</code>の読み込みと各Podの<code>log</code>サブリソースへのアクセスを許可するには、次のように記述します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-and-pod-logs-reader<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods/log&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p><code>resourceNames</code>リストを通じて、特定のリクエストのリソースを名前で参照することもできます。
指定すると、リクエストをリソースの個々のインスタンスに制限できます。
以下は対象を<code>get</code>または<code>my-configmap</code>と名付けられた
<a class=glossary-tooltip title=機密性のないデータをキーと値のペアで保存するために使用されるAPIオブジェクトです。環境変数、コマンドライン引数、またはボリューム内の設定ファイルとして使用できます。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>を<code>update</code>のみに制限する例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-updater<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、ConfigMapにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;configmaps&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;my-configmap&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;get&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>resourceNames</code>で<code>create</code>または<code>deletecollection</code>のリクエストを制限することはできません。この制限は<code>create</code>の場合、認証時にオブジェクト名がわからないためです。
</div>
<h3 id=集約clusterrole>集約ClusterRole</h3>
<p>複数のClusterRoleを一つのClusterRoleに <em>集約</em> できます。
クラスターコントロールプレーンの一部として実行されるコントローラーは、<code>aggregationRule</code>セットを持つClusterRoleオブジェクトを監視します。<code>aggregationRule</code>はコントローラーが、このオブジェクトの<code>rules</code>フィールドに結合する必要のある他のClusterRoleオブジェクトを一致させるために使用するラベル<a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selector>selector</a>を定義します。</p>
<p>以下に、集約されたClusterRoleの例を示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>monitoring<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>aggregationRule</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterRoleSelectors</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>rbac.example.com/aggregate-to-monitoring</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># コントロールプレーンは自動的にルールを入力します</span><span style=color:#bbb>
</span></code></pre></div><p>既存の集約されたClusterRoleのラベルセレクターと一致する新しいClusterRoleを作成すると、その変更をトリガーに、集約されたClusterRoleに新しいルールが追加されます。
<code>rbac.example.com/aggregate-to-monitoring: true</code>ラベルが付けられた別のClusterRoleを作成して、ClusterRole「monitoring」にルールを追加する例を以下に示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>monitoring-endpoints<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.example.com/aggregate-to-monitoring</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># ClusterRole「monitoring-endpoints」を作成すると、</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 以下のルールがClusterRole「monitoring」に追加されます</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;services&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;endpoints&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p><a href=#%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88role%E3%81%A8clusterrolebinding>デフォルトのユーザー向けRole</a>はClusterRoleの集約を使用します。これによりクラスター管理者として、 デフォルトroleを拡張するため、<a class=glossary-tooltip title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle=tooltip data-placement=top href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CustomResourceDefinitions>CustomResourceDefinitions</a>または集約されたAPIサーバーなどによって提供されたルールをカスタムリソースに含めることができます。</p>
<p>例えば、次のClusterRoleでは、「admin」と「edit」のデフォルトのRoleでCronTabという名前のカスタムリソースを管理できますが、「view」のRoleではCronTabリソースに対して読み取りアクションのみを実行できます。CronTabオブジェクトは、APIサーバーから見たURLで<code>"crontabs"</code>と名前が付けられていると想定できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>aggregate-cron-tabs-edit<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># デフォルトRoleの「admin」と「edit」にこれらの権限を追加する。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stable.example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;crontabs&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>aggregate-cron-tabs-view<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># デフォルトRoleの「view」にこれらの権限を追加します。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-view</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stable.example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;crontabs&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><h4 id=roleの例-1>Roleの例</h4>
<p>次の例は、RoleオブジェクトまたはClusterRoleオブジェクトからの抜粋であり、<code>rules</code>セクションのみを示しています。</p>
<p><code>"pods"</code>の読み取りを許可する
<a class=glossary-tooltip title="A set of related paths in the Kubernetes API." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label="API Group">API Group</a>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、Podにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;pods&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>APIグループ<code>" extensions "</code>と <code>" apps "</code> の両方で、Deploymentsへの読み取り/書き込みを許可します。
(HTTPレベルでURLのリソース部分に<code>"deployments"</code>を持つオブジェクトで)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;extensions&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、Deploymentにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;deployments&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>コアAPIグループのPodの読み取り、および<code>"batch"</code>または<code>"extensions"</code>APIグループのJobリソースの読み取りまたは書き込みを許可します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、Podにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;pods&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;batch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;extensions&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、Jobにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;jobs&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;jobs&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>「my-config」という名前のConfigMapの読み取りを許可します(
単一のNamespace内の単一のConfigMapに制限するRoleBinding)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、ConfigMapにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;configmaps&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;my-config&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>コアグループ内のリソース <code>"nodes"</code>の読み取りを許可します(Nodeはクラスタースコープであり、ClusterRoleBindingが効果的であるため、ClusterRoleにバインドされている必要があります)。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、Nodeにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;nodes&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;nodes&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>非リソースエンドポイント <code>/ healthz</code>およびすべてのサブパス(ClusterRoleBindingが効果的であるため、ClusterRoleにバインドされている必要があります)のGETおよびPOSTリクエストを許可します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/healthz&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;/healthz/*&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nonResourceURLの「*」はサフィックスグロブマッチです</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;post&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><h3 id=subjectsを参照する>subjectsを参照する</h3>
<p>RoleBindingまたはClusterRoleBindingは、Roleをsubjectsにバインドします。subjectsはグループ、ユーザー、または<a class=glossary-tooltip title="Provides an identity for processes that run in a Pod." data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=ServiceAccounts>ServiceAccounts</a>にすることができます。</p>
<p>Kubernetesはユーザー名を文字列として表します。
これらは次のようにできます。「alice」などの単純な名前。「bob@example.com」のような電子メール形式の名前。または文字列として表される数値のユーザーID。 認証が必要な形式のユーザー名を生成するように<a href=https://kubernetes.io/ja/docs/reference/access-authn-authz/authentication/>認証モジュール</a>を構成するかどうかは、クラスター管理者が決定します。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> プレフィックス<code>system:</code>はKubernetesシステムで使用するために予約されているため、誤って<code>system:</code>で始まる名前のユーザーまたはグループが存在しないようにする必要があります。
この特別なプレフィックスを除いて、RBAC承認システムでは、ユーザー名の形式は問いません。
</div>
<p>Kubernetesでは、Authenticatorモジュールがグループ情報を提供します。
ユーザーと同様に、グループは文字列として表され、その文字列には、プレフィックス<code>system:</code>が予約されていることを除いて、フォーマット要件はありません。</p>
<p><a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>の名前はプレフィックス<code>system:serviceaccount:</code>が付いており、名前のプレフィックス<code>system:serviceaccounts:</code>が付いているグループに属しています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <ul>
<li><code>system:serviceaccount:</code> (単数)は、サービスアカウントのユーザー名のプレフィックスです。</li>
<li><code>system:serviceaccounts:</code>(複数)は、サービスアカウントグループのプレフィックスです。</li>
</ul>
</div>
<h4 id=role-binding-examples>RoleBindingの例</h4>
<p>次の例は<code>RoleBinding</code>、<code>subjects</code>セクションのみを示す抜粋です。</p>
<p><code>alice@example.com</code>という名前のユーザーの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;alice@example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p><code>frontend-admins</code>という名前のグループの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;frontend-admins&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p>Namespace「kube-system」のデフォルトのサービスアカウントの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></code></pre></div><p>Namespace「qa」の全てのサービスアカウントの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts:qa<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p>任意のNamespaceの全てのサービスアカウントの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p>すべての認証済みユーザーの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p>認証されていないすべてのユーザーの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:unauthenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p>すべてのユーザーの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:unauthenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><h2 id=デフォルトroleとclusterrolebinding>デフォルトRoleとClusterRoleBinding</h2>
<p>APIサーバーは、デフォルトのClusterRoleオブジェクトとClusterRoleBindingオブジェクトのセットを作成します。
これらの多くにはプレフィックス<code>system:</code>が付いています。これは、リソースがクラスターコントロールプレーンによって直接管理されることを示しています。
デフォルトのすべてのClusterRoleおよびClusterRoleBindingには、ラベル<code>kubernetes.io/bootstrapping=rbac-defaults</code>が付いています。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> プレフィックスとして<code>system:</code>を含む名前で、ClusterRolesおよびClusterRoleBindingsを変更する場合は注意してください。
これらのリソースを変更すると、クラスターが機能しなくなる可能性があります。
</div>
<h3 id=自動調整>自動調整</h3>
<p>起動するたびに、APIサーバーはデフォルトのClusterRoleを不足している権限で更新し、
デフォルトのClusterRoleBindingを不足しているsubjectsで更新します。
これにより、誤った変更をクラスタが修復できるようになり、新しいKubernetesリリースで権限とsubjectsが変更されても、
RoleとRoleBindingを最新の状態に保つことができます。</p>
<p>この調整を無効化するには<code>rbac.authorization.kubernetes.io/autoupdate</code>をデフォルトのClusterRoleまたはRoleBindingのアノテーションを<code>false</code>に設定します。
デフォルトの権限と subjectsがないと、クラスターが機能しなくなる可能性があることに注意してください。</p>
<p>RBAC authorizerが有効な場合、自動調整はデフォルトで有効になっています。</p>
<h3 id=discovery-roles>APIディスカバリーRole</h3>
<p>デフォルトのRoleBindingでは、認証されていないユーザーと認証されたユーザーが、パブリックアクセスが安全であると見なされるAPI情報(CustomResourceDefinitionを含む)の読み取りを認可しています。匿名の非認証アクセスを無効にするには、APIサーバー構成に<code>--anonymous-auth=false</code> 追加します。</p>
<p><code>kubectl</code>の実行によってこれらのRoleの構成を表示するには。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get clusterroles system:discovery -o yaml
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ClusterRoleを編集すると、変更が<a href=#%E8%87%AA%E5%8B%95%E8%AA%BF%E6%95%B4>自動調整</a>によるAPIサーバーの再起動時に上書きされます。この上書きを回避するにはRoleを手動で編集しないか、自動調整を無効にします。
</div>
<table>
<caption>Kubernetes RBAC APIディスカバリーRole</caption>
<col width=25%><col width=25%><col>
<tr>
<th>デフォルトのClusterRole</th>
<th>デフォルトのClusterRoleBinding</th>
<th>説明</th>
</tr>
<tr>
<td><b>system:basic-user</b></td>
<td><b>system:authenticated</b> group</td>
<td>ユーザーに、自身に関する基本情報への読み取り専用アクセスを許可します。v1.14より前は、このRoleはデフォルトで<tt>system:unauthenticated</tt>にもバインドされていました。</td>
</tr>
<tr>
<td><b>system:discovery</b></td>
<td><b>system:authenticated</b> group</td>
<td>APIレベルのディスカバリーとネゴシエーションに必要なAPIディスカバリーエンドポイントへの読み取り専用アクセスを許可します。v1.14より前は、このRoleはデフォルトで<tt>system:unauthenticated</tt>にもバインドされていました。</td>
</tr>
<tr>
<td><b>system:public-info-viewer</b></td>
<td><b>system:authenticated</b> and <b>system:unauthenticated</b> groups</td>
<td>クラスターに関する機密情報以外への読み取り専用アクセスを許可します。Kubernetes v1.14で導入されました。</td>
</tr>
</table>
<h3 id=ユーザー向けrole>ユーザー向けRole</h3>
<p>一部のデフォルトClusterRolesにはプレフィックス<code>system:</code>が付いていません。これらは、ユーザー向けのroleを想定しています。それらは、スーパーユーザのRole(<code>cluster-admin</code>)、ClusterRoleBindingsを使用してクラスタ全体に付与されることを意図しているRole、そしてRoleBindings(<code>admin</code>, <code>edit</code>, <code>view</code>)を使用して、特定のNamespace内に付与されることを意図しているRoleを含んでいます。</p>
<p>ユーザー向けのClusterRolesは<a href=#%E9%9B%86%E7%B4%84clusterrole>ClusterRoleの集約</a>を使用して、管理者がこれらのClusterRolesにカスタムリソースのルールを含めることができるようにします。ルールを<code>admin</code>、<code>edit</code>、または<code>view</code> Roleに追加するには、次のラベルの一つ以上でClusterRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-view</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></code></pre></div><table>
<col width=25%><col width=25%><col>
<tr>
<th>デフォルトのClusterRole</th>
<th>デフォルトのClusterRoleBinding</th>
<th>説明</th>
</tr>
<tr>
<td><b>cluster-admin</b></td>
<td><b>system:masters</b> group</td>
<td>スーパーユーザーが任意のリソースで任意のアクションを実行できるようにします。
<b>ClusterRoleBinding</b>で使用すると、クラスター内およびすべてのNamespace内のすべてのリソースを完全に制御できます。
<b>RoleBinding</b>で使用すると、Namespace自体を含む、RoleBindingのNamespace内のすべてのリソースを完全に制御できます。</td>
</tr>
<tr>
<td><b>admin</b></td>
<td>None</td>
<td><b>RoleBinding</b>を使用してNamespace内で付与することを想定した、管理者アクセスを許可します。
<b>RoleBinding</b>で使用した場合、Namespace内にRoleとRoleBindingを作成する機能を含め、Namespaceのほとんどのリソースへの読み取り/書き込みアクセスを許可します。
このRoleは、リソースクォータまたはNamespace自体への書き込みアクセスを許可しません。</td>
</tr>
<tr>
<td><b>edit</b></td>
<td>None</td>
<td>Namespace内のほとんどのオブジェクトへの読み取り/書き込みアクセスを許可します。
<p>このRoleは、RoleまたはRoleBindingの表示または変更を許可しません。
ただし、このRoleでは、Secretsにアクセスして、Namespace内の任意のServiceAccountとしてPodsを実行できるため、Namespace内の任意のServiceAccountのAPIアクセスレベルを取得するために使用できます。</td></p>
</tr>
<tr>
<td><b>view</b></td>
<td>None</td>
<td>Namespace内のほとんどのオブジェクトを表示するための読み取り専用アクセスを許可します。
RoleまたはRoleBindingは表示できません。
<p>Secretsの内容を読み取るとNamespaceのServiceAccountのクレデンシャルにアクセスできるため、このRoleではSecretsの表示は許可されません。これにより、Namespace内の任意のServiceAccountとしてAPIアクセスが許可されます(特権昇格の形式)。</td></p>
</tr>
</table>
<h3 id=コアコンポーネントのrole>コアコンポーネントのRole</h3>
<table>
<col width=25%><col width=25%><col>
<tr>
<th>デフォルトのClusterRole</th>
<th>デフォルトのClusterRoleBinding</th>
<th>説明</th>
</tr>
<tr>
<td><b>system:kube-scheduler</b></td>
<td><b>system:kube-scheduler</b> user</td>
<td><a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=scheduler>scheduler</a>コンポーネントが必要とするリソースへのアクセスを許可します。</td>
</tr>
<tr>
<td><b>system:volume-scheduler</b></td>
<td><b>system:kube-scheduler</b> user</td>
<td>kube-scheduleコンポーネントが必要とするリソースへのアクセスを許可します。</td>
</tr>
<tr>
<td><b>system:kube-controller-manager</b></td>
<td><b>system:kube-controller-manager</b> user</td>
<td><a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label="controller manager">controller manager</a>コンポーネントが必要とするリソースへのアクセスを許可します。
個々のコントローラーに必要な権限については、<a href=#controller-roles>組み込みコントローラーのRoleで詳しく説明しています</a>。</td>
</tr>
<tr>
<td><b>system:node</b></td>
<td>None</td>
<td><b>すべてのsecretへの読み取りアクセス、すべてのポッドステータスオブジェクトへの書き込みアクセスなど、</b>kubeletが必要とするリソースへのアクセスを許可します。
<p><tt>system:node</tt>Roleの代わりに<a href=/docs/reference/access-authn-authz/node/>Node authorizer</a>と <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a>を使用し、それらで実行するようにスケジュールされたPodに基づいてkubeletへのAPIアクセスを許可する必要があります。</p>
<p><tt>system:node</tt>のRoleは、V1.8より前のバージョンからアップグレードしたKubernetesクラスターとの互換性のためだけに存在します。</p>
</td>
</tr>
<tr>
<td><b>system:node-proxier</b></td>
<td><b>system:kube-proxy</b> user</td>
<td><a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>コンポーネントが必要とするリソースへのアクセスを許可します。</td>
</tr>
</table>
<h3 id=他のコンポーネントのrole>他のコンポーネントのRole</h3>
<table>
<col width=25%><col width=25%><col>
<tr>
<th>デフォルトのClusterRole</th>
<th>デフォルトのClusterRoleBinding</th>
<th>説明</th>
</tr>
<tr>
<td><b>system:auth-delegator</b></td>
<td>None</td>
<td>委任された認証と認可のチェックを許可します。
これは一般に、認証と認可を統合するためにアドオンAPIサーバーで使用されます。</td>
</tr>
<tr>
<td><b>system:heapster</b></td>
<td>None</td>
<td><a href=https://github.com/kubernetes/heapster>Heapster</a>コンポーネントのRole(非推奨)。</td>
</tr>
<tr>
<td><b>system:kube-aggregator</b></td>
<td>None</td>
<td><a href=https://github.com/kubernetes/kube-aggregator>kube-aggregator</a>コンポーネントのRole。</td>
</tr>
<tr>
<td><b>system:kube-dns</b></td>
<td><b><b>kube-system</b>Namespaceのサービスアカウントkube-dns</b></td>
<td><a href=/ja/docs/concepts/services-networking/dns-pod-service/>kube-dns</a>コンポーネントのRole。</td>
</tr>
<tr>
<td><b>system:kubelet-api-admin</b></td>
<td>None</td>
<td>kubelet APIへのフルアクセスを許可します。</td>
</tr>
<tr>
<td><b>system:node-bootstrapper</b></td>
<td>None</td>
<td><a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLS bootstrapping</a>の実行に必要なリソースへのアクセスを許可します。</td>
</tr>
<tr>
<td><b>system:node-problem-detector</b></td>
<td>None</td>
<td><a href=https://github.com/kubernetes/node-problem-detector>node-problem-detector</a>コンポーネントのRole。</td>
</tr>
<tr>
<td><b>system:persistent-volume-provisioner</b></td>
<td>None</td>
<td>ほとんどの<a href=/ja/docs/concepts/storage/persistent-volumes/#dynamic>dynamic volume provisioners</a>が必要とするリソースへのアクセスを許可します。</td>
</tr>
</table>
<h3 id=controller-roles>組み込みコントローラーのRole</h3>
<p>Kubernetes <a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label="controller manager">controller manager</a>は、Kubernetesコントロールプレーンに組み込まれている<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a>を実行します。
<code>--use-service-account-credentials</code>を指定して呼び出すと、kube-controller-manager個別のサービスアカウントを使用して各コントローラーを起動します。
組み込みコントローラーごとに、プレフィックス<code>system:controller:</code>付きの対応するRoleが存在します。
コントローラーマネージャーが<code>--use-service-account-credentials</code>で開始されていない場合、コントローラマネージャーは、関連するすべてのRoleを付与する必要がある自身のクレデンシャルを使用して、すべてのコントロールループを実行します。
これらのRoleは次のとおりです。</p>
<ul>
<li><code>system:controller:attachdetach-controller</code></li>
<li><code>system:controller:certificate-controller</code></li>
<li><code>system:controller:clusterrole-aggregation-controller</code></li>
<li><code>system:controller:cronjob-controller</code></li>
<li><code>system:controller:daemon-set-controller</code></li>
<li><code>system:controller:deployment-controller</code></li>
<li><code>system:controller:disruption-controller</code></li>
<li><code>system:controller:endpoint-controller</code></li>
<li><code>system:controller:expand-controller</code></li>
<li><code>system:controller:generic-garbage-collector</code></li>
<li><code>system:controller:horizontal-pod-autoscaler</code></li>
<li><code>system:controller:job-controller</code></li>
<li><code>system:controller:namespace-controller</code></li>
<li><code>system:controller:node-controller</code></li>
<li><code>system:controller:persistent-volume-binder</code></li>
<li><code>system:controller:pod-garbage-collector</code></li>
<li><code>system:controller:pv-protection-controller</code></li>
<li><code>system:controller:pvc-protection-controller</code></li>
<li><code>system:controller:replicaset-controller</code></li>
<li><code>system:controller:replication-controller</code></li>
<li><code>system:controller:resourcequota-controller</code></li>
<li><code>system:controller:root-ca-cert-publisher</code></li>
<li><code>system:controller:route-controller</code></li>
<li><code>system:controller:service-account-controller</code></li>
<li><code>system:controller:service-controller</code></li>
<li><code>system:controller:statefulset-controller</code></li>
<li><code>system:controller:ttl-controller</code></li>
</ul>
<h2 id=特権昇格の防止とブートストラップ>特権昇格の防止とブートストラップ</h2>
<p>RBAC APIは、RoleまたはRoleBindingを編集することにより、ユーザーが特権を昇格するのを防ぎます。
これはAPIレベルで適用されるため、RBAC authorizerが使用されていない場合でも適用されます。</p>
<h3 id=roleの作成または更新に関する制限>Roleの作成または更新に関する制限</h3>
<p>次の項目1つ以上が当てはまる場合にのみ、Roleを作成/更新できます。</p>
<ol>
<li>変更対象のオブジェクトと同じスコープで、Roleに含まれるすべての権限を既に持っている(ClusterRoleの場合はクラスター全体。Roleの場合は、同じNamespace内またはクラスター全体)。</li>
<li><code>rbac.authorization.k8s.io</code>APIグループの<code> roles</code>または<code>clusterroles</code>リソースで<code> escalate</code> verbを実行する明示的な権限が付与されている。</li>
</ol>
<p>たとえば、 <code>user-1</code>にクラスター全体でSecretsを一覧表示する権限がない場合、それらにその権限を含むClusterRoleを作成できません。
ユーザーがRoleを作成/更新できるようにするには、以下のいずれかを実施します。</p>
<ol>
<li>必要に応じて、RoleオブジェクトまたはClusterRoleオブジェクトを作成/更新できるRoleを付与する。</li>
<li>作成/更新するRoleに特定の権限を含む権限を付与する。
<ul>
<li>暗黙的に、これらの権限を付与することにより(自分自身が付与されていない権限でRoleまたはClusterRoleを作成または変更しようとすると、APIリクエストは禁止されます)。</li>
<li>または、<code>rbac.authorization.k8s.io</code>APIグループの<code> roles</code>または <code>clusterroles</code>リソースで<code> escalate</code> verbを実行する権限を与えることにより、 <code>Role</code>または<code> ClusterRole</code>で権限を指定することを明示的に許可する</li>
</ul>
</li>
</ol>
<h3 id=rolebindingの作成または更新に関する制限>RoleBindingの作成または更新に関する制限</h3>
<p>参照されるRoleに含まれるすべての権限を(RoleBindingと同じスコープで)すでに持っている場合、
<em>または</em>参照されたRoleで<code>bind</code> verbを実行する認可されている場合のみ、RoleBindingを作成/更新できます。
たとえば、 <code>user-1</code>にクラスター全体でSecretsを一覧表示する権限がない場合、ClusterRoleBindingを作成してもRoleにその権限を付与できません。
ユーザーがRoleBindingを作成/更新できるようにするには、以下のいずれかを実施します。</p>
<ol>
<li>必要に応じて、RoleBindingまたはClusterRoleBindingオブジェクトを作成/更新できるようにする役割を付与する。</li>
<li>特定の役割をバインドするために必要なアクセス許可を付与する。
<ul>
<li>暗黙的に、Roleに含まれる権限を付与することによって。</li>
<li>明示的に、特定のRole(またはClusterRole)で <code>bind</code> verbを実行する許可を与えることによって。</li>
</ul>
</li>
</ol>
<p>たとえば、このClusterRoleとRoleBindingを使用すると、 <code>user-1</code>は他のユーザーにNamespace<code> user-1-namespace</code>の <code>admin</code>、<code> edit</code>、および <code>view</code>Roleを付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rbac.authorization.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rolebindings&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;create&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rbac.authorization.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;clusterroles&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;bind&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;admin&#34;</span>,<span style=color:#b44>&#34;edit&#34;</span>,<span style=color:#b44>&#34;view&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor-binding<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>user-1-namespace<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>user-1<span style=color:#bbb>
</span></code></pre></div><p>最初のRoleとRoleBindingをブートストラップするときは、最初のユーザーがまだ持っていない権限を付与する必要があります。
初期RoleとRoleBindingをブートストラップするには、以下のいずれかを実施します。</p>
<ul>
<li>「system：masters」グループのクレデンシャルを使用します。このグループは、デフォルトのBindingによって「cluster-admin」スーパーユーザーRoleにバインドされています。</li>
<li>APIサーバーが安全でないポート(<code>--insecure-port</code>)を有効にして実行されている場合、そのポートを介してのAPI呼び出しもできます。これにより、認証や認可が実行されません。</li>
</ul>
<h2 id=コマンドラインユーティリティー>コマンドラインユーティリティー</h2>
<h3 id=kubectl-create-role><code>kubectl create role</code></h3>
<p>以下に、単一のNamespace内で権限を定義するRoleオブジェクトをいくつか例として作成します。</p>
<ul>
<li>
<p>ユーザーがポッドで <code>get</code>、<code> watch</code>、および <code>list</code>を実行できるように「pod-reader」という名前のRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role pod-reader --verb<span style=color:#666>=</span>get --verb<span style=color:#666>=</span>list --verb<span style=color:#666>=</span>watch --resource<span style=color:#666>=</span>pods
</code></pre></div></li>
<li>
<p>resourceNamesを指定して、「pod-reader」という名前のRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role pod-reader --verb<span style=color:#666>=</span>get --resource<span style=color:#666>=</span>pods --resource-name<span style=color:#666>=</span>readablepod --resource-name<span style=color:#666>=</span>anotherpod
</code></pre></div></li>
<li>
<p>apiGroupsを指定して「foo」という名前のRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>replicasets.apps
</code></pre></div></li>
<li>
<p>サブリソースの権限を持つ「foo」という名前のRoleを作成します。</p>
</li>
<li>
<p>Create a Role named "foo" with subresource permissions:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods,pods/status
</code></pre></div></li>
<li>
<p>特定の名前のリソースを取得/更新する権限を持つ「my-component-lease-holder」という名前のRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role my-component-lease-holder --verb<span style=color:#666>=</span>get,list,watch,update --resource<span style=color:#666>=</span>lease --resource-name<span style=color:#666>=</span>my-component
</code></pre></div></li>
</ul>
<h3 id=kubectl-create-clusterrole><code>kubectl create clusterrole</code></h3>
<p>以下にClusterRoleをいくつか例として作成します。</p>
<ul>
<li>
<p>ユーザーがポッドに対して<code>get</code>、<code> watch</code>、および <code>list</code>を実行できるようにする「pod-reader」という名前のClusterRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole pod-reader --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods
</code></pre></div></li>
<li>
<p>resourceNamesを指定して、「pod-reader」という名前のClusterRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole pod-reader --verb<span style=color:#666>=</span>get --resource<span style=color:#666>=</span>pods --resource-name<span style=color:#666>=</span>readablepod --resource-name<span style=color:#666>=</span>anotherpod
</code></pre></div></li>
<li>
<p>apiGroupsを指定して「foo」という名前のClusterRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>replicasets.apps
</code></pre></div></li>
<li>
<p>サブリソースの権限を持つ「foo」という名前のClusterRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods,pods/status
</code></pre></div></li>
<li>
<p>nonResourceURLを指定して「foo」という名前のClusterRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole <span style=color:#b44>&#34;foo&#34;</span> --verb<span style=color:#666>=</span>get --non-resource-url<span style=color:#666>=</span>/logs/*
</code></pre></div></li>
<li>
<p>aggregationRuleを指定して、「monitoring」という名前のClusterRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole monitoring --aggregation-rule<span style=color:#666>=</span><span style=color:#b44>&#34;rbac.example.com/aggregate-to-monitoring=true&#34;</span>
</code></pre></div></li>
</ul>
<h3 id=kubectl-create-rolebinding><code>kubectl create rolebinding</code></h3>
<p>以下に、特定のNamespace内でRoleまたはClusterRoleをいくつか例として付与します。</p>
<ul>
<li>
<p>Namespace「acme」内で、「admin」ClusterRoleの権限を「bob」という名前のユーザーに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding bob-admin-binding --clusterrole<span style=color:#666>=</span>admin --user<span style=color:#666>=</span>bob --namespace<span style=color:#666>=</span>acme
</code></pre></div></li>
<li>
<p>Namespace「acme」内で、ClusterRole「view」へのアクセス許可を「myapp」というNamespace「acme」のサービスアカウントに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>acme:myapp --namespace<span style=color:#666>=</span>acme
</code></pre></div></li>
<li>
<p>Namespace「acme」内で、ClusterRole「view」へのアクセス許可を「myapp」というNamespace「myappnamespace」のサービスアカウントに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding myappnamespace-myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>myappnamespace:myapp --namespace<span style=color:#666>=</span>acme
</code></pre></div></li>
</ul>
<h3 id=kubectl-create-clusterrolebinding><code>kubectl create clusterrolebinding</code></h3>
<p>以下に、クラスタ全体(すべてのNamespace)にClusterRoleをいくつか例として付与します。</p>
<ul>
<li>
<p>クラスター全体で、ClusterRole「cluster-admin」へのアクセス許可を「root」という名前のユーザーに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole<span style=color:#666>=</span>cluster-admin --user<span style=color:#666>=</span>root
</code></pre></div></li>
<li>
<p>クラスター全体で、ClusterRole「system：node-proxier」へのアクセス許可を「system：kube-proxy」という名前のユーザーに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding kube-proxy-binding --clusterrole<span style=color:#666>=</span>system:node-proxier --user<span style=color:#666>=</span>system:kube-proxy
</code></pre></div></li>
<li>
<p>クラスター全体で、ClusterRole「view」へのアクセス許可を、Namespace「acme」の「myapp」という名前のサービスアカウントに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>acme:myapp
</code></pre></div></li>
</ul>
<h3 id=kubectl-auth-reconcile><code>kubectl auth reconcile</code></h3>
<p>マニフェストファイルから <code>rbac.authorization.k8s.io/v1</code>APIオブジェクトを作成または更新します。</p>
<p>欠落しているオブジェクトが作成され、必要に応じて、Namespaceに属するオブジェクト用にオブジェクトを含むNamespaceが作成されます。</p>
<p>既存のRoleが更新され、入力オブジェクトに権限が含まれるようになります。
<code>--remove-extra-permissions</code>が指定されている場合は、余分な権限を削除します。</p>
<p>既存のBindingが更新され、入力オブジェクトにsubjectsが含まれるようになります。
<code>--remove-extra-subjects</code>が指定されている場合は、余分な件名を削除します。</p>
<p>以下、例として。</p>
<ul>
<li>
<p>RBACオブジェクトのマニフェストファイルをテストとして適用し、行われる変更を表示します。</p>
<pre><code>kubectl auth reconcile -f my-rbac-rules.yaml --dry-run=client
</code></pre></li>
<li>
<p>RBACオブジェクトのマニフェストファイルを適用し、(Role内の)追加のアクセス許可と(Binding内の)追加のsubjectsを保持します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl auth reconcile -f my-rbac-rules.yaml
</code></pre></div></li>
<li>
<p>RBACオブジェクトのマニフェストファイルを適用し、(Role内の)余分なアクセス許可と(Binding内の)余分なsubjectsを削除します。</p>
</li>
</ul>
<h2 id=service-account-permissions>ServiceAccount権限</h2>
<p>デフォルトのRBACポリシーは、コントロールプレーンコンポーネント、ノード、
およびコントローラーをスコープとして権限を付与しますが、 Namespace<code>kube-system</code>外のサービスアカウントには<em>no permissions</em>で付与します
(すべての認証されたユーザーに与えられたディスカバリー権限に関わらず)。</p>
<p>これにより、必要に応じて特定のServiceAccountに特定のRoleを付与できます。
きめ細かいRoleBindingはセキュリティを強化しますが、管理にはより多くの労力が必要です。
より広範な権限は、不必要な(そして潜在的にエスカレートする)APIアクセスをServiceAccountsに与える可能性がありますが、管理が簡単です。</p>
<p>アプローチを最も安全なものから最も安全でないものの順に並べると、次のとおりです。</p>
<ol>
<li>
<p>アプリケーション固有のサービスアカウントにRoleを付与する(ベストプラクティス)
これには、アプリケーションがpodのspec、そして作成するサービスアカウント(API、アプリケーションマニフェスト、 <code>kubectl create serviceaccount</code>などを介して）で<code>serviceAccountName</code>を指定する必要があります。
たとえば、「my-namespace」内の読み取り専用権限を「my-sa」サービスアカウントに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding my-sa-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>my-namespace:my-sa <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</code></pre></div></li>
<li>
<p>あるNamespaceのサービスアカウント「default」にRoleを付与します</p>
<p>アプリケーションが <code>serviceAccountName</code>を指定しない場合、サービスアカウント「default」を使用します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> サービスアカウント「default」に付与された権限は、<code>serviceAccountName</code>を指定しないNamespace内のすべてのポッドで利用できます。
</div>
<p>たとえば、「my-namespace」内の読み取り専用権限をサービスアカウント「default」に付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding default-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>my-namespace:default <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</code></pre></div><p>多くの<a href=/ja/docs/concepts/cluster-administration/addons/>アドオン</a>は、
Namespace<code>kube-system</code>のサービスアカウント「default」として実行されます。
これらのアドオンをスーパーユーザーアクセスでの実行を許可するには、Namespace<code>kube-system</code>のサービスアカウント「default」のcluster-admin権限を付与します。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> これを有効にすると、 Namespace`kube-systemにクラスターのAPIへのスーパーユーザーアクセス許可するSecretsが含まれます。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding add-on-cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>kube-system:default
</code></pre></div></li>
<li>
<p>Namespace内のすべてのサービスアカウントにRoleを付与します</p>
<p>Namespace内のすべてのアプリケーションにRoleを持たせたい場合は、使用するサービスアカウントに関係なく、
そのNamespaceのサービスアカウントグループにRoleを付与できます。</p>
<p>たとえば、「my-namespace」内の読み取り専用アクセス許可を、そのNamespace内のすべてのサービスアカウントに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding serviceaccounts-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts:my-namespace <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</code></pre></div></li>
<li>
<p>クラスター全体のすべてのサービスアカウントに制限されたRoleを付与します(お勧めしません)</p>
<p>Namespaceごとのアクセス許可を管理したくない場合は、すべてのサービスアカウントにクラスター全体の役割を付与できます。</p>
<p>たとえば、クラスター内のすべてのサービスアカウントに、すべてのNamespaceで読み取り専用のアクセス許可を付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding serviceaccounts-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span> --group<span style=color:#666>=</span>system:serviceaccounts
</code></pre></div></li>
<li>
<p>クラスター全体のすべてのサービスアカウントへのスーパーユーザーアクセスを許可します。(強くお勧めしません)</p>
<p>権限の分割をまったく考慮しない場合は、すべてのサービスアカウントにスーパーユーザーアクセスを許可できます。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> これにより、すべてのアプリケーションにクラスターへのフルアクセスが許可され、Secretsの読み取りアクセス権(または任意のポッドを作成する機能)を持つユーザーに、クラスターへのフルアクセスが許可されます。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding serviceaccounts-cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</code></pre></div></li>
</ol>
<h2 id=abacからアップグレードする>ABACからアップグレードする</h2>
<p>以前は古いバージョンのKubernetesを実行していたクラスターは、すべてのサービスアカウントに完全なAPIアクセスを許可するなど、permissiveなABACポリシーを使用することがよくありました。</p>
<p>デフォルトのRBACポリシーは、コントロールプレーンコンポーネント、ノード、
およびコントローラーをスコープとして権限を付与しますが、 Namespace<code>kube-system</code>外のサービスアカウントには<em>no permissions</em>で付与します
(すべての認証されたユーザーに与えられたディスカバリー権限に関わらず)。</p>
<p>これははるかに安全ですが、API権限を自動的に受け取ることを期待している既存のワークロードを混乱させる可能性があります。
この移行を管理するための2つのアプローチは次のとおりです。</p>
<h3 id=並行認可>並行認可</h3>
<p>RBACとABACの両方のauthorizerを実行し、<a href=/docs/reference/access-authn-authz/abac/#policy-file-format>legacy ABAC policy</a>を含むポリシーファイルを指定します。</p>
<pre><code>--authorization-mode=...,RBAC,ABAC --authorization-policy-file=mypolicy.json
</code></pre><p>最初のコマンドラインオプションを詳細に説明すると、Nodeなどの以前のauthorizerが
要求を拒否すると、RBAC authorizerはAPI要求を認可しようとします。 RBACの場合
また、そのAPI要求を拒否すると、ABAC authorizerが実行されます。これにより、すべてのリクエストが
RBACまたはABACポリシーの<em>いずれか</em>で許可されます。</p>
<p>RBACコンポーネントのログレベルが5以上でkube-apiserverを実行した場合(<code>--vmodule = rbac * = 5</code>または<code> --v = 5</code>)、APIサーバーログでRBACの拒否を確認できます(プレフィックスは「RBAC」)。
その情報を使用して、どのRoleをどのユーザー、グループ、またはサービスアカウントに付与する必要があるかを判断できます。</p>
<p><a href=#service-account-permissions>サービスアカウントに付与されたRole</a>を取得し、
ワークロードがサーバーログにRBACの拒否メッセージがない状態で実行されている場合は、ABAC authorizerを削除できます。</p>
<h3 id=permissive-rbac権限>Permissive RBAC権限</h3>
<p>RBACRoleBindingを使用して、permissive ABACポリシーを複製できます。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> <p>次のポリシーでは、<strong>すべて</strong>のサービスアカウントがクラスター管理者としてふるまうことを許可しています。
コンテナで実行されているアプリケーションは、サービスアカウントのクレデンシャルを自動的に受け取ります。
secretsの表示や権限の変更など、APIに対して任意のアクションを実行できます。
これは推奨されるポリシーではありません。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding permissive-binding <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --user<span style=color:#666>=</span>admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --user<span style=color:#666>=</span>kubelet <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</code></pre></div>
</div>
<p>RBACの使用に移行後、クラスターが情報セキュリティのニーズを確実に満たすように、アクセスコントロールを調整する必要があります。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4f002b9458521ca7afd32176fd590646>6.7 - ツール</h1>
<p>Kubernetesには、Kubernetesシステムの操作に役立ついくつかの組み込みツールが含まれています。</p>
<h2 id=kubectl>Kubectl</h2>
<p><a href=/docs/tasks/tools/install-kubectl/><code>kubectl</code></a>は、Kubernetesのためのコマンドラインツールです。このコマンドはKubernetes cluster managerを操作します。</p>
<h2 id=kubeadm>Kubeadm</h2>
<p><a href=docs/setup/production-environment/tools/kubeadm/install-kubeadm/><code>kubeadm</code></a>は、物理サーバやクラウドサーバ、仮想マシン上にKubernetesクラスタを容易にプロビジョニングするためのコマンドラインツールです(現在はアルファ版です)。</p>
<h2 id=minikube>Minikube</h2>
<p><a href=https://minikube.sigs.k8s.io/docs/><code>minikube</code></a>は、開発やテストのためにワークステーション上でシングルノードのKubernetesクラスタをローカルで実行するツールです。</p>
<h2 id=dashboard>Dashboard</h2>
<p><a href=/docs/tasks/access-application-cluster/web-ui-dashboard/><code>Dashboard</code></a>は、KubernetesのWebベースのユーザインタフェースで、コンテナ化されたアプリケーションをKubernetesクラスタにデプロイしたり、トラブルシューティングしたり、クラスタとそのリソース自体を管理したりすることが出来ます。</p>
<h2 id=helm>Helm</h2>
<p><a href=https://github.com/helm/helm><code>Kubernetes Helm</code></a>は、事前に設定されたKubernetesリソースのパッケージ、別名Kubernetes chartsを管理するためのツールです。</p>
<p>Helmを用いて以下のことを行います。</p>
<ul>
<li>
<p>Kubernetes chartsとしてパッケージ化された人気のあるソフトウェアの検索と利用</p>
</li>
<li>
<p>Kubernetes chartsとして所有するアプリケーションを共有すること</p>
</li>
<li>
<p>Kubernetesアプリケーションの再現性のあるビルドの作成</p>
</li>
<li>
<p>Kubernetesマニフェストファイルを知的な方法で管理</p>
</li>
<li>
<p>Helmパッケージのリリース管理</p>
</li>
</ul>
<h2 id=kompose>Kompose</h2>
<p><a href=https://github.com/kubernetes/kompose><code>Kompose</code></a>は、Docker ComposeユーザがKubernetesに移行する手助けをするツールです。</p>
<p>Komposeを用いて以下のことを行います。</p>
<ul>
<li>
<p>Docker ComposeファイルのKubernetesオブジェクトへの変換</p>
</li>
<li>
<p>ローカルのDocker開発からKubernetesを経由したアプリケーション管理への移行</p>
</li>
<li>
<p>v1またはv2のDocker Compose用 <code>yaml</code> ファイルならびに<a href=https://docs.docker.com/compose/bundles/>分散されたアプリケーションバンドル</a>の変換</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4985cb55ddfb184639d767ec54b9f0f7>7 - K8sのドキュメントに貢献する</h1>
<p><em>Kubernetesは初心者でも経験者でも、全てのコントリビューターからの改善を歓迎しています！</em></p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Kubernetesへの貢献について総合的に知りたい場合は、<a href=https://www.kubernetes.dev/docs/>contributor documentation</a>を参照してください。
</div>
<p>このウェブサイトは<a href=/docs/contribute/#get-involved-with-sig-docs>Kubernetes SIG Docs</a>が管理しています。</p>
<p>Kubernetesドキュメントコントリビューターは</p>
<ul>
<li>既存のコンテンツを改善します</li>
<li>新しいコンテンツを作成します</li>
<li>ドキュメントを翻訳します</li>
<li>Kubernetesリリースサイクルの一部としてドキュメントを管理・公開します</li>
</ul>
<h2 id=はじめに>はじめに</h2>
<p>どなたでも、問題を説明するissueや、ドキュメントの改善を求めるissueを作成し、<a href=https://github.com/kubernetes/website><code>kubernetes/website</code> GitHub リポジトリ</a>に対するプルリクエスト(PR)を用いて変更に貢献することができます。
Kubernetesコミュニティで効果的に働くためには、<a href=https://git-scm.com/>git</a>と<a href=https://lab.github.com/>GitHub</a>を基本的に使いこなせる必要があります。</p>
<p>ドキュメンテーションに関わるには:</p>
<ol>
<li>CNCFの<a href=https://github.com/kubernetes/community/blob/master/CLA.md>Contributor License Agreement</a>にサインしてください。</li>
<li><a href=https://github.com/kubernetes/website>ドキュメンテーションのリポジトリー</a>と、ウェブサイトの<a href=https://gohugo.io>静的サイトジェネレーター</a>に慣れ親しんでください。</li>
<li><a href=/docs/contribute/new-content/open-a-pr/>プルリクエストのオープン</a>と<a href=/docs/contribute/review/reviewing-prs/>変更レビュー</a>の基本的なプロセスを理解していることを確認してください。</li>
</ol>
<p>一部のタスクでは、Kubernetes organizationで、より多くの信頼とアクセス権限が必要です。
役割と権限についての詳細は、<a href=/docs/contribute/participating/>SIG Docsへの参加</a>を参照してください。</p>
<h2 id=はじめての貢献>はじめての貢献</h2>
<ul>
<li>貢献のための複数の方法について学ぶために<a href=/docs/contribute/new-content/overview/>貢献の概要</a>を読んでください。</li>
<li>良い開始地点を探すために<a href=https://github.com/kubernetes/website/issues/><code>kubernetes/website</code> issueリスト</a>を確認してください。</li>
<li>既存のドキュメントに対して<a href=/docs/contribute/new-content/open-a-pr/#changes-using-github>GitHubを使ってプルリクエストをオープン</a>し、GitHubへのissueの登録について学んでください。</li>
<li>正確さと言語の校正のため、他のKubernetesコミュニティメンバーから<a href=/docs/contribute/review/reviewing-prs/>プルリクエストのレビュー</a>を受けてください。</li>
<li>見識のあるコメントを残せるようにするため、Kubernetesの<a href=/docs/contribute/style/content-guide/>コンテンツ</a>と<a href=/docs/contribute/style/style-guide/>スタイルガイド</a>を読んでください。</li>
<li><a href=/docs/contribute/style/page-content-types/>ページコンテンツの種類</a>と<a href=/docs/contribute/style/hugo-shortcodes/>Hugoショートコード</a>について勉強してください。</li>
</ul>
<h2 id=次のステップ>次のステップ</h2>
<ul>
<li>リポジトリの<a href=/docs/contribute/new-content/open-a-pr/#fork-the-repo>ローカルクローンでの作業</a>について学んでください。</li>
<li><a href=/docs/contribute/new-content/new-features/>リリース機能</a>について記載してください。</li>
<li><a href=/docs/contribute/participate/>SIG Docs</a>に参加し、<a href=/docs/contribute/participate/roles-and-responsibilities/>memberやreviewer</a>になってください。</li>
<li><a href=/docs/contribute/localization/>国際化</a>を始めたり、支援したりしてください。</li>
</ul>
<h2 id=sig-docsに参加する>SIG Docsに参加する</h2>
<p><a href=/docs/contribute/participate/>SIG Docs</a>はKubernetesのドキュメントとウェブサイトを公開・管理するコントリビューターのグループです。SIG Docsに参加することはKubernetesコントリビューター（機能開発でもそれ以外でも）にとってKubernetesプロジェクトに大きな影響を与える素晴らしい方法の一つです。</p>
<p>SIG Docsは複数の方法でコミュニケーションをとっています。</p>
<ul>
<li><a href=https://slack.k8s.io/>Kubernetes Slackインスタンスの<code>#sig-docs</code>に参加してください</a>。自己紹介を忘れずに！</li>
<li><a href=https://groups.google.com/forum/#!forum/kubernetes-sig-docs><code>kubernetes-sig-docs</code>メーリングリストに参加してください</a>。ここでは幅広い議論が起こり、公式な決定が記録されます。</li>
<li><a href=https://github.com/kubernetes/community/tree/master/sig-docs>毎週のSIG Docsビデオミーティング</a>に参加してください。ミーティングは <code>#sig-docs</code>でアナウンスされ、<a href="https://calendar.google.com/calendar/embed?src=cgnt364vd8s86hr2phapfjc6uk%40group.calendar.google.com&ctz=America/Los_Angeles">Kubernetesコミュニティミーティングカレンダー</a>に追加されます。<a href=https://zoom.us/download>Zoomクライアント</a>をダウンロードするか、電話を使って通話する必要があります。</li>
</ul>
<h2 id=その他の貢献方法>その他の貢献方法</h2>
<ul>
<li><a href=/community/>Kubernetesコミュニティサイト</a>を訪問してください。TwitterやStack Overflowに参加したり、Kubernetesの集会やイベントについて学んだりしてください。</li>
<li>機能開発に貢献したい方は、まずはじめに<a href=https://github.com/kubernetes/community/tree/master/contributors/guide/contributor-cheatsheet>Kubernetesコントリビューターチートシート</a>を読んでください。</li>
<li><a href=/docs/contribute/new-content/blogs-case-studies/>ブログ記事やケーススタディ</a>を投稿してください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e5340359b8afe1fe409af06178af8886>7.1 - コンテンツの改善を提案する</h1>
<p>Kubernetesのドキュメントに何か問題を見つけたり、新しいコンテンツに関してアイデアを思い付いたときは、issueを作ってください。必要なものは、<a href=https://github.com/join>GitHubアカウント</a>とウェブブラウザーだけです。</p>
<p>Kubernetesのドキュメント上の新しい作業は、ほとんどの場合、GitHubのissueから始まります。Kubernetesのコントリビューターは、必要に応じてレビュー、分類、タグ付けを行います。次に、あなたやKubernetesコミュニティの他のメンバーが、そのissueを解決するための変更を加えるpull requestを開きます。</p>
<h2 id=issueを作る>issueを作る</h2>
<p>既存のコンテンツに対して改善を提案したい場合や、間違いを発見した場合は、issueを作ってください。</p>
<ol>
<li>ページの右側のサイドバーにある<strong>ドキュメントのissueを作成</strong>ボタンをクリックします。GitHubのissueページにリダイレクトし、一部のヘッダーが自動的に挿入されます。</li>
<li>問題や改善の提案について書きます。できる限り多くの詳細情報を提供するようにしてください。</li>
<li><strong>Submit new issue</strong>ボタンをクリックします。</li>
</ol>
<p>送信後、定期的にissueを確認するか、GitHubの通知を設定してください。レビュアや他のコミュニティメンバーが、issueに対して作業を行うために、あなたに何か質問をするかもしれません。</p>
<h2 id=新しいコンテンツの提案>新しいコンテンツの提案</h2>
<p>新しいコンテンツに関するアイデアがあるものの、どの場所に追加すればわからないときでも、issueを作ることができます。次のいずれかを選択して行ってください。</p>
<ul>
<li>コンテンツが追加されるべきだと思う既存のページを選択し、<strong>ドキュメントのissueを作成</strong>ボタンをクリックする。</li>
<li><a href=https://github.com/kubernetes/website/issues/new/>GitHub</a>に移動し、直接issueを作る。</li>
</ul>
<h2 id=よいissueを作るには>よいissueを作るには</h2>
<p>issueを作るときは、以下のことを心に留めてください。</p>
<ul>
<li>明確なissueの説明を書く。不足している点、古くなっている点、誤っている点、改善が必要な点など、どの点がそうであるか明確に書く。</li>
<li>issueがユーザーに与える具体的な影響を説明する。</li>
<li>合理的な作業単位になるように、特定のissueのスコープを制限する。スコープの大きな問題については、小さな複数のissueに分割する。たとえば、"Fix the security docs"(セキュリティのドキュメントを修正する)というのはスコープが大きすぎますが、"Add details to the 'Restricting network access' topic"(トピック「ネットワークアクセスの制限」に詳細情報を追加する)であれば十分に作業可能な大きさです。</li>
<li>すでにあるissueを検索し、関連または同様のissueがないかどうか確認する。</li>
<li>新しいissueがほかのissueやpull requestと関係する場合は、完全なURLを参照するか、issueやpull requestの数字の前に<code>#</code>の文字を付けて参照する。例えば、<code>Introduced by #987654</code>のように書きます。</li>
<li><a href=/ja/community/code-of-conduct/>行動規範</a>に従って、仲間のコントリビューターに敬意を払いましょう。たとえば、"The docs are terrible"(このドキュメントは最悪だ)のようなコメントは、役に立つ敬意のあるフィードバックではありません。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e937703be4ed0c81ebac5c90d296644f>7.2 - 新しいコンテンツの貢献</h1>
</div>
<div class=td-content>
<h1 id=pg-15909b651921a0531bcfb705012b0d3e>7.2.1 - 新しいコンテンツの貢献の概要</h1>
<p>このセクションでは、新しいコンテンツの貢献を行う前に知っておくべき情報を説明します。</p>
<h2 id=貢献の基本>貢献の基本</h2>
<ul>
<li>KubernetesのドキュメントはMarkdownで書き、Kubernetesのウェブサイトは<a href=https://gohugo.io/>Hugo</a>を使ってビルドします。</li>
<li>ソースは<a href=https://github.com/kubernetes/website>GitHub</a>にあります。Kubernetesのドキュメントは<code>/content/en/docs/</code>にあります。リファレンスドキュメントの一部は、<code>update-imported-docs/</code>ディレクトリ内のスクリプトから自動的に生成されます。</li>
<li><a href=/docs/contribute/style/page-content-types/>Page content types</a>にHugoによるドキュメントのコンテンツの見え方を記述しています。</li>
<li>標準のHugoのshortcodeに加えて、多数の<a href=/docs/contribute/style/hugo-shortcodes/>カスタムのHugo shortcode</a>を使用してコンテンツの見え方をコントロールしています。</li>
<li>ドキュメントのソースは<code>/content/</code>内にある複数の言語で利用できます。各言語はそれぞれ<a href=https://www.loc.gov/standards/iso639-2/php/code_list.php>ISO 639-1標準</a>で定義された2文字のコードの名前のフォルダを持ちます。たとえば、英語のドキュメントのソースは<code>/content/en/docs/</code>内に置かれています。</li>
<li>複数言語でのドキュメントへの貢献や新しい翻訳の開始に関する情報については、<a href=/docs/contribute/localization>Kubernetesのドキュメントを翻訳する</a>を参照してください。</li>
</ul>
<h2 id=before-you-begin>始める前に</h2>
<h3 id=sign-the-cla>CNCF CLAに署名する</h3>
<p>すべてのKubernetesのコントリビューターは、<a href=https://github.com/kubernetes/community/blob/master/contributors/guide/README.md>コントリビューターガイド</a>を読み、<a href=https://github.com/kubernetes/community/blob/master/CLA.md>Contributor License Agreement(コントリビューターライセンス契約、CLA)への署名</a>を<strong>必ず行わなければなりません</strong>。</p>
<p>CLAへの署名が完了していないコントリビューターからのpull requestは、自動化されたテストで失敗します。名前とメールアドレスは<code>git config</code>コマンドで表示されるものに一致し、gitの名前とメールアドレスはCNCF CLAで使われたものに一致しなければなりません。</p>
<h3 id=どのgitブランチを使用するかを選ぶ>どのGitブランチを使用するかを選ぶ</h3>
<p>pull requestをオープンするときは、どのブランチをベースにして作業するかをあらかじめ知っておく必要があります。</p>
<table>
<thead>
<tr>
<th style=text-align:left>シナリオ</th>
<th style=text-align:left>ブランチ</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>現在のリリースに対する既存または新しい英語のコンテンツ</td>
<td style=text-align:left><code>master</code></td>
</tr>
<tr>
<td style=text-align:left>機能変更のリリースに対するコンテンツ</td>
<td style=text-align:left>機能変更が含まれるメジャーおよびマイナーバージョンに対応する、<code>dev-&lt;version></code>というパターンのブランチを使います。たとえば、機能変更が<code>v1.27</code>に含まれる場合、ドキュメントの変更は<code>dev-1.27</code>ブランチに追加します。</td>
</tr>
<tr>
<td style=text-align:left>他の言語内のコンテンツ(翻訳)</td>
<td style=text-align:left>各翻訳対象の言語のルールに従います。詳しい情報は、<a href=/docs/contribute/localization/#branching-strategy>翻訳のブランチ戦略</a>を読んでください。</td>
</tr>
</tbody>
</table>
<p>それでも選ぶべきブランチがわからないときは、Slack上の<code>#sig-docs</code>チャンネルで質問してください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> すでにpull requestを作成していて、ベースブランチが間違っていたことに気づいた場合は、作成者であるあなただけがベースブランチを変更できます。
</div>
<h3 id=言語ごとのpr>言語ごとのPR</h3>
<p>pull requestはPRごとに1つの言語に限定してください。複数の言語に同一の変更を行う必要がある場合は、言語ごとに別々のPRを作成してください。</p>
<h2 id=コントリビューターのためのツール>コントリビューターのためのツール</h2>
<p><code>kubernetes/website</code>リポジトリ内の<a href=https://github.com/kubernetes/website/tree/master/content/en/docs/doc-contributor-tools>doc contributors tools</a>ディレクトリには、コントリビューターとしての旅を楽にしてくれるツールがあります。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7667825f238ad55850e95e02d21e9772>7.3 - 変更のレビュー</h1>
<p>このセクションでは、コンテンツのレビュー方法について説明します。</p>
</div>
<div class=td-content>
<h1 id=pg-bf4cdc925c4f306d4dc42184255aab58>7.3.1 - プルリクエストのレビュー</h1>
<p>ドキュメントのプルリクエストは誰でもレビューすることができます。Kubernetesのwebsiteリポジトリで<a href=https://github.com/kubernetes/website/pulls>pull requests</a>のセクションに移動し、open状態のプルリクエストを確認してください。</p>
<p>ドキュメントのプルリクエストのレビューは、Kubernetesコミュニティに自分を知ってもらうためのよい方法の1つです。コードベースについて学んだり、他のコントリビューターとの信頼関係を築く助けともなるはずです。</p>
<p>レビューを行う前には、以下のことを理解しておくとよいでしょう。</p>
<ul>
<li><a href=/docs/contribute/style/content-guide/>コンテンツガイド</a>と<a href=/docs/contribute/style/style-guide/>スタイルガイド</a>を読んで、有益なコメントを残せるようにする。</li>
<li>Kubernetesのドキュメントコミュニティにおける<a href=/docs/contribute/participate/roles-and-responsibilities/>役割と責任</a>の違いを理解する。</li>
</ul>
<h2 id=はじめる前に>はじめる前に</h2>
<p>レビューを始める前に、以下のことを心に留めてください。</p>
<ul>
<li><a href=https://github.com/cncf/foundation/blob/master/code-of-conduct.md>CNCFの行動規範</a>を読み、いかなる時にも行動規範にしたがって行動するようにする。</li>
<li>礼儀正しく、思いやりを持ち、助け合う気持ちを持つ。</li>
<li>変更点だけでなく、PRのポジティブな側面についてもコメントする。</li>
<li>相手の気持ちに共感して、自分のレビューが相手にどのように受け取られるのかをよく意識する。</li>
<li>相手の善意を前提として、疑問点を明確にする質問をする。</li>
<li>経験を積んだコントリビューターの場合、コンテンツに大幅な変更が必要な新規のコントリビューターとペアを組んで作業に取り組むことを考える。</li>
</ul>
<h2 id=レビューのプロセス>レビューのプロセス</h2>
<p>一般に、コンテンツや文体に対するプルリクエストは、英語でレビューを行います。</p>
<ol>
<li>
<p><a href=https://github.com/kubernetes/website/pulls>https://github.com/kubernetes/website/pulls</a>に移動します。Kubernetesのウェブサイトとドキュメントに対するopen状態のプルリクエスト一覧が表示されます。</p>
</li>
<li>
<p>open状態のPRに、以下に示すラベルを1つ以上使って絞り込みます。</p>
<ul>
<li><code>cncf-cla: yes</code> (推奨): CLAにサインしていないコントリビューターが提出したPRはマージできません。詳しい情報は、<a href=/docs/contribute/new-content/overview/#sign-the-cla>CLAの署名</a>を読んでください。</li>
<li><code>language/en</code> (推奨): 英語のPRだけに絞り込みます。</li>
<li><code>size/&lt;size></code>: 特定の大きさのPRだけに絞り込みます。レビューを始めたばかりの人は、小さなPRから始めてください。</li>
</ul>
<p>さらに、PRがwork in progressとしてマークされていないことも確認してください。<code>work in progress</code>ラベルの付いたPRは、まだレビューの準備ができていない状態です。</p>
</li>
<li>
<p>レビューするPRを選んだら、以下のことを行い、変更点について理解します。</p>
<ul>
<li>PRの説明を読み、行われた変更について理解し、関連するissueがあればそれも読みます。</li>
<li>他のレビュアのコメントがあれば読みます。</li>
<li><strong>Files changed</strong>タブをクリックし、変更されたファイルと行を確認します。</li>
<li><strong>Conversation</strong>タブの下にあるPRのbuild checkセクションまでスクロールし、<strong>deploy/netlify</strong>の行の<strong>Details</strong>リンクをクリックして、Netlifyのプレビュービルドで変更点をプレビューします。</li>
</ul>
</li>
<li>
<p><strong>Files changed</strong>タブに移動してレビューを始めます。</p>
<ol>
<li>コメントしたい場合は行の横の<code>+</code>マークをクリックします。</li>
<li>その行に関するコメントを書き、<strong>Add single comment</strong>(1つのコメントだけを残したい場合)または<strong>Start a review</strong>(複数のコメントを行いたい場合)のいずれかをクリックします。</li>
<li>コメントをすべて書いたら、ページ上部の<strong>Review changes</strong>をクリックします。ここでは、レビューの要約を追加できます(コントリビューターにポジティブなコメントも書きましょう！)。必要に応じて、PRを承認したり、コメントしたり、変更をリクエストします。新しいコントリビューターの場合は<strong>Comment</strong>だけが行えます。</li>
</ol>
</li>
</ol>
<h2 id=レビューのチェックリスト>レビューのチェックリスト</h2>
<p>レビューするときは、最初に以下の点を確認してみてください。</p>
<h3 id=言語と文法>言語と文法</h3>
<ul>
<li>言語や文法に明らかな間違いはないですか？ もっとよい言い方はないですか？</li>
<li>もっと簡単な単語に置き換えられる複雑な単語や古い単語はありませんか？</li>
<li>使われている単語や専門用語や言い回しで差別的ではない別の言葉に置き換えられるものはありませんか？</li>
<li>言葉選びや大文字の使い方は<a href=/docs/contribute/style/style-guide/>style guide</a>に従っていますか？</li>
<li>もっと短くしたり単純な文に書き換えられる長い文はありませんか？</li>
<li>箇条書きやテーブルでもっとわかりやすく表現できる長いパラグラフはありませんか？</li>
</ul>
<h3 id=コンテンツ>コンテンツ</h3>
<ul>
<li>同様のコンテンツがKubernetesのサイト上のどこかに存在しませんか？</li>
<li>コンテンツが外部サイト、特定のベンダー、オープンソースではないドキュメントなどに過剰にリンクを張っていませんか？</li>
</ul>
<h3 id=ウェブサイト>ウェブサイト</h3>
<ul>
<li>PRはページ名、slug/alias、アンカーリンクの変更や削除をしていますか？ その場合、このPRの変更の結果、リンク切れは発生しませんか？ ページ名を変更してslugはそのままにするなど、他の選択肢はありませんか？</li>
<li>PRは新しいページを作成するものですか？ その場合、次の点に注意してください。
<ul>
<li>ページは正しい<a href=/docs/contribute/style/page-content-types/>page content type</a>と関係するHugoのshortcodeを使用していますか？</li>
<li>セクションの横のナビゲーション(または全体)にページは正しく表示されますか？</li>
<li>ページは<a href=/docs/home/>Docs Home</a>に一覧されますか？</li>
</ul>
</li>
<li>Netlifyのプレビューで変更は確認できますか？ 特にリスト、コードブロック、テーブル、備考、画像などに注意してください。</li>
</ul>
<h3 id=その他>その他</h3>
<p>PRに関して誤字や空白などの小さな問題を指摘する場合は、コメントの前に<code>nit:</code>と書いてください。こうすることで、PRの作者は問題が深刻なものではないことが分かります。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5f7b891275b826a0a9dc82836542a607>7.3.2 - approverとreviewer向けのレビュー</h1>
<p>SIG Docsの<a href=/docs/contribute/participate/#reviewers>Reviewer(レビュアー)</a>と<a href=/docs/contribute/participate/#approvers>Approver(承認者)</a>は、変更をレビューする時にいくつか追加の作業を行います。</p>
<p>毎週、docsのメンバーの特定のapproverのボランティアは、pull requestのトリアージとレビューを担当します。この担当者は、その週の「PR Wrangler(PRの世話人)」と呼ばれます。詳しい情報は、<a href=https://github.com/kubernetes/website/wiki/PR-Wranglers>PR Wrangler scheduler</a>を参照してください。PR Wranglerになるには、週次のSIG Docsミーティングに参加し、ボランティアをします。もしその週にスケジュールされていなくても、活発なレビューが行われていないpull request(PR)をレビューすることは問題ありません。</p>
<p>このローテーションに加えて、変更されたファイルのオーナーに基づいて、botがPRにreviewerとapproverを割り当てます。</p>
<h2 id=prをレビューする>PRをレビューする</h2>
<p>Kubernetesのドキュメントは<a href=https://github.com/kubernetes/community/blob/master/contributors/guide/owners.md#the-code-review-process>Kubernetesコードレビュープロセス</a>に従います。</p>
<p><a href=/ja/docs/contribute/review/reviewing-prs/>pull requestのレビュー</a>に書かれているすべてのことが適用されますが、ReviewerとApproverはそれに加えて次のことも行います。</p>
<ul>
<li>
<p>必要に応じて、<code>/assign</code>Prowコマンドを使用して、特定のreviewerにPRを割り当てる。これは、コードのコントリビューターからの技術的なレビューが必要な場合には特に重要です。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 技術的なレビューを行える人物を知るには、Markdownファイル上部にあるfront-matterの<code>reviewers</code>フィールドを確認してください。
</div>
</li>
<li>
<p>PRが<a href=/ja/docs/contribute/style/content-guide/>コンテンツ</a>および<a href=/docs/contribute/style/style-guide/>スタイル</a>のガイドに従っていることを確認してください。ガイドに従っていない場合は、ガイドの関連する部分にリンクを作者に示してください。</p>
</li>
<li>
<p>PRの作者に変更を提案できるときは、GitHubの<strong>Request Changes</strong>(変更をリクエスト)オプションを利用してください。</p>
</li>
<li>
<p>提案したことが反映されたら、<code>/approve</code>や<code>/lgtm</code>コマンドを使用して、GitHubのレビューステータスを変更してください。</p>
</li>
</ul>
<h2 id=他の作者のprにコミットを追加する>他の作者のPRにコミットを追加する</h2>
<p>PRにコメントを残すのは助けになりますが、まれに他の作者のPRに代わりにコミットを追加する必要がある場合があります。</p>
<p>あなたが明示的に作者から頼まれたり、長い間放置されたPRを蘇らせるような場合でない限り、他の作者のPRを「乗っ取る」ようなことはしないでください。短期的に見ればそのほうが短時間で終わるかもしれませんが、そのようなことをするとその人が貢献するチャンスを奪ってしまうことになります。</p>
<p>あなたが取る方法は、編集する必要のあるファイルがすでにPRのスコープに入っているか、あるいはPRがまだ触れていないファイルであるかによって変わります。</p>
<p>以下のいずれかが当てはまる場合、他の作者のPRにあなたがコミットを追加することはできません。</p>
<ul>
<li>
<p>PRの作者が自分のブランチを直接<a href=https://github.com/kubernetes/website/>https://github.com/kubernetes/website/</a>リポジトリにpushした場合。この場合、pushアクセス権限を持つreviewerしか他のユーザーのPRにコミットを追加することはできません。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 次回PRを作成するとき、自分のブランチを自分のforkに対してpushするように作者に促してください。
</div>
</li>
<li>
<p>PRの作者が明示的にapproverからの編集を禁止している場合。</p>
</li>
</ul>
<h2 id=レビュー向けのprowコマンド>レビュー向けのProwコマンド</h2>
<p><a href=https://github.com/kubernetes/test-infra/blob/master/prow/README.md>Prow</a>は、pull request(PR)に対してジョブを実行するKubernetesベースのCI/CDシステムです。Prowは、Kubernetes organization全体でchatbotスタイルのコマンドを利用してGitHub actionsを扱えるようにします。たとえば、<a href=#adding-and-removing-issue-labels>ラベルの追加と削除</a>、issueのclose、approverの割り当てなどが行なえます。Prowコマンドは、GitHubのコメントに<code>/&lt;command-name></code>という形式で入力します。</p>
<p>reviewerとapproverが最もよく使うprowコマンドには、以下のようなものがあります。</p>
<table><caption style=display:none>Prow commands for reviewing</caption>
<thead>
<tr>
<th style=text-align:left>Prowコマンド</th>
<th style=text-align:left>Roleの制限</th>
<th style=text-align:left>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left><code>/lgtm</code></td>
<td style=text-align:left>誰でも。ただし、オートメーションがトリガされるのはReviewerまたはApproverが使用したときのみ。</td>
<td style=text-align:left>PRのレビューが完了し、変更に納得したことを知らせる。</td>
</tr>
<tr>
<td style=text-align:left><code>/approve</code></td>
<td style=text-align:left>Approver</td>
<td style=text-align:left>PRをマージすることを承認する。</td>
</tr>
<tr>
<td style=text-align:left><code>/assign</code></td>
<td style=text-align:left>ReviewerまたはApprover</td>
<td style=text-align:left>PRのレビューまたは承認するひとを割り当てる。</td>
</tr>
<tr>
<td style=text-align:left><code>/close</code></td>
<td style=text-align:left>ReviewerまたはApprover</td>
<td style=text-align:left>issueまたはPRをcloseする。</td>
</tr>
<tr>
<td style=text-align:left><code>/hold</code></td>
<td style=text-align:left>誰でも</td>
<td style=text-align:left><code>do-not-merge/hold</code>ラベルを追加して、自動的にマージできないPRであることを示す。</td>
</tr>
<tr>
<td style=text-align:left><code>/hold cancel</code></td>
<td style=text-align:left>誰でも</td>
<td style=text-align:left><code>do-not-merge/hold</code>ラベルを削除する。</td>
</tr>
</tbody>
</table>
<p>PRで利用できるすべてのコマンド一覧を確認するには、<a href=https://prow.k8s.io/command-help>Prowコマンドリファレンス</a>を参照してください。</p>
<h2 id=issueのトリアージとカテゴリー分類>issueのトリアージとカテゴリー分類</h2>
<p>一般に、SIG Docsは<a href=https://github.com/kubernetes/community/blob/master/contributors/guide/issue-triage.md>Kubernetes issue triage</a>のプロセスに従い、同じラベルを使用しています。</p>
<p>このGitHub issueの<a href="https://github.com/kubernetes/website/issues?q=is%3Aissue+is%3Aopen+-label%3Apriority%2Fbacklog+-label%3Apriority%2Fimportant-longterm+-label%3Apriority%2Fimportant-soon+-label%3Atriage%2Fneeds-information+-label%3Atriage%2Fsupport+sort%3Acreated-asc">フィルター</a>は、トリアージが必要な可能性があるissueを表示します。</p>
<h3 id=issueをトリアージする>issueをトリアージする</h3>
<ol>
<li>issueを検証する</li>
</ol>
<ul>
<li>issueがドキュメントのウェブサイトに関係するものであることを確かめる。質問に答えたりリソースの場所を報告者に教えることですぐに閉じられるissueもあります。詳しくは、<a href=#support-requests-or-code-bug-reports>サポートリクエストまたはコードのバグレポート</a>のセクションを読んでください。</li>
<li>issueにメリットがあるかどうか評価する。</li>
<li>issueに行動を取るのに十分な詳細情報がない場合や、テンプレートが十分埋められていない場合は、<code>triage/needs-information</code>ラベルを追加する。</li>
<li><code>lifecycle/stale</code>と<code>triage/needs-information</code>の両方のラベルがあるときは、issueをcloseする。</li>
</ul>
<ol start=2>
<li>優先度(priority)ラベルを追加する(<a href=https://github.com/kubernetes/community/blob/master/contributors/guide/issue-triage.md#define-priority>issueトリアージガイドライン</a>は、priorityラベルについて詳しく定義しています。)</li>
</ol>
<table><caption style=display:none>issueのラベル</caption>
<thead>
<tr>
<th style=text-align:left>ラベル</th>
<th style=text-align:left>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left><code>priority/critical-urgent</code></td>
<td style=text-align:left>今すぐに作業する。</td>
</tr>
<tr>
<td style=text-align:left><code>priority/important-soon</code></td>
<td style=text-align:left>3ヶ月以内に取り組む。</td>
</tr>
<tr>
<td style=text-align:left><code>priority/important-longterm</code></td>
<td style=text-align:left>6ヶ月以内に取り組む。</td>
</tr>
<tr>
<td style=text-align:left><code>priority/backlog</code></td>
<td style=text-align:left>無期限に延期可能。リソースに余裕がある時に取り組む。</td>
</tr>
<tr>
<td style=text-align:left><code>priority/awaiting-more-evidence</code></td>
<td style=text-align:left>よいissueの可能性があるissueを見失わないようにするためのプレースホルダー。</td>
</tr>
<tr>
<td style=text-align:left><code>help</code>または<code>good first issue</code></td>
<td style=text-align:left>KubernetesまたはSIG Docsでほとんど経験がない人に適したissue。より詳しい情報は、<a href=https://github.com/kubernetes/community/blob/master/contributors/guide/help-wanted.md>Help WantedとGood First Issueラベル</a>を読んでください。</td>
</tr>
</tbody>
</table>
<p>あなたの裁量で、issueのオーナーシップを取り、issueに対するPRを提出してください(簡単なissueや、自分がすでに行った作業に関連するissueである場合は特に)。</p>
<p>issueのトリアージについて質問があるときは、Slackの<code>#sig-docs</code>か<a href=https://groups.google.com/forum/#!forum/kubernetes-sig-docs>kubernetes-sig-docs mailing list</a>で質問してください。</p>
<h2 id=adding-and-removing-issue-labels>issueラベルの追加と削除</h2>
<p>ラベルを追加するには、以下のいずれかの形式でコメントします。</p>
<ul>
<li><code>/&lt;label-to-add></code>(たとえば、<code>/good-first-issue</code>)</li>
<li><code>/&lt;label-category> &lt;label-to-add></code>(たとえば、<code>/triage needs-information</code>や<code>/language ja</code>)</li>
</ul>
<p>ラベルを削除するには、以下のいずれかの形式でコメントします。</p>
<ul>
<li><code>/remove-&lt;label-to-remove></code>(たとえば、<code>/remove-help</code>)</li>
<li><code>/remove-&lt;label-category> &lt;label-to-remove></code>(たとえば、<code>/remove-triage needs-information</code>)</li>
</ul>
<p>いずれの場合でも、ラベルは既存のものでなければなりません。存在しないラベルを追加しようとした場合、コマンドは無視されます。</p>
<p>すべてのラベル一覧は、<a href=https://github.com/kubernetes/website/labels>websiteリポジトリーのラベルセクション</a>で確認できます。SIG Docsですべてのラベルが使われているわけではありません。</p>
<h3 id=issueのライフサイクルに関するラベル>issueのライフサイクルに関するラベル</h3>
<p>issueは一般にopen後に短期間でcloseされます。しかし、issueがopenされた後にアクティブでなくなったり、issueが90日以上openのままである場合もあります。</p>
<table><caption style=display:none>issueのライブラリに関するラベル</caption>
<thead>
<tr>
<th style=text-align:left>ラベル</th>
<th style=text-align:left>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left><code>lifecycle/stale</code></td>
<td style=text-align:left>90日間活動がない場合、issueは自動的にstaleとラベル付けされます。<code>/remove-lifecycle stale</code>コマンドを使って手動でlifecycleをリバートしない限り、issueは自動的にcloseされます。</td>
</tr>
<tr>
<td style=text-align:left><code>lifecycle/frozen</code></td>
<td style=text-align:left>このラベルが付けられたissueは、90日間活動がなくてもstaleになりません。<code>priority/important-longterm</code>ラベルを付けたissueなど、90日以上openにしておく必要があるissueには、このラベルを手動で追加します。</td>
</tr>
</tbody>
</table>
<h2 id=特別な種類のissueに対処する>特別な種類のissueに対処する</h2>
<p>SIG Docsでは、対処方法をドキュメントに書いても良いくらい頻繁に、以下のような種類のissueに出会います。</p>
<h3 id=重服したissue>重服したissue</h3>
<p>1つの問題に対して1つ以上のissueがopenしている場合、1つのissueに統合します。あなたはどちらのissueをopenにしておくか(あるいは新しいissueを作成するか)を決断して、すべての関連する情報を移動し、関連するすべてのissueにリンクしなければなりません。最後に、同じ問題について書かれたすべての他のissueに<code>triage/duplicate</code>ラベルを付けて、それらをcloseします。作業対象のissueを1つだけにすることで、混乱を減らし、同じ問題に対して作業が重複することを避けられます。</p>
<h3 id=リンク切れに関するissue>リンク切れに関するissue</h3>
<p>リンク切れのissueがAPIまたは<code>kubectl</code>のドキュメントにあるものは、問題が完全に理解されるまでは<code>/priority critical-urgent</code>を割り当ててください。その他のすべてのリンク切れに関するissueには、手動で修正が必要であるため、<code>/priority important-longterm</code>を付けます。</p>
<h3 id=blogに関するissue>Blogに関するissue</h3>
<p><a href=https://kubernetes.io/blog/>Kubernetes Blog</a>のエントリーは時間が経つと情報が古くなるものだと考えています。そのため、ブログのエントリーは1年以内のものだけをメンテナンスします。1年以上前のブログエントリーに関するissueは修正せずにcloseします。</p>
<h3 id=support-requests-or-code-bug-reports>サポートリクエストまたはコードのバグレポート</h3>
<p>一部のドキュメントのissueは、実際には元になっているコードの問題や、何か(たとえば、チュートリアル)がうまく動かないときにサポートをリクエストするものです。ドキュメントに関係のない問題は、<code>kind/support</code>ラベルを付け、サポートチャンネル(SlackやStack Overflowなど)へ報告者を導くコメントをして、もし関連があれば機能のバグに対するissueを報告するリポジトリ(<code>kubernetes/kubernetes</code>は始めるのに最適な場所です)を教えて、closeします。</p>
<p>サポートリクエストに対する返答の例を示します。(リクエストを行う際は英語で行うことが想定されるため、英文とその日本語訳を記載しています)</p>
<pre><code class=language-none data-lang=none>This issue sounds more like a request for support and less
like an issue specifically for docs. I encourage you to bring
your question to the `#kubernetes-users` channel in
[Kubernetes slack](https://slack.k8s.io/). You can also search
resources like
[Stack Overflow](https://stackoverflow.com/questions/tagged/kubernetes)
for answers to similar questions.

You can also open issues for Kubernetes functionality in
https://github.com/kubernetes/kubernetes.

If this is a documentation issue, please re-open this issue.
</code></pre><pre><code class=language-none data-lang=none>このissueは特定のドキュメントに関するissueではなく、サポートリクエストのようです。
Kubernetesに関する質問については、[Kubernetes slack](https://slack.k8s.io/)の
`#kubernetes-users`チャンネルに投稿することをおすすめします。同様の質問に対する回答を
[Stack Overflow](https://stackoverflow.com/questions/tagged/kubernetes)などの
リソースで検索することもできます。

Kubernetesの機能に関するissueについては、https://github.com/kubernetes/kubernetes
でissueを作成できます。

もしこれがドキュメントに関するissueの場合、このissueを再びopenしてください。
</code></pre><p>コードのバグに対する返答の例を示します。</p>
<pre><code class=language-none data-lang=none>This sounds more like an issue with the code than an issue with
the documentation. Please open an issue at
https://github.com/kubernetes/kubernetes/issues.

If this is a documentation issue, please re-open this issue.
</code></pre><pre><code class=language-none data-lang=none>こちらのissueは、ドキュメントではなくコードに関係するissueのようです。
https://github.com/kubernetes/kubernetes/issues でissueを作成してください。

もしこれがドキュメントに関するissueの場合、このissueを再びopenしてください。
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8b9b22280711800788333c1a4d129735>7.4 - SIG Docsへの参加</h1>
<p>SIG Docsは、Kubernetesプロジェクト内の
<a href=https://github.com/kubernetes/community/blob/master/sig-list.md>special interest groups</a>の1つであり、
Kubernetes全体のドキュメントの作成、更新、および保守に重点を置いています。
SIGの詳細については、<a href=https://github.com/kubernetes/community/blob/master/sig-list.md>SIG DocsのGithubリポジトリ</a>を参照してください。</p>
<p>SIG Docsは、すべての寄稿者からのコンテンツとレビューを歓迎します。
誰でもPull Request(PR)を開くことができ、コンテンツに関するissueを提出したり、進行中のPull Requestにコメントしたりできます。</p>
<p>あなたは、<a href=/docs/contribute/participate/roles-and-responsibilities/#members>member</a>や、
<a href=/docs/contribute/participate/roles-and-responsibilities/#reviewers>reviewer</a>、
<a href=/docs/contribute/participate/roles-and-responsibilities/#approvers>approver</a>になることもできます。
これらの役割にはより多くのアクセスが必要であり、変更を承認およびコミットするための特定の責任が伴います。
Kubernetesコミュニティ内でメンバーシップがどのように機能するかについての詳細は、
<a href=https://github.com/kubernetes/community/blob/master/community-membership.md>community-membership</a>
をご覧ください。</p>
<p>このドキュメントの残りの部分では、kubernetesの中で最も広く公開されている
Kubernetesのウェブサイトとドキュメントの管理を担当しているSIG Docsの中で、これらの役割がどのように機能するのかを概説します。</p>
<h2 id=sig-docs-chairperson>SIG Docs chairperson</h2>
<p>SIG Docsを含む各SIGは、議長として機能する1人以上のSIGメンバーを選択します。
これらは、SIGDocsとKubernetes organizationの他の部分との連絡先です。
それらには、Kubernetesプロジェクト全体の構造と、SIG Docsがその中でどのように機能するかについての広範な知識が必要です。
現在のchairpersonのリストについては、
<a href=https://github.com/kubernetes/community/tree/master/sig-docs#leadership>Leadership</a>
を参照してください。</p>
<h2 id=sig-docs-teamsと自動化>SIG Docs teamsと自動化</h2>
<p>SIG Docsの自動化は、GitHub teamsとOWNERSファイルの2つの異なるメカニズムに依存しています。</p>
<h3 id=github-teams>GitHub teams</h3>
<p>GitHubには、二つのSIG Docs
<a href="https://github.com/orgs/kubernetes/teams?query=sig-docs">teams</a>
カテゴリがあります:</p>
<ul>
<li><code>@sig-docs-{language}-owners</code>は承認者かつリードです。</li>
<li><code>@sig-docs-{language}-reviewers</code> はレビュアーです。</li>
</ul>
<p>それぞれをGitHubコメントの<code>@name</code>で参照して、そのグループの全員とコミュニケーションできます。</p>
<p>ProwチームとGitHub teamsが完全に一致せずに重複する場合があります。
問題の割り当て、Pull Request、およびPR承認のサポートのために、自動化ではOWNERSファイルからの情報を使用します。</p>
<h3 id=ownersファイルとfront-matter>OWNERSファイルとfront-matter</h3>
<p>Kubernetesプロジェクトは、GitHubのissueとPull Requestに関連する自動化のためにprowと呼ばれる自動化ツールを使用します。
<a href=https://github.com/kubernetes/website>Kubernetes Webサイトリポジトリ</a>
は、2つの<a href=https://github.com/kubernetes/test-infra/tree/master/prow/plugins>prowプラグイン</a>を使用します：</p>
<ul>
<li>blunderbuss</li>
<li>approve</li>
</ul>
<p>これらの2つのプラグインは<code>kubernetes.website</code>のGithubリポジトリのトップレベルにある
<a href=https://github.com/kubernetes/website/blob/master/OWNERS>OWNERS</a>ファイルと、
<a href=https://github.com/kubernetes/website/blob/master/OWNERS_ALIASES>OWNERS_ALIASES</a>ファイルを使用して、
リポジトリ内でのprowの動作を制御します。</p>
<p>OWNERSファイルには、SIG Docsのレビュー担当者および承認者であるユーザーのリストが含まれています。
OWNERSファイルはサブディレクトリに存在することもでき、そのサブディレクトリとその子孫のファイルのレビュー担当者または承認者として機能できるユーザーを上書きできます。
一般的なOWNERSファイルの詳細については、
<a href=https://github.com/kubernetes/community/blob/master/contributors/guide/owners.md>OWNERS</a>を参照してください。</p>
<p>さらに、個々のMarkdownファイルは、個々のGitHubユーザー名またはGitHubグループを一覧表示することにより、そのfront-matterでレビュー担当者と承認者を一覧表示できます。</p>
<p>OWNERSファイルとMarkdownファイルのfront-matterの組み合わせにより、PRの技術的および編集上のレビューを誰に依頼するかについてPRの所有者が自動化システムから得るアドバイスが決まります。</p>
<h2 id=マージの仕組み>マージの仕組み</h2>
<p>Pull Requestがコンテンツの公開に使用されるブランチにマージされると、そのコンテンツは <a href=http://kubernetes.io>http://kubernetes.io</a> に公開されます。
公開されたコンテンツの品質を高くするために、Pull RequestのマージはSIG Docsの承認者に限定しています。仕組みは次のとおりです。</p>
<ul>
<li>Pull Requestに<code>lgtm</code>ラベルと<code>approve</code>ラベルの両方があり、<code>hold</code>ラベルがなく、すべてのテストに合格すると、Pull Requestは自動的にマージされます。</li>
<li>Kubernetes organizationのメンバーとSIG Docsの承認者はコメントを追加して、特定のPull Requestが自動的にマージされないようにすることができます(<code>/hold</code>コメントを追加するか、<code>/lgtm</code>コメントを保留します)。</li>
<li>Kubernetesメンバーは誰でも、<code>/lgtm</code>コメントを追加することで<code>lgtm</code>ラベルを追加できます。</li>
<li><code>/approve</code>コメントを追加してPull Requestをマージできるのは、SIG Docsの承認者だけです。一部の承認者は、<a href=/docs/contribute/participate/pr-wranglers/>PR Wrangler</a>や<a href=#sig-docs-chairperson>SIG Docsのchairperson</a>など、追加の特定の役割も実行します。</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<p>Kubernetesドキュメントへの貢献の詳細については、以下を参照してください：</p>
<ul>
<li><a href=/docs/contribute/new-content/overview/>Contributing new content</a></li>
<li><a href=/docs/contribute/review/reviewing-prs>Reviewing content</a></li>
<li><a href=/ja/docs/contribute/style/>ドキュメントスタイルの概要</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a2d946282df02cdeb47d9f54dfef198e>7.5 - ドキュメントスタイルの概要</h1>
<p>このセクション内のトピックでは、文章のスタイル、コンテンツの形式や構成、特にKubernetesのドキュメント特有のHugoカスタマイズの使用方法に関するガイダンスを提供します。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3b9549b1c8f5ef9d6ae0a841cc99c180>7.5.1 - ドキュメントコンテンツガイド</h1>
<p>このページでは、Kubernetesのドキュメント上のコンテンツのガイドラインを説明します。</p>
<p>許可されるコンテンツに関して疑問がある場合は、<a href=https://slack.k8s.io/>Kubernetes Slack</a>の#sig-docsチャンネルに参加して質問してください！</p>
<p>Kubernetes Slackには、<a href=https://slack.k8s.io/>https://slack.k8s.io/</a> から参加登録ができます。</p>
<p>Kubernetesドキュメントの新しいコンテンツの作成に関する情報については、<a href=/docs/contribute/style/style-guide>スタイルガイド</a>に従ってください。</p>
<h2 id=概要>概要</h2>
<p>ドキュメントを含むKubernetesのウェブサイトのソースは、<a href=https://github.com/kubernetes/website>kubernetes/website</a>リポジトリに置かれています。</p>
<p>Kubernetesの主要なドキュメントは<code>kubernetes/website/content/&lt;language_code>/docs</code>フォルダに置かれており、これらは<a href=https://github.com/kubernetes/kubernetes>Kubernetesプロジェクト</a>を対象としています。</p>
<h2 id=許可されるコンテンツ>許可されるコンテンツ</h2>
<p>Kubernetesのドキュメントにサードパーティーのコンテンツを掲載することが許されるのは、次の場合のみです。</p>
<ul>
<li>コンテンツがKubernetesプロジェクト内のソフトウェアのドキュメントとなる場合</li>
<li>コンテンツがプロジェクト外のソフトウェアのドキュメントとなるが、Kubernetesを機能させるために必要である場合</li>
<li>コンテンツがkubernetes.ioの正規のコンテンツであるか、他の場所の正規のコンテンツへのリンクである場合</li>
</ul>
<h3 id=third-party-content>サードパーティーのコンテンツ</h3>
<p>Kubernetesのドキュメントには、Kubernetesプロジェクト(<a href=https://github.com/kubernetes>kubernetes</a>および<a href=https://github.com/kubernetes-sigs>kubernetes-sigs</a> GitHub organizationsに存在するプロジェクト)の適用例が含まれています。</p>
<p>Kubernetesプロジェクト内のアクティブなコンテンツへのリンクは常に許可されます。</p>
<p>Kubernetesを機能させるためには、一部サードパーティーのコンテンツが必要です。たとえば、コンテナランタイム(containerd、CRI-O、Docker)、<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークポリシー</a>(CNI plugin)、<a href=/ja/docs/concepts/services-networking/ingress-controllers/>Ingressコントローラー</a>、<a href=/docs/concepts/cluster-administration/logging/>ロギング</a>などです。</p>
<p>ドキュメント内で、Kubernetesプロジェクト外のサードパーティーのオープンソースソフトウェア(OSS)にリンクすることができるのは、Kubernetesを機能させるために必要な場合のみです。</p>
<h3 id=情報源が重複するコンテンツ>情報源が重複するコンテンツ</h3>
<p>可能な限り、Kubernetesのドキュメントは正規の情報源にリンクするようにし、情報源が重複してしまうようなホスティングは行いません。</p>
<p>情報源が重複したコンテンツは、メンテナンスするために2倍の労力(あるいはそれ以上！)が必要になり、より早く情報が古くなってしまいます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> あなたがKubernetesのプロジェクトのメンテナーであり、ドキュメントのホスティングに関して手助けが必要なときは、<a href=https://kubernetes.slack.com/messages/C1J0BPD2M/>Kubernetes Slackの#sig-docs</a>で教えてください。
</div>
<h3 id=その他の情報>その他の情報</h3>
<p>許可されるコンテンツに関して疑問がある場合は、<a href=https://slack.k8s.io/>Kubernetes Slack</a>の#sig-docsチャンネルに参加して質問してください！</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/contribute/style/style-guide>スタイルガイド</a>を読む</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-357f2ddd61035f18c2aa63fe86203f9c>7.5.2 - コンテンツの構造化</h1>
<p>このサイトではHugoを使用しています。Hugoでは、<a href=https://gohugo.io/content-management/organization/>コンテンツの構造化</a>がコアコンセプトとなっています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <strong>Hugoのヒント:</strong> コンテンツの編集を始めるときは、<code>hugo server --navigateToChanged</code>コマンドを使用してHugoを実行してください。
</div>
<h2 id=ページの一覧>ページの一覧</h2>
<h3 id=ページの順序>ページの順序</h3>
<p>ドキュメントのサイドメニューやページブラウザーなどでは、Hugoのデフォルトのソート順序を使用して一覧を作成しています。デフォルトでは、weight(1から開始)、日付(最新のものが1番目)、最後にリンクのタイトルの順でソートされます。</p>
<p>そのため、特定のページやセッションを上に移動したい場合には、ページのフロントマター内のweightを設定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>title</span>:<span style=color:#bbb> </span>My Page<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ページのweightについては、1、2、3…などの値を使用せず、10、20、30…のように一定の間隔を空けた方が賢明です。こうすることで、後で別のページを間に挿入できるようになります。
</div>
<h3 id=ドキュメントのメインメニュー>ドキュメントのメインメニュー</h3>
<p>ドキュメントのメインメニューは、<code>docs/</code>以下に置かれたセクションのコンテンツファイル<code>_index.md</code>のフロントマター内に<code>main_menu</code>フラグが設定されたものから生成されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>main_menu</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><p>リンクのタイトルは、ページの<code>linkTitle</code>から取得されることに注意してください。そのため、ページのタイトルとは異なるリンクテキストにしたい場合、コンテンツファイル内の値を以下のように設定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>main_menu</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>title</span>:<span style=color:#bbb> </span>ページタイトル<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>linkTitle</span>:<span style=color:#bbb> </span>リンク内で使われるタイトル<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 上記の設定は言語ごとに行う必要があります。メニュー上にセクションが表示されないときは、Hugoからセクションとして認識されていないためである可能性が高いです。セクションフォルダー内に<code>_index.md</code>コンテンツファイルを作成してください。
</div>
<h3 id=ドキュメントのサイドメニュー>ドキュメントのサイドメニュー</h3>
<p>ドキュメントのサイドバーメニューは、<code>docs/</code>以下の<em>現在のセクションツリー</em>から生成されます。</p>
<p>セクションと、そのセクション内のページがすべて表示されます。</p>
<p>特定のセクションやページをリストに表示したくない場合、フロントマター内の<code>toc_hide</code>フラグを<code>true</code>に設定してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>toc_hide</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><p>コンテンツが存在するセクションに移動すると、特定のセクションまたはページ(例:<code>index.md</code>)が表示されます。それ以外の場合、そのセクションの最初のページが表示されます。</p>
<h3 id=ドキュメントのブラウザー>ドキュメントのブラウザー</h3>
<p>ドキュメントのホームページのページブラウザーは、<code>docs</code>セクション直下のすべてのセクションとページを使用して生成されています。</p>
<p>特定のセクションやページを表示したくない場合、フロントマターの<code>toc_hide</code>フラグを<code>true</code>に設定してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>toc_hide</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><h3 id=メインメニュー>メインメニュー</h3>
<p>右上のメニュー(およびフッター)にあるサイトリンクは、page-lookupの機能を使用して実装されています。これにより、ページが実際に存在することを保証しています。そのため、たとえば<code>case-studies</code>のセクションが特定の言語のサイトに存在しない場合、メニューにはケーススタディのリンクが表示されません。</p>
<h2 id=page-bundle>Page Bundle</h2>
<p>スタンドアローンのコンテンツページ(Markdownファイル)に加えて、Hugoでは、<a href=https://gohugo.io/content-management/page-bundles/>Page Bundles</a>がサポートされています。</p>
<p>Page Bundleの1つの例は、<a href=/docs/contribute/style/hugo-shortcodes/>カスタムのHugo Shortcode</a>です。これは、<code>leaf bundle</code>であると見做されます。ディレクトリ内のすべてのファイルは、<code>index.md</code>を含めてバンドルの一部となります。これには、ページからの相対リンク、処理可能な画像なども含まれます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>en/docs/home/contribute/includes
├── example1.md
├── example2.md
├── index.md
└── podtemplate.json
</code></pre></div><p>もう1つのPage Bundleがよく使われる例は、<code>includes</code>バンドルです。フロントマターに<code>headless: true</code>を設定すると、自分自身のURLを持たなくなり、他のページ内でのみ使用されるようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>en/includes
├── default-storage-class-prereqs.md
├── index.md
├── partner-script.js
├── partner-style.css
├── task-tutorial-prereqs.md
├── user-guide-content-moved.md
└── user-guide-migration-notice.md
</code></pre></div><p>バンドル内のファイルに関して、いくつか重要な注意点があります。</p>
<ul>
<li>翻訳されたバンドルに対しては、コンテンツ以外の見つからなかったファイルは上位の言語から継承されます。これにより重複が回避できます。</li>
<li>バンドル内のすべてのファイルは、Hugoが<code>Resources</code>と呼ぶファイルになり、フロントマター(YAMLファイルなど)をサポートしていない場合であっても、言語ごとにパラメーターやタイトルなどのメタデータを提供できます。詳しくは、<a href=https://gohugo.io/content-management/page-resources/#page-resources-metadata>Page Resourcesメタデータ</a>を参照してください。</li>
<li><code>Resource</code>の<code>.RelPermalink</code>から取得した値は、ページからの相対的なものとなっています。詳しくは、<a href=https://gohugo.io/content-management/urls/#permalinks>Permalinks</a>を参照してください。</li>
</ul>
<h2 id=スタイル>スタイル</h2>
<p>このサイトのスタイルシートの<a href=https://sass-lang.com/>SASS</a>のソースは、<code>assets/sass</code>に置かれていて、Hugoによって自動的にビルドされます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/contribute/style/hugo-shortcodes/>カスタムのHugo shortcode</a>について学ぶ</li>
<li><a href=/docs/contribute/style/style-guide>スタイルガイド</a>について学ぶ</li>
<li><a href=/docs/contribute/style/content-guide>コンテンツガイド</a>について学ぶ</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-849a2fdb87779db1c212fe5a9f88ff0d>7.6 - Kubernetesのドキュメントを翻訳する</h1>
<p>このページでは、Kubernetesドキュメントにおける日本語翻訳の方針について説明します。</p>
<h2 id=ドキュメントを日本語に翻訳するまでの流れ>ドキュメントを日本語に翻訳するまでの流れ</h2>
<p>翻訳を行うための基本的な流れについて説明します。不明点がある場合は<a href=http://slack.kubernetes.io/>Kubernetes公式Slack</a>の<code>#kubernetes-docs-ja</code>チャンネルにてお気軽にご質問ください。</p>
<h3 id=前提知識>前提知識</h3>
<p>翻訳作業は全て<a href="https://github.com/kubernetes/website/issues?q=is%3Aissue+is%3Aopen+label%3Alanguage%2Fja">GitHubのIssue</a>によって管理されています。翻訳作業を行いたい場合は、Issueの一覧をまず最初にご確認ください。</p>
<p>また、Kubernetes傘下のリポジトリでは<code>CLA</code>と呼ばれる同意書に署名しないと、Pull Requestをマージすることができません。詳しくは<a href=https://github.com/kubernetes/community/blob/master/CLA.md>英語のドキュメント</a>や、<a href=https://qiita.com/jlandowner/items/d14d9bc8797a62b65e67>Qiitaに有志の方が書いてくださった日本語のまとめ</a>をご覧ください。</p>
<h3 id=翻訳を始めるまで>翻訳を始めるまで</h3>
<h4 id=翻訳を希望するページのissueが存在しない場合>翻訳を希望するページのIssueが存在しない場合</h4>
<ol>
<li><a href=https://github.com/kubernetes/website/issues/22340>こちらのサンプル</a>に従う形でIssueを作成する</li>
<li>自分自身を翻訳作業に割り当てたい場合は、Issueのメッセージまたはコメントに<code>/assign</code>と書く</li>
<li><a href=#translate-new-page>新規ページを翻訳する場合</a>のステップに進む</li>
</ol>
<p><strong>不明点がある場合は<a href=http://slack.kubernetes.io/>Kubernetes公式Slack</a>の<code>#kubernetes-docs-ja</code>チャンネルにてお気軽にご質問ください。</strong></p>
<h4 id=翻訳を希望するページのissueが存在する場合>翻訳を希望するページのIssueが存在する場合</h4>
<ol>
<li>自分自身を翻訳作業に割り当てるために、Issueのコメントに<code>/assign</code>と書く</li>
<li><a href=#translate-new-page>新規ページを翻訳する場合</a>のステップに進む</li>
</ol>
<h3 id=pull-requestを送るまで>Pull Requestを送るまで</h3>
<p>未翻訳ページの新規翻訳作業と既存ページの修正作業でそれぞれ手順が異なります。</p>
<p>既存ページへの追加修正については、後述の<a href=#milestones>マイルストーンについて</a>に目を通すことをおすすめします。</p>
<h4 id=translate-new-page>新規ページを翻訳する場合の手順</h4>
<ol>
<li><code>kubernetes/website</code>リポジトリをフォークする</li>
<li><code>master</code>から任意の名前でブランチを作成する</li>
<li><code>content/en</code>のディレクトリから必要なファイルを<code>content/ja</code>にコピーし、翻訳する</li>
<li><code>master</code>ブランチに向けてPull Requestを作成する</li>
</ol>
<h4 id=既存のページの誤字脱字や古い記述を修正する場合の手順>既存のページの誤字脱字や古い記述を修正する場合の手順</h4>
<ol>
<li><code>kubernetes/website</code>リポジトリをフォークする</li>
<li><code>dev-1.18-ja.2</code>(最新のマイルストーンブランチに適宜読み替えること)から任意の名前でブランチを作成し、該当箇所を編集する</li>
<li><code>dev-1.18-ja.2</code>(最新のマイルストーンブランチに適宜読み替えること)ブランチに向けてPull Requestを作成する</li>
</ol>
<h3 id=milestones>マイルストーンについて</h3>
<p>翻訳作業を集中的に管理するために、日本語を含む複数の言語ではマイルストーンを採用しています。</p>
<p>各マイルストーンでは、</p>
<ul>
<li>最低要件のコンテンツの追加・更新(項目については<a href=https://kubernetes.io/docs/contribute/localization/#translating-documents>こちら</a>を参照してください)</li>
<li>バージョンに追従できていない翻訳済みコンテンツの更新</li>
</ul>
<p>を行い、ドキュメントの全体的なメンテナンスを行っています。</p>
<p>マイルストーンのバージョンはOwner権限を持つメンバーが管理するものとします。</p>
<h2 id=翻訳スタイルガイド>翻訳スタイルガイド</h2>
<h3 id=基本方針>基本方針</h3>
<ul>
<li>本文を、敬体（ですます調）で統一
<ul>
<li>特に、「〜になります」「〜となります」という表現は「〜です」の方が適切な場合が多いため注意</li>
</ul>
</li>
<li>句読点は「、」と「。」を使用</li>
<li>漢字、ひらがな、カタカナは全角で表記</li>
<li>数字とアルファベットは半角で表記</li>
<li>スペースと括弧 <code>()</code> 、コロン <code>:</code> は半角、それ以外の記号類は全角で表記</li>
<li>英単語と日本語の間に半角スペースは不要</li>
</ul>
<h3 id=頻出単語>頻出単語</h3>
<table>
<thead>
<tr>
<th>英語</th>
<th>日本語</th>
</tr>
</thead>
<tbody>
<tr>
<td>Addon/Add-on</td>
<td>アドオン</td>
</tr>
<tr>
<td>Aggregation Layer</td>
<td>アグリゲーションレイヤー</td>
</tr>
<tr>
<td>architecture</td>
<td>アーキテクチャ</td>
</tr>
<tr>
<td>binary</td>
<td>バイナリ</td>
</tr>
<tr>
<td>cluster</td>
<td>クラスター</td>
</tr>
<tr>
<td>community</td>
<td>コミュニティ</td>
</tr>
<tr>
<td>container</td>
<td>コンテナ</td>
</tr>
<tr>
<td>controller</td>
<td>コントローラー</td>
</tr>
<tr>
<td>Deployment/Deploy</td>
<td>KubernetesリソースとしてのDeploymentはママ表記、一般的な用語としてのdeployの場合は、デプロイ</td>
</tr>
<tr>
<td>directory</td>
<td>ディレクトリ</td>
</tr>
<tr>
<td>For more information</td>
<td>さらなる情報(一時的)</td>
</tr>
<tr>
<td>GitHub</td>
<td>GitHub (ママ表記)</td>
</tr>
<tr>
<td>Issue</td>
<td>Issue (ママ表記)</td>
</tr>
<tr>
<td>operator</td>
<td>オペレーター</td>
</tr>
<tr>
<td>orchestrate(動詞)</td>
<td>オーケストレーションする</td>
</tr>
<tr>
<td>Persistent Volume</td>
<td>KubernetesリソースとしてのPersistentVolumeはママ表記、一般的な用語としての場合は、永続ボリューム</td>
</tr>
<tr>
<td>prefix</td>
<td>プレフィックス</td>
</tr>
<tr>
<td>Pull Request</td>
<td>Pull Request (ママ表記)</td>
</tr>
<tr>
<td>Quota</td>
<td>クォータ</td>
</tr>
<tr>
<td>registry</td>
<td>レジストリ</td>
</tr>
<tr>
<td>secure</td>
<td>セキュア</td>
</tr>
<tr>
<td>a set of ~</td>
<td>～の集合</td>
</tr>
<tr>
<td>stacked</td>
<td>積層(例: stacked etcd clusterは積層etcdクラスター)</td>
</tr>
</tbody>
</table>
<h3 id=備考>備考</h3>
<p>ServiceやDeploymentなどのKubernetesのAPIオブジェクトや技術仕様的な固有名詞は、無理に日本語訳せずそのまま書いてください。</p>
<p>また、日本語では名詞を複数形にする意味はあまりないので、英語の名詞を利用する場合は原則として単数形で表現してください。</p>
<p>例:</p>
<ul>
<li>Kubernetes Service</li>
<li>Node</li>
<li>Pod</li>
</ul>
<p>外部サイトへの参照の記事タイトルは翻訳しましょう。(一時的)</p>
<h3 id=頻出表記-日本語>頻出表記（日本語）</h3>
<table>
<thead>
<tr>
<th>よくある表記</th>
<th>あるべき形</th>
</tr>
</thead>
<tbody>
<tr>
<td>〜ので、〜から、〜だから</td>
<td>〜のため 、〜ため</td>
</tr>
<tr>
<td>（あいうえお。）</td>
<td>（あいうえお）。</td>
</tr>
<tr>
<td>〇,〇,〇</td>
<td>〇、〇、〇（※今回列挙はすべて読点で統一）</td>
</tr>
</tbody>
</table>
<h3 id=単語末尾に長音記号-ー-を付けるかどうか>単語末尾に長音記号(「ー」)を付けるかどうか</h3>
<p>「サーバー」「ユーザー」など英単語をカタカナに訳すときに、末尾の「ー」を付けるかどうか。</p>
<ul>
<li>「r」「re」「y」などで終わる単語については、原則付ける</li>
<li>上の頻出語のように、別途まとめたものは例外とする</li>
</ul>
<p>参考: <a href=https://kubernetes.slack.com/archives/CAG2M83S8/p1554096635015200>https://kubernetes.slack.com/archives/CAG2M83S8/p1554096635015200</a> 辺りのやりとり</p>
<h3 id=cron-jobの訳し方に関して>cron jobの訳し方に関して</h3>
<p>混同を避けるため、cron jobはcronジョブと訳し、CronJobはリソース名としてのままにする。
cron「の」ジョブは、「の」が続く事による解釈の難から基本的にはつけないものとする。</p>
<h3 id=その他基本方針など>その他基本方針など</h3>
<ul>
<li>意訳と直訳で迷った場合は「直訳」で訳す</li>
<li>訳で難しい・わからないと感じたらSlackの#kubernetes-docs-jaでみんなに聞く</li>
<li>できることを挙手制で、できないときは早めに報告</li>
</ul>
<h2 id=アップストリームのコントリビューター>アップストリームのコントリビューター</h2>
<p>SIG Docsでは、英語のソースに対する<a href=/docs/contribute/intermediate#localize-content>アップストリームへのコントリビュートや誤りの訂正</a>を歓迎しています。</p>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>