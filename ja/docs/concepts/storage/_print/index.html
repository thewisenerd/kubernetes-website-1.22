<!doctype html><html lang=ja class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/storage/>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/storage/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/storage/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/storage/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/storage/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/storage/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/storage/>
<link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/storage/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/concepts/storage/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>ストレージ | Kubernetes</title><meta property="og:title" content="ストレージ">
<meta property="og:description" content="プロダクショングレードのコンテナ管理基盤">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/storage/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="ストレージ">
<meta itemprop=description content="プロダクショングレードのコンテナ管理基盤"><meta name=twitter:card content="summary">
<meta name=twitter:title content="ストレージ">
<meta name=twitter:description content="プロダクショングレードのコンテナ管理基盤">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content>
<meta property="og:description" content>
<meta name=twitter:description content>
<meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/storage/">
<meta property="og:title" content="ストレージ">
<meta name=twitter:title content="ストレージ">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/ja/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/ja/docs/>ドキュメント</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/training/>トレーニング</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/partners/>パートナー</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/community/>コミュニティ</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/case-studies/>ケーススタディ</span></a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
バージョン
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/concepts/storage/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/ja/docs/concepts/storage/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/concepts/storage/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/concepts/storage/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/concepts/storage/>v1.22</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
日本語 Japanese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/concepts/storage/>English</a>
<a class=dropdown-item href=/zh/docs/concepts/storage/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/concepts/storage/>한국어 Korean</a>
<a class=dropdown-item href=/fr/docs/concepts/storage/>Français</a>
<a class=dropdown-item href=/de/docs/concepts/storage/>Deutsch</a>
<a class=dropdown-item href=/es/docs/concepts/storage/>Español</a>
<a class=dropdown-item href=/id/docs/concepts/storage/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/storage/>Українська</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.
</p><p>
<a href=/ja/docs/concepts/storage/>このページの通常のビューに戻る</a>.
</p>
</div>
<h1 class=title>ストレージ</h1>
<ul>
<li>1: <a href=#pg-ffd12528a12882b282e1bd19e29f9e75>永続ボリューム</a></li>
<li>2: <a href=#pg-707ca81a34eb1ca202f34692e9917d1e>CSI Volume Cloning</a></li>
<li>3: <a href=#pg-4d00116c86dade62bdd5be7dc2afa1ca>VolumeSnapshotClass</a></li>
<li>4: <a href=#pg-018f0a7fc6e2f6d16da37702fc39b4f3>ボリュームの動的プロビジョニング(Dynamic Volume Provisioning)</a></li>
<li>5: <a href=#pg-00cd24f4570b7acaac75c2551c948bc7>ストレージ容量</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-ffd12528a12882b282e1bd19e29f9e75>1 - 永続ボリューム</h1>
<p>このドキュメントではKubernetesの <em>PersistentVolume</em> について説明します。<a href=/docs/concepts/storage/volumes/>ボリューム</a>を一読することをおすすめします。</p>
<h2 id=概要>概要</h2>
<p>ストレージを管理することはインスタンスを管理することとは全くの別物です。PersistentVolumeサブシステムは、ストレージが何から提供されているか、どのように消費されているかをユーザーと管理者から抽象化するAPIを提供します。これを実現するためのPersistentVolumeとPersistentVolumeClaimという2つの新しいAPIリソースを紹介します。</p>
<p><em>PersistentVolume</em> (PV)は<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>を使って管理者もしくは動的にプロビジョニングされるクラスターのストレージの一部です。これはNodeと同じようにクラスターリソースの一部です。PVはVolumeのようなボリュームプラグインですが、PVを使う個別のPodとは独立したライフサイクルを持っています。このAPIオブジェクトはNFS、iSCSIやクラウドプロバイダー固有のストレージシステムの実装の詳細を捕捉します。</p>
<p><em>PersistentVolumeClaim</em> (PVC)はユーザーによって要求されるストレージです。これはPodと似ています。PodはNodeリソースを消費し、PVCはPVリソースを消費します。Podは特定レベルのCPUとメモリーリソースを要求することができます。クレームは特定のサイズやアクセスモード(例えば、ReadWriteOnce、ReadOnlyMany、ReadWriteManyにマウントできます。詳しくは<a href=#access-modes>アクセスモード</a>を参照してください)を要求することができます。</p>
<p>PersistentVolumeClaimはユーザーに抽象化されたストレージリソースの消費を許可する一方、ユーザーは色々な問題に対処するためにパフォーマンスといった様々なプロパティを持ったPersistentVolumeを必要とすることは一般的なことです。クラスター管理者はユーザーに様々なボリュームがどのように実装されているかを表に出すことなく、サイズやアクセスモードだけではない色々な点で異なった、様々なPersistentVolumeを提供できる必要があります。これらのニーズに応えるために <em>StorageClass</em> リソースがあります。</p>
<p><a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/>実例を含む詳細なチュートリアル</a>を参照して下さい。</p>
<h2 id=ボリュームと要求のライフサイクル>ボリュームと要求のライフサイクル</h2>
<p>PVはクラスター内のリソースです。PVCはこれらのリソースの要求でありまた、クレームのチェックとしても機能します。PVとPVCの相互作用はこのライフサイクルに従います。</p>
<h3 id=プロビジョニング>プロビジョニング</h3>
<p>PVは静的か動的どちらかでプロビジョニングされます。</p>
<h4 id=静的>静的</h4>
<p>クラスター管理者は多数のPVを作成します。それらはクラスターのユーザーが使うことのできる実際のストレージの詳細を保持します。それらはKubernetes APIに存在し、利用できます。</p>
<h4 id=動的>動的</h4>
<p>ユーザーのPersistentVolumeClaimが管理者の作成したいずれの静的PVにも一致しない場合、クラスターはPVC用にボリュームを動的にプロビジョニングしようとする場合があります。
このプロビジョニングはStorageClassに基づいています。PVCは<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>の要求が必要であり、管理者は動的プロビジョニングを行うためにストレージクラスの作成・設定が必要です。ストレージクラスを""にしたストレージ要求は、自身の動的プロビジョニングを事実上無効にします。</p>
<p>ストレージクラスに基づいたストレージの動的プロビジョニングを有効化するには、クラスター管理者が<code>DefaultStorageClass</code><a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass>アドミッションコントローラー</a>をAPIサーバーで有効化する必要があります。
これは例えば、<code>DefaultStorageClass</code>がAPIサーバーコンポーネントの<code>--enable-admission-plugins</code>フラグのコンマ区切りの順序付きリストの中に含まれているかで確認できます。
APIサーバーのコマンドラインフラグの詳細については<a href=/docs/admin/kube-apiserver/>kube-apiserver</a>のドキュメントを参照してください。</p>
<h3 id=バインディング>バインディング</h3>
<p>ユーザは、特定のサイズのストレージとアクセスモードを指定した上でPersistentVolumeClaimを作成します（動的プロビジョニングの場合は、すでに作られています）。マスター内のコントロールループは、新しく作られるPVCをウォッチして、それにマッチするPVが見つかったときに、それらを紐付けます。PVが新しいPVC用に動的プロビジョニングされた場合、コントロールループは常にPVをそのPVCに紐付けます。そうでない場合、ユーザーは常に少なくとも要求したサイズ以上のボリュームを取得しますが、ボリュームは要求されたサイズを超えている可能性があります。一度紐付けされると、どのように紐付けられたかに関係なくPersistentVolumeClaimの紐付けは排他的（決められた特定のPVとしか結びつかない状態）になります。PVCからPVへの紐付けは、PersistentVolumeとPersistentVolumeClaim間の双方向の紐付けであるClaimRefを使用した1対1のマッピングになっています。</p>
<p>一致するボリュームが存在しない場合、クレームはいつまでも紐付けされないままになります。一致するボリュームが利用可能になると、クレームがバインドされます。たとえば、50GiのPVがいくつもプロビジョニングされているクラスターだとしても、100Giを要求するPVCとは一致しません。100GiのPVがクラスターに追加されると、PVCを紐付けできます。</p>
<h3 id=使用>使用</h3>
<p>Podは要求をボリュームとして使用します。クラスターは、要求を検査して紐付けられたボリュームを見つけそのボリュームをPodにマウントします。複数のアクセスモードをサポートするボリュームの場合、ユーザーはPodのボリュームとしてクレームを使う時にどのモードを希望するかを指定します。</p>
<p>ユーザーがクレームを取得し、そのクレームがバインドされると、バインドされたPVは必要な限りそのユーザーに属します。ユーザーはPodをスケジュールし、Podのvolumesブロックに<code>persistentVolumeClaim</code>を含めることで、バインドされたクレームのPVにアクセスします。
<a href=#claims-as-volumes>書式の詳細はこちらを確認して下さい。</a></p>
<h3 id=使用中のストレージオブジェクトの保護>使用中のストレージオブジェクトの保護</h3>
<p>使用中のストレージオブジェクト保護機能の目的はデータ損失を防ぐために、Podによって実際に使用されている永続ボリュームクレーム(PVC)と、PVCにバインドされている永続ボリューム(PV)がシステムから削除されないようにすることです。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> PVCを使用しているPodオブジェクトが存在する場合、PVCはPodによって実際に使用されています。
</div>
<p>ユーザーがPodによって実際に使用されているPVCを削除しても、そのPVCはすぐには削除されません。PVCの削除は、PVCがPodで使用されなくなるまで延期されます。また、管理者がPVCに紐付けられているPVを削除しても、PVはすぐには削除されません。PVがPVCに紐付けられなくなるまで、PVの削除は延期されます。</p>
<p>PVCの削除が保護されているかは、PVCのステータスが<code>Terminating</code>になっていて、そして<code>Finalizers</code>のリストに<code>kubernetes.io/pvc-protection</code>が含まれているかで確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pvc hostpath
Name:          hostpath
Namespace:     default
StorageClass:  example-hostpath
Status:        Terminating
Volume:
Labels:        &lt;none&gt;
Annotations:   volume.beta.kubernetes.io/storage-class<span style=color:#666>=</span>example-hostpath
               volume.beta.kubernetes.io/storage-provisioner<span style=color:#666>=</span>example.com/hostpath
Finalizers:    <span style=color:#666>[</span>kubernetes.io/pvc-protection<span style=color:#666>]</span>
</code></pre></div><p>同様にPVの削除が保護されているかは、PVのステータスが<code>Terminating</code>になっていて、そして<code>Finalizers</code>のリストに<code>kubernetes.io/pv-protection</code>が含まれているかで確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pv task-pv-volume
Name:            task-pv-volume
Labels:          <span style=color:#b8860b>type</span><span style=color:#666>=</span><span style=color:#a2f>local</span>
Annotations:     &lt;none&gt;
Finalizers:      <span style=color:#666>[</span>kubernetes.io/pv-protection<span style=color:#666>]</span>
StorageClass:    standard
Status:          Terminating
Claim:
Reclaim Policy:  Delete
Access Modes:    RWO
Capacity:        1Gi
Message:
Source:
    Type:          HostPath <span style=color:#666>(</span>bare host directory volume<span style=color:#666>)</span>
    Path:          /tmp/data
    HostPathType:
Events:            &lt;none&gt;
</code></pre></div><h3 id=再クレーム>再クレーム</h3>
<p>ユーザーは、ボリュームの使用が完了したら、リソースの再クレームを許可するAPIからPVCオブジェクトを削除できます。PersistentVolumeの再クレームポリシーはそのクレームが解放された後のボリュームの処理をクラスターに指示します。現在、ボリュームは保持、リサイクル、または削除できます。</p>
<h4 id=保持>保持</h4>
<p><code>Retain</code>という再クレームポリシーはリソースを手動で再クレームすることができます。PersistentVolumeClaimが削除される時、PersistentVolumeは依然として存在はしますが、ボリュームは解放済みです。ただし、以前のクレームデータはボリューム上に残っているため、別のクレームにはまだ使用できません。管理者は次の手順でボリュームを手動で再クレームできます。</p>
<ol>
<li>PersistentVolumeを削除します。PVが削除された後も、外部インフラストラクチャー(AWS EBS、GCE PD、Azure Disk、Cinderボリュームなど)に関連付けられたストレージアセットは依然として残ります。</li>
<li>ストレージアセットに関連するのデータを手動で適切にクリーンアップします。</li>
<li>関連するストレージアセットを手動で削除するか、同じストレージアセットを再利用したい場合、新しいストレージアセット定義と共にPersistentVolumeを作成します。</li>
</ol>
<h4 id=削除>削除</h4>
<p><code>Delete</code>再クレームポリシーをサポートするボリュームプラグインの場合、削除するとPersistentVolumeオブジェクトがKubernetesから削除されるだけでなく、AWS EBS、GCE PD、Azure Disk、Cinderボリュームなどの外部インフラストラクチャーの関連ストレージアセットも削除されます。動的にプロビジョニングされたボリュームは、<a href=#reclaim-policy>StorageClassの再クレームポリシー</a>を継承します。これはデフォルトで削除です。管理者は、ユーザーの需要に応じてStorageClassを構成する必要があります。そうでない場合、PVは作成後に編集またはパッチを適用する必要があります。<a href=/docs/tasks/administer-cluster/change-pv-reclaim-policy/>PersistentVolumeの再クレームポリシーの変更</a>を参照してください。</p>
<h4 id=リサイクル>リサイクル</h4>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> <code>Recycle</code>再クレームポリシーは非推奨になりました。代わりに、動的プロビジョニングを使用することをおすすめします。
</div>
<p>基盤となるボリュームプラグインでサポートされている場合、<code>Recycle</code>再クレームポリシーはボリュームに対して基本的な削除(<code>rm -rf /thevolume/*</code>)を実行し、新しいクレームに対して再び利用できるようにします。</p>
<p>管理者は<a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>reference</a>で説明するように、Kubernetesコントローラーマネージャーのコマンドライン引数を使用して、カスタムリサイクラーPodテンプレートを構成できます。カスタムリサイクラーPodテンプレートには、次の例に示すように、<code>volumes</code>仕様が含まれている必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/any/path/it/will/be/replaced<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/busybox&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;test -e /scrub &amp;&amp; rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  &amp;&amp; test -z \&#34;$(ls -A /scrub)\&#34; || exit 1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/scrub<span style=color:#bbb>
</span></code></pre></div><p>ただし、カスタムリサイクラーPodテンプレートの<code>volumes</code>パート内で指定された特定のパスは、リサイクルされるボリュームの特定のパスに置き換えられます。</p>
<h3 id=永続ボリュームの予約>永続ボリュームの予約</h3>
<p>コントロールプレーンは、永続ボリュームクレームをクラスター内の一致する永続ボリュームに<a href=#%E3%83%90%E3%82%A4%E3%83%B3%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0>バインド</a>できます。
ただし、永続ボリュームクレームを特定の永続ボリュームにバインドする場合、それらを事前にバインドする必要があります。</p>
<p>永続ボリュームクレームで永続ボリュームを指定することにより、その特定の永続ボリュームと永続ボリュームクレームの間のバインディングを宣言します。
永続ボリュームが存在し、その<code>claimRef</code>フィールドで永続ボリュームクレームを予約していない場合に永続ボリュームと永続ボリュームクレームがバインドされます。</p>
<p>バインディングは、ノードアフィニティを含むいくつかのボリュームの一致基準に関係なく発生します。
コントロールプレーンは、依然として<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>、アクセスモード、および要求されたストレージサイズが有効であることをチェックします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 空の文字列を明示的に指定する必要があります。そうしないとデフォルトのストレージクラスが設定されてしまいます。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>この方法は、永続ボリュームへのバインド特権を保証するものではありません。
他の永続ボリュームクレームが指定した永続ボリュームを使用できる場合、最初にそのストレージボリュームを予約する必要があります。
永続ボリュームの<code>claimRef</code>フィールドに関連する永続ボリュームクレームを指定して、他の永続ボリュームクレームがその永続ボリュームにバインドできないようにしてください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>claimRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></code></pre></div><p>これは、既存の永続ボリュームを再利用する場合など、<code>claimPolicy</code>が<code>Retain</code>に設定されている永続ボリュームを使用する場合に役立ちます。</p>
<h3 id=永続ボリュームクレームの拡大>永続ボリュームクレームの拡大</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p>PersistentVolumeClaim(PVC)の拡大はデフォルトで有効です。次のボリュームの種類で拡大できます。</p>
<ul>
<li>gcePersistentDisk</li>
<li>awsElasticBlockStore</li>
<li>Cinder</li>
<li>glusterfs</li>
<li>rbd</li>
<li>Azure File</li>
<li>Azure Disk</li>
<li>Portworx</li>
<li>FlexVolumes</li>
<li>CSI</li>
</ul>
<p>そのストレージクラスの<code>allowVolumeExpansion</code>フィールドがtrueとなっている場合のみ、PVCを拡大できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gluster-vol-default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://192.168.10.100:8080&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div><p>PVCに対してさらに大きなボリュームを要求するには、PVCオブジェクトを編集してより大きなサイズを指定します。これによりPersistentVolumeを受け持つ基盤にボリュームの拡大がトリガーされます。クレームを満たすため新しくPersistentVolumeが作成されることはありません。代わりに既存のボリュームがリサイズされます。</p>
<h4 id=csiボリュームの拡張>CSIボリュームの拡張</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code>
</div>
<p>CSIボリュームの拡張のサポートはデフォルトで有効になっていますが、ボリューム拡張をサポートするにはボリューム拡張を利用できるCSIドライバーも必要です。詳細については、それぞれのCSIドライバーのドキュメントを参照してください。</p>
<h4 id=ファイルシステムを含むボリュームのリサイズ>ファイルシステムを含むボリュームのリサイズ</h4>
<p>ファイルシステムがXFS、Ext3、またはExt4の場合にのみ、ファイルシステムを含むボリュームのサイズを変更できます。</p>
<p>ボリュームにファイルシステムが含まれる場合、新しいPodが<code>PersistentVolumeClaim</code>でReadWriteモードを使用している場合にのみ、ファイルシステムのサイズが変更されます。ファイルシステムの拡張は、Podの起動時、もしくはPodの実行時で基盤となるファイルシステムがオンラインの拡張をサポートする場合に行われます。</p>
<p>FlexVolumesでは、ドライバの<code>RequiresFSResize</code>機能がtrueに設定されている場合、サイズを変更できます。
FlexVolumeは、Podの再起動時にサイズ変更できます。</p>
<h4 id=使用中の永続ボリュームクレームのリサイズ>使用中の永続ボリュームクレームのリサイズ</h4>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 使用中のPVCの拡張は、Kubernetes 1.15以降のベータ版と、1.11以降のアルファ版として利用可能です。<code>ExpandInUsePersistentVolume</code>機能を有効化する必要があります。これはベータ機能のため多くのクラスターで自動的に行われます。詳細については、<a href=/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>のドキュメントを参照してください。
</div>
<p>この場合、既存のPVCを使用しているPodまたはDeploymentを削除して再作成する必要はありません。使用中のPVCは、ファイルシステムが拡張されるとすぐにPodで自動的に使用可能になります。この機能は、PodまたはDeploymentで使用されていないPVCには影響しません。拡張を完了する前に、PVCを使用するPodを作成する必要があります。</p>
<p>他のボリュームタイプと同様、FlexVolumeボリュームは、Podによって使用されている最中でも拡張できます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> FlexVolumeのリサイズは、基盤となるドライバーがリサイズをサポートしている場合のみ可能です。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> EBSの拡張は時間がかかる操作です。また変更は、ボリュームごとに6時間に1回までというクォータもあります。
</div>
<h4 id=ボリューム拡張時の障害からの復旧>ボリューム拡張時の障害からの復旧</h4>
<p>基盤ストレージの拡張に失敗した際には、クラスターの管理者はPersistent Volume Claim (PVC)の状態を手動で復旧し、リサイズ要求をキャンセルします。それをしない限り、リサイズ要求は管理者の介入なしにコントローラーによって継続的に再試行されます。</p>
<ol>
<li>PersistentVolumeClaim(PVC)にバインドされているPersistentVolume(PV)を<code>Retain</code>再クレームポリシーとしてマークします。</li>
<li>PVCを削除します。PVは<code>Retain</code>再クレームポリシーを持っているため、PVCを再び作成したときにいかなるデータも失うことはありません。</li>
<li><code>claimRef</code>エントリーをPVスペックから削除して、新しいPVCがそれにバインドできるようにします。これによりPVは<code>Available</code>になります。</li>
<li>PVより小さいサイズでPVCを再作成し、PVCの<code>volumeName</code>フィールドをPVの名前に設定します。これにより新しいPVCを既存のPVにバインドします。</li>
<li>PVを再クレームポリシーを復旧することを忘れずに行ってください。</li>
</ol>
<h2 id=永続ボリュームの種類>永続ボリュームの種類</h2>
<p>PersistentVolumeの種類はプラグインとして実装されます。Kubernetesは現在次のプラグインに対応しています。</p>
<ul>
<li><a href=/docs/concepts/storage/volumes/#awselasticblockstore><code>awsElasticBlockStore</code></a> - AWS Elastic Block Store (EBS)</li>
<li><a href=/docs/concepts/storage/volumes/#azuredisk><code>azureDisk</code></a> - Azure Disk</li>
<li><a href=/docs/concepts/storage/volumes/#azurefile><code>azureFile</code></a> - Azure File</li>
<li><a href=/docs/concepts/storage/volumes/#cephfs><code>cephfs</code></a> - CephFS volume</li>
<li><a href=/docs/concepts/storage/volumes/#cinder><code>cinder</code></a> - Cinder (OpenStack block storage)
(<strong>非推奨</strong>)</li>
<li><a href=/docs/concepts/storage/volumes/#csi><code>csi</code></a> - Container Storage Interface (CSI)</li>
<li><a href=/docs/concepts/storage/volumes/#fc><code>fc</code></a> - Fibre Channel (FC) storage</li>
<li><a href=/docs/concepts/storage/volumes/#flexVolume><code>flexVolume</code></a> - FlexVolume</li>
<li><a href=/docs/concepts/storage/volumes/#flocker><code>flocker</code></a> - Flocker storage</li>
<li><a href=/docs/concepts/storage/volumes/#gcepersistentdisk><code>gcePersistentDisk</code></a> - GCE Persistent Disk</li>
<li><a href=/docs/concepts/storage/volumes/#glusterfs><code>glusterfs</code></a> - Glusterfs volume</li>
<li><a href=/docs/concepts/storage/volumes/#hostpath><code>hostPath</code></a> - HostPath volume
(テスト用の単一ノードのみ。マルチノードクラスターでは動作しません。代わりに<code>local</code>ボリュームを利用することを検討してください。)</li>
<li><a href=/docs/concepts/storage/volumes/#iscsi><code>iscsi</code></a> - iSCSI (SCSI over IP) storage</li>
<li><a href=/docs/concepts/storage/volumes/#local><code>local</code></a> - ノードにマウントされたローカルストレージデバイス</li>
<li><a href=/docs/concepts/storage/volumes/#nfs><code>nfs</code></a> - Network File System (NFS) storage</li>
<li><code>photonPersistentDisk</code> - Photon controller persistent disk
(対応するクラウドプロバイダーが削除されたため、このボリュームタイプは機能しなくなりました。)</li>
<li><a href=/docs/concepts/storage/volumes/#portworxvolume><code>portworxVolume</code></a> - Portworx volume</li>
<li><a href=/docs/concepts/storage/volumes/#quobyte><code>quobyte</code></a> - Quobyte volume</li>
<li><a href=/docs/concepts/storage/volumes/#rbd><code>rbd</code></a> - Rados Block Device (RBD) volume</li>
<li><a href=/docs/concepts/storage/volumes/#scaleio><code>scaleIO</code></a> - ScaleIO volume
(<strong>非推奨</strong>)</li>
<li><a href=/docs/concepts/storage/volumes/#storageos><code>storageos</code></a> - StorageOS volume</li>
<li><a href=/docs/concepts/storage/volumes/#vspherevolume><code>vsphereVolume</code></a> - vSphere VMDK volume</li>
</ul>
<h2 id=永続ボリューム>永続ボリューム</h2>
<p>各PVには、仕様とボリュームのステータスが含まれているspecとstatusが含まれています。
PersistentVolumeオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv0003<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Recycle<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>mountOptions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- hard<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- nfsvers=4.1<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nfs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/tmp<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.2</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> クラスター内でPersistentVolumeを使用するには、ボリュームタイプに関連するヘルパープログラムが必要な場合があります。
この例では、PersistentVolumeはNFSタイプで、NFSファイルシステムのマウントをサポートするためにヘルパープログラム<code>/sbin/mount.nfs</code>が必要になります。
</div>
<h3 id=容量>容量</h3>
<p>通常、PVには特定のストレージ容量があります。これはPVの<code>capacity</code>属性を使用して設定されます。容量によって期待される単位を理解するためには、Kubernetesの<a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>リソースモデル</a>を参照してください。</p>
<p>現在、設定または要求できるのはストレージサイズのみです。将来の属性には、IOPS、スループットなどが含まれます。</p>
<h3 id=ボリュームモード>ボリュームモード</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>KubernetesはPersistentVolumesの2つの<code>volumeModes</code>をサポートしています: <code>Filesystem</code>と<code>Block</code>です。<br>
<code>volumeMode</code>は任意のAPIパラメーターです。<br>
<code>Filesystem</code>は<code>volumeMode</code>パラメーターが省略されたときに使用されるデフォルトのモードです。</p>
<p><code>volumeMode: Filesystem</code>であるボリュームはPodに<em>マウント</em>されてディレクトリになります。 ボリュームがブロックデバイスでデバイスが空の時、Kubernetesは初めてそれにマウントされる前にデバイスのファイルシステムを作成します。</p>
<p><code>volumeMode</code>の値を<code>Block</code>に設定してボリュームをRAWブロックデバイスとして使用します。<br>
このようなボリュームは、ファイルシステムを持たないブロックデバイスとしてPodに提示されます。<br>
このモードは、Podとボリュームの間のファイルシステムレイヤなしにボリュームにアクセスする可能な限り最速の方法をPodに提供するのに便利です。一方で、Pod上で実行しているアプリケーションはRAWブロックデバイスの扱い方を知っていなければなりません。<br>
Pod内で<code>volumeMode: Block</code>とともにボリュームを使用する例としては、<a href=#raw-block-volume-support>Raw Block Volume Support</a>を参照してください。</p>
<h3 id=アクセスモード>アクセスモード</h3>
<p>PersistentVolumeは、リソースプロバイダーがサポートする方法でホストにマウントできます。次の表に示すように、プロバイダーにはさまざまな機能があり、各PVのアクセスモードは、その特定のボリュームでサポートされる特定のモードに設定されます。たとえば、NFSは複数の読み取り/書き込みクライアントをサポートできますが、特定のNFSのPVはサーバー上で読み取り専用としてエクスポートされる場合があります。各PVは、その特定のPVの機能を記述する独自のアクセスモードのセットを取得します。</p>
<p>アクセスモードは次の通りです。</p>
<ul>
<li>ReadWriteOnce –ボリュームは単一のNodeで読み取り/書き込みとしてマウントできます</li>
<li>ReadOnlyMany –ボリュームは多数のNodeで読み取り専用としてマウントできます</li>
<li>ReadWriteMany –ボリュームは多数のNodeで読み取り/書き込みとしてマウントできます</li>
</ul>
<p>CLIではアクセスモードは次のように略されます。</p>
<ul>
<li>RWO - ReadWriteOnce</li>
<li>ROX - ReadOnlyMany</li>
<li>RWX - ReadWriteMany</li>
</ul>
<blockquote>
<p><strong>Important!</strong> ボリュームは、多数のモードをサポートしていても、一度に1つのアクセスモードでしかマウントできません。たとえば、GCEPersistentDiskは、単一NodeではReadWriteOnceとして、または多数のNodeではReadOnlyManyとしてマウントできますが、同時にマウントすることはできません。</p>
</blockquote>
<table>
<thead>
<tr>
<th style=text-align:left>ボリュームプラグイン</th>
<th style=text-align:center>ReadWriteOnce</th>
<th style=text-align:center>ReadOnlyMany</th>
<th style=text-align:center>ReadWriteMany</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>AWSElasticBlockStore</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>AzureFile</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
</tr>
<tr>
<td style=text-align:left>AzureDisk</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>CephFS</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
</tr>
<tr>
<td style=text-align:left>Cinder</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>CSI</td>
<td style=text-align:center>ドライバーに依存</td>
<td style=text-align:center>ドライバーに依存</td>
<td style=text-align:center>ドライバーに依存</td>
</tr>
<tr>
<td style=text-align:left>FC</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>FlexVolume</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>ドライバーに依存</td>
</tr>
<tr>
<td style=text-align:left>Flocker</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>GCEPersistentDisk</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>Glusterfs</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
</tr>
<tr>
<td style=text-align:left>HostPath</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>iSCSI</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>Quobyte</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
</tr>
<tr>
<td style=text-align:left>NFS</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
</tr>
<tr>
<td style=text-align:left>RBD</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>VsphereVolume</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>- (Podが連結されている場合のみ)</td>
</tr>
<tr>
<td style=text-align:left>PortworxVolume</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>✓</td>
</tr>
<tr>
<td style=text-align:left>ScaleIO</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
</tr>
<tr>
<td style=text-align:left>StorageOS</td>
<td style=text-align:center>✓</td>
<td style=text-align:center>-</td>
<td style=text-align:center>-</td>
</tr>
</tbody>
</table>
<h3 id=class>Class</h3>
<p>PVはクラスを持つことができます。これは<code>storageClassName</code>属性を<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>の名前に設定することで指定されます。特定のクラスのPVは、そのクラスを要求するPVCにのみバインドできます。<code>storageClassName</code>にクラスがないPVは、特定のクラスを要求しないPVCにのみバインドできます。</p>
<p>以前<code>volume.beta.kubernetes.io/storage-class</code>アノテーションは、<code>storageClassName</code>属性の代わりに使用されていました。このアノテーションはまだ機能しています。ただし、将来のKubernetesリリースでは完全に非推奨です。</p>
<h3 id=reclaim-policy>再クレームポリシー</h3>
<p>現在の再クレームポリシーは次のとおりです。</p>
<ul>
<li>保持 -- 手動再クレーム</li>
<li>リサイクル -- 基本的な削除 (<code>rm -rf /thevolume/*</code>)</li>
<li>削除 -- AWS EBS、GCE PD、Azure Disk、もしくはOpenStack Cinderボリュームに関連するストレージアセットを削除</li>
</ul>
<p>現在、NFSとHostPathのみがリサイクルをサポートしています。AWS EBS、GCE PD、Azure Disk、およびCinder volumeは削除をサポートしています。</p>
<h3 id=マウントオプション>マウントオプション</h3>
<p>Kubernetes管理者は永続ボリュームがNodeにマウントされるときの追加マウントオプションを指定できます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> すべての永続ボリュームタイプがすべてのマウントオプションをサポートするわけではありません。
</div>
<p>次のボリュームタイプがマウントオプションをサポートしています。</p>
<ul>
<li>AWSElasticBlockStore</li>
<li>AzureDisk</li>
<li>AzureFile</li>
<li>CephFS</li>
<li>Cinder (OpenStackブロックストレージ)</li>
<li>GCEPersistentDisk</li>
<li>Glusterfs</li>
<li>NFS</li>
<li>Quobyte Volumes</li>
<li>RBD (Ceph Block Device)</li>
<li>StorageOS</li>
<li>VsphereVolume</li>
<li>iSCSI</li>
</ul>
<p>マウントオプションは検証されないため、不正だった場合マウントは失敗します。</p>
<p>以前<code>volume.beta.kubernetes.io/mount-options</code>アノテーションが<code>mountOptions</code>属性の代わりに使われていました。このアノテーションはまだ機能しています。ただし、将来のKubernetesリリースでは完全に非推奨です。</p>
<h3 id=ノードアフィニティ>ノードアフィニティ</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ほとんどのボリュームタイプはこのフィールドを設定する必要がありません。<a href=/docs/concepts/storage/volumes/#awselasticblockstore>AWS EBS</a>、<a href=/docs/concepts/storage/volumes/#gcepersistentdisk>GCE PD</a>、もしくは<a href=/docs/concepts/storage/volumes/#azuredisk>Azure Disk</a>ボリュームブロックタイプの場合自動的に設定されます。<a href=/docs/concepts/storage/volumes/#local>local</a>ボリュームは明示的に設定する必要があります。
</div>
<p>PVは<a href=/docs/reference/generated/kubernetes-api/v1.22/#volumenodeaffinity-v1-core>ノードアフィニティ</a>を指定して、このボリュームにアクセスできるNodeを制限する制約を定義できます。PVを使用するPodは、ノードアフィニティによって選択されたNodeにのみスケジュールされます。</p>
<h3 id=フェーズ>フェーズ</h3>
<p>ボリュームは次のフェーズのいずれかです。</p>
<ul>
<li>利用可能 -- まだクレームに紐付いていない自由なリソース</li>
<li>バウンド -- クレームに紐付いている</li>
<li>リリース済み -- クレームが削除されたが、クラスターにまだクレームされている</li>
<li>失敗 -- 自動再クレームに失敗</li>
</ul>
<p>CLIにはPVに紐付いているPVCの名前が表示されます。</p>
<h2 id=persistentvolumeclaims>永続ボリューム要求</h2>
<p>各PVCにはspecとステータスが含まれます。これは、仕様とクレームのステータスです。</p>
<p>PersistentVolumeClaimオブジェクトの名前は、有効な
<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>8Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>release</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- {<span style=color:green;font-weight:700>key: environment, operator: In, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></code></pre></div><h3 id=アクセスモード-1>アクセスモード</h3>
<p>クレームは、特定のアクセスモードでストレージを要求するときにボリュームと同じ規則を使用します。</p>
<h3 id=ボリュームモード-1>ボリュームモード</h3>
<p>クレームは、ボリュームと同じ規則を使用して、ファイルシステムまたはブロックデバイスとしてのボリュームの消費を示します。</p>
<h3 id=リソース>リソース</h3>
<p>Podと同様に、クレームは特定の量のリソースを要求できます。この場合、要求はストレージ用です。同じ<a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>リソースモデル</a>がボリュームとクレームの両方に適用されます。</p>
<h3 id=セレクター>セレクター</h3>
<p>クレームでは、<a href=/ja/docs/concepts/overview/working-with-objects/labels/#label-selectors>ラベルセレクター</a>を指定して、ボリュームセットをさらにフィルター処理できます。ラベルがセレクターに一致するボリュームのみがクレームにバインドできます。セレクターは2つのフィールドで構成できます。</p>
<ul>
<li><code>matchLabels</code> - ボリュームはこの値のラベルが必要です</li>
<li><code>matchExpressions</code> - キー、値のリスト、およびキーと値を関連付ける演算子を指定することによって作成された要件のリスト。有効な演算子は、In、NotIn、ExistsおよびDoesNotExistです。</li>
</ul>
<p><code>matchLabels</code>と<code>matchExpressions</code>の両方からのすべての要件はANDで結合されます。一致するには、すべてが一致する必要があります。</p>
<h3 id=クラス>クラス</h3>
<p>クレームは、<code>storageClassName</code>属性を使用して<a href=/docs/concepts/storage/storage-classes/>ストレージクラス</a>の名前を指定することにより、特定のクラスを要求できます。PVCにバインドできるのは、PVCと同じ<code>storageClassName</code>を持つ、要求されたクラスのPVのみです。</p>
<p>PVCは必ずしもクラスをリクエストする必要はありません。<code>storageClassName</code>が<code>""</code>に設定されているPVCは、クラスのないPVを要求していると常に解釈されるため、クラスのないPVにのみバインドできます（アノテーションがないか、<code>""</code>に等しい1つのセット）。<code>storageClassName</code>のないPVCはまったく同じではなく、<a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code>アドミッションプラグイン</a>がオンになっているかどうかによって、クラスターによって異なる方法で処理されます。</p>
<ul>
<li>アドミッションプラグインがオンになっている場合、管理者はデフォルトの<code>StorageClass</code>を指定できます。<code>storageClassName</code>を持たないすべてのPVCは、そのデフォルトのPVにのみバインドできます。デフォルトの<code>StorageClass</code>の指定は、<code>StorageClass</code>オブジェクトで<code>storageclass.kubernetes.io/is-default-class</code>アノテーションを<code>true</code>に設定することにより行われます。管理者がデフォルトを指定しない場合、クラスターは、アドミッションプラグインがオフになっているかのようにPVC作成をレスポンスします。複数のデフォルトが指定されている場合、アドミッションプラグインはすべてのPVCの作成を禁止します。</li>
<li>アドミッションプラグインがオフになっている場合、デフォルトの<code>StorageClass</code>の概念はありません。<code>storageClassName</code>を持たないすべてのPVCは、クラスを持たないPVにのみバインドできます。この場合、storageClassNameを持たないPVCは、<code>storageClassName</code>が<code>""</code>に設定されているPVCと同じように扱われます。</li>
</ul>
<p>インストール方法によっては、インストール時にアドオンマネージャーによってデフォルトのストレージクラスがKubernetesクラスターにデプロイされる場合があります。</p>
<p>PVCが<code>selector</code>を要求することに加えて<code>StorageClass</code>を指定する場合、要件はANDで一緒に結合されます。要求されたクラスのPVと要求されたラベルのみがPVCにバインドされます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 現在、<code>selector</code>が空ではないPVCは、PVを動的にプロビジョニングできません。
</div>
<p>以前は、<code>storageClassName</code>属性の代わりに<code>volume.beta.kubernetes.io/storage-class</code>アノテーションが使用されていました。このアノテーションはまだ機能しています。ただし、今後のKubernetesリリースではサポートされません。</p>
<h2 id=ボリュームとしてのクレーム>ボリュームとしてのクレーム</h2>
<p>Podは、クレームをボリュームとして使用してストレージにアクセスします。クレームは、そのクレームを使用するPodと同じ名前空間に存在する必要があります。クラスターは、Podの名前空間でクレームを見つけ、それを使用してクレームを支援しているPersistentVolumeを取得します。次に、ボリュームがホストとPodにマウントされます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfrontend<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/www/html&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></code></pre></div><h3 id=名前空間に関する注意>名前空間に関する注意</h3>
<p>PersistentVolumeバインドは排他的であり、PersistentVolumeClaimは名前空間オブジェクトであるため、"多"モード(<code>ROX</code>、<code>RWX</code>)でクレームをマウントすることは1つの名前空間内でのみ可能です。</p>
<h2 id=rawブロックボリュームのサポート>Rawブロックボリュームのサポート</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>次のボリュームプラグインは、必要に応じて動的プロビジョニングを含むrawブロックボリュームをサポートします。</p>
<ul>
<li>AWSElasticBlockStore</li>
<li>AzureDisk</li>
<li>CSI</li>
<li>FC (Fibre Channel)</li>
<li>GCEPersistentDisk</li>
<li>iSCSI</li>
<li>Local volume</li>
<li>OpenStack Cinder</li>
<li>RBD (Ceph Block Device)</li>
<li>VsphereVolume</li>
</ul>
<h3 id=persistent-volume-using-a-raw-block-volume>Rawブロックボリュームを使用した永続ボリューム</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pv<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fc</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetWWNs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;50060e801049cfd1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lun</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></code></pre></div><h3 id=rawブロックボリュームを要求する永続ボリュームクレーム>Rawブロックボリュームを要求する永続ボリュームクレーム</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></code></pre></div><h3 id=コンテナにrawブロックデバイスパスを追加するpod仕様>コンテナにRawブロックデバイスパスを追加するPod仕様</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-block-volume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fc-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:26<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;tail -f /dev/null&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeDevices</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>devicePath</span>:<span style=color:#bbb> </span>/dev/xvda<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Podにrawブロックデバイスを追加する場合は、マウントパスの代わりにコンテナーでデバイスパスを指定します。
</div>
<h3 id=ブロックボリュームのバインド>ブロックボリュームのバインド</h3>
<p>ユーザーがPersistentVolumeClaim specの<code>volumeMode</code>フィールドを使用してrawブロックボリュームの要求を示す場合、バインディングルールは、このモードをspecの一部として考慮しなかった以前のリリースとわずかに異なります。表にリストされているのは、ユーザーと管理者がrawブロックデバイスを要求するために指定可能な組み合わせの表です。この表は、ボリュームがバインドされるか、組み合わせが与えられないかを示します。静的にプロビジョニングされたボリュームのボリュームバインディングマトリクスはこちらです。</p>
<table>
<thead>
<tr>
<th>PVボリュームモード</th>
<th style=text-align:center>PVCボリュームモード</th>
<th style=text-align:right>結果</th>
</tr>
</thead>
<tbody>
<tr>
<td>未定義</td>
<td style=text-align:center>未定義</td>
<td style=text-align:right>バインド</td>
</tr>
<tr>
<td>未定義</td>
<td style=text-align:center>ブロック</td>
<td style=text-align:right>バインドなし</td>
</tr>
<tr>
<td>未定義</td>
<td style=text-align:center>ファイルシステム</td>
<td style=text-align:right>バインド</td>
</tr>
<tr>
<td>ブロック</td>
<td style=text-align:center>未定義</td>
<td style=text-align:right>バインドなし</td>
</tr>
<tr>
<td>ブロック</td>
<td style=text-align:center>ブロック</td>
<td style=text-align:right>バインド</td>
</tr>
<tr>
<td>ブロック</td>
<td style=text-align:center>ファイルシステム</td>
<td style=text-align:right>バインドなし</td>
</tr>
<tr>
<td>ファイルシステム</td>
<td style=text-align:center>ファイルシステム</td>
<td style=text-align:right>バインド</td>
</tr>
<tr>
<td>ファイルシステム</td>
<td style=text-align:center>ブロック</td>
<td style=text-align:right>バインドなし</td>
</tr>
<tr>
<td>ファイルシステム</td>
<td style=text-align:center>未定義</td>
<td style=text-align:right>バインド</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> アルファリリースでは、静的にプロビジョニングされたボリュームのみがサポートされます。管理者は、rawブロックデバイスを使用する場合、これらの値を考慮するように注意する必要があります。
</div>
<h2 id=ボリュームのスナップショットとスナップショットからのボリュームの復元のサポート>ボリュームのスナップショットとスナップショットからのボリュームの復元のサポート</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code>
</div>
<p>ボリュームスナップショット機能は、CSIボリュームプラグインのみをサポートするために追加されました。詳細については、<a href=/docs/concepts/storage/volume-snapshots/>ボリュームのスナップショット</a>を参照してください。</p>
<p>ボリュームスナップショットのデータソースからボリュームを復元する機能を有効にするには、apiserverおよびcontroller-managerで<code>VolumeSnapshotDataSource</code>フィーチャーゲートを有効にします。</p>
<h3 id=create-persistent-volume-claim-from-volume-snapshot>ボリュームスナップショットから永続ボリュームクレームを作成する</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>restore-pvc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>csi-hostpath-sc<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></code></pre></div><h2 id=ボリュームの複製>ボリュームの複製</h2>
<p><a href=/ja/docs/concepts/storage/volume-pvc-datasource/>ボリュームの複製</a>はCSIボリュームプラグインにのみ利用可能です。</p>
<p>PVCデータソースからのボリューム複製機能を有効にするには、apiserverおよびcontroller-managerで<code>VolumeSnapshotDataSource</code>フィーチャーゲートを有効にします。</p>
<h3 id=create-persistent-volume-claim-from-an-existing-pvc>既存のPVCからの永続ボリュームクレーム作成</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloned-pvc<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>my-csi-plugin<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>existing-src-pvc-name<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></code></pre></div><h2 id=可搬性の高い設定の作成>可搬性の高い設定の作成</h2>
<p>もし幅広いクラスターで実行され、永続ボリュームが必要となる構成テンプレートやサンプルを作成している場合は、次のパターンを使用することをお勧めします。</p>
<ul>
<li>
<p>構成にPersistentVolumeClaimオブジェクトを含める(DeploymentやConfigMapと共に)</p>
</li>
<li>
<p>ユーザーが設定をインスタンス化する際にPersistentVolumeを作成する権限がない場合があるため、設定にPersistentVolumeオブジェクトを含めない。</p>
</li>
<li>
<p>テンプレートをインスタンス化する時にストレージクラス名を指定する選択肢をユーザーに与える</p>
<ul>
<li>ユーザーがストレージクラス名を指定する場合、persistentVolumeClaim.storageClassName フィールドにその値を入力する。これにより、クラスターが管理者によって有効にされたストレージクラスを持っている場合、PVCは正しいストレージクラスと一致する。</li>
<li>ユーザーがストレージクラス名を指定しない場合、<code>persistentVolumeClaim.storageClassName</code>フィールドはnilのままにする。これにより、PVはユーザーにクラスターのデフォルトストレージクラスで自動的にプロビジョニングされる。多くのクラスター環境ではデフォルトのストレージクラスがインストールされているが、管理者は独自のデフォルトストレージクラスを作成することができる。</li>
</ul>
</li>
<li>
<p>ツールがPVCを監視し、しばらくしてもバインドされないことをユーザーに表示する。これはクラスターが動的ストレージをサポートしない(この場合ユーザーは対応するPVを作成するべき)、もしくはクラスターがストレージシステムを持っていない(この場合ユーザーはPVCを必要とする設定をデプロイできない)可能性があることを示す。</p>
<h2 id=次の項目>次の項目</h2>
</li>
</ul>
<ul>
<li><a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume>Creating a Persistent Volume</a>について学ぶ</li>
<li><a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolumeclaim>Creating a Persistent Volume Claim</a>について学ぶ</li>
<li><a href=https://git.k8s.io/community/contributors/design-proposals/storage/persistent-storage.md>Persistent Storage design document</a>を読む</li>
</ul>
<h3 id=リファレンス>リファレンス</h3>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#persistentvolume-v1-core>PersistentVolume</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#persistentvolumespec-v1-core>PersistentVolumeSpec</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#persistentvolumeclaim-v1-core>PersistentVolumeClaim</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#persistentvolumeclaimspec-v1-core>PersistentVolumeClaimSpec</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-707ca81a34eb1ca202f34692e9917d1e>2 - CSI Volume Cloning</h1>
<p>このドキュメントではKubernetesで既存のCSIボリュームの複製についてのコンセプトを説明します。このページを読む前にあらかじめ<a href=/docs/concepts/storage/volumes>ボリューム</a>についてよく理解していることが望ましいです。</p>
<h2 id=イントロダクション>イントロダクション</h2>
<p><a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a>のボリューム複製機能は、ユーザーが<a class=glossary-tooltip title=データを格納するディレクトリで、Pod内のコンテナからアクセス可能です。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=ボリューム>ボリューム</a>の複製を作成することを示す<code>dataSource</code>フィールドで既存の<a class=glossary-tooltip title=コンテナ内でボリュームとしてマウントするためにPersistentVolume内で定義されたストレージリソースを要求します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PVC>PVC</a>を指定するためのサポートを追加します。</p>
<p>複製は既存のKubernetesボリュームの複製として定義され、標準のボリュームと同じように使用できます。唯一の違いは、プロビジョニング時に「新しい」空のボリュームを作成するのではなく、バックエンドデバイスが指定されたボリュームの正確な複製を作成することです。</p>
<p>複製の実装は、Kubernetes APIの観点からは新しいPVCの作成時に既存のPVCをdataSourceとして指定する機能を追加するだけです。ソースPVCはバインドされており、使用可能でなければなりません(使用中ではありません)。</p>
<p>この機能を使用する場合、ユーザーは次のことに注意する必要があります:</p>
<ul>
<li>複製のサポート(<code>VolumePVCDataSource</code>)はCSIドライバーのみです。</li>
<li>複製のサポートは動的プロビジョニングのみです。</li>
<li>CSIドライバーはボリューム複製機能を実装している場合としていない場合があります。</li>
<li>PVCは複製先のPVCと同じ名前空間に存在する場合にのみ複製できます(複製元と複製先は同じ名前空間になければなりません)。</li>
<li>複製は同じストレージクラス内でのみサポートされます。
<ul>
<li>宛先ボリュームは、ソースと同じストレージクラスである必要があります。</li>
<li>デフォルトのストレージクラスを使用でき、仕様ではstorageClassNameを省略できます。</li>
</ul>
</li>
<li>複製は同じVolumeMode設定を使用する2つのボリューム間でのみ実行できます(ブロックモードのボリュームを要求する場合、ソースもブロックモードである必要があります)。</li>
</ul>
<h2 id=プロビジョニング>プロビジョニング</h2>
<p>複製は同じ名前空間内の既存のPVCを参照するdataSourceを追加すること以外は他のPVCと同様にプロビジョニングされます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>clone-of-pvc-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>myns<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>cloning<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pvc-1<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>spec.resources.requests.storage</code>に容量の値を指定する必要があります。指定する値は、ソースボリュームの容量と同じかそれ以上である必要があります。
</div>
<p>このyamlの作成結果は指定された複製元である<code>pvc-1</code>と全く同じデータを持つ<code>clone-of-pvc-1</code>という名前の新しいPVCです。</p>
<h2 id=使い方>使い方</h2>
<p>新しいPVCが使用可能になると、複製されたPVCは他のPVCと同じように利用されます。またこの時点で新しく作成されたPVCは独立したオブジェクトであることが期待されます。元のdataSource PVCを考慮せず個別に利用、複製、スナップショット、削除できます。これはまた複製元が新しく作成された複製にリンクされておらず、新しく作成された複製に影響を与えずに変更または削除できることを意味します。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4d00116c86dade62bdd5be7dc2afa1ca>3 - VolumeSnapshotClass</h1>
<p>このドキュメントでは、Kubernetesにおける<code>VolumeSnapshotClass</code>のコンセプトについて説明します。<br>
関連する項目として、<a href=/docs/concepts/storage/volume-snapshots/>Volumeのスナップショット</a>と<a href=/docs/concepts/storage/storage-classes>ストレージクラス</a>も参照してください。</p>
<h2 id=イントロダクション>イントロダクション</h2>
<p><code>StorageClass</code>はVolumeをプロビジョンするときに、ストレージの"クラス"に関する情報を記述する方法を提供します。それと同様に、<code>VolumeSnapshotClass</code>ではVolumeSnapshotをプロビジョンするときに、ストレージの"クラス"に関する情報を記述する方法を提供します。</p>
<h2 id=volumesnapshotclass-リソース>VolumeSnapshotClass リソース</h2>
<p>各<code>VolumeSnapshotClass</code>は<code>driver</code>、<code>deletionPolicy</code>と<code>parameters</code>フィールドを含み、それらは、そのクラスに属する<code>VolumeSnapshot</code>が動的にプロビジョンされるときに使われます。</p>
<p><code>VolumeSnapshotClass</code>オブジェクトの名前は重要であり、それはユーザーがどのように特定のクラスをリクエストできるかを示したものです。管理者は初めて<code>VolumeSnapshotClass</code>オブジェクトを作成するときに、その名前と他のパラメーターをセットし、そのオブジェクトは一度作成されるとそのあと更新することができません。</p>
<p>管理者は、バインド対象のクラスを1つもリクエストしないようなVolumeSnapshotのために、デフォルトの<code>VolumeSnapshotClass</code>を指定することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></code></pre></div><h3 id=driver>Driver</h3>
<p>VolumeSnapshotClassは、VolumeSnapshotをプロビジョンするときに何のCSIボリュームプラグインを使うか決定するための<code>driver</code>フィールドを持っています。このフィールドは必須となります。</p>
<h3 id=deletionpolicy>DeletionPolicy</h3>
<p>VolumeSnapshotClassにはdeletionPolicyがあります。これにより、バインドされている <code>VolumeSnapshot</code>オブジェクトが削除されるときに、<code>VolumeSnapshotContent</code>がどうなるかを設定することができます。VolumeSnapshotのdeletionPolicyは、<code>Retain</code>または<code>Delete</code>のいずれかです。このフィールドは指定しなければなりません。</p>
<p>deletionPolicyが<code>Delete</code>の場合、元となるストレージスナップショットは <code>VolumeSnapshotContent</code>オブジェクトとともに削除されます。deletionPolicyが<code>Retain</code>の場合、元となるスナップショットと<code>VolumeSnapshotContent</code>の両方が残ります。</p>
<h2 id=parameters>Parameters</h2>
<p>VolumeSnapshotClassは、そのクラスに属するVolumeSnapshotを指定するパラメータを持っています。
<code>driver</code>に応じて様々なパラメータを使用できます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-018f0a7fc6e2f6d16da37702fc39b4f3>4 - ボリュームの動的プロビジョニング(Dynamic Volume Provisioning)</h1>
<p>ボリュームの動的プロビジョニングにより、ストレージ用のボリュームをオンデマンドに作成することができます。
動的プロビジョニングなしでは、クラスター管理者はクラウドプロバイダーまたはストレージプロバイダーに対して新規のストレージ用のボリュームと<a href=/ja/docs/concepts/storage/persistent-volumes/><code>PersistentVolume</code>オブジェクト</a>を作成するように手動で指示しなければなりません。動的プロビジョニングの機能によって、クラスター管理者がストレージを事前にプロビジョンする必要がなくなります。その代わりに、ユーザーによってリクエストされたときに自動でストレージをプロビジョンします。</p>
<h2 id=バックグラウンド>バックグラウンド</h2>
<p>ボリュームの動的プロビジョニングの実装は<code>storage.k8s.io</code>というAPIグループ内の<code>StorageClass</code>というAPIオブジェクトに基づいています。クラスター管理者は<code>StorageClass</code>オブジェクトを必要に応じていくつでも定義でき、各オブジェクトはボリュームをプロビジョンする<em>Volumeプラグイン</em> (別名<em>プロビジョナー</em>)と、プロビジョンされるときにプロビジョナーに渡されるパラメータを指定します。
クラスター管理者はクラスター内で複数の種類のストレージ(同一または異なるストレージシステム)を定義し、さらには公開でき、それらのストレージはパラメータのカスタムセットを持ちます。この仕組みにおいて、エンドユーザーはストレージがどのようにプロビジョンされるか心配する必要がなく、それでいて複数のストレージオプションから選択できることを保証します。</p>
<p>StorageClassに関するさらなる情報は<a href=/docs/concepts/storage/storage-classes/>Storage Class</a>を参照ください。</p>
<h2 id=動的プロビジョニングを有効にする>動的プロビジョニングを有効にする</h2>
<p>動的プロビジョニングを有効にするために、クラスター管理者はユーザーのために1つまたはそれ以上のStorageClassを事前に作成する必要があります。StorageClassオブジェクトは、動的プロビジョニングが実行されるときに、どのプロビジョナーが使用されるべきか、またどのようなパラメーターをプロビジョナーに渡すべきか定義します。StorageClassオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<p>下記のマニフェストでは標準的な永続化ディスクをプロビジョンする"slow"というStorageClassを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span></code></pre></div><p>下記のマニフェストではSSDを使った永続化ディスクをプロビジョンする"fast"というStorageClassを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-ssd<span style=color:#bbb>
</span></code></pre></div><h2 id=動的プロビジョニングの使用>動的プロビジョニングの使用</h2>
<p>ユーザーは<code>PersistentVolumeClaim</code>リソース内でStorageClassを含むことで、動的にプロビジョンされたStorageをリクエストできます。Kubernetes v1.6以前では、この機能は<code>volume.beta.kubernetes.io/storage-class</code>アノテーションを介して使うことができました。しかしこのアノテーションではv1.6から廃止になりました。その代わりユーザーは現在では<code>PersistentVolumeClaim</code>オブジェクトの<code>storageClassName</code>を使う必要があります。このフィールドの値は、管理者によって設定された<code>StorageClass</code>の名前と一致しなければなりません(<a href=#enabling-dynamic-provisioning>下記</a>のセクションも参照ください)。</p>
<p>"fast"というStorageClassを選択するために、例としてユーザーは下記のPersistentVolumeClaimを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>claim1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>30Gi<span style=color:#bbb>
</span></code></pre></div><p>このリソースによってSSDのような永続化ディスクが自動的にプロビジョンされます。このリソースが削除された時、そのボリュームは削除されます。</p>
<h2 id=デフォルトの挙動>デフォルトの挙動</h2>
<p>動的プロビジョニングは、もしStorageClassが1つも指定されていないときに全てのPersistentVolumeClaimが動的にプロビジョンされるようにクラスター上で有効にできます。クラスター管理者は、下記を行うことによりこのふるまいを有効にできます。</p>
<ul>
<li>1つの<code>StorageClass</code>オブジェクトを<em>default</em> としてマーキングする</li>
<li>API Server上で<a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code>管理コントローラー</a>を有効にする。</li>
</ul>
<p>管理者は<code>StorageClass</code>に対して<code>storageclass.kubernetes.io/is-default-class</code>アノテーションをつけることで、デフォルトのStorageClassとしてマーキングできます。
デフォルトの<code>StorageClass</code>がクラスター内で存在し、かつユーザーが<code>PersistentVolumeClaim</code>リソースで<code>storageClassName</code>を指定しなかった場合、<code>DefaultStorageClass</code>という管理コントローラーは<code>storageClassName</code>フィールドの値をデフォルトのStorageClassを指し示すように自動で追加します。</p>
<p>注意点として、クラスター上では最大1つしか<em>デフォルト</em> のStorageClassが指定できず、<code>storageClassName</code>を明示的に指定しない<code>PersistentVolumeClaim</code>は作成することもできません。</p>
<h2 id=トポロジーに関する注意>トポロジーに関する注意</h2>
<p><a href=/docs/setup/multiple-zones>マルチゾーン</a>クラスター内では、Podは単一のリージョン内のゾーンをまたいでしか稼働できません。シングルゾーンのStorageバックエンドはPodがスケジュールされるゾーン内でプロビジョンされる必要があります。これは<a href=/docs/concepts/storage/storage-classes/#volume-binding-mode>Volume割り当てモード</a>を設定することにより可能となります。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-00cd24f4570b7acaac75c2551c948bc7>5 - ストレージ容量</h1>
<p>ストレージ容量は、Podが実行されるノードごとに制限があったり、大きさが異なる可能性があります。たとえば、NASがすべてのノードからはアクセスできなかったり、初めからストレージがノードローカルでしか利用できない可能性があります。</p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.19 [alpha]</code>
</div>
<p>このページでは、Kubernetesがストレージ容量を追跡し続ける方法と、スケジューラーがその情報を利用して、残りの未作成のボリュームのために十分なストレージ容量へアクセスできるノード上にどのようにPodをスケジューリングするかについて説明します。もしストレージ容量の追跡がなければ、スケジューラーは、ボリュームをプロビジョニングするために十分な容量のないノードを選択してしまい、スケジューリングの再試行が複数回行われてしまう恐れがあります。</p>
<p>ストレージ容量の追跡は、<a class=glossary-tooltip title=コンテナストレージインターフェイス(CSI)はストレージシステムをコンテナに公開するための標準インターフェイスを定義します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label="Container Storage Interface">Container Storage Interface</a>(CSI)向けにサポートされており、CSIドライバーのインストール時に<a href=#enabling-storage-capacity-tracking>有効にする必要があります</a>。</p>
<h2 id=api>API</h2>
<p>この機能には、以下の2つのAPI拡張があります。</p>
<ul>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#csistoragecapacity-v1alpha1-storage-k8s-io>CSIStorageCapacity</a>オブジェクト: このオブジェクトは、CSIドライバーがインストールされた名前空間に生成されます。各オブジェクトには1つのストレージクラスに対する容量の情報が含まれ、そのストレージに対してどのノードがアクセス権を持つかが定められています。</p>
</li>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#csidriverspec-v1-storage-k8s-io><code>CSIDriverSpec.StorageCapacity</code>フィールド</a>: <code>true</code>に設定すると、Kubernetesのスケジューラーが、CSIドライバーを使用するボリュームに対してストレージ容量を考慮するようになります。</p>
</li>
</ul>
<h2 id=スケジューリング>スケジューリング</h2>
<p>ストレージ容量の情報がKubernetesのスケジューラーで利用されるのは、以下のすべての条件を満たす場合です。</p>
<ul>
<li><code>CSIStorageCapacity</code>フィーチャーゲートがtrueである</li>
<li>Podがまだ作成されていないボリュームを使用する時</li>
<li>そのボリュームが、CSIドライバーを参照し、<a href=/docs/concepts/storage/storage-classes/#volume-binding-mode>volume binding mode</a>に<code>WaitForFirstConsumer</code>を使う<a class=glossary-tooltip title=StorageClassは管理者が利用可能なさまざまなストレージタイプを記述する方法を提供します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/storage-classes target=_blank aria-label=StorageClass>StorageClass</a>を使用している</li>
<li>ドライバーに対する<code>CSIDriver</code>オブジェクトの<code>StorageCapacity</code>がtrueに設定されている</li>
</ul>
<p>その場合、スケジューラーはPodに対して、十分なストレージ容量が利用できるノードだけを考慮するようになります。このチェックは非常に単純で、ボリュームのサイズと、<code>CSIStorageCapacity</code>オブジェクトに一覧された容量を、ノードを含むトポロジーで比較するだけです。</p>
<p>volume binding modeが<code>Immediate</code>のボリュームの場合、ストレージドライバーはボリュームを使用するPodとは関係なく、ボリュームを作成する場所を決定します。次に、スケジューラーはボリュームが作成された後、Podをボリュームが利用できるノードにスケジューリングします。</p>
<p><a href=/docs/concepts/storage/volumes/#csi>CSI ephemeral volumes</a>の場合、スケジューリングは常にストレージ容量を考慮せずに行われます。このような動作になっているのは、このボリュームタイプはノードローカルな特別なCSIドライバーでのみ使用され、そこでは特に大きなリソースが必要になることはない、という想定に基づいています。</p>
<h2 id=再スケジューリング>再スケジューリング</h2>
<p><code>WaitForFirstConsumer</code>ボリュームがあるPodに対してノードが選択された場合は、その決定はまだ一時的なものです。次のステップで、CSIストレージドライバーに対して、選択されたノード上でボリュームが利用可能になることが予定されているというヒントを使用してボリュームの作成を要求します。</p>
<p>Kubernetesは古い容量の情報をもとにノードを選択する場合があるため、実際にはボリュームが作成できないという可能性が存在します。その場合、ノードの選択がリセットされ、KubernetesスケジューラーはPodに割り当てるノードを再び探します。</p>
<h2 id=制限>制限</h2>
<p>ストレージ容量を追跡することで、1回目の試行でスケジューリングが成功する可能性が高くなります。しかし、スケジューラーは潜在的に古い情報に基づいて決定を行う可能性があるため、成功を保証することはできません。通常、ストレージ容量の情報が存在しないスケジューリングと同様のリトライの仕組みによって、スケジューリングの失敗に対処します。</p>
<p>スケジューリングが永続的に失敗する状況の1つは、Podが複数のボリュームを使用する場合で、あるトポロジーのセグメントで1つのボリュームがすでに作成された後、もう1つのボリュームのために十分な容量が残っていないような場合です。この状況から回復するには、たとえば、容量を増加させたり、すでに作成されたボリュームを削除するなどの手動での対応が必要です。この問題に自動的に対処するためには、まだ<a href=https://github.com/kubernetes/enhancements/pull/1703>追加の作業</a>が必要となっています。</p>
<h2 id=enabling-storage-capacity-tracking>ストレージ容量の追跡を有効にする</h2>
<p>ストレージ容量の追跡は<em>アルファ機能</em>であり、<code>CSIStorageCapacity</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>と<code>storage.k8s.io/v1alpha1</code> <a class=glossary-tooltip title="A set of related paths in the Kubernetes API." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label="API group">API group</a>を有効にした場合にのみ、有効化されます。詳細については、<code>--feature-gates</code>および<code>--runtime-config</code> <a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserverパラメータ</a>を参照してください。</p>
<p>Kubernetesクラスターがこの機能をサポートしているか簡単に確認するには、以下のコマンドを実行して、CSIStorageCapacityオブジェクトを一覧表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get csistoragecapacities --all-namespaces
</code></pre></div><p>クラスターがCSIStorageCapacityをサポートしていれば、CSIStorageCapacityのリストが表示されるか、次のメッセージが表示されます。</p>
<pre><code>No resources found
</code></pre><p>もしサポートされていなければ、代わりに次のエラーが表示されます。</p>
<pre><code>error: the server doesn't have a resource type &quot;csistoragecapacities&quot;
</code></pre><p>クラスター内で機能を有効化することに加えて、CSIドライバーもこの機能をサポートしている必要があります。詳細については、各ドライバーのドキュメントを参照してください。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>設計に関するさらなる情報について知るために、<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1472-storage-capacity-tracking/README.md>Storage Capacity Constraints for Pod Scheduling KEP</a>を読む。</li>
<li>この機能の今後の開発に関する情報について知るために、<a href=https://github.com/kubernetes/enhancements/issues/1472>enhancement tracking issue #1472</a>を参照する。</li>
<li><a href=/ja/docs/concepts/scheduling-eviction/kube-scheduler/>Kubernetesのスケジューラー</a>についてもっと学ぶ。</li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>