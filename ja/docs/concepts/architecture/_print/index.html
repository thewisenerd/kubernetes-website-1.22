<!doctype html><html lang=ja class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/architecture/>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/concepts/architecture/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/architecture/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/architecture/>
<link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/architecture/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/architecture/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/architecture/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/architecture/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/architecture/>
<link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/architecture/>
<link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/architecture/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/concepts/architecture/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>クラスターのアーキテクチャ | Kubernetes</title><meta property="og:title" content="クラスターのアーキテクチャ">
<meta property="og:description" content="プロダクショングレードのコンテナ管理基盤">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/architecture/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="クラスターのアーキテクチャ">
<meta itemprop=description content="プロダクショングレードのコンテナ管理基盤"><meta name=twitter:card content="summary">
<meta name=twitter:title content="クラスターのアーキテクチャ">
<meta name=twitter:description content="プロダクショングレードのコンテナ管理基盤">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content>
<meta property="og:description" content>
<meta name=twitter:description content>
<meta property="og:url" content="https://kubernetes.io/ja/docs/concepts/architecture/">
<meta property="og:title" content="クラスターのアーキテクチャ">
<meta name=twitter:title content="クラスターのアーキテクチャ">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/ja/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/ja/docs/>ドキュメント</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/training/>トレーニング</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/partners/>パートナー</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/community/>コミュニティ</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/case-studies/>ケーススタディ</span></a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
バージョン
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/concepts/architecture/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/ja/docs/concepts/architecture/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/concepts/architecture/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/concepts/architecture/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/concepts/architecture/>v1.22</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
日本語 Japanese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/concepts/architecture/>English</a>
<a class=dropdown-item href=/zh/docs/concepts/architecture/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/concepts/architecture/>한국어 Korean</a>
<a class=dropdown-item href=/fr/docs/concepts/architecture/>Français</a>
<a class=dropdown-item href=/it/docs/concepts/architecture/>Italiano</a>
<a class=dropdown-item href=/de/docs/concepts/architecture/>Deutsch</a>
<a class=dropdown-item href=/es/docs/concepts/architecture/>Español</a>
<a class=dropdown-item href=/pt-br/docs/concepts/architecture/>Português</a>
<a class=dropdown-item href=/id/docs/concepts/architecture/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/architecture/>Tiếng Việt</a>
<a class=dropdown-item href=/ru/docs/concepts/architecture/>Русский</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.
</p><p>
<a href=/ja/docs/concepts/architecture/>このページの通常のビューに戻る</a>.
</p>
</div>
<h1 class=title>クラスターのアーキテクチャ</h1>
<ul>
<li>1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>ノード</a></li>
<li>2: <a href=#pg-63e7fdf87ba61eb2586bb8c625c23506>マスターとノード間の通信</a></li>
<li>3: <a href=#pg-ca8819042a505291540e831283da66df>コントローラー</a></li>
<li>4: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>クラウドコントローラーマネージャー</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>1 - ノード</h1>
<p>Kubernetesはコンテナを <em>Node</em> 上で実行されるPodに配置することで、ワークロードを実行します。
ノードはクラスターによりますが、1つのVMまたは物理的なマシンです。
各ノードは<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>やそれを制御する<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>を実行するのに必要なサービスを含んでいます。</p>
<p>通常、1つのクラスターで複数のノードを持ちます。学習用途やリソースの制限がある環境では、1ノードかもしれません。</p>
<p>1つのノード上の<a href=/ja/docs/concepts/overview/components/#node-components>コンポーネント</a>には、<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>、<a class=glossary-tooltip title=コンテナランタイムは、コンテナの実行を担当するソフトウェアです。 data-toggle=tooltip data-placement=top href=/ja/docs/setup/production-environment/container-runtimes target=_blank aria-label=コンテナランタイム>コンテナランタイム</a>、<a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>が含まれます。</p>
<h2 id=management>管理</h2>
<p>ノードを<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>に加えるには2つの方法があります:</p>
<ol>
<li>ノード上のkubeletが、コントロールプレーンに自己登録する。</li>
<li>あなた、もしくは他のユーザーが手動でNodeオブジェクトを追加する。</li>
</ol>
<p>Nodeオブジェクトの作成、もしくはノード上のkubeketによる自己登録の後、コントロールプレーンはNodeオブジェクトが有効かチェックします。例えば、下記のjsonマニフェストでノードを作成してみましょう:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
    }
  }
}
</code></pre></div><p>Kubernetesは内部的にNodeオブジェクトを作成します。 APIサーバーに登録したkubeletがノードの<code>metadata.name</code>フィールドが一致しているか検証します。ノードが有効な場合、つまり必要なサービスがすべて実行されている場合は、Podを実行する資格があります。それ以外の場合、該当ノードが有効になるまではいかなるクラスターの活動に対しても無視されます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>Kubernetesは無効なNodeのオブジェクトを保持し、それが有効になるまで検証を続けます。</p>
<p>ヘルスチェックを止めるためには、あなた、もしくは<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>が明示的にNodeを削除する必要があります。</p>
</div>
<p>Nodeオブジェクトの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<h3 id=self-registration-of-nodes>ノードの自己登録</h3>
<p>kubeletのフラグ <code>--register-node</code>がtrue（デフォルト）のとき、kubeletは自分自身をAPIサーバーに登録しようとします。これはほとんどのディストリビューションで使用されている推奨パターンです。</p>
<p>自己登録については、kubeletは以下のオプションを伴って起動されます:</p>
<ul>
<li><code>--kubeconfig</code> - 自分自身をAPIサーバーに対して認証するための資格情報へのパス</li>
<li><code>--cloud-provider</code> - 自身に関するメタデータを読むために<a class=glossary-tooltip title="An organization that offers a cloud computing platform." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-cloud-provider" target=_blank aria-label=クラウドプロバイダー>クラウドプロバイダー</a>と会話する方法</li>
<li><code>--register-node</code> - 自身をAPIサーバーに自動的に登録</li>
<li><code>--register-with-taints</code> - 与えられた<a class=glossary-tooltip title="A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups." data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taint>taint</a>のリストでノードを登録します (カンマ区切りの <code>&lt;key>=&lt;value>:&lt;effect></code>)。</li>
</ul>
<p><code>register-node</code>がfalseの場合、このオプションは機能しません</p>
<ul>
<li><code>--node-ip</code> - ノードのIPアドレス</li>
<li><code>--node-labels</code> - ノードをクラスターに登録するときに追加する<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=Label>Label</a>（<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction許可プラグイン</a>によって適用されるラベルの制限を参照）</li>
<li><code>--node-status-update-frequency</code> - kubeletがノードのステータスをマスターにPOSTする頻度の指定</li>
</ul>
<p><a href=/docs/reference/access-authn-authz/node/>ノード認証モード</a>および<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction許可プラグイン</a>が有効になっている場合、kubeletは自分自身のノードリソースを作成/変更することのみ許可されています。</p>
<h3 id=manual-node-administration>手動によるノード管理</h3>
<p>クラスター管理者は<a class=glossary-tooltip title="A command line tool for communicating with a Kubernetes API server." data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>を使用してNodeオブジェクトを作成および変更できます。</p>
<p>管理者が手動でNodeオブジェクトを作成したい場合は、kubeletフラグ <code>--register-node = false</code>を設定してください。</p>
<p>管理者は<code>--register-node</code>の設定に関係なくNodeオブジェクトを変更することができます。
例えば、ノードにラベルを設定し、それをunschedulableとしてマークすることが含まれます。</p>
<p>ノード上のラベルは、スケジューリングを制御するためにPod上のノードセレクターと組み合わせて使用できます。
例えば、Podをノードのサブセットでのみ実行する資格があるように制限します。</p>
<p>ノードをunschedulableとしてマークすると、新しいPodがそのノードにスケジュールされるのを防ぎますが、ノード上の既存のPodには影響しません。
これは、ノードの再起動などの前の準備ステップとして役立ちます。</p>
<p>ノードにスケジュール不可能のマークを付けるには、次のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cordon $ノード名
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>によって作成されたPodはノード上のunschedulable属性を考慮しません。
これは、再起動の準備中にアプリケーションからアプリケーションが削除されている場合でも、DaemonSetがマシンに属していることを前提としているためです。
</div>
<h2 id=ノードのステータス>ノードのステータス</h2>
<p>ノードのステータスは以下の情報を含みます:</p>
<ul>
<li><a href=#addresses>Addresses</a></li>
<li><a href=#condition>Conditions</a></li>
<li><a href=#capacity>CapacityとAllocatable</a></li>
<li><a href=#info>Info</a></li>
</ul>
<p><code>kubectl</code>を使用し、ノードのステータスや詳細を確認できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe node &lt;ノード名をここに挿入&gt;
</code></pre></div><p>出力情報の各箇所について、以下で説明します。</p>
<h3 id=addresses>Addresses</h3>
<p>これらのフィールドの使い方は、お使いのクラウドプロバイダーやベアメタルの設定内容によって異なります。</p>
<ul>
<li>HostName: ノードのカーネルによって伝えられたホスト名です。kubeletの<code>--hostname-override</code>パラメーターによって上書きすることができます。</li>
<li>ExternalIP: 通常は、外部にルーティング可能(クラスターの外からアクセス可能)なノードのIPアドレスです。</li>
<li>InternalIP: 通常は、クラスター内でのみルーティング可能なノードのIPアドレスです。</li>
</ul>
<h3 id=condition>Conditions</h3>
<p><code>conditions</code>フィールドは全ての<code>Running</code>なノードのステータスを表します。例として、以下のような状態を含みます:</p>
<table><caption style=display:none>ノードのConditionと、各condition適用時の概要</caption>
<thead>
<tr>
<th>ノードのCondition</th>
<th>概要</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ready</code></td>
<td>ノードの状態が有効でPodを配置可能な場合に<code>True</code>になります。ノードの状態に問題があり、Podが配置できない場合に<code>False</code>になります。ノードコントローラーが、<code>node-monitor-grace-period</code>で設定された時間内(デフォルトでは40秒)に該当ノードと疎通できない場合、<code>Unknown</code>になります。</td>
</tr>
<tr>
<td><code>DiskPressure</code></td>
<td>ノードのディスク容量が圧迫されているときに<code>True</code>になります。圧迫とは、ディスクの空き容量が少ないことを指します。それ以外のときは<code>False</code>です。</td>
</tr>
<tr>
<td><code>MemoryPressure</code></td>
<td>ノードのメモリが圧迫されているときに<code>True</code>になります。圧迫とは、メモリの空き容量が少ないことを指します。それ以外のときは<code>False</code>です。</td>
</tr>
<tr>
<td><code>PIDPressure</code></td>
<td>プロセスが圧迫されているときに<code>True</code>になります。圧迫とは、プロセス数が多すぎることを指します。それ以外のときは<code>False</code>です。</td>
</tr>
<tr>
<td><code>NetworkUnavailable</code></td>
<td>ノードのネットワークが適切に設定されていない場合に<code>True</code>になります。それ以外のときは<code>False</code>です。</td>
</tr>
</tbody>
</table>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> コマンドラインを使用してcordonされたNodeを表示する場合、Conditionは<code>SchedulingDisabled</code>を含みます。
<code>SchedulingDisabled</code>はKubernetesのAPIにおけるConditionではありません;その代わり、cordonされたノードはUnschedulableとしてマークされます。
</div>
<p>ノードのConditionはJSONオブジェクトで表現されます。例えば、正常なノードの場合は以下のような構造体が表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
  {
    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
  }
]
</code></pre></div><p>Ready conditionが<code>pod-eviction-timeout</code>(<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>に渡された引数)に設定された時間を超えても<code>Unknown</code>や<code>False</code>のままになっている場合、該当ノード上にあるPodはノードコントローラーによって削除がスケジュールされます。デフォルトの退役のタイムアウトの時間は<strong>5分</strong>です。ノードが到達不能ないくつかの場合においては、APIサーバーが該当ノードのkubeletと疎通できない状態になっています。その場合、APIサーバーがkubeletと再び通信を確立するまでの間、Podの削除を行うことはできません。削除がスケジュールされるまでの間、削除対象のPodは切り離されたノードの上で稼働を続けることになります。</p>
<p>ノードコントローラーはクラスター内でPodが停止するのを確認するまでは強制的に削除しないようになりました。到達不能なノード上で動いているPodは<code>Terminating</code>または<code>Unknown</code>のステータスになります。Kubernetesが基盤となるインフラストラクチャーを推定できない場合、クラスター管理者は手動でNodeオブジェクトを削除する必要があります。KubernetesからNodeオブジェクトを削除すると、そのノードで実行されているすべてのPodオブジェクトがAPIサーバーから削除され、それらの名前が解放されます。</p>
<p>ノードのライフサイクルコントローラーがconditionを表した<a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>taint</a>を自動的に生成します。
スケジューラーがPodをノードに割り当てる際、ノードのtaintを考慮します。Podが許容するtaintは例外です。</p>
<p>詳細は<a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/#taint-nodes-by-condition>条件によるtaintの付与</a>を参照してください。</p>
<h3 id=capacity>CapacityとAllocatable</h3>
<p>ノードで利用可能なリソース（CPU、メモリ、およびノードでスケジュールできる最大Pod数）について説明します。</p>
<p>capacityブロック内のフィールドは、ノードが持っているリソースの合計量を示します。
allocatableブロックは、通常のPodによって消費されるノード上のリソースの量を示します。</p>
<p>CapacityとAllocatableについて深く知りたい場合は、ノード上でどのように<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>コンピュートリソースが予約されるか</a>を読みながら学ぶことができます。</p>
<h3 id=info>Info</h3>
<p>カーネルのバージョン、Kubernetesのバージョン（kubeletおよびkube-proxyのバージョン）、（使用されている場合）Dockerのバージョン、OS名など、ノードに関する一般的な情報です。
この情報はノードからkubeletを通じて取得されます。</p>
<h2 id=management>管理</h2>
<p><a href=/ja/docs/concepts/workloads/pods/pod/>Pod</a>や<a href=/ja/docs/concepts/services-networking/service/>Service</a>と違い、ノードは本質的にはKubernetesによって作成されません。GCPのようなクラウドプロバイダーによって外的に作成されるか、VMや物理マシンのプールに存在するものです。そのため、Kubernetesがノードを作成すると、そのノードを表すオブジェクトが作成されます。作成後、Kubernetesはそのノードが有効かどうかを確認します。 たとえば、次の内容からノードを作成しようとしたとします:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
    }
  }
}
</code></pre></div><p>Kubernetesは内部的にNodeオブジェクトを作成し、 <code>metadata.name</code>フィールドに基づくヘルスチェックによってノードを検証します。ノードが有効な場合、つまり必要なサービスがすべて実行されている場合は、Podを実行する資格があります。それ以外の場合、該当ノードが有効になるまではいかなるクラスターの活動に対しても無視されます。
Nodeオブジェクトの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Kubernetesは無効なノードのためにオブジェクトを保存し、それをチェックし続けます。
このプロセスを停止するには、Nodeオブジェクトを明示的に削除する必要があります。
</div>
<p>現在、Kubernetesのノードインターフェースと相互作用する3つのコンポーネントがあります。ノードコントローラー、kubelet、およびkubectlです。</p>
<h3 id=ノードコントローラー>ノードコントローラー</h3>
<p>ノード<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>は、ノードのさまざまな側面を管理するKubernetesのコントロールプレーンコンポーネントです。</p>
<p>ノードコントローラーは、ノードの存続期間中に複数の役割を果たします。1つ目は、ノードが登録されたときにCIDRブロックをノードに割り当てることです（CIDR割り当てがオンになっている場合）。</p>
<p>2つ目は、ノードコントローラーの内部ノードリストをクラウドの利用可能なマシンのリストと一致させることです。
クラウド環境で実行している場合、ノードに異常があると、ノードコントローラーはクラウドプロバイダーにそのNodeのVMがまだ使用可能かどうかを問い合わせます。
使用可能でない場合、ノードコントローラーはノードのリストから該当ノードを削除します。</p>
<p>3つ目は、ノードの状態を監視することです。
ノードが到達不能(例えば、ノードがダウンしているなどので理由で、ノードコントローラーがハートビートの受信を停止した場合)になると、ノードコントローラーは、NodeStatusのNodeReady conditionをConditionUnknownに変更する役割があります。その後も該当ノードが到達不能のままであった場合、Graceful Terminationを使って全てのPodを退役させます。デフォルトのタイムアウトは、ConditionUnknownの報告を開始するまで40秒、その後Podの追い出しを開始するまで5分に設定されています。
ノードコントローラーは、<code>--node-monitor-period</code>に設定された秒数ごとに各ノードの状態をチェックします。</p>
<h4 id=ハートビート>ハートビート</h4>
<p>ハートビートは、Kubernetesノードから送信され、ノードが利用可能か判断するのに役立ちます。
２つのハートビートがあります：<code>NodeStatus</code>の更新と<a href=/docs/reference/generated/kubernetes-api/v1.26#lease-v1-coordination-k8s-io>Lease object</a>です。
各ノードは<code>kube-node-lease</code>という<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>に関連したLeaseオブジェクトを持ちます。
Leaseは軽量なリソースで、クラスターのスケールに応じてノードのハートビートにおけるパフォーマンスを改善します。</p>
<p>kubeletが<code>NodeStatus</code>とLeaseオブジェクトの作成および更新を担当します。</p>
<ul>
<li>kubeletは、ステータスに変化があったり、設定した間隔の間に更新がない時に<code>NodeStatus</code>を更新します。<code>NodeStatus</code>更新のデフォルト間隔は５分です。（到達不能の場合のデフォルトタイムアウトである40秒よりもはるかに長いです）</li>
<li>kubeletは10秒間隔(デフォルトの更新間隔)でLeaseオブジェクトの生成と更新を実施します。Leaseの更新は<code>NodeStatus</code>の更新とは独立されて行われます。Leaseの更新が失敗した場合、kubeletは200ミリ秒から始まり7秒を上限とした指数バックオフでリトライします。</li>
</ul>
<h4 id=信頼性>信頼性</h4>
<p>ほとんどの場合、排除の速度は1秒あたり<code>--node-eviction-rate</code>に設定された数値（デフォルトは秒間0.1）です。つまり、10秒間に1つ以上のPodをノードから追い出すことはありません。</p>
<p>特定のアベイラビリティーゾーン内のノードのステータスが異常になると、ノード排除の挙動が変わります。ノードコントローラーは、ゾーン内のノードの何%が異常（NodeReady条件がConditionUnknownまたはConditionFalseである）であるかを同時に確認します。
異常なノードの割合が少なくとも <code>--healthy-zone-threshold</code>に設定した値を下回る場合（デフォルトは0.55）であれば、退役率は低下します。クラスターが小さい場合（すなわち、 <code>--large-cluster-size-threshold</code>の設定値よりもノード数が少ない場合。デフォルトは50）、退役は停止し、そうでない場合、退役率は秒間で<code>--secondary-node-eviction-rate</code>の設定値（デフォルトは0.01）に減少します。
これらのポリシーがアベイラビリティーゾーンごとに実装されているのは、1つのアベイラビリティーゾーンがマスターから分割される一方、他のアベイラビリティーゾーンは接続されたままになる可能性があるためです。
クラスターが複数のクラウドプロバイダーのアベイラビリティーゾーンにまたがっていない場合、アベイラビリティーゾーンは1つだけです（クラスター全体）。</p>
<p>ノードを複数のアベイラビリティゾーンに分散させる主な理由は、1つのゾーン全体が停止したときにワークロードを正常なゾーンに移動できることです。
したがって、ゾーン内のすべてのノードが異常である場合、ノードコントローラーは通常のレート <code>--node-eviction-rate</code>で退役します。
コーナーケースは、すべてのゾーンが完全にUnhealthyである（すなわち、クラスタ内にHealthyなノードがない）場合です。
このような場合、ノードコントローラーはマスター接続に問題があると見なし、接続が回復するまですべての退役を停止します。</p>
<p>ノードコントローラーは、Podがtaintを許容しない場合、 <code>NoExecute</code>のtaintを持つノード上で実行されているPodを排除する責務もあります。
さらに、ノードコントローラーはノードに到達できない、または準備ができていないなどのノードの問題に対応する<a class=glossary-tooltip title="A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups." data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taint>taint</a>を追加する責務があります。これはスケジューラーが、問題のあるノードにPodを配置しない事を意味しています。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <code>kubectl cordon</code>はノードに'unschedulable'としてマークします。それはロードバランサーのターゲットリストからノードを削除するという
サービスコントローラーの副次的な効果をもたらします。これにより、ロードバランサトラフィックの流入をcordonされたノードから効率的に除去する事ができます。
</div>
<h3 id=ノードのキャパシティ>ノードのキャパシティ</h3>
<p>Nodeオブジェクトはノードのリソースキャパシティ（CPUの数とメモリの量）を監視します。
<a href=#self-registration-of-nodes>自己登録</a>したノードは、Nodeオブジェクトを作成するときにキャパシティを報告します。
<a href=#manual-node-administration>手動によるノード管理</a>を実行している場合は、ノードを追加するときにキャパシティを設定する必要があります。</p>
<p>Kubernetes<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=スケジューラー>スケジューラー</a>は、ノード上のすべてのPodに十分なリソースがあることを確認します。スケジューラーは、ノード上のコンテナが要求するリソースの合計がノードキャパシティ以下であることを確認します。
これは、kubeletによって管理されたすべてのコンテナを含みますが、コンテナランタイムによって直接開始されたコンテナやkubeletの制御外で実行されているプロセスは含みません。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Pod以外のプロセス用にリソースを明示的に予約したい場合は、<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>Systemデーモン用にリソースを予約</a>を参照してください。
</div>
<h2 id=ノードのトポロジー>ノードのトポロジー</h2>
<p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code>
</div>
<code>TopologyManager</code>の<a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にすると、
kubeletはリソースの割当を決定する際にトポロジーのヒントを利用できます。
詳細は、<a href=/docs/tasks/administer-cluster/topology-manager/>ノードのトポロジー管理ポリシーを制御する</a>を参照してください。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/overview/components/#node-components>ノードコンポーネント</a>について学習する。</li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#node-v1-core>Node APIオブジェクト</a>について読む。</li>
<li>アーキテクチャ設計文書の<a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>Node</a>という章を読む。</li>
<li><a href=/ja/docs/concepts/scheduling-eviction/taint-and-toleration/>TaintとToleration</a>について読む。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-63e7fdf87ba61eb2586bb8c625c23506>2 - マスターとノード間の通信</h1>
<p>本ドキュメントでは、KubernetesにおけるMaster(実態はAPIサーバー)およびクラスター間のコミュニケーション経路についてまとめます。
この文書の目的は、信頼できないネットワーク上(またはクラウドプロバイダ上の完全にパブリックなIP上)でクラスタを実行できるように、ユーザーがインストールをカスタマイズしてネットワーク構成を強化できるようにすることです。</p>
<h2 id=クラスターからマスターへの通信>クラスターからマスターへの通信</h2>
<p>クラスターからマスターへのすべての通信経路は、APIサーバーで終端します(他のマスターコンポーネントはどれもリモートサービスを公開するように設計されていません)。
一般的には、1つ以上の形式のクライアント<a href=/docs/reference/access-authn-authz/authentication/>認証</a>が有効になっている状態で、APIサーバーはセキュアなHTTPSポート(443)でリモート接続をlistenするように構成されています。
特に<a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>匿名のリクエスト</a>または<a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>サービスアカウントトークン</a>が許可されている場合は、1つまたは複数の<a href=/docs/reference/access-authn-authz/authorization/>認証</a>を有効にする必要があります。</p>
<p>ノードには、有効なクライアント認証情報を使って安全にAPIサーバーに接続できるように、クラスターのパブリックなルート証明書をプロビジョニングする必要があります。
たとえば、GKEのデフォルト設定では、kubeletに提供されるクライアント認証情報はクライアント証明書の形式です。
kubeletのクライアント証明書を自動プロビジョニングする方法については、<a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLSブートストラッピング</a>を参照してください。</p>
<p>APIサーバーに接続したいPodは、サービスアカウントを利用することで接続を安全にすることができます。そうすることで、Podが作成されたときにKubernetesがパブリックなルート証明書と有効なBearer TokenをPodに自動的に挿入します。</p>
<p><code>kubernetes</code>サービスには(すべてのネームスペースで)、APIサーバー上のHTTPSエンドポイントに(kube-proxy経由で)リダイレクトされる仮想IPアドレスが設定されています。</p>
<p>マスターコンポーネントは、セキュアなポートを介してクラスターAPIサーバーとも通信します。</p>
<p>その結果、クラスター(ノードとそのノードで実行されているPod)からマスターへの接続はデフォルトで保護され、信頼できないネットワークやパブリックネットワークを介して実行できます。</p>
<h2 id=マスターからクラスターへの通信>マスターからクラスターへの通信</h2>
<p>マスター(APIサーバー)からクラスターへの通信には、2つの主要な通信経路があります。
1つ目は、APIサーバーからクラスター内の各ノードで実行されるkubeletプロセスへの通信です。
2つ目は、APIサーバーのプロキシ機能を介した、APIサーバーから任意のノード、Pod、またはサービスへのアクセスです。</p>
<h3 id=apiサーバーからkubeletへの通信>APIサーバーからkubeletへの通信</h3>
<p>APIサーバーからkubeletへの接続は以下の目的で使用されます:</p>
<ul>
<li>Podのログを取得する</li>
<li>実行中のPodに(kubectlを通して)接続する</li>
<li>kubeletのポート転送機能を提供する</li>
</ul>
<p>これらの接続は、kubeletのHTTPSエンドポイントで終了します。
デフォルトでは、APIサーバーはkubeletが提供する証明書を検証しないため、接続は中間者攻撃を受けやすく、<strong>安全でない</strong>信頼できないネットワークやパブリックなネットワークを介して実行されることになります。</p>
<p>この接続を検証するには、<code>--kubelet-certificate-authority</code>フラグを使用して、kubeletが提供する証明書を確認するために使用するルート証明書バンドルをAPIサーバーに提供します。</p>
<p>それができない場合は、信頼できないネットワークやパブリックなネットワークを介した接続を回避するために、必要に応じてAPIサーバーとkubeletの間でSSHトンネリングを使用してください。</p>
<p>最後に、kubeletのAPIを保護するために<a href=/docs/admin/kubelet-authentication-authorization/>kubeletの認証認可</a>を有効にする必要があります。</p>
<h3 id=apiサーバーからノード-pod-サービスへの通信>APIサーバーからノード、Pod、サービスへの通信</h3>
<p>APIサーバーからノード、Pod、またはサービスへの接続はデフォルトで平文のHTTP接続になるため、認証も暗号化もされません。
API URL内のノード、Pod、またはサービス名に<code>https:</code>を付けることで安全なHTTPS接続で実行できますが、HTTPSエンドポイントから提供される証明書を検証したりクライアントの資格情報を提供したりすることはありませんし、暗号化されているという完全性を保証するものでもありません。
これらの接続を信頼できないネットワークや公衆ネットワークを介して実行するのは、現時点において安全ではありません。</p>
<h3 id=sshトンネル>SSHトンネル</h3>
<p>Kubernetesはマスターからクラスターへの通信経路を保護するためにSSHトンネルをサポートしています。
この設定では、APIサーバーはクラスター内の各ノード(ポート22でlistenしているsshサーバーに接続)へのSSHトンネルを開始し、トンネルを介してkubelet、ノード、Pod、またはサービス宛てのすべてのトラフィックを渡します。
このトンネルにより、ノードが実行されているネットワークの外部にトラフィックが公開されないようにします。</p>
<p>SSHトンネルは現在非推奨なので、自分がしていることが分からない限り、使用しないでください。この通信チャネルに代わるものが設計されています。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ca8819042a505291540e831283da66df>3 - コントローラー</h1>
<p>ロボット工学やオートメーションの分野において、 <em>制御ループ</em> とは、あるシステムの状態を制御する終了状態のないループのことです。</p>
<p>ここでは、制御ループの一例として、部屋の中にあるサーモスタットを挙げます。</p>
<p>あなたが温度を設定すると、それはサーモスタットに <em>目的の状態(desired state)</em> を伝えることになります。実際の部屋の温度は <em>現在の状態</em> です。サーモスタットは、装置をオンまたはオフにすることによって、現在の状態を目的の状態に近づけるように動作します。</p>
Kubernetesにおいて、コントローラーは<a class=glossary-tooltip title=コンテナ化されたアプリケーションを実行する、ノードと呼ばれるワーカーマシンの集合です。すべてのクラスターには少なくとも1つのワーカーノードがあります。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-cluster" target=_blank aria-label=クラスター>クラスター</a>の状態を監視し、必要に応じて変更を加えたり要求したりする制御ループです。それぞれのコントローラーは現在のクラスターの状態を望ましい状態に近づけるように動作します。
<h2 id=コントローラーパターン>コントローラーパターン</h2>
<p>コントローラーは少なくとも1種類のKubernetesのリソースを監視します。これらの<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>オブジェクト</a>には目的の状態を表すspecフィールドがあります。リソースのコントローラーは、現在の状態を目的の状態に近づける責務を持ちます。</p>
<p>コントローラーは自分自身でアクションを実行する場合もありますが、Kubernetesではコントローラーが<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>に意味のある副作用を持つメッセージを送信することが一般的です。以下では、このような例を見ていきます。</p>
<h3 id=apiサーバー経由でコントロールする>APIサーバー経由でコントロールする</h3>
<p><a class=glossary-tooltip title="A finite or batch task that runs to completion." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>コントローラーはKubernetesのビルトインのコントローラーの一例です。ビルトインのコントローラーは、クラスターのAPIサーバーとやりとりをして状態を管理します。</p>
<p>Jobは、1つ以上の<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>を起動して、タスクを実行した後に停止する、Kubernetesのリソースです。</p>
<p>(1度<a href=/ja/docs/concepts/scheduling-eviction/>スケジュール</a>されると、Podオブジェクトはkubeletに対する目的の状態の一部になります。)</p>
<p>Jobコントローラーが新しいタスクを見つけると、その処理が完了するように、クラスター上のどこかで、一連のNode上のkubeletが正しい数のPodを実行することを保証します。ただし、Jobコントローラーは、自分自身でPodやコンテナを実行することはありません。代わりに、APIサーバーに対してPodの作成や削除を依頼します。<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label=コントロールプレーン>コントロールプレーン</a>上の他のコンポーネントが(スケジュールして実行するべき新しいPodが存在するという)新しい情報を基に動作することによって、最終的に目的の処理が完了します。</p>
<p>新しいJobが作成されたとき、目的の状態は、そのJobが完了することです。JobコントローラーはそのJobに対する現在の状態を目的の状態に近づけるようにします。つまり、そのJobが行ってほしい処理を実行するPodを作成し、Jobが完了に近づくようにします。</p>
<p>コントローラーは、コントローラーを設定するオブジェクトも更新します。たとえば、あるJobが完了した場合、Jobコントローラーは、Jobオブジェクトに<code>Finished</code>というマークを付けます。</p>
<p>(これは、部屋が設定温度になったことを示すために、サーモスタットがランプを消灯するのに少し似ています。)</p>
<h3 id=直接的なコントロール>直接的なコントロール</h3>
<p>Jobとは対照的に、クラスターの外部に変更を加える必要があるコントローラーもあります。</p>
<p>たとえば、クラスターに十分な数の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>が存在することを保証する制御ループの場合、そのコントローラーは、必要に応じて新しいNodeをセットアップするために、現在のクラスターの外部とやりとりをする必要があります。</p>
<p>外部の状態とやりとりをするコントローラーは、目的の状態をAPIサーバーから取得した後、外部のシステムと直接通信し、現在の状態を目的の状態に近づけます。</p>
<p>(クラスター内のノードを水平にスケールさせる<a href=https://github.com/kubernetes/autoscaler/>コントローラー</a>が実際に存在します。)</p>
<p>ここで重要な点は、コントローラーが目的の状態を実現するために変更を加えてから、現在の状態をクラスターのAPIサーバーに報告することです。他の制御ループは、その報告されたデータを監視し、独自のアクションを実行できます。</p>
<p>サーモスタットの例では、部屋が非常に寒い場合、別のコントローラーが霜防止ヒーターをオンにすることもあります。Kubernetesクラスターを使用すると、コントロールプレーンは、<a href=/ja/docs/concepts/extend-kubernetes/>Kubernetesを拡張して</a>実装することにより、IPアドレス管理ツールやストレージサービス、クラウドプロバイダーAPI、およびその他のサービスと間接的に連携します。</p>
<h2 id=desired-vs-current>目的の状態 vs 現在の状態</h2>
<p>Kubernetesはシステムに対してクラウドネイティブな見方をするため、常に変化し続けるような状態を扱えるように設計されています。</p>
<p>処理を実行したり、制御ループが故障を自動的に修正したりしているどの時点でも、クラスターは変化中である可能性があります。つまり、クラスターは決して安定した状態にならない可能性があるということです。</p>
<p>コントローラーがクラスターのために実行されていて、有用な変更が行われるのであれば、全体的な状態が安定しているかどうかは問題にはなりません。</p>
<h2 id=設計>設計</h2>
<p>設計理念として、Kubernetesは多数のコントローラーを使用しており、各コントローラーはクラスターの状態の特定の側面をそれぞれ管理しています。最もよくあるパターンは、特定の制御ループ(コントローラー)が目的の状態として1種類のリソースを使用し、目的の状態を実現することを管理するために別の種類のリソースを用意するというものです。たとえば、Jobのコントローラーは、Jobオブジェクト(新しい処理を見つけるため)およびPodオブジェクト(Jobを実行し、処理が完了したか確認するため)を監視します。この場合、なにか別のものがJobを作成し、JobコントローラーはPodを作成します。</p>
<p>相互にリンクされた単一のモノリシックな制御ループよりは、複数の単純なコントローラーが存在する方が役に立ちます。コントローラーは故障することがあるため、Kubernetesは故障を許容するように設計されています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>同じ種類のオブジェクトを作成または更新するコントローラーが、複数存在する場合があります。実際には、Kubernetesコントローラーは、自分が制御するリソースに関連するリソースにのみ注意を払うように作られています。</p>
<p>たとえば、DeploymentとJobがありますが、これらは両方ともPodを作成するものです。しかし、JobコントローラーはDeploymentが作成したPodを削除することはありません。各コントローラーが2つのPodを区別できる情報(<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=ラベル>ラベル</a>)が存在するためです。</p>
</div>
<h2 id=running-controllers>コントローラーを実行する方法</h2>
<p>Kubernetesには、<a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>内部で動作する一組のビルトインのコントローラーが用意されています。これらビルトインのコントローラーは、コアとなる重要な振る舞いを提供します。</p>
<p>DeploymentコントローラーとJobコントローラーは、Kubernetes自体の一部として同梱されているコントローラーの例です(それゆえ「ビルトイン」のコントローラーと呼ばれます)。Kubernetesは回復性のあるコントロールプレーンを実行できるようにしているため、ビルトインのコントローラーの一部が故障しても、コントロールプレーンの別の部分が作業を引き継いでくれます。</p>
<p>Kubernetesを拡張するためにコントロールプレーンの外で動作するコントローラーもあります。もし望むなら、新しいコントローラーを自分で書くこともできます。自作のコントローラーをPodセットとして動作させたり、Kubernetesの外部で動作させることもできます。どのような動作方法が最も適しているかは、そのコントローラーがどのようなことを行うのかに依存します。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/#kubernetes-control-plane>Kubernetesコントロールプレーン</a>について読む</li>
<li>基本的な<a href=/ja/docs/concepts/#kubernetes-objects>Kubernetesオブジェクト</a>について学ぶ</li>
<li><a href=/ja/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>について学ぶ</li>
<li>自分でコントローラーを書きたい場合は、「Kubernetesを拡張する」の<a href=/ja/docs/concepts/extend-kubernetes/extend-cluster/#extension-patterns>エクステンションパターン</a>を読んでください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>4 - クラウドコントローラーマネージャー</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p>クラウドインフラストラクチャー技術により、パブリック、プライベート、ハイブリッドクラウド上でKubernetesを動かすことができます。Kubernetesは、コンポーネント間の密なつながりが不要な自動化されたAPI駆動インフラストラクチャーを信条としています。</p>
<p><p>cloud-controller-managerは クラウド特有の制御ロジックを組み込むKubernetesの<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="control plane">control plane</a>コンポーネントです。クラウドコントロールマネージャーは、クラスターをクラウドプロバイダーAPIをリンクし、クラスタのみで相互作用するコンポーネントからクラウドプラットフォームで相互作用するコンポーネントを分離します。</p></p>
<p>Kubernetesと下のクラウドインフラストラクチャー間の相互運用ロジックを分離することで、cloud-controller-managerコンポーネントはクラウドプロバイダを主なKubernetesプロジェクトと比較し異なるペースで機能をリリース可能にします。</p>
<p>cloud-controller-managerは、プラグイン機構を用い、異なるクラウドプロバイダーに対してそれぞれのプラットフォームとKubernetesの結合を可能にする構成になっています。</p>
<h2 id=設計>設計</h2>
<p><img src=/images/docs/components-of-kubernetes.svg alt=Kubernetesのコンポーネント></p>
<p>クラウドコントローラーマネージャーは、複製されたプロセスの集合としてコントロールプレーンで実行されます。（通常、Pod内のコンテナとなります）各cloud-controller-managerは、シングルプロセスで複数の<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a>を実装します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> コントロールプレーンの一部ではなく、Kubernetesの<a class=glossary-tooltip title="Resources that extend the functionality of Kubernetes." data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=addon>addon</a>としてクラウドコントローラーマネージャーを実行することもできます。
</div>
<h2 id=functions-of-the-ccm>クラウドコントローラーマネージャーの機能</h2>
<p>クラウドコントローラーマネージャーのコントローラーは以下を含んでいます。</p>
<h4 id=ノードコントローラー>ノードコントローラー</h4>
<p>ノードコントローラーは、クラウドインフラストラクチャーで新しいサーバーが作成された際に、<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>オブジェクトを作成する責務を持ちます。ノードコントローラーは、クラウドプロバイダーのテナント内で動作しているホストの情報を取得します。ノードコントローラーは下記に示す機能を実行します:</p>
<ol>
<li>Nodeオブジェクトを、コントローラーがクラウドプロバイダーAPIを通じて見つけた各サーバーで初期化する</li>
<li>Nodeオブジェクトに、ノードがデプロイされているリージョンや利用可能なリソース（CPU、メモリなど）のようなクラウド特有な情報を注釈付けやラベル付けをする</li>
<li>ノードのホスト名とネットワークアドレスを取得する</li>
<li>ノードの正常性を検証する。ノードが応答しなくなった場合、クラウドプロバイダーのAPIを利用しサーバーがdeactivated / deleted / terminatedであるかを確認する。クラウドからノードが削除されていた場合、KubernetesクラスターからNodeオブジェクトを削除する</li>
</ol>
<p>いくつかのクラウドプロバイダーは、これをノードコントローラーと個別のノードライフサイクルコントローラーに分けて実装しています。</p>
<h4 id=ルートコントローラー>ルートコントローラー</h4>
<p>ルートコントローラーは、クラスタ内の異なるノード上で稼働しているコンテナが相互に通信できるように、クラウド内のルートを適切に設定する責務を持ちます。</p>
<p>クラウドプロバイダーによっては、ルートコントローラーはPodネットワークのIPアドレスのブロックを割り当てることもあります。</p>
<h4 id=サービスコントローラー>サービスコントローラー</h4>
<p><a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Services>Services</a>は、マネージドロードバランサー、IPアドレスネットワークパケットフィルタや対象のヘルスチェックのようなクラウドインフラストラクチャーコンポーネントのインテグレーションを行います。サービスコントローラーは、ロードバランサーや他のインフラストラクチャーコンポーネントを必要とするServiceリソースを宣言する際にそれらのコンポーネントを設定するため、クラウドプロバイダーのAPIと対話します。</p>
<h2 id=認可>認可</h2>
<p>このセクションでは、クラウドコントローラーマネージャーが操作を行うために様々なAPIオブジェクトに必要な権限を分類します。</p>
<h3 id=authorization-node-controller>ノードコントローラー</h3>
<p>ノードコントローラーはNodeオブジェクトのみに対して働きます。Nodeオブジェクトに対して、readとmodifyの全権限が必要です。</p>
<p><code>v1/Node</code>:</p>
<ul>
<li>Get</li>
<li>List</li>
<li>Create</li>
<li>Update</li>
<li>Patch</li>
<li>Watch</li>
<li>Delete</li>
</ul>
<h3 id=authorization-route-controller>ルートコントローラー </h3>
<p>ルートコントローラーは、Nodeオブジェクトの作成を待ち受け、ルートを適切に設定します。Nodeオブジェクトについて、get権限が必要です。</p>
<p><code>v1/Node</code>:</p>
<ul>
<li>Get</li>
</ul>
<h3 id=authorization-service-controller>サービスコントローラー</h3>
<p>サービスコントローラーは、Serviceオブジェクトの作成、更新、削除イベントを待ち受け、その後、サービスのEndpointを適切に設定します。</p>
<p>サービスにアクセスするため、list、watchの権限が必要です。サービスを更新するため、patch、updateの権限が必要です。</p>
<p>サービスのEndpointリソースを設定するため、create、list、get、watchそしてupdateの権限が必要です。</p>
<p><code>v1/Service</code>:</p>
<ul>
<li>List</li>
<li>Get</li>
<li>Watch</li>
<li>Patch</li>
<li>Update</li>
</ul>
<h3 id=authorization-miscellaneous>その他</h3>
<p>クラウドコントローラーマネージャーのコア機能の実装は、Eventオブジェクトのcreate権限と、セキュアな処理を保証するため、ServiceAccountのcreate権限が必要です。</p>
<p><code>v1/Event</code>:</p>
<ul>
<li>Create</li>
<li>Patch</li>
<li>Update</li>
</ul>
<p><code>v1/ServiceAccount</code>:</p>
<ul>
<li>Create</li>
</ul>
<p>クラウドコントローラーマネージャーの<a class=glossary-tooltip title="Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API." data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a> ClusterRoleはこのようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></code></pre></div><h2 id=次の項目>次の項目</h2>
<p><a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>Cloud Controller Manager Administration</a>
はクラウドコントラーマネージャーの実行と管理を説明しています。</p>
<p>どのようにあなた自身のクラウドコントローラーマネージャーが実装されるのか、もしくは既存プロジェクトの拡張について知りたいですか？</p>
<p>クラウドコントローラーマネージャーは、いかなるクラウドからもプラグインとしての実装を許可するためにGoインターフェースを使います。具体的には、<a href=https://github.com/kubernetes/cloud-provider>kubernetes/cloud-provider</a>の <a href=https://github.com/kubernetes/cloud-provider/blob/release-1.21/cloud.go#L42-L69><code>cloud.go</code></a>で定義されている<code>CloudProvider</code>を使います。</p>
<p>本ドキュメントでハイライトした共有コントローラー（Node、Route、Service）の実装と共有クラウドプロバイダーインターフェースに沿ったいくつかの足場は、Kubernetesコアの一部です。クラウドプロバイダに特化した実装は、Kubernetesのコアの外部として、また<code>CloudProvider</code>インターフェースを実装します。</p>
<p>プラグイン開発ついての詳細な情報は、<a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Developing Cloud Controller Manager</a>を見てください。</p>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>