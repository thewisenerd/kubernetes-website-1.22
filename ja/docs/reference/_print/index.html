<!doctype html><html lang=ja class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/reference/>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/reference/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/reference/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/reference/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/reference/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/reference/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/reference/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/reference/>
<link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/reference/>
<link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/reference/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/reference/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>リファレンス | Kubernetes</title><meta property="og:title" content="リファレンス">
<meta property="og:description" content="プロダクショングレードのコンテナ管理基盤">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/ja/docs/reference/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="リファレンス">
<meta itemprop=description content="プロダクショングレードのコンテナ管理基盤"><meta name=twitter:card content="summary">
<meta name=twitter:title content="リファレンス">
<meta name=twitter:description content="プロダクショングレードのコンテナ管理基盤">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="本セクションには、Kubernetesのドキュメントのリファレンスが含まれています。
APIリファレンス  Kubernetes API概要 - Kubernetes APIの概要です。 Kubernetes APIリファレンス v1.26  APIクライアントライブラリー プログラミング言語からKubernetesのAPIを呼ぶためには、クライアントライブラリーを使うことができます。公式にサポートしているクライアントライブラリー:
 Kubernetes Go client library Kubernetes Python client library Kubernetes Java client library Kubernetes JavaScript client library  CLIリファレンス  kubectl - コマンドの実行やKubernetesクラスターの管理に使う主要なCLIツールです。  JSONPath - kubectlでJSONPath記法を使うための構文ガイドです。   kubeadm - セキュアなKubernetesクラスターを簡単にプロビジョニングするためのCLIツールです。  コンポーネントリファレンス  kubelet - 各ノード上で動作する最も重要なノードエージェントです。kubeletは一通りのPodSpecを受け取り、コンテナーが実行中で正常であることを確認します。 kube-apiserver - Pod、Service、Replication Controller等、APIオブジェクトのデータを検証・設定するREST APIサーバーです。 kube-controller-manager - Kubernetesに同梱された、コアのコントロールループを埋め込むデーモンです。 kube-proxy - 単純なTCP/UDPストリームのフォワーディングや、一連のバックエンド間でTCP/UDPのラウンドロビンでのフォワーディングを実行できます。 kube-scheduler - 可用性、パフォーマンス、およびキャパシティを管理するスケジューラーです。  kube-schedulerポリシー kube-schedulerプロファイル    設計のドキュメント Kubernetesの機能に関する設計ドキュメントのアーカイブです。Kubernetesアーキテクチャ とKubernetesデザイン概要から読み始めると良いでしょう。">
<meta property="og:description" content="本セクションには、Kubernetesのドキュメントのリファレンスが含まれています。
APIリファレンス  Kubernetes API概要 - Kubernetes APIの概要です。 Kubernetes APIリファレンス v1.26  APIクライアントライブラリー プログラミング言語からKubernetesのAPIを呼ぶためには、クライアントライブラリーを使うことができます。公式にサポートしているクライアントライブラリー:
 Kubernetes Go client library Kubernetes Python client library Kubernetes Java client library Kubernetes JavaScript client library  CLIリファレンス  kubectl - コマンドの実行やKubernetesクラスターの管理に使う主要なCLIツールです。  JSONPath - kubectlでJSONPath記法を使うための構文ガイドです。   kubeadm - セキュアなKubernetesクラスターを簡単にプロビジョニングするためのCLIツールです。  コンポーネントリファレンス  kubelet - 各ノード上で動作する最も重要なノードエージェントです。kubeletは一通りのPodSpecを受け取り、コンテナーが実行中で正常であることを確認します。 kube-apiserver - Pod、Service、Replication Controller等、APIオブジェクトのデータを検証・設定するREST APIサーバーです。 kube-controller-manager - Kubernetesに同梱された、コアのコントロールループを埋め込むデーモンです。 kube-proxy - 単純なTCP/UDPストリームのフォワーディングや、一連のバックエンド間でTCP/UDPのラウンドロビンでのフォワーディングを実行できます。 kube-scheduler - 可用性、パフォーマンス、およびキャパシティを管理するスケジューラーです。  kube-schedulerポリシー kube-schedulerプロファイル    設計のドキュメント Kubernetesの機能に関する設計ドキュメントのアーカイブです。Kubernetesアーキテクチャ とKubernetesデザイン概要から読み始めると良いでしょう。">
<meta name=twitter:description content="本セクションには、Kubernetesのドキュメントのリファレンスが含まれています。
APIリファレンス  Kubernetes API概要 - Kubernetes APIの概要です。 Kubernetes APIリファレンス v1.26  APIクライアントライブラリー プログラミング言語からKubernetesのAPIを呼ぶためには、クライアントライブラリーを使うことができます。公式にサポートしているクライアントライブラリー:
 Kubernetes Go client library Kubernetes Python client library Kubernetes Java client library Kubernetes JavaScript client library  CLIリファレンス  kubectl - コマンドの実行やKubernetesクラスターの管理に使う主要なCLIツールです。  JSONPath - kubectlでJSONPath記法を使うための構文ガイドです。   kubeadm - セキュアなKubernetesクラスターを簡単にプロビジョニングするためのCLIツールです。  コンポーネントリファレンス  kubelet - 各ノード上で動作する最も重要なノードエージェントです。kubeletは一通りのPodSpecを受け取り、コンテナーが実行中で正常であることを確認します。 kube-apiserver - Pod、Service、Replication Controller等、APIオブジェクトのデータを検証・設定するREST APIサーバーです。 kube-controller-manager - Kubernetesに同梱された、コアのコントロールループを埋め込むデーモンです。 kube-proxy - 単純なTCP/UDPストリームのフォワーディングや、一連のバックエンド間でTCP/UDPのラウンドロビンでのフォワーディングを実行できます。 kube-scheduler - 可用性、パフォーマンス、およびキャパシティを管理するスケジューラーです。  kube-schedulerポリシー kube-schedulerプロファイル    設計のドキュメント Kubernetesの機能に関する設計ドキュメントのアーカイブです。Kubernetesアーキテクチャ とKubernetesデザイン概要から読み始めると良いでしょう。">
<meta property="og:url" content="https://kubernetes.io/ja/docs/reference/">
<meta property="og:title" content="リファレンス">
<meta name=twitter:title content="リファレンス">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/ja/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/ja/docs/>ドキュメント</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/training/>トレーニング</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/partners/>パートナー</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/community/>コミュニティ</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/case-studies/>ケーススタディ</span></a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
バージョン
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/reference/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/ja/docs/reference/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/reference/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/reference/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/reference/>v1.22</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
日本語 Japanese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/reference/>English</a>
<a class=dropdown-item href=/zh/docs/reference/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/reference/>한국어 Korean</a>
<a class=dropdown-item href=/fr/docs/reference/>Français</a>
<a class=dropdown-item href=/de/docs/reference/>Deutsch</a>
<a class=dropdown-item href=/es/docs/reference/>Español</a>
<a class=dropdown-item href=/pt-br/docs/reference/>Português</a>
<a class=dropdown-item href=/id/docs/reference/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/reference/>Русский</a>
<a class=dropdown-item href=/pl/docs/reference/>Polski</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.
</p><p>
<a href=/ja/docs/reference/>このページの通常のビューに戻る</a>.
</p>
</div>
<h1 class=title>リファレンス</h1>
<ul>
<li>1: <a href=#pg-2b03679960950df772fb4fe7d78427b9>標準化用語集</a></li>
<li>2: <a href=#pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b>認証</a></li>
<li>3: <a href=#pg-5bbbc5163b35431b3bff029ab9ec57d3>セットアップツールのリファレンス</a></li>
<ul>
<li>3.1: <a href=#pg-f351ced098abbb076bc8c4be1053672b>Kubeadm</a></li>
<ul>
</ul>
</ul>
<li>4: <a href=#pg-03460a7254c6c73eb2a1bb3dd7d25910>kubectl CLI</a></li>
<ul>
<li>4.1: <a href=#pg-f14fe15ecc2d41b5e901ef5e872ca657>kubectlの概要</a></li>
<li>4.2: <a href=#pg-a938176c695852fe70362c29cf615f1c>JSONPathのサポート</a></li>
<li>4.3: <a href=#pg-8aba901ac13f124e5782b90ddb166ee2>kubectlチートシート</a></li>
</ul>
<li>5: <a href=#pg-54e562dd1441d0195970a6526b0055cc>コマンドラインツールのリファレンス</a></li>
<ul>
<li>5.1: <a href=#pg-ca5d01a42c486d535539d3038aa67eb9>フィーチャーゲート</a></li>
<li>5.2: <a href=#pg-1715b765e2ff39feffd103d59ec0ef07>Kubelet 認証/認可</a></li>
</ul>
<li>6: <a href=#pg-954776b47f2d90515f375623a0ce98e1>RBAC認可を使用する</a></li>
<li>7: <a href=#pg-4f002b9458521ca7afd32176fd590646>ツール</a></li>
</ul>
<div class=content>
<p>本セクションには、Kubernetesのドキュメントのリファレンスが含まれています。</p>
<h2 id=apiリファレンス>APIリファレンス</h2>
<ul>
<li><a href=/docs/reference/using-api/>Kubernetes API概要</a> - Kubernetes APIの概要です。</li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.26/>Kubernetes APIリファレンス v1.26</a></li>
</ul>
<h2 id=apiクライアントライブラリー>APIクライアントライブラリー</h2>
<p>プログラミング言語からKubernetesのAPIを呼ぶためには、<a href=/docs/reference/using-api/client-libraries/>クライアントライブラリー</a>を使うことができます。公式にサポートしているクライアントライブラリー:</p>
<ul>
<li><a href=https://github.com/kubernetes/client-go/>Kubernetes Go client library</a></li>
<li><a href=https://github.com/kubernetes-client/python>Kubernetes Python client library</a></li>
<li><a href=https://github.com/kubernetes-client/java>Kubernetes Java client library</a></li>
<li><a href=https://github.com/kubernetes-client/javascript>Kubernetes JavaScript client library</a></li>
</ul>
<h2 id=cliリファレンス>CLIリファレンス</h2>
<ul>
<li><a href=/ja/docs/reference/kubectl/overview/>kubectl</a> - コマンドの実行やKubernetesクラスターの管理に使う主要なCLIツールです。
<ul>
<li><a href=/ja/docs/reference/kubectl/jsonpath/>JSONPath</a> - kubectlで<a href=https://goessner.net/articles/JsonPath/>JSONPath記法</a>を使うための構文ガイドです。</li>
</ul>
</li>
<li><a href=ja/docs/reference/setup-tools/kubeadm/>kubeadm</a> - セキュアなKubernetesクラスターを簡単にプロビジョニングするためのCLIツールです。</li>
</ul>
<h2 id=コンポーネントリファレンス>コンポーネントリファレンス</h2>
<ul>
<li><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> - 各ノード上で動作する最も重要なノードエージェントです。kubeletは一通りのPodSpecを受け取り、コンテナーが実行中で正常であることを確認します。</li>
<li><a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a> - Pod、Service、Replication Controller等、APIオブジェクトのデータを検証・設定するREST APIサーバーです。</li>
<li><a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a> - Kubernetesに同梱された、コアのコントロールループを埋め込むデーモンです。</li>
<li><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> - 単純なTCP/UDPストリームのフォワーディングや、一連のバックエンド間でTCP/UDPのラウンドロビンでのフォワーディングを実行できます。</li>
<li><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a> - 可用性、パフォーマンス、およびキャパシティを管理するスケジューラーです。
<ul>
<li><a href=/docs/reference/scheduling/policies>kube-schedulerポリシー</a></li>
<li><a href=/docs/reference/scheduling/profiles>kube-schedulerプロファイル</a></li>
</ul>
</li>
</ul>
<h2 id=設計のドキュメント>設計のドキュメント</h2>
<p>Kubernetesの機能に関する設計ドキュメントのアーカイブです。<a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md>Kubernetesアーキテクチャ</a> と<a href=https://git.k8s.io/community/contributors/design-proposals>Kubernetesデザイン概要</a>から読み始めると良いでしょう。</p>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-2b03679960950df772fb4fe7d78427b9>1 - 標準化用語集</h1>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b>2 - 認証</h1>
<p>このページでは、認証の概要について説明します。</p>
<h2 id=kubernetesにおけるユーザー>Kubernetesにおけるユーザー</h2>
<p>すべてのKubernetesクラスターには、2種類のユーザーがあります。Kubernetesによって管理されるサービスアカウントと、通常のユーザーです。</p>
<p>クラスターから独立したサービスは通常のユーザーを以下の方法で管理することを想定されています。</p>
<ul>
<li>秘密鍵を配布する管理者</li>
<li>KeystoneやGoogle Accountsのようなユーザーストア</li>
<li>ユーザー名とパスワードのリストを持つファイル</li>
</ul>
<p>これを考慮すると、 <em>Kubernetesは通常のユーザーアカウントを表すオブジェクトを持ちません。</em> APIコールを介して、通常のユーザーをクラスターに追加することはできません。</p>
<p>APIコールを介して通常のユーザーを追加できませんが、クラスターの認証局(CA)に署名された有効な証明書で表すユーザーは認証済みと判断されます。この構成では、Kubernetesは証明書の‘subject’内にある一般的な名前フィールド(例えば、“/CN=bob”)からユーザー名を特定します。そこから、ロールベースアクセス制御(RBAC)サブシステムは、ユーザーがあるリソースにおける特定の操作を実行するために認証済みかどうか特定します。詳細は、 <a href=/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user>証明書要求</a>内の通常のユーザーの題目を参照してください。</p>
<p>対照的に、サービスアカウントはKubernetes APIによって管理されるユーザーです。サービスアカウントは特定の名前空間にバインドされており、APIサーバーによって自動的に作成されるか、APIコールによって手動で作成されます。サービスアカウントは、<code>Secrets</code>として保存された資格情報の集合に紐付けられています。これをPodにマウントすることで、クラスター内のプロセスがKubernetes APIと通信できるようにします。</p>
<p>APIリクエストは、通常のユーザーかサービスアカウントに紐付けられているか、<a href=#anonymous-requests>匿名リクエスト</a>として扱われます。つまり、ワークステーションで<code>kubectl</code>を入力する人間のユーザーから、ノード上の<code>kubelets</code>やコントロールプレーンのメンバーまで、クラスター内外の全てのプロセスは、APIサーバーへのリクエストを行う際に認証を行うか匿名ユーザーとして扱われる必要があります。</p>
<h2 id=認証戦略>認証戦略</h2>
<p>Kubernetesは、クライアント証明書、Bearerトークン、認証プロキシー、HTTP Basic認証を使い、認証プラグインを通してAPIリクエストを認証します。APIサーバーにHTTPリクエストが送信されると、プラグインは以下の属性をリクエストに関連付けようとします。</p>
<ul>
<li>ユーザー名: エンドユーザーを識別する文字列です。一般的にな値は、<code>kube-admin</code>や<code>jane@example.com</code>です。</li>
<li>UID: エンドユーザーを識別する文字列であり、ユーザー名よりも一貫性と一意性を持たせようとするものです。</li>
<li>グループ: 各要素がユーザーの役割を示すような意味を持つ文字列の集合です。<code>system:masters</code>や<code>devops-team</code>といった値が一般的です。</li>
<li>追加フィールド: 認証者が有用と思われる追加情報を保持する文字列のリストに対する、文字列のマップです。</li>
</ul>
<p>すべての値は認証システムに対して非透過であり、<a href=/docs/reference/access-authn-authz/authorization/>認可機能</a>が解釈した場合にのみ意味を持ちます。</p>
<p>一度に複数の認証方法を有効にすることができます。通常は、以下のように少なくとも2つの方法を使用するべきです。</p>
<ul>
<li>サービスアカウント用のサービスアカウントトークン</li>
<li>ユーザー認証のための、少なくとも1つの他の方法</li>
</ul>
<p>複数の認証モジュールが有効化されている場合、リクエストの認証に成功した最初のモジュールが、評価が簡略化します。APIサーバーは、認証の実行順序を保証しません。</p>
<p><code>system:authenticated</code>グループには、すべての認証済みユーザーのグループのリストが含まれます。</p>
<p>他の認証プロトコル(LDAP、SAML、Kerberos、X509スキームなど)との統合は、<a href=#authenticating-proxy>認証プロキシー</a>や<a href=#webhook-token-authentication>認証Webhook</a>を使用して実施できます。</p>
<h3 id=x509クライアント証明書>X509クライアント証明書</h3>
<p>クライアント証明書認証は、APIサーバーに<code>--client-ca-file=SOMEFILE</code>オプションを渡すことで有効になります。参照されるファイルには、APIサーバーに提示されたクライアント証明書を検証するために使用する1つ以上の認証局が含まれている必要があります。クライアント証明書が提示され、検証された場合、サブジェクトのCommon Nameがリクエストのユーザー名として使用されます。Kubernetes1.4時点では、クライアント証明書は、証明書のOrganizationフィールドを使用して、ユーザーのグループメンバーシップを示すこともできます。あるユーザーに対して複数のグループメンバーシップを含めるには、証明書に複数のOrganizationフィールドを含めます。</p>
<p>例えば、証明書署名要求を生成するために、<code>openssl</code>コマンドラインツールを使用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>openssl req -new -key jbeda.pem -out jbeda-csr.pem -subj <span style=color:#b44>&#34;/CN=jbeda/O=app1/O=app2&#34;</span>
</code></pre></div><p>これにより、"app1"と"app2"の2つのグループに属するユーザー名"jbeda"の証明書署名要求が作成されます。</p>
<p>クライアント証明書の生成方法については、<a href=/ja/docs/concepts/cluster-administration/certificates/>証明書の管理</a>を参照してください。</p>
<h3 id=静的なトークンファイル>静的なトークンファイル</h3>
<p>コマンドラインで<code>--token-auth-file=SOMEFILE</code>オプションを指定すると、APIサーバーはファイルからBearerトークンを読み込みます。現在のところ、トークンの有効期限は無く、APIサーバーを再起動しない限りトークンのリストを変更することはできません。</p>
<p>トークンファイルは、トークン、ユーザー名、ユーザーUIDの少なくとも3つの列を持つcsvファイルで、その後にオプションでグループ名が付きます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>複数のグループがある場合はダブルクォートで囲む必要があります。</p>
<pre><code class=language-conf data-lang=conf>token,user,uid,&quot;group1,group2,group3&quot;
</code></pre>
</div>
<h4 id=putting-a-bearer-token-in-a-request>リクエストにBearerトークンを含める</h4>
<p>HTTPクライアントからBearerトークン認証を利用する場合、APIサーバーは<code>Bearer THETOKEN</code>という値を持つ<code>Authorization</code>ヘッダーを待ち受けます。Bearerトークンは、HTTPのエンコーディングとクォート機能を利用してHTTPヘッダーの値に入れることができる文字列でなければなりません。例えば、Bearerトークンが<code>31ada4fd-adec-460c-809a-9e56ceb75269</code>であれば、HTTPのヘッダを以下のようにします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269
</span></code></pre></div><h3 id=ブートストラップトークン>ブートストラップトークン</h3>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
<p>新しいクラスタの効率的なブートストラップを可能にするために、Kubernetesには<em>ブートストラップトークン</em>と呼ばれる動的に管理されたBearerトークンタイプが含まれています。これらのトークンは、<code>kube-system</code>名前空間にSecretsとして格納され、動的に管理したり作成したりすることができます。コントローラーマネージャーには、TokenCleanerコントローラーが含まれており、ブートストラップトークンの有効期限が切れると削除します。</p>
<p>トークンの形式は<code>[a-z0-9]{6}.[a-z0-9]{16}</code>です。最初のコンポーネントはトークンIDであり、第2のコンポーネントはToken Secretです。以下のように、トークンをHTTPヘッダーに指定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Authorization: Bearer 781292.db7bc3a58fc5f07e
</span></code></pre></div><p>APIサーバーの<code>--enable-bootstrap-token-auth</code>フラグで、Bootstrap Token Authenticatorを有効にする必要があります。TokenCleanerコントローラーを有効にするには、コントローラーマネージャーの<code>--controllers</code>フラグを使います。<code>--controllers=*,tokencleaner</code>のようにして行います。クラスターをブートストラップするために<code>kubeadm</code>を使用している場合は、<code>kubeadm</code>がこれを代行してくれます。</p>
<p>認証機能は<code>system:bootstrap:&lt;Token ID></code>という名前で認証します。これは<code>system:bootstrappers</code>グループに含まれます。名前とグループは意図的に制限されており、ユーザーがブートストラップ後にこれらのトークンを使わないようにしています。ユーザー名とグループは、クラスタのブートストラップをサポートする適切な認可ポリシーを作成するために使用され、<code>kubeadm</code>によって使用されます。</p>
<p>ブートストラップトークンの認証機能やコントローラーについての詳細な説明、<code>kubeadm</code>でこれらのトークンを管理する方法については、<a href=/docs/reference/access-authn-authz/bootstrap-tokens/>ブートストラップトークン</a>を参照してください。</p>
<h3 id=サービスアカウントトークン>サービスアカウントトークン</h3>
<p>サービスアカウントは、自動的に有効化される認証機能で、署名されたBearerトークンを使ってリクエストを検証します。このプラグインは、オプションとして2つのフラグを取ります。</p>
<ul>
<li><code>--service-account-key-file</code>: Bearerトークンに署名するためのPEMエンコードされた鍵を含むファイルです。指定しない場合は、APIサーバーのTLS秘密鍵が使われます。</li>
<li><code>--service-account-lookup</code>: 有効にすると、APIから削除されたトークンは取り消されます。</li>
</ul>
<p>サービスアカウントは通常、APIサーバーによって自動的に作成され、<code>ServiceAccount</code><a href=/docs/reference/access-authn-authz/admission-controllers/>Admission Controller</a>を介してクラスター内のPodに関連付けられます。Bearerトークンは、Podのよく知られた場所にマウントされ、これによりクラスター内のプロセスがAPIサーバー通信できるようになります。アカウントは<code>PodSpec</code>の<code>serviceAccountName</code>フィールドを使って、明示的にPodに関連付けることができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 自動で行われるため、通常<code>serviceAccountName</code>は省略します。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># このapiVersionは、Kubernetes1.9時点で適切です</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>bob-the-bot<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></code></pre></div><p>サービスアカウントのBearerトークンは、クラスター外で使用するために完全に有効であり、Kubernetes APIと通信したい長期的なジョブのアイデンティティを作成するために使用することができます。サービスアカウントを手動で作成するには、単に<code>kubectl create serviceaccount (NAME)</code>コマンドを使用します。これにより、現在の名前空間にサービスアカウントと関連するSecretが作成されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl create serviceaccount jenkins
</code></pre></div><pre><code class=language-none data-lang=none>serviceaccount &quot;jenkins&quot; created
</code></pre><p>以下のように、関連するSecretを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get serviceaccounts jenkins -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>secrets</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jenkins-token-1yvwg<span style=color:#bbb>
</span></code></pre></div><p>作成されたSecretは、APIサーバーのパブリック認証局と署名されたJSON Web Token(JWT)を保持します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get secret jenkins-token-1yvwg -o yaml
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ca.crt</span>:<span style=color:#bbb> </span>(base64でエンコードされたAPIサーバーの認証局)<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>ZGVmYXVsdA==<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token</span>:<span style=color:#bbb> </span>(base64でエンコードされたBearerトークン)<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Secretは常にbase64でエンコードされるため、これらの値もbase64でエンコードされています。
</div>
<p>署名されたJWTは、与えられたサービスアカウントとして認証するためのBearerトークンとして使用できます。トークンをリクエストに含める方法については、<a href=#putting-a-bearer-token-in-a-request>リクエストにBearerトークンを含める</a>を参照してください。通常、これらのSecretはAPIサーバーへのクラスタ内アクセス用にPodにマウントされますが、クラスター外からも使用することができます。</p>
<p>サービスアカウントは、ユーザー名<code>system:serviceaccount:(NAMESPACE):(SERVICEACCOUNT)</code>で認証され、グループ<code>system:serviceaccounts</code>と<code>system:serviceaccounts:(NAMESPACE)</code>に割り当てられます。</p>
<p>警告: サービスアカウントトークンはSecretに保持されているため、Secretにアクセスできるユーザーは誰でもサービスアカウントとして認証することができます。サービスアカウントに権限を付与したり、Secretの読み取り機能を付与したりする際には注意が必要です。</p>
<h3 id=openid-connectトークン>OpenID Connectトークン</h3>
<p><a href=https://openid.net/connect/>OpenID Connect</a>は、Azure Active Directory、Salesforce、Googleなど、いくつかのOAuth2プロバイダーでサポートされているOAuth2の一種です。
このプロトコルのOAuth2の主な拡張機能は、<a href=https://openid.net/specs/openid-connect-core-1_0.html#IDToken>ID Token</a>と呼ばれる、アクセストークンとアクセストークンと一緒に返される追加フィールドです。
このトークンは、ユーザーの電子メールなどのよく知られたフィールドを持つJSON Web Token(JWT)であり、サーバーによって署名されています。トークンをリクエストに含める方法については、<a href=#putting-a-bearer-token-in-a-request>リクエストにBearerトークンを含める</a>を参照してください。</p>
<p><img src=/images/docs/admin/k8s_oidc_login.svg alt="Kubernetes OpenID Connect Flow"></p>
<ol>
<li>IDプロバイダーにログインします</li>
<li>IDプロバイダーは、<code>access_token</code>、<code>id_token</code>、<code>refresh_token</code>を提供します</li>
<li><code>kubectl</code>を使う場合は、<code>--token</code>フラグで<code>id_token</code>を使うか、<code>kubeconfig</code>に直接追加してください</li>
<li><code>kubectl</code>は、<code>id_token</code>をAuthorizationと呼ばれるヘッダーでAPIサーバーに送ります</li>
<li>APIサーバーは、設定で指定された証明書と照合することで、JWT署名が有効であることを確認します</li>
<li><code>id_token</code>の有効期限が切れていないことを確認します</li>
<li>ユーザーが認可されていることを確認します</li>
<li>認可されると、APIサーバーは<code>kubectl</code>にレスポンスを返します</li>
<li><code>kubectl</code>はユーザーにフィードバックを提供します</li>
</ol>
<p>自分が誰であるかを確認するために必要なデータはすべて<code>id_token</code>の中にあるので、KubernetesはIDプロバイダーと通信する必要がありません。すべてのリクエストがステートレスであるモデルでは、これは非常に認証のためのスケーラブルなソリューションを提供します。一方で、以下のようにいくつか課題があります。</p>
<ol>
<li>Kubernetesには、認証プロセスを起動するための"Webインターフェース"がありません。クレデンシャルを収集するためのブラウザやインターフェースがないため、まずIDプロバイダに認証を行う必要があります。</li>
<li><code>id_token</code>は、取り消すことができません。これは証明書のようなもので、有効期限が短い(数分のみ)必要があるので、数分ごとに新しいトークンを取得しなければならないのは非常に面倒です。</li>
<li>Kubernetesダッシュボードへの認証において、<code>kubectl proxy</code>コマンドや<code>id_token</code>を注入するリバースプロキシーを使う以外に、簡単な方法はありません。</li>
</ol>
<h4 id=apiサーバーの設定>APIサーバーの設定</h4>
<p>プラグインを有効にするには、APIサーバーで以下のフラグを設定します。</p>
<table>
<thead>
<tr>
<th>パラメーター</th>
<th>説明</th>
<th>例</th>
<th>必須か</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--oidc-issuer-url</code></td>
<td>APIサーバーが公開署名鍵を発見できるようにするプロバイダーのURLです。 <code>https://</code>スキームを使用するURLのみが受け入れられます。これは通常、"https://accounts.google.com"や"https://login.salesforce.com"のようにパスを持たないプロバイダのディスカバリーURLです。このURLは、<code>.well-known/openid-configuration</code>の下のレベルを指す必要があります。</td>
<td>ディスカバリーURLが<code>https://accounts.google.com/.well-known/openid-configuration</code>である場合、値は<code>https://accounts.google.com</code>とします。</td>
<td>はい</td>
</tr>
<tr>
<td><code>--oidc-client-id</code></td>
<td>すべてのトークンが発行されなければならないクライアントIDです。</td>
<td>kubernetes</td>
<td>はい</td>
</tr>
<tr>
<td><code>--oidc-username-claim</code></td>
<td>ユーザー名として使用するJWTのクレームを指定します。デフォルトでは<code>sub</code>が使用されますが、これはエンドユーザーの一意の識別子であることが期待されます。管理者はプロバイダーに応じて<code>email</code>や<code>name</code>などの他のクレームを選択することができます。ただし、他のプラグインとの名前の衝突を防ぐために、<code>email</code>以外のクレームには、プレフィックスとして発行者のURLが付けられます。</td>
<td>sub</td>
<td>いいえ</td>
</tr>
<tr>
<td><code>--oidc-username-prefix</code></td>
<td>既存の名前(<code>system:</code>ユーザーなど)との衝突を防ぐために、ユーザー名の前にプレフィックスを付加します。例えば<code>oidc:</code>という値は、<code>oidc:jane.doe</code>のようなユーザー名を生成します。このフラグが指定されておらず、<code>--oidc-username-claim</code>が<code>email</code>以外の値である場合、プレフィックスのデフォルトは<code>(Issuer URL)#</code>で、<code>(Issuer URL)</code>は<code>--oidc-issuer-url</code>の値です。すべてのプレフィックスを無効にするためには、<code>-</code>という値を使用できます。</td>
<td><code>oidc:</code></td>
<td>いいえ</td>
</tr>
<tr>
<td><code>--oidc-groups-claim</code></td>
<td>ユーザーのグループとして使用するJWTのクレームです。クレームがある場合は、文字列の配列である必要があります。</td>
<td>groups</td>
<td>いいえ</td>
</tr>
<tr>
<td><code>--oidc-groups-prefix</code></td>
<td>既存の名前(<code>system:</code>グループなど)との衝突を防ぐために、グループ名の前にプレフィックスを付加します。例えば<code>oidc:</code>という値は、<code>oidc:engineering</code>や<code>oidc:infra</code>のようなグループ名を生成します。</td>
<td><code>oidc:</code></td>
<td>いいえ</td>
</tr>
<tr>
<td><code>--oidc-required-claim</code></td>
<td>IDトークンの中の必須クレームを記述するkey=valueのペアです。設定されている場合、クレームが一致する値でIDトークンに存在することが検証されます。このフラグを繰り返して複数のクレームを指定します。</td>
<td><code>claim=value</code></td>
<td>いいえ</td>
</tr>
<tr>
<td><code>--oidc-ca-file</code></td>
<td>IDプロバイダーのWeb証明書に署名した認証局の証明書へのパスです。デフォルトはホストのルート認証局が指定されます。</td>
<td><code>/etc/kubernetes/ssl/kc-ca.pem</code></td>
<td>いいえ</td>
</tr>
</tbody>
</table>
<p>重要なのは、APIサーバーはOAuth2クライアントではなく、ある単一の発行者を信頼するようにしか設定できないことです。これにより、サードパーティーに発行されたクレデンシャルを信頼せずに、Googleのようなパブリックプロバイダーを使用することができます。複数のOAuthクライアントを利用したい管理者は、<code>azp</code>クレームをサポートしているプロバイダや、あるクライアントが別のクライアントに代わってトークンを発行できるような仕組みを検討する必要があります。</p>
<p>KubernetesはOpenID Connect IDプロバイダーを提供していません。既存のパブリックなOpenID Connect IDプロバイダー(Googleや<a href=https://connect2id.com/products/nimbus-oauth-openid-connect-sdk/openid-connect-providers>その他</a>など)を使用できます。もしくは、CoreOS <a href=https://github.com/coreos/dex>dex</a>、<a href=https://github.com/keycloak/keycloak>Keycloak</a>、CloudFoundry<a href=https://github.com/cloudfoundry/uaa>UAA</a>、Tremolo Securityの<a href=https://github.com/tremolosecurity/openunison>OpenUnison</a>など、独自のIDプロバイダーを実行することもできます。</p>
<p>IDプロバイダーがKubernetesと連携するためには、以下のことが必要です。</p>
<ol>
<li>すべてではないが、[OpenID Connect Discovery](<a href=https://openid.net/specs/openid-connect-discovery-1_0.html>https://openid.net/specs/openid-connect-discovery-1_0.html</a>）をサポートしていること</li>
<li>廃れていない暗号を用いたTLSで実行されていること</li>
<li>認証局が署名した証明書を持っていること(認証局が商用ではない場合や、自己署名の場合も可)</li>
</ol>
<p>上述の要件#3、認証局署名付き証明書を必要とすることについて、注意事項があります。GoogleやMicrosoftなどのクラウドプロバイダーではなく、独自のIDプロバイダーをデプロイする場合は、たとえ自己署名されていても、<code>CA</code>フラグが<code>TRUE</code>に設定されている証明書によって署名されたIDプロバイダーのWebサーバー証明書を持っていなければなりません。これは、Go言語のTLSクライアント実装が、証明書検証に関する標準に対して非常に厳格であるためです。認証局をお持ちでない場合は、CoreOSチームの<a href=https://github.com/coreos/dex/blob/1ee5920c54f5926d6468d2607c728b71cfe98092/examples/k8s/gencert.sh>このスクリプト</a>を使用して、シンプルな認証局と署名付きの証明書と鍵のペアを作成することができます。
または、<a href=https://raw.githubusercontent.com/TremoloSecurity/openunison-qs-kubernetes/master/src/main/bash/makessl.sh>この類似のスクリプト</a>を使って、より寿命が長く、よりキーサイズの大きいSHA256証明書を生成できます。</p>
<p>特定のシステム用のセットアップ手順は、以下を参照してください。</p>
<ul>
<li><a href=https://docs.cloudfoundry.org/concepts/architecture/uaa.html>UAA</a></li>
<li><a href=https://dexidp.io/docs/kubernetes/>Dex</a></li>
<li><a href=https://www.tremolosecurity.com/orchestra-k8s/>OpenUnison</a></li>
</ul>
<h4 id=kubectlの使用>kubectlの使用</h4>
<h5 id=選択肢1-oidc認証機能>選択肢1 - OIDC認証機能</h5>
<p>最初の選択肢は、kubectlの<code>oidc</code>認証機能を利用することです。これはすべてのリクエストのBearerトークンとして<code>id_token</code>を設定し、有効期限が切れるとトークンを更新します。プロバイダーにログインした後、kubectlを使って<code>id_token</code>、<code>refresh_token</code>、<code>client_id</code>、<code>client_secret</code>を追加してプラグインを設定します。</p>
<p>リフレッシュトークンのレスポンスの一部として<code>id_token</code>を返さないプロバイダーは、このプラグインではサポートされていないので、以下の"選択肢2"を使用してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config set-credentials USER_NAME <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider<span style=color:#666>=</span>oidc <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>idp-issuer-url<span style=color:#666>=(</span> issuer url <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>client-id<span style=color:#666>=(</span> your client id <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>client-secret<span style=color:#666>=(</span> your client secret <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>refresh-token<span style=color:#666>=(</span> your refresh token <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>idp-certificate-authority<span style=color:#666>=(</span> path to your ca certificate <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>id-token<span style=color:#666>=(</span> your id_token <span style=color:#666>)</span>
</code></pre></div><p>例として、IDプロバイダーに認証した後に以下のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config set-credentials mmosley  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider<span style=color:#666>=</span>oidc  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>idp-issuer-url<span style=color:#666>=</span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>client-id<span style=color:#666>=</span>kubernetes  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>client-secret<span style=color:#666>=</span>1db158f6-177d-4d9c-8a8b-d36869918ec5  <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>refresh-token<span style=color:#666>=</span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXqHega4GAXlF+ma+vmYpFcHe5eZR+slBFpZKtQA<span style=color:#666>=</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>idp-certificate-authority<span style=color:#666>=</span>/root/ca.pem <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>id-token<span style=color:#666>=</span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw
</code></pre></div><p>これは以下のような構成になります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mmosley<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>auth-provider</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>config</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>client-id</span>:<span style=color:#bbb> </span>kubernetes<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>client-secret</span>:<span style=color:#bbb> </span>1db158f6-177d-4d9c-8a8b-d36869918ec5<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>id-token</span>:<span style=color:#bbb> </span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>idp-certificate-authority</span>:<span style=color:#bbb> </span>/root/ca.pem<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>idp-issuer-url</span>:<span style=color:#bbb> </span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>refresh-token</span>:<span style=color:#bbb> </span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXq<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>oidc<span style=color:#bbb>
</span></code></pre></div><p><code>id_token</code>の有効期限が切れると、<code>kubectl</code>は<code>refresh_token</code>と<code>client_secret</code>を用いて<code>id_token</code>の更新しようとします。<code>refresh_token</code>と<code>id_token</code>の新しい値は、<code>.kube/config</code>に格納されます。</p>
<h5 id=選択肢2-token-オプションの使用>選択肢2 - <code>--token</code>オプションの使用</h5>
<p><code>kubectl</code>コマンドでは、<code>--token</code>オプションを使ってトークンを渡すことができる。以下のように、このオプションに<code>id_token</code>をコピーして貼り付けるだけです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl --token<span style=color:#666>=</span>eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJodHRwczovL21sYi50cmVtb2xvLmxhbjo4MDQzL2F1dGgvaWRwL29pZGMiLCJhdWQiOiJrdWJlcm5ldGVzIiwiZXhwIjoxNDc0NTk2NjY5LCJqdGkiOiI2RDUzNXoxUEpFNjJOR3QxaWVyYm9RIiwiaWF0IjoxNDc0NTk2MzY5LCJuYmYiOjE0NzQ1OTYyNDksInN1YiI6Im13aW5kdSIsInVzZXJfcm9sZSI6WyJ1c2VycyIsIm5ldy1uYW1lc3BhY2Utdmlld2VyIl0sImVtYWlsIjoibXdpbmR1QG5vbW9yZWplZGkuY29tIn0.f2As579n9VNoaKzoF-dOQGmXkFKf1FMyNV0-va_B63jn-_n9LGSCca_6IVMP8pO-Zb4KvRqGyTP0r3HkHxYy5c81AnIh8ijarruczl-TK_yF5akjSTHFZD-0gRzlevBDiH8Q79NAr-ky0P4iIXS8lY9Vnjch5MF74Zx0c3alKJHJUnnpjIACByfF2SCaYzbWFMUNat-K1PaUk5-ujMBG7yYnr95xD-63n8CO8teGUAAEMx6zRjzfhnhbzX-ajwZLGwGUBT4WqjMs70-6a7_8gZmLZb2az1cZynkFRj2BaCkVT3A2RrjeEwZEtGXlMqKJ1_I2ulrOVsYx01_yD35-rw get nodes
</code></pre></div><h3 id=webhook-token-authentication>Webhookトークン認証</h3>
<p>Webhook認証は、Bearerトークンを検証するためのフックです。</p>
<ul>
<li><code>--authentication-token-webhook-config-file</code>: リモートのWebhookサービスへのアクセス方法を記述した設定ファイルです</li>
<li><code>--authentication-token-webhook-cache-ttl</code>: 認証をキャッシュする時間を決定します。デフォルトは2分です</li>
</ul>
<p>設定ファイルは、<a href=/ja/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>のファイル形式を使用します。
ファイル内で、<code>clusters</code>はリモートサービスを、<code>users</code>はAPIサーバーのWebhookを指します。例えば、以下のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># Kubernetes APIのバージョン</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># APIオブジェクトの種類</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># clustersは、リモートサービスを指します。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-remote-authn-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/path/to/ca.pem        <span style=color:#bbb> </span><span style=color:#080;font-style:italic># リモートサービスを検証するためのCA</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://authn.example.com/authenticate<span style=color:#bbb> </span><span style=color:#080;font-style:italic># クエリするリモートサービスのURL。&#39;https&#39;を使用する必要があります。</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># usersは、APIサーバーのWebhook設定を指します。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/path/to/cert.pem<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Webhookプラグインを使うための証明書</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/path/to/key.pem         <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 証明書に合致する鍵</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kubeconfigファイルにはコンテキストが必要です。APIサーバー用のものを用意してください。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>name-of-remote-authn-service<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>name-of-api-sever<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span></code></pre></div><p>クライアントが<a href=#putting-a-bearer-token-in-a-request>上記</a>のようにBearerトークンを使用してAPIサーバーとの認証を試みた場合、認証Webhookはトークンを含むJSONでシリアライズされた<code>authentication.k8s.io/v1beta1</code> <code>TokenReview</code>オブジェクトをリモートサービスにPOSTします。Kubernetesはそのようなヘッダーが不足しているリクエストを作成しようとはしません。</p>
<p>Webhook APIオブジェクトは、他のKubernetes APIオブジェクトと同じように、<a href=/ja/docs/concepts/overview/kubernetes-api/>Versioning Compatibility Rule</a>に従うことに注意してください。実装者は、ベータオブジェクトで保証される互換性が緩いことに注意し、正しいデシリアライゼーションが使用されるようにリクエストの"apiVersion"フィールドを確認する必要があります。さらにAPIサーバーは、API拡張グループ<code>authentication.k8s.io/v1beta1</code>を有効にしなければなりません(<code>--runtime config=authentication.k8s.io/v1beta1=true</code>)。</p>
<p>POSTボディは、以下の形式になります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;TokenReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;(Bearerトークン)&#34;</span>
  }
}
</code></pre></div><p>リモートサービスはログインの成功を示すために、リクエストの<code>status</code>フィールドを埋めることが期待されます。レスポンスボディの<code>spec</code>フィールドは無視され、省略することができます。Bearerトークンの検証に成功すると、以下のようにBearerトークンが返されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;TokenReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;authenticated&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
    <span style=color:green;font-weight:700>&#34;user&#34;</span>: {
      <span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;janedoe@example.com&#34;</span>,
      <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;42&#34;</span>,
      <span style=color:green;font-weight:700>&#34;groups&#34;</span>: [
        <span style=color:#b44>&#34;developers&#34;</span>,
        <span style=color:#b44>&#34;qa&#34;</span>
      ],
      <span style=color:green;font-weight:700>&#34;extra&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;extrafield1&#34;</span>: [
          <span style=color:#b44>&#34;extravalue1&#34;</span>,
          <span style=color:#b44>&#34;extravalue2&#34;</span>
        ]
      }
    }
  }
}
</code></pre></div><p>リクエストに失敗した場合は、以下のように返されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;TokenReview&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;authenticated&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>
  }
}
</code></pre></div><p>HTTPステータスコードは、追加のエラーコンテキストを提供するために使うことができます。</p>
<h3 id=authenticating-proxy>認証プロキシー</h3>
<p>APIサーバーは、<code>X-Remote-User</code>のようにリクエストヘッダの値からユーザーを識別するように設定することができます。
これは、リクエストヘッダの値を設定する認証プロキシーと組み合わせて使用するために設計です。</p>
<ul>
<li><code>--requestheader-username-headers</code>: 必須であり、大文字小文字を区別しません。ユーザーのIDをチェックするためのヘッダー名を順番に指定します。値を含む最初のヘッダーが、ユーザー名として使われます。</li>
<li><code>--requestheader-group-headers</code>: バージョン1.6以降で任意であり、大文字小文字を区別しません。"X-Remote-Group"を推奨します。ユーザーのグループをチェックするためのヘッダー名を順番に指定します。指定されたヘッダーの全ての値が、グループ名として使われます。</li>
<li><code>--requestheader-extra-headers-prefix</code> バージョン1.6以降で任意であり、大文字小文字を区別しません。"X-Remote-Extra-"を推奨します。ユーザーに関する追加情報を判断するために検索するヘッダーのプレフィックスです。通常、設定された認可プラグインによって使用されます。指定されたプレフィックスのいずれかで始まるヘッダーは、プレフィックスが削除されます。ヘッダー名の残りの部分は小文字化され<a href=https://tools.ietf.org/html/rfc3986#section-2.1>パーセントデコーディング</a>されて追加のキーとなり、ヘッダーの値が追加の値となります。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 1.11.3(および1.10.7、1.9.11)よりも前のバージョンでは、追加のキーには<a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>HTTPヘッダーラベルで使用可能な文字</a>のみを含めることができました。
</div>
<p>例えば、このような設定を行います。</p>
<pre><code>--requestheader-username-headers=X-Remote-User
--requestheader-group-headers=X-Remote-Group
--requestheader-extra-headers-prefix=X-Remote-Extra-
</code></pre><p>以下のようなリクエストを考えます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=color:#00a000>GET</span> <span style=color:#00f;font-weight:700>/</span> <span style=color:#a2f;font-weight:700>HTTP</span><span style=color:#666>/</span><span style=color:#666>1.1</span>
X-Remote-User<span style=color:#666>:</span> fido
X-Remote-Group<span style=color:#666>:</span> dogs
X-Remote-Group<span style=color:#666>:</span> dachshunds
X-Remote-Extra-Acme.com%2Fproject<span style=color:#666>:</span> some-project
X-Remote-Extra-Scopes<span style=color:#666>:</span> openid
X-Remote-Extra-Scopes<span style=color:#666>:</span> profile
</code></pre></div><p>このリクエストは、このユーザー情報を取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fido<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>groups</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- dogs<span style=color:#bbb>
</span><span style=color:#bbb></span>- dachshunds<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>acme.com/project</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- some-project<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- openid<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- profile<span style=color:#bbb>
</span></code></pre></div><p>ヘッダーのスプーフィングを防ぐため、認証プロキシーはリクエストヘッダーがチェックされる前に、指定された認証局に対する検証のために有効なクライアント証明書をAPIサーバーへ提示する必要があります。</p>
<ul>
<li><code>--requestheader-client-ca-file</code>: 必須です。PEMエンコードされた証明書バンドルです。有効なクライアント証明書を提示し、リクエストヘッダーでユーザー名がチェックされる前に、指定されたファイル内の認証局に対して検証する必要があります。</li>
<li><code>--requestheader-allowed-names</code>: 任意です。Common Name(CN)の値のリストです。設定されている場合、リクエストヘッダーでユーザー名がチェックされる前に、指定されたリストのCNを持つ有効なクライアント証明書を提示する必要があります。空の場合は、任意のCNが許可されます。</li>
</ul>
<h2 id=anonymous-requests>匿名リクエスト</h2>
<p>この機能を有効にすると、他の設定された認証方法で拒否されなかったリクエストは匿名リクエストとして扱われ、 <code>system:anonymous</code>というユーザー名と<code>system:unauthenticated</code>というグループが与えられます。</p>
<p>例えば、トークン認証が設定されており、匿名アクセスが有効になっているサーバー上で、無効なBearerトークンを提供するリクエストは<code>401 Unauthorized</code>エラーを受け取ります。Bearerトークンを提供しないリクエストは匿名リクエストとして扱われます。</p>
<p>バージョン1.5.1から1.5.xでは、匿名アクセスはデフォルトでは無効になっており、APIサーバーに <code>--anonymous-auth=true</code>オプションを渡すことで有効にすることができます。</p>
<p>バージョン1.6以降では、<code>AlwaysAllow</code>以外の認証モードが使用されている場合、匿名アクセスがデフォルトで有効であり、<code>--anonymous-auth=false</code>オプションをAPIサーバーに渡すことで無効にできます。
1.6以降、ABACおよびRBAC認可機能は、<code>system:anonymous</code>ユーザーまたは<code>system:unauthenticated</code>グループの明示的な認証を必要とするようになったため、<code>*</code>ユーザーまたは<code>*</code>グループへのアクセスを許可する従来のポリシールールには匿名ユーザーは含まれません。</p>
<h2 id=ユーザーの偽装>ユーザーの偽装</h2>
<p>ユーザーは偽装ヘッダーを使って別のユーザーとして振る舞うことができます。これにより、リクエストが認証したユーザー情報を手動で上書きすることが可能です。例えば、管理者はこの機能を使って一時的に別のユーザーに偽装、リクエストが拒否されたかどうかを確認することで認可ポリシーをデバッグすることができます。</p>
<p>偽装リクエストは最初にリクエスト中のユーザーとして認証を行い、次に偽装ユーザー情報に切り替えます。</p>
<ul>
<li>ユーザーは、認証情報と偽装ヘッダーを使ってAPIコールを行います。</li>
<li>APIサーバーはユーザーを認証します。</li>
<li>APIサーバーは、認証されたユーザーが偽装した権限を持っていることを確認します。</li>
<li>リクエストされたユーザー情報は、偽装した値に置き換えられます。</li>
<li>リクエストが評価され、認可は偽装されたユーザー情報に基づいて実行されます。</li>
</ul>
<p>偽装リクエストを実行する際には、以下のHTTPヘッダを使用することができます。</p>
<ul>
<li><code>Impersonate-User</code>: ユーザー名を指定します。このユーザーとして振る舞います。</li>
<li><code>Impersonate-Group</code>: グループ名を指定します。このグループとして振る舞います。複数回指定して複数のグループを設定することができます。任意であり、"Impersonate-User"が必要です。</li>
<li><code>Impersonate-Extra-( extra name )</code>: 追加フィールドをユーザーに関連付けるために使用される動的なヘッダーです。任意であり、"Impersonate-User"が必要です。一貫して保存されるためには、<code>( extra name )</code>は小文字である必要があり、<a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>HTTPヘッダーラベルで使用可能な文字</a>以外の文字は、UTF-8であり、<a href=https://tools.ietf.org/html/rfc3986#section-2.1>パーセントエンコーディング</a>されている必要があります.</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 1.11.3(および1.10.7、1.9.11)よりも前のバージョンでは、<code>( extra name )</code>には<a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>HTTPヘッダーラベルで使用可能な文字</a>のみを含めることができました。
</div>
<p>以下が、ヘッダーの例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>Impersonate-User: jane.doe@example.com
</span><span>Impersonate-Group: developers
</span><span>Impersonate-Group: admins
</span><span>Impersonate-Extra-dn: cn=jane,ou=engineers,dc=example,dc=com
</span><span>Impersonate-Extra-acme.com%2Fproject: some-project
</span><span>Impersonate-Extra-scopes: view
</span><span>Impersonate-Extra-scopes: development
</span></code></pre></div><p><code>kubectl</code>を使う場合は、<code>--as</code>フラグに<code>Impersonate-User</code>ヘッダーを、<code>--as-group</code>フラグに<code>Impersonate-Group</code>ヘッダーを設定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl drain mynode
</code></pre></div><pre><code class=language-none data-lang=none>Error from server (Forbidden): User &quot;clark&quot; cannot get nodes at the cluster scope. (get nodes mynode)
</code></pre><p><code>--as</code>フラグと<code>--as-group</code>フラグを設定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl drain mynode --as<span style=color:#666>=</span>superman --as-group<span style=color:#666>=</span>system:masters
</code></pre></div><pre><code class=language-none data-lang=none>node/mynode cordoned
node/mynode drained
</code></pre><p>ユーザー、グループ、または追加フィールドを偽装するために、偽装ユーザーは偽装される属性の種類("user"、"group"など)に対して、"偽装した"操作を行う能力を持っている必要があります。RBAC認可プラグインが有効なクラスターの場合、以下のClusterRoleは、ユーザーとグループの偽装ヘッダーを設定するために必要なルールを網羅しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;users&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;groups&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;serviceaccounts&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>追加フィールドは、"userextras"リソースのサブリソースとして評価されます。ユーザーが追加フィールド"scopes"に偽装ヘッダーを使用できるようにするには、ユーザーに以下のようなロールを付与する必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scopes-impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># &#34;Impersonate-Extra-scopes&#34;ヘッダーを設定できます。</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;userextras/scopes&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>偽装ヘッダーの値は、リソースが取り得る<code>resourceNames</code>の集合を制限することで、管理することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>limited-impersonator<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># &#34;jane.doe@example.com&#34;というユーザーを偽装できます。</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;users&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;jane.doe@example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># &#34;developers&#34;と&#34;admins&#34;というグループを偽装できます。</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;groups&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;developers&#34;</span>,<span style=color:#b44>&#34;admins&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># &#34;view&#34;と&#34;development&#34;を値に持つ&#34;scopes&#34;という追加フィールドを偽装できます。</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;userextras/scopes&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;view&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;development&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><h2 id=client-goクレデンシャルプラグイン>client-goクレデンシャルプラグイン</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p><code>k8s.io/client-go</code>と、それを使用する<code>kubectl</code>や<code>kubelet</code>のようなツールは、外部コマンドを実行してユーザーの認証情報を受け取ることができます。</p>
<p>この機能は<code>k8s.io/client-go</code>がネイティブにサポートしていない認証プロトコル(LDAP、Kerberos、OAuth2、SAMLなど)とクライアントサイドで統合するためのものです。プラグインはプロトコル固有のロジックを実装し、使用する不透明なクレデンシャルを返します。ほとんどすべてのクレデンシャルプラグインのユースケースでは、クライアントプラグインが生成するクレデンシャルフォーマットを解釈するために、<a href=#webhook-token-authentication>Webhookトークン認証</a>をサポートするサーバーサイドコンポーネントが必要です。</p>
<h3 id=使用例>使用例</h3>
<p>ある組織は、LDAPクレデンシャルをユーザー固有の署名済みトークンと交換する外部サービスを実行すると仮定します。このサービスは、トークンを検証するために<a href=#webhook-token-authentication>Webhookトークン認証</a>リクエストに応答することもできます。ユーザーはワークステーションにクレデンシャルプラグインをインストールする必要があります。</p>
<p>以下のようにして、APIに対して認証を行います。</p>
<ul>
<li>ユーザーは<code>kubectl</code>コマンドを発行します。</li>
<li>クレデンシャルプラグインは、LDAPクレデンシャルの入力をユーザーに要求し、クレデンシャルを外部サービスとトークンと交換します。</li>
<li>クレデンシャルプラグインはトークンを<code>client-go</code>に返します。これはAPIサーバーに対するBearerトークンとして使用されます。</li>
<li>APIサーバーは、<a href=#webhook-token-authentication>Webhookトークン認証</a>を使用して、<code>TokenReview</code>を外部サービスに送信します。</li>
<li>外部サービスはトークンの署名を検証し、ユーザーのユーザー名とグループを返します。</li>
</ul>
<h3 id=設定>設定</h3>
<p>クレデンシャルプラグインの設定は、userフィールドの一部として<a href=/ja/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubectlの設定ファイル</a>で行います。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 実行するコマンドです。必須です。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ExecCredentialsリソースをデコードする際に使用するAPIのバージョン。必須です。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># プラグインが返すAPIのバージョンは、ここに記載されているバージョンと一致しなければなりません</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 複数のバージョンをサポートするツール(client.authentication.k8s.io/v1alpha1など)と統合するには、</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 環境変数を設定するか、execプラグインが期待するバージョンを示す引数をツールに渡します。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># プラグインを実行する際に設定する環境変数です。任意です。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;FOO&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;bar&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># プラグインを実行する際に渡す引数です。任意です。</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;arg1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;arg2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/ca.pem&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></code></pre></div><p>相対的なコマンドパスは、設定ファイルのディレクトリーからの相対的なものとして解釈されます。KUBECONFIGが<code>/home/jane/kubeconfig</code>に設定されていて、execコマンドが<code>./bin/example-client-go-exec-plugin</code>の場合、バイナリー<code>/home/jane/bin/example-client-go-exec-plugin</code>が実行されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># kubeconfigのディレクトリーへの相対パス</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;./bin/example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span><span style=color:#bbb>
</span></code></pre></div><h3 id=入出力フォーマット>入出力フォーマット</h3>
<p>実行されたコマンドは<code>ExecCredential</code>オブジェクトを<code>stdout</code>に出力します。<code>k8s.io/client-go</code>は<code>status</code>で返された認証情報を用いて、Kubernetes APIに対して認証を行ういます。</p>
<p>対話的なセッションから実行する場合、<code>stdin</code>はプラグインに直接公開されます。プラグインは<a href=https://godoc.org/golang.org/x/crypto/ssh/terminal#IsTerminal>TTYチェック</a>を使って、対話的にユーザーにプロンプトを出すことが適切かどうかを判断する必要があります。</p>
<p>Bearerトークンのクレデンシャルを使用するために、プラグインは<code>ExecCredential</code>のステータスにトークンを返します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>
  }
}
</code></pre></div><p>あるいは、PEMエンコードされたクライアント証明書と鍵を返して、TLSクライアント認証を使用することもできます。
プラグインが後続の呼び出しで異なる証明書と鍵を返すと、<code>k8s.io/client-go</code>はサーバーとの既存の接続を閉じて、新しいTLSハンドシェイクを強制します</p>
<p>指定された場合、<code>clientKeyData</code>と<code>clientCertificateData</code>両方が存在しなければなりません。</p>
<p><code>clientCertificateData</code>には、サーバーに送信するための中間証明書を含めることができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;clientCertificateData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----&#34;</span>,
    <span style=color:green;font-weight:700>&#34;clientKeyData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----&#34;</span>
  }
}
</code></pre></div><p>オプションで、レスポンスにはRFC3339のタイムスタンプとしてフォーマットされたクレデンシャルの有効期限を含めることができます。有効期限の有無には、以下のような影響あります。</p>
<ul>
<li>有効期限が含まれている場合、BearerトークンとTLSクレデンシャルは有効期限に達するまで、またはサーバーがHTTPステータスコード401で応答したとき、またはプロセスが終了するまでキャッシュされます。</li>
<li>有効期限が省略された場合、BearerトークンとTLSクレデンシャルはサーバーがHTTPステータスコード401で応答したとき、またはプロセスが終了するまでキャッシュされます。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>,
    <span style=color:green;font-weight:700>&#34;expirationTimestamp&#34;</span>: <span style=color:#b44>&#34;2018-03-05T17:30:20-08:00&#34;</span>
  }
}
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5bbbc5163b35431b3bff029ab9ec57d3>3 - セットアップツールのリファレンス</h1>
</div>
<div class=td-content>
<h1 id=pg-f351ced098abbb076bc8c4be1053672b>3.1 - Kubeadm</h1>
<p><img src=/images/kubeadm-stacked-color.png align=right width=150px>kubeadmは、<code>kubeadm init</code>や<code>kubeadm join</code>などのコマンドを提供するツールで、Kubernetesクラスターを構築する上でのベストプラクティスを反映した「近道」を提供するものとして開発されました。</p>
<p>kubeadmは実用最小限のクラスターをセットアップするための処理を実行します。設計上、kubeadmはブートストラップのみを行い、マシンのプロビジョニングは行いません。同様に、Kubernetesダッシュボード、モニタリングソリューション、クラウド向けのアドオンなど、あれば便利でもなくても支障のない各種アドオンのインストールも範囲外です。</p>
<p>その代わりに、高度な特定用途向けのツールはkubeadmをベースに構築されることが期待されています。理想的には、すべてのデプロイのベースとしてkubeadmを使用することで、適合テストに通るクラスターを簡単に作れるようになります。</p>
<h2 id=インストール方法>インストール方法</h2>
<p>kubeadmをインストールするには、<a href=/ja/docs/setup/production-environment/tools/kubeadm/install-kubeadm>インストールガイド</a>を参照してください。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init>kubeadm init</a>を使用して、Kubernetesのコントロールプレーンノードをブートストラップする</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join>kubeadm join</a>を使用して、Kubernetesのワーカーノードをブートストラップし、クラスターに参加させる</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-upgrade>kubeadm upgrade</a>で、Kubernetesクラスターを新しいバージョンにアップグレードする</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-config>kubeadm config</a>を使用して、kubeadm v1.7.x以前で初期化されたクラスターを、<code>kubeadm upgrade</code>を利用できるように設定する</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-token>kubeadm token</a>で、<code>kubeadm join</code>のためのトークンを管理する</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset>kubeadm reset</a>を使用して、<code>kubeadm init</code>または<code>kubeadm join</code>でホストに行われた変更を元に戻す</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-version>kubeadm version</a>で、kubeadmのバージョンを表示する</li>
<li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-alpha>kubeadm alpha</a>で、コミュニティからのフィードバックを集めるために有効にされた各種機能を試用する</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-03460a7254c6c73eb2a1bb3dd7d25910>4 - kubectl CLI</h1>
</div>
<div class=td-content>
<h1 id=pg-f14fe15ecc2d41b5e901ef5e872ca657>4.1 - kubectlの概要</h1>
<p><code>kubectl</code>コマンドラインツールを使うと、Kubernetesクラスターを制御できます。環境設定のために、<code>kubectl</code>は、<code>$HOME/.kube</code>ディレクトリにある<code>config</code>という名前のファイルを探します。他の<a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>ファイルは、<code>KUBECONFIG</code>環境変数を設定するか、<a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/><code>--kubeconfig</code></a>フラグを設定することで指定できます。
この概要では、<code>kubectl</code>の構文を扱い、コマンド操作を説明し、一般的な例を示します。サポートされているすべてのフラグやサブコマンドを含め、各コマンドの詳細については、<a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a>リファレンスドキュメントを参照してください。インストール方法については、<a href=/ja/docs/tasks/tools/install-kubectl/>kubectlのインストールおよびセットアップ</a>をご覧ください。</p>
<h2 id=構文>構文</h2>
<p>ターミナルウィンドウから<code>kubectl</code>コマンドを実行するには、以下の構文を使用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> <span style=color:#666>[</span>flags<span style=color:#666>]</span>
</code></pre></div><p>ここで、<code>command</code>、<code>TYPE</code>、<code>NAME</code>、<code>flags</code>は、以下を表します。</p>
<ul>
<li>
<p><code>command</code>: 1つ以上のリソースに対して実行したい操作を指定します。例えば、<code>create</code>、<code>get</code>、<code>describe</code>、<code>delete</code>です。</p>
</li>
<li>
<p><code>TYPE</code>: <a href=#resource-types>リソースタイプ</a>を指定します。リソースタイプは大文字と小文字を区別せず、単数形や複数形、省略形を指定できます。例えば、以下のコマンドは同じ出力を生成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod pod1
kubectl get pods pod1
kubectl get po pod1
</code></pre></div></li>
<li>
<p><code>NAME</code>: リソースの名前を指定します。名前は大文字と小文字を区別します。<code>kubectl get pods</code>のように名前が省略された場合は、すべてのリソースの詳細が表示されます。</p>
<p>複数のリソースに対して操作を行う場合は、各リソースをタイプと名前で指定するか、1つまたは複数のファイルを指定することができます。</p>
<ul>
<li>
<p>リソースをタイプと名前で指定する場合</p>
<ul>
<li>
<p>タイプがすべて同じとき、リソースをグループ化するには<code>TYPE1 name1 name2 name&lt;#></code>とします。<br>
例: <code>kubectl get pod example-pod1 example-pod2</code></p>
</li>
<li>
<p>複数のリソースタイプを個別に指定するには、<code>TYPE1/name1 TYPE1/name2 TYPE2/name3 TYPE&lt;#>/name&lt;#></code>とします。<br>
例: <code>kubectl get pod/example-pod1 replicationcontroller/example-rc1</code></p>
</li>
</ul>
</li>
<li>
<p>リソースを1つ以上のファイルで指定する場合は、<code>-f file1 -f file2 -f file&lt;#></code>とします。</p>
<ul>
<li>特に設定ファイルについては、YAMLの方がより使いやすいため、<a href=/ja/docs/concepts/configuration/overview/#%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%AA%E8%A8%AD%E5%AE%9A%E3%81%AEtips>JSONではなくYAMLを使用してください</a>。<br>
例: <code>kubectl get pod -f ./pod.yaml</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>flags</code>: オプションのフラグを指定します。例えば、<code>-s</code>または<code>--server</code>フラグを使って、Kubernetes APIサーバーのアドレスやポートを指定できます。<br></p>
</li>
</ul>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> コマンドラインから指定したフラグは、デフォルト値および対応する任意の環境変数を上書きします。
</div>
<p>ヘルプが必要な場合は、ターミナルウィンドウから<code>kubectl help</code>を実行してください。</p>
<h2 id=操作>操作</h2>
<p>以下の表に、<code>kubectl</code>のすべての操作の簡単な説明と一般的な構文を示します。</p>
<table>
<thead>
<tr>
<th>操作                </th>
<th>構文</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alpha</code></td>
<td><code>kubectl alpha SUBCOMMAND [flags]</code></td>
<td>アルファ機能に該当する利用可能なコマンドを一覧表示します。これらの機能は、デフォルトではKubernetesクラスターで有効になっていません。</td>
</tr>
<tr>
<td><code>annotate</code></td>
<td><code>kubectl annotate (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td>
<td>1つ以上のリソースのアノテーションを、追加または更新します。</td>
</tr>
<tr>
<td><code>api-resources</code></td>
<td><code>kubectl api-resources [flags]</code></td>
<td>利用可能なAPIリソースを一覧表示します。</td>
</tr>
<tr>
<td><code>api-versions</code></td>
<td><code>kubectl api-versions [flags]</code></td>
<td>利用可能なAPIバージョンを一覧表示します。</td>
</tr>
<tr>
<td><code>apply</code></td>
<td><code>kubectl apply -f FILENAME [flags]</code></td>
<td>ファイルまたは標準出力から、リソースの設定変更を適用します。</td>
</tr>
<tr>
<td><code>attach</code></td>
<td><code>kubectl attach POD -c CONTAINER [-i] [-t] [flags]</code></td>
<td>実行中のコンテナにアタッチして、出力ストリームを表示するか、コンテナ(標準入力)と対話します。</td>
</tr>
<tr>
<td><code>auth</code></td>
<td><code>kubectl auth [flags] [options]</code></td>
<td>認可を検査します。</td>
</tr>
<tr>
<td><code>autoscale</code></td>
<td><code>kubectl autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]</code></td>
<td>ReplicationControllerで管理されているPodのセットを、自動的にスケールします。</td>
</tr>
<tr>
<td><code>certificate</code></td>
<td><code>kubectl certificate SUBCOMMAND [options]</code></td>
<td>証明書のリソースを変更します。</td>
</tr>
<tr>
<td><code>cluster-info</code></td>
<td><code>kubectl cluster-info [flags]</code></td>
<td>クラスター内のマスターとサービスに関するエンドポイント情報を表示します。</td>
</tr>
<tr>
<td><code>completion</code></td>
<td><code>kubectl completion SHELL [options]</code></td>
<td>指定されたシェル(bashまたはzsh)のシェル補完コードを出力します。</td>
</tr>
<tr>
<td><code>config</code></td>
<td><code>kubectl config SUBCOMMAND [flags]</code></td>
<td>kubeconfigファイルを変更します。詳細は、個々のサブコマンドを参照してください。</td>
</tr>
<tr>
<td><code>convert</code></td>
<td><code>kubectl convert -f FILENAME [options]</code></td>
<td>異なるAPIバージョン間で設定ファイルを変換します。YAMLとJSONに対応しています。</td>
</tr>
<tr>
<td><code>cordon</code></td>
<td><code>kubectl cordon NODE [options]</code></td>
<td>Nodeをスケジュール不可に設定します。</td>
</tr>
<tr>
<td><code>cp</code></td>
<td><code>kubectl cp &lt;file-spec-src> &lt;file-spec-dest> [options]</code></td>
<td>コンテナとの間でファイルやディレクトリをコピーします。</td>
</tr>
<tr>
<td><code>create</code></td>
<td><code>kubectl create -f FILENAME [flags]</code></td>
<td>ファイルまたは標準出力から、1つ以上のリソースを作成します。</td>
</tr>
<tr>
<td><code>delete</code></td>
<td><code>kubectl delete (-f FILENAME | TYPE [NAME | /NAME | -l label | --all]) [flags]</code></td>
<td>ファイル、標準出力、またはラベルセレクター、リソースセレクター、リソースを指定して、リソースを削除します。</td>
</tr>
<tr>
<td><code>describe</code></td>
<td><code>kubectl describe (-f FILENAME | TYPE [NAME_PREFIX | /NAME | -l label]) [flags]</code></td>
<td>1つ以上のリソースの詳細な状態を表示します。</td>
</tr>
<tr>
<td><code>diff</code></td>
<td><code>kubectl diff -f FILENAME [flags]</code></td>
<td>ファイルまたは標準出力と、現在の設定との差分を表示します。</td>
</tr>
<tr>
<td><code>drain</code></td>
<td><code>kubectl drain NODE [options]</code></td>
<td>メンテナンスの準備のためにNodeをdrainします。</td>
</tr>
<tr>
<td><code>edit</code></td>
<td><code>kubectl edit (-f FILENAME | TYPE NAME | TYPE/NAME) [flags]</code></td>
<td>デファルトのエディタを使い、サーバー上の1つ以上のリソースリソースの定義を編集し、更新します。</td>
</tr>
<tr>
<td><code>exec</code></td>
<td><code>kubectl exec POD [-c CONTAINER] [-i] [-t] [flags] [-- COMMAND [args...]]</code></td>
<td>Pod内のコンテナに対して、コマンドを実行します。</td>
</tr>
<tr>
<td><code>explain</code></td>
<td><code>kubectl explain [--recursive=false] [flags]</code></td>
<td>様々なリソースのドキュメントを取得します。例えば、Pod、Node、Serviceなどです。</td>
</tr>
<tr>
<td><code>expose</code></td>
<td><code>kubectl expose (-f FILENAME | TYPE NAME | TYPE/NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type] [flags]</code></td>
<td>ReplicationController、Service、Podを、新しいKubernetesサービスとして公開します。</td>
</tr>
<tr>
<td><code>get</code></td>
<td><code>kubectl get (-f FILENAME | TYPE [NAME | /NAME | -l label]) [--watch] [--sort-by=FIELD] [[-o | --output]=OUTPUT_FORMAT] [flags]</code></td>
<td>1つ以上のリソースを表示します。</td>
</tr>
<tr>
<td><code>kustomize</code></td>
<td><code>kubectl kustomize &lt;dir> [flags] [options]</code></td>
<td>kustomization.yamlファイル内の指示から生成されたAPIリソースのセットを一覧表示します。引数はファイルを含むディレクトリのPath，またはリポジトリルートに対して同じ場所を示すパスサフィックス付きのgitリポジトリのURLを指定しなければなりません。</td>
</tr>
<tr>
<td><code>label</code></td>
<td><code>kubectl label (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td>
<td>1つ以上のリソースのラベルを、追加または更新します。</td>
</tr>
<tr>
<td><code>logs</code></td>
<td><code>kubectl logs POD [-c CONTAINER] [--follow] [flags]</code></td>
<td>Pod内のコンテナのログを表示します。</td>
</tr>
<tr>
<td><code>options</code></td>
<td><code>kubectl options</code></td>
<td>すべてのコマンドに適用されるグローバルコマンドラインオプションを一覧表示します。</td>
</tr>
<tr>
<td><code>patch</code></td>
<td><code>kubectl patch (-f FILENAME | TYPE NAME | TYPE/NAME) --patch PATCH [flags]</code></td>
<td>Strategic Merge Patchの処理を使用して、リソースの1つ以上のフィールドを更新します。</td>
</tr>
<tr>
<td><code>plugin</code></td>
<td><code>kubectl plugin [flags] [options]</code></td>
<td>プラグインと対話するためのユーティリティを提供します。</td>
</tr>
<tr>
<td><code>port-forward</code></td>
<td><code>kubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N] [flags]</code></td>
<td>1つ以上のローカルポートを、Podに転送します。</td>
</tr>
<tr>
<td><code>proxy</code></td>
<td><code>kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]</code></td>
<td>Kubernetes APIサーバーへのプロキシーを実行します。</td>
</tr>
<tr>
<td><code>replace</code></td>
<td><code>kubectl replace -f FILENAME</code></td>
<td>ファイルや標準出力から、リソースを置き換えます。</td>
</tr>
<tr>
<td><code>rollout</code></td>
<td><code>kubectl rollout SUBCOMMAND [options]</code></td>
<td>リソースのロールアウトを管理します。有効なリソースには、Deployment、DaemonSetとStatefulSetが含まれます。</td>
</tr>
<tr>
<td><code>run</code></td>
<td><code>kubectl run NAME --image=image [--env="key=value"] [--port=port] [--dry-run=server|client|none] [--overrides=inline-json] [flags]</code></td>
<td>指定したイメージを、クラスタ上で実行します。</td>
</tr>
<tr>
<td><code>scale</code></td>
<td><code>kubectl scale (-f FILENAME | TYPE NAME | TYPE/NAME) --replicas=COUNT [--resource-version=version] [--current-replicas=count] [flags]</code></td>
<td>指定したReplicationControllerのサイズを更新します。</td>
</tr>
<tr>
<td><code>set</code></td>
<td><code>kubectl set SUBCOMMAND [options]</code></td>
<td>アプリケーションリソースを設定します。</td>
</tr>
<tr>
<td><code>taint</code></td>
<td><code>kubectl taint NODE NAME KEY_1=VAL_1:TAINT_EFFECT_1 ... KEY_N=VAL_N:TAINT_EFFECT_N [options]</code></td>
<td>1つ以上のNodeのtaintを更新します。</td>
</tr>
<tr>
<td><code>top</code></td>
<td><code>kubectl top [flags] [options]</code></td>
<td>リソース(CPU/メモリー/ストレージ)の使用量を表示します。</td>
</tr>
<tr>
<td><code>uncordon</code></td>
<td><code>kubectl uncordon NODE [options]</code></td>
<td>Nodeをスケジュール可に設定します。</td>
</tr>
<tr>
<td><code>version</code></td>
<td><code>kubectl version [--client] [flags]</code></td>
<td>クライアントとサーバーで実行中のKubernetesのバージョンを表示します。</td>
</tr>
<tr>
<td><code>wait</code></td>
<td><code>kubectl wait ([-f FILENAME] | resource.group/resource.name | resource.group [(-l label | --all)]) [--for=delete|--for condition=available] [options]</code></td>
<td>実験中の機能: 1つ以上のリソースが特定の状態になるまで待ちます。</td>
</tr>
</tbody>
</table>
<p>コマンド操作について詳しく知りたい場合は、<a href=/docs/reference/kubectl/kubectl/>kubectl</a>リファレンスドキュメントを参照してください。</p>
<h2 id=resource-types>リソースタイプ</h2>
<p>以下の表に、サポートされているすべてのリソースと、省略されたエイリアスの一覧を示します。</p>
<p>(この出力は<code>kubectl api-resources</code>から取得でき、Kubernetes 1.13.3時点で正確でした。)</p>
<table>
<thead>
<tr>
<th>リソース名</th>
<th>短縮名</th>
<th>APIグループ</th>
<th>名前空間に属するか</th>
<th>リソースの種類</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bindings</code></td>
<td></td>
<td></td>
<td>true</td>
<td>Binding</td>
</tr>
<tr>
<td><code>componentstatuses</code></td>
<td><code>cs</code></td>
<td></td>
<td>false</td>
<td>ComponentStatus</td>
</tr>
<tr>
<td><code>configmaps</code></td>
<td><code>cm</code></td>
<td></td>
<td>true</td>
<td>ConfigMap</td>
</tr>
<tr>
<td><code>endpoints</code></td>
<td><code>ep</code></td>
<td></td>
<td>true</td>
<td>Endpoints</td>
</tr>
<tr>
<td><code>limitranges</code></td>
<td><code>limits</code></td>
<td></td>
<td>true</td>
<td>LimitRange</td>
</tr>
<tr>
<td><code>namespaces</code></td>
<td><code>ns</code></td>
<td></td>
<td>false</td>
<td>Namespace</td>
</tr>
<tr>
<td><code>nodes</code></td>
<td><code>no</code></td>
<td></td>
<td>false</td>
<td>Node</td>
</tr>
<tr>
<td><code>persistentvolumeclaims</code></td>
<td><code>pvc</code></td>
<td></td>
<td>true</td>
<td>PersistentVolumeClaim</td>
</tr>
<tr>
<td><code>persistentvolumes</code></td>
<td><code>pv</code></td>
<td></td>
<td>false</td>
<td>PersistentVolume</td>
</tr>
<tr>
<td><code>pods</code></td>
<td><code>po</code></td>
<td></td>
<td>true</td>
<td>Pod</td>
</tr>
<tr>
<td><code>podtemplates</code></td>
<td></td>
<td></td>
<td>true</td>
<td>PodTemplate</td>
</tr>
<tr>
<td><code>replicationcontrollers</code></td>
<td><code>rc</code></td>
<td></td>
<td>true</td>
<td>ReplicationController</td>
</tr>
<tr>
<td><code>resourcequotas</code></td>
<td><code>quota</code></td>
<td></td>
<td>true</td>
<td>ResourceQuota</td>
</tr>
<tr>
<td><code>secrets</code></td>
<td></td>
<td></td>
<td>true</td>
<td>Secret</td>
</tr>
<tr>
<td><code>serviceaccounts</code></td>
<td><code>sa</code></td>
<td></td>
<td>true</td>
<td>ServiceAccount</td>
</tr>
<tr>
<td><code>services</code></td>
<td><code>svc</code></td>
<td></td>
<td>true</td>
<td>Service</td>
</tr>
<tr>
<td><code>mutatingwebhookconfigurations</code></td>
<td></td>
<td>admissionregistration.k8s.io</td>
<td>false</td>
<td>MutatingWebhookConfiguration</td>
</tr>
<tr>
<td><code>validatingwebhookconfigurations</code></td>
<td></td>
<td>admissionregistration.k8s.io</td>
<td>false</td>
<td>ValidatingWebhookConfiguration</td>
</tr>
<tr>
<td><code>customresourcedefinitions</code></td>
<td><code>crd</code>, <code>crds</code></td>
<td>apiextensions.k8s.io</td>
<td>false</td>
<td>CustomResourceDefinition</td>
</tr>
<tr>
<td><code>apiservices</code></td>
<td></td>
<td>apiregistration.k8s.io</td>
<td>false</td>
<td>APIService</td>
</tr>
<tr>
<td><code>controllerrevisions</code></td>
<td></td>
<td>apps</td>
<td>true</td>
<td>ControllerRevision</td>
</tr>
<tr>
<td><code>daemonsets</code></td>
<td><code>ds</code></td>
<td>apps</td>
<td>true</td>
<td>DaemonSet</td>
</tr>
<tr>
<td><code>deployments</code></td>
<td><code>deploy</code></td>
<td>apps</td>
<td>true</td>
<td>Deployment</td>
</tr>
<tr>
<td><code>replicasets</code></td>
<td><code>rs</code></td>
<td>apps</td>
<td>true</td>
<td>ReplicaSet</td>
</tr>
<tr>
<td><code>statefulsets</code></td>
<td><code>sts</code></td>
<td>apps</td>
<td>true</td>
<td>StatefulSet</td>
</tr>
<tr>
<td><code>tokenreviews</code></td>
<td></td>
<td>authentication.k8s.io</td>
<td>false</td>
<td>TokenReview</td>
</tr>
<tr>
<td><code>localsubjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>true</td>
<td>LocalSubjectAccessReview</td>
</tr>
<tr>
<td><code>selfsubjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SelfSubjectAccessReview</td>
</tr>
<tr>
<td><code>selfsubjectrulesreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SelfSubjectRulesReview</td>
</tr>
<tr>
<td><code>subjectaccessreviews</code></td>
<td></td>
<td>authorization.k8s.io</td>
<td>false</td>
<td>SubjectAccessReview</td>
</tr>
<tr>
<td><code>horizontalpodautoscalers</code></td>
<td><code>hpa</code></td>
<td>autoscaling</td>
<td>true</td>
<td>HorizontalPodAutoscaler</td>
</tr>
<tr>
<td><code>cronjobs</code></td>
<td><code>cj</code></td>
<td>batch</td>
<td>true</td>
<td>CronJob</td>
</tr>
<tr>
<td><code>jobs</code></td>
<td></td>
<td>batch</td>
<td>true</td>
<td>Job</td>
</tr>
<tr>
<td><code>certificatesigningrequests</code></td>
<td><code>csr</code></td>
<td>certificates.k8s.io</td>
<td>false</td>
<td>CertificateSigningRequest</td>
</tr>
<tr>
<td><code>leases</code></td>
<td></td>
<td>coordination.k8s.io</td>
<td>true</td>
<td>Lease</td>
</tr>
<tr>
<td><code>events</code></td>
<td><code>ev</code></td>
<td>events.k8s.io</td>
<td>true</td>
<td>Event</td>
</tr>
<tr>
<td><code>ingresses</code></td>
<td><code>ing</code></td>
<td>extensions</td>
<td>true</td>
<td>Ingress</td>
</tr>
<tr>
<td><code>networkpolicies</code></td>
<td><code>netpol</code></td>
<td>networking.k8s.io</td>
<td>true</td>
<td>NetworkPolicy</td>
</tr>
<tr>
<td><code>poddisruptionbudgets</code></td>
<td><code>pdb</code></td>
<td>policy</td>
<td>true</td>
<td>PodDisruptionBudget</td>
</tr>
<tr>
<td><code>podsecuritypolicies</code></td>
<td><code>psp</code></td>
<td>policy</td>
<td>false</td>
<td>PodSecurityPolicy</td>
</tr>
<tr>
<td><code>clusterrolebindings</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>false</td>
<td>ClusterRoleBinding</td>
</tr>
<tr>
<td><code>clusterroles</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>false</td>
<td>ClusterRole</td>
</tr>
<tr>
<td><code>rolebindings</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>true</td>
<td>RoleBinding</td>
</tr>
<tr>
<td><code>roles</code></td>
<td></td>
<td>rbac.authorization.k8s.io</td>
<td>true</td>
<td>Role</td>
</tr>
<tr>
<td><code>priorityclasses</code></td>
<td><code>pc</code></td>
<td>scheduling.k8s.io</td>
<td>false</td>
<td>PriorityClass</td>
</tr>
<tr>
<td><code>csidrivers</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>CSIDriver</td>
</tr>
<tr>
<td><code>csinodes</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>CSINode</td>
</tr>
<tr>
<td><code>storageclasses</code></td>
<td><code>sc</code></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>StorageClass</td>
</tr>
<tr>
<td><code>volumeattachments</code></td>
<td></td>
<td>storage.k8s.io</td>
<td>false</td>
<td>VolumeAttachment</td>
</tr>
</tbody>
</table>
<h2 id=出力オプション>出力オプション</h2>
<p>ある特定のコマンドの出力に対してフォーマットやソートを行う方法については、以下の節を参照してください。どのコマンドが様々な出力オプションをサポートしているかについては、<a href=/docs/reference/kubectl/kubectl/>kubectl</a>リファレンスドキュメントをご覧ください。</p>
<h3 id=出力のフォーマット>出力のフォーマット</h3>
<p>すべての<code>kubectl</code>コマンドのデフォルトの出力フォーマットは、人間が読みやすいプレーンテキスト形式です。特定のフォーマットで、詳細をターミナルウィンドウに出力するには、サポートされている<code>kubectl</code>コマンドに<code>-o</code>または<code>--output</code>フラグのいずれかを追加します。</p>
<h4 id=構文-1>構文</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> -o &lt;output_format&gt;
</code></pre></div><p><code>kubectl</code>の操作に応じて、以下の出力フォーマットがサポートされています。</p>
<table>
<thead>
<tr>
<th>出力フォーマット</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o custom-columns=&lt;spec></code></td>
<td><a href=#custom-columns>カスタムカラム</a>のコンマ区切りのリストを使用して、テーブルを表示します。</td>
</tr>
<tr>
<td><code>-o custom-columns-file=&lt;filename></code></td>
<td><code>&lt;filename></code>ファイル内の<a href=#custom-columns>カスタムカラム</a>のテンプレートを使用して、テーブルを表示します。</td>
</tr>
<tr>
<td><code>-o json</code></td>
<td>JSON形式のAPIオブジェクトを出力します。</td>
</tr>
<tr>
<td><code>-o jsonpath=&lt;template></code></td>
<td><a href=/ja/docs/reference/kubectl/jsonpath/>jsonpath</a>式で定義されたフィールドを表示します。</td>
</tr>
<tr>
<td><code>-o jsonpath-file=&lt;filename></code></td>
<td><code>&lt;filename></code>ファイル内の<a href=/ja/docs/reference/kubectl/jsonpath/>jsonpath</a>式で定義されたフィールドを表示します。</td>
</tr>
<tr>
<td><code>-o name</code></td>
<td>リソース名のみを表示します。</td>
</tr>
<tr>
<td><code>-o wide</code></td>
<td>追加情報を含めて、プレーンテキスト形式で出力します。Podの場合は、Node名が含まれます。</td>
</tr>
<tr>
<td><code>-o yaml</code></td>
<td>YAML形式のAPIオブジェクトを出力します。</td>
</tr>
</tbody>
</table>
<h5 id=例>例</h5>
<p>この例において、以下のコマンドは1つのPodの詳細を、YAML形式のオブジェクトとして出力します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod web-pod-13je7 -o yaml
</code></pre></div><p>各コマンドでサポートされている出力フォーマットの詳細については、<a href=/docs/reference/kubectl/kubectl/>kubectl</a>リファレンスドキュメントを参照してください。</p>
<h4 id=custom-columns>カスタムカラム</h4>
<p>カスタムカラムを定義して、必要な詳細のみをテーブルに出力するには、<code>custom-columns</code>オプションを使います。カスタムカラムをインラインで定義するか、<code>-o custom-columns=&lt;spec></code>または<code>-o custom-columns-file=&lt;filename></code>のようにテンプレートファイルを使用するかを選択できます。</p>
<h5 id=例-1>例</h5>
<p>インラインで定義する例は、以下の通りです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; -o custom-columns<span style=color:#666>=</span>NAME:.metadata.name,RSRC:.metadata.resourceVersion
</code></pre></div><p>テンプレートファイルを使用して定義する例は、以下の通りです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; -o custom-columns-file<span style=color:#666>=</span>template.txt
</code></pre></div><p>ここで、<code>template.txt</code>には以下の内容が含まれます。</p>
<pre><code>NAME          RSRC
metadata.name metadata.resourceVersion
</code></pre><p>どちらのコマンドを実行した場合でも、以下の結果を得ます。</p>
<pre><code>NAME           RSRC
submit-queue   610995
</code></pre><h4 id=サーバーサイドカラム>サーバーサイドカラム</h4>
<p><code>kubectl</code>は、サーバーからオブジェクトに関する特定のカラム情報を受け取ることをサポートしています。
つまり、与えられた任意のリソースについて、サーバーはそのリソースに関連する列や行を返し、クライアントが表示できるようにします。
これにより、サーバーが表示の詳細をカプセル化することで、同一クラスターに対して使用されているクライアント間で、一貫した人間が読みやすい出力が可能です。</p>
<p>この機能は、デフォルトで有効になっています。無効にするには、<code>kubectl get</code>コマンドに<code>--server-print=false</code>フラグを追加します。</p>
<h5 id=例-2>例</h5>
<p>Podの状態に関する情報を表示するには、以下のようなコマンドを使用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods &lt;pod-name&gt; --server-print<span style=color:#666>=</span><span style=color:#a2f>false</span>
</code></pre></div><p>以下のように出力されます。</p>
<pre><code>NAME       AGE
pod-name   1m
</code></pre><h3 id=オブジェクトリストのソート>オブジェクトリストのソート</h3>
<p>ターミナルウィンドウで、オブジェクトをソートされたリストに出力するには、サポートされている<code>kubectl</code>コマンドに<code>--sort-by</code>フラグを追加します。<code>--sort-by</code>フラグで任意の数値フィールドや文字列フィールドを指定することで、オブジェクトをソートします。フィールドの指定には、<a href=/ja/docs/reference/kubectl/jsonpath/>jsonpath</a>式を使用します。</p>
<h4 id=構文-2>構文</h4>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> --sort-by<span style=color:#666>=</span>&lt;jsonpath_exp&gt;
</code></pre></div><h5 id=例-3>例</h5>
<p>名前でソートしたPodのリストを表示するには、以下のように実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --sort-by<span style=color:#666>=</span>.metadata.name
</code></pre></div><h2 id=例-一般的な操作>例: 一般的な操作</h2>
<p>よく使われる<code>kubectl</code>の操作に慣れるために、以下の例を使用してください。</p>
<p><code>kubectl apply</code> - ファイルや標準出力から、リソースの適用や更新を行います。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># example-service.yaml内の定義を使用して、Serviceを作成します。</span>
kubectl apply -f example-service.yaml

<span style=color:#080;font-style:italic># example-controller.yaml内の定義を使用して、ReplicationControllerを作成します。</span>
kubectl apply -f example-controller.yaml

<span style=color:#080;font-style:italic># &lt;directory&gt;ディレクトリ内の、任意の.yaml、.yml、.jsonファイルで定義されているオブジェクトを作成します。</span>
kubectl apply -f &lt;directory&gt;
</code></pre></div><p><code>kubectl get</code> - 1つ以上のリソースの一覧を表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># すべてのPodの一覧をプレーンテキスト形式で表示します。</span>
kubectl get pods

<span style=color:#080;font-style:italic># すべてのPodの一覧を、ノード名などの追加情報を含めて、プレーンテキスト形式で表示します。</span>
kubectl get pods -o wide

<span style=color:#080;font-style:italic># 指定した名前のReplicationControllerの一覧をプレーンテキスト形式で表示します。&#39;replicationcontroller&#39;リソースタイプを短縮して、エイリアス&#39;rc&#39;で置き換えることもできます。</span>
kubectl get replicationcontroller &lt;rc-name&gt;

<span style=color:#080;font-style:italic># すべてのReplicationControllerとServiceの一覧をまとめてプレーンテキスト形式で表示します。</span>
kubectl get rc,services

<span style=color:#080;font-style:italic># すべてのDaemonSetの一覧をプレーンテキスト形式で表示します。</span>
kubectl get ds

<span style=color:#080;font-style:italic># server01ノードで実行中のPodの一覧をプレーンテキスト形式で表示します。</span>
kubectl get pods --field-selector<span style=color:#666>=</span>spec.nodeName<span style=color:#666>=</span>server01
</code></pre></div><p><code>kubectl describe</code> - 1つ以上のリソースの詳細な状態を、デフォルトでは初期化されないものも含めて表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Node &lt;node-name&gt;の詳細を表示します。</span>
kubectl describe nodes &lt;node-name&gt;

<span style=color:#080;font-style:italic># Pod &lt;pod-name&gt;の詳細を表示します。</span>
kubectl describe pods/&lt;pod-name&gt;

<span style=color:#080;font-style:italic># ReplicationController &lt;rc-name&gt;が管理しているすべてのPodの詳細を表示します。</span>
<span style=color:#080;font-style:italic># ReplicationControllerによって作成された任意のPodには、ReplicationControllerの名前がプレフィックスとして付与されます。</span>
kubectl describe pods &lt;rc-name&gt;

<span style=color:#080;font-style:italic># すべてのPodの詳細を表示します。</span>
kubectl describe pods
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>kubectl get</code>コマンドは通常、同じリソースタイプの1つ以上のリソースを取得するために使用します。豊富なフラグが用意されており、例えば<code>-o</code>や<code>--output</code>フラグを使って、出力フォーマットをカスタマイズできます。<code>-w</code>や<code>--watch</code>フラグを指定することで、特定のオブジェクトの更新を監視できます。<code>kubectl describe</code>コマンドは、指定されたリソースに関する多くの側面を説明することに重点を置いています。ユーザーに対してビューを構築するために、APIサーバーへ複数のAPIコールを呼び出すことができます。例えば、<code>kubectl describe node</code>コマンドは、Nodeに関する情報だけでなく、その上で動いているPodやNodeで生成されたイベントなどをまとめて表示します。
</div>
<p><code>kubectl delete</code> - ファイル、標準出力、または指定したラベルセレクター、名前、リソースセレクター、リソースを指定して、リソースを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># pod.yamlファイルで指定されたタイプと名前を用いて、Podを削除します。</span>
kubectl delete -f pod.yaml

<span style=color:#080;font-style:italic># &#39;&lt;label-key&gt;=&lt;label-value&gt;&#39;というラベルを持つPodとServiceをすべて削除します。</span>
kubectl delete pods,services -l &lt;label-key&gt;<span style=color:#666>=</span>&lt;label-value&gt;

<span style=color:#080;font-style:italic># 初期化されていないPodを含む、すべてのPodを削除します。</span>
kubectl delete pods --all
</code></pre></div><p><code>kubectl exec</code> - Pod内のコンテナに対してコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Pod &lt;pod-name&gt;から、&#39;date&#39;を実行している時の出力を取得します。デフォルトでは、最初のコンテナから出力されます。</span>
kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -- date

<span style=color:#080;font-style:italic># Pod &lt;pod-name&gt;のコンテナ &lt;container-name&gt;から、&#39;date&#39;を実行している時の出力を取得します。</span>
kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -c &lt;container-name&gt; -- date

<span style=color:#080;font-style:italic># インタラクティブな TTY を取得し、Pod &lt;pod-name&gt;から/bin/bashを実行します。デフォルトでは、最初のコンテナから出力されます。</span>
kubectl <span style=color:#a2f>exec</span> -ti &lt;pod-name&gt; -- /bin/bash
</code></pre></div><p><code>kubectl logs</code> - Pod内のコンテナのログを表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Pod &lt;pod-name&gt;のログのスナップショットを返します。</span>
kubectl logs &lt;pod-name&gt;

<span style=color:#080;font-style:italic># Pod &lt;pod-name&gt;から、ログのストリーミングを開始します。Linuxの&#39;tail -f&#39;コマンドと似ています。</span>
kubectl logs -f &lt;pod-name&gt;
</code></pre></div><p><code>kubectl diff</code> - 提案されたクラスタに対する更新の差分を表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># pod.jsonに含まれるリソースの差分を表示します。</span>
kubectl diff -f pod.json

<span style=color:#080;font-style:italic># 標準出力から読み込んだファイルの差分を表示します。</span>
cat service.yaml | kubectl diff -f -
</code></pre></div><h2 id=例-プラグインの作成と使用>例: プラグインの作成と使用</h2>
<p><code>kubectl</code>プラグインの書き方や使い方に慣れるために、以下の例を使用してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 任意の言語でシンプルなプラグインを作成し、生成される実行可能なファイルに</span>
<span style=color:#080;font-style:italic># プレフィックス&#34;kubectl-&#34;で始まる名前を付けます。</span>
cat ./kubectl-hello
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080>#!/bin/sh
</span><span style=color:#080></span>
<span style=color:#080;font-style:italic># このプラグインは、&#34;hello world&#34;という単語を表示します。</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;hello world&#34;</span>
</code></pre></div><p>プラグインを書いたら、実行可能にします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>chmod a+x ./kubectl-hello

<span style=color:#080;font-style:italic># さらに、PATH内の場所に移動させます。</span>
sudo mv ./kubectl-hello /usr/local/bin
sudo chown root:root /usr/local/bin

<span style=color:#080;font-style:italic># これでkubectlプラグインを作成し、&#34;インストール&#34;できました。</span>
<span style=color:#080;font-style:italic># 通常のコマンドのようにkubectlから呼び出すことで、プラグインを使用できます。</span>
kubectl hello
</code></pre></div><pre><code>hello world
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># 配置したPATHのフォルダから削除することで、プラグインを&#34;アンインストール&#34;できます。</span>
sudo rm /usr/local/bin/kubectl-hello
</code></pre></div><p><code>kubectl</code>で利用可能なプラグインをすべて表示するには、<code>kubectl plugin list</code>サブコマンドを使用してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl plugin list
</code></pre></div><p>出力は以下のようになります。</p>
<pre><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
/usr/local/bin/kubectl-bar
</code></pre><p><code>kubectl plugin list</code>コマンドは、実行不可能なプラグインや、他のプラグインの影に隠れてしまっているプラグインなどについて、警告することもできます。例えば、以下のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sudo chmod -x /usr/local/bin/kubectl-foo <span style=color:#080;font-style:italic># 実行権限を削除します。</span>
kubectl plugin list
</code></pre></div><pre><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
  - warning: /usr/local/bin/kubectl-foo identified as a plugin, but it is not executable
/usr/local/bin/kubectl-bar

error: one plugin warning was found
</code></pre><p>プラグインは、既存の<code>kubectl</code>コマンドの上に、より複雑な機能を構築するための手段であると考えることができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat ./kubectl-whoami
</code></pre></div><p>次の例では、下記の内容を含んだ<code>kubectl-whoami</code>が既に作成済であることを前提としています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080>#!/bin/bash
</span><span style=color:#080></span>
<span style=color:#080;font-style:italic># このプラグインは、`kubectl config`コマンドを使って</span>
<span style=color:#080;font-style:italic># 現在選択されているコンテキストに基づいて、現在のユーザーに関する情報を提供します。</span>
kubectl config view --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{ range .contexts }}{{ if eq .name &#34;&#39;</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config current-context<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#39;&#34; }}Current user: {{ printf &#34;%s\n&#34; .context.user }}{{ end }}{{ end }}&#39;</span>
</code></pre></div><p>上記のコマンドを実行すると、KUBECONFIGファイル内のカレントコンテキストのユーザーを含んだ出力を得られます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># ファイルを実行可能にします。</span>
sudo chmod +x ./kubectl-whoami

<span style=color:#080;font-style:italic># さらに、ファイルをPATHに移動します。</span>
sudo mv ./kubectl-whoami /usr/local/bin

kubectl whoami
Current user: plugins-user
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li>
<p><a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a>を使い始めてください。</p>
</li>
<li>
<p>プラグインについてより詳しく知りたい場合は, <a href=https://github.com/kubernetes/sample-cli-plugin>example cli plugin</a>を御覧ください。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a938176c695852fe70362c29cf615f1c>4.2 - JSONPathのサポート</h1>
<p>kubectlはJSONPathのテンプレートをサポートしています。</p>
<p>JSONPathのテンプレートは、波括弧<code>{}</code>によって囲まれたJSONPathの式によって構成されています。
kubectlでは、JSONPathの式を使うことで、JSONオブジェクトの特定のフィールドをフィルターしたり、出力のフォーマットを変更することができます。
本来のJSONPathのテンプレートの構文に加え、以下の機能と構文が使えます:</p>
<ol>
<li>JSONPathの式の内部でテキストをクォートするために、ダブルクォーテーションを使用します。</li>
<li>リストを反復するために、<code>range</code>、<code>end</code>オペレーターを使用します。</li>
<li>リストを末尾側から参照するために、負の数のインデックスを使用します。負の数のインデックスはリストを「周回」せず、<code>-index + listLength >= 0</code>が満たされる限りにおいて有効になります。</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <ul>
<li>
<p>式は常にルートのオブジェクトから始まるので、<code>$</code>オペレーターの入力は任意になります。</p>
</li>
<li>
<p>結果のオブジェクトはString()関数を適用した形で表示されます。</p>
</li>
</ul>
</div>
<p>以下のようなJSONの入力が与えられたとします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;List&#34;</span>,
  <span style=color:green;font-weight:700>&#34;items&#34;</span>:[
    {
      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>},
      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;4&#34;</span>},
        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[{<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>}]
      }
    },
    {
      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;8&#34;</span>},
        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[
          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;another&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.3&#34;</span>}
        ]
      }
    }
  ],
  <span style=color:green;font-weight:700>&#34;users&#34;</span>:[
    {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;myself&#34;</span>,
      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {}
    },
    {
      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;e2e&#34;</span>,
      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {<span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;admin&#34;</span>, <span style=color:green;font-weight:700>&#34;password&#34;</span>: <span style=color:#b44>&#34;secret&#34;</span>}
    }
  ]
}
</code></pre></div><table>
<thead>
<tr>
<th>機能</th>
<th>説明</th>
<th>例</th>
<th>結果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>text</code></td>
<td>プレーンテキスト</td>
<td><code>kind is {.kind}</code></td>
<td><code>kind is List</code></td>
</tr>
<tr>
<td><code>@</code></td>
<td>現在のオブジェクト</td>
<td><code>{@}</code></td>
<td>入力した値と同じ値</td>
</tr>
<tr>
<td><code>.</code> or <code>[]</code></td>
<td>子要素</td>
<td><code>{.kind}</code>, <code>{['kind']}</code> or <code>{['name\.type']}</code></td>
<td><code>List</code></td>
</tr>
<tr>
<td><code>..</code></td>
<td>子孫要素を再帰的に探す</td>
<td><code>{..name}</code></td>
<td><code>127.0.0.1 127.0.0.2 myself e2e</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>ワイルドカード。すべてのオブジェクトを取得する</td>
<td><code>{.items[*].metadata.name}</code></td>
<td><code>[127.0.0.1 127.0.0.2]</code></td>
</tr>
<tr>
<td><code>[start:end:step]</code></td>
<td>添字</td>
<td><code>{.users[0].name}</code></td>
<td><code>myself</code></td>
</tr>
<tr>
<td><code>[,]</code></td>
<td>和集合</td>
<td><code>{.items[*]['metadata.name', 'status.capacity']}</code></td>
<td><code>127.0.0.1 127.0.0.2 map[cpu:4] map[cpu:8]</code></td>
</tr>
<tr>
<td><code>?()</code></td>
<td>フィルター</td>
<td><code>{.users[?(@.name=="e2e")].user.password}</code></td>
<td><code>secret</code></td>
</tr>
<tr>
<td><code>range</code>, <code>end</code></td>
<td>リストの反復</td>
<td><code>{range .items[*]}[{.metadata.name}, {.status.capacity}] {end}</code></td>
<td><code>[127.0.0.1, map[cpu:4]] [127.0.0.2, map[cpu:8]]</code></td>
</tr>
<tr>
<td><code>''</code></td>
<td>解釈済みの文字列をクォートする</td>
<td><code>{range .items[*]}{.metadata.name}{'\t'}{end}</code></td>
<td><code>127.0.0.1 127.0.0.2</code></td>
</tr>
</tbody>
</table>
<p><code>kubectl</code>とJSONPathの式を使った例:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -o json
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{@}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0]}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0].metadata.name}&#39;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*][&#39;metadata.name&#39;, &#39;status.capacity&#39;]}&#34;</span>
kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{.metadata.name}{&#34;\t&#34;}{.status.startTime}{&#34;\n&#34;}{end}&#39;</span>
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>Windowsでは、空白が含まれるJSONPathのテンプレートをクォートする場合は(上記のようにシングルクォーテーションを使うのではなく)、ダブルクォーテーションを使わなければなりません。
また、テンプレート内のリテラルをクォートする際には、シングルクォーテーションか、エスケープされたダブルクォーテーションを使わなければなりません。例えば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd>kubectl get pods -o=jsonpath=<span style=color:#b44>&#34;{range .items[*]}{.metadata.name}{&#39;\t&#39;}{.status.startTime}{&#39;\n&#39;}{end}&#34;</span>
kubectl get pods -o=jsonpath=<span style=color:#b44>&#34;{range .items[*]}{.metadata.name}{\&#34;</span>\t\<span style=color:#b44>&#34;}{.status.startTime}{\&#34;</span>\n\<span style=color:#b44>&#34;}{end}&#34;</span>
</code></pre></div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>JSONPathの正規表現はサポートされていません。正規表現を利用した検索を行いたい場合は、<code>jq</code>のようなツールを使ってください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># kubectlはJSONpathの出力として正規表現をサポートしていないので、以下のコマンドは動作しない</span>
kubectl get pods -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[?(@.metadata.name=~/^test$/)].metadata.name}&#39;</span>

<span style=color:#080;font-style:italic># 上のコマンドに期待される結果が欲しい場合、以下のコマンドを使うとよい</span>
kubectl get pods -o json | jq -r <span style=color:#b44>&#39;.items[] | select(.metadata.name | test(&#34;test-&#34;)).spec.containers[].image&#39;</span>
</code></pre></div>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8aba901ac13f124e5782b90ddb166ee2>4.3 - kubectlチートシート</h1>
<p>このページには、一般的によく使われる<code>kubectl</code>コマンドとフラグのリストが含まれています。</p>
<h2 id=kubectlコマンドの補完>Kubectlコマンドの補完</h2>
<h3 id=bash>BASH</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion bash<span style=color:#666>)</span> <span style=color:#080;font-style:italic># 現在のbashシェルにコマンド補完を設定するには、最初にbash-completionパッケージをインストールする必要があります。</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;source &lt;(kubectl completion bash)&#34;</span> &gt;&gt; ~/.bashrc <span style=color:#080;font-style:italic># bashシェルでのコマンド補完を永続化するために.bashrcに追記します。</span>
</code></pre></div><p>また、エイリアスを使用している場合にも<code>kubectl</code>コマンドを補完できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>alias</span> <span style=color:#b8860b>k</span><span style=color:#666>=</span>kubectl
<span style=color:#a2f>complete</span> -F __start_kubectl k
</code></pre></div><h3 id=zsh>ZSH</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>  <span style=color:#080;font-style:italic># 現在のzshシェルにコマンド補完を設定します</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;[[ </span><span style=color:#b8860b>$commands</span><span style=color:#b44>[kubectl] ]] &amp;&amp; source &lt;(kubectl completion zsh)&#34;</span> &gt;&gt; ~/.zshrc <span style=color:#080;font-style:italic># zshシェルでのコマンド補完を永続化するために.zshrcに追記します。</span>
</code></pre></div><h2 id=kubectlコンテキストの設定>Kubectlコンテキストの設定</h2>
<p><code>kubectl</code>がどのKubernetesクラスターと通信するかを設定します。
設定ファイル詳細については<a href=/ja/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfigを使用した複数クラスターとの認証</a>をご覧ください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl config view <span style=color:#080;font-style:italic># マージされたkubeconfigの設定を表示します。</span>

<span style=color:#080;font-style:italic># 複数のkubeconfigファイルを同時に読み込む場合はこのように記述します。</span>
<span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>~/.kube/config:~/.kube/kubconfig2 

kubectl config view

<span style=color:#080;font-style:italic># e2eユーザのパスワードを取得します。</span>
kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[?(@.name == &#34;e2e&#34;)].user.password}&#39;</span>

kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[].name}&#39;</span>    <span style=color:#080;font-style:italic># 最初のユーザー名を表示します</span>
kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[*].name}&#39;</span>   <span style=color:#080;font-style:italic># ユーザー名のリストを表示します</span>
kubectl config get-contexts                          <span style=color:#080;font-style:italic># コンテキストのリストを表示します</span>
kubectl config current-context                       <span style=color:#080;font-style:italic># 現在のコンテキストを表示します</span>
kubectl config use-context my-cluster-name           <span style=color:#080;font-style:italic># デフォルトのコンテキストをmy-cluster-nameに設定します</span>

<span style=color:#080;font-style:italic># basic認証をサポートする新たなユーザーをkubeconfigに追加します</span>
kubectl config set-credentials kubeuser/foo.kubernetes.com --username<span style=color:#666>=</span>kubeuser --password<span style=color:#666>=</span>kubepassword

<span style=color:#080;font-style:italic># 現在のコンテキストでkubectlのサブコマンドの名前空間を永続的に変更します</span>
kubectl config set-context --current --namespace<span style=color:#666>=</span>ggckad-s2

<span style=color:#080;font-style:italic># 特定のユーザー名と名前空間を使用してコンテキストを設定します</span>
kubectl config set-context gce --user<span style=color:#666>=</span>cluster-admin --namespace<span style=color:#666>=</span>foo <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> kubectl config use-context gce
 
kubectl config <span style=color:#a2f>unset</span> users.foo    <span style=color:#080;font-style:italic># ユーザーfooを削除します</span>
</code></pre></div><h2 id=kubectl-apply>Kubectl Apply</h2>
<p><code>apply</code>はKubernetesリソースを定義するファイルを通じてアプリケーションを管理します。<code>kubectl apply</code>を実行して、クラスター内のリソースを作成および更新します。これは、本番環境でKubernetesアプリケーションを管理する推奨方法です。
詳しくは<a href=https://kubectl.docs.kubernetes.io>Kubectl Book</a>をご覧ください。</p>
<h2 id=objectの作成>Objectの作成</h2>
<p>Kubernetesのマニフェストファイルは、JSONまたはYAMLで定義できます。ファイル拡張子として、<code>.yaml</code>や<code>.yml</code>、<code>.json</code>が使えます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f ./my-manifest.yaml            <span style=color:#080;font-style:italic># リソースを作成します</span>
kubectl apply -f ./my1.yaml -f ./my2.yaml      <span style=color:#080;font-style:italic># 複数のファイルからリソースを作成します</span>
kubectl apply -f ./dir                         <span style=color:#080;font-style:italic># dirディレクトリ内のすべてのマニフェストファイルからリソースを作成します</span>
kubectl apply -f https://git.io/vPieo          <span style=color:#080;font-style:italic># urlで公開されているファイルからリソースを作成します</span>
kubectl create deployment nginx --image<span style=color:#666>=</span>nginx  <span style=color:#080;font-style:italic># 単一のnginx Deploymentを作成します</span>
kubectl explain pods                           <span style=color:#080;font-style:italic># Podマニフェストのドキュメントを取得します</span>

<span style=color:#080;font-style:italic># 標準入力から複数のYAMLオブジェクトを作成します</span>

cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: busybox-sleep
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>  - name: busybox
</span><span style=color:#b44>    image: busybox
</span><span style=color:#b44>    args:
</span><span style=color:#b44>    - sleep
</span><span style=color:#b44>    - &#34;1000000&#34;
</span><span style=color:#b44>---
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: busybox-sleep-less
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>  - name: busybox
</span><span style=color:#b44>    image: busybox
</span><span style=color:#b44>    args:
</span><span style=color:#b44>    - sleep
</span><span style=color:#b44>    - &#34;1000&#34;
</span><span style=color:#b44>EOF</span>

<span style=color:#080;font-style:italic># いくつかの鍵を含むSecretを作成します</span>

cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Secret
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: mysecret
</span><span style=color:#b44>type: Opaque
</span><span style=color:#b44>data:
</span><span style=color:#b44>  password: $(echo -n &#34;s33msi4&#34; | base64 -w0)
</span><span style=color:#b44>  username: $(echo -n &#34;jane&#34; | base64 -w0)
</span><span style=color:#b44>EOF</span>

</code></pre></div><h2 id=リソースの検索と閲覧>リソースの検索と閲覧</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># Getコマンドで基本的な情報を確認します</span>
kubectl get services                          <span style=color:#080;font-style:italic># 現在の名前空間上にあるすべてのサービスのリストを表示します</span>
kubectl get pods --all-namespaces             <span style=color:#080;font-style:italic># すべての名前空間上にあるすべてのPodのリストを表示します</span>
kubectl get pods -o wide                      <span style=color:#080;font-style:italic># 現在の名前空間上にあるすべてのPodについてより詳細なリストを表示します</span>
kubectl get deployment my-dep                 <span style=color:#080;font-style:italic># 特定のDeploymentを表示します</span>
kubectl get pods                              <span style=color:#080;font-style:italic># 現在の名前空間上にあるすべてのPodのリストを表示します</span>
kubectl get pod my-pod -o yaml                <span style=color:#080;font-style:italic># PodのYAMLを表示します</span>

<span style=color:#080;font-style:italic># Describeコマンドで詳細な情報を確認します</span>
kubectl describe nodes my-node
kubectl describe pods my-pod

<span style=color:#080;font-style:italic># 名前順にソートしたServiceのリストを表示します</span>
kubectl get services --sort-by<span style=color:#666>=</span>.metadata.name

<span style=color:#080;font-style:italic># Restartカウント順にPodのリストを表示します</span>
kubectl get pods --sort-by<span style=color:#666>=</span><span style=color:#b44>&#39;.status.containerStatuses[0].restartCount&#39;</span>

<span style=color:#080;font-style:italic># capacity順にソートしたPersistentVolumeのリストを表示します</span>
kubectl get pv --sort-by<span style=color:#666>=</span>.spec.capacity.storage

<span style=color:#080;font-style:italic># app=cassandraラベルのついたすべてのPodのversionラベルを表示します</span>
kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra -o <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.labels.version}&#39;</span>

<span style=color:#080;font-style:italic># &#39;ca.crt&#39;のようなピリオドが含まれるキーの値を取得します</span>
kubectl get configmap myconfig <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.ca\.crt}&#39;</span>

<span style=color:#080;font-style:italic># すべてのワーカーノードを取得します（セレクターを使用して、</span>
<span style=color:#080;font-style:italic># 「node-role.kubernetes.io/master」という名前のラベルを持つ結果を除外します）</span>
kubectl get node --selector<span style=color:#666>=</span><span style=color:#b44>&#39;!node-role.kubernetes.io/master&#39;</span>

<span style=color:#080;font-style:italic># 現在の名前空間でrunning状態のPodのリストを表示します</span>
kubectl get pods --field-selector<span style=color:#666>=</span>status.phase<span style=color:#666>=</span>Running

<span style=color:#080;font-style:italic># すべてのノードのExternal IPのリストを表示します</span>
kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].status.addresses[?(@.type==&#34;ExternalIP&#34;)].address}&#39;</span>

<span style=color:#080;font-style:italic># 特定のRCに属するPodの名前のリストを表示します</span>
<span style=color:#080;font-style:italic># `jq`コマンドは複雑なjsonpathを変換する場合に便利であり、https://stedolan.github.io/jq/で見つけることが可能です</span>
<span style=color:#b8860b>sel</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get rc my-rc --output<span style=color:#666>=</span>json | jq -j <span style=color:#b44>&#39;.spec.selector | to_entries | .[] | &#34;\(.key)=\(.value),&#34;&#39;</span><span style=color:#a2f;font-weight:700>)</span>%?<span style=color:#b68;font-weight:700>}</span>
<span style=color:#a2f>echo</span> <span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>$sel</span> --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>

<span style=color:#080;font-style:italic># すべてのPod(またはラベル付けをサポートする他のKubernetesオブジェクト)のラベルのリストを表示します</span>
kubectl get pods --show-labels

<span style=color:#080;font-style:italic># どのノードがready状態か確認します</span>
<span style=color:#b8860b>JSONPATH</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span> <span style=color:#666>&amp;&amp;</span> kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$JSONPATH</span><span style=color:#b44>&#34;</span> | grep <span style=color:#b44>&#34;Ready=True&#34;</span>

<span style=color:#080;font-style:italic># Podで現在使用中のSecretをすべて表示します</span>
kubectl get pods -o json | jq <span style=color:#b44>&#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39;</span> | grep -v null | sort | uniq

<span style=color:#080;font-style:italic># すべてのPodのInitContainerのコンテナIDのリストを表示します</span>
<span style=color:#080;font-style:italic># initContainerの削除を回避しながら、停止したコンテナを削除するときに役立つでしょう</span>
kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*].status.initContainerStatuses[*]}{.containerID}{&#34;\n&#34;}{end}&#39;</span> | cut -d/ -f3

<span style=color:#080;font-style:italic># タイムスタンプでソートされたEventのリストを表示します</span>
kubectl get events --sort-by<span style=color:#666>=</span>.metadata.creationTimestamp

<span style=color:#080;font-style:italic># クラスターの現在の状態を、マニフェストが適用された場合のクラスターの状態と比較します。</span>
kubectl diff -f ./my-manifest.yaml

<span style=color:#080;font-style:italic># Nodeから返されるすべてのキーをピリオド区切りの階層表記で生成します。</span>
<span style=color:#080;font-style:italic># 複雑にネストされたJSON構造をもつキーを指定したい時に便利です</span>
kubectl get nodes -o json | jq -c <span style=color:#b44>&#39;path(..)|[.[]|tostring]|join(&#34;.&#34;)&#39;</span>

<span style=color:#080;font-style:italic># Pod等から返されるすべてのキーをピリオド区切り階層表記で生成します。</span>
kubectl get pods -o json | jq -c <span style=color:#b44>&#39;path(..)|[.[]|tostring]|join(&#34;.&#34;)&#39;</span>
</code></pre></div><h2 id=リソースのアップデート>リソースのアップデート</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl <span style=color:#a2f>set</span> image deployment/frontend <span style=color:#b8860b>www</span><span style=color:#666>=</span>image:v2               <span style=color:#080;font-style:italic># frontend Deploymentのwwwコンテナイメージをv2にローリングアップデートします</span>
kubectl rollout <span style=color:#a2f>history</span> deployment/frontend                      <span style=color:#080;font-style:italic># frontend Deploymentの改訂履歴を確認します</span>
kubectl rollout undo deployment/frontend                         <span style=color:#080;font-style:italic># 1つ前のDeploymentにロールバックします</span>
kubectl rollout undo deployment/frontend --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>         <span style=color:#080;font-style:italic># 特定のバージョンにロールバックします</span>
kubectl rollout status -w deployment/frontend                    <span style=color:#080;font-style:italic># frontend Deploymentのローリングアップデートを状態をwatchします</span>
kubectl rollout restart deployment/frontend                      <span style=color:#080;font-style:italic># frontend Deployment を再起動します</span>


cat pod.json | kubectl replace -f -                              <span style=color:#080;font-style:italic># 標準入力から渡されたJSONに基づいてPodを置き換えます</span>

<span style=color:#080;font-style:italic># リソースを強制的に削除してから再生成し、置き換えます。サービスの停止が発生します</span>
kubectl replace --force -f ./pod.json

<span style=color:#080;font-style:italic># ReplicaSetリソースで作られたnginxについてServiceを作成します。これは、ポート80で提供され、コンテナへはポート8000で接続します</span>
kubectl expose rc nginx --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8000</span>

<span style=color:#080;font-style:italic># 単一コンテナのPodイメージのバージョン(タグ)をv4に更新します</span>
kubectl get pod mypod -o yaml | sed <span style=color:#b44>&#39;s/\(image: myimage\):.*$/\1:v4/&#39;</span> | kubectl replace -f -

kubectl label pods my-pod new-label<span style=color:#666>=</span>awesome                      <span style=color:#080;font-style:italic># ラベルを追加します</span>
kubectl annotate pods my-pod icon-url<span style=color:#666>=</span>http://goo.gl/XXBTWq       <span style=color:#080;font-style:italic># アノテーションを追加します</span>
kubectl autoscale deployment foo --min<span style=color:#666>=</span><span style=color:#666>2</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>                <span style=color:#080;font-style:italic># &#34;foo&#34; Deploymentのオートスケーリングを行います</span>
</code></pre></div><h2 id=リソースへのパッチ適用>リソースへのパッチ適用</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># ノードを部分的に更新します</span>
kubectl patch node k8s-node-1 -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;unschedulable&#34;:true}}&#39;</span>

<span style=color:#080;font-style:italic># コンテナのイメージを更新します。spec.containers[*].nameはマージキーであるため必須です</span>
kubectl patch pod valid-pod -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;kubernetes-serve-hostname&#34;,&#34;image&#34;:&#34;new image&#34;}]}}&#39;</span>

<span style=color:#080;font-style:italic># ポテンシャル配列を含むJSONパッチを使用して、コンテナのイメージを更新します</span>
kubectl patch pod valid-pod --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/containers/0/image&#34;, &#34;value&#34;:&#34;new image&#34;}]&#39;</span>

<span style=color:#080;font-style:italic># ポテンシャル配列のJSONパッチを使用してDeploymentのlivenessProbeを無効にします</span>
kubectl patch deployment valid-deployment  --type json   -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/livenessProbe&#34;}]&#39;</span>

<span style=color:#080;font-style:italic># ポテンシャル配列に新たな要素を追加します</span>
kubectl patch sa default --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/secrets/1&#34;, &#34;value&#34;: {&#34;name&#34;: &#34;whatever&#34; } }]&#39;</span>
</code></pre></div><h2 id=リソースの編集>リソースの編集</h2>
<p>任意のエディターでAPIリソースを編集します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl edit svc/docker-registry                      <span style=color:#080;font-style:italic># docker-registryという名前のサービスを編集します</span>
<span style=color:#b8860b>KUBE_EDITOR</span><span style=color:#666>=</span><span style=color:#b44>&#34;nano&#34;</span> kubectl edit svc/docker-registry   <span style=color:#080;font-style:italic># エディターを指定します</span>
</code></pre></div><h2 id=リソースのスケーリング>リソースのスケーリング</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> rs/foo                                 <span style=color:#080;font-style:italic># 「foo」という名前のレプリカセットを3にスケーリングします</span>
kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> -f foo.yaml                            <span style=color:#080;font-style:italic># 「foo.yaml」で指定されたリソースを3にスケーリングします</span>
kubectl scale --current-replicas<span style=color:#666>=</span><span style=color:#666>2</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span> deployment/mysql  <span style=color:#080;font-style:italic># mysqlと名付けられたdeploymentの現在のサイズが2であれば、mysqlを3にスケーリングします</span>
kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>5</span> rc/foo rc/bar rc/baz                   <span style=color:#080;font-style:italic># 複数のReplication controllerをスケーリングします</span>
</code></pre></div><h2 id=リソースの削除>リソースの削除</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl delete -f ./pod.json                                              <span style=color:#080;font-style:italic># pod.jsonで指定されたタイプと名前を使用してPodを削除します</span>
kubectl delete pod,service baz foo                                        <span style=color:#080;font-style:italic># 「baz」と「foo」の名前を持つPodとServiceを削除します</span>
kubectl delete pods,services -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                              <span style=color:#080;font-style:italic># name=myLabelラベルを持つのPodとServiceを削除します</span>
kubectl -n my-ns delete pod,svc --all                                     <span style=color:#080;font-style:italic># 名前空間my-ns内のすべてのPodとServiceを削除します</span>
<span style=color:#080;font-style:italic># awkコマンドのpattern1またはpattern2に一致するすべてのPodを削除します。</span>
kubectl get pods  -n mynamespace --no-headers<span style=color:#666>=</span><span style=color:#a2f>true</span> | awk <span style=color:#b44>&#39;/pattern1|pattern2/{print $1}&#39;</span> | xargs  kubectl delete -n mynamespace pod
</code></pre></div><h2 id=実行中のポッドとの対話処理>実行中のポッドとの対話処理</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl logs my-pod                                 <span style=color:#080;font-style:italic># Podのログをダンプします(標準出力)</span>
kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                        <span style=color:#080;font-style:italic># name=myLabelラベルの持つPodのログをダンプします(標準出力)</span>
kubectl logs my-pod --previous                      <span style=color:#080;font-style:italic># 以前に存在したコンテナのPodログをダンプします(標準出力)</span>
kubectl logs my-pod -c my-container                 <span style=color:#080;font-style:italic># 複数コンテナがあるPodで、特定のコンテナのログをダンプします(標準出力)</span>
kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel -c my-container        <span style=color:#080;font-style:italic># name=mylabelラベルを持つPodのログをダンプします(標準出力) </span>
kubectl logs my-pod -c my-container --previous      <span style=color:#080;font-style:italic># 複数コンテナがあるPodで、以前に作成した特定のコンテナのログをダンプします(標準出力)</span>
kubectl logs -f my-pod                              <span style=color:#080;font-style:italic># Podのログをストリームで確認します(標準出力)</span>
kubectl logs -f my-pod -c my-container              <span style=color:#080;font-style:italic># 複数のコンテナがあるPodで、特定のコンテナのログをストリームで確認します(標準出力)</span>
kubectl logs -f -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel --all-containers    <span style=color:#080;font-style:italic># name-myLabelラベルを持つすべてのコンテナのログをストリームで確認します(標準出力)</span>
kubectl run -i --tty busybox --image<span style=color:#666>=</span>busybox -- sh  <span style=color:#080;font-style:italic># Podをインタラクティブシェルとして実行します</span>
kubectl run nginx --image<span style=color:#666>=</span>nginx -n 
mynamespace                                         <span style=color:#080;font-style:italic># 特定の名前空間でnginx Podを実行します</span>
kubectl run nginx --image<span style=color:#666>=</span>nginx                     <span style=color:#080;font-style:italic># nginx Podを実行し、マニフェストファイルをpod.yamlという名前で書き込みます</span>
--dry-run<span style=color:#666>=</span>client -o yaml &gt; pod.yaml
kubectl attach my-pod -i                            <span style=color:#080;font-style:italic># 実行中のコンテナに接続します</span>
kubectl port-forward my-pod 5000:6000               <span style=color:#080;font-style:italic># ローカルマシンのポート5000を、my-podのポート6000に転送します</span>
kubectl <span style=color:#a2f>exec</span> my-pod -- ls /                         <span style=color:#080;font-style:italic># 既存のPodでコマンドを実行(単一コンテナの場合)</span>
kubectl <span style=color:#a2f>exec</span> my-pod -c my-container -- ls /         <span style=color:#080;font-style:italic># 既存のPodでコマンドを実行(複数コンテナがある場合)</span>
kubectl top pod POD_NAME --containers               <span style=color:#080;font-style:italic># 特定のPodとそのコンテナのメトリクスを表示します</span>
</code></pre></div><h2 id=ノードおよびクラスターとの対話処理>ノードおよびクラスターとの対話処理</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl cordon my-node                                                <span style=color:#080;font-style:italic># my-nodeをスケーリングされないように設定します</span>
kubectl drain my-node                                                 <span style=color:#080;font-style:italic># メンテナンスの準備としてmy-nodeで動作中のPodを空にします</span>
kubectl uncordon my-node                                              <span style=color:#080;font-style:italic># my-nodeをスケーリングされるように設定します</span>
kubectl top node my-node                                              <span style=color:#080;font-style:italic># 特定のノードのメトリクスを表示します</span>
kubectl cluster-info                                                  <span style=color:#080;font-style:italic># Kubernetesクラスターのマスターとサービスのアドレスを表示します</span>
kubectl cluster-info dump                                             <span style=color:#080;font-style:italic># 現在のクラスター状態を標準出力にダンプします</span>
kubectl cluster-info dump --output-directory<span style=color:#666>=</span>/path/to/cluster-state   <span style=color:#080;font-style:italic># 現在のクラスター状態を/path/to/cluster-stateにダンプします</span>

<span style=color:#080;font-style:italic># special-userキーとNoScheduleエフェクトを持つTaintがすでに存在する場合、その値は指定されたとおりに置き換えられます</span>
kubectl taint nodes foo <span style=color:#b8860b>dedicated</span><span style=color:#666>=</span>special-user:NoSchedule
</code></pre></div><h3 id=リソースタイプ>リソースタイプ</h3>
<p>サポートされているすべてのリソースタイプを、それらが<a href=/ja/docs/concepts/overview/kubernetes-api/#api-groups>API group</a>か<a href=/ja/docs/concepts/overview/working-with-objects/namespaces>Namespaced</a>、<a href=/ja/docs/concepts/overview/working-with-objects/kubernetes-objects>Kind</a>に関わらずその短縮名をリストします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl api-resources
</code></pre></div><p>APIリソースを探索するためのその他の操作:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>      <span style=color:#080;font-style:italic># 名前空間付きのすべてのリソースを表示します</span>
kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>     <span style=color:#080;font-style:italic># 名前空間のないすべてのリソースを表示します</span>
kubectl api-resources -o name                <span style=color:#080;font-style:italic># すべてのリソースを単純な出力(リソース名のみ)で表示します</span>
kubectl api-resources -o wide                <span style=color:#080;font-style:italic># すべてのリソースを拡張された形(別名 &#34;wide&#34;)で表示します</span>
kubectl api-resources --verbs<span style=color:#666>=</span>list,get       <span style=color:#080;font-style:italic># &#34;list&#34;および&#34;get&#34;操作をサポートするすべてのリソースを表示します</span>
kubectl api-resources --api-group<span style=color:#666>=</span>extensions <span style=color:#080;font-style:italic># &#34;extensions&#34; APIグループのすべてのリソースを表示します</span>
</code></pre></div><h3 id=出力のフォーマット>出力のフォーマット</h3>
<p>特定の形式で端末ウィンドウに詳細を出力するには、サポートされている<code>kubectl</code>コマンドに<code>-o</code>(または<code>--output</code>)フラグを追加します。</p>
<table>
<thead>
<tr>
<th>出力フォーマット</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o=custom-columns=&lt;spec></code></td>
<td>コンマ区切りされたカスタムカラムのリストを指定してテーブルを表示します</td>
</tr>
<tr>
<td><code>-o=custom-columns-file=&lt;filename></code></td>
<td><code>&lt;filename></code>ファイル内のカスタムカラムテンプレートを使用してテーブルを表示します</td>
</tr>
<tr>
<td><code>-o=json</code></td>
<td>JSON形式のAPIオブジェクトを出力します</td>
</tr>
<tr>
<td><code>-o=jsonpath=&lt;template></code></td>
<td><a href=/docs/reference/kubectl/jsonpath>jsonpath</a>式で定義されたフィールドを出力します</td>
</tr>
<tr>
<td><code>-o=jsonpath-file=&lt;filename></code></td>
<td><code>&lt;filename></code>ファイル内の<a href=/docs/reference/kubectl/jsonpath>jsonpath</a>式で定義されたフィールドを出力します</td>
</tr>
<tr>
<td><code>-o=name</code></td>
<td>リソース名のみを出力し、それ以外は何も出力しません。</td>
</tr>
<tr>
<td><code>-o=wide</code></td>
<td>追加の情報を含むプレーンテキスト形式で出力します。Podの場合、Node名が含まれます。</td>
</tr>
<tr>
<td><code>-o=yaml</code></td>
<td>YAML形式のAPIオブジェクトを出力します</td>
</tr>
</tbody>
</table>
<p><code>-o=custom-columns</code>を使用したサンプル:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># クラスター内で実行中のすべてのイメージ名を表示する</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[*].image&#39;</span>

<span style=color:#080;font-style:italic># &#34;k8s.gcr.io/coredns:1.6.2&#34;を除いたすべてのイメージ名を表示する</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[?(@.image!=&#34;k8s.gcr.io/coredns:1.6.2&#34;)].image&#39;</span>

<span style=color:#080;font-style:italic># 名前に関係なくmetadata以下のすべてのフィールドを表示する</span>
kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:metadata.*&#39;</span>
</code></pre></div><p>kubectlに関するより多くのサンプルは<a href=/ja/docs/reference/kubectl/overview/#custom-columns>カスタムカラムのリファレンス</a>を参照してください。</p>
<h3 id=kubectlのログレベルとデバッグ>Kubectlのログレベルとデバッグ</h3>
<p>kubectlのログレベルは、レベルを表す整数が後に続く<code>-v</code>または<code>--v</code>フラグで制御されます。一般的なKubernetesのログ記録規則と関連するログレベルについて、<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>こちら</a>で説明します。</p>
<table>
<thead>
<tr>
<th>ログレベル</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--v=0</code></td>
<td>これは、クラスターオペレーターにログレベルが0であることを"常に"見えるようにするために役立ちます</td>
</tr>
<tr>
<td><code>--v=1</code></td>
<td>ログレベルが必要ない場合に、妥当なデフォルトのログレベルです</td>
</tr>
<tr>
<td><code>--v=2</code></td>
<td>サービスに関する重要な定常状態情報と、システムの重要な変更に関連する可能性がある重要なログメッセージを表示します。 これは、ほとんどのシステムで推奨されるデフォルトのログレベルです。</td>
</tr>
<tr>
<td><code>--v=3</code></td>
<td>変更に関するより詳細なログレベルを表示します</td>
</tr>
<tr>
<td><code>--v=4</code></td>
<td>デバックにむいたログレベルで表示します</td>
</tr>
<tr>
<td><code>--v=6</code></td>
<td>要求されたリソースを表示します</td>
</tr>
<tr>
<td><code>--v=7</code></td>
<td>HTTPリクエストのヘッダを表示します</td>
</tr>
<tr>
<td><code>--v=8</code></td>
<td>HTTPリクエストのコンテンツを表示します</td>
</tr>
<tr>
<td><code>--v=9</code></td>
<td>HTTPリクエストのコンテンツをtruncationなしで表示します</td>
</tr>
</tbody>
</table>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>
<p>kubectlについてより深く学びたい方は<a href=/ja/docs/reference/kubectl/overview/>kubectl概要</a>や<a href=/docs/reference/kubectl/jsonpath>JsonPath</a>をご覧ください。</p>
</li>
<li>
<p>オプションについては<a href=/docs/reference/kubectl/kubectl/>kubectl</a> optionsをご覧ください。</p>
</li>
<li>
<p>また<a href=/docs/reference/kubectl/conventions/>kubectlの利用パターン</a>では再利用可能なスクリプトでkubectlを利用する方法を学べます。</p>
</li>
<li>
<p>コミュニティ版<a href=https://github.com/dennyzhang/cheatsheet-kubernetes-A4>kubectlチートシート</a>もご覧ください。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-54e562dd1441d0195970a6526b0055cc>5 - コマンドラインツールのリファレンス</h1>
</div>
<div class=td-content>
<h1 id=pg-ca5d01a42c486d535539d3038aa67eb9>5.1 - フィーチャーゲート</h1>
<p>このページでは管理者がそれぞれのKubernetesコンポーネントで指定できるさまざまなフィーチャーゲートの概要について説明しています。</p>
<p>各機能におけるステージの説明については、<a href=#feature-stages>機能のステージ</a>を参照してください。</p>
<h2 id=概要>概要</h2>
<p>フィーチャーゲートはアルファ機能または実験的機能を記述するkey=valueのペアのセットです。管理者は各コンポーネントで<code>--feature-gates</code>コマンドラインフラグを使用することで機能をオンまたはオフにできます。</p>
<p>各コンポーネントはそれぞれのコンポーネント固有のフィーチャーゲートの設定をサポートします。すべてのコンポーネントのフィーチャーゲートの全リストを表示するには<code>-h</code>フラグを使用します。kubeletなどのコンポーネントにフィーチャーゲートを設定するには以下のようにリストの機能ペアを<code>--feature-gates</code>フラグを使用して割り当てます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>--feature-gates<span style=color:#666>=</span><span style=color:#b44>&#34;...,DynamicKubeletConfig=true&#34;</span>
</code></pre></div><p>次の表は各Kubernetesコンポーネントに設定できるフィーチャーゲートの概要です。</p>
<ul>
<li>「導入開始バージョン」列は機能が導入されたとき、またはリリース段階が変更されたときのKubernetesリリースバージョンとなります。</li>
<li>「最終利用可能バージョン」列は空ではない場合はフィーチャーゲートを使用できる最後のKubernetesリリースバージョンとなります。</li>
<li>アルファまたはベータ状態の機能は<a href=#feature-gates-for-alpha-or-beta-features>AlphaまたはBetaのフィーチャーゲート</a>に載っています。</li>
<li>安定している機能は、<a href=#feature-gates-for-graduated-or-deprecated-features>graduatedまたはdeprecatedのフィーチャーゲート</a>に載っています。</li>
<li>graduatedまたはdeprecatedのフィーチャーゲートには、非推奨および廃止された機能もリストされています。</li>
</ul>
<h3 id=feature-gates-for-alpha-or-beta-features>AlphaまたはBetaのフィーチャーゲート</h3>
<table><caption style=display:none>AlphaまたはBetaのフィーチャーゲート</caption>
<thead>
<tr>
<th>機能名</th>
<th>デフォルト値</th>
<th>ステージ</th>
<th>導入開始バージョン</th>
<th>最終利用可能バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AnyVolumeDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>APIListChunking</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>APIListChunking</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.9</td>
<td></td>
</tr>
<tr>
<td><code>APIPriorityAndFairness</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>APIResponseCompression</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td></td>
</tr>
<tr>
<td><code>AppArmor</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.4</td>
<td></td>
</tr>
<tr>
<td><code>BalanceAttachedNodeVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>BoundServiceAccountTokenVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td></td>
</tr>
<tr>
<td><code>CPUManager</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CPUManager</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>CRIContainerLogRotation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>CRIContainerLogRotation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>CSIInlineVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CSIInlineVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIMigration</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSIMigration</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAWS</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAWS</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAWSComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAzureDisk</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAzureDiskComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAzureFile</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationAzureFileComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationGCE</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSIMigrationGCE</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationGCEComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationOpenStack</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>CSIMigrationOpenStackComplete</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>ConfigurableFSGroupPolicy</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>CustomCPUCFSQuotaPeriod</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>CustomResourceDefaulting</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceDefaulting</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>DevicePlugins</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>DevicePlugins</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>DryRun</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.12</td>
</tr>
<tr>
<td><code>DryRun</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td></td>
</tr>
<tr>
<td><code>DynamicAuditing</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td></td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.4</td>
<td>1.10</td>
</tr>
<tr>
<td><code>DynamicKubeletConfig</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>EndpointSlice</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>EndpointSliceProxying</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>EphemeralContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>ExpandCSIVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ExpandCSIVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>ExpandInUsePersistentVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.14</td>
</tr>
<tr>
<td><code>ExpandInUsePersistentVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>ExpandPersistentVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.10</td>
</tr>
<tr>
<td><code>ExpandPersistentVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>ExperimentalHostUserNamespaceDefaulting</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.5</td>
<td></td>
</tr>
<tr>
<td><code>EvenPodsSpread</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>EvenPodsSpread</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>HPAScaleToZero</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>HugePageStorageMediumSize</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>HyperVContainer</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>ImmutableEphemeralVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>KubeletPodResources</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.14</td>
</tr>
<tr>
<td><code>KubeletPodResources</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>LegacyNodeRoleBehavior</code></td>
<td><code>true</code></td>
<td>Alpha</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.9</td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td></td>
</tr>
<tr>
<td><code>LocalStorageCapacityIsolationFSQuotaMonitoring</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>MountContainers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td></td>
</tr>
<tr>
<td><code>NodeDisruptionExclusion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>NonPreemptingPriority</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>PodDisruptionBudget</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.3</td>
<td>1.4</td>
</tr>
<tr>
<td><code>PodDisruptionBudget</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.5</td>
<td></td>
</tr>
<tr>
<td><code>PodOverhead</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>ProcMountType</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>QOSReserved</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>RemainingItemCount</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>ResourceLimitsPriorityFunction</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td></td>
</tr>
<tr>
<td><code>RotateKubeletClientCertificate</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.8</td>
<td></td>
</tr>
<tr>
<td><code>RotateKubeletServerCertificate</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.11</td>
</tr>
<tr>
<td><code>RotateKubeletServerCertificate</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>RunAsGroup</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>RuntimeClass</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>RuntimeClass</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>SCTPSupport</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>ServerSideApply</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ServerSideApply</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>ServiceAccountIssuerDiscovery</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>ServiceAppProtocol</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>ServiceNodeExclusion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td></td>
</tr>
<tr>
<td><code>ServiceTopology</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>StartupProbe</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>StartupProbe</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>StorageVersionHash</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>StorageVersionHash</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.5</td>
<td>1.5</td>
</tr>
<tr>
<td><code>StreamingProxyRedirects</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.6</td>
<td></td>
</tr>
<tr>
<td><code>SupportNodePidsLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>SupportNodePidsLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td></td>
</tr>
<tr>
<td><code>SupportPodPidsLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>SupportPodPidsLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>Sysctls</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td></td>
</tr>
<tr>
<td><code>TokenRequest</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TokenRequest</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>TokenRequestProjection</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TokenRequestProjection</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td></td>
</tr>
<tr>
<td><code>TTLAfterFinished</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.20</td>
</tr>
<tr>
<td><code>TTLAfterFinished</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.21</td>
<td></td>
</tr>
<tr>
<td><code>TopologyManager</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>TopologyManager</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>ValidateProxyRedirects</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>ValidateProxyRedirects</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>VolumeSnapshotDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>VolumeSnapshotDataSource</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td></td>
</tr>
<tr>
<td><code>WinDSR</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
<tr>
<td><code>WinOverlay</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id=feature-gates-for-graduated-or-deprecated-features>GraduatedまたはDeprecatedのフィーチャーゲート</h3>
<table><caption style=display:none>GraduatedまたはDeprecatedのフィーチャーゲート</caption>
<thead>
<tr>
<th>機能名</th>
<th>デフォルト値</th>
<th>ステージ</th>
<th>導入開始バージョン</th>
<th>最終利用可能バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Accelerators</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.10</td>
</tr>
<tr>
<td><code>Accelerators</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.7</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.8</td>
<td>1.11</td>
</tr>
<tr>
<td><code>AdvancedAuditing</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>AffinityInAnnotations</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.7</td>
</tr>
<tr>
<td><code>AffinityInAnnotations</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.8</td>
<td>-</td>
</tr>
<tr>
<td><code>AllowExtTrafficLocalEndpoints</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.4</td>
<td>1.6</td>
</tr>
<tr>
<td><code>AllowExtTrafficLocalEndpoints</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.7</td>
<td>-</td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.12</td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td>1.17</td>
</tr>
<tr>
<td><code>BlockVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.17</td>
</tr>
<tr>
<td><code>CSIBlockVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.17</td>
</tr>
<tr>
<td><code>CSIDriverRegistry</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td></td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>CSINodeInfo</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td></td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>AttachVolumeLimit</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>CSIPersistentVolume</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>CustomPodDNS</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourcePublishOpenAPI</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceSubresources</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.9</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceValidation</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.13</td>
<td>1.14</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>CustomResourceWebhookConversion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicProvisioningScheduling</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>DynamicProvisioningScheduling</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>DynamicVolumeProvisioning</code></td>
<td><code>true</code></td>
<td>Alpha</td>
<td>1.3</td>
<td>1.7</td>
</tr>
<tr>
<td><code>DynamicVolumeProvisioning</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.8</td>
<td>-</td>
</tr>
<tr>
<td><code>EnableAggregatedDiscoveryTimeout</code></td>
<td><code>true</code></td>
<td>Deprecated</td>
<td>1.16</td>
<td>-</td>
</tr>
<tr>
<td><code>EnableEquivalenceClassCache</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.14</td>
</tr>
<tr>
<td><code>EnableEquivalenceClassCache</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.15</td>
<td>-</td>
</tr>
<tr>
<td><code>ExperimentalCriticalPodAnnotation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.5</td>
<td>1.12</td>
</tr>
<tr>
<td><code>ExperimentalCriticalPodAnnotation</code></td>
<td><code>false</code></td>
<td>Deprecated</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>GCERegionalPersistentDisk</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>GCERegionalPersistentDisk</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>HugePages</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>Initializers</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.13</td>
</tr>
<tr>
<td><code>Initializers</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>KubeletConfigFile</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>KubeletConfigFile</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.10</td>
<td>-</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.12</td>
</tr>
<tr>
<td><code>KubeletPluginsWatcher</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.9</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>MountPropagation</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.12</td>
<td>-</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.14</td>
<td>1.16</td>
</tr>
<tr>
<td><code>NodeLease</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.7</td>
<td>1.9</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PersistentLocalVolumes</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.10</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.11</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PodPriority</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.13</td>
</tr>
<tr>
<td><code>PodReadinessGates</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.14</td>
<td>-</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.10</td>
<td>1.11</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>PodShareProcessNamespace</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>PVCProtection</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>PVCProtection</code></td>
<td>-</td>
<td>Deprecated</td>
<td>1.10</td>
<td>-</td>
</tr>
<tr>
<td><code>RequestManagement</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ResourceQuotaScopeSelectors</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.11</td>
<td>1.11</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ScheduleDaemonSetPods</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>ServiceLoadBalancerFinalizer</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>StorageObjectInUseProtection</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>StorageObjectInUseProtection</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.8</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>false</code></td>
<td>Beta</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.10</td>
</tr>
<tr>
<td><code>SupportIPVSProxyMode</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.11</td>
<td>-</td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.6</td>
<td>1.12</td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.13</td>
<td>1.17</td>
</tr>
<tr>
<td><code>TaintBasedEvictions</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.8</td>
<td>1.11</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.12</td>
<td>1.16</td>
</tr>
<tr>
<td><code>TaintNodesByCondition</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>VolumePVCDataSource</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.9</td>
<td>1.9</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.10</td>
<td>1.12</td>
</tr>
<tr>
<td><code>VolumeScheduling</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeSubpath</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.13</td>
<td>-</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.14</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.15</td>
<td>1.16</td>
</tr>
<tr>
<td><code>VolumeSubpathEnvExpansion</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.15</td>
<td>1.15</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>WatchBookmark</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.17</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.14</td>
<td>1.15</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.16</td>
<td>1.17</td>
</tr>
<tr>
<td><code>WindowsGMSA</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>false</code></td>
<td>Alpha</td>
<td>1.16</td>
<td>1.16</td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>true</code></td>
<td>Beta</td>
<td>1.17</td>
<td>1.17</td>
</tr>
<tr>
<td><code>WindowsRunAsUserName</code></td>
<td><code>true</code></td>
<td>GA</td>
<td>1.18</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id=機能を使用する>機能を使用する</h2>
<h3 id=feature-stages>機能のステージ</h3>
<p>機能には<em>Alpha</em> 、<em>Beta</em> 、<em>GA</em> の段階があります。<em>Alpha</em> 機能とは：</p>
<ul>
<li>デフォルトでは無効になっています。</li>
<li>バグがあるかもしれません。機能を有効にするとバグが発生する可能性があります。</li>
<li>機能のサポートは予告無しにいつでも削除される場合があります。</li>
<li>APIは今後のソフトウェアリリースで予告なく互換性の無い変更が行われる場合があります。</li>
<li>バグが発生するリスクが高く長期的なサポートはないため、短期間のテストクラスターでのみ使用することをお勧めします。</li>
</ul>
<p><em>Beta</em> 機能とは：</p>
<ul>
<li>デフォルトで有効になっています。</li>
<li>この機能は十分にテストされていて、有効にすることは安全と考えられます。</li>
<li>詳細は変更される可能性がありますが、機能全体のサポートは削除されません。</li>
<li>オブジェクトのスキーマやセマンティックは、その後のベータ版または安定版リリースで互換性の無い変更が行われる場合があります。互換性の無い変更が行われた場合には次のバージョンへの移行手順を提供します。これにはAPIオブジェクトの削除、編集、および再作成が必要になる場合があります。バージョンアップにはいくつかの対応が必要な場合があります。これには機能に依存するアプリケーションのダウンタイムが発生する場合があります。</li>
<li>今後のリリースで互換性の無い変更が行われる可能性があるため、ビジネスクリティカルでない使用のみが推奨されます。個別にアップグレードできる複数のクラスターがある場合はこの制限を緩和できる場合があります。</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <em>ベータ版</em> の機能を試してフィードバックをお寄せください！
GAになってからさらなる変更を加えることは現実的ではない場合があります。
</div>
<p><em>GA</em> 機能とは(<em>GA</em> 機能は<em>安定版</em> 機能とも呼ばれます):</p>
<ul>
<li>機能は常に有効となり、無効にすることはできません。</li>
<li>フィーチャーゲートの設定は不要になります。</li>
<li>機能の安定版は後続バージョンでリリースされたソフトウェアで使用されます。</li>
</ul>
<h3 id=フィーチャーゲート>フィーチャーゲート</h3>
<p>各フィーチャーゲートは特定の機能を有効/無効にするように設計されています。</p>
<ul>
<li><code>Accelerators</code>: DockerでのNvidia GPUのサポートを有効にします。</li>
<li><code>AdvancedAuditing</code>: <a href=/docs/tasks/debug-application-cluster/audit/#advanced-audit>高度な監査機能</a>を有効にします。</li>
<li><code>AffinityInAnnotations</code>(<em>非推奨</em>): <a href=/ja/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity>Podのアフィニティまたはアンチアフィニティ</a>を有効にします。</li>
<li><code>AnyVolumeDataSource</code>: <a class=glossary-tooltip title=コンテナ内でボリュームとしてマウントするためにPersistentVolume内で定義されたストレージリソースを要求します。 data-toggle=tooltip data-placement=top href=/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PVC>PVC</a>の<code>DataSource</code>としてカスタムリソースの使用を有効にします。</li>
<li><code>AllowExtTrafficLocalEndpoints</code>: サービスが外部へのリクエストをノードのローカルエンドポイントにルーティングできるようにします。</li>
<li><code>APIListChunking</code>: APIクライアントがAPIサーバーからチャンク単位で（<code>LIST</code>や<code>GET</code>の）リソースを取得できるようにします。
<code>APIPriorityAndFairness</code>: 各サーバーで優先順位付けと公平性を備えた要求の並行性を管理できるようにします(<code>RequestManagement</code>から名前が変更されました)。</li>
<li><code>APIResponseCompression</code>:<code>LIST</code>や<code>GET</code>リクエストのAPIレスポンスを圧縮します。</li>
<li><code>AppArmor</code>: Dockerを使用する場合にLinuxノードでAppArmorによる強制アクセスコントロールを有効にします。詳細は<a href=/docs/tutorials/clusters/apparmor/>AppArmorチュートリアル</a>で確認できます。</li>
<li><code>AttachVolumeLimit</code>: ボリュームプラグインを有効にすることでノードにアタッチできるボリューム数の制限を設定できます。</li>
<li><code>BalanceAttachedNodeVolumes</code>: スケジューリング中にバランスのとれたリソース割り当てを考慮するノードのボリュームカウントを含めます。判断を行う際に、CPU、メモリー使用率、およびボリュームカウントが近いノードがスケジューラーによって優先されます。</li>
<li><code>BlockVolume</code>: PodでRawブロックデバイスの定義と使用を有効にします。詳細は<a href=/docs/concepts/storage/persistent-volumes/#raw-block-volume-support>Rawブロックボリュームのサポート</a>で確認できます。</li>
<li><code>BoundServiceAccountTokenVolume</code>: ServiceAccountTokenVolumeProjectionによって構成される計画ボリュームを使用するにはServiceAccountボリュームを移行します。詳細は<a href=https://git.k8s.io/community/contributors/design-proposals/storage/svcacct-token-volume-source.md>Service Account Token Volumes</a>で確認できます。</li>
<li><code>ConfigurableFSGroupPolicy</code>: Podにボリュームをマウントするときに、ユーザーがfsGroupsのボリューム権限変更ポリシーを設定できるようにします。詳細については、<a href=/docs/tasks/configure-pod-container/security-context/#configure-volume-permission-and-ownership-change-policy-for-pods>Podのボリューム権限と所有権変更ポリシーの設定</a>をご覧ください。</li>
<li><code>CPUManager</code>: コンテナレベルのCPUアフィニティサポートを有効します。<a href=/docs/tasks/administer-cluster/cpu-management-policies/>CPUマネジメントポリシー</a>を見てください。</li>
<li><code>CRIContainerLogRotation</code>: criコンテナランタイムのコンテナログローテーションを有効にします。</li>
<li><code>CSIBlockVolume</code>: 外部CSIボリュームドライバーを有効にしてブロックストレージをサポートします。詳細は<a href=/docs/concepts/storage/volumes/#csi-raw-block-volume-support><code>csi</code>Rawブロックボリュームのサポート</a>で確認できます。</li>
<li><code>CSIDriverRegistry</code>: csi.storage.k8s.ioのCSIDriver APIオブジェクトに関連するすべてのロジックを有効にします。</li>
<li><code>CSIInlineVolume</code>: PodのCSIインラインボリュームサポートを有効にします。</li>
<li><code>CSIMigration</code>: シムと変換ロジックを有効にしてボリューム操作をKubernetesリポジトリー内のプラグインから対応した事前インストール済みのCSIプラグインにルーティングします。</li>
<li><code>CSIMigrationAWS</code>: シムと変換ロジックを有効にしてボリューム操作をKubernetesリポジトリー内のAWS-EBSプラグインからEBS CSIプラグインにルーティングします。ノードにEBS CSIプラグインがインストールおよび設定されていない場合、ツリー内のEBSプラグインへのフォールバックをサポートします。CSIMigration機能フラグを有効にする必要があります。</li>
<li><code>CSIMigrationAWSComplete</code>: EBSツリー内プラグインのkubeletおよびボリュームコントローラーへの登録を停止し、シムと変換ロジックを有効にして、AWS-EBSツリー内プラグインからEBS CSIプラグインにボリューム操作をルーティングします。CSIMigrationおよびCSIMigrationAWS機能フラグを有効にし、クラスター内のすべてのノードにEBS CSIプラグインをインストールおよび設定する必要があります。</li>
<li><code>CSIMigrationAzureDisk</code>: シムと変換ロジックを有効にしてボリューム操作をKubernetesリポジトリー内のAzure-DiskプラグインからAzure Disk CSIプラグインにルーティングします。ノードにAzureDisk CSIプラグインがインストールおよび設定されていない場合、ツリー内のAzureDiskプラグインへのフォールバックをサポートします。CSIMigration機能フラグを有効にする必要があります。</li>
<li><code>CSIMigrationAzureDiskComplete</code>: Azure-Diskツリー内プラグインのkubeletおよびボリュームコントローラーへの登録を停止し、シムと変換ロジックを有効にして、Azure-Diskツリー内プラグインからAzureDisk CSIプラグインにボリューム操作をルーティングします。CSIMigrationおよびCSIMigrationAzureDisk機能フラグを有効にし、クラスター内のすべてのノードにAzureDisk CSIプラグインをインストールおよび設定する必要があります。</li>
<li><code>CSIMigrationAzureFile</code>: シムと変換ロジックを有効にしてボリューム操作をKubernetesリポジトリー内のAzure-FileプラグインからAzure File CSIプラグインにルーティングします。ノードにAzureFile CSIプラグインがインストールおよび設定されていない場合、ツリー内のAzureFileプラグインへのフォールバックをサポートします。CSIMigration機能フラグを有効にする必要があります。</li>
<li><code>CSIMigrationAzureFileComplete</code>: Azure-Fileツリー内プラグインのkubeletおよびボリュームコントローラーへの登録を停止し、シムと変換ロジックを有効にして、Azure-Fileツリー内プラグインからAzureFile CSIプラグインにボリューム操作をルーティングします。CSIMigrationおよびCSIMigrationAzureFile機能フラグを有効にし、クラスター内のすべてのノードにAzureFile CSIプラグインをインストールおよび設定する必要があります。</li>
<li><code>CSIMigrationGCE</code>: シムと変換ロジックを有効にしてボリューム操作をKubernetesリポジトリー内のGCE-PDプラグインからPD CSIプラグインにルーティングします。ノードにPD CSIプラグインがインストールおよび設定されていない場合、ツリー内のGCEプラグインへのフォールバックをサポートします。CSIMigration機能フラグを有効にする必要があります。</li>
<li><code>CSIMigrationGCEComplete</code>: GCE-PDのツリー内プラグインのkubeletおよびボリュームコントローラーへの登録を停止し、シムと変換ロジックがGCE-PDのツリー内プラグインからPD CSIプラグインにボリューム操作をルーティングできるようにします。CSIMigrationおよびCSIMigrationGCE機能フラグを有効にし、クラスター内のすべてのノードにPD CSIプラグインをインストールおよび設定する必要があります。</li>
<li><code>CSIMigrationOpenStack</code>: シムと変換ロジックを有効にしてボリューム操作をKubernetesリポジトリー内のCinderプラグインからCinder CSIプラグインにルーティングします。ノードにCinder CSIプラグインがインストールおよび設定されていない場合、ツリー内のCinderプラグインへのフォールバックをサポートします。CSIMigration機能フラグを有効にする必要があります。</li>
<li><code>CSIMigrationOpenStackComplete</code>: Cinderのツリー内プラグインのkubeletおよびボリュームコントローラーへの登録を停止し、シムと変換ロジックがCinderのツリー内プラグインからCinder CSIプラグインにボリューム操作をルーティングできるようにします。CSIMigrationおよびCSIMigrationOpenStack機能フラグを有効にし、クラスター内のすべてのノードにCinder CSIプラグインをインストールおよび設定する必要があります。</li>
<li><code>CSINodeInfo</code>: csi.storage.k8s.ioのCSINodeInfo APIオブジェクトに関連するすべてのロジックを有効にします。</li>
<li><code>CSIPersistentVolume</code>: <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md>CSI(Container Storage Interface)</a>互換のボリュームプラグインを通してプロビジョニングされたボリュームの検出とマウントを有効にします。
詳細については<a href=/docs/concepts/storage/volumes/#csi><code>csi</code>ボリュームタイプ</a>ドキュメントを確認してください。</li>
<li><code>CustomCPUCFSQuotaPeriod</code>: ノードがCPUCFSQuotaPeriodを変更できるようにします。</li>
<li><code>CustomPodDNS</code>: <code>dnsConfig</code>プロパティを使用したPodのDNS設定のカスタマイズを有効にします。詳細は<a href=/ja/docs/concepts/services-networking/dns-pod-service/#pods-dns-config>PodのDNS構成</a>で確認できます。</li>
<li><code>CustomResourceDefaulting</code>: OpenAPI v3バリデーションスキーマにおいて、デフォルト値のCRDサポートを有効にします。</li>
<li><code>CustomResourcePublishOpenAPI</code>: CRDのOpenAPI仕様での公開を有効にします。</li>
<li><code>CustomResourceSubresources</code>: <a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>CustomResourceDefinition</a>から作成されたリソースの<code>/status</code>および<code>/scale</code>サブリソースを有効にします。</li>
<li><code>CustomResourceValidation</code>: <a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>CustomResourceDefinition</a>から作成されたリソースのスキーマによる検証を有効にします。</li>
<li><code>CustomResourceWebhookConversion</code>: <a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>CustomResourceDefinition</a>から作成されたリソースのWebhookベースの変換を有効にします。</li>
<li><code>DevicePlugins</code>: <a href=/docs/concepts/cluster-administration/device-plugins/>device-plugins</a>によるノードでのリソースプロビジョニングを有効にします。</li>
<li><code>DryRun</code>: サーバーサイドでの<a href=/docs/reference/using-api/api-concepts/#dry-run>dry run</a>リクエストを有効にします。</li>
<li><code>DynamicAuditing</code>: <a href=/docs/tasks/debug-application-cluster/audit/#dynamic-backend>動的監査</a>を有効にします。</li>
<li><code>DynamicKubeletConfig</code>: kubeletの動的構成を有効にします。<a href=/docs/tasks/administer-cluster/reconfigure-kubelet/>kubeletの再設定</a>を参照してください。</li>
<li><code>DynamicProvisioningScheduling</code>: デフォルトのスケジューラーを拡張してボリュームトポロジーを認識しPVプロビジョニングを処理します。この機能は、v1.12の<code>VolumeScheduling</code>機能に完全に置き換えられました。</li>
<li><code>DynamicVolumeProvisioning</code>(<em>非推奨</em>): Podへの永続ボリュームの<a href=/ja/docs/concepts/storage/dynamic-provisioning/>動的プロビジョニング</a>を有効にします。</li>
<li><code>EnableAggregatedDiscoveryTimeout</code> (<em>非推奨</em>): 集約されたディスカバリーコールで5秒のタイムアウトを有効にします。</li>
<li><code>EnableEquivalenceClassCache</code>: Podをスケジュールするときにスケジューラーがノードの同等をキャッシュできるようにします。</li>
<li><code>EphemeralContainers</code>: 稼働するPodに<a class=glossary-tooltip title="A type of container type that you can temporarily run inside a Pod" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ephemeral-containers/ target=_blank aria-label="ephemeral containers">ephemeral containers</a>を追加する機能を有効にします。</li>
<li><code>EvenPodsSpread</code>: Podをトポロジードメイン全体で均等にスケジュールできるようにします。<a href=/docs/concepts/configuration/even-pods-spread>Even Pods Spread</a>をご覧ください。</li>
<li><code>ExpandInUsePersistentVolumes</code>: 使用中のPVCのボリューム拡張を有効にします。<a href=/docs/concepts/storage/persistent-volumes/#resizing-an-in-use-persistentvolumeclaim>使用中のPersistentVolumeClaimのサイズ変更</a>を参照してください。</li>
<li><code>ExpandPersistentVolumes</code>: 永続ボリュームの拡張を有効にします。<a href=/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims>永続ボリューム要求の拡張</a>を参照してください。</li>
<li><code>ExperimentalCriticalPodAnnotation</code>: <a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/>スケジューリングが保証されるよう</a>に特定のPodへの <em>クリティカル</em> の注釈を加える設定を有効にします。</li>
<li><code>ExperimentalHostUserNamespaceDefaultingGate</code>: ホストするデフォルトのユーザー名前空間を有効にします。これは他のホストの名前空間やホストのマウントを使用しているコンテナ、特権を持つコンテナ、または名前空間のない特定の機能（たとえば<code>MKNODE</code>、<code>SYS_MODULE</code>など）を使用しているコンテナ用です。これはDockerデーモンでユーザー名前空間の再マッピングが有効になっている場合にのみ有効にすべきです。</li>
<li><code>EndpointSlice</code>: よりスケーラブルで拡張可能なネットワークエンドポイントのエンドポイントスライスを有効にします。<a href=/docs/tasks/administer-cluster/enabling-endpointslices/>Enabling Endpoint Slices</a>をご覧ください。</li>
<li><code>EndpointSliceProxying</code>: このフィーチャーゲートを有効にすると、kube-proxyはエンドポイントの代わりにエンドポイントスライスをプライマリデータソースとして使用し、スケーラビリティとパフォーマンスの向上を実現します。<a href=/docs/tasks/administer-cluster/enabling-endpointslices/>Enabling Endpoint Slices</a>.をご覧ください。</li>
<li><code>GCERegionalPersistentDisk</code>: GCEでリージョナルPD機能を有効にします。</li>
<li><code>HugePages</code>: 事前に割り当てられた<a href=/docs/tasks/manage-hugepages/scheduling-hugepages/>huge pages</a>の割り当てと消費を有効にします。</li>
<li><code>HugePageStorageMediumSize</code>: 事前に割り当てられた複数のサイズの<a href=/docs/tasks/manage-hugepages/scheduling-hugepages/>huge pages</a>のサポートを有効にします。</li>
<li><code>HyperVContainer</code>: Windowsコンテナの<a href=https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container>Hyper-Vによる分離</a>を有効にします。</li>
<li><code>HPAScaleToZero</code>: カスタムメトリクスまたは外部メトリクスを使用するときに、<code>HorizontalPodAutoscaler</code>リソースの<code>minReplicas</code>を0に設定できるようにします。</li>
<li><code>ImmutableEphemeralVolumes</code>: 安全性とパフォーマンスを向上させるために、個々のSecretとConfigMapが不変となるように指定できるようにします。</li>
<li><code>KubeletConfigFile</code>: 設定ファイルを使用して指定されたファイルからのkubelet設定の読み込みを有効にします。詳細は<a href=/docs/tasks/administer-cluster/kubelet-config-file/>設定ファイルによるkubeletパラメーターの設定</a>で確認できます。</li>
<li><code>KubeletPluginsWatcher</code>: 調査ベースのプラグイン監視ユーティリティを有効にしてkubeletが<a href=/docs/concepts/storage/volumes/#csi>CSIボリュームドライバー</a>などのプラグインを検出できるようにします。</li>
<li><code>KubeletPodResources</code>: kubeletのPodのリソースgrpcエンドポイントを有効にします。詳細は<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/compute-device-assignment.md>デバイスモニタリングのサポート</a>で確認できます。</li>
<li><code>LegacyNodeRoleBehavior</code>: 無効にすると、サービスロードバランサーの従来の動作とノードの中断により機能固有のラベルが優先され、<code>node-role.kubernetes.io/master</code>ラベルが無視されます。</li>
<li><code>LocalStorageCapacityIsolation</code>: <a href=/docs/concepts/configuration/manage-resources-containers/>ローカルの一時ストレージ</a>の消費を有効にして、<a href=/docs/concepts/storage/volumes/#emptydir>emptyDirボリューム</a>の<code>sizeLimit</code>プロパティも有効にします。</li>
<li><code>LocalStorageCapacityIsolationFSQuotaMonitoring</code>: <code>LocalStorageCapacityIsolation</code>が<a href=/docs/concepts/configuration/manage-resources-containers/>ローカルの一時ストレージ</a>で有効になっていて、<a href=/docs/concepts/storage/volumes/#emptydir>emptyDirボリューム</a>のbacking filesystemがプロジェクトクォータをサポートし有効になっている場合、プロジェクトクォータを使用して、パフォーマンスと精度を向上させるために、ファイルシステムへのアクセスではなく<a href=/docs/concepts/storage/volumes/#emptydir>emptyDirボリューム</a>ストレージ消費を監視します。</li>
<li><code>MountContainers</code>: ホスト上のユーティリティコンテナをボリュームマウンターとして使用できるようにします。</li>
<li><code>MountPropagation</code>: あるコンテナによってマウントされたボリュームを他のコンテナまたはPodに共有できるようにします。詳細は<a href=/docs/concepts/storage/volumes/#mount-propagation>マウントの伝播</a>で確認できます。</li>
<li><code>NodeDisruptionExclusion</code>: ノードラベル<code>node.kubernetes.io/exclude-disruption</code>の使用を有効にします。これにより、ゾーン障害時にノードが退避するのを防ぎます。</li>
<li><code>NodeLease</code>: 新しいLease APIを有効にしてノードヘルスシグナルとして使用できるノードのハートビートをレポートします。</li>
<li><code>NonPreemptingPriority</code>: PriorityClassとPodのNonPreemptingオプションを有効にします。</li>
<li><code>PersistentLocalVolumes</code>: Podで<code>local</code>ボリュームタイプの使用を有効にします。<code>local</code>ボリュームを要求する場合、Podアフィニティを指定する必要があります。</li>
<li><code>PodOverhead</code>: <a href=/docs/concepts/configuration/pod-overhead/>PodOverhead</a>機能を有効にして、Podのオーバーヘッドを考慮するようにします。</li>
<li><code>PodDisruptionBudget</code>: <a href=/docs/tasks/run-application/configure-pdb/>PodDisruptionBudget</a>機能を有効にします。</li>
<li><code>PodPriority</code>: <a href=/docs/concepts/configuration/pod-priority-preemption/>優先度</a>に基づいてPodの再スケジューリングとプリエンプションを有効にします。</li>
<li><code>PodReadinessGates</code>: Podのreadinessの評価を拡張するために<code>PodReadinessGate</code>フィールドの設定を有効にします。詳細は<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate>Pod readiness gate</a>で確認できます。</li>
<li><code>PodShareProcessNamespace</code>: Podで実行されているコンテナ間で単一のプロセス名前空間を共有するには、Podで<code>shareProcessNamespace</code>の設定を有効にします。詳細については、<a href=/docs/tasks/configure-pod-container/share-process-namespace/>Pod内のコンテナ間でプロセス名前空間を共有する</a>をご覧ください。</li>
<li><code>ProcMountType</code>: コンテナのProcMountTypeの制御を有効にします。</li>
<li><code>PVCProtection</code>: 永続ボリューム要求（PVC）がPodでまだ使用されているときに削除されないようにします。詳細は<a href=/docs/tasks/administer-cluster/storage-object-in-use-protection/>ここ</a>で確認できます。</li>
<li><code>QOSReserved</code>: QoSレベルでのリソース予約を許可して、低いQoSレベルのポッドが高いQoSレベルで要求されたリソースにバーストするのを防ぎます（現時点ではメモリのみ）。</li>
<li><code>ResourceLimitsPriorityFunction</code>: 入力したPodのCPU制限とメモリ制限の少なくとも1つを満たすノードに対して最低スコアを1に割り当てるスケジューラー優先機能を有効にします。その目的は同じスコアを持つノード間の関係を断つことです。</li>
<li><code>ResourceQuotaScopeSelectors</code>: リソース割当のスコープセレクターを有効にします。</li>
<li><code>RotateKubeletClientCertificate</code>: kubeletでクライアントTLS証明書のローテーションを有効にします。詳細は<a href=/docs/tasks/administer-cluster/storage-object-in-use-protection/>kubeletの設定</a>で確認できます。</li>
<li><code>RotateKubeletServerCertificate</code>: kubeletでサーバーTLS証明書のローテーションを有効にします。詳細は<a href=/docs/tasks/administer-cluster/storage-object-in-use-protection/>kubeletの設定</a>で確認できます。</li>
<li><code>RunAsGroup</code>: コンテナの初期化プロセスで設定されたプライマリグループIDの制御を有効にします。</li>
<li><code>RuntimeClass</code>: コンテナのランタイム構成を選択するには<a href=/docs/concepts/containers/runtime-class/>RuntimeClass</a>機能を有効にします。</li>
<li><code>ScheduleDaemonSetPods</code>: DaemonSetのPodをDaemonSetコントローラーではなく、デフォルトのスケジューラーによってスケジュールされるようにします。</li>
<li><code>SCTPSupport</code>: <code>Service</code>、<code>Endpoints</code>、<code>NetworkPolicy</code>、<code>Pod</code>の定義で<code>protocol</code>の値としてSCTPを使用できるようにします</li>
<li><code>ServerSideApply</code>: APIサーバーで<a href=/docs/reference/using-api/api-concepts/#server-side-apply>サーバーサイドApply(SSA)</a>のパスを有効にします。</li>
<li><code>ServiceAccountIssuerDiscovery</code>: APIサーバーにてサービスアカウント発行者のOIDC検出エンドポイント（発行者とJWKS URL）を有効にします。詳細については、<a href=/docs/tasks/configure-pod-container/configure-service-account/#service-account-issuer-discovery>Podのサービスアカウント設定</a>をご覧ください。</li>
<li><code>ServiceAppProtocol</code>: サービスとエンドポイントで<code>AppProtocol</code>フィールドを有効にします。</li>
<li><code>ServiceLoadBalancerFinalizer</code>: サービスロードバランサーのファイナライザー保護を有効にします。</li>
<li><code>ServiceNodeExclusion</code>: クラウドプロバイダーによって作成されたロードバランサーからのノードの除外を有効にします。"<code>alpha.service-controller.kubernetes.io/exclude-balancer</code>"キーまたは<code>node.kubernetes.io/exclude-from-external-load-balancers</code>でラベル付けされている場合ノードは除外の対象となります。</li>
<li><code>ServiceTopology</code>: クラスタのノードトポロジーに基づいてトラフィックをルーティングするサービスを有効にします。詳細については、<a href=/ja/docs/concepts/services-networking/service-topology/>Serviceトポロジー</a>を参照してください。</li>
<li><code>StartupProbe</code>: kubeletで<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#when-should-you-use-a-startup-probe>startup</a>プローブを有効にします。</li>
<li><code>StorageObjectInUseProtection</code>: PersistentVolumeまたはPersistentVolumeClaimオブジェクトがまだ使用されている場合、それらの削除を延期します。</li>
<li><code>StorageVersionHash</code>: apiserversがディスカバリーでストレージのバージョンハッシュを公開できるようにします。</li>
<li><code>StreamingProxyRedirects</code>: ストリーミングリクエストのバックエンド(kubelet)からのリダイレクトをインターセプト（およびフォロー）するようAPIサーバーに指示します。ストリーミングリクエストの例には<code>exec</code>、<code>attach</code>、<code>port-forward</code>リクエストが含まれます。</li>
<li><code>SupportIPVSProxyMode</code>: IPVSを使用したクラスター内サービスの負荷分散の提供を有効にします。詳細は<a href=/ja/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>サービスプロキシー</a>で確認できます。</li>
<li><code>SupportPodPidsLimit</code>: PodのPID制限のサポートを有効にします。</li>
<li><code>Sysctls</code>: 各Podに設定できる名前空間付きのカーネルパラメーター(sysctl)のサポートを有効にします。詳細は<a href=/docs/tasks/administer-cluster/sysctl-cluster/>sysctls</a>で確認できます。</li>
<li><code>TaintBasedEvictions</code>: ノードのTaintとPodのTolerationに基づいてノードからPodを排除できるようにします。。詳細は<a href=/docs/concepts/scheduling-eviction/taint-and-toleration/>TaintとToleration</a>で確認できます。</li>
<li><code>TaintNodesByCondition</code>: <a href=/ja/docs/concepts/architecture/nodes/#condition>ノードの条件</a>に基づいてノードの自動Taintを有効にします。</li>
<li><code>TokenRequest</code>: サービスアカウントリソースで<code>TokenRequest</code>エンドポイントを有効にします。</li>
<li><code>TokenRequestProjection</code>: <a href=/docs/concepts/storage/volumes/#projected>Projectedボリューム</a>を使用したPodへのサービスアカウントのトークンの注入を有効にします。</li>
<li><code>TTLAfterFinished</code>: <a href=/docs/concepts/workloads/controllers/ttlafterfinished/>TTLコントローラー</a>が実行終了後にリソースをクリーンアップできるようにします。</li>
<li><code>VolumePVCDataSource</code>: 既存のPVCをデータソースとして指定するサポートを有効にします。</li>
<li><code>VolumeScheduling</code>: ボリュームトポロジー対応のスケジューリングを有効にし、PersistentVolumeClaim（PVC）バインディングにスケジューリングの決定を認識させます。また<code>PersistentLocalVolumes</code>フィーチャーゲートと一緒に使用すると<a href=/docs/concepts/storage/volumes/#local><code>local</code></a>ボリュームタイプの使用が可能になります。</li>
<li><code>VolumeSnapshotDataSource</code>: ボリュームスナップショットのデータソースサポートを有効にします。</li>
<li><code>VolumeSubpathEnvExpansion</code>: 環境変数を<code>subPath</code>に展開するための<code>subPathExpr</code>フィールドを有効にします。</li>
<li><code>WatchBookmark</code>: ブックマークイベントの監視サポートを有効にします。</li>
<li><code>WindowsGMSA</code>: GMSA資格仕様をPodからコンテナランタイムに渡せるようにします。</li>
<li><code>WindowsRunAsUserName</code>: デフォルト以外のユーザーでWindowsコンテナアプリケーションを実行するためのサポートを有効にします。詳細については、<a href=/docs/tasks/configure-pod-container/configure-runasusername>RunAsUserNameの設定</a>を参照してください。</li>
<li><code>WinDSR</code>: kube-proxyがWindows用のDSRロードバランサーを作成できるようにします。</li>
<li><code>WinOverlay</code>: kube-proxyをWindowsのオーバーレイモードで実行できるようにします。</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>Kubernetesの<a href=/docs/reference/using-api/deprecation-policy/>非推奨ポリシー</a>では、機能とコンポーネントを削除するためのプロジェクトのアプローチを説明しています。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1715b765e2ff39feffd103d59ec0ef07>5.2 - Kubelet 認証/認可</h1>
<h2 id=概要>概要</h2>
<p>kubeletのHTTPSエンドポイントは、さまざまな感度のデータへのアクセスを提供するAPIを公開し、
ノードとコンテナ内のさまざまなレベルの権限でタスクを実行できるようにします。</p>
<p>このドキュメントでは、kubeletのHTTPSエンドポイントへのアクセスを認証および承認する方法について説明します。</p>
<h2 id=kubelet-認証>Kubelet 認証</h2>
<p>デフォルトでは、他の構成済み認証方法によって拒否されないkubeletのHTTPSエンドポイントへのリクエストは
匿名リクエストとして扱われ、ユーザー名は<code>system:anonymous</code>、
グループは<code>system:unauthenticated</code>になります。</p>
<p>匿名アクセスを無効にし、認証されていないリクエストに対して<code>401 Unauthorized</code>応答を送信するには：</p>
<ul>
<li><code>--anonymous-auth=false</code>フラグでkubeletを開始します。</li>
</ul>
<p>kubeletのHTTPSエンドポイントに対するX509クライアント証明書認証を有効にするには：</p>
<ul>
<li><code>--client-ca-file</code>フラグでkubeletを起動し、クライアント証明書を確認するためのCAバンドルを提供します。</li>
<li><code>--kubelet-client-certificate</code>および<code>--kubelet-client-key</code>フラグを使用してapiserverを起動します。</li>
<li>詳細については、<a href=/ja/docs/reference/access-authn-authz/authentication/#x509-client-certs>apiserver認証ドキュメント</a>を参照してください。</li>
</ul>
<p>APIベアラートークン(サービスアカウントトークンを含む)を使用して、kubeletのHTTPSエンドポイントへの認証を行うには：</p>
<ul>
<li>APIサーバーで<code>authentication.k8s.io/v1beta1</code>グループが有効になっていることを確認します。</li>
<li><code>--authentication-token-webhook</code>および<code>--kubeconfig</code>フラグを使用してkubeletを開始します。</li>
<li>kubeletは、構成済みのAPIサーバーで <code>TokenReview</code> APIを呼び出して、ベアラートークンからユーザー情報を判別します。</li>
</ul>
<h2 id=kubelet-承認>Kubelet 承認</h2>
<p>認証に成功した要求(匿名要求を含む)はすべて許可されます。デフォルトの認可モードは、すべての要求を許可する<code>AlwaysAllow</code>です。</p>
<p>kubelet APIへのアクセスを細分化するのは、次のような多くの理由が考えられます:</p>
<ul>
<li>匿名認証は有効になっていますが、匿名ユーザーがkubeletのAPIを呼び出す機能は制限する必要があります。</li>
<li>ベアラートークン認証は有効になっていますが、kubeletのAPIを呼び出す任意のAPIユーザー(サービスアカウントなど)の機能を制限する必要があります。</li>
<li>クライアント証明書の認証は有効になっていますが、構成されたCAによって署名されたクライアント証明書の一部のみがkubeletのAPIの使用を許可されている必要があります。</li>
</ul>
<p>kubeletのAPIへのアクセスを細分化するには、APIサーバーに承認を委任します:</p>
<ul>
<li>APIサーバーで<code>authorization.k8s.io/v1beta1</code> APIグループが有効になっていることを確認します。</li>
<li><code>--authorization-mode=Webhook</code>と<code>--kubeconfig</code>フラグでkubeletを開始します。</li>
<li>kubeletは、構成されたAPIサーバーで<code>SubjectAccessReview</code> APIを呼び出して、各リクエストが承認されているかどうかを判断します。</li>
</ul>
<p>kubeletは、apiserverと同じ<a href=/docs/reference/access-authn-authz/authorization/#review-your-request-attributes>リクエスト属性</a>アプローチを使用してAPIリクエストを承認します。</p>
<p>動詞は、受けとったリクエストのHTTP動詞から決定されます:</p>
<table>
<thead>
<tr>
<th>HTTP動詞</th>
<th>要求 動詞</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>create</td>
</tr>
<tr>
<td>GET, HEAD</td>
<td>get</td>
</tr>
<tr>
<td>PUT</td>
<td>update</td>
</tr>
<tr>
<td>PATCH</td>
<td>patch</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete</td>
</tr>
</tbody>
</table>
<p>リソースとサブリソースは、受けとったリクエストのパスから決定されます:</p>
<table>
<thead>
<tr>
<th>Kubelet API</th>
<th>リソース</th>
<th>サブリソース</th>
</tr>
</thead>
<tbody>
<tr>
<td>/stats/*</td>
<td>nodes</td>
<td>stats</td>
</tr>
<tr>
<td>/metrics/*</td>
<td>nodes</td>
<td>metrics</td>
</tr>
<tr>
<td>/logs/*</td>
<td>nodes</td>
<td>log</td>
</tr>
<tr>
<td>/spec/*</td>
<td>nodes</td>
<td>spec</td>
</tr>
<tr>
<td><em>all others</em></td>
<td>nodes</td>
<td>proxy</td>
</tr>
</tbody>
</table>
<p>名前空間とAPIグループの属性は常に空の文字列であり、
リソース名は常にkubeletの<code>Node</code> APIオブジェクトの名前です。</p>
<p>このモードで実行する場合は、apiserverに渡される<code>--kubelet-client-certificate</code>フラグと<code>--kubelet-client-key</code>
フラグで識別されるユーザーが次の属性に対して許可されていることを確認します:</p>
<ul>
<li>verb=*, resource=nodes, subresource=proxy</li>
<li>verb=*, resource=nodes, subresource=stats</li>
<li>verb=*, resource=nodes, subresource=log</li>
<li>verb=*, resource=nodes, subresource=spec</li>
<li>verb=*, resource=nodes, subresource=metrics</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-954776b47f2d90515f375623a0ce98e1>6 - RBAC認可を使用する</h1>
<p>Role Based Access Control(RBAC)は、組織内の個々のユーザーのRoleをベースに、コンピューターまたはネットワークリソースへのアクセスを制御する方法です。</p>
<p>RBAC認可は<a class=glossary-tooltip title="A set of related paths in the Kubernetes API." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label="API Group">API Group</a> <code>rbac.authorization.k8s.io</code>を使用して認可の決定を行い、Kubernetes APIを介して動的にポリシーを構成できるようにします。</p>
<p>RBACを有効にするには、以下の例のように<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label="API server">API server</a>の<code>--authorization-mode</code> フラグをコンマ区切りの<code>RBAC</code>を含むリストでスタートします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kube-apiserver --authorization-mode<span style=color:#666>=</span>Example,RBAC --other-options --more-options
</code></pre></div><h2 id=api-overview>APIオブジェクト</h2>
<p>RBAC APIは4種類のKubernetesオブジェクト(<em>Role</em>、 <em>ClusterRole</em>、 <em>RoleBinding</em> そして <em>ClusterRoleBinding</em>)を宣言します。他のKubernetesオブジェクトのように<code>kubectl</code>のようなツールを使って、<a href=https://kubernetes.io/ja/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>オブジェクトを記述</a>、または変更できます。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> これらのオブジェクトは設計上、アクセス制限を課します。学んできたように変更を行っている場合、
<a href=#%E7%89%B9%E6%A8%A9%E6%98%87%E6%A0%BC%E3%81%AE%E9%98%B2%E6%AD%A2%E3%81%A8%E3%83%96%E3%83%BC%E3%83%88%E3%82%B9%E3%83%88%E3%83%A9%E3%83%83%E3%83%97>特権エスカレーション防止とブートストラップ</a>
を参照し、これらの制限がどのようにいつかの変更を防止するのかを理解しましょう。
</div>
<h3 id=roleとclusterrole>RoleとClusterRole</h3>
<p>RBACの <em>Role</em> または <em>ClusterRole</em> には、一連の権限を表すルールが含まれて言います。
権限は完全な追加方式です(「deny」のルールはありません)。</p>
<p>Roleは常に特定の<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>で権限を設定します。
つまり、Roleを作成する時は、Roleが属するNamespaceを指定する必要があります。</p>
<p>対照的にClusterRoleは、Namespaceに属さないリソースです。Kubernetesオブジェクトは常にNamespaceに属するか、属さないかのいずれかである必要があり、リソースは異なる名前(RoleとClusterRole)を持っています。つまり、両方であることは不可能です。</p>
<p>ClusterRolesにはいくつかの用途があります。ClusterRoleを利用して、以下のことができます。</p>
<ol>
<li>Namespaceに属するリソースに対する権限を定義し、個々のNamespace内で付与する</li>
<li>Namespaceに属するリソースに対する権限を定義し、すべてのNamespaceにわたって付与する</li>
<li>クラスター単位でスコープされているリソースに対するアクセス許可を定義する</li>
</ol>
<p>NamespaceでRoleを定義する場合は、Roleを使用します。クラスター全体でRoleを定義する場合は、ClusterRoleを使用します</p>
<h4 id=roleの例>Roleの例</h4>
<p>以下はNamespace「default」にあるRoleの例で、
<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>への読み取りアクセス権の付与に使用できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-reader<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#34;&#34; はコアのAPIグループを示します</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><h4 id=clusterroleの例>ClusterRoleの例</h4>
<p>ClusterRoleを使用してRoleと同じ権限を付与できます。
ClusterRolesはクラスター単位でスコープされているため、以下へのアクセスの許可もできます。</p>
<ul>
<li>クラスター単位でスコープされているリソースに(<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=node>node</a>など)</li>
<li>非リソースエンドポイントに(<code>/healthz</code>など)</li>
<li>すべてのNamespaceに渡ってNamespaceに属するリソースに(Podなど)。
例えば、ClusterRoleを使用して特定のユーザーに<code>kubectl get pods --all-namespaces</code>の実行を許可できます。</li>
</ul>
<p>以下は特定のNamespace、またはすべてのNamespace(<a href=#rolebinding%E3%81%A8clusterrolebinding>バインド</a>方法によります)で<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=secrets>secrets</a>への読み取りアクセス権を付与するClusterRoleの例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 「namespace」はClusterRolesがNamespaceに属していないため、省略されています</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、Secretにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;secrets&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;secrets&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>RoleまたはClusterRoleオブジェクトの名前は有効な
<a href=https://kubernetes.io/ja/docs/concepts/overview/working-with-objects/names/>パスセグメント名</a>である必要があります。</p>
<h3 id=rolebindingとclusterrolebinding>RoleBindingとClusterRoleBinding</h3>
<p>RoleBindingはRoleで定義された権限をユーザーまたはユーザのセットに付与します。
RoleBindingは<em>subjects</em> (ユーザー、グループ、サービスアカウント)のリストと、付与されるRoleへの参照を保持します。
RoleBindingは特定のNamespace内の権限を付与しますが、ClusterRoleBindingはクラスター全体にアクセスする権限を付与します。</p>
<p>RoleBindingは、同じNamespace内の任意のRoleを参照できます。
または、RoleBindingはClusterRoleを参照し、そのClusterRoleをRoleBindingのNamespaceにバインドできます。
ClusterRoleをクラスター内のすべてのNamespaceにバインドする場合は、ClusterRoleBindingを使用します。</p>
<p>RoleBindingまたはClusterRoleBindingオブジェクトは有効な
<a href=https://kubernetes.io/ja/docs/concepts/overview/working-with-objects/names/>パスセグメント名</a>である必要があります。</p>
<h4 id=rolebinding-example>RoleBindingの例</h4>
<p>以下はNamespace「default」内でユーザー「jane」に「pod-reader」のRoleを付与するRoleBindingの例です。
これにより、「jane」にNamespace「default」のポッドの読み取り許可されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># このRoleBindingは「jane」にNamespace「default」のポッドの読み取りを許可する</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># そのNamespaceでRole「pod-reader」を既に持っている必要があります。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-pods<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 一つ以上の「subject」を指定する必要があります</span><span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jane<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 「name」は大文字と小文字が区別されます</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 「roleRef」はRole/ClusterRoleへのバインドを指定します</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb> </span><span style=color:#080;font-style:italic>#RoleまたはClusterRoleである必要があります</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-reader<span style=color:#bbb> </span><span style=color:#080;font-style:italic># これはバインドしたいRole名またはClusterRole名とマッチする必要があります</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p>RoleBindingはClusterRoleを参照し、ClusterRoleで定義されている権限をRoleBinding内のNamespaceのリソースに権限付与もできます。この種類の参照を利用すると、クラスター全体で共通のRoleのセットを定義して、それらを複数のNamespace内での再利用できます。</p>
<p>例えば、以下のRoleBindingがClusterRoleを参照している場合でも、
「dave」(大文字と小文字が区別されるsubject)はRoleBindingのNamespace(メタデータ内)が「development」のため、Namespace「development」のSecretsのみの読み取りができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># このRoleBindingは「dave」にNamespace「development」のSecretsの読み取りを許可する</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># ClusterRole「secret-reader」を既に持っている必要があります。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-secrets<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RoleBindingのNamespaceが、どこの権限が付与されるかを決定する。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># これはNamespace「development」内の権限のみ付与する。</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dave<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nameは大文字、小文字を区別する</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><h4 id=clusterrolebindingの例>ClusterRoleBindingの例</h4>
<p>クラスター全体に権限を付与するには、ClusterRoleBindingを使用できます。
以下のClusterRoleBindingはグループ「manager」のすべてのユーザーに
Secretsの読み取りを許可します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># このClusterRoleBindingはグループ「manager」のすべてのユーザーに任意のNamespaceのSecretsの読み取りを許可します。</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-secrets-global<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>manager<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nameは大文字、小文字を区別します</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p>Bindingを作成後は、それが参照するRoleまたはClusterRoleを変更できません。
Bindingの<code>roleRef</code>を変更しようとすると、バリデーションエラーが発生します。Bindingの<code>roleRef</code>を変更する場合は、Bindingのオブジェクトを削除して、代わりのオブジェクトを作成する必要があります。</p>
<p>この制限には２つの理由があります。</p>
<ol>
<li><code>roleRef</code>をイミュータブルにすることで、誰かに既存のオブジェクトに対する<code>update</code>権限を付与します。それにより、subjectsに付与されたRoleの変更ができなくても、subjectsのリストを管理できるようになります。</li>
<li>異なるRoleへのBindingは根本的に異なるBindingです。
<code>roleRef</code>を変更するためにBindingの削除/再作成を要求することによって、(すべての既存のsubjectsを確認せずに、roleRefだけを誤って変更できるようにするのとは対照的に)Binding内のsubjectsのリストのすべてが意図された新しいRoleが付与されることを担保します。</li>
</ol>
<p><code>kubectl auth reconcile</code> コマンドラインユーティリティーはRBACオブジェクトを含んだマニフェストファイルを作成または更新します。また、それらが参照しているRoleへの変更を要求されると、Bindingオブジェクトの削除と再作成を取り扱います。
詳細は<a href=#kubectl-auth-reconcile>command usage and examples</a>を確認してください。</p>
<h3 id=リソースを参照する>リソースを参照する</h3>
<p>KubernetesのAPIでは、ほとんどのリソースはPodであれば<code>pods</code>のように、オブジェクト名の文字列表現を使用して表されます。RBACは、関連するAPIエンドポイントのURLに表示されるものとまったく同じ名前を使用するリソースを参照します。
一部のKubernetes APIには、Podのログなどの
<em>subresource</em>　が含まれます。Podのログのリクエストは次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span>GET /api/v1/namespaces/{namespace}/pods/{name}/log
</span></code></pre></div><p>この場合、<code>pods</code> はPodリソースのNamespaceに属するリソースであり、<code>log</code>は<code>pods</code>のサブリソースです。これをRBACRoleで表すには、スラッシュ(<code>/</code>)を使用してリソースとサブリソースを区切ります。サブジェクトへの<code>pods</code>の読み込みと各Podの<code>log</code>サブリソースへのアクセスを許可するには、次のように記述します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-and-pod-logs-reader<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods/log&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p><code>resourceNames</code>リストを通じて、特定のリクエストのリソースを名前で参照することもできます。
指定すると、リクエストをリソースの個々のインスタンスに制限できます。
以下は対象を<code>get</code>または<code>my-configmap</code>と名付けられた
<a class=glossary-tooltip title=機密性のないデータをキーと値のペアで保存するために使用されるAPIオブジェクトです。環境変数、コマンドライン引数、またはボリューム内の設定ファイルとして使用できます。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>を<code>update</code>のみに制限する例です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-updater<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、ConfigMapにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;configmaps&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;my-configmap&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;get&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>resourceNames</code>で<code>create</code>または<code>deletecollection</code>のリクエストを制限することはできません。この制限は<code>create</code>の場合、認証時にオブジェクト名がわからないためです。
</div>
<h3 id=集約clusterrole>集約ClusterRole</h3>
<p>複数のClusterRoleを一つのClusterRoleに <em>集約</em> できます。
クラスターコントロールプレーンの一部として実行されるコントローラーは、<code>aggregationRule</code>セットを持つClusterRoleオブジェクトを監視します。<code>aggregationRule</code>はコントローラーが、このオブジェクトの<code>rules</code>フィールドに結合する必要のある他のClusterRoleオブジェクトを一致させるために使用するラベル<a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selector>selector</a>を定義します。</p>
<p>以下に、集約されたClusterRoleの例を示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>monitoring<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>aggregationRule</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterRoleSelectors</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>rbac.example.com/aggregate-to-monitoring</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># コントロールプレーンは自動的にルールを入力します</span><span style=color:#bbb>
</span></code></pre></div><p>既存の集約されたClusterRoleのラベルセレクターと一致する新しいClusterRoleを作成すると、その変更をトリガーに、集約されたClusterRoleに新しいルールが追加されます。
<code>rbac.example.com/aggregate-to-monitoring: true</code>ラベルが付けられた別のClusterRoleを作成して、ClusterRole「monitoring」にルールを追加する例を以下に示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>monitoring-endpoints<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.example.com/aggregate-to-monitoring</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># ClusterRole「monitoring-endpoints」を作成すると、</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 以下のルールがClusterRole「monitoring」に追加されます</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;services&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;endpoints&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p><a href=#%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88role%E3%81%A8clusterrolebinding>デフォルトのユーザー向けRole</a>はClusterRoleの集約を使用します。これによりクラスター管理者として、 デフォルトroleを拡張するため、<a class=glossary-tooltip title="Custom code that defines a resource to add to your Kubernetes API server without building a complete custom server." data-toggle=tooltip data-placement=top href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CustomResourceDefinitions>CustomResourceDefinitions</a>または集約されたAPIサーバーなどによって提供されたルールをカスタムリソースに含めることができます。</p>
<p>例えば、次のClusterRoleでは、「admin」と「edit」のデフォルトのRoleでCronTabという名前のカスタムリソースを管理できますが、「view」のRoleではCronTabリソースに対して読み取りアクションのみを実行できます。CronTabオブジェクトは、APIサーバーから見たURLで<code>"crontabs"</code>と名前が付けられていると想定できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>aggregate-cron-tabs-edit<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># デフォルトRoleの「admin」と「edit」にこれらの権限を追加する。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stable.example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;crontabs&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>aggregate-cron-tabs-view<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># デフォルトRoleの「view」にこれらの権限を追加します。</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-view</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stable.example.com&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;crontabs&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><h4 id=roleの例-1>Roleの例</h4>
<p>次の例は、RoleオブジェクトまたはClusterRoleオブジェクトからの抜粋であり、<code>rules</code>セクションのみを示しています。</p>
<p><code>"pods"</code>の読み取りを許可する
<a class=glossary-tooltip title="A set of related paths in the Kubernetes API." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label="API Group">API Group</a>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、Podにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;pods&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>APIグループ<code>" extensions "</code>と <code>" apps "</code> の両方で、Deploymentsへの読み取り/書き込みを許可します。
(HTTPレベルでURLのリソース部分に<code>"deployments"</code>を持つオブジェクトで)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;extensions&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、Deploymentにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;deployments&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>コアAPIグループのPodの読み取り、および<code>"batch"</code>または<code>"extensions"</code>APIグループのJobリソースの読み取りまたは書き込みを許可します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、Podにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;pods&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;batch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;extensions&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、Jobにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;jobs&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;jobs&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>「my-config」という名前のConfigMapの読み取りを許可します(
単一のNamespace内の単一のConfigMapに制限するRoleBinding)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、ConfigMapにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;configmaps&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;my-config&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>コアグループ内のリソース <code>"nodes"</code>の読み取りを許可します(Nodeはクラスタースコープであり、ClusterRoleBindingが効果的であるため、ClusterRoleにバインドされている必要があります)。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># HTTPレベルでの、Nodeにアクセスするリソースの名前</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># オブジェクトは&#34;nodes&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;nodes&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>非リソースエンドポイント <code>/ healthz</code>およびすべてのサブパス(ClusterRoleBindingが効果的であるため、ClusterRoleにバインドされている必要があります)のGETおよびPOSTリクエストを許可します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/healthz&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;/healthz/*&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nonResourceURLの「*」はサフィックスグロブマッチです</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;post&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><h3 id=subjectsを参照する>subjectsを参照する</h3>
<p>RoleBindingまたはClusterRoleBindingは、Roleをsubjectsにバインドします。subjectsはグループ、ユーザー、または<a class=glossary-tooltip title="Provides an identity for processes that run in a Pod." data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=ServiceAccounts>ServiceAccounts</a>にすることができます。</p>
<p>Kubernetesはユーザー名を文字列として表します。
これらは次のようにできます。「alice」などの単純な名前。「bob@example.com」のような電子メール形式の名前。または文字列として表される数値のユーザーID。 認証が必要な形式のユーザー名を生成するように<a href=https://kubernetes.io/ja/docs/reference/access-authn-authz/authentication/>認証モジュール</a>を構成するかどうかは、クラスター管理者が決定します。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> プレフィックス<code>system:</code>はKubernetesシステムで使用するために予約されているため、誤って<code>system:</code>で始まる名前のユーザーまたはグループが存在しないようにする必要があります。
この特別なプレフィックスを除いて、RBAC承認システムでは、ユーザー名の形式は問いません。
</div>
<p>Kubernetesでは、Authenticatorモジュールがグループ情報を提供します。
ユーザーと同様に、グループは文字列として表され、その文字列には、プレフィックス<code>system:</code>が予約されていることを除いて、フォーマット要件はありません。</p>
<p><a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>の名前はプレフィックス<code>system:serviceaccount:</code>が付いており、名前のプレフィックス<code>system:serviceaccounts:</code>が付いているグループに属しています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <ul>
<li><code>system:serviceaccount:</code> (単数)は、サービスアカウントのユーザー名のプレフィックスです。</li>
<li><code>system:serviceaccounts:</code>(複数)は、サービスアカウントグループのプレフィックスです。</li>
</ul>
</div>
<h4 id=role-binding-examples>RoleBindingの例</h4>
<p>次の例は<code>RoleBinding</code>、<code>subjects</code>セクションのみを示す抜粋です。</p>
<p><code>alice@example.com</code>という名前のユーザーの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;alice@example.com&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p><code>frontend-admins</code>という名前のグループの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;frontend-admins&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p>Namespace「kube-system」のデフォルトのサービスアカウントの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></code></pre></div><p>Namespace「qa」の全てのサービスアカウントの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts:qa<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p>任意のNamespaceの全てのサービスアカウントの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p>すべての認証済みユーザーの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p>認証されていないすべてのユーザーの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:unauthenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><p>すべてのユーザーの場合。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:unauthenticated<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></code></pre></div><h2 id=デフォルトroleとclusterrolebinding>デフォルトRoleとClusterRoleBinding</h2>
<p>APIサーバーは、デフォルトのClusterRoleオブジェクトとClusterRoleBindingオブジェクトのセットを作成します。
これらの多くにはプレフィックス<code>system:</code>が付いています。これは、リソースがクラスターコントロールプレーンによって直接管理されることを示しています。
デフォルトのすべてのClusterRoleおよびClusterRoleBindingには、ラベル<code>kubernetes.io/bootstrapping=rbac-defaults</code>が付いています。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> プレフィックスとして<code>system:</code>を含む名前で、ClusterRolesおよびClusterRoleBindingsを変更する場合は注意してください。
これらのリソースを変更すると、クラスターが機能しなくなる可能性があります。
</div>
<h3 id=自動調整>自動調整</h3>
<p>起動するたびに、APIサーバーはデフォルトのClusterRoleを不足している権限で更新し、
デフォルトのClusterRoleBindingを不足しているsubjectsで更新します。
これにより、誤った変更をクラスタが修復できるようになり、新しいKubernetesリリースで権限とsubjectsが変更されても、
RoleとRoleBindingを最新の状態に保つことができます。</p>
<p>この調整を無効化するには<code>rbac.authorization.kubernetes.io/autoupdate</code>をデフォルトのClusterRoleまたはRoleBindingのアノテーションを<code>false</code>に設定します。
デフォルトの権限と subjectsがないと、クラスターが機能しなくなる可能性があることに注意してください。</p>
<p>RBAC authorizerが有効な場合、自動調整はデフォルトで有効になっています。</p>
<h3 id=discovery-roles>APIディスカバリーRole</h3>
<p>デフォルトのRoleBindingでは、認証されていないユーザーと認証されたユーザーが、パブリックアクセスが安全であると見なされるAPI情報(CustomResourceDefinitionを含む)の読み取りを認可しています。匿名の非認証アクセスを無効にするには、APIサーバー構成に<code>--anonymous-auth=false</code> 追加します。</p>
<p><code>kubectl</code>の実行によってこれらのRoleの構成を表示するには。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get clusterroles system:discovery -o yaml
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ClusterRoleを編集すると、変更が<a href=#%E8%87%AA%E5%8B%95%E8%AA%BF%E6%95%B4>自動調整</a>によるAPIサーバーの再起動時に上書きされます。この上書きを回避するにはRoleを手動で編集しないか、自動調整を無効にします。
</div>
<table>
<caption>Kubernetes RBAC APIディスカバリーRole</caption>
<col width=25%><col width=25%><col>
<tr>
<th>デフォルトのClusterRole</th>
<th>デフォルトのClusterRoleBinding</th>
<th>説明</th>
</tr>
<tr>
<td><b>system:basic-user</b></td>
<td><b>system:authenticated</b> group</td>
<td>ユーザーに、自身に関する基本情報への読み取り専用アクセスを許可します。v1.14より前は、このRoleはデフォルトで<tt>system:unauthenticated</tt>にもバインドされていました。</td>
</tr>
<tr>
<td><b>system:discovery</b></td>
<td><b>system:authenticated</b> group</td>
<td>APIレベルのディスカバリーとネゴシエーションに必要なAPIディスカバリーエンドポイントへの読み取り専用アクセスを許可します。v1.14より前は、このRoleはデフォルトで<tt>system:unauthenticated</tt>にもバインドされていました。</td>
</tr>
<tr>
<td><b>system:public-info-viewer</b></td>
<td><b>system:authenticated</b> and <b>system:unauthenticated</b> groups</td>
<td>クラスターに関する機密情報以外への読み取り専用アクセスを許可します。Kubernetes v1.14で導入されました。</td>
</tr>
</table>
<h3 id=ユーザー向けrole>ユーザー向けRole</h3>
<p>一部のデフォルトClusterRolesにはプレフィックス<code>system:</code>が付いていません。これらは、ユーザー向けのroleを想定しています。それらは、スーパーユーザのRole(<code>cluster-admin</code>)、ClusterRoleBindingsを使用してクラスタ全体に付与されることを意図しているRole、そしてRoleBindings(<code>admin</code>, <code>edit</code>, <code>view</code>)を使用して、特定のNamespace内に付与されることを意図しているRoleを含んでいます。</p>
<p>ユーザー向けのClusterRolesは<a href=#%E9%9B%86%E7%B4%84clusterrole>ClusterRoleの集約</a>を使用して、管理者がこれらのClusterRolesにカスタムリソースのルールを含めることができるようにします。ルールを<code>admin</code>、<code>edit</code>、または<code>view</code> Roleに追加するには、次のラベルの一つ以上でClusterRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-view</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></code></pre></div><table>
<col width=25%><col width=25%><col>
<tr>
<th>デフォルトのClusterRole</th>
<th>デフォルトのClusterRoleBinding</th>
<th>説明</th>
</tr>
<tr>
<td><b>cluster-admin</b></td>
<td><b>system:masters</b> group</td>
<td>スーパーユーザーが任意のリソースで任意のアクションを実行できるようにします。
<b>ClusterRoleBinding</b>で使用すると、クラスター内およびすべてのNamespace内のすべてのリソースを完全に制御できます。
<b>RoleBinding</b>で使用すると、Namespace自体を含む、RoleBindingのNamespace内のすべてのリソースを完全に制御できます。</td>
</tr>
<tr>
<td><b>admin</b></td>
<td>None</td>
<td><b>RoleBinding</b>を使用してNamespace内で付与することを想定した、管理者アクセスを許可します。
<b>RoleBinding</b>で使用した場合、Namespace内にRoleとRoleBindingを作成する機能を含め、Namespaceのほとんどのリソースへの読み取り/書き込みアクセスを許可します。
このRoleは、リソースクォータまたはNamespace自体への書き込みアクセスを許可しません。</td>
</tr>
<tr>
<td><b>edit</b></td>
<td>None</td>
<td>Namespace内のほとんどのオブジェクトへの読み取り/書き込みアクセスを許可します。
<p>このRoleは、RoleまたはRoleBindingの表示または変更を許可しません。
ただし、このRoleでは、Secretsにアクセスして、Namespace内の任意のServiceAccountとしてPodsを実行できるため、Namespace内の任意のServiceAccountのAPIアクセスレベルを取得するために使用できます。</td></p>
</tr>
<tr>
<td><b>view</b></td>
<td>None</td>
<td>Namespace内のほとんどのオブジェクトを表示するための読み取り専用アクセスを許可します。
RoleまたはRoleBindingは表示できません。
<p>Secretsの内容を読み取るとNamespaceのServiceAccountのクレデンシャルにアクセスできるため、このRoleではSecretsの表示は許可されません。これにより、Namespace内の任意のServiceAccountとしてAPIアクセスが許可されます(特権昇格の形式)。</td></p>
</tr>
</table>
<h3 id=コアコンポーネントのrole>コアコンポーネントのRole</h3>
<table>
<col width=25%><col width=25%><col>
<tr>
<th>デフォルトのClusterRole</th>
<th>デフォルトのClusterRoleBinding</th>
<th>説明</th>
</tr>
<tr>
<td><b>system:kube-scheduler</b></td>
<td><b>system:kube-scheduler</b> user</td>
<td><a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、新しく作られたPodにノードが割り当てられているか監視し、割り当てられていなかった場合にそのPodを実行するノードを選択します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=scheduler>scheduler</a>コンポーネントが必要とするリソースへのアクセスを許可します。</td>
</tr>
<tr>
<td><b>system:volume-scheduler</b></td>
<td><b>system:kube-scheduler</b> user</td>
<td>kube-scheduleコンポーネントが必要とするリソースへのアクセスを許可します。</td>
</tr>
<tr>
<td><b>system:kube-controller-manager</b></td>
<td><b>system:kube-controller-manager</b> user</td>
<td><a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label="controller manager">controller manager</a>コンポーネントが必要とするリソースへのアクセスを許可します。
個々のコントローラーに必要な権限については、<a href=#controller-roles>組み込みコントローラーのRoleで詳しく説明しています</a>。</td>
</tr>
<tr>
<td><b>system:node</b></td>
<td>None</td>
<td><b>すべてのsecretへの読み取りアクセス、すべてのポッドステータスオブジェクトへの書き込みアクセスなど、</b>kubeletが必要とするリソースへのアクセスを許可します。
<p><tt>system:node</tt>Roleの代わりに<a href=/docs/reference/access-authn-authz/node/>Node authorizer</a>と <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a>を使用し、それらで実行するようにスケジュールされたPodに基づいてkubeletへのAPIアクセスを許可する必要があります。</p>
<p><tt>system:node</tt>のRoleは、V1.8より前のバージョンからアップグレードしたKubernetesクラスターとの互換性のためだけに存在します。</p>
</td>
</tr>
<tr>
<td><b>system:node-proxier</b></td>
<td><b>system:kube-proxy</b> user</td>
<td><a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>コンポーネントが必要とするリソースへのアクセスを許可します。</td>
</tr>
</table>
<h3 id=他のコンポーネントのrole>他のコンポーネントのRole</h3>
<table>
<col width=25%><col width=25%><col>
<tr>
<th>デフォルトのClusterRole</th>
<th>デフォルトのClusterRoleBinding</th>
<th>説明</th>
</tr>
<tr>
<td><b>system:auth-delegator</b></td>
<td>None</td>
<td>委任された認証と認可のチェックを許可します。
これは一般に、認証と認可を統合するためにアドオンAPIサーバーで使用されます。</td>
</tr>
<tr>
<td><b>system:heapster</b></td>
<td>None</td>
<td><a href=https://github.com/kubernetes/heapster>Heapster</a>コンポーネントのRole(非推奨)。</td>
</tr>
<tr>
<td><b>system:kube-aggregator</b></td>
<td>None</td>
<td><a href=https://github.com/kubernetes/kube-aggregator>kube-aggregator</a>コンポーネントのRole。</td>
</tr>
<tr>
<td><b>system:kube-dns</b></td>
<td><b><b>kube-system</b>Namespaceのサービスアカウントkube-dns</b></td>
<td><a href=/ja/docs/concepts/services-networking/dns-pod-service/>kube-dns</a>コンポーネントのRole。</td>
</tr>
<tr>
<td><b>system:kubelet-api-admin</b></td>
<td>None</td>
<td>kubelet APIへのフルアクセスを許可します。</td>
</tr>
<tr>
<td><b>system:node-bootstrapper</b></td>
<td>None</td>
<td><a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLS bootstrapping</a>の実行に必要なリソースへのアクセスを許可します。</td>
</tr>
<tr>
<td><b>system:node-problem-detector</b></td>
<td>None</td>
<td><a href=https://github.com/kubernetes/node-problem-detector>node-problem-detector</a>コンポーネントのRole。</td>
</tr>
<tr>
<td><b>system:persistent-volume-provisioner</b></td>
<td>None</td>
<td>ほとんどの<a href=/ja/docs/concepts/storage/persistent-volumes/#dynamic>dynamic volume provisioners</a>が必要とするリソースへのアクセスを許可します。</td>
</tr>
</table>
<h3 id=controller-roles>組み込みコントローラーのRole</h3>
<p>Kubernetes <a class=glossary-tooltip title=コントロールプレーン上で動作するコンポーネントで、複数のコントローラープロセスを実行します。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label="controller manager">controller manager</a>は、Kubernetesコントロールプレーンに組み込まれている<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a>を実行します。
<code>--use-service-account-credentials</code>を指定して呼び出すと、kube-controller-manager個別のサービスアカウントを使用して各コントローラーを起動します。
組み込みコントローラーごとに、プレフィックス<code>system:controller:</code>付きの対応するRoleが存在します。
コントローラーマネージャーが<code>--use-service-account-credentials</code>で開始されていない場合、コントローラマネージャーは、関連するすべてのRoleを付与する必要がある自身のクレデンシャルを使用して、すべてのコントロールループを実行します。
これらのRoleは次のとおりです。</p>
<ul>
<li><code>system:controller:attachdetach-controller</code></li>
<li><code>system:controller:certificate-controller</code></li>
<li><code>system:controller:clusterrole-aggregation-controller</code></li>
<li><code>system:controller:cronjob-controller</code></li>
<li><code>system:controller:daemon-set-controller</code></li>
<li><code>system:controller:deployment-controller</code></li>
<li><code>system:controller:disruption-controller</code></li>
<li><code>system:controller:endpoint-controller</code></li>
<li><code>system:controller:expand-controller</code></li>
<li><code>system:controller:generic-garbage-collector</code></li>
<li><code>system:controller:horizontal-pod-autoscaler</code></li>
<li><code>system:controller:job-controller</code></li>
<li><code>system:controller:namespace-controller</code></li>
<li><code>system:controller:node-controller</code></li>
<li><code>system:controller:persistent-volume-binder</code></li>
<li><code>system:controller:pod-garbage-collector</code></li>
<li><code>system:controller:pv-protection-controller</code></li>
<li><code>system:controller:pvc-protection-controller</code></li>
<li><code>system:controller:replicaset-controller</code></li>
<li><code>system:controller:replication-controller</code></li>
<li><code>system:controller:resourcequota-controller</code></li>
<li><code>system:controller:root-ca-cert-publisher</code></li>
<li><code>system:controller:route-controller</code></li>
<li><code>system:controller:service-account-controller</code></li>
<li><code>system:controller:service-controller</code></li>
<li><code>system:controller:statefulset-controller</code></li>
<li><code>system:controller:ttl-controller</code></li>
</ul>
<h2 id=特権昇格の防止とブートストラップ>特権昇格の防止とブートストラップ</h2>
<p>RBAC APIは、RoleまたはRoleBindingを編集することにより、ユーザーが特権を昇格するのを防ぎます。
これはAPIレベルで適用されるため、RBAC authorizerが使用されていない場合でも適用されます。</p>
<h3 id=roleの作成または更新に関する制限>Roleの作成または更新に関する制限</h3>
<p>次の項目1つ以上が当てはまる場合にのみ、Roleを作成/更新できます。</p>
<ol>
<li>変更対象のオブジェクトと同じスコープで、Roleに含まれるすべての権限を既に持っている(ClusterRoleの場合はクラスター全体。Roleの場合は、同じNamespace内またはクラスター全体)。</li>
<li><code>rbac.authorization.k8s.io</code>APIグループの<code> roles</code>または<code>clusterroles</code>リソースで<code> escalate</code> verbを実行する明示的な権限が付与されている。</li>
</ol>
<p>たとえば、 <code>user-1</code>にクラスター全体でSecretsを一覧表示する権限がない場合、それらにその権限を含むClusterRoleを作成できません。
ユーザーがRoleを作成/更新できるようにするには、以下のいずれかを実施します。</p>
<ol>
<li>必要に応じて、RoleオブジェクトまたはClusterRoleオブジェクトを作成/更新できるRoleを付与する。</li>
<li>作成/更新するRoleに特定の権限を含む権限を付与する。
<ul>
<li>暗黙的に、これらの権限を付与することにより(自分自身が付与されていない権限でRoleまたはClusterRoleを作成または変更しようとすると、APIリクエストは禁止されます)。</li>
<li>または、<code>rbac.authorization.k8s.io</code>APIグループの<code> roles</code>または <code>clusterroles</code>リソースで<code> escalate</code> verbを実行する権限を与えることにより、 <code>Role</code>または<code> ClusterRole</code>で権限を指定することを明示的に許可する</li>
</ul>
</li>
</ol>
<h3 id=rolebindingの作成または更新に関する制限>RoleBindingの作成または更新に関する制限</h3>
<p>参照されるRoleに含まれるすべての権限を(RoleBindingと同じスコープで)すでに持っている場合、
<em>または</em>参照されたRoleで<code>bind</code> verbを実行する認可されている場合のみ、RoleBindingを作成/更新できます。
たとえば、 <code>user-1</code>にクラスター全体でSecretsを一覧表示する権限がない場合、ClusterRoleBindingを作成してもRoleにその権限を付与できません。
ユーザーがRoleBindingを作成/更新できるようにするには、以下のいずれかを実施します。</p>
<ol>
<li>必要に応じて、RoleBindingまたはClusterRoleBindingオブジェクトを作成/更新できるようにする役割を付与する。</li>
<li>特定の役割をバインドするために必要なアクセス許可を付与する。
<ul>
<li>暗黙的に、Roleに含まれる権限を付与することによって。</li>
<li>明示的に、特定のRole(またはClusterRole)で <code>bind</code> verbを実行する許可を与えることによって。</li>
</ul>
</li>
</ol>
<p>たとえば、このClusterRoleとRoleBindingを使用すると、 <code>user-1</code>は他のユーザーにNamespace<code> user-1-namespace</code>の <code>admin</code>、<code> edit</code>、および <code>view</code>Roleを付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rbac.authorization.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rolebindings&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;create&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rbac.authorization.k8s.io&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;clusterroles&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;bind&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;admin&#34;</span>,<span style=color:#b44>&#34;edit&#34;</span>,<span style=color:#b44>&#34;view&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor-binding<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>user-1-namespace<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>user-1<span style=color:#bbb>
</span></code></pre></div><p>最初のRoleとRoleBindingをブートストラップするときは、最初のユーザーがまだ持っていない権限を付与する必要があります。
初期RoleとRoleBindingをブートストラップするには、以下のいずれかを実施します。</p>
<ul>
<li>「system：masters」グループのクレデンシャルを使用します。このグループは、デフォルトのBindingによって「cluster-admin」スーパーユーザーRoleにバインドされています。</li>
<li>APIサーバーが安全でないポート(<code>--insecure-port</code>)を有効にして実行されている場合、そのポートを介してのAPI呼び出しもできます。これにより、認証や認可が実行されません。</li>
</ul>
<h2 id=コマンドラインユーティリティー>コマンドラインユーティリティー</h2>
<h3 id=kubectl-create-role><code>kubectl create role</code></h3>
<p>以下に、単一のNamespace内で権限を定義するRoleオブジェクトをいくつか例として作成します。</p>
<ul>
<li>
<p>ユーザーがポッドで <code>get</code>、<code> watch</code>、および <code>list</code>を実行できるように「pod-reader」という名前のRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role pod-reader --verb<span style=color:#666>=</span>get --verb<span style=color:#666>=</span>list --verb<span style=color:#666>=</span>watch --resource<span style=color:#666>=</span>pods
</code></pre></div></li>
<li>
<p>resourceNamesを指定して、「pod-reader」という名前のRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role pod-reader --verb<span style=color:#666>=</span>get --resource<span style=color:#666>=</span>pods --resource-name<span style=color:#666>=</span>readablepod --resource-name<span style=color:#666>=</span>anotherpod
</code></pre></div></li>
<li>
<p>apiGroupsを指定して「foo」という名前のRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>replicasets.apps
</code></pre></div></li>
<li>
<p>サブリソースの権限を持つ「foo」という名前のRoleを作成します。</p>
</li>
<li>
<p>Create a Role named "foo" with subresource permissions:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods,pods/status
</code></pre></div></li>
<li>
<p>特定の名前のリソースを取得/更新する権限を持つ「my-component-lease-holder」という名前のRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create role my-component-lease-holder --verb<span style=color:#666>=</span>get,list,watch,update --resource<span style=color:#666>=</span>lease --resource-name<span style=color:#666>=</span>my-component
</code></pre></div></li>
</ul>
<h3 id=kubectl-create-clusterrole><code>kubectl create clusterrole</code></h3>
<p>以下にClusterRoleをいくつか例として作成します。</p>
<ul>
<li>
<p>ユーザーがポッドに対して<code>get</code>、<code> watch</code>、および <code>list</code>を実行できるようにする「pod-reader」という名前のClusterRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole pod-reader --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods
</code></pre></div></li>
<li>
<p>resourceNamesを指定して、「pod-reader」という名前のClusterRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole pod-reader --verb<span style=color:#666>=</span>get --resource<span style=color:#666>=</span>pods --resource-name<span style=color:#666>=</span>readablepod --resource-name<span style=color:#666>=</span>anotherpod
</code></pre></div></li>
<li>
<p>apiGroupsを指定して「foo」という名前のClusterRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>replicasets.apps
</code></pre></div></li>
<li>
<p>サブリソースの権限を持つ「foo」という名前のClusterRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods,pods/status
</code></pre></div></li>
<li>
<p>nonResourceURLを指定して「foo」という名前のClusterRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole <span style=color:#b44>&#34;foo&#34;</span> --verb<span style=color:#666>=</span>get --non-resource-url<span style=color:#666>=</span>/logs/*
</code></pre></div></li>
<li>
<p>aggregationRuleを指定して、「monitoring」という名前のClusterRoleを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrole monitoring --aggregation-rule<span style=color:#666>=</span><span style=color:#b44>&#34;rbac.example.com/aggregate-to-monitoring=true&#34;</span>
</code></pre></div></li>
</ul>
<h3 id=kubectl-create-rolebinding><code>kubectl create rolebinding</code></h3>
<p>以下に、特定のNamespace内でRoleまたはClusterRoleをいくつか例として付与します。</p>
<ul>
<li>
<p>Namespace「acme」内で、「admin」ClusterRoleの権限を「bob」という名前のユーザーに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding bob-admin-binding --clusterrole<span style=color:#666>=</span>admin --user<span style=color:#666>=</span>bob --namespace<span style=color:#666>=</span>acme
</code></pre></div></li>
<li>
<p>Namespace「acme」内で、ClusterRole「view」へのアクセス許可を「myapp」というNamespace「acme」のサービスアカウントに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>acme:myapp --namespace<span style=color:#666>=</span>acme
</code></pre></div></li>
<li>
<p>Namespace「acme」内で、ClusterRole「view」へのアクセス許可を「myapp」というNamespace「myappnamespace」のサービスアカウントに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding myappnamespace-myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>myappnamespace:myapp --namespace<span style=color:#666>=</span>acme
</code></pre></div></li>
</ul>
<h3 id=kubectl-create-clusterrolebinding><code>kubectl create clusterrolebinding</code></h3>
<p>以下に、クラスタ全体(すべてのNamespace)にClusterRoleをいくつか例として付与します。</p>
<ul>
<li>
<p>クラスター全体で、ClusterRole「cluster-admin」へのアクセス許可を「root」という名前のユーザーに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole<span style=color:#666>=</span>cluster-admin --user<span style=color:#666>=</span>root
</code></pre></div></li>
<li>
<p>クラスター全体で、ClusterRole「system：node-proxier」へのアクセス許可を「system：kube-proxy」という名前のユーザーに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding kube-proxy-binding --clusterrole<span style=color:#666>=</span>system:node-proxier --user<span style=color:#666>=</span>system:kube-proxy
</code></pre></div></li>
<li>
<p>クラスター全体で、ClusterRole「view」へのアクセス許可を、Namespace「acme」の「myapp」という名前のサービスアカウントに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>acme:myapp
</code></pre></div></li>
</ul>
<h3 id=kubectl-auth-reconcile><code>kubectl auth reconcile</code></h3>
<p>マニフェストファイルから <code>rbac.authorization.k8s.io/v1</code>APIオブジェクトを作成または更新します。</p>
<p>欠落しているオブジェクトが作成され、必要に応じて、Namespaceに属するオブジェクト用にオブジェクトを含むNamespaceが作成されます。</p>
<p>既存のRoleが更新され、入力オブジェクトに権限が含まれるようになります。
<code>--remove-extra-permissions</code>が指定されている場合は、余分な権限を削除します。</p>
<p>既存のBindingが更新され、入力オブジェクトにsubjectsが含まれるようになります。
<code>--remove-extra-subjects</code>が指定されている場合は、余分な件名を削除します。</p>
<p>以下、例として。</p>
<ul>
<li>
<p>RBACオブジェクトのマニフェストファイルをテストとして適用し、行われる変更を表示します。</p>
<pre><code>kubectl auth reconcile -f my-rbac-rules.yaml --dry-run=client
</code></pre></li>
<li>
<p>RBACオブジェクトのマニフェストファイルを適用し、(Role内の)追加のアクセス許可と(Binding内の)追加のsubjectsを保持します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl auth reconcile -f my-rbac-rules.yaml
</code></pre></div></li>
<li>
<p>RBACオブジェクトのマニフェストファイルを適用し、(Role内の)余分なアクセス許可と(Binding内の)余分なsubjectsを削除します。</p>
</li>
</ul>
<h2 id=service-account-permissions>ServiceAccount権限</h2>
<p>デフォルトのRBACポリシーは、コントロールプレーンコンポーネント、ノード、
およびコントローラーをスコープとして権限を付与しますが、 Namespace<code>kube-system</code>外のサービスアカウントには<em>no permissions</em>で付与します
(すべての認証されたユーザーに与えられたディスカバリー権限に関わらず)。</p>
<p>これにより、必要に応じて特定のServiceAccountに特定のRoleを付与できます。
きめ細かいRoleBindingはセキュリティを強化しますが、管理にはより多くの労力が必要です。
より広範な権限は、不必要な(そして潜在的にエスカレートする)APIアクセスをServiceAccountsに与える可能性がありますが、管理が簡単です。</p>
<p>アプローチを最も安全なものから最も安全でないものの順に並べると、次のとおりです。</p>
<ol>
<li>
<p>アプリケーション固有のサービスアカウントにRoleを付与する(ベストプラクティス)
これには、アプリケーションがpodのspec、そして作成するサービスアカウント(API、アプリケーションマニフェスト、 <code>kubectl create serviceaccount</code>などを介して）で<code>serviceAccountName</code>を指定する必要があります。
たとえば、「my-namespace」内の読み取り専用権限を「my-sa」サービスアカウントに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding my-sa-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>my-namespace:my-sa <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</code></pre></div></li>
<li>
<p>あるNamespaceのサービスアカウント「default」にRoleを付与します</p>
<p>アプリケーションが <code>serviceAccountName</code>を指定しない場合、サービスアカウント「default」を使用します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> サービスアカウント「default」に付与された権限は、<code>serviceAccountName</code>を指定しないNamespace内のすべてのポッドで利用できます。
</div>
<p>たとえば、「my-namespace」内の読み取り専用権限をサービスアカウント「default」に付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding default-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>my-namespace:default <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</code></pre></div><p>多くの<a href=/ja/docs/concepts/cluster-administration/addons/>アドオン</a>は、
Namespace<code>kube-system</code>のサービスアカウント「default」として実行されます。
これらのアドオンをスーパーユーザーアクセスでの実行を許可するには、Namespace<code>kube-system</code>のサービスアカウント「default」のcluster-admin権限を付与します。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> これを有効にすると、 Namespace`kube-systemにクラスターのAPIへのスーパーユーザーアクセス許可するSecretsが含まれます。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding add-on-cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>kube-system:default
</code></pre></div></li>
<li>
<p>Namespace内のすべてのサービスアカウントにRoleを付与します</p>
<p>Namespace内のすべてのアプリケーションにRoleを持たせたい場合は、使用するサービスアカウントに関係なく、
そのNamespaceのサービスアカウントグループにRoleを付与できます。</p>
<p>たとえば、「my-namespace」内の読み取り専用アクセス許可を、そのNamespace内のすべてのサービスアカウントに付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create rolebinding serviceaccounts-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts:my-namespace <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</code></pre></div></li>
<li>
<p>クラスター全体のすべてのサービスアカウントに制限されたRoleを付与します(お勧めしません)</p>
<p>Namespaceごとのアクセス許可を管理したくない場合は、すべてのサービスアカウントにクラスター全体の役割を付与できます。</p>
<p>たとえば、クラスター内のすべてのサービスアカウントに、すべてのNamespaceで読み取り専用のアクセス許可を付与します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding serviceaccounts-view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span> --group<span style=color:#666>=</span>system:serviceaccounts
</code></pre></div></li>
<li>
<p>クラスター全体のすべてのサービスアカウントへのスーパーユーザーアクセスを許可します。(強くお勧めしません)</p>
<p>権限の分割をまったく考慮しない場合は、すべてのサービスアカウントにスーパーユーザーアクセスを許可できます。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> これにより、すべてのアプリケーションにクラスターへのフルアクセスが許可され、Secretsの読み取りアクセス権(または任意のポッドを作成する機能)を持つユーザーに、クラスターへのフルアクセスが許可されます。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding serviceaccounts-cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</code></pre></div></li>
</ol>
<h2 id=abacからアップグレードする>ABACからアップグレードする</h2>
<p>以前は古いバージョンのKubernetesを実行していたクラスターは、すべてのサービスアカウントに完全なAPIアクセスを許可するなど、permissiveなABACポリシーを使用することがよくありました。</p>
<p>デフォルトのRBACポリシーは、コントロールプレーンコンポーネント、ノード、
およびコントローラーをスコープとして権限を付与しますが、 Namespace<code>kube-system</code>外のサービスアカウントには<em>no permissions</em>で付与します
(すべての認証されたユーザーに与えられたディスカバリー権限に関わらず)。</p>
<p>これははるかに安全ですが、API権限を自動的に受け取ることを期待している既存のワークロードを混乱させる可能性があります。
この移行を管理するための2つのアプローチは次のとおりです。</p>
<h3 id=並行認可>並行認可</h3>
<p>RBACとABACの両方のauthorizerを実行し、<a href=/docs/reference/access-authn-authz/abac/#policy-file-format>legacy ABAC policy</a>を含むポリシーファイルを指定します。</p>
<pre><code>--authorization-mode=...,RBAC,ABAC --authorization-policy-file=mypolicy.json
</code></pre><p>最初のコマンドラインオプションを詳細に説明すると、Nodeなどの以前のauthorizerが
要求を拒否すると、RBAC authorizerはAPI要求を認可しようとします。 RBACの場合
また、そのAPI要求を拒否すると、ABAC authorizerが実行されます。これにより、すべてのリクエストが
RBACまたはABACポリシーの<em>いずれか</em>で許可されます。</p>
<p>RBACコンポーネントのログレベルが5以上でkube-apiserverを実行した場合(<code>--vmodule = rbac * = 5</code>または<code> --v = 5</code>)、APIサーバーログでRBACの拒否を確認できます(プレフィックスは「RBAC」)。
その情報を使用して、どのRoleをどのユーザー、グループ、またはサービスアカウントに付与する必要があるかを判断できます。</p>
<p><a href=#service-account-permissions>サービスアカウントに付与されたRole</a>を取得し、
ワークロードがサーバーログにRBACの拒否メッセージがない状態で実行されている場合は、ABAC authorizerを削除できます。</p>
<h3 id=permissive-rbac権限>Permissive RBAC権限</h3>
<p>RBACRoleBindingを使用して、permissive ABACポリシーを複製できます。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> <p>次のポリシーでは、<strong>すべて</strong>のサービスアカウントがクラスター管理者としてふるまうことを許可しています。
コンテナで実行されているアプリケーションは、サービスアカウントのクレデンシャルを自動的に受け取ります。
secretsの表示や権限の変更など、APIに対して任意のアクションを実行できます。
これは推奨されるポリシーではありません。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding permissive-binding <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --user<span style=color:#666>=</span>admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --user<span style=color:#666>=</span>kubelet <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</code></pre></div>
</div>
<p>RBACの使用に移行後、クラスターが情報セキュリティのニーズを確実に満たすように、アクセスコントロールを調整する必要があります。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4f002b9458521ca7afd32176fd590646>7 - ツール</h1>
<p>Kubernetesには、Kubernetesシステムの操作に役立ついくつかの組み込みツールが含まれています。</p>
<h2 id=kubectl>Kubectl</h2>
<p><a href=/docs/tasks/tools/install-kubectl/><code>kubectl</code></a>は、Kubernetesのためのコマンドラインツールです。このコマンドはKubernetes cluster managerを操作します。</p>
<h2 id=kubeadm>Kubeadm</h2>
<p><a href=docs/setup/production-environment/tools/kubeadm/install-kubeadm/><code>kubeadm</code></a>は、物理サーバやクラウドサーバ、仮想マシン上にKubernetesクラスタを容易にプロビジョニングするためのコマンドラインツールです(現在はアルファ版です)。</p>
<h2 id=minikube>Minikube</h2>
<p><a href=https://minikube.sigs.k8s.io/docs/><code>minikube</code></a>は、開発やテストのためにワークステーション上でシングルノードのKubernetesクラスタをローカルで実行するツールです。</p>
<h2 id=dashboard>Dashboard</h2>
<p><a href=/docs/tasks/access-application-cluster/web-ui-dashboard/><code>Dashboard</code></a>は、KubernetesのWebベースのユーザインタフェースで、コンテナ化されたアプリケーションをKubernetesクラスタにデプロイしたり、トラブルシューティングしたり、クラスタとそのリソース自体を管理したりすることが出来ます。</p>
<h2 id=helm>Helm</h2>
<p><a href=https://github.com/helm/helm><code>Kubernetes Helm</code></a>は、事前に設定されたKubernetesリソースのパッケージ、別名Kubernetes chartsを管理するためのツールです。</p>
<p>Helmを用いて以下のことを行います。</p>
<ul>
<li>
<p>Kubernetes chartsとしてパッケージ化された人気のあるソフトウェアの検索と利用</p>
</li>
<li>
<p>Kubernetes chartsとして所有するアプリケーションを共有すること</p>
</li>
<li>
<p>Kubernetesアプリケーションの再現性のあるビルドの作成</p>
</li>
<li>
<p>Kubernetesマニフェストファイルを知的な方法で管理</p>
</li>
<li>
<p>Helmパッケージのリリース管理</p>
</li>
</ul>
<h2 id=kompose>Kompose</h2>
<p><a href=https://github.com/kubernetes/kompose><code>Kompose</code></a>は、Docker ComposeユーザがKubernetesに移行する手助けをするツールです。</p>
<p>Komposeを用いて以下のことを行います。</p>
<ul>
<li>
<p>Docker ComposeファイルのKubernetesオブジェクトへの変換</p>
</li>
<li>
<p>ローカルのDocker開発からKubernetesを経由したアプリケーション管理への移行</p>
</li>
<li>
<p>v1またはv2のDocker Compose用 <code>yaml</code> ファイルならびに<a href=https://docs.docker.com/compose/bundles/>分散されたアプリケーションバンドル</a>の変換</p>
</li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>