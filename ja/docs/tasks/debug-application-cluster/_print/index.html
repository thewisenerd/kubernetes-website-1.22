<!doctype html><html lang=ja class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/debug-application-cluster/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/debug-application-cluster/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/tasks/debug-application-cluster/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>監視、ログ、デバッグ | Kubernetes</title><meta property="og:title" content="監視、ログ、デバッグ">
<meta property="og:description" content="クラスターのトラブルシューティングや、コンテナ化したアプリケーションのデバッグのために、監視とログをセットアップします。">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/ja/docs/tasks/debug-application-cluster/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="監視、ログ、デバッグ">
<meta itemprop=description content="クラスターのトラブルシューティングや、コンテナ化したアプリケーションのデバッグのために、監視とログをセットアップします。"><meta name=twitter:card content="summary">
<meta name=twitter:title content="監視、ログ、デバッグ">
<meta name=twitter:description content="クラスターのトラブルシューティングや、コンテナ化したアプリケーションのデバッグのために、監視とログをセットアップします。">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="クラスターのトラブルシューティングや、コンテナ化したアプリケーションのデバッグのために、監視とログをセットアップします。">
<meta property="og:description" content="クラスターのトラブルシューティングや、コンテナ化したアプリケーションのデバッグのために、監視とログをセットアップします。">
<meta name=twitter:description content="クラスターのトラブルシューティングや、コンテナ化したアプリケーションのデバッグのために、監視とログをセットアップします。">
<meta property="og:url" content="https://kubernetes.io/ja/docs/tasks/debug-application-cluster/">
<meta property="og:title" content="監視、ログ、デバッグ">
<meta name=twitter:title content="監視、ログ、デバッグ">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/ja/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/ja/docs/>ドキュメント</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/training/>トレーニング</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/partners/>パートナー</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/community/>コミュニティ</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/case-studies/>ケーススタディ</span></a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
バージョン
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/tasks/debug-application-cluster/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/ja/docs/tasks/debug-application-cluster/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/tasks/debug-application-cluster/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/tasks/debug-application-cluster/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/tasks/debug-application-cluster/>v1.22</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
日本語 Japanese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/tasks/debug-application-cluster/>English</a>
<a class=dropdown-item href=/zh/docs/tasks/debug-application-cluster/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/tasks/debug-application-cluster/>한국어 Korean</a>
<a class=dropdown-item href=/fr/docs/tasks/debug-application-cluster/>Français</a>
<a class=dropdown-item href=/de/docs/tasks/debug-application-cluster/>Deutsch</a>
<a class=dropdown-item href=/es/docs/tasks/debug-application-cluster/>Español</a>
<a class=dropdown-item href=/id/docs/tasks/debug-application-cluster/>Bahasa Indonesia</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.
</p><p>
<a href=/ja/docs/tasks/debug-application-cluster/>このページの通常のビューに戻る</a>.
</p>
</div>
<h1 class=title>監視、ログ、デバッグ</h1>
<div class=lead>クラスターのトラブルシューティングや、コンテナ化したアプリケーションのデバッグのために、監視とログをセットアップします。</div>
<ul>
<li>1: <a href=#pg-06bb252f25983de12f635c806d180d30>Initコンテナのデバッグ</a></li>
<li>2: <a href=#pg-858517cd46a1b5a1fd2e650edd785cea>PodとReplicationControllerのデバッグ</a></li>
<li>3: <a href=#pg-ef360b1f8e65236251826db478cfcab3>Pod障害の原因を特定する</a></li>
<li>4: <a href=#pg-f79645981e310858111bd5673614cab6>Serviceのデバッグ</a></li>
<li>5: <a href=#pg-a070b1250ee142402d492b505a56ca83>StatefulSetのデバッグ</a></li>
<li>6: <a href=#pg-9713ac27b6d9e3034033200d968221f2>実行中のコンテナへのシェルを取得する</a></li>
</ul>
<div class=content>
</div>
</div>
<div class=td-content>
<h1 id=pg-06bb252f25983de12f635c806d180d30>1 - Initコンテナのデバッグ</h1>
<p>このページでは、Initコンテナの実行に関連する問題を調査する方法を説明します。以下のコマンドラインの例では、Podを<code>&lt;pod-name></code>、Initコンテナを<code>&lt;init-container-1></code>および<code>&lt;init-container-2></code>として参照しています。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<ul>
<li><a href=/ja/docs/concepts/workloads/pods/init-containers/>Initコンテナ</a>の基本を理解しておきましょう。</li>
<li><a href=/docs/tasks/configure-pod-container/configure-pod-initialization/#creating-a-pod-that-has-an-init-container/>Initコンテナを設定</a>しておきましょう。</li>
</ul>
<h2 id=initコンテナのステータスを確認する>Initコンテナのステータスを確認する</h2>
<p>Podのステータスを表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod &lt;pod-name&gt;
</code></pre></div><p>たとえば、<code>Init：1/2</code>というステータスは、2つのInitコンテナのうちの1つが正常に完了したことを示します。</p>
<pre><code>NAME         READY     STATUS     RESTARTS   AGE
&lt;pod-name&gt;   0/1       Init:1/2   0          7s
</code></pre><p>ステータス値とその意味の例については、<a href=#understanding-pod-status>Podのステータスを理解する</a>を参照してください。</p>
<h2 id=initコンテナの詳細を取得する>Initコンテナの詳細を取得する</h2>
<p>Initコンテナの実行に関する詳細情報を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod &lt;pod-name&gt;
</code></pre></div><p>たとえば、2つのInitコンテナを持つPodでは、次のように表示されます:</p>
<pre><code>Init Containers:
  &lt;init-container-1&gt;:
    Container ID:    ...
    ...
    State:           Terminated
      Reason:        Completed
      Exit Code:     0
      Started:       ...
      Finished:      ...
    Ready:           True
    Restart Count:   0
    ...
  &lt;init-container-2&gt;:
    Container ID:    ...
    ...
    State:           Waiting
      Reason:        CrashLoopBackOff
    Last State:      Terminated
      Reason:        Error
      Exit Code:     1
      Started:       ...
      Finished:      ...
    Ready:           False
    Restart Count:   3
    ...
</code></pre><p>また、Pod Specの<code>status.initContainerStatuses</code>フィールドを読むことでプログラムでInitコンテナのステータスにアクセスすることもできます。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod nginx --template <span style=color:#b44>&#39;{{.status.initContainerStatuses}}&#39;</span>
</code></pre></div><p>このコマンドは生のJSONで上記と同じ情報を返します。</p>
<h2 id=initコンテナのログにアクセスする>Initコンテナのログにアクセスする</h2>
<p>ログにアクセスするには、Initコンテナ名とPod名を渡します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs &lt;pod-name&gt; -c &lt;init-container-2&gt;
</code></pre></div><p>シェルスクリプトを実行するInitコンテナは、実行時にコマンドを出力します。たとえば、スクリプトの始めに<code>set -x</code>を実行することでBashで同じことができます。</p>
<h2 id=understanding-pod-status>Podのステータスを理解する</h2>
<p><code>Init：</code>で始まるPodステータスはInitコンテナの実行ステータスを要約します。以下の表は、Initコンテナのデバッグ中に表示される可能性のあるステータス値の例をいくつか示しています。</p>
<table>
<thead>
<tr>
<th>ステータス</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Init:N/M</code></td>
<td>Podは<code>M</code>個のInitコンテナを持ち、これまでに<code>N</code>個完了しました。</td>
</tr>
<tr>
<td><code>Init:Error</code></td>
<td>Initコンテナが実行に失敗しました。</td>
</tr>
<tr>
<td><code>Init:CrashLoopBackOff</code></td>
<td>Initコンテナが繰り返し失敗しました。</td>
</tr>
<tr>
<td><code>Pending</code></td>
<td>PodはまだInitコンテナの実行を開始していません。</td>
</tr>
<tr>
<td><code>PodInitializing</code> or <code>Running</code></td>
<td>PodはすでにInitコンテナの実行を終了しています。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-858517cd46a1b5a1fd2e650edd785cea>2 - PodとReplicationControllerのデバッグ</h1>
<p>このページでは、PodとReplicationControllerをデバッグする方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<ul>
<li><a href=/ja/docs/concepts/workloads/pods/pod/>Pod</a>と<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>の基本を理解している必要があります。</li>
</ul>
<h2 id=podのデバッグ>Podのデバッグ</h2>
<p>Podのデバッグの最初のステップは、Podを調べることです。
次のコマンドで、Podの現在の状態と最近のイベントを確認して下さい。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pods <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div><p>Pod内のコンテナの状態を確認します。
コンテナはすべて<code>Running</code>状態ですか？最近再起動はしましたか？</p>
<p>Podの状態に応じてデバッグを続けます。</p>
<h3 id=podがpending状態にとどまっている>PodがPending状態にとどまっている</h3>
<p>Podが<code>Pending</code>状態でスタックしている場合、ノードにスケジュールできていないことを意味します。
一般的に、これは、何らかのタイプのリソースが不足しており、それによってスケジューリングを妨げられているためです。
上述の<code>kubectl describe...</code>コマンドの出力を確認してください。
Podをスケジュールできない理由に関するスケジューラーからのメッセージがあるはずです。
理由としては以下のようなものがあります。</p>
<h4 id=リソースが不十分>リソースが不十分</h4>
<p>クラスター内のCPUまたはメモリーの供給を使い果たした可能性があります。
この場合、いくつかのことを試すことができます。</p>
<ul>
<li>
<p>クラスターにノードを追加します。</p>
</li>
<li>
<p><a href=/docs/concepts/workloads/pods/#pod-termination>不要なPodを終了</a>して、
<code>Pending</code>状態のPodのための空きリソースを作ります。</p>
</li>
<li>
<p>Podがノードよりも大きくないことを確認します。
例えば、すべてのノードのキャパシティーが<code>cpu: 1</code>の場合、<code>cpu: 1.1</code>を要求するPodは決してスケジュールされません。</p>
<p><code>kubectl get nodes -o &lt;format></code>コマンドでノードのキャパシティーを確認できます。
必要な情報を抽出するコマンドラインの例を以下に示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes -o yaml | egrep <span style=color:#b44>&#39;\sname:|cpu:|memory:&#39;</span>
kubectl get nodes -o json | jq <span style=color:#b44>&#39;.items[] | {name: .metadata.name, cap: .status.capacity}&#39;</span>
</code></pre></div><p><a href=/docs/concepts/policy/resource-quotas/>リソースクォータ</a>機能では、
消費できるリソースの合計量を制限するように構成できます。
Namespaceと組み合わせて使用すると、1つのチームがすべてのリソースを占有することを防ぐことができます。</p>
</li>
</ul>
<h4 id=hostportの使用>hostPortの使用</h4>
<p>Podを<code>hostPort</code>にバインドすると、Podをスケジュールできる場所の数が制限されます。
ほとんどの場合、<code>hostPort</code>は不要です。Serviceオブジェクトを使用してPodを公開してください。
どうしても<code>hostPort</code>が必要な場合は、コンテナクラスター内のノードと同じ数のPodのみをスケジュールできます。</p>
<h3 id=podがwaiting状態にとどまっている>PodがWaiting状態にとどまっている</h3>
<p>Podが<code>Waiting</code>状態でスタックしている場合、Podはワーカーノードにスケジュールされていますが、そのマシンでは実行できない状態です。
この場合も、<code>kubectl describe ...</code>の情報が参考になるはずです。
Podが<code>Waiting</code>状態となる最も一般的な原因は、イメージをプルできないことです。
確認すべき事項が3つあります。</p>
<ul>
<li>イメージの名前が正しいことを確認して下さい。</li>
<li>イメージはリポジトリーにプッシュしましたか？</li>
<li>マシンで手動で<code>docker pull &lt;image></code>を実行し、イメージをプルできるかどうかを確認して下さい。</li>
</ul>
<h3 id=podがクラッシュする-あるいはunhealthy状態>Podがクラッシュする、あるいはUnhealthy状態</h3>
<p>Podがスケジュールされると、<a href=/docs/tasks/debug-application-cluster/debug-running-pod/>動作中のPodをデバッグする</a>に説明されている方法がデバッグに使用可能です。</p>
<h2 id=replicationcontrollerのデバッグ>ReplicationControllerのデバッグ</h2>
<p>ReplicationControllerはかなり明快です。Podを作成できるか、できないかのどちらかです。
Podを作成できない場合は、<a href=#Pod%E3%81%AE%E3%83%87%E3%83%90%E3%83%83%E3%82%B0>上述の手順</a>を参照してPodをデバッグしてください。</p>
<p><code>kubectl describe rc ${CONTROLLER_NAME}</code>を使用して、レプリケーションコントローラーに関連するイベントを調べることもできます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ef360b1f8e65236251826db478cfcab3>3 - Pod障害の原因を特定する</h1>
<p>このページでは、コンテナ終了メッセージの読み書き方法を説明します。</p>
<p>終了メッセージは、致命的なイベントに関する情報を、ダッシュボードや監視ソフトウェアなどのツールで簡単に取得して表示できる場所にコンテナが書き込むための手段を提供します。 ほとんどの場合、終了メッセージに入力した情報も一般的な<a href=/docs/concepts/cluster-administration/logging/>Kubernetesログ</a>に書き込まれるはずです。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=終了メッセージの書き込みと読み取り>終了メッセージの書き込みと読み取り</h2>
<p>この課題では、1つのコンテナを実行するPodを作成します。
設定ファイルには、コンテナの開始時に実行されるコマンドを指定します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/debug/termination.yaml download=debug/termination.yaml><code>debug/termination.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('debug-termination-yaml')" title="Copy debug/termination.yaml to clipboard">
</img>
</div>
<div class=includecode id=debug-termination-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>termination-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>termination-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep 10 &amp;&amp; echo Sleep expired &gt; /dev/termination-log&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>YAML設定ファイルに基づいてPodを作成します:</p>
<pre><code> kubectl apply -f https://k8s.io/examples/debug/termination.yaml
</code></pre>
<p>YAMLファイルの<code>command</code>フィールドと<code>args</code>フィールドで、コンテナが10秒間スリープしてから<code>/dev/termination-log</code>ファイルに「Sleep expired」と書いているのがわかります。コンテナが「Sleep expired」メッセージを書き込んだ後、コンテナは終了します。</p>
</li>
<li>
<p>Podに関する情報を表示します:</p>
<pre><code> kubectl get pod termination-demo
</code></pre>
<p>Podが実行されなくなるまで、上記のコマンドを繰り返します。</p>
</li>
<li>
<p>Podに関する詳細情報を表示します:</p>
<pre><code> kubectl get pod termination-demo --output=yaml
</code></pre>
<p>出力には「Sleep expired」メッセージが含まれています:</p>
<pre><code> apiVersion: v1
 kind: Pod
 ...
     lastState:
       terminated:
         containerID: ...
         exitCode: 0
         finishedAt: ...
         message: |
           Sleep expired
         ...
</code></pre>
</li>
<li>
<p>Goテンプレートを使用して、終了メッセージのみが含まれるように出力をフィルタリングします:</p>
<pre><code> kubectl get pod termination-demo -o go-template=&quot;{{range .status.containerStatuses}}{{.lastState.terminated.message}}{{end}}&quot;
</code></pre>
</li>
</ol>
<h2 id=終了メッセージのカスタマイズ>終了メッセージのカスタマイズ</h2>
<p>Kubernetesは、コンテナの<code>terminationMessagePath</code>フィールドで指定されている終了メッセージファイルから終了メッセージを取得します。デフォルト値は<code>/dev/termination-log</code>です。このフィールドをカスタマイズすることで、Kubernetesに別のファイルを使うように指示できます。Kubernetesは指定されたファイルの内容を使用して、成功と失敗の両方についてコンテナのステータスメッセージを入力します。</p>
<p>終了メッセージはアサーションエラーメッセージのように、最終状態を簡潔に示します。kubeletは4096バイトより長いメッセージは切り詰めます。全コンテナの合計メッセージの長さの上限は12キビバイトです。デフォルトの終了メッセージのパスは<code>/dev/termination-log</code>です。Pod起動後に終了メッセージのパスを設定することはできません。</p>
<p>次の例では、コンテナはKubernetesが取得するために終了メッセージを<code>/tmp/my-log</code>に書き込みます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>msg-path-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>msg-path-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>terminationMessagePath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp/my-log&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>さらに、ユーザーは追加のカスタマイズをするためにContainerの<code>terminationMessagePolicy</code>フィールドを設定できます。このフィールドのデフォルト値は<code>File</code>です。これは、終了メッセージが終了メッセージファイルからのみ取得されることを意味します。<code>terminationMessagePolicy</code>を<code>FallbackToLogsOnError</code>に設定することで、終了メッセージファイルが空でコンテナがエラーで終了した場合に、コンテナログ出力の最後のチャンクを使用するようにKubernetesに指示できます。ログ出力は、2048バイトまたは80行のどちらか小さい方に制限されています。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#container-v1-core>コンテナ</a>の<code>terminationMessagePath</code>フィールド参照</li>
<li><a href=/docs/concepts/cluster-administration/logging/>ログ取得</a>について</li>
<li><a href=https://golang.org/pkg/text/template/>Goテンプレート</a>について</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f79645981e310858111bd5673614cab6>4 - Serviceのデバッグ</h1>
<p>新規にKubernetesをインストールした環境でかなり頻繁に発生する問題は、Serviceが適切に機能しないというものです。Deployment(または他のワークロードコントローラー)を通じてPodを実行し、サービスを作成したにもかかわらず、アクセスしようとしても応答がありません。何が問題になっているのかを理解するのに、このドキュメントがきっと役立つでしょう。</p>
<h2 id=pod内でコマンドを実行する>Pod内でコマンドを実行する</h2>
<p>ここでの多くのステップでは、クラスターで実行されているPodが見ているものを確認する必要があります。これを行う最も簡単な方法は、インタラクティブなalpineのPodを実行することです。</p>
<pre><code class=language-none data-lang=none>kubectl run -it --rm --restart=Never alpine --image=alpine sh
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> コマンドプロンプトが表示されない場合は、Enterキーを押してみてください。
</div>
<p>使用したい実行中のPodがすでにある場合は、以下のようにしてそのPod内でコマンドを実行できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> &lt;POD-NAME&gt; -c &lt;CONTAINER-NAME&gt; -- &lt;COMMAND&gt;
</code></pre></div><h2 id=セットアップ>セットアップ</h2>
<p>このドキュメントのウォークスルーのために、いくつかのPodを実行しましょう。おそらくあなた自身のServiceをデバッグしているため、あなた自身の詳細に置き換えることもできますし、これに沿って2番目のデータポイントを取得することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment hostnames --image<span style=color:#666>=</span>k8s.gcr.io/serve_hostname
</code></pre></div><pre><code class=language-none data-lang=none>deployment.apps/hostnames created
</code></pre><p><code>kubectl</code>コマンドは作成、変更されたリソースのタイプと名前を出力するため、この後のコマンドで使用することもできます。</p>
<p>Deploymentを3つのレプリカにスケールさせてみましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment hostnames --replicas<span style=color:#666>=</span><span style=color:#666>3</span>
</code></pre></div><pre><code class=language-none data-lang=none>deployment.apps/hostnames scaled
</code></pre><p>これは、次のYAMLでDeploymentを開始した場合と同じです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/serve_hostname<span style=color:#bbb>
</span></code></pre></div><p>"app"ラベルは<code>kubectl create deployment</code>によって、Deploymentの名前に自動的にセットされます。</p>
<p>Podが実行されていることを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME                        READY     STATUS    RESTARTS   AGE
hostnames-632524106-bbpiw   1/1       Running   0          2m
hostnames-632524106-ly40y   1/1       Running   0          2m
hostnames-632524106-tlaok   1/1       Running   0          2m
</code></pre><p>Podが機能していることも確認できます。Pod IP アドレスリストを取得し、直接テストできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .items}}{{.status.podIP}}{{&#34;\n&#34;}}{{end}}&#39;</span>
</code></pre></div><pre><code class=language-none data-lang=none>10.244.0.5
10.244.0.6
10.244.0.7
</code></pre><p>このウォークスルーに使用されるサンプルコンテナは、ポート9376でHTTPを介して独自のホスト名を提供するだけですが、独自のアプリをデバッグする場合は、Podがリッスンしているポート番号を使用する必要があります。</p>
<p>Pod内から実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> ep in 10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376; <span style=color:#a2f;font-weight:700>do</span>
    wget -qO- <span style=color:#b8860b>$ep</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><p>次のように表示されます。</p>
<pre><code>hostnames-632524106-bbpiw
hostnames-632524106-ly40y
hostnames-632524106-tlaok
</code></pre><p>この時点で期待通りの応答が得られない場合、Podが正常でないか、想定しているポートでリッスンしていない可能性があります。なにが起きているかを確認するために<code>kubectl logs</code>が役立ちます。Podに直接に入りデバッグする場合は<code>kubectl exec</code>が必要になります。</p>
<p>これまでにすべての計画が完了していると想定すると、Serviceが機能しない理由を調査することができます。</p>
<h2 id=serviceは存在するか>Serviceは存在するか？</h2>
<p>賢明な読者は、Serviceをまだ実際に作成していないことにお気付きかと思いますが、これは意図的です。これは時々忘れられるステップであり、最初に確認すべきことです。</p>
<p>存在しないServiceにアクセスしようとするとどうなるでしょうか？このServiceを名前で利用する別のPodがあると仮定すると、次のような結果が得られます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget -O- hostnames
</code></pre></div><pre><code class=language-none data-lang=none>Resolving hostnames (hostnames)... failed: Name or service not known.
wget: unable to resolve host address 'hostnames'
</code></pre><p>最初に確認するのは、そのServiceが実際に存在するかどうかです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc hostnames
</code></pre></div><pre><code class=language-none data-lang=none>No resources found.
Error from server (NotFound): services &quot;hostnames&quot; not found
</code></pre><p>Serviceを作成しましょう。前と同様に、これはウォークスルー用です。ご自身のServiceの詳細を使用することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment hostnames --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>9376</span>
</code></pre></div><pre><code class=language-none data-lang=none>service/hostnames exposed
</code></pre><p>そして、念のため内容を確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME        TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
hostnames   ClusterIP   10.0.1.175   &lt;none&gt;        80/TCP    5s
</code></pre><p>これで、Serviceが存在することがわかりました。</p>
<p>前と同様に、これは次のようなYAMLでServiceを開始した場合と同じです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></code></pre></div><p>構成の全範囲をハイライトするため、ここで作成したServiceはPodとは異なるポート番号を使用します。多くの実際のServiceでは、これらのポートは同じになる場合があります。</p>
<h2 id=サービスはdns名によって機能しているか>サービスはDNS名によって機能しているか？</h2>
<p>クライアントがサービスを使用する最も一般的な方法の1つは、DNS名を使用することです。同じNamespaceのPodから次のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre><p>これが失敗した場合、おそらくPodとServiceが異なるNamespaceにあるため、ネームスペースで修飾された名前を試してください。(Podの中からもう一度)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames.default
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre><p>これが機能する場合、クロスネームスペース名を使用するようにアプリケーションを調整するか、同じNamespaceでアプリとServiceを実行する必要があります。これでも失敗する場合は、完全修飾名を試してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default.svc.cluster.local
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames.default.svc.cluster.local
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre><p>ここでのサフィックス"default.svc.cluster.local"に注意してください。"default"は、操作しているNamespaceです。"svc"は、これがServiceであることを示します。"cluster.local"はクラスタードメインであり、あなたのクラスターでは異なる場合があります。</p>
<p>クラスター内のノードからも試すこともできます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 10.0.0.10はクラスターのDNSサービスのIPであり、あなたのクラスターでは異なるかもしれません。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default.svc.cluster.local 10.0.0.10
</code></pre></div><pre><code class=language-none data-lang=none>Server:         10.0.0.10
Address:        10.0.0.10#53

Name:   hostnames.default.svc.cluster.local
Address: 10.0.1.175
</code></pre><p>完全修飾名では検索できるのに、相対名ではできない場合、Podの<code>/etc/resolv.conf</code>ファイルが正しいことを確認する必要があります。Pod内から実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /etc/resolv.conf
</code></pre></div><p>次のように表示されます。</p>
<pre><code>nameserver 10.0.0.10
search default.svc.cluster.local svc.cluster.local cluster.local example.com
options ndots:5
</code></pre><p>nameserver行はクラスターのDNS Serviceを示さなければなりません。これは、<code>--cluster-dns</code>フラグで<code>kubelet</code>に渡されます。</p>
<p><code>search</code>行には、<code>Service</code>名を見つけるための適切なサフィックスを含める必要があります。この場合、ローカルの<code>Namespace</code>で<code>Service</code>を見つけるためのサフィックス(<code>default.svc.cluster.local</code>)、すべての<code>Namespaces</code>で<code>Service</code>を見つけるためのサフィックス(<code>svc.cluster.local</code>)、およびクラスターのサフィックス(<code>cluster.local</code>)です。インストール方法によっては、その後に追加のレコードがある場合があります(合計6つまで)。クラスターのサフィックスは、<code>--cluster-domain</code>フラグを使用して<code>kubelet</code>に渡されます。このドキュメントではそれが"cluster.local"であると仮定していますが、あなたのクラスターでは異なる場合があります。その場合は、上記のすべてのコマンドでクラスターのサフィックスを変更する必要があります。</p>
<p><code>options</code>行では、DNSクライアントライブラリーが検索パスをまったく考慮しないように<code>ndots</code>を十分に高く設定する必要があります。Kubernetesはデフォルトでこれを5に設定します。これは、生成されるすべてのDNS名をカバーするのに十分な大きさです。</p>
<h3 id=does-any-service-exist-in-dns>DNS名で機能するServiceはあるか？</h3>
<p>上記がまだ失敗する場合、DNSルックアップがServiceに対して機能していません。一歩離れて、他の何が機能していないかを確認しましょう。KubernetesマスターのServiceは常に機能するはずです。Pod内から実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup kubernetes.default
</code></pre></div><pre><code class=language-none data-lang=none>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      kubernetes.default
Address 1: 10.0.0.1 kubernetes.default.svc.cluster.local
</code></pre><p>これが失敗する場合は、このドキュメントの<a href=#is-the-kube-proxy-working>kube-proxy</a>セクションを参照するか、このドキュメントの先頭に戻って最初からやり直してください。ただし、あなた自身のServiceをデバッグするのではなく、DNSサービスをデバッグします。</p>
<h2 id=serviceはipでは機能するか>ServiceはIPでは機能するか？</h2>
<p>DNSサービスが正しく動作できると仮定すると、次にテストするのはIPによってServiceが動作しているかどうかです。上述の<code>kubectl get</code>で確認できるIPに、クラスター内のPodからアクセスします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#a2f;font-weight:700>$(</span>seq <span style=color:#666>1</span> 3<span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
    wget -qO- 10.0.1.175:80
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><p>次のように表示されます。</p>
<pre><code>hostnames-0uton
hostnames-bvc05
hostnames-yp2kp
</code></pre><p>Serviceが機能している場合は、正しい応答が得られるはずです。そうでない場合、おかしい可能性のあるものがいくつかあるため、続けましょう。</p>
<h2 id=serviceは正しく定義されているか>Serviceは正しく定義されているか？</h2>
<p>馬鹿げているように聞こえるかもしれませんが、Serviceが正しく定義されPodのポートとマッチすることを二度、三度と確認すべきです。Serviceを読み返して確認しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service hostnames -o json
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Service&#34;</span>,
    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;428c8b6c-24bc-11e5-936d-42010af0a9bc&#34;</span>,
        <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>: <span style=color:#b44>&#34;347189&#34;</span>,
        <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>: <span style=color:#b44>&#34;2015-07-07T15:24:29Z&#34;</span>,
        <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;app&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>
        }
    },
    <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;ports&#34;</span>: [
            {
                <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
                <span style=color:green;font-weight:700>&#34;protocol&#34;</span>: <span style=color:#b44>&#34;TCP&#34;</span>,
                <span style=color:green;font-weight:700>&#34;port&#34;</span>: <span style=color:#666>80</span>,
                <span style=color:green;font-weight:700>&#34;targetPort&#34;</span>: <span style=color:#666>9376</span>,
                <span style=color:green;font-weight:700>&#34;nodePort&#34;</span>: <span style=color:#666>0</span>
            }
        ],
        <span style=color:green;font-weight:700>&#34;selector&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;app&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>
        },
        <span style=color:green;font-weight:700>&#34;clusterIP&#34;</span>: <span style=color:#b44>&#34;10.0.1.175&#34;</span>,
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;ClusterIP&#34;</span>,
        <span style=color:green;font-weight:700>&#34;sessionAffinity&#34;</span>: <span style=color:#b44>&#34;None&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;loadBalancer&#34;</span>: {}
    }
}
</code></pre></div><ul>
<li>アクセスしようとしているServiceポートは<code>spec.ports[]</code>のリストのなかに定義されていますか？</li>
<li><code>targetPort</code>はPodに対して適切ですか(いくつかのPodはServiceとは異なるポートを使用します)？</li>
<li><code>targetPort</code>を数値で定義しようとしている場合、それは数値(9376)、文字列"9376"のどちらですか？</li>
<li><code>targetPort</code>を名前で定義しようとしている場合、Podは同じ名前でポートを公開していますか？</li>
<li>ポートの<code>protocol</code>はPodに適切ですか？</li>
</ul>
<h2 id=serviceにendpointsがあるか>ServiceにEndpointsがあるか？</h2>
<p>ここまで来たということは、Serviceは正しく定義され、DNSによって名前解決できることが確認できているでしょう。ここでは、実行したPodがServiceによって実際に選択されていることを確認しましょう。</p>
<p>以前に、Podが実行されていることを確認しました。再確認しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME                        READY     STATUS    RESTARTS   AGE
hostnames-632524106-bbpiw   1/1       Running   0          1h
hostnames-632524106-ly40y   1/1       Running   0          1h
hostnames-632524106-tlaok   1/1       Running   0          1h
</code></pre><p><code>-l app=hostnames</code>引数はラベルセレクターで、ちょうど私たちの<code>Service</code>に定義されているものと同じです。</p>
<p>"AGE"列は、これらのPodが約1時間前のものであることを示しており、それらが正常に実行され、クラッシュしていないことを意味します。</p>
<p>"RESTARTS"列は、これらのポッドが頻繁にクラッシュしたり、再起動されていないことを示しています。頻繁に再起動すると、断続的な接続性の問題が発生する可能性があります。再起動回数が多い場合は、<a href=/ja/docs/tasks/debug-application-cluster/debug-pod-replication-controller/#pod%E3%81%AE%E3%83%87%E3%83%90%E3%83%83%E3%82%B0>ポッドをデバッグする</a>を参照してください。</p>
<p>Kubernetesシステム内には、すべてのServiceのセレクターを評価し、結果をEndpointsオブジェクトに保存するコントロールループがあります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get endpoints hostnames

NAME        ENDPOINTS
hostnames   10.244.0.5:9376,10.244.0.6:9376,10.244.0.7:9376
</code></pre></div><p>これにより、EndpointsコントローラーがServiceの正しいPodを見つけていることを確認できます。<code>ENDPOINTS</code>列が<code>&lt;none></code>の場合、Serviceの<code>spec.selector</code>フィールドが実際にPodの<code>metadata.labels</code>値を選択していることを確認する必要があります。よくある間違いは、タイプミスやその他のエラー、たとえばDeployment作成にも<code>kubectl run</code>が使われた1.18以前のバージョンのように、Serviceが<code>app=hostnames</code>を選択しているのにDeploymentが<code>run=hostnames</code>を指定していることです。</p>
<h2 id=podは機能しているか>Podは機能しているか？</h2>
<p>この時点で、Serviceが存在し、Podを選択していることがわかります。このウォークスルーの最初に、Pod自体を確認しました。Podが実際に機能していることを確認しましょう。Serviceメカニズムをバイパスして、上記EndpointsにリストされているPodに直接アクセスすることができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> これらのコマンドは、Serviceポート(80)ではなく、Podポート(9376)を使用します。
</div>
<p>Pod内から実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> ep in 10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376; <span style=color:#a2f;font-weight:700>do</span>
    wget -qO- <span style=color:#b8860b>$ep</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><p>次のように表示されます。</p>
<pre><code>hostnames-632524106-bbpiw
hostnames-632524106-ly40y
hostnames-632524106-tlaok
</code></pre><p>Endpointsリスト内の各Podは、それぞれの自身のホスト名を返すはずです。そうならない(または、あなた自身のPodの正しい振る舞いにならない)場合は、そこで何が起こっているのかを調査する必要があります。</p>
<h2 id=is-the-kube-proxy-working>kube-proxyは機能しているか？</h2>
<p>ここに到達したのなら、Serviceは実行され、Endpointsがあり、Podが実際にサービスを提供しています。この時点で、Serviceのプロキシーメカニズム全体が疑わしいです。ひとつひとつ確認しましょう。</p>
<p>Serviceのデフォルト実装、およびほとんどのクラスターで使用されるものは、kube-proxyです。kube-proxyはそれぞれのノードで実行され、Serviceの抽象化を提供するための小さなメカニズムセットの1つを構成するプログラムです。クラスターがkube-proxyを使用しない場合、以下のセクションは適用されず、使用しているServiceの実装を調査する必要があります。</p>
<h3 id=kube-proxyは実行されているか>kube-proxyは実行されているか？</h3>
<p><code>kube-proxy</code>がノード上で実行されていることを確認しましょう。ノードで実行されていれば、以下のような結果が得られるはずです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps auxw | grep kube-proxy
</code></pre></div><pre><code class=language-none data-lang=none> root  4194  0.4  0.1 101864 17696 ?    Sl Jul04  25:43 /usr/local/bin/kube-proxy --master=https://kubernetes-master --kubeconfig=/var/lib/kube-proxy/kubeconfig --v=2
</code></pre><p>次に、マスターとの接続など、明らかな失敗をしていないことを確認します。これを行うには、ログを確認する必要があります。ログへのアクセス方法は、ノードのOSに依存します。一部のOSでは/var/log/kube-proxy.logのようなファイルですが、他のOSでは<code>journalctl</code>を使用してログにアクセスします。次のように表示されます。</p>
<pre><code class=language-none data-lang=none>I1027 22:14:53.995134    5063 server.go:200] Running in resource-only container &quot;/kube-proxy&quot;
I1027 22:14:53.998163    5063 server.go:247] Using iptables Proxier.
I1027 22:14:53.999055    5063 server.go:255] Tearing down userspace rules. Errors here are acceptable.
I1027 22:14:54.038140    5063 proxier.go:352] Setting endpoints for &quot;kube-system/kube-dns:dns-tcp&quot; to [10.244.1.3:53]
I1027 22:14:54.038164    5063 proxier.go:352] Setting endpoints for &quot;kube-system/kube-dns:dns&quot; to [10.244.1.3:53]
I1027 22:14:54.038209    5063 proxier.go:352] Setting endpoints for &quot;default/kubernetes:https&quot; to [10.240.0.2:443]
I1027 22:14:54.038238    5063 proxier.go:429] Not syncing iptables until Services and Endpoints have been received from master
I1027 22:14:54.040048    5063 proxier.go:294] Adding new service &quot;default/kubernetes:https&quot; at 10.0.0.1:443/TCP
I1027 22:14:54.040154    5063 proxier.go:294] Adding new service &quot;kube-system/kube-dns:dns&quot; at 10.0.0.10:53/UDP
I1027 22:14:54.040223    5063 proxier.go:294] Adding new service &quot;kube-system/kube-dns:dns-tcp&quot; at 10.0.0.10:53/TCP
</code></pre><p>マスターに接続できないことに関するエラーメッセージが表示された場合、ノードの設定とインストール手順をダブルチェックする必要があります。</p>
<p><code>kube-proxy</code>が正しく実行できない理由の可能性の1つは、必須の<code>conntrack</code>バイナリが見つからないことです。これは、例えばKubernetesをスクラッチからインストールするなど、クラスターのインストール方法に依存して、一部のLinuxシステムで発生する場合があります。これが該当する場合は、<code>conntrack</code>パッケージを手動でインストール(例: Ubuntuでは<code>sudo apt install conntrack</code>)する必要があり、その後に再試行する必要があります。</p>
<p>kube-proxyは、いくつかのモードのいずれかで実行できます。上記のログの<code>Using iptables Proxier</code>という行は、kube-proxyが「iptables」モードで実行されていることを示しています。最も一般的な他のモードは「ipvs」です。古い「ユーザースペース」モードは、主にこれらに置き換えられました。</p>
<h4 id=iptables-mode>Iptables mode</h4>
<p>「iptables」モードでは、ノードに次のようなものが表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>iptables-save | grep hostnames
</code></pre></div><pre><code class=language-none data-lang=none>-A KUBE-SEP-57KPRZ3JQVENLNBR -s 10.244.3.6/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-57KPRZ3JQVENLNBR -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.3.6:9376
-A KUBE-SEP-WNBA2IHDGP2BOBGZ -s 10.244.1.7/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-WNBA2IHDGP2BOBGZ -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.1.7:9376
-A KUBE-SEP-X3P2623AGDH6CDF3 -s 10.244.2.3/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-X3P2623AGDH6CDF3 -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.2.3:9376
-A KUBE-SERVICES -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames: cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-NWV5X2332I4OT4T3
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-WNBA2IHDGP2BOBGZ
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-X3P2623AGDH6CDF3
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -j KUBE-SEP-57KPRZ3JQVENLNBR
</code></pre><p>各サービスのポートごとに、<code>KUBE-SERVICES</code>に1つのルールと1つの<code>KUBE-SVC- &lt;hash></code>チェーンが必要です。Podエンドポイントごとに、その<code>KUBE-SVC- &lt;hash></code>に少数のルールがあり、少数のルールが含まれる1つの<code>KUBE-SEP- &lt;hash></code>チェーンがあるはずです。正確なルールは、正確な構成(NodePortとLoadBalancerを含む)に基づいて異なります。</p>
<h4 id=ipvs-mode>IPVS mode</h4>
<p>「ipvs」モードでは、ノードに次のようなものが表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ipvsadm -ln
</code></pre></div><pre><code class=language-none data-lang=none>Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
...
TCP  10.0.1.175:80 rr
  -&gt; 10.244.0.5:9376               Masq    1      0          0
  -&gt; 10.244.0.6:9376               Masq    1      0          0
  -&gt; 10.244.0.7:9376               Masq    1      0          0
...
</code></pre><p>各Serviceの各ポートに加えて、NodePort、External IP、およびLoad Balancer IPに対して、kube-proxyは仮想サーバーを作成します。Pod endpointごとに、対応する実サーバーが作成されます。この例では、サービスhostnames(<code>10.0.1.175:80</code>)は3つのendpoints(<code>10.244.0.5:9376</code>、<code>10.244.0.6:9376</code>、<code>10.244.0.7:9376</code>)を持っています。</p>
<p>IPVSプロキシーは、各Serviceアドレス(Cluster IP、External IP、NodePort IP、Load Balancer IPなど)毎の仮想サーバーと、Serviceのエンドポイントが存在する場合に対応する実サーバーを作成します。この例では、hostnames Service(<code>10.0.1.175:80</code>)は3つのエンドポイント(<code>10.244.0.5:9376</code>、<code>10.244.0.6:9376</code>、<code>10.244.0.7:9376</code>)を持ち、上と似た結果が得られるはずです。</p>
<h4 id=userspace-mode>Userspace mode</h4>
<p>まれに、「userspace」モードを使用している場合があります。</p>
<p>ノードから実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>iptables-save | grep hostnames
</code></pre></div><pre><code class=language-none data-lang=none>-A KUBE-PORTALS-CONTAINER -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames:default&quot; -m tcp --dport 80 -j REDIRECT --to-ports 48577
-A KUBE-PORTALS-HOST -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames:default&quot; -m tcp --dport 80 -j DNAT --to-destination 10.240.115.247:48577
</code></pre><p>サービスの各ポートには2つのルールが必要です(この例では1つだけ)-「KUBE-PORTALS-CONTAINER」と「KUBE-PORTALS-HOST」です。</p>
<p>「userspace」モードを使用する必要はほとんどないので、ここでこれ以上時間を費やすことはありません。</p>
<h3 id=kube-proxyはプロキシしているか>kube-proxyはプロキシしているか？</h3>
<p>上記のいずれかが発生したと想定して、いずれかのノードからIPでサービスにアクセスをしています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl 10.0.1.175:80
</code></pre></div><pre><code class=language-none data-lang=none>hostnames-632524106-bbpiw
</code></pre><p>もしこれが失敗し、あなたがuserspaceプロキシーを使用している場合、プロキシーへの直接アクセスを試してみてください。もしiptablesプロキシーを使用している場合、このセクションはスキップしてください。</p>
<p>上記の<code>iptables-save</code>の出力を振り返り、<code>kube-proxy</code>がServiceに使用しているポート番号を抽出します。上記の例では"48577"です。このポートに接続してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl localhost:48577
</code></pre></div><pre><code class=language-none data-lang=none>hostnames-632524106-tlaok
</code></pre><p>もしまだ失敗する場合は、<code>kube-proxy</code>ログで次のような特定の行を探してください。</p>
<pre><code class=language-none data-lang=none>Setting endpoints for default/hostnames:default to [10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376]
</code></pre><p>これらが表示されない場合は、<code>-v</code>フラグを4に設定して<code>kube-proxy</code>を再起動してから、再度ログを確認してください。</p>
<h3 id=a-pod-fails-to-reach-itself-via-the-service-ip>エッジケース: PodがService IP経由で自身に到達できない</h3>
<p>これはありそうに聞こえないかもしれませんが、実際には起こり、動作するはずです。これはネットワークが"hairpin"トラフィック用に適切に設定されていない場合、通常は<code>kube-proxy</code>が<code>iptables</code>モードで実行され、Podがブリッジネットワークに接続されている場合に発生します。<code>Kubelet</code>は<code>hairpin-mode</code><a href=/docs/reference/command-line-tools-reference/kubelet/>フラグ</a>を公開します。これにより、Serviceのエンドポイントが自身のServiceのVIPにアクセスしようとした場合に、自身への負荷分散を可能にします。<code>hairpin-mode</code>フラグは<code>hairpin-veth</code>または<code>promiscuous-bridge</code>に設定する必要があります。</p>
<p>この問題をトラブルシューティングする一般的な手順は次のとおりです。</p>
<ul>
<li><code>hairpin-mode</code>が<code>hairpin-veth</code>または<code>promiscuous-bridge</code>に設定されていることを確認します。次のような表示がされるはずです。この例では、<code>hairpin-mode</code>は<code>promiscuous-bridge</code>に設定されています。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps auxw | grep kubelet
</code></pre></div><pre><code class=language-none data-lang=none>root      3392  1.1  0.8 186804 65208 ?        Sl   00:51  11:11 /usr/local/bin/kubelet --enable-debugging-handlers=true --config=/etc/kubernetes/manifests --allow-privileged=True --v=4 --cluster-dns=10.0.0.10 --cluster-domain=cluster.local --configure-cbr0=true --cgroup-root=/ --system-cgroups=/system --hairpin-mode=promiscuous-bridge --runtime-cgroups=/docker-daemon --kubelet-cgroups=/kubelet --babysit-daemons=true --max-pods=110 --serialize-image-pulls=false --outofdisk-transition-frequency=0
</code></pre><ul>
<li>実際に使われている<code>hairpin-mode</code>を確認します。これを行うには、kubeletログを確認する必要があります。ログへのアクセス方法は、ノードのOSによって異なります。一部のOSでは/var/log/kubelet.logなどのファイルですが、他のOSでは<code>journalctl</code>を使用してログにアクセスします。互換性のために、実際に使われている<code>hairpin-mode</code>が<code>--hairpin-mode</code>フラグと一致しない場合があることに注意してください。kubelet.logにキーワード<code>hairpin</code>を含むログ行があるかどうかを確認してください。実際に使われている<code>hairpin-mode</code>を示す以下のようなログ行があるはずです。</li>
</ul>
<pre><code class=language-none data-lang=none>I0629 00:51:43.648698    3252 kubelet.go:380] Hairpin mode set to &quot;promiscuous-bridge&quot;
</code></pre><ul>
<li>実際に使われている<code>hairpin-mode</code>が<code>hairpin-veth</code>の場合、<code>Kubelet</code>にノードの<code>/sys</code>で操作する権限があることを確認します。すべてが正常に機能している場合、次のようなものが表示されます。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> intf in /sys/devices/virtual/net/cbr0/brif/*; <span style=color:#a2f;font-weight:700>do</span> cat <span style=color:#b8860b>$intf</span>/hairpin_mode; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><pre><code class=language-none data-lang=none>1
1
1
1
</code></pre><p>実際に使われている<code>hairpin-mode</code>が<code>promiscuous-bridge</code>の場合、<code>Kubelet</code>にノード上のLinuxブリッジを操作する権限があることを確認してください。<code>cbr0</code>ブリッジが使用され適切に構成されている場合、以下が表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ifconfig cbr0 |grep PROMISC
</code></pre></div><pre><code class=language-none data-lang=none>UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1460  Metric:1
</code></pre><ul>
<li>上記のいずれも解決しない場合、助けを求めてください。</li>
</ul>
<h2 id=助けを求める>助けを求める</h2>
<p>ここまでたどり着いたということは、とてもおかしなことが起こっています。Serviceは実行中で、Endpointsがあり、Podは実際にサービスを提供しています。DNSは動作していて、<code>kube-proxy</code>も誤動作していないようです。それでも、あなたのServiceは機能していません。おそらく私たちにお知らせ頂いた方がよいでしょう。調査をお手伝いします！</p>
<p><a href=/docs/tasks/debug-application-cluster/troubleshooting/#slack>Slack</a>、<a href=https://discuss.kubernetes.io>Forum</a>または<a href=https://github.com/kubernetes/kubernetes>GitHub</a>でお問い合わせください。</p>
<h2 id=次の項目>次の項目</h2>
<p>詳細については、<a href=/docs/tasks/debug-application-cluster/troubleshooting/>トラブルシューティングドキュメント</a>をご覧ください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a070b1250ee142402d492b505a56ca83>5 - StatefulSetのデバッグ</h1>
<p>このタスクでは、StatefulSetをデバッグする方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>Kubernetesクラスターが必要です。また、kubectlコマンドラインツールがクラスターと通信するように設定されている必要があります。</li>
<li>調べたいStatefulSetを実行しておきましょう。</li>
</ul>
<h2 id=statefulsetのデバッグ>StatefulSetのデバッグ</h2>
<p>StatefulSetに属し、ラベル<code>app=myapp</code>が設定されているすべてのPodを一覧表示するには、以下のコマンドを利用できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp
</code></pre></div><p>Podが長期間<code>Unknown</code>または<code>Terminating</code>の状態になっていることがわかった場合は、それらを処理する方法について<a href=/ja/docs/tasks/run-application/delete-stateful-set/>StatefulSetの削除</a>タスクを参照してください。
<a href=/docs/tasks/debug-application-cluster/debug-pod-replication-controller/>Podのデバッグ</a>ガイドを使用して、StatefulSet内の個々のPodをデバッグできます。</p>
<h2 id=次の項目>次の項目</h2>
<p><a href=/ja/docs/tasks/debug-application-cluster/debug-init-containers/>Initコンテナのデバッグ</a>の詳細</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9713ac27b6d9e3034033200d968221f2>6 - 実行中のコンテナへのシェルを取得する</h1>
<p>このページは<code>kubectl exec</code>を使用して実行中のコンテナへのシェルを取得する方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=コンテナへのシェルの取得>コンテナへのシェルの取得</h2>
<p>このエクササイズでは、1つのコンテナを持つPodを作成します。
コンテナはnginxのイメージを実行します。以下がそのPodの設定ファイルです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/shell-demo.yaml download=application/shell-demo.yaml><code>application/shell-demo.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-shell-demo-yaml')" title="Copy application/shell-demo.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-shell-demo-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/shell-demo.yaml
</code></pre></div><p>コンテナが実行中であることを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod shell-demo
</code></pre></div><p>実行中のコンテナへのシェルを取得します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> --stdin --tty shell-demo -- /bin/bash
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ダブルダッシュの記号 <code>--</code> はコマンドに渡す引数とkubectlの引数を分離します。
</div>
<p>シェル内で、ルートディレクトリーのファイル一覧を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドをコンテナ内で実行します</span>
ls /
</code></pre></div><p>シェル内で、他のコマンドを試しましょう。以下がいくつかの例です:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># これらのサンプルコマンドをコンテナ内で実行することができます</span>
ls /
cat /proc/mounts
cat /proc/1/maps
apt-get update
apt-get install -y tcpdump
tcpdump
apt-get install -y lsof
lsof
apt-get install -y procps
ps aux
ps aux | grep nginx
</code></pre></div><h2 id=nginxのルートページへの書き込み>nginxのルートページへの書き込み</h2>
<p>Podの設定ファイルを再度確認します。Podは<code>emptyDir</code>ボリュームを持ち、
コンテナは<code>/usr/share/nginx/html</code>ボリュームをマウントします。</p>
<p>シェル内で、<code>/usr/share/nginx/html</code>ディレクトリに<code>index.html</code>を作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドをコンテナ内で実行します</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;Hello shell demo&#39;</span> &gt; /usr/share/nginx/html/index.html
</code></pre></div><p>シェル内で、nginxサーバーにGETリクエストを送信します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># これらのコマンドをコンテナ内のシェルで実行します</span>
apt-get update
apt-get install curl
curl http://localhost/
</code></pre></div><p>出力に<code>index.html</code>ファイルに書き込んだ文字列が表示されます:</p>
<pre><code>Hello shell demo
</code></pre><p>シェルを終了する場合、<code>exit</code>を入力します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>exit</span> <span style=color:#080;font-style:italic># コンテナ内のシェルを終了する</span>
</code></pre></div><h2 id=コンテナ内での各コマンドの実行>コンテナ内での各コマンドの実行</h2>
<p>シェルではない通常のコマンドウインドウ内で、実行中のコンテナの環境変数の一覧を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> shell-demo env
</code></pre></div><p>他のコマンドを試します。以下がいくつかの例です:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> shell-demo -- ps aux
kubectl <span style=color:#a2f>exec</span> shell-demo -- ls /
kubectl <span style=color:#a2f>exec</span> shell-demo -- cat /proc/1/mounts
</code></pre></div>
<h2 id=podが1つ以上のコンテナを持つ場合にシェルを開く>Podが1つ以上のコンテナを持つ場合にシェルを開く</h2>
<p>Podが1つ以上のコンテナを持つ場合、<code>--container</code>か<code>-c</code>を使用して、<code>kubectl exec</code>コマンド内でコンテナを指定します。
例えば、my-podという名前のPodがあり、そのPodが <em>main-app</em> と <em>helper-app</em> という2つのコンテナを持つとします。
以下のコマンドは <em>main-app</em> のコンテナへのシェルを開きます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -i -t my-pod --container main-app -- /bin/bash
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ショートオプションの<code>-i</code>と<code>-t</code>は、ロングオプションの<code>--stdin</code>と<code>--tty</code>と同様です。
</div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>について読む</li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>