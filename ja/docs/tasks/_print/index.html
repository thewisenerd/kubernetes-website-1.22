<!doctype html><html lang=ja class=no-js>
<head>
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JPP6RFM2BP"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-JPP6RFM2BP')</script>
<link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/>
<link rel=alternate hreflang=zh href=https://kubernetes.io/zh/docs/tasks/>
<link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tasks/>
<link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/>
<link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/>
<link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/>
<link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/tasks/>
<link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/>
<link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/tasks/>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=generator content="Hugo 0.87.0">
<link rel=canonical type=text/html href=https://kubernetes.io/ja/docs/tasks/>
<link rel="shortcut icon" type=image/png href=/images/favicon.png>
<link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180>
<link rel=manifest href=/manifest.webmanifest>
<link rel=apple-touch-icon href=/images/kubernetes-192x192.png>
<title>タスク | Kubernetes</title><meta property="og:title" content="タスク">
<meta property="og:description" content="プロダクショングレードのコンテナ管理基盤">
<meta property="og:type" content="website">
<meta property="og:url" content="https://kubernetes.io/ja/docs/tasks/"><meta property="og:site_name" content="Kubernetes">
<meta itemprop=name content="タスク">
<meta itemprop=description content="プロダクショングレードのコンテナ管理基盤"><meta name=twitter:card content="summary">
<meta name=twitter:title content="タスク">
<meta name=twitter:description content="プロダクショングレードのコンテナ管理基盤">
<link href=/scss/main.css rel=stylesheet>
<script src=/js/jquery-3.3.1.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png"}</script>
<meta name=theme-color content="#326ce5">
<link rel=stylesheet href=/css/feature-states.css>
<meta name=description content="Kubernetesドキュメントのこのセクションには、個々のタスクの実行方法を示すページが含まれています。タスクページは、通常、短い手順を実行することにより、1つのことを行う方法を示します。
タスクページを作成したい場合は、ドキュメントのPull Requestの作成を参照してください。">
<meta property="og:description" content="Kubernetesドキュメントのこのセクションには、個々のタスクの実行方法を示すページが含まれています。タスクページは、通常、短い手順を実行することにより、1つのことを行う方法を示します。
タスクページを作成したい場合は、ドキュメントのPull Requestの作成を参照してください。">
<meta name=twitter:description content="Kubernetesドキュメントのこのセクションには、個々のタスクの実行方法を示すページが含まれています。タスクページは、通常、短い手順を実行することにより、1つのことを行う方法を示します。
タスクページを作成したい場合は、ドキュメントのPull Requestの作成を参照してください。">
<meta property="og:url" content="https://kubernetes.io/ja/docs/tasks/">
<meta property="og:title" content="タスク">
<meta name=twitter:title content="タスク">
<meta name=twitter:image content="https://kubernetes.io/images/favicon.png">
<meta name=twitter:image:alt content="Kubernetes">
<meta property="og:image" content="/images/kubernetes-horizontal-color.png">
<meta property="og:type" content="article">
<script src=/js/script.js></script>
</head>
<body class=td-section>
<header>
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary>
<a class=navbar-brand href=/ja/></a>
<div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar>
<ul class="navbar-nav mt-2 mt-lg-0">
<li class="nav-item mr-2 mb-lg-0">
<a class="nav-link active" href=/ja/docs/>ドキュメント</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/training/>トレーニング</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/partners/>パートナー</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/community/>コミュニティ</span></a>
</li>
<li class="nav-item mr-2 mb-lg-0">
<a class=nav-link href=/ja/case-studies/>ケーススタディ</span></a>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
バージョン
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ja/docs/tasks/>v1.26</a>
<a class=dropdown-item href=https://v1-25.docs.kubernetes.io/ja/docs/tasks/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ja/docs/tasks/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ja/docs/tasks/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ja/docs/tasks/>v1.22</a>
</div>
</li>
<li class="nav-item dropdown">
<a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>
日本語 Japanese
</a>
<div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink>
<a class=dropdown-item href=/docs/tasks/>English</a>
<a class=dropdown-item href=/zh/docs/tasks/>中文 Chinese</a>
<a class=dropdown-item href=/ko/docs/tasks/>한국어 Korean</a>
<a class=dropdown-item href=/fr/docs/tasks/>Français</a>
<a class=dropdown-item href=/de/docs/tasks/>Deutsch</a>
<a class=dropdown-item href=/es/docs/tasks/>Español</a>
<a class=dropdown-item href=/pt-br/docs/tasks/>Português</a>
<a class=dropdown-item href=/id/docs/tasks/>Bahasa Indonesia</a>
<a class=dropdown-item href=/pl/docs/tasks/>Polski</a>
</div>
</li>
</ul>
</div>
<button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button>
</nav>
</header>
<div class="container-fluid td-outer">
<div class=td-main>
<div class="row flex-xl-nowrap">
<div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
</div>
<div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
</div>
<main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main>
<div class=td-content>
<div class="pageinfo pageinfo-primary d-print-none">
<p>
これは、このセクションの複数ページの印刷可能なビューです。
<a href=# onclick="return print(),!1">印刷するには、ここをクリックしてください</a>.
</p><p>
<a href=/ja/docs/tasks/>このページの通常のビューに戻る</a>.
</p>
</div>
<h1 class=title>タスク</h1>
<ul>
<li>1: <a href=#pg-57bf66f59d9a642b82eebeabbc66470b>ツールのインストール</a></li>
<ul>
<li>1.1: <a href=#pg-bbdc530b292ab4074d1dfe69feafb3e7>kubectlのインストールおよびセットアップ</a></li>
</ul>
<li>2: <a href=#pg-f5da33b976758a9183018c421eb83f58>Podとコンテナの設定</a></li>
<ul>
<li>2.1: <a href=#pg-e6dd9300cf3a955f7cdfe77fb5d15292>コンテナおよびPodへのメモリーリソースの割り当て</a></li>
<li>2.2: <a href=#pg-8555af270ae7122cc0464bab3f5d1609>コンテナおよびPodへのCPUリソースの割り当て</a></li>
<li>2.3: <a href=#pg-904cea8c8efd5c0d33adbfe579ec2dd2>PodにQuality of Serviceを設定する</a></li>
<li>2.4: <a href=#pg-4219ac6ab56a3b88d20305083d57d03c>拡張リソースをコンテナに割り当てる</a></li>
<li>2.5: <a href=#pg-484833fb880d1e179cc2965d15f84da5>ストレージにボリュームを使用するPodを構成する</a></li>
<li>2.6: <a href=#pg-4621938ba53c04a77f51b5938a583439>ストレージにProjectedボリュームを使用するようPodを設定する</a></li>
<li>2.7: <a href=#pg-eb54daf87df373096b5e830680194dfc>Liveness Probe、Readiness ProbeおよびStartup Probeを使用する</a></li>
<li>2.8: <a href=#pg-fc3f4777ae8ea685d2b54e175277ac01>Node Affinityを利用してPodをノードに割り当てる</a></li>
<li>2.9: <a href=#pg-bbc17480da6d051c696489654c64064a>Podをノードに割り当てる</a></li>
<li>2.10: <a href=#pg-efbc43486296f0439d1a89c12d944d94>コンテナライフサイクルイベントへのハンドラー紐付け</a></li>
<li>2.11: <a href=#pg-ed34e761c3dbd00fa79577fa78e30020>Podを構成してConfigMapを使用する</a></li>
<li>2.12: <a href=#pg-3d7b9cb24a647c36ba63f7a02ec49010>Pod内のコンテナ間でプロセス名前空間を共有する</a></li>
<li>2.13: <a href=#pg-42a59b878d4c58e5c6f4bb87483dda93>static Podを作成する</a></li>
</ul>
<li>3: <a href=#pg-34a810f1516ad9d99b2697e36e9b0d0f>クラスターの管理</a></li>
<ul>
<li>3.1: <a href=#pg-adb489b1ab985c9215657b0d4c6ae92b>Namespaceに対する最小および最大メモリー制約の構成</a></li>
<li>3.2: <a href=#pg-9133578f1e75663bb031e5a377ca896d>Windowsノードの追加</a></li>
<li>3.3: <a href=#pg-e805c7d8d4ad6195cb82dbbc843bfc29>Windowsノードのアップグレード</a></li>
<li>3.4: <a href=#pg-77351865caa548b0a06694b904dd881c>EndpointSliceの有効化</a></li>
<li>3.5: <a href=#pg-9ceed97f912df7289ed8872e290cfbad>KubernetesクラスターでNodeLocal DNSキャッシュを使用する</a></li>
<li>3.6: <a href=#pg-00733cc3747eb3f5fe1c9e0439262967>Serviceトポロジーを有効にする</a></li>
<li>3.7: <a href=#pg-ce4cd28c8feb9faa783e79b48af37961>クラウドコントローラーマネージャーの運用管理</a></li>
<li>3.8: <a href=#pg-9585dc0efb0450fd68728e7511754717>クラウドコントローラーマネージャーの開発</a></li>
<li>3.9: <a href=#pg-e1afcdac8d5e8458274b3c481c5ebcda>サービスディスカバリーにCoreDNSを使用する</a></li>
<li>3.10: <a href=#pg-a3790dfb57271d13517e549dffa805b9>ネットワークポリシーを宣言する</a></li>
<li>3.11: <a href=#pg-8060aed5bf1172fa62199a4c306a4cd1>ノードのトポロジー管理ポリシーを制御する</a></li>
<li>3.12: <a href=#pg-a8f6511197efcd7d0db80ade49620f9d>拡張リソースをNodeにアドバタイズする</a></li>
</ul>
<li>4: <a href=#pg-aa0731e8aa8e2f6cc9e3c1a5e9895863>Kubernetesオブジェクトの管理</a></li>
<ul>
</ul>
<li>5: <a href=#pg-94f49ece137035764368f22a98942872>Secretの管理</a></li>
<ul>
<li>5.1: <a href=#pg-0ed63ce3c9665aed7ff5a560ff1da843>kubectlを使用してSecretを管理する</a></li>
<li>5.2: <a href=#pg-e841cf91fd3566db1e86143ed7a9e13c>設定ファイルを使用してSecretを管理する</a></li>
<li>5.3: <a href=#pg-a0ff2e3ba8af5670d5dc3d94c4bd0a68>Kustomizeを使用してSecretを管理する</a></li>
</ul>
<li>6: <a href=#pg-866924fa095f897ede8dfdcab9e97942>アプリケーションへのデータ注入</a></li>
<ul>
<li>6.1: <a href=#pg-82c93897176489678232542102daea40>コンテナの環境変数の定義</a></li>
<li>6.2: <a href=#pg-66c0456fdbef5e5116dd606d1e6f73cc>環境変数によりコンテナにPod情報を共有する</a></li>
</ul>
<li>7: <a href=#pg-a78a5e7e765fd8c49c8f7c0d72499f72>アプリケーションの実行</a></li>
<ul>
<li>7.1: <a href=#pg-790ea02857492b3a822e981e93e3a98b>Deploymentを使用してステートレスアプリケーションを実行する</a></li>
<li>7.2: <a href=#pg-43398a6f5dc7ce19df59f5f4c2e7922d>単一レプリカのステートフルアプリケーションを実行する</a></li>
<li>7.3: <a href=#pg-95b3d561509c573e53bec2368264cf6a>レプリカを持つステートフルアプリケーションを実行する</a></li>
<li>7.4: <a href=#pg-7a9b5779e228083ba3fdeaf414fe704e>StatefulSetのスケール</a></li>
<li>7.5: <a href=#pg-c43537b0ee1da992ecb7488f87e6c934>StatefulSetの削除</a></li>
<li>7.6: <a href=#pg-f5f2f7a74377a9d45325c5253353fa8f>StatefulSet Podの強制削除</a></li>
<li>7.7: <a href=#pg-8138226ce9660ac8e3e82ff86fff8ad2>Horizontal Pod Autoscalerウォークスルー</a></li>
</ul>
<li>8: <a href=#pg-ca3bc4e31dfe46d5044a3b93eb804ee9>Jobの実行</a></li>
<ul>
<li>8.1: <a href=#pg-964bdff888520740e5e221695245678d>CronJobを使用して自動化タスクを実行する</a></li>
<li>8.2: <a href=#pg-9e63850014876afaebd1561f70bb8f6b>静的な処理の割り当てを使用した並列処理のためのインデックス付きJob</a></li>
</ul>
<li>9: <a href=#pg-b74b959f5a531003dd0653dfbfc2e88b>クラスター内アプリケーションへのアクセス</a></li>
<ul>
<li>9.1: <a href=#pg-777447042cd4e81df3fa5beb3357a485>Web UI (Dashboard)</a></li>
<li>9.2: <a href=#pg-5a233e14205d77fe1294917d2da6f876>複数のクラスターへのアクセスを設定する</a></li>
<li>9.3: <a href=#pg-312f29f850826b74618634cd877aa065>Serviceを利用したクラスター内のアプリケーションへのアクセス</a></li>
<li>9.4: <a href=#pg-f3dac629bea950fc026d920306f09fb4>Serviceを使用してフロントエンドをバックエンドに接続する</a></li>
<li>9.5: <a href=#pg-1839d8468a083839ed1cc8d18fe1142e>Minikube上でNGINX Ingressコントローラーを使用してIngressをセットアップする</a></li>
<li>9.6: <a href=#pg-48e8f306f919c5b81265e265a2b76ab4>クラスターで実行されているすべてのコンテナイメージを一覧表示する</a></li>
<li>9.7: <a href=#pg-7c319a9981586e5fbcfa21b392720650>共有ボリュームを使用して同じPod内のコンテナ間で通信する</a></li>
</ul>
<li>10: <a href=#pg-f6a755efe831d24956501e4bcd49ff96>監視、ログ、デバッグ</a></li>
<ul>
<li>10.1: <a href=#pg-06bb252f25983de12f635c806d180d30>Initコンテナのデバッグ</a></li>
<li>10.2: <a href=#pg-858517cd46a1b5a1fd2e650edd785cea>PodとReplicationControllerのデバッグ</a></li>
<li>10.3: <a href=#pg-ef360b1f8e65236251826db478cfcab3>Pod障害の原因を特定する</a></li>
<li>10.4: <a href=#pg-f79645981e310858111bd5673614cab6>Serviceのデバッグ</a></li>
<li>10.5: <a href=#pg-a070b1250ee142402d492b505a56ca83>StatefulSetのデバッグ</a></li>
<li>10.6: <a href=#pg-9713ac27b6d9e3034033200d968221f2>実行中のコンテナへのシェルを取得する</a></li>
</ul>
<li>11: <a href=#pg-d3c88a8663f58e9ec0bed73faff5b670>TLS</a></li>
<ul>
<li>11.1: <a href=#pg-1272b18ac0c008f6ffc2c62a29fa929f>Kubeletの証明書のローテーションを設定する</a></li>
</ul>
<li>12: <a href=#pg-5266308e17490aeee8b018316bf47e03>サービスカタログ</a></li>
<ul>
<li>12.1: <a href=#pg-f741b6fc36e27a6f79c1c3d02a40d8f9>Helmを使用したサービスカタログのインストール</a></li>
<li>12.2: <a href=#pg-d85a30635b5c3578487b9f6f214c07ea>SCを使用したサービスカタログのインストール</a></li>
</ul>
<li>13: <a href=#pg-a701e71f3b32dae474c63ae4c596c856>ネットワーク</a></li>
<ul>
<li>13.1: <a href=#pg-2edb5b02ea1e646c333c9fe4d5f02ff1>HostAliasesを使用してPodの/etc/hostsにエントリーを追加する</a></li>
<li>13.2: <a href=#pg-eebac062766222247063d6513f95c7b2>IPv4/IPv6デュアルスタックの検証</a></li>
</ul>
<li>14: <a href=#pg-5ab7bc7f14942c5c4b29d19f4a87271c>GPUのスケジューリング</a></li>
<li>15: <a href=#pg-fdfb2a2cba62a1e624897eaebac0168e>huge pageを管理する</a></li>
</ul>
<div class=content>
<p>Kubernetesドキュメントのこのセクションには、個々のタスクの実行方法を示すページが含まれています。タスクページは、通常、短い手順を実行することにより、1つのことを行う方法を示します。</p>
<p>タスクページを作成したい場合は、<a href=/docs/contribute/new-content/open-a-pr/>ドキュメントのPull Requestの作成</a>を参照してください。</p>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-57bf66f59d9a642b82eebeabbc66470b>1 - ツールのインストール</h1>
<div class=lead>Kubernetesのツールをローカルのコンピュータ上にセットアップします。</div>
<h2 id=kubectl>kubectl</h2>
<p>Kubernetesのコマンドラインツール<code>kubectl</code>を使用すると、Kubernetesクラスターに対してコマンドを実行できるようになります。kubectlは、アプリケーションのデプロイ、クラスターリソースの調査と管理、ログの表示などに使用できます。</p>
<p><code>kubectl</code>のダウンロードとインストールを行い、クラスターへのアクセスをセットアップする方法については、<a href=/ja/docs/tasks/tools/install-kubectl/>kubectlのインストールおよびセットアップ</a>を参照してください。</p>
<p>また、<a href=/ja/docs/reference/kubectl/><code>kubectl</code>リファレンスドキュメント</a>も参照できます。</p>
<h2 id=minikube>Minikube</h2>
<p><a href=https://minikube.sigs.k8s.io/>Minikube</a>は、Kubernetesをローカルで実行するツールです。MinikubeはシングルノードのKubernetesクラスターをパーソナルコンピューター上(Windows、macOS、Linux PCを含む)で実行することで、Kubernetesを試したり、日常的な開発作業のために利用できます。</p>
<p>ツールのインストールについて知りたい場合は、公式の<a href=https://minikube.sigs.k8s.io/docs/start/>Get Started!</a>のガイドに従ってください。</p>
<p>Minikubeが起動したら、<a href=/ja/docs/tutorials/hello-minikube/>サンプルアプリケーションの実行</a>を試すことができます。</p>
<h2 id=kind>kind</h2>
<p>Minikubeと同じように、<a href=https://kind.sigs.k8s.io/docs/>kind</a>もローカルコンピューター上でKubernetesを実行するツールです。Minikubeとは違い、kindは1種類のコンテナランタイム上でしか動作しません。実行には<a href=https://docs.docker.com/get-docker/>Docker</a>のインストールと設定が必要です。</p>
<p><a href=https://kind.sigs.k8s.io/docs/user/quick-start/>Quick Start</a>に、kindの起動に必要な手順が説明されています。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bbdc530b292ab4074d1dfe69feafb3e7>1.1 - kubectlのインストールおよびセットアップ</h1>
<p>Kubernetesのコマンドラインツールである<a href=/ja/docs/reference/kubectl/overview/>kubectl</a>を使用して、Kubernetesクラスターに対してコマンドを実行することができます。kubectlによってアプリケーションのデプロイや、クラスターのリソース管理、検査およびログの表示を行うことができます。kubectlの操作に関する完全なリストは、<a href=/ja/docs/reference/kubectl/overview/>kubectlの概要</a>を参照してください。</p>
<h2 id=始める前に>始める前に</h2>
<p>kubectlのバージョンは、クラスターのマイナーバージョンとの差分が1つ以内でなければなりません。たとえば、クライアントがv1.2であれば、v1.1、v1.2、v1.3のマスターで動作するはずです。最新バージョンのkubectlを使うことで、不測の事態を避けることができるでしょう。</p>
<h2 id=install-kubectl-on-linux>Linuxへkubectlをインストールする</h2>
<h3 id=curlを使用してlinuxへkubectlのバイナリをインストールする>curlを使用してLinuxへkubectlのバイナリをインストールする</h3>
<ol>
<li>
<p>次のコマンドにより、最新リリースをダウンロードしてください:</p>
<pre><code>curl -LO &quot;https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl&quot;
</code></pre><p>特定のバージョンをダウンロードする場合、コマンドの<code>$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)</code>の部分を特定のバージョンに書き換えてください。</p>
<p>たとえば、Linuxへv1.22.16のバージョンをダウンロードするには、次のコマンドを入力します:</p>
<pre><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.22.16/bin/linux/amd64/kubectl
</code></pre></li>
<li>
<p>kubectlバイナリを実行可能にしてください。</p>
<pre><code>chmod +x ./kubectl
</code></pre></li>
<li>
<p>バイナリをPATHの中に移動させてください。</p>
<pre><code>sudo mv ./kubectl /usr/local/bin/kubectl
</code></pre></li>
<li>
<p>インストールしたバージョンが最新であることを確認してください:</p>
<pre><code>kubectl version --client
</code></pre></li>
</ol>
<h3 id=ネイティブなパッケージマネージャーを使用してインストールする>ネイティブなパッケージマネージャーを使用してインストールする</h3>
<ul class="nav nav-tabs" id=kubectl-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-install-0 role=tab aria-controls=kubectl-install-0 aria-selected=true>Ubuntu、DebianまたはHypriotOS</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-install-1 role=tab aria-controls=kubectl-install-1>CentOS、RHELまたはFedora</a></li></ul>
<div class=tab-content id=kubectl-install><div id=kubectl-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-install-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>
sudo apt-get update <span style=color:#666>&amp;&amp;</span> sudo apt-get install -y apt-transport-https gnupg2
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
<span style=color:#a2f>echo</span> <span style=color:#b44>&#34;deb https://apt.kubernetes.io/ kubernetes-xenial main&#34;</span> | sudo tee -a /etc/apt/sources.list.d/kubernetes.list
sudo apt-get update
sudo apt-get install -y kubectl
</code></pre></div></div>
<div id=kubectl-install-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-install-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#b44>&lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
</span><span style=color:#b44>[kubernetes]
</span><span style=color:#b44>name=Kubernetes
</span><span style=color:#b44>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
</span><span style=color:#b44>enabled=1
</span><span style=color:#b44>gpgcheck=1
</span><span style=color:#b44>repo_gpgcheck=1
</span><span style=color:#b44>gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</span><span style=color:#b44>EOF</span>
yum install -y kubectl
</code></pre></div></div></div>
<h3 id=他のパッケージマネージャーを使用してインストールする>他のパッケージマネージャーを使用してインストールする</h3>
<ul class="nav nav-tabs" id=other-kubectl-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#other-kubectl-install-0 role=tab aria-controls=other-kubectl-install-0 aria-selected=true>Snap</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#other-kubectl-install-1 role=tab aria-controls=other-kubectl-install-1>Homebrew</a></li></ul>
<div class=tab-content id=other-kubectl-install><div id=other-kubectl-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=other-kubectl-install-0>
<p><p>Ubuntuまたは<a href=https://snapcraft.io/docs/core/install>snap</a>パッケージマネージャーをサポートする別のLinuxディストリビューションを使用している場合、kubectlは<a href=https://snapcraft.io/>snap</a>アプリケーションとして使用できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>snap install kubectl --classic

kubectl version --client
</code></pre></div></div>
<div id=other-kubectl-install-1 class=tab-pane role=tabpanel aria-labelledby=other-kubectl-install-1>
<p><p>Linuxで<a href=https://docs.brew.sh/Homebrew-on-Linux>Homebrew</a>パッケージマネージャーを使用している場合は、kubectlを<a href=https://docs.brew.sh/Homebrew-on-Linux#install>インストール</a>することが可能です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>brew install kubectl

kubectl version --client
</code></pre></div></div></div>
<h2 id=install-kubectl-on-macos>macOSへkubectlをインストールする</h2>
<h3 id=curlを使用してmacosへkubectlのバイナリをインストールする>curlを使用してmacOSへkubectlのバイナリをインストールする</h3>
<ol>
<li>
<p>最新リリースをダウンロードしてください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -LO <span style=color:#b44>&#34;https://storage.googleapis.com/kubernetes-release/release/</span><span style=color:#a2f;font-weight:700>$(</span>curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>/bin/darwin/amd64/kubectl&#34;</span>
</code></pre></div><p>特定のバージョンをダウンロードする場合、コマンドの<code>$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)</code>の部分を特定のバージョンに書き換えてください。</p>
<p>たとえば、macOSへv1.22.16のバージョンをダウンロードするには、次のコマンドを入力します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash> curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.22.16/bin/darwin/amd64/kubectl
</code></pre></div></li>
<li>
<p>kubectlバイナリを実行可能にしてください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>chmod +x ./kubectl
</code></pre></div></li>
<li>
<p>バイナリをPATHの中に移動させてください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo mv ./kubectl /usr/local/bin/kubectl
</code></pre></div></li>
<li>
<p>インストールしたバージョンが最新であることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl version --client
</code></pre></div></li>
</ol>
<h3 id=homebrewを使用してmacosへインストールする>Homebrewを使用してmacOSへインストールする</h3>
<p>macOSで<a href=https://brew.sh/>Homebrew</a>パッケージマネージャーを使用していれば、Homebrewでkubectlをインストールすることもできます。</p>
<ol>
<li>
<p>インストールコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install kubectl
</code></pre></div><p>または</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install kubernetes-cli
</code></pre></div></li>
<li>
<p>インストールしたバージョンが最新であることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl version --client
</code></pre></div></li>
</ol>
<h3 id=macportsを使用してmacosへインストールする>MacPortsを使用してmacOSへインストールする</h3>
<p>macOSで<a href=https://macports.org/>MacPorts</a>パッケージマネージャーを使用していれば、MacPortsでkubectlをインストールすることもできます。</p>
<ol>
<li>
<p>インストールコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo port selfupdate
sudo port install kubectl
</code></pre></div></li>
<li>
<p>インストールしたバージョンが最新であることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl version --client
</code></pre></div></li>
</ol>
<h2 id=install-kubectl-on-windows>Windowsへkubectlをインストールする</h2>
<h3 id=curlを使用してwindowsへkubectlのバイナリをインストールする>curlを使用してWindowsへkubectlのバイナリをインストールする</h3>
<ol>
<li>
<p><a href=https://storage.googleapis.com/kubernetes-release/release/v1.22.16/bin/windows/amd64/kubectl.exe>こちらのリンク</a>から、最新リリースであるv1.22.16をダウンロードしてください。</p>
<p>または、<code>curl</code>をインストールされていれば、次のコマンドも使用できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.22.16/bin/windows/amd64/kubectl.exe
</code></pre></div><p>最新の安定版を入手する際は(たとえばスクリプトで使用する場合)、<a href=https://storage.googleapis.com/kubernetes-release/release/stable.txt>https://storage.googleapis.com/kubernetes-release/release/stable.txt</a>を参照してください。</p>
</li>
<li>
<p>バイナリをPATHに追加します</p>
</li>
<li>
<p><code>kubectl</code>のバージョンがダウンロードしたものと同じであることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl version --client
</code></pre></div></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <a href=https://docs.docker.com/docker-for-windows/#kubernetes>Docker Desktop for Windows</a>は、それ自身のバージョンの<code>kubectl</code>をPATHに追加します。Docker Desktopをすでにインストールしている場合、Docker Desktopインストーラーによって追加されたPATHの前に追加するか、Docker Desktopの<code>kubectl</code>を削除してください。
</div>
<h3 id=psgalleryからpowershellを使用してインストールする>PSGalleryからPowerShellを使用してインストールする</h3>
<p>Windowsで<a href=https://www.powershellgallery.com/>Powershell Gallery</a>パッケージマネージャーを使用していれば、Powershellでkubectlをインストールおよびアップデートすることもできます。</p>
<ol>
<li>
<p>インストールコマンドを実行してください(必ず<code>DownloadLocation</code>を指定してください):</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>Install-Script</span> -Name <span style=color:#b44>&#39;install-kubectl&#39;</span> -Scope CurrentUser -Force
<span style=color:#a2f>install-kubectl</span>.ps1 [-DownloadLocation &lt;path&gt;]
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>DownloadLocation</code>を指定しない場合、<code>kubectl</code>はユーザのTempディレクトリにインストールされます。
</div>
<p>インストーラーは<code>$HOME/.kube</code>を作成し、設定ファイルを作成します。</p>
</li>
<li>
<p>インストールしたバージョンが最新であることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>kubectl version --client
</code></pre></div></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> アップデートする際は、手順1に示した2つのコマンドを再実行してください。
</div>
<h3 id=chocolateyまたはscoopを使用してwindowsへインストールする>ChocolateyまたはScoopを使用してWindowsへインストールする</h3>
<ol>
<li>
<p>Windowsへkubectlをインストールするために、<a href=https://chocolatey.org>Chocolatey</a>パッケージマネージャーや<a href=https://scoop.sh>Scoop</a>コマンドラインインストーラーを使用することもできます。</p>
<ul class="nav nav-tabs" id=kubectl-win-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-win-install-0 role=tab aria-controls=kubectl-win-install-0 aria-selected=true>choco</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-win-install-1 role=tab aria-controls=kubectl-win-install-1>scoop</a></li></ul>
<div class=tab-content id=kubectl-win-install><div id=kubectl-win-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-win-install-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>choco install <span style=color:#a2f>kubernetes-cli</span>
</code></pre></div></div>
<div id=kubectl-win-install-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-win-install-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>scoop install kubectl
</code></pre></div></div></div>
</li>
<li>
<p>インストールしたバージョンが最新であることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>kubectl version --client
</code></pre></div></li>
<li>
<p>ホームディレクトリへ移動してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#080;font-style:italic># cmd.exeを使用している場合は cd %USERPROFILE% を実行してください。</span>
<span style=color:#a2f>cd </span>~
</code></pre></div></li>
<li>
<p><code>.kube</code>ディレクトリを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>mkdir .kube
</code></pre></div></li>
<li>
<p>作成した<code>.kube</code>ディレクトリへ移動してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>cd </span>.kube
</code></pre></div></li>
<li>
<p>リモートのKubernetesクラスターを使うために、kubectlを設定してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>New-Item</span> config -type file
</code></pre></div></li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Notepadなどの選択したテキストエディターから設定ファイルを編集してください。
</div>
<h2 id=google-cloud-sdkの一部としてダウンロードする>Google Cloud SDKの一部としてダウンロードする</h2>
<p>Google Cloud SDKの一部として、kubectlをインストールすることもできます。</p>
<ol>
<li>
<p><a href=https://cloud.google.com/sdk/>Google Cloud SDK</a>をインストールしてください。</p>
</li>
<li>
<p><code>kubectl</code>のインストールコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>gcloud components install kubectl
</code></pre></div></li>
<li>
<p>インストールしたバージョンが最新であることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl version --client
</code></pre></div></li>
</ol>
<h2 id=kubectlの設定を検証する>kubectlの設定を検証する</h2>
<p>kubectlがKubernetesクラスターを探索し接続するために、<a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfigファイル</a>が必要になります。これは、<a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh>kube-up.sh</a>によりクラスターを作成した際や、Minikubeクラスターを正常にデプロイした際に自動生成されます。デフォルトでは、kubectlの設定は<code>~/.kube/config</code>に格納されています。</p>
<p>クラスターの状態を取得し、kubectlが適切に設定されていることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info
</code></pre></div><p>URLのレスポンスが表示されている場合は、kubectlはクラスターに接続するよう正しく設定されています。</p>
<p>以下のようなメッセージが表示されている場合は、kubectlは正しく設定されていないか、Kubernetesクラスターに接続できていません。</p>
<pre><code>The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?
</code></pre><p>たとえば、ラップトップ上(ローカル環境)でKubernetesクラスターを起動するような場合、Minikubeなどのツールを最初にインストールしてから、上記のコマンドを再実行する必要があります。</p>
<p>kubectl cluster-infoがURLレスポンスを返したにもかかわらずクラスターにアクセスできない場合は、次のコマンドで設定が正しいことを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl cluster-info dump
</code></pre></div><h2 id=kubectlの任意の設定>kubectlの任意の設定</h2>
<h3 id=シェルの自動補完を有効にする>シェルの自動補完を有効にする</h3>
<p>kubectlはBashおよびZshの自動補完を提供しています。これにより、入力を大幅に削減することができます。</p>
<p>以下にBash(LinuxとmacOSの違いも含む)およびZshの自動補完の設定手順を示します。</p>
<ul class="nav nav-tabs" id=kubectl-autocompletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-autocompletion-0 role=tab aria-controls=kubectl-autocompletion-0 aria-selected=true>LinuxでのBash</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-1 role=tab aria-controls=kubectl-autocompletion-1>macOSでのBash</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-2 role=tab aria-controls=kubectl-autocompletion-2>Zsh</a></li></ul>
<div class=tab-content id=kubectl-autocompletion><div id=kubectl-autocompletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-autocompletion-0>
<p><h3 id=はじめに>はじめに</h3>
<p>Bashにおけるkubectlの補完スクリプトは<code>kubectl completion bash</code>コマンドで生成できます。シェル内で補完スクリプトをsourceすることでkubectlの自動補完が有効になります。</p>
<p>ただし、補完スクリプトは<a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>に依存しているため、このソフトウェアを最初にインストールしておく必要があります(<code>type _init_completion</code>を実行することで、bash-completionがすでにインストールされていることを確認できます)。</p>
<h3 id=bash-completionをインストールする>bash-completionをインストールする</h3>
<p>bash-completionは多くのパッケージマネージャーから提供されています(<a href=https://github.com/scop/bash-completion#installation>こちら</a>を参照してください)。<code>apt-get install bash-completion</code>または<code>yum install bash-completion</code>などでインストールできます。</p>
<p>上記のコマンドでbash-completionの主要スクリプトである<code>/usr/share/bash-completion/bash_completion</code>が作成されます。パッケージマネージャーによっては、このファイルを<code>~/.bashrc</code>にて手動でsourceする必要があります。</p>
<p>これを調べるには、シェルをリロードしてから<code>type _init_completion</code>を実行してください。コマンドが成功していればすでに設定済みです。そうでなければ、<code>~/.bashrc</code>に以下を追記してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>source</span> /usr/share/bash-completion/bash_completion
</code></pre></div><p>シェルをリロードし、<code>type _init_completion</code>を実行してbash-completionが正しくインストールされていることを検証してください。</p>
<h3 id=kubectlの自動補完を有効にする>kubectlの自動補完を有効にする</h3>
<p>すべてのシェルセッションにてkubectlの補完スクリプトをsourceできるようにしなければなりません。これを行うには2つの方法があります:</p>
<ul>
<li>
<p>補完スクリプトを<code>~/.bashrc</code>内でsourceしてください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bashrc
</code></pre></div></li>
<li>
<p>補完スクリプトを<code>/etc/bash_completion.d</code>ディレクトリに追加してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl completion bash &gt;/etc/bash_completion.d/kubectl
</code></pre></div></li>
<li>
<p>kubectlにエイリアスを張っている場合は、以下のようにシェルの補完を拡張して使うことができます:</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bashrc
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -F __start_kubectl k&#39;</span> &gt;&gt;~/.bashrc
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> bash-completionは<code>/etc/bash_completion.d</code>内のすべての補完スクリプトをsourceします。
</div>
<p>どちらも同様の手法です。シェルをリロードしたあとに、kubectlの自動補完が機能するはずです。</p>
</div>
<div id=kubectl-autocompletion-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-1>
<p><h3 id=はじめに>はじめに</h3>
<p>Bashにおけるkubectlの補完スクリプトは<code>kubectl completion bash</code>コマンドで生成できます。シェル内で補完スクリプトをsourceすることでkubectlの自動補完が有効になります。</p>
<p>ただし、補完スクリプトは<a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>に依存しているため、事前にインストールする必要があります。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> bash-completionにはv1とv2のバージョンがあり、v1はBash 3.2(macOSのデフォルト)用で、v2はBash 4.1以降向けです。kubectlの補完スクリプトはbash-completionのv1とBash 3.2では正しく<strong>動作しません</strong>。<strong>bash-completion v2</strong>および<strong>Bash 4.1</strong>が必要になります。したがって、macOSで正常にkubectlの補完を使用するには、Bash 4.1以降をインストールする必要があります(<a href=https://itnext.io/upgrading-bash-on-macos-7138bd1066ba><em>手順</em></a>)。以下の手順では、Bash4.1以降(Bashのバージョンが4.1またはそれより新しいことを指します)を使用することを前提とします。
</div>
<h3 id=bashのアップグレード>bashのアップグレード</h3>
<p>ここではBash 4.1以降の使用を前提としています。Bashのバージョンは下記のコマンドで調べることができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b8860b>$BASH_VERSION</span>
</code></pre></div><p>バージョンが古い場合、Homebrewを使用してインストールもしくはアップグレードできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install bash
</code></pre></div><p>シェルをリロードし、希望するバージョンを使用していることを確認してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b8860b>$BASH_VERSION</span> <span style=color:#b8860b>$SHELL</span>
</code></pre></div><p>Homebrewは通常、<code>/usr/local/bin/bash</code>にインストールします。</p>
<h3 id=bash-completionをインストールする>bash-completionをインストールする</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 前述のとおり、この手順ではBash 4.1以降であることが前提のため、bash-completion v2をインストールすることになります(これとは逆に、Bash 3.2およびbash-completion v1の場合ではkubectlの補完は動作しません)。
</div>
<p><code>type _init_completion</code>を実行することで、bash-completionがすでにインストールされていることを確認できます。ない場合は、Homebrewを使用してインストールすることもできます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>brew install bash-completion@2
</code></pre></div><p>このコマンドの出力で示されたように、<code>~/.bash_profile</code>に以下を追記してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>export</span> <span style=color:#b8860b>BASH_COMPLETION_COMPAT_DIR</span><span style=color:#666>=</span><span style=color:#b44>&#34;/usr/local/etc/bash_completion.d&#34;</span>
<span style=color:#666>[[</span> -r <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span> <span style=color:#666>]]</span> <span style=color:#666>&amp;&amp;</span> . <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span>
</code></pre></div><p>シェルをリロードし、<code>type _init_completion</code>を実行してbash-completion v2が正しくインストールされていることを検証してください。</p>
<h3 id=kubectlの自動補完を有効にする>kubectlの自動補完を有効にする</h3>
<p>すべてのシェルセッションにてkubectlの補完スクリプトをsourceできるようにしなければなりません。これを行うには複数の方法があります:</p>
<ul>
<li>
<p>補完スクリプトを<code>~/.bash_profile</code>内でsourceする:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bash_profile
</code></pre></div></li>
<li>
<p>補完スクリプトを<code>/usr/local/etc/bash_completion.d</code>ディレクトリに追加する:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl completion bash &gt;/usr/local/etc/bash_completion.d/kubectl
</code></pre></div></li>
<li>
<p>kubectlにエイリアスを張っている場合は、以下のようにシェルの補完を拡張して使うことができます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bash_profile
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -F __start_kubectl k&#39;</span> &gt;&gt;~/.bash_profile
</code></pre></div></li>
<li>
<p>kubectlをHomwbrewでインストールした場合(<a href=#homebrew%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6macos%E3%81%B8%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%99%E3%82%8B>前述</a>のとおり)、kubectlの補完スクリプトはすでに<code>/usr/local/etc/bash_completion.d/kubectl</code>に格納されているでしょう。この場合、なにも操作する必要はありません。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Homebrewでインストールしたbash-completion v2は<code>BASH_COMPLETION_COMPAT_DIR</code>ディレクトリ内のすべてのファイルをsourceするため、後者の2つの方法が機能します。
</li>
</ul>
</div>
<p>どの場合でも、シェルをリロードしたあとに、kubectlの自動補完が機能するはずです。</p>
</div>
<div id=kubectl-autocompletion-2 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-2>
<p><p>Zshにおけるkubectlの補完スクリプトは<code>kubectl completion zsh</code>コマンドで生成できます。シェル内で補完スクリプトをsourceすることでkubectlの自動補完が有効になります。</p>
<p>すべてのシェルセッションで使用するには、<code>~/.zshrc</code>に以下を追記してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>
</code></pre></div><p>kubectlにエイリアスを張っている場合は、以下のようにシェルの補完を拡張して使うことができます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.zshrc
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;compdef __start_kubectl k&#39;</span> &gt;&gt;~/.zshrc
</code></pre></div><p>シェルをリロードしたあとに、kubectlの自動補完が機能するはずです。</p>
<p><code>complete:13: command not found: compdef</code>のようなエラーが出力された場合は、以下を<code>~/.zshrc</code>の先頭に追記してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>autoload -Uz compinit
compinit
</code></pre></div></div></div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=https://minikube.sigs.k8s.io/docs/start/>Minikubeをインストールする</a></li>
<li>クラスターの作成に関する詳細を<a href=/ja/docs/setup/>スタートガイド</a>で確認する</li>
<li><a href=/ja/docs/tasks/access-application-cluster/service-access-application-cluster/>アプリケーションを起動して公開する方法を学ぶ</a></li>
<li>あなたが作成していないクラスターにアクセスする必要がある場合は、<a href=/ja/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>クラスターアクセスドキュメントの共有</a>を参照してください</li>
<li><a href=/docs/reference/kubectl/kubectl/>kubectlリファレンスドキュメント</a>を参照する</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5da33b976758a9183018c421eb83f58>2 - Podとコンテナの設定</h1>
<div class=lead>Podとコンテナの一般的な設定のタスクを行います。</div>
</div>
<div class=td-content>
<h1 id=pg-e6dd9300cf3a955f7cdfe77fb5d15292>2.1 - コンテナおよびPodへのメモリーリソースの割り当て</h1>
<p>このページでは、メモリーの <em>要求</em> と <em>制限</em> をコンテナに割り当てる方法について示します。コンテナは要求されたメモリーを確保することを保証しますが、その制限を超えるメモリーの使用は許可されません。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>クラスターの各ノードには、少なくとも300MiBのメモリーが必要になります。</p>
<p>このページのいくつかの手順では、クラスターにて<a href=https://github.com/kubernetes-incubator/metrics-server>metrics-server</a>サービスを実行する必要があります。すでにmetrics-serverが動作している場合、これらの手順をスキップできます。</p>
<p>Minikubeを動作させている場合、以下のコマンドによりmetrics-serverを有効にできます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube addons <span style=color:#a2f>enable</span> metrics-server
</code></pre></div><p>metrics-serverが実行されているか、もしくはリソースメトリクスAPI (<code>metrics.k8s.io</code>) の別のプロバイダが実行されていることを確認するには、以下のコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get apiservices
</code></pre></div><p>リソースメトリクスAPIが利用可能であれば、出力には <code>metrics.k8s.io</code> への参照が含まれます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME
v1beta1.metrics.k8s.io
</code></pre></div>
<h2 id=namespaceの作成>namespaceの作成</h2>
<p>この練習で作成するリソースがクラスター内で分離されるよう、namespaceを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace mem-example
</code></pre></div><h2 id=メモリーの要求と制限を指定する>メモリーの要求と制限を指定する</h2>
<p>コンテナにメモリーの要求を指定するには、コンテナのリソースマニフェストに<code>resources:requests</code>フィールドを追記します。メモリーの制限を指定するには、<code>resources:limits</code>を追記します。</p>
<p>この練習では、一つのコンテナをもつPodを作成します。コンテナに100MiBのメモリー要求と200MiBのメモリー制限を与えます。Podの設定ファイルは次のようになります:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/resource/memory-request-limit.yaml download=pods/resource/memory-request-limit.yaml><code>pods/resource/memory-request-limit.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-memory-request-limit-yaml')" title="Copy pods/resource/memory-request-limit.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-memory-request-limit-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルの<code>args</code>セクションでは、コンテナ起動時の引数を与えます。<code>"--vm-bytes", "150M"</code>という引数では、コンテナに150MiBのメモリーを割り当てます。</p>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit.yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>Podのコンテナが起動していることを検証してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>Podの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>この出力では、Pod内の一つのコンテナに100MiBのメモリー要求と200MiBのメモリー制限があることを示しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></code></pre></div><p><code>kubectl top</code>を実行し、Podのメトリクスを取得してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl top pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>この出力では、Podが約162,900,000バイト(約150MiB)のメモリーを使用していることを示しています。Podの100MiBの要求を超えていますが、200MiBの制限には収まっています。</p>
<pre><code>NAME                        CPU(cores)   MEMORY(bytes)
memory-demo                 &lt;something&gt;  162856960
</code></pre><p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><h2 id=コンテナのメモリー制限を超える>コンテナのメモリー制限を超える</h2>
<p>ノードに利用可能なメモリーがある場合、コンテナはメモリー要求を超えることができます。しかしながら、メモリー制限を超えて使用することは許可されません。コンテナが制限を超えてメモリーを確保しようとした場合、そのコンテナは終了候補となります。コンテナが制限を超えてメモリーを消費し続ける場合、コンテナは終了されます。終了したコンテナを再起動できる場合、ほかのランタイムの失敗時と同様に、kubeletがコンテナを再起動させます。</p>
<p>この練習では、制限を超えてメモリーを確保しようとするPodを作成します。以下に50MiBのメモリー要求と100MiBのメモリー制限を与えたコンテナを持つ、Podの設定ファイルを示します:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/resource/memory-request-limit-2.yaml download=pods/resource/memory-request-limit-2.yaml><code>pods/resource/memory-request-limit-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-memory-request-limit-2-yaml')" title="Copy pods/resource/memory-request-limit-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-memory-request-limit-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;250M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルの<code>args</code>セクションでは、コンテナに250MiBのメモリーを割り当てており、これは100MiBの制限を十分に超えています。</p>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-2.yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>Podの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>この時点で、コンテナは起動中か強制終了されているでしょう。コンテナが強制終了されるまで上記のコマンドをくり返し実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME            READY     STATUS      RESTARTS   AGE
memory-demo-2   0/1       OOMKilled   <span style=color:#666>1</span>          24s
</code></pre></div><p>コンテナステータスの詳細な情報を取得してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-2 --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>この出力では、コンテナがメモリー不足 (OOM) により強制終了されたことを示しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>lastState:
   terminated:
     containerID: docker://65183c1877aaec2e8427bc95609cc52677a454b56fcb24340dbd22917c23b10f
     exitCode: <span style=color:#666>137</span>
     finishedAt: 2017-06-20T20:52:19Z
     reason: OOMKilled
     startedAt: null
</code></pre></div><p>この練習のコンテナはkubeletによって再起動されます。次のコマンドを数回くり返し実行し、コンテナが強制終了と再起動を続けていることを確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>この出力では、コンテナが強制終了され、再起動され、再度強制終了および再起動が続いていることを示しています:</p>
<pre><code>kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS      RESTARTS   AGE
memory-demo-2   0/1       OOMKilled   1          37s
</code></pre><pre><code>
kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-2   1/1       Running   2          40s
</code></pre><p>Podの履歴について詳細な情報を確認してください:</p>
<pre><code>kubectl describe pod memory-demo-2 --namespace=mem-example
</code></pre><p>この出力では、コンテナの開始とその失敗が繰り返されていることを示しています:</p>
<pre><code>... Normal  Created   Created container with id 66a3a20aa7980e61be4922780bf9d24d1a1d8b7395c09861225b0eba1b1f8511
... Warning BackOff   Back-off restarting failed container
</code></pre><p>クラスターのノードの詳細な情報を確認してください:</p>
<pre><code>kubectl describe nodes
</code></pre><p>この出力には、メモリー不足の状態のためコンテナが強制終了された記録が含まれます:</p>
<pre><code>Warning OOMKilling Memory cgroup out of memory: Kill process 4481 (stress) score 1994 or sacrifice child
</code></pre><p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><h2 id=ノードよりも大きいメモリー要求を指定する>ノードよりも大きいメモリー要求を指定する</h2>
<p>メモリー要求と制限はコンテナと関連づけられていますが、Podにメモリー要求と制限が与えられていると考えるとわかりやすいでしょう。Podのメモリー要求は、Pod内のすべてのコンテナのメモリー要求の合計となります。同様に、Podのメモリー制限は、Pod内のすべてのコンテナのメモリー制限の合計となります。</p>
<p>Podのスケジューリングは要求に基づいています。Podはノード上で動作するうえで、そのメモリー要求に対してノードに十分利用可能なメモリーがある場合のみスケジュールされます。</p>
<p>この練習では、クラスター内のノードのキャパシティを超える大きさのメモリー要求を与えたPodを作成します。以下に1000GiBのメモリー要求を与えた一つのコンテナを持つ、Podの設定ファイルを示します。これは、クラスター内のノードのキャパシティを超える可能性があります。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/resource/memory-request-limit-3.yaml download=pods/resource/memory-request-limit-3.yaml><code>pods/resource/memory-request-limit-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-memory-request-limit-3-yaml')" title="Copy pods/resource/memory-request-limit-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-memory-request-limit-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-3.yaml --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>Podの状態を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>この出力では、Podのステータスが待機中であることを示しています。つまり、Podがどのノードに対しても実行するようスケジュールされておらず、いつまでも待機状態のままであることを表しています:</p>
<pre><code>kubectl get pod memory-demo-3 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-3   0/1       Pending   0          25s
</code></pre><p>イベントを含むPodの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><p>この出力では、ノードのメモリー不足のためコンテナがスケジュールされないことを示しています:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Events:
  ...  Reason            Message
       ------            -------
  ...  FailedScheduling  No nodes are available that match all of the following predicates:: Insufficient memory <span style=color:#666>(</span>3<span style=color:#666>)</span>.
</code></pre></div><h2 id=メモリーの単位>メモリーの単位</h2>
<p>メモリーリソースはバイト単位で示されます。メモリーをE、P、T、G、M、K、Ei、Pi、Ti、Gi、Mi、Kiという接尾辞とともに、整数型または固定小数点整数で表現できます。たとえば、以下はおおよそ同じ値を表します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>128974848, 129e6, 129M , 123Mi
</code></pre></div><p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</code></pre></div><h2 id=メモリー制限を指定しない場合>メモリー制限を指定しない場合</h2>
<p>コンテナのメモリー制限を指定しない場合、次のいずれかの状態となります:</p>
<ul>
<li>
<p>コンテナのメモリー使用量に上限がない状態となります。コンテナは実行中のノードで利用可能なすべてのメモリーを使用でき、その後OOM Killerが呼び出される可能性があります。さらに、OOM killの場合、リソース制限のないコンテナは強制終了される可能性が高くなります。</p>
</li>
<li>
<p>メモリー制限を与えられたnamespaceでコンテナを実行されると、コンテナにはデフォルトの制限値が自動的に指定されます。クラスターの管理者は<a href=/docs/reference/generated/kubernetes-api/v1.22/#limitrange-v1-core>LimitRange</a>によってメモリー制限のデフォルト値を指定できます。</p>
</li>
</ul>
<h2 id=メモリー要求と制限のモチベーション>メモリー要求と制限のモチベーション</h2>
<p>クラスターで動作するコンテナにメモリー要求と制限を設定することで、クラスターのノードで利用可能なメモリーリソースを効率的に使用することができます。Podのメモリー要求を低く保つことで、Podがスケジュールされやすくなります。メモリー要求よりも大きい制限を与えることで、次の2つを実現できます:</p>
<ul>
<li>Podは利用可能なメモリーを、突発的な活動(バースト)に使用することができます。</li>
<li>バースト中のPodのメモリー使用量は、適切な量に制限されます。</li>
</ul>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>namespaceを削除してください。これにより、今回のタスクで作成したすべてのPodが削除されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace mem-example
</code></pre></div><h2 id=次の項目>次の項目</h2>
<h3 id=アプリケーション開発者向け>アプリケーション開発者向け</h3>
<ul>
<li>
<p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>コンテナとPodにCPUリソースを割り当てる</a></p>
</li>
<li>
<p><a href=/docs/tasks/configure-pod-container/quality-service-pod/>PodのQuality of Serviceを設定する</a></p>
</li>
</ul>
<h3 id=クラスター管理者向け>クラスター管理者向け</h3>
<ul>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>Namespaceにメモリー要求および制限のデフォルト値を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>NamespaceにCPU要求および制限のデフォルト値を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>Namespaceに最小および最大メモリー量の制約を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>Namespaceに最小および最大のCPU使用量の制約を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>NamespaceにメモリーおよびCPUのクォータを設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>NamespaceにPodのクォータを設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/quota-api-object/>APIオブジェクトのクォータを設定する</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8555af270ae7122cc0464bab3f5d1609>2.2 - コンテナおよびPodへのCPUリソースの割り当て</h1>
<p>このページでは、CPUの <em>request</em> と <em>limit</em> をコンテナに割り当てる方法について示します。コンテナは設定された制限を超えてCPUを使用することはできません。システムにCPUの空き時間がある場合、コンテナには要求されたCPUを割り当てられます。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>タスク例を実行するには、クラスターに少なくとも利用可能な1 CPUが必要です。</p>
<p>このページのいくつかの手順では、クラスターにて<a href=https://github.com/kubernetes-incubator/metrics-server>metrics-server</a>サービスを実行する必要があります。すでにmetrics-serverが動作している場合、これらの手順をスキップできます。</p>
<p><a class=glossary-tooltip title="A tool for running Kubernetes locally." data-toggle=tooltip data-placement=top href=/docs/setup/learning-environment/minikube/ target=_blank aria-label=Minikube>Minikube</a>を動作させている場合、以下のコマンドによりmetrics-serverを有効にできます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube addons <span style=color:#a2f>enable</span> metrics-server
</code></pre></div><p>metrics-serverが実行されているか、もしくはリソースメトリクスAPI (<code>metrics.k8s.io</code>) の別のプロバイダーが実行されていることを確認するには、以下のコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get apiservices
</code></pre></div><p>リソースメトリクスAPIが利用可能であれば、出力には <code>metrics.k8s.io</code> への参照が含まれます。</p>
<pre><code>NAME
v1beta1.metrics.k8s.io
</code></pre>
<h2 id=namespaceの作成>namespaceの作成</h2>
<p>この練習で作成するリソースがクラスター内で分離されるよう、<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=Namespace>Namespace</a>を作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace cpu-example
</code></pre></div><h2 id=cpuの要求と制限を指定する>CPUの要求と制限を指定する</h2>
<p>コンテナにCPUの要求を指定するには、コンテナのリソースマニフェストに<code>resources:requests</code>フィールドを追記します。CPUの制限を指定するには、<code>resources:limits</code>を追記します。</p>
<p>この練習では、一つのコンテナをもつPodを作成します。コンテナに0.5 CPUの要求と1 CPUの制限を与えます。Podの設定ファイルは次のようになります:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/resource/cpu-request-limit.yaml download=pods/resource/cpu-request-limit.yaml><code>pods/resource/cpu-request-limit.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-cpu-request-limit-yaml')" title="Copy pods/resource/cpu-request-limit.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-cpu-request-limit-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cpu-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0.5&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -cpus<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルの<code>args</code>セクションでは、コンテナ起動時の引数を与えます。<code>-cpus "2"</code>という引数では、コンテナに2 CPUを割り当てます。</p>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/cpu-request-limit.yaml --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><p>Podのコンテナが起動していることを検証してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><p>Podの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod cpu-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><p>この出力では、Pod内の一つのコンテナに500ミリCPUの要求と1 CPUの制限があることを示しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></code></pre></div><p><code>kubectl top</code>を実行し、Podのメトリクスを取得してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl top pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><p>この出力では、Podが974ミリCPUを使用していることを示しています。Podの設定で指定した1 CPUの制限よりわずかに小さい値です。</p>
<pre><code>NAME                        CPU(cores)   MEMORY(bytes)
cpu-demo                    974m         &lt;something&gt;
</code></pre><p><code>-cpu "2"</code>を設定することで、コンテナが2 CPU利用しようとすることを思い出してください。しかしながら、コンテナは約1 CPUしか使用することができません。コンテナが制限よりも多くのCPUリソースを利用しようとしているため、コンテナのCPUの利用が抑制されています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> CPUの使用量が1.0未満である理由の可能性して、ノードに利用可能なCPUリソースが十分にないことが挙げられます。この練習における必要条件として、クラスターに少なくとも利用可能な1 CPUが必要であることを思い出してください。1 CPUのノード上でコンテナを実行させる場合、指定したコンテナのCPU制限にかかわらず、コンテナは1 CPU以上使用することはできません。
</div>
<h2 id=cpuの単位>CPUの単位</h2>
<p>CPUリソースは <em>CPU</em> の単位で示されます。Kubernetesにおいて1つのCPUは次に等しくなります:</p>
<ul>
<li>1 AWS vCPU</li>
<li>1 GCPコア</li>
<li>1 Azure vCore</li>
<li>ハイパースレッディングが有効なベアメタルIntelプロセッサーの1スレッド</li>
</ul>
<p>小数値も利用可能です。0.5 CPUを要求するコンテナには、1 CPUを要求するコンテナの半分のCPUが与えられます。mというミリを表す接尾辞も使用できます。たとえば、100m CPU、100 milliCPU、0.1 CPUはすべて同じです。1m以上の精度は指定できません。</p>
<p>CPUはつねに絶対量として要求され、決して相対量としては要求されません。0.1はシングルコア、デュアルコア、48コアCPUのマシンで同じ量となります。</p>
<p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><h2 id=ノードよりも大きいcpu要求を指定する>ノードよりも大きいCPU要求を指定する</h2>
<p>CPU要求と制限はコンテナと関連づけられていますが、PodにCPU要求と制限が与えられていると考えるとわかりやすいでしょう。PodのCPU要求は、Pod内のすべてのコンテナのCPU要求の合計となります。同様に、PodのCPU制限は、Pod内のすべてのコンテナのCPU制限の合計となります。</p>
<p>Podのスケジューリングはリソースの要求量に基づいています。Podはノード上で動作するうえで、そのCPU要求に対してノードに十分利用可能なCPUリソースがある場合のみスケジュールされます。</p>
<p>この練習では、クラスター内のノードのキャパシティを超える大きさのCPU要求を与えたPodを作成します。以下に100 CPUの要求を与えた一つのコンテナを持つ、Podの設定ファイルを示します。これは、クラスター内のノードのキャパシティを超える可能性があります。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/resource/cpu-request-limit-2.yaml download=pods/resource/cpu-request-limit-2.yaml><code>pods/resource/cpu-request-limit-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-cpu-request-limit-2-yaml')" title="Copy pods/resource/cpu-request-limit-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-cpu-request-limit-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cpu-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-ctr-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -cpus<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/cpu-request-limit-2.yaml --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><p>Podの状態を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><p>この出力では、Podのステータスが待機中であることを示しています。つまり、Podがどのノードに対しても実行するようスケジュールされておらず、いつまでも待機状態のままであることを表しています:</p>
<pre><code>NAME         READY     STATUS    RESTARTS   AGE
cpu-demo-2   0/1       Pending   0          7m
</code></pre><p>イベントを含むPodの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><p>この出力では、ノードのCPU不足のためコンテナがスケジュールされないことを示しています:</p>
<pre><code>Events:
  Reason                        Message
  ------                        -------
  FailedScheduling      No nodes are available that match all of the following predicates:: Insufficient cpu (3).
</code></pre><p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</code></pre></div><h2 id=cpu制限を指定しない場合>CPU制限を指定しない場合</h2>
<p>コンテナのCPU制限を指定しない場合、次のいずれかの状態となります:</p>
<ul>
<li>
<p>コンテナのCPUリソースの使用量に上限がない状態となります。コンテナは実行中のノードで利用可能なすべてのCPUを使用できます。</p>
</li>
<li>
<p>CPU制限を与えられたnamespaceでコンテナを実行されると、コンテナにはデフォルトの制限値が自動的に指定されます。クラスターの管理者は<a href=/docs/reference/generated/kubernetes-api/v1.22/#limitrange-v1-core>LimitRange</a>によってCPU制限のデフォルト値を指定できます。</p>
</li>
</ul>
<h2 id=cpu要求と制限のモチベーション>CPU要求と制限のモチベーション</h2>
<p>クラスターで動作するコンテナにCPU要求と制限を設定することで、クラスターのノードで利用可能なCPUリソースを効率的に使用することができます。PodのCPU要求を低く保つことで、Podがスケジュールされやすくなります。CPU要求よりも大きい制限を与えることで、次の2つを実現できます:</p>
<ul>
<li>Podは利用可能なCPUリソースを、突発的な活動(バースト)に使用することができます。</li>
<li>バースト中のPodのCPUリソース量は、適切な量に制限されます。</li>
</ul>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>namespaceを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace cpu-example
</code></pre></div><h2 id=次の項目>次の項目</h2>
<h3 id=アプリケーション開発者向け>アプリケーション開発者向け</h3>
<ul>
<li>
<p><a href=/ja/docs/tasks/configure-pod-container/assign-memory-resource/>コンテナおよびPodへのメモリーリソースの割り当て</a></p>
</li>
<li>
<p><a href=/docs/tasks/configure-pod-container/quality-service-pod/>PodのQuality of Serviceを設定する</a></p>
</li>
</ul>
<h3 id=クラスター管理者向け>クラスター管理者向け</h3>
<ul>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>Namespaceにメモリー要求および制限のデフォルト値を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>NamespaceにCPU要求および制限のデフォルト値を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>Namespaceに最小および最大メモリー量の制約を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>Namespaceに最小および最大のCPU使用量の制約を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>NamespaceにメモリーおよびCPUのクォータを設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>NamespaceにPodのクォータを設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/quota-api-object/>APIオブジェクトのクォータを設定する</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-904cea8c8efd5c0d33adbfe579ec2dd2>2.3 - PodにQuality of Serviceを設定する</h1>
<p>このページでは、特定のQuality of Service (QoS)クラスをPodに割り当てるための設定方法を示します。Kubernetesは、Podのスケジューリングおよび退役を決定するためにQoSクラスを用います。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=qosクラス>QoSクラス</h2>
<p>KubernetesはPodの作成時に次のいずれかのQoSクラスをPodに割り当てます:</p>
<ul>
<li>Guaranteed</li>
<li>Burstable</li>
<li>BestEffort</li>
</ul>
<h2 id=namespaceの作成>namespaceの作成</h2>
<p>この演習で作成するリソースがクラスター内で分離されるよう、namespaceを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace qos-example
</code></pre></div><h2 id=guaranteedのqosクラスを割り当てたpodを作成する>GuaranteedのQoSクラスを割り当てたPodを作成する</h2>
<p>PodにGuaranteedのQoSクラスを与えるには、以下が必要になります:</p>
<ul>
<li>Pod内のすべてのコンテナにメモリーの制限と要求が与えられており、同じ値であること。</li>
<li>Pod内のすべてのコンテナにCPUの制限と要求が与えられており、同じ値であること。</li>
</ul>
<p>以下に1つのコンテナをもつPodの設定ファイルを示します。コンテナには200MiBのメモリー制限とリクエストを与え、700ミリCPUの制限と要求を与えます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/qos/qos-pod.yaml download=pods/qos/qos-pod.yaml><code>pods/qos/qos-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-yaml')" title="Copy pods/qos/qos-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><p>Podの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div><p>この出力では、KubernetesがPodにGuaranteed QoSクラスを与えたことを示しています。Podのコンテナにメモリー制限と一致するメモリー要求があり、CPU制限と一致するCPU要求があることも確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Guaranteed<span style=color:#bbb>
</span></code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> コンテナにメモリー制限を指定し、メモリー要求を指定していない場合は、Kubernetesは自動的にメモリー制限と一致するメモリー要求を割り当てます。同様に、コンテナにCPU制限を指定し、CPU要求を指定していない場合は、Kubernetesは自動的にCPU制限と一致するCPU要求を割り当てます。
</div>
<p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><h2 id=burstableのqosクラスを割り当てたpodを作成する>BurstableのQoSクラスを割り当てたPodを作成する</h2>
<p>次のような場合に、Burstable QoSクラスがPodに与えられます:</p>
<ul>
<li>PodがGuaranteed QoSクラスの基準に満たない場合。</li>
<li>Pod内の1つ以上のコンテナがメモリーまたはCPUの要求を与えられている場合。</li>
</ul>
<p>以下に1つのコンテナをもつPodの設定ファイルを示します。コンテナには200MiBのメモリー制限と100MiBのメモリー要求を与えます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/qos/qos-pod-2.yaml download=pods/qos/qos-pod-2.yaml><code>pods/qos/qos-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-2-yaml')" title="Copy pods/qos/qos-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-2.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><p>Podの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div><p>この出力では、KubernetesがPodにBurstable QoSクラスを与えたことを示しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></code></pre></div><p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><h2 id=besteffortのqosクラスを割り当てたpodを作成する>BestEffortのQoSクラスを割り当てたPodを作成する</h2>
<p>PodにBestEffort QoSクラスを与えるには、Pod内のコンテナにはメモリーやCPUの制限や要求を指定してはなりません。</p>
<p>以下に1つのコンテナをもつPodの設定ファイルを示します。コンテナにはメモリーやCPUの制限や要求がありません:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/qos/qos-pod-3.yaml download=pods/qos/qos-pod-3.yaml><code>pods/qos/qos-pod-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-3-yaml')" title="Copy pods/qos/qos-pod-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-3.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><p>Podの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div><p>この出力では、KubernetesがPodにBestEffort QoSクラスを与えたことを示しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>BestEffort<span style=color:#bbb>
</span></code></pre></div><p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><h2 id=2つのコンテナを含むpodを作成する>2つのコンテナを含むPodを作成する</h2>
<p>以下に2つのコンテナをもつPodの設定ファイルを示します。一方のコンテナは200MiBのメモリー要求を指定し、もう一方のコンテナには要求や制限を指定しません。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/qos/qos-pod-4.yaml download=pods/qos/qos-pod-4.yaml><code>pods/qos/qos-pod-4.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-qos-qos-pod-4-yaml')" title="Copy pods/qos/qos-pod-4.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-qos-qos-pod-4-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>このPodがBurstable QoSクラスの基準を満たしていることに注目してください。つまり、Guaranteed QoSクラスの基準に満たしておらず、一方のコンテナにはメモリー要求を与えられています。</p>
<p>Podを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-4.yaml --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><p>Podの詳細な情報を確認してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</code></pre></div><p>この出力では、KubernetesがPodにBurstable QoSクラスを与えたことを示しています:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></code></pre></div><p>Podを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example
</code></pre></div><h2 id=クリーンアップ>クリーンアップ</h2>
<p>namespaceを削除してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace qos-example
</code></pre></div><h2 id=次の項目>次の項目</h2>
<h3 id=アプリケーション開発者向け>アプリケーション開発者向け</h3>
<ul>
<li>
<p><a href=/ja/docs/tasks/configure-pod-container/assign-memory-resource/>コンテナおよびPodへのメモリーリソースの割り当て</a></p>
</li>
<li>
<p><a href=/ja/docs/tasks/configure-pod-container/assign-cpu-resource/>コンテナとPodにCPUリソースを割り当てる</a></p>
</li>
</ul>
<h3 id=クラスター管理者向け>クラスター管理者向け</h3>
<ul>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>Namespaceにメモリー要求および制限のデフォルト値を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>NamespaceにCPU要求および制限のデフォルト値を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>Namespaceに最小および最大メモリー量の制約を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>Namespaceに最小および最大のCPU使用量の制約を設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>NamespaceにメモリーおよびCPUのクォータを設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>NamespaceにPodのクォータを設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/quota-api-object/>APIオブジェクトのクォータを設定する</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/topology-manager/>ノードのトポロジー管理ポリシーを制御する</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4219ac6ab56a3b88d20305083d57d03c>2.4 - 拡張リソースをコンテナに割り当てる</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<p>このページでは、拡張リソースをコンテナに割り当てる方法について説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>この練習を始める前に、<a href=/ja/docs/tasks/administer-cluster/extended-resource-node/>Nodeに拡張リソースをアドバタイズする</a>の練習を行ってください。これにより、Nodeの1つがドングルリソースをアドバタイズするように設定されます。</p>
<h2 id=拡張リソースをpodに割り当てる>拡張リソースをPodに割り当てる</h2>
<p>拡張リソースをリクエストするには、コンテナのマニフェストに<code>resources:requests</code>フィールドを含めます。拡張リソースは、<code>*.kubernetes.io/</code>以外の任意のドメインで完全修飾されます。有効な拡張リソース名は、<code>example.com/foo</code>という形式になります。ここで、<code>example.com</code>はあなたの組織のドメインで、<code>foo</code>は記述的なリソース名で置き換えます。</p>
<p>1つのコンテナからなるPodの構成ファイルを示します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/resource/extended-resource-pod.yaml download=pods/resource/extended-resource-pod.yaml><code>pods/resource/extended-resource-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-extended-resource-pod-yaml')" title="Copy pods/resource/extended-resource-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-extended-resource-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>構成ファイルでは、コンテナが3つのdongleをリクエストしていることがわかります。</p>
<p>次のコマンドでPodを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/extended-resource-pod.yaml
</code></pre></div><p>Podが起動したことを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod extended-resource-demo
</code></pre></div><p>Podの説明を表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod extended-resource-demo
</code></pre></div><p>dongleのリクエストが表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>Requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div><h2 id=2つ目のpodの作成を試みる>2つ目のPodの作成を試みる</h2>
<p>以下に、1つのコンテナを持つPodの構成ファイルを示します。コンテナは2つのdongleをリクエストします。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/resource/extended-resource-pod-2.yaml download=pods/resource/extended-resource-pod-2.yaml><code>pods/resource/extended-resource-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-resource-extended-resource-pod-2-yaml')" title="Copy pods/resource/extended-resource-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-resource-extended-resource-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Kubernetesは、2つのdongleのリクエストを満たすことができません。1つ目のPodが、利用可能な4つのdongleのうち3つを使用してしまっているためです。</p>
<p>Podを作成してみます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/resource/extended-resource-pod-2.yaml
</code></pre></div><p>Podの説明を表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod extended-resource-demo-2
</code></pre></div><p>出力にはPodがスケジュールできないことが示されます。2つのdongleが利用できるNodeが存在しないためです。</p>
<pre><code>Conditions:
  Type    Status
  PodScheduled  False
...
Events:
  ...
  ... Warning   FailedScheduling  pod (extended-resource-demo-2) failed to fit in any node
fit failure summary on nodes : Insufficient example.com/dongle (1)
</code></pre><p>Podのステータスを表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod extended-resource-demo-2
</code></pre></div><p>出力には、Podは作成されたものの、Nodeにスケジュールされなかったことが示されています。PodはPending状態になっています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>NAME                       READY     STATUS    RESTARTS   AGE<span style=color:#bbb>
</span><span style=color:#bbb></span>extended-resource-demo-2   0/1       Pending   0          6m<span style=color:#bbb>
</span></code></pre></div><h2 id=クリーンアップ>クリーンアップ</h2>
<p>この練習で作成したPodを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod extended-resource-demo
kubectl delete pod extended-resource-demo-2
</code></pre></div><h2 id=次の項目>次の項目</h2>
<h3 id=アプリケーション開発者向け>アプリケーション開発者向け</h3>
<ul>
<li><a href=/ja/docs/tasks/configure-pod-container/assign-memory-resource/>コンテナおよびPodへのメモリーリソースの割り当て</a></li>
<li><a href=/ja/docs/tasks/configure-pod-container/assign-cpu-resource/>コンテナおよびPodへのCPUリソースの割り当て</a></li>
</ul>
<h3 id=クラスター管理者向け>クラスター管理者向け</h3>
<ul>
<li><a href=/ja/docs/tasks/administer-cluster/extended-resource-node/>Nodeに拡張リソースをアドバタイズする</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-484833fb880d1e179cc2965d15f84da5>2.5 - ストレージにボリュームを使用するPodを構成する</h1>
<p>このページでは、ストレージにボリュームを使用するPodを構成する方法を示します。</p>
<p>コンテナのファイルシステムは、コンテナが存在する間のみ存続します。
そのため、コンテナが終了して再起動すると、ファイルシステムの変更は失われます。
コンテナに依存しない、より一貫したストレージを実現するには、<a href=/docs/concepts/storage/volumes/>ボリューム</a>を使用できます。
これは、キーバリューストア(Redisなど)やデータベースなどのステートフルアプリケーションにとって特に重要です。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=podのボリュームを構成する>Podのボリュームを構成する</h2>
<p>この演習では、1つのコンテナを実行するPodを作成します。
今回作成するPodには、コンテナが終了して再起動した場合でもPodの寿命が続く<a href=/docs/concepts/storage/volumes/#emptydir>emptyDir</a>タイプのボリュームがあります。
これがPodの設定ファイルです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/storage/redis.yaml download=pods/storage/redis.yaml><code>pods/storage/redis.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-redis-yaml')" title="Copy pods/storage/redis.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-redis-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/data/redis<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/storage/redis.yaml
</code></pre></div></li>
<li>
<p>Podのコンテナが実行されていることを確認し、Podへの変更を監視します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod redis --watch
</code></pre></div><p>出力は次のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      READY     STATUS    RESTARTS   AGE
redis     1/1       Running   <span style=color:#666>0</span>          13s
</code></pre></div></li>
<li>
<p>別のターミナルで、実行中のコンテナへのシェルを取得します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</code></pre></div></li>
<li>
<p>シェルで、<code>/data/redis</code>に移動し、ファイルを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data# <span style=color:#a2f>cd</span> /data/redis/
root@redis:/data/redis# <span style=color:#a2f>echo</span> Hello &gt; test-file
</code></pre></div></li>
<li>
<p>シェルで、実行中のプロセスを一覧表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data/redis# apt-get update
root@redis:/data/redis# apt-get install procps
root@redis:/data/redis# ps aux
</code></pre></div><p>出力はこのようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
redis        <span style=color:#666>1</span>  0.1  0.1  <span style=color:#666>33308</span>  <span style=color:#666>3828</span> ?        Ssl  00:46   0:00 redis-server *:6379
root        <span style=color:#666>12</span>  0.0  0.0  <span style=color:#666>20228</span>  <span style=color:#666>3020</span> ?        Ss   00:47   0:00 /bin/bash
root        <span style=color:#666>15</span>  0.0  0.0  <span style=color:#666>17500</span>  <span style=color:#666>2072</span> ?        R+   00:48   0:00 ps aux
</code></pre></div></li>
<li>
<p>シェルで、Redisプロセスを終了します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data/redis# <span style=color:#a2f>kill</span> &lt;pid&gt;
</code></pre></div><p>ここで<code>&lt;pid></code>はRedisプロセスID(PID)です。</p>
</li>
<li>
<p>元の端末で、Redis Podへの変更を監視します。最終的には、このようなものが表示されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      READY     STATUS     RESTARTS   AGE
redis     1/1       Running    <span style=color:#666>0</span>          13s
redis     0/1       Completed  <span style=color:#666>0</span>         6m
redis     1/1       Running    <span style=color:#666>1</span>         6m
</code></pre></div></li>
</ol>
<p>この時点で、コンテナは終了して再起動しました。
これは、Redis Podの<a href=/docs/reference/generated/kubernetes-api/v1.22/#podspec-v1-core>restartPolicy</a>が<code>Always</code>であるためです。</p>
<ol>
<li>
<p>再起動されたコンテナへのシェルを取得します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</code></pre></div></li>
<li>
<p>シェルで<code>/data/redis</code>に移動し、<code>test-file</code>がまだ存在することを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>root@redis:/data/redis# <span style=color:#a2f>cd</span> /data/redis/
root@redis:/data/redis# ls
test-file
</code></pre></div></li>
<li>
<p>この演習用に作成したPodを削除します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod redis
</code></pre></div></li>
</ol>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#volume-v1-core>Volume</a>参照</p>
</li>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#pod-v1-core>Pod</a>参照</p>
</li>
<li>
<p><code>emptyDir</code>によって提供されるローカルディスクストレージに加えて、Kubernetesは、GCEのPDやEC2のEBSなど、さまざまなネットワーク接続ストレージソリューションをサポートします。これらは、重要なデータに好ましく、ノード上のデバイスのマウントやアンマウントなどの詳細を処理します。詳細は<a href=/docs/concepts/storage/volumes/>ボリューム</a>を参照してください。</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-4621938ba53c04a77f51b5938a583439>2.6 - ストレージにProjectedボリュームを使用するようPodを設定する</h1>
<p>このページでは、<a href=/docs/concepts/storage/volumes/#projected><code>projected</code></a>(投影)ボリュームを使用して、既存の複数のボリュームソースを同一ディレクトリ内にマウントする方法を説明します。
現在、<code>secret</code>、<code>configMap</code>、<code>downwardAPI</code>および<code>serviceAccountToken</code>ボリュームを投影できます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>serviceAccountToken</code>はボリュームタイプではありません。
</div>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=projectedボリュームをpodに設定する>ProjectedボリュームをPodに設定する</h2>
<p>この課題では、ローカルファイルからユーザーネームおよびパスワードの<a class=glossary-tooltip title=パスワードやOAuthトークン、SSHキーのような機密の情報を保持します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>を作成します。
次に、単一のコンテナを実行するPodを作成し、<a href=/docs/concepts/storage/volumes/#projected><code>projected</code></a>ボリュームを使用してそれぞれのSecretを同じ共有ディレクトリにマウントします。</p>
<p>以下にPodの設定ファイルを示します:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/storage/projected.yaml download=pods/storage/projected.yaml><code>pods/storage/projected.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-storage-projected-yaml')" title="Copy pods/storage/projected.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-storage-projected-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-projected-volume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-projected-volume<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;86400&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>user<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pass<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>Secretを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># ユーザーネームおよびパスワードを含むファイルを作成します:</span>
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#34;admin&#34;</span> &gt; ./username.txt
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#34;1f2d1e2e67df&#34;</span> &gt; ./password.txt

<span style=color:#080;font-style:italic># これらのファイルからSecretを作成します:</span>
kubectl create secret generic user --from-file<span style=color:#666>=</span>./username.txt
kubectl create secret generic pass --from-file<span style=color:#666>=</span>./password.txt
</code></pre></div></li>
<li>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/storage/projected.yaml
</code></pre></div></li>
<li>
<p>Pod内のコンテナが実行されていることを確認するため、Podの変更を監視します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get --watch pod test-projected-volume
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>NAME                    READY     STATUS    RESTARTS   AGE
test-projected-volume   1/1       Running   0          14s
</code></pre></li>
<li>
<p>別の端末にて、実行中のコンテナへのシェルを取得します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it test-projected-volume -- /bin/sh
</code></pre></div></li>
<li>
<p>シェル内にて、投影されたソースを含む<code>projected-volume</code>ディレクトリが存在することを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ls /projected-volume/
</code></pre></div></li>
</ol>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>PodおよびSecretを削除します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod test-projected-volume
kubectl delete secret user pass
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/concepts/storage/volumes/#projected><code>projected</code></a>ボリュームについてさらに学ぶ</li>
<li><a href=https://github.com/kubernetes/community/blob/v1.22.16/contributors/design-proposals/node/all-in-one-volume.md>all-in-oneボリューム</a>のデザインドキュメントを読む</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eb54daf87df373096b5e830680194dfc>2.7 - Liveness Probe、Readiness ProbeおよびStartup Probeを使用する</h1>
<p>このページでは、Liveness Probe、Readiness ProbeおよびStartup Probeの使用方法について説明します。</p>
<p><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>は、Liveness Probeを使用して、コンテナをいつ再起動するかを認識します。
例えば、アプリケーション自体は起動しているが、処理を継続することができないデッドロック状態を検知することができます。
このような状態のコンテナを再起動することで、バグがある場合でもアプリケーションの可用性を高めることができます。</p>
<p>kubeletは、Readiness Probeを使用して、コンテナがトラフィックを受け入れられる状態であるかを認識します。
Podが準備ができていると見なされるのは、Pod内の全てのコンテナの準備が整ったときです。
一例として、このシグナルはServiceのバックエンドとして使用されるPodを制御するときに使用されます。
Podの準備ができていない場合、そのPodはServiceのロードバランシングから切り離されます。</p>
<p>kubeletは、Startup Probeを使用して、コンテナアプリケーションの起動が完了したかを認識します。
Startup Probeを使用している場合、Startup Probeが成功するまでは、Liveness Probeと
Readiness Probeによるチェックを無効にし、これらがアプリケーションの起動に干渉しないようにします。
例えば、これを起動が遅いコンテナの起動チェックとして使用することで、起動する前にkubeletによって
強制終了されることを防ぐことができます。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=define-a-liveness-command>コマンド実行によるLiveness Probeを定義する</h2>
<p>長期間実行されているアプリケーションの多くは、再起動されるまで回復できないような異常な状態になることがあります。
Kubernetesはこのような状況を検知し、回復するためのLiveness Probeを提供します。</p>
<p>この演習では、<code>k8s.gcr.io/busybox</code>イメージのコンテナを起動するPodを作成します。
Podの構成ファイルは次の通りです。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/probe/exec-liveness.yaml download=pods/probe/exec-liveness.yaml><code>pods/probe/exec-liveness.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-probe-exec-liveness-yaml')" title="Copy pods/probe/exec-liveness.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-probe-exec-liveness-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-exec<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- cat<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- /tmp/healthy<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>この構成ファイルでは、Podは一つの<code>Container</code>を起動します。
<code>periodSeconds</code>フィールドは、kubeletがLiveness Probeを5秒おきに行うように指定しています。
<code>initialDelaySeconds</code>フィールドは、kubeletが最初のProbeを実行する前に5秒間待機するように指示しています。
Probeの動作としては、kubeletは<code>cat /tmp/healthy</code>を対象のコンテナ内で実行します。
このコマンドが成功し、リターンコード0が返ると、kubeletはコンテナが問題なく動いていると判断します。
リターンコードとして0以外の値が返ると、kubeletはコンテナを終了し、再起動を行います。</p>
<p>このコンテナは、起動すると次のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/bin/sh -c <span style=color:#b44>&#34;touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600&#34;</span>
</code></pre></div><p>コンテナが起動してから初めの30秒間は<code>/tmp/healthy</code>ファイルがコンテナ内に存在します。
そのため初めの30秒間は<code>cat /tmp/healthy</code>コマンドは成功し、正常なリターンコードが返ります。
その後30秒が経過すると、<code>cat /tmp/healthy</code>コマンドは異常なリターンコードを返します。</p>
<p>このPodを起動してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/probe/exec-liveness.yaml
</code></pre></div><p>30秒間以内に、Podのイベントを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod liveness-exec
</code></pre></div><p>この出力結果は、Liveness Probeがまだ失敗していないことを示しています。</p>
<pre><code>FirstSeen    LastSeen    Count   From            SubobjectPath           Type        Reason      Message
--------- --------    -----   ----            -------------           --------    ------      -------
24s       24s     1   {default-scheduler }                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulling     pulling image &quot;k8s.gcr.io/busybox&quot;
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulled      Successfully pulled image &quot;k8s.gcr.io/busybox&quot;
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Created     Created container with docker id 86849c15382e; Security:[seccomp=unconfined]
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Started     Started container with docker id 86849c15382e
</code></pre><p>35秒後に、Podのイベントをもう一度確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod liveness-exec
</code></pre></div><p>出力結果の最後に、Liveness Probeが失敗していることを示すメッセージが表示されます。これによりコンテナは強制終了し、再作成されました。</p>
<pre><code>FirstSeen LastSeen    Count   From            SubobjectPath           Type        Reason      Message
--------- --------    -----   ----            -------------           --------    ------      -------
37s       37s     1   {default-scheduler }                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulling     pulling image &quot;k8s.gcr.io/busybox&quot;
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulled      Successfully pulled image &quot;k8s.gcr.io/busybox&quot;
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Created     Created container with docker id 86849c15382e; Security:[seccomp=unconfined]
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Started     Started container with docker id 86849c15382e
2s        2s      1   {kubelet worker0}   spec.containers{liveness}   Warning     Unhealthy   Liveness probe failed: cat: can't open '/tmp/healthy': No such file or directory
</code></pre><p>さらに30秒後、コンテナが再起動していることを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod liveness-exec
</code></pre></div><p>出力結果から、<code>RESTARTS</code>がインクリメントされていることを確認します:</p>
<pre><code>NAME            READY     STATUS    RESTARTS   AGE
liveness-exec   1/1       Running   1          1m
</code></pre><h2 id=define-a-liveness-http-request>HTTPリクエストによるLiveness Probeを定義する</h2>
<p>別の種類のLiveness Probeでは、HTTP GETリクエストを使用します。
次の構成ファイルは、<code>k8s.gcr.io/liveness</code>イメージを使用したコンテナを起動するPodを作成します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/probe/http-liveness.yaml download=pods/probe/http-liveness.yaml><code>pods/probe/http-liveness.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-probe-http-liveness-yaml')" title="Copy pods/probe/http-liveness.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-probe-http-liveness-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-http<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/liveness<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /server<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>X-Custom-Header<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>Awesome<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>この構成ファイルでは、Podは一つの<code>Container</code>を起動します。
<code>periodSeconds</code>フィールドは、kubeletがLiveness Probeを3秒おきに行うように指定しています。
<code>initialDelaySeconds</code>フィールドは、kubeletが最初のProbeを実行する前に3秒間待機するように指示しています。
Probeの動作としては、kubeletは8080ポートをリッスンしているコンテナ内のサーバーに対してHTTP GETリクエストを送ります。
サーバー内の<code>/healthz</code>パスに対するハンドラーが正常なリターンコードを応答した場合、
kubeletはコンテナが問題なく動いていると判断します。
異常なリターンコードを応答すると、kubeletはコンテナを終了し、再起動を行います。</p>
<p>200以上400未満のコードは成功とみなされ、その他のコードは失敗とみなされます。</p>
<p><a href=https://github.com/kubernetes/kubernetes/blob/v1.22.16/test/images/agnhost/liveness/server.go>server.go</a>
にてサーバーのソースコードを確認することができます。</p>
<p>コンテナが生きている初めの10秒間は、<code>/healthz</code>ハンドラーが200ステータスを返します。
その後、ハンドラーは500ステータスを返します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>http.<span style=color:#00a000>HandleFunc</span>(<span style=color:#b44>&#34;/healthz&#34;</span>, <span style=color:#a2f;font-weight:700>func</span>(w http.ResponseWriter, r <span style=color:#666>*</span>http.Request) {
    duration <span style=color:#666>:=</span> time.<span style=color:#00a000>Now</span>().<span style=color:#00a000>Sub</span>(started)
    <span style=color:#a2f;font-weight:700>if</span> duration.<span style=color:#00a000>Seconds</span>() &gt; <span style=color:#666>10</span> {
        w.<span style=color:#00a000>WriteHeader</span>(<span style=color:#666>500</span>)
        w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;error: %v&#34;</span>, duration.<span style=color:#00a000>Seconds</span>())))
    } <span style=color:#a2f;font-weight:700>else</span> {
        w.<span style=color:#00a000>WriteHeader</span>(<span style=color:#666>200</span>)
        w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(<span style=color:#b44>&#34;ok&#34;</span>))
    }
})
</code></pre></div><p>kubeletは、コンテナが起動してから3秒後からヘルスチェックを行います。
そのため、初めのいくつかのヘルスチェックは成功します。しかし、10秒経過するとヘルスチェックは失敗し、kubeletはコンテナを終了し、再起動します。</p>
<p>HTTPリクエストのチェックによるLiveness Probeを試すには、以下のようにPodを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/probe/http-liveness.yaml
</code></pre></div><p>10秒後、Podのイベントを表示して、Liveness Probeが失敗し、コンテナが再起動されていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod liveness-http
</code></pre></div><p>v1.13以前(v1.13を含む)のリリースにおいては、Podが起動しているノードに環境変数<code>http_proxy</code>
(または <code>HTTP_PROXY</code>)が設定されている場合、HTTPリクエストのLiveness Probeは設定されたプロキシを使用します。
v1.13より後のリリースにおいては、ローカルHTTPプロキシ環境変数の設定はHTTPリクエストのLiveness Probeに影響しません。</p>
<h2 id=define-a-tcp-liveness-probe>TCPによるLiveness Probeを定義する</h2>
<p>3つ目のLiveness ProbeはTCPソケットを使用するタイプです。
この構成においては、kubeletは指定したコンテナのソケットを開くことを試みます。
コネクションが確立できる場合はコンテナを正常とみなし、失敗する場合は異常とみなします。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/probe/tcp-liveness-readiness.yaml download=pods/probe/tcp-liveness-readiness.yaml><code>pods/probe/tcp-liveness-readiness.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-probe-tcp-liveness-readiness-yaml')" title="Copy pods/probe/tcp-liveness-readiness.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-probe-tcp-liveness-readiness-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/goproxy:0.1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tcpSocket</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tcpSocket</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>20</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>見ての通り、TCPによるチェックの構成はHTTPによるチェックと非常に似ています。
この例では、Readiness ProbeとLiveness Probeを両方使用しています。
kubeletは、コンテナが起動してから5秒後に最初のReadiness Probeを開始します。
これは<code>goproxy</code>コンテナの8080ポートに対して接続を試みます。
このProbeが成功すると、Podは準備ができていると通知されます。kubeletはこのチェックを10秒ごとに行います。</p>
<p>この構成では、Readiness Probeに加えてLiveness Probeが含まれています。
kubeletは、コンテナが起動してから15秒後に最初のLiveness Probeを実行します。
Readiness Probeと同様に、これは<code>goproxy</code>コンテナの8080ポートに対して接続を試みます。
Liveness Probeが失敗した場合、コンテナは再起動されます。</p>
<p>TCPのチェックによるLiveness Probeを試すには、以下のようにPodを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/probe/tcp-liveness-readiness.yaml
</code></pre></div><p>15秒後、Podのイベントを表示し、Liveness Probeが行われていることを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod goproxy
</code></pre></div><h2 id=use-a-named-port>名前付きポートを使用する</h2>
<p>HTTPまたはTCPによるProbeにおいて、<a href=/docs/reference/generated/kubernetes-api/v1.22/#containerport-v1-core>ContainerPort</a>
で定義した名前付きポートを使用することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></code></pre></div><h2 id=define-startup-probes>Startup Probeを使用して、起動の遅いコンテナを保護する</h2>
<p>場合によっては、最初の初期化において追加の起動時間が必要になるようなレガシーアプリケーションを扱う必要があります。
そのような場合、デッドロックに対する迅速な反応を損なうことなくLiveness Probeのパラメーターを設定することは難しい場合があります。</p>
<p>これに対する解決策の一つは、Liveness Probeと同じ構成のコマンドを用いるか、HTTPまたはTCPによるチェックを使用したStartup Probeをセットアップすることです。
その際、<code>failureThreshold * periodSeconds</code>で計算される時間を、起動時間として想定される最も遅いケースをカバーできる十分な長さに設定します。</p>
<p>上記の例は、次のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>startupProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></code></pre></div><p>Startup Probeにより、アプリケーションは起動が完了するまでに最大5分間の猶予(30 * 10 = 300秒)が与えられます。
Startup Probeに一度成功すると、その後はLiveness Probeが引き継ぎ、コンテナのデッドロックに対して迅速に反応します。
Startup Probeが成功しない場合、コンテナは300秒後に終了し、その後はPodの<code>restartPolicy</code>に従います。</p>
<h2 id=define-readiness-probes>Readiness Probeを定義する</h2>
<p>アプリケーションは一時的にトラフィックを処理できないことが起こり得ます。
例えば、アプリケーションは起動時に大きなデータまたは構成ファイルを読み込む必要がある場合や、起動後に外部サービスに依存している場合があります。
このような場合、アプリケーション自体を終了させたくはありませんが、このアプリケーションに対してリクエストも送信したくないと思います。
Kubernetesは、これらの状況を検知して緩和するための機能としてReadiness Probeを提供します。
これにより、準備ができていないことを報告するコンテナを含むPodは、KubernetesのServiceを通してトラフィックを受信しないようになります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Readiness Probeは、コンテナの全てのライフサイクルにおいて実行されます。
</div>
<p>Readiness ProbeはLiveness Probeと同様に構成します。
唯一の違いは<code>readinessProbe</code>フィールドを<code>livenessProbe</code>フィールドの代わりに利用することだけです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- cat<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- /tmp/healthy<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></code></pre></div><p>HTTPおよびTCPによるReadiness Probeの構成もLiveness Probeと同じです。</p>
<p>Readiness ProbeとLiveness Probeは同じコンテナで同時に使用できます。
両方使用することで、準備できていないコンテナへのトラフィックが到達しないようにし、コンテナが失敗したときに再起動することができます。</p>
<h2 id=configure-probes>Probeの構成</h2>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#probe-v1-core>Probe</a> には、
Liveness ProbeおよびReadiness Probeのチェック動作をより正確に制御するために使用できるフィールドがあります:</p>
<ul>
<li><code>initialDelaySeconds</code>: コンテナが起動してから、Liveness ProbeまたはReadiness Probeが開始されるまでの秒数。デフォルトは0秒。最小値は0。</li>
<li><code>periodSeconds</code>: Probeが実行される頻度(秒数)。デフォルトは10秒。最小値は1。</li>
<li><code>timeoutSeconds</code>: Probeがタイムアウトになるまでの秒数。デフォルトは1秒。最小値は1。</li>
<li><code>successThreshold</code>: 一度Probeが失敗した後、次のProbeが成功したとみなされるための最小連続成功数。
デフォルトは1。Liveness Probeには1を設定する必要があります。最小値は1。</li>
<li><code>failureThreshold</code>: Probeが失敗した場合、Kubernetesは<code>failureThreshold</code>に設定した回数までProbeを試行します。
Liveness Probeにおいて、試行回数に到達することはコンテナを再起動することを意味します。
Readiness Probeの場合は、Podが準備できていない状態として通知されます。デフォルトは3。最小値は1。</li>
</ul>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#httpgetaction-v1-core>HTTPによるProbe</a>
には、<code>httpGet</code>にて設定できる追加のフィールドがあります:</p>
<ul>
<li><code>host</code>: 接続先ホスト名。デフォルトはPod IP。おそらくはこのフィールドの代わりに<code>httpHeaders</code>内の"Host"を代わりに使用することになります。</li>
<li><code>scheme</code>: ホストへの接続で使用するスキーマ（HTTP または HTTPS）。デフォルトは HTTP。</li>
<li><code>path</code>: HTTPサーバーへアクセスする際のパス</li>
<li><code>httpHeaders</code>: リクエスト内のカスタムヘッダー。HTTPでは重複したヘッダーが許可されています。</li>
<li><code>port</code>: コンテナにアクセスする際のポートの名前または番号。ポート番号の場合、1から65535の範囲内である必要があります。</li>
</ul>
<p>HTTPによるProbeの場合、kubeletは指定したパスとポートに対するHTTPリクエストを送ることでチェックを行います。
<code>httpGet</code>のオプションである<code>host</code>フィールドでアドレスが上書きされない限り、kubeletはPodのIPアドレスに対してProbeを送ります。
<code>scheme</code>フィールドに<code>HTTPS</code>がセットされている場合、kubeletは証明書の検証を行わずにHTTPSリクエストを送ります。
ほとんどのシナリオにおいては、<code>host</code>フィールドを使用する必要はありません。次のシナリオは使用する場合の一例です。
仮にコンテナが127.0.0.1をリッスンしており、かつPodの<code>hostNetwork</code>フィールドがtrueだとします。
その場合においては、<code>httpGet</code>フィールド内の<code>host</code>には127.0.0.1をセットする必要があります。
より一般的なケースにおいてPodが仮想ホストに依存している場合は、おそらく<code>host</code>フィールドではなく、<code>httpHeaders</code>フィールド内の<code>Host</code>ヘッダーを使用する必要があります。</p>
<p>TCPによるProbeの場合、kubeletはPodの中ではなく、ノードに対してコネクションを確立するProbeを実行します。
kubeletはServiceの名前を解決できないため、<code>host</code>パラメーター内でServiceの名前を使用することはできません。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>Container Probes</a>についてもっと学ぶ</li>
</ul>
<p>また、次のAPIリファレンスも参考にしてください:</p>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#pod-v1-core>Pod</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#container-v1-core>Container</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#probe-v1-core>Probe</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fc3f4777ae8ea685d2b54e175277ac01>2.8 - Node Affinityを利用してPodをノードに割り当てる</h1>
<p>このページでは、Node Affinityを利用して、PodをKubernetesクラスター内の特定のノードに割り当てる方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.10.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=ノードにラベルを追加する>ノードにラベルを追加する</h2>
<ol>
<li>
<p>クラスター内のノードを一覧表示して、ラベルを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker2
</code></pre></div></li>
<li>
<p>ノードを選択して、ラベルを追加します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl label nodes &lt;your-node-name&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</code></pre></div><p>ここで、<code>&lt;your-node-name></code>は選択したノードの名前で置換します。</p>
</li>
<li>
<p>選択したノードに<code>disktype=ssd</code>ラベルがあることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,disktype=ssd,kubernetes.io/hostname=worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker2
</code></pre><p>この出力を見ると、<code>worker0</code>ノードに<code>disktype=ssd</code>というラベルが追加されたことがわかります。</p>
</li>
</ol>
<h2 id=required-node-affinityを使用してpodをスケジューリングする>required node affinityを使用してPodをスケジューリングする</h2>
<p>以下に示すマニフェストには、<code>requiredDuringSchedulingIgnoredDuringExecution</code>に<code>disktype: ssd</code>というnode affinityを使用したPodが書かれています。このように書くと、Podは<code>disktype=ssd</code>というラベルを持つノードにだけスケジューリングされるようになります。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-nginx-required-affinity.yaml download=pods/pod-nginx-required-affinity.yaml><code>pods/pod-nginx-required-affinity.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-required-affinity-yaml')" title="Copy pods/pod-nginx-required-affinity.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-required-affinity-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- ssd<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>マニフェストを適用して、選択したノード上にスケジューリングされるPodを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/pod-nginx-required-affinity.yaml
</code></pre></div></li>
<li>
<p>Podが選択したノード上で実行されていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li>
</ol>
<h2 id=preferred-node-affinityを使用してpodをスケジューリングする>preferred node affinityを使用してPodをスケジューリングする</h2>
<p>以下に示すマニフェストには、<code>preferredDuringSchedulingIgnoredDuringExecution</code>に<code>disktype: ssd</code>というnode affinityを使用したPodが書かれています。このように書くと、Podは<code>disktype=ssd</code>というラベルを持つノードに優先的にスケジューリングされるようになります。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-nginx-preferred-affinity.yaml download=pods/pod-nginx-preferred-affinity.yaml><code>pods/pod-nginx-preferred-affinity.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-preferred-affinity-yaml')" title="Copy pods/pod-nginx-preferred-affinity.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-preferred-affinity-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>preference</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- ssd<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>マニフェストを適用して、選択したノード上にスケジューリングされるPodを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/pod-nginx-preferred-affinity.yaml
</code></pre></div></li>
<li>
<p>Podが選択したノード上で実行されていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li>
</ol>
<h2 id=次の項目>次の項目</h2>
<p><a href=/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity>Node Affinity</a>についてさらに学ぶ。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-bbc17480da6d051c696489654c64064a>2.9 - Podをノードに割り当てる</h1>
<p>このページでは、KubernetesのPodをKubernetesクラスター上の特定のノードに割り当てる方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=ラベルをノードに追加する>ラベルをノードに追加する</h2>
<ol>
<li>
<p>クラスター内の<a class=glossary-tooltip title=ノードはKubernetesのワーカーマシンです。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/nodes/ target=_blank aria-label=ノード>ノード</a>のリストをラベル付きで表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker2
</code></pre></div></li>
<li>
<p>ノードの1つを選択して、ラベルを追加します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl label nodes &lt;your-node-name&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</code></pre></div><p>ここで、<code>&lt;your-node-name></code>は選択したノードの名前です。</p>
</li>
<li>
<p>選択したノードに<code>disktype=ssd</code>ラベルがあることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes --show-labels
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,disktype<span style=color:#666>=</span>ssd,kubernetes.io/hostname<span style=color:#666>=</span>worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker2
</code></pre></div><p>上の出力を見ると、<code>worker0</code>に<code>disktype=ssd</code>というラベルがあることがわかります。</p>
</li>
</ol>
<h2 id=選択したノードにスケジューリングされるpodを作成する>選択したノードにスケジューリングされるPodを作成する</h2>
<p>以下のPodの構成ファイルには、nodeSelectorに<code>disktype: ssd</code>を持つPodが書かれています。これにより、Podは<code>disktype: ssd</code>というラベルを持っているノードにスケジューリングされるようになります。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-nginx.yaml download=pods/pod-nginx.yaml><code>pods/pod-nginx.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-yaml')" title="Copy pods/pod-nginx.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>disktype</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>構成ファイルを使用して、選択したノードにスケジューリングされるPodを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/pod-nginx.yaml
</code></pre></div></li>
<li>
<p>Podが選択したノード上で実行されているをことを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   <span style=color:#666>0</span>          13s    10.200.0.4   worker0
</code></pre></div></li>
</ol>
<h2 id=特定のノードにスケジューリングされるpodを作成する>特定のノードにスケジューリングされるPodを作成する</h2>
<p><code>nodeName</code>という設定を使用して、Podを特定のノードにスケジューリングすることもできます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-nginx-specific-node.yaml download=pods/pod-nginx-specific-node.yaml><code>pods/pod-nginx-specific-node.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-nginx-specific-node-yaml')" title="Copy pods/pod-nginx-specific-node.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-nginx-specific-node-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>foo-node<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 特定のノードにPodをスケジューリングする</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>構成ファイルを使用して、<code>foo-node</code>にだけスケジューリングされるPodを作成します。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベルとセレクター</a>についてさらに学ぶ。</li>
<li><a href=/ja/docs/concepts/architecture/nodes/>ノード</a>についてさらに学ぶ。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-efbc43486296f0439d1a89c12d944d94>2.10 - コンテナライフサイクルイベントへのハンドラー紐付け</h1>
<p>このページでは、コンテナのライフサイクルイベントにハンドラーを紐付けする方法を説明します。KubernetesはpostStartとpreStopイベントをサポートしています。Kubernetesはコンテナの起動直後にpostStartイベントを送信し、コンテナの終了直前にpreStopイベントを送信します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=poststartハンドラーとprestopハンドラーを定義する>postStartハンドラーとpreStopハンドラーを定義する</h2>
<p>この課題では、1つのコンテナを持つPodを作成します。コンテナには、postStartイベントとpreStopイベントのハンドラーがあります。</p>
<p>これがPodの設定ファイルです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/lifecycle-events.yaml download=pods/lifecycle-events.yaml><code>pods/lifecycle-events.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-lifecycle-events-yaml')" title="Copy pods/lifecycle-events.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-lifecycle-events-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lifecycle-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lifecycle-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>postStart</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo Hello from the postStart handler &gt; /usr/share/message&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preStop</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/usr/sbin/nginx&#34;</span>,<span style=color:#b44>&#34;-s&#34;</span>,<span style=color:#b44>&#34;quit&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルでは、postStartコマンドが<code>message</code>ファイルをコンテナの<code>/usr/share</code>ディレクトリに書き込むことがわかります。preStopコマンドはnginxを適切にシャットダウンします。これは、障害のためにコンテナが終了している場合に役立ちます。</p>
<p>Podを作成します:</p>
<pre><code>kubectl apply -f https://k8s.io/examples/pods/lifecycle-events.yaml
</code></pre>
<p>Pod内のコンテナが実行されていることを確認します:</p>
<pre><code>kubectl get pod lifecycle-demo
</code></pre>
<p>Pod内で実行されているコンテナでシェルを実行します:</p>
<pre><code>kubectl exec -it lifecycle-demo -- /bin/bash
</code></pre>
<p>シェルで、<code>postStart</code>ハンドラーが<code>message</code>ファイルを作成したことを確認します:</p>
<pre><code>root@lifecycle-demo:/# cat /usr/share/message
</code></pre>
<p>出力は、postStartハンドラーによって書き込まれたテキストを示しています。</p>
<pre><code>Hello from the postStart handler
</code></pre>
<h2 id=議論>議論</h2>
<p>コンテナが作成された直後にKubernetesはpostStartイベントを送信します。
ただし、コンテナのエントリーポイントが呼び出される前にpostStartハンドラーが呼び出されるという保証はありません。postStartハンドラーはコンテナのコードに対して非同期的に実行されますが、postStartハンドラーが完了するまでコンテナのKubernetesによる管理はブロックされます。postStartハンドラーが完了するまで、コンテナのステータスはRUNNINGに設定されません。</p>
<p>Kubernetesはコンテナが終了する直前にpreStopイベントを送信します。
コンテナのKubernetesによる管理は、Podの猶予期間が終了しない限り、preStopハンドラーが完了するまでブロックされます。詳細は<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>を参照してください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Kubernetesは、Podが <em>終了</em> したときにのみpreStopイベントを送信します。
これは、Podが <em>完了</em> したときにpreStopフックが呼び出されないことを意味します。
この制限は<a href=https://github.com/kubernetes/kubernetes/issues/55807>issue #55087</a>で追跡されています。
</div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/containers/container-lifecycle-hooks/>コンテナライフサイクルフック</a>の詳細</li>
<li><a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>の詳細</li>
</ul>
<h3 id=参照>参照</h3>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#lifecycle-v1-core>ライフサイクル</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#container-v1-core>コンテナ</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#podspec-v1-core>PodSpec</a>の<code>terminationGracePeriodSeconds</code></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ed34e761c3dbd00fa79577fa78e30020>2.11 - Podを構成してConfigMapを使用する</h1>
<p>ConfigMapを使用すると、設定をイメージのコンテンツから切り離して、コンテナ化されたアプリケーションの移植性を維持できます。このページでは、ConfigMapを作成し、ConfigMapに保存されているデータを使用してPodを構成する一連の使用例を示します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=configmapを作成する>ConfigMapを作成する</h2>
<p><code>kubectl create configmap</code>または<code>kustomization.yaml</code>のConfigMap generatorを使用すると、ConfigMapを作成できます。<code>kubectl</code>が<code>kustomization.yaml</code>をサポートをしているのは1.14からである点に注意してください。</p>
<h3 id=kubectl-create-configmapを使用してconfigmapを作成する>kubectl create configmapを使用してConfigMapを作成する</h3>
<p><code>kubectl create configmap</code>を使用してConfigMapを<a href=#create-configmaps-from-directories>ディレクトリ</a>、<a href=#create-configmaps-from-files>ファイル</a>、または<a href=#create-configmaps-from-literal-values>リテラル値</a>から作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap &lt;map-name&gt; &lt;data-source&gt;
</code></pre></div><p>&lt;map-name>の部分はConfigMapに割り当てる名前で、&lt;data-source>はデータを取得するディレクトリ、ファイル、またはリテラル値です。ConfigMapの名前は有効な<a href=/ja/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<p>ファイルをベースにConfigMapを作成する場合、&lt;data-source> のキーはデフォルトでファイル名になり、値はデフォルトでファイルの中身になります。</p>
<p><a href=/docs/reference/generated/kubectl/kubectl-commands/#describe><code>kubectl describe</code></a>または
<a href=/docs/reference/generated/kubectl/kubectl-commands/#get><code>kubectl get</code></a>を使用すると、ConfigMapに関する情報を取得できます。</p>
<h4 id=create-configmaps-from-directories>ディレクトリからConfigMapを作成する</h4>
<p><code>kubectl create configmap</code>を使用すると、同一ディレクトリ内にある複数のファイルから1つのConfigMapを作成できます。ディレクトリをベースにConfigMapを作成する場合、kubectlはディレクトリ内でベース名が有効なキーであるファイルを識別し、それらのファイルを新たなConfigMapにパッケージ化します。ディレクトリ内にある通常のファイルでないものは無視されます(例: サブディレクトリ、シンボリックリンク、デバイス、パイプなど)。</p>
<p>例えば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># ローカルディレクトリを作成します</span>
mkdir -p configure-pod-container/configmap/

<span style=color:#080;font-style:italic># `configure-pod-container/configmap/`ディレクトリにサンプルファイルをダウンロードします</span>
wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.properties
wget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.properties

<span style=color:#080;font-style:italic># ConfigMapを作成します</span>
kubectl create configmap game-config --from-file<span style=color:#666>=</span>configure-pod-container/configmap/
</code></pre></div><p>上記のコマンドは各ファイルをパッケージ化します。この場合、<code>configure-pod-container/configmap/</code> ディレクトリの<code>game.properties</code> と <code>ui.properties</code>をgame-config ConfigMapにパッケージ化します。 以下のコマンドを使用すると、ConfigMapの詳細を表示できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe configmaps game-config
</code></pre></div><p>出力結果は以下のようになります:</p>
<pre><code>Name:         game-config
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
ui.properties:
----
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
</code></pre><p><code>configure-pod-container/configmap/</code> ディレクトリの<code>game.properties</code> と <code>ui.properties</code> ファイルはConfigMapの<code>data</code>セクションに表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmaps game-config -o yaml
</code></pre></div><p>出力結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T18:52:05Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;516&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>b4952dc3-d670-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    enemies=aliens
</span><span style=color:#b44;font-style:italic>    lives=3
</span><span style=color:#b44;font-style:italic>    enemies.cheat=true
</span><span style=color:#b44;font-style:italic>    enemies.cheat.level=noGoodRotten
</span><span style=color:#b44;font-style:italic>    secret.code.passphrase=UUDDLRLRBABAS
</span><span style=color:#b44;font-style:italic>    secret.code.allowed=true
</span><span style=color:#b44;font-style:italic>    secret.code.lives=30</span><span style=color:#bbb>    
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    color.good=purple
</span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span><span style=color:#b44;font-style:italic>    allow.textmode=true
</span><span style=color:#b44;font-style:italic>    how.nice.to.look=fairlyNice</span><span style=color:#bbb>    
</span></code></pre></div><h4 id=create-configmaps-from-files>ファイルからConfigMapを作成する</h4>
<p><code>kubectl create configmap</code>を使用して、個別のファイルまたは複数のファイルからConfigMapを作成できます。</p>
<p>例えば、</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-2 --from-file<span style=color:#666>=</span>configure-pod-container/configmap/game.properties
</code></pre></div><p>は、以下のConfigMapを生成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe configmaps game-config-2
</code></pre></div><p>出力結果は以下のようになります:</p>
<pre><code>Name:         game-config-2
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
</code></pre><p><code>--from-file</code>引数を複数回渡し、ConfigMapを複数のデータソースから作成できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-2 --from-file<span style=color:#666>=</span>configure-pod-container/configmap/game.properties --from-file<span style=color:#666>=</span>configure-pod-container/configmap/ui.properties
</code></pre></div><p>以下のコマンドを使用すると、ConfigMap<code>game-config-2</code>の詳細を表示できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe configmaps game-config-2
</code></pre></div><p>出力結果は以下のようになります:</p>
<pre><code>Name:         game-config-2
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
ui.properties:
----
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
</code></pre><p><code>--from-env-file</code>オプションを利用してConfigMapをenv-fileから作成します。例えば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># Env-filesは環境編集のリストを含んでいます。</span>
<span style=color:#080;font-style:italic># 以下のシンタックスルールが適用されます:</span>
<span style=color:#080;font-style:italic>#   envファイルの各行はVAR=VALの形式である必要がある。</span>
<span style=color:#080;font-style:italic>#   #で始まる行 (例えばコメント)は無視される。</span>
<span style=color:#080;font-style:italic>#   空の行は無視される。</span>
<span style=color:#080;font-style:italic>#   クオーテーションマークは特別な扱いは処理をしない(例えばConfigMapの値の一部になる).</span>

<span style=color:#080;font-style:italic># `configure-pod-container/configmap/`ディレクトリにサンプルファイルをダウンロードします</span>
wget https://kubernetes.io/examples/configmap/game-env-file.properties -O configure-pod-container/configmap/game-env-file.properties

<span style=color:#080;font-style:italic># env-file `game-env-file.properties`は以下のようになります</span>
cat configure-pod-container/configmap/game-env-file.properties
<span style=color:#b8860b>enemies</span><span style=color:#666>=</span>aliens
<span style=color:#b8860b>lives</span><span style=color:#666>=</span><span style=color:#666>3</span>
<span style=color:#b8860b>allowed</span><span style=color:#666>=</span><span style=color:#b44>&#34;true&#34;</span>

<span style=color:#080;font-style:italic># このコメントと上記の空の行は無視されます</span>
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-env-file <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>       --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/game-env-file.properties
</code></pre></div><p>は、以下のConfigMapを生成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmap game-config-env-file -o yaml
</code></pre></div><p>出力結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-12-27T18:36:28Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config-env-file<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;809965&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>d9d1ca5b-eb34-11e7-887b-42010a8002b8<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;&#34;true&#34;&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>enemies</span>:<span style=color:#bbb> </span>aliens<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></code></pre></div><div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <code>--from-env-file</code>を複数回渡してConfigMapを複数のデータソースから作成する場合、最後のenv-fileのみが使用されます。
</div>
<p><code>--from-env-file</code>を複数回渡す場合の挙動は以下のように示されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># `configure-pod-container/configmap/`ディレクトリにサンブルファイルをダウンロードします</span>
wget https://kubernetes.io/examples/configmap/ui-env-file.properties -O configure-pod-container/configmap/ui-env-file.properties

<span style=color:#080;font-style:italic># ConfigMapを作成します</span>
kubectl create configmap config-multi-env-files <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/game-env-file.properties <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>        --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/ui-env-file.properties
</code></pre></div><p>は、以下のConfigMapを生成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmap config-multi-env-files -o yaml
</code></pre></div><p>出力結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-12-27T18:38:34Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-multi-env-files<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;810136&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>252c4572-eb35-11e7-887b-42010a8002b8<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>color</span>:<span style=color:#bbb> </span>purple<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>how</span>:<span style=color:#bbb> </span>fairlyNice<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>textmode</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></code></pre></div><h4 id=ファイルからconfigmap作成する場合は使用するキーを定義する>ファイルからConfigMap作成する場合は使用するキーを定義する</h4>
<p><code>--from-file</code>引数を使用する場合、ConfigMapの<code>data</code> セクションでキーにファイル名以外を定義できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-3 --from-file<span style=color:#666>=</span>&lt;my-key-name&gt;<span style=color:#666>=</span>&lt;path-to-file&gt;
</code></pre></div><p><code>&lt;my-key-name></code>の部分はConfigMapで使うキー、<code>&lt;path-to-file></code> はキーで表示したいデータソースファイルの場所です。</p>
<p>例えば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap game-config-3 --from-file<span style=color:#666>=</span>game-special-key<span style=color:#666>=</span>configure-pod-container/configmap/game.properties
</code></pre></div><p>は、以下のConfigMapを生成します:</p>
<pre><code>kubectl get configmaps game-config-3 -o yaml
</code></pre><p>出力結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T18:54:22Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config-3<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;530&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>05f8da22-d671-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game-special-key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    enemies=aliens
</span><span style=color:#b44;font-style:italic>    lives=3
</span><span style=color:#b44;font-style:italic>    enemies.cheat=true
</span><span style=color:#b44;font-style:italic>    enemies.cheat.level=noGoodRotten
</span><span style=color:#b44;font-style:italic>    secret.code.passphrase=UUDDLRLRBABAS
</span><span style=color:#b44;font-style:italic>    secret.code.allowed=true
</span><span style=color:#b44;font-style:italic>    secret.code.lives=30</span><span style=color:#bbb>    
</span></code></pre></div><h4 id=create-configmaps-from-literal-values>リテラル値からConfigMapを作成する</h4>
<p><code>--from-literal</code>引数を指定して<code>kubectl create configmap</code>を使用すると、コマンドラインからリテラル値を定義できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap special-config --from-literal<span style=color:#666>=</span>special.how<span style=color:#666>=</span>very --from-literal<span style=color:#666>=</span>special.type<span style=color:#666>=</span>charm
</code></pre></div><p>複数のキーバリューペアを渡せます。CLIに提供された各ペアは、ConfigMapの<code>data</code>セクションで別のエントリーとして表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmaps special-config -o yaml
</code></pre></div><p>出力結果は以下のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T19:14:38Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;651&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>dadce046-d673-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.how</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.type</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></code></pre></div><h3 id=ジェネレーターからconfigmapを作成する>ジェネレーターからConfigMapを作成する</h3>
<p><code>kubectl</code>は<code>kustomization.yaml</code>を1.14からサポートしています。
ジェネレーターからConfigMapを作成して適用すると、APIサーバー上でオブジェクトを作成できます。ジェネレーターはディレクトリ内の<code>kustomization.yaml</code>で指定する必要があリます。</p>
<h4 id=ファイルからconfigmapを生成する>ファイルからConfigMapを生成する</h4>
<p>例えば、ファイル<code>configure-pod-container/configmap/game.properties</code>からConfigMapを生成するには、</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># ConfigMapGeneratorを含むkustomization.yamlファイルを作成する</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: game-config-4
</span><span style=color:#b44>  files:
</span><span style=color:#b44>  - configure-pod-container/configmap/game.properties
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>ConfigMapを作成するためにkustomizationディレクトリを適用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
configmap/game-config-4-m9dm2f92bt created
</code></pre></div><p>ConfigMapが作成されたことを以下のようにチェックできます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get configmap
NAME                       DATA   AGE
game-config-4-m9dm2f92bt   <span style=color:#666>1</span>      37s


kubectl describe configmaps/game-config-4-m9dm2f92bt
Name:         game-config-4-m9dm2f92bt
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                <span style=color:#666>{</span><span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;data&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;game.properties&#34;</span>:<span style=color:#b44>&#34;enemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.p...
</span><span style=color:#b44>
</span><span style=color:#b44>Data
</span><span style=color:#b44>====
</span><span style=color:#b44>game.properties:
</span><span style=color:#b44>----
</span><span style=color:#b44>enemies=aliens
</span><span style=color:#b44>lives=3
</span><span style=color:#b44>enemies.cheat=true
</span><span style=color:#b44>enemies.cheat.level=noGoodRotten
</span><span style=color:#b44>secret.code.passphrase=UUDDLRLRBABAS
</span><span style=color:#b44>secret.code.allowed=true
</span><span style=color:#b44>secret.code.lives=30
</span><span style=color:#b44>Events:  &lt;none&gt;
</span></code></pre></div><p>生成されたConfigMapの名前は、コンテンツをハッシュ化したサフィックスを持つことに注意してください。これにより、コンテンツが変更されるたびに新しいConfigMapが生成されます。</p>
<h4 id=ファイルからconfigmapを生成する場合に使用するキーを定義する>ファイルからConfigMapを生成する場合に使用するキーを定義する</h4>
<p>ConfigMapジェネレーターで使用するキーはファイルの名前以外を定義できます。
例えば、ファイル<code>configure-pod-container/configmap/game.properties</code>からキー<code>game-special-key</code>を持つConfigMapを作成する場合</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># ConfigMapGeneratorを含むkustomization.yamlファイルを作成する</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: game-config-5
</span><span style=color:#b44>  files:
</span><span style=color:#b44>  - game-special-key=configure-pod-container/configmap/game.properties
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>kustomizationディレクトリを適用してConfigMapを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
configmap/game-config-5-m67dt67794 created
</code></pre></div><h4 id=リテラルからconfigmapを作成する>リテラルからConfigMapを作成する</h4>
<p>リテラル<code>special.type=charm</code>と<code>special.how=very</code>からConfigMapを作成する場合は、
以下のように<code>kustomization.yaml</code>のConfigMapジェネレーターで指定できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># ConfigMapGeneratorを含むkustomization.yamlファイルを作成します</span>
cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span><span style=color:#b44>configMapGenerator:
</span><span style=color:#b44>- name: special-config-2
</span><span style=color:#b44>  literals:
</span><span style=color:#b44>  - special.how=very
</span><span style=color:#b44>  - special.type=charm
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>kustomizationディレクトリを適用してConfigMapを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
configmap/special-config-2-c92b5mmcf2 created
</code></pre></div><h2 id=configmapデータを使用してコンテナ環境変数を定義する>ConfigMapデータを使用してコンテナ環境変数を定義する</h2>
<h3 id=単一のconfigmapのデータを使用してコンテナ環境変数を定義する>単一のConfigMapのデータを使用してコンテナ環境変数を定義する</h3>
<ol>
<li>
<p>ConfigMapに環境変数をキーバリューペアとして定義します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create configmap special-config --from-literal<span style=color:#666>=</span>special.how<span style=color:#666>=</span>very
</code></pre></div></li>
<li>
<p>ConfigMapに定義された値<code>special.how</code>をPod specificationの環境変数<code>SPECIAL_LEVEL_KEY</code>に割り当てます。</p>
</li>
</ol>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-single-configmap-env-variable.yaml download=pods/pod-single-configmap-env-variable.yaml><code>pods/pod-single-configmap-env-variable.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-single-configmap-env-variable-yaml')" title="Copy pods/pod-single-configmap-env-variable.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-single-configmap-env-variable-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 環境変数を定義します</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:#080;font-style:italic># SPECIAL_LEVEL_KEYに割り当てる値をConfigMapが保持します</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:#080;font-style:italic># 値に紐付けるキーを指定します</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>special.how<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-single-configmap-env-variable.yaml
</code></pre></div><p>すると、Podの出力結果に環境変数<code>SPECIAL_LEVEL_KEY=very</code>が含まれています。</p>
<h3 id=複数のconfigmapのデータを使用してコンテナ環境変数を定義する>複数のConfigMapのデータを使用してコンテナ環境変数を定義する</h3>
<ul>
<li>
<p>先ほどの例の通り、まずはConfigMapを作成します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/configmap/configmaps.yaml download=configmap/configmaps.yaml><code>configmap/configmaps.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('configmap-configmaps-yaml')" title="Copy configmap/configmaps.yaml to clipboard">
</img>
</div>
<div class=includecode id=configmap-configmaps-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.how</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>log_level</span>:<span style=color:#bbb> </span>INFO<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>ConfigMapを作成します:</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/configmap/configmaps.yaml
</code></pre></div><ul>
<li>
<p>Pod specificationの環境変数を定義します</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-multiple-configmap-env-variable.yaml download=pods/pod-multiple-configmap-env-variable.yaml><code>pods/pod-multiple-configmap-env-variable.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-multiple-configmap-env-variable-yaml')" title="Copy pods/pod-multiple-configmap-env-variable.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-multiple-configmap-env-variable-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>special.how<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>LOG_LEVEL<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します:</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-multiple-configmap-env-variable.yaml
</code></pre></div><p>すると、Podの出力結果に環境変数<code>SPECIAL_LEVEL_KEY=very</code> and <code>LOG_LEVEL=INFO</code>が含まれています。</p>
<h2 id=configmapの全てのキーバリューペアをコンテナ環境変数として構成する>ConfigMapの全てのキーバリューペアをコンテナ環境変数として構成する</h2>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> この機能はKubernetes v1.6以降で利用可能です。
</div>
<ul>
<li>
<p>複数のキーバリューペアを含むConfigMapを作成します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/configmap/configmap-multikeys.yaml download=configmap/configmap-multikeys.yaml><code>configmap/configmap-multikeys.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('configmap-configmap-multikeys-yaml')" title="Copy configmap/configmap-multikeys.yaml to clipboard">
</img>
</div>
<div class=includecode id=configmap-configmap-multikeys-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_LEVEL</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_TYPE</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>ConfigMapを作成します:</p>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml
</code></pre></div><ul>
<li><code>envFrom</code>を利用して全てのConfigMapのデータをコンテナ環境変数として定義します。ConfigMapからのキーがPodの環境変数名になります。</li>
</ul>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-configmap-envFrom.yaml download=pods/pod-configmap-envFrom.yaml><code>pods/pod-configmap-envFrom.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-envfrom-yaml')" title="Copy pods/pod-configmap-envFrom.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-envfrom-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMapRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-envFrom.yaml
</code></pre></div><p>すると、Podの出力結果は環境変数<code>SPECIAL_LEVEL=very</code>と<code>SPECIAL_TYPE=charm</code>が含まれています。</p>
<h2 id=podのコマンドでconfigmapに定義した環境変数を使用する>PodのコマンドでConfigMapに定義した環境変数を使用する</h2>
<p>ConfigMapに環境変数を定義し、Pod specificationの<code>command</code> セクションで<code>$(VAR_NAME)</code>Kubernetes置換構文を介して使用できます。</p>
<p>例えば以下のPod specificationは</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-configmap-env-var-valueFrom.yaml download=pods/pod-configmap-env-var-valueFrom.yaml><code>pods/pod-configmap-env-var-valueFrom.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-env-var-valuefrom-yaml')" title="Copy pods/pod-configmap-env-var-valueFrom.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-env-var-valuefrom-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_TYPE_KEY<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_TYPE<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>以下コマンドの実行で作成され、</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-env-var-valueFrom.yaml
</code></pre></div><p><code>test-container</code>コンテナで以下の出力結果を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>very charm
</code></pre></div><h2 id=ボリュームにconfigmapデータを追加する>ボリュームにConfigMapデータを追加する</h2>
<p><a href=#create-configmaps-from-files>ファイルからConfigMapを作成する</a>で説明したように、<code>--from-file</code>を使用してConfigMapを作成する場合は、ファイル名がConfigMapの<code>data</code>セクションに保存されるキーになり、ファイルのコンテンツがキーの値になります。</p>
<p>このセクションの例は以下に示されているspecial-configと名付けれたConfigMapについて言及したものです。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/configmap/configmap-multikeys.yaml download=configmap/configmap-multikeys.yaml><code>configmap/configmap-multikeys.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('configmap-configmap-multikeys-yaml')" title="Copy configmap/configmap-multikeys.yaml to clipboard">
</img>
</div>
<div class=includecode id=configmap-configmap-multikeys-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_LEVEL</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_TYPE</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>ConfigMapを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml
</code></pre></div><h3 id=configmapに保存されているデータをボリュームに入力する>ConfigMapに保存されているデータをボリュームに入力する</h3>
<p>ConfigMap名をPod specificationの<code>volumes</code>セクション配下に追加します。
これによりConfigMapデータが<code>volumeMounts.mountPath</code>で指定されたディレクトリに追加されます (このケースでは、<code>/etc/config</code>に)。<code>command</code>セクションはConfigMapのキーに合致したディレクトリファイルを名前別でリスト表示します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-configmap-volume.yaml download=pods/pod-configmap-volume.yaml><code>pods/pod-configmap-volume.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-volume-yaml')" title="Copy pods/pod-configmap-volume.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-volume-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;ls /etc/config/&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># コンテナに追加するファイルを含むConfigMapの名前を提供する</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume.yaml
</code></pre></div><p>Podが稼働していると、<code>ls /etc/config/</code>は以下の出力結果を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>SPECIAL_LEVEL
SPECIAL_TYPE
</code></pre></div><div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <code>/etc/config/</code>ディレクトリに何かファイルがある場合、それらは削除されます。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> テキストデータはUTF-8文字エンコーディングを使用しているファイルとして公開されます。他の文字エンコーディングを使用する場合は、バイナリデータを使用してください。
</div>
<h3 id=configmapデータをボリュームの特定のパスに追加する>ConfigMapデータをボリュームの特定のパスに追加する</h3>
<p><code>path</code>フィールドを利用して特定のConfigMapのアイテム向けに希望のファイルパスを指定します。
このケースでは<code>SPECIAL_LEVEL</code>アイテムが<code>/etc/config/keys</code>の<code>config-volume</code>ボリュームにマウントされます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/pod-configmap-volume-specific-key.yaml download=pods/pod-configmap-volume-specific-key.yaml><code>pods/pod-configmap-volume-specific-key.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-pod-configmap-volume-specific-key-yaml')" title="Copy pods/pod-configmap-volume-specific-key.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-pod-configmap-volume-specific-key-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#b44>&#34;cat /etc/config/keys&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>keys<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume-specific-key.yaml
</code></pre></div><p>Podが稼働していると、 <code>cat /etc/config/keys</code>は以下の出力結果を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>very
</code></pre></div><div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> 先ほどのように、<code>/etc/config/</code> ディレクトリのこれまでのファイルは全て削除されます
</div>
<h3 id=キーを特定のパスとファイルアクセス許可に投影する>キーを特定のパスとファイルアクセス許可に投影する</h3>
<p>キーをファイル単位で特定のパスとアクセス許可に投影できます。<a href=/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod>Secret</a>のユーザーガイドで構文が解説されています。</p>
<h3 id=マウントされたconfigmapは自動的に更新される>マウントされたConfigMapは自動的に更新される</h3>
<p>ボリュームで使用されているConfigMapが更新されている場合、投影されているキーも同じく結果的に更新されます。kubeletは定期的な同期ごとにマウントされているConfigMapが更新されているかチェックします。しかし、これはローカルのttlを基にしたキャッシュでConfigMapの現在の値を取得しています。その結果、新しいキーがPodに投影されてからConfigMapに更新されるまでのトータルの遅延はkubeletで、kubeletの同期期間(デフォルトで1分) + ConfigMapキャッシュのttl(デフォルトで1分)の長さになる可能性があります。Podのアノテーションを1つ更新すると即時のリフレッシュをトリガーできます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ConfigMapを<a href=/docs/concepts/storage/volumes/#using-subpath>subPath</a>ボリュームとして利用するコンテナはConfigMapの更新を受け取りません。
</div>
<h2 id=configmapとpodsを理解する>ConfigMapとPodsを理解する</h2>
<p>ConfigMap APIリソースは構成情報をキーバリューペアとして保存します。データはPodで利用したり、コントローラーなどのシステムコンポーネントに提供できます。ConfigMapは<a href=/docs/concepts/configuration/secret/>Secret</a>に似ていますが、機密情報を含まない文字列を含まない操作する手段を提供します。ユーザーとシステムコンポーネントはどちらも構成情報をConfigMapに保存できます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ConfigMapはプロパティーファイルを参照するべきであり、置き換えるべきではありません。ConfigMapをLinuxの<code>/etc</code>ディレクトリとそのコンテンツのように捉えましょう。例えば、<a href=/docs/concepts/storage/volumes/>Kubernetes Volume</a>をConfigMapから作成した場合、ConfigMapのデータアイテムはボリューム内で個別のファイルとして表示されます。
</div>
<p>ConfigMapの<code>data</code>フィールドは構成情報を含みます。下記の例のように、シンプルに個別のプロパティーを<code>--from-literal</code>で定義、または複雑に構成ファイルまたはJSON blobsを<code>--from-file</code>で定義できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T19:14:38Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-config<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># --from-literalを使用してシンプルにプロパティーを定義する例</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.1</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.2</span>:<span style=color:#bbb> </span>world<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># --from-fileを使用して複雑にプロパティーを定義する例</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.file</span>:<span style=color:#bbb> </span>|-<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    property.1=value-1
</span><span style=color:#b44;font-style:italic>    property.2=value-2
</span><span style=color:#b44;font-style:italic>    property.3=value-3</span><span style=color:#bbb>    
</span></code></pre></div><h3 id=制限事項>制限事項</h3>
<ul>
<li>
<p>ConfigMapはPod specificationを参照させる前に作成する必要があります(ConfigMapを"optional"として設定しない限り)。存在しないConfigMapを参照させた場合、Podは起動しません。同様にConfigMapに存在しないキーを参照させた場合も、Podは起動しません。</p>
</li>
<li>
<p>ConfigMapで<code>envFrom</code>を使用して環境変数を定義した場合、無効と判断されたキーはスキップされます。Podは起動されますが、無効な名前はイベントログに(<code>InvalidVariableNames</code>)と記録されます。ログメッセージはスキップされたキーごとにリスト表示されます。例えば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get events
</code></pre></div><p>出力結果は以下のようになります:</p>
<pre><code>LASTSEEN FIRSTSEEN COUNT NAME          KIND  SUBOBJECT  TYPE      REASON                            SOURCE                MESSAGE
0s       0s        1     dapi-test-pod Pod              Warning   InvalidEnvironmentVariableNames   {kubelet, 127.0.0.1}  Keys [1badkey, 2alsobad] from the EnvFrom configMap default/myconfig were skipped since they are considered invalid environment variable names.
</code></pre></li>
<li>
<p>ConfigMapは特定の<a class=glossary-tooltip title=同一の物理クラスター上で複数の仮想クラスターをサポートするために使われる抽象概念です。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=Namespace>Namespace</a>に属します。ConfigMapは同じ名前空間に属するPodからのみ参照できます。</p>
</li>
<li>
<p><a class=glossary-tooltip title="A pod managed directly by the kubelet daemon on a specific node." data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label="static pods">static pods</a>はKubeletがサポートしていないため、ConfigMapに使用できません。</p>
</li>
</ul>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>実践例<a href=/ja/docs/tutorials/configuration/configure-redis-using-configmap/>ConfigMapを使ったRedisの設定</a>を続けて読む。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-3d7b9cb24a647c36ba63f7a02ec49010>2.12 - Pod内のコンテナ間でプロセス名前空間を共有する</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code>
</div>
<p>このページでは、プロセス名前空間を共有するPodを構成する方法を示します。
プロセス名前空間の共有が有効になっている場合、コンテナ内のプロセスは、そのPod内の他のすべてのコンテナに表示されます。</p>
<p>この機能を使用して、ログハンドラーサイドカーコンテナなどの協調コンテナを構成したり、シェルなどのデバッグユーティリティを含まないコンテナイメージをトラブルシューティングしたりできます。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.10.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=podを構成する>Podを構成する</h2>
<p>プロセス名前空間の共有は、<code>v1.PodSpec</code>の<code>shareProcessNamespace</code>フィールドを使用して有効にします。
例:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/share-process-namespace.yaml download=pods/share-process-namespace.yaml><code>pods/share-process-namespace.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-share-process-namespace-yaml')" title="Copy pods/share-process-namespace.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-share-process-namespace-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>shareProcessNamespace</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>capabilities</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>add</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- SYS_PTRACE<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stdin</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tty</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>クラスターにPod <code>nginx</code>を作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/share-process-namespace.yaml
</code></pre></div></li>
<li>
<p><code>shell</code>コンテナにアタッチして<code>ps</code>を実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl attach -it nginx -c shell
</code></pre></div><p>コマンドプロンプトが表示されない場合は、Enterキーを押してみてください。</p>
<pre><code>/ # ps ax
PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    8 root      0:00 nginx: master process nginx -g daemon off;
   14 101       0:00 nginx: worker process
   15 root      0:00 sh
   21 root      0:00 ps ax
</code></pre></li>
</ol>
<p>他のコンテナのプロセスにシグナルを送ることができます。
たとえば、ワーカープロセスを再起動するには、<code>SIGHUP</code>をnginxに送信します。
この操作には<code>SYS_PTRACE</code>機能が必要です。</p>
<pre><code>/ # kill -HUP 8
/ # ps ax
PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    8 root      0:00 nginx: master process nginx -g daemon off;
   15 root      0:00 sh
   22 101       0:00 nginx: worker process
   23 root      0:00 ps ax
</code></pre><p><code>/proc/$pid/root</code>リンクを使用して別のコンテナイメージにアクセスすることもできます。</p>
<pre><code>/ # head /proc/8/root/etc/nginx/nginx.conf

user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
</code></pre>
<h2 id=プロセス名前空間の共有について理解する>プロセス名前空間の共有について理解する</h2>
<p>Podは多くのリソースを共有するため、プロセスの名前空間も共有することになります。
ただし、一部のコンテナイメージは他のコンテナから分離されることが期待されるため、これらの違いを理解することが重要です:</p>
<ol>
<li>
<p><strong>コンテナプロセスは PID 1ではなくなります。</strong>
一部のコンテナイメージは、PID 1なしで起動することを拒否し(たとえば、<code>systemd</code>を使用するコンテナ)、<code>kill -HUP 1</code>などのコマンドを実行してコンテナプロセスにシグナルを送信します。
共有プロセス名前空間を持つPodでは、<code>kill -HUP 1</code>はPodサンドボックスにシグナルを送ります。(上の例では<code>/pause</code>)</p>
</li>
<li>
<p><strong>プロセスはPod内の他のコンテナに表示されます。</strong>
これには、引数または環境変数として渡されたパスワードなど、<code>/proc</code>に表示されるすべての情報が含まれます。
これらは、通常のUnixアクセス許可によってのみ保護されます。</p>
</li>
<li>
<p><strong>コンテナファイルシステムは、<code>/proc/$pid/root</code>リンクを介してPod内の他のコンテナに表示されます。</strong>
これによりデバッグが容易になりますが、ファイルシステム内の秘密情報はファイルシステムのアクセス許可によってのみ保護されることも意味します。</p>
</li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-42a59b878d4c58e5c6f4bb87483dda93>2.13 - static Podを作成する</h1>
<p><em>Static Pod</em>とは、<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=APIサーバー>APIサーバー</a>が監視せず、特定のノード上のkubeletデーモンによって直接管理されるPodです。コントロールプレーンに管理されるPod(たとえば<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>など)とは異なり、kubeletがそれぞれのstatic Podを監視(および障害時には再起動)します。</p>
<p>Static Podは、常に特定のノード上の1つの<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>に紐付けられます。</p>
<p>kubeletは、各static Podに対して、自動的にKubernetes APIサーバー上に<a class=glossary-tooltip title="kubelet上のstatic Podを追跡するAPIサーバー内のオブジェクトです。" data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-mirror-pod" target=_blank aria-label=ミラーPod>ミラーPod</a>の作成を試みます。つまり、ノード上で実行中のPodはAPIサーバーから検出されますが、APIサーバー自身から制御されることはないということです。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 複数ノードからなるKubernetesクラスターを実行していて、Podをすべてのノード上で実行するためにstatic Podを使用している場合、おそらくstatic Podの代わりに<a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>を使用するべきでしょう。
</div>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>このページの説明では、Podを実行するために<a class=glossary-tooltip title=Dockerは、コンテナとして知られる、オペレーティングシステムレベルでの仮想化を提供するソフトウェア技術です。 data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>を使用しており、ノード上のOSがFedoraであることを前提としています。他のディストリビューションやKubernetesのインストール方法によっては、操作が異なる場合があります。</p>
<h2 id=static-pod-creation>static Podを作成する</h2>
<p>static Podは、<a href=#configuration-files>ファイルシステム上でホストされた設定ファイル</a>または<a href=/#pods-created-via-http>ウェブ上でホストされた設定ファイル</a>を使用して設定できます。</p>
<h3 id=configuration-files>ファイルシステム上でホストされたstatic Podマニフェスト</h3>
<p>マニフェストは、JSONまたはYAML形式の標準のPod定義で、特定のディレクトリに置きます。<a href=/docs/tasks/administer-cluster/kubelet-config-file>kubeletの設定ファイル</a>の中で、<code>staticPodPath: &lt;ディレクトリの場所></code>というフィールドを使用すると、kubeletがこのディレクトリを定期的にスキャンして、YAML/JSONファイルが作成/削除されるたびに、static Podの作成/削除が行われるようになります。指定したディレクトリをスキャンする際、kubeletはドットから始まる名前のファイルを無視することに注意してください。</p>
<p>例として、単純なウェブサーバーをstatic Podとして実行する方法を示します。</p>
<ol>
<li>
<p>static Podを実行したいノードを選択します。この例では、<code>my-node1</code>です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ssh my-node1
</code></pre></div></li>
<li>
<p>ディレクトリを選び(ここでは<code>/etc/kubelet.d</code>とします)、ここにウェブサーバーのPodの定義を置きます。たとえば、<code>/etc/kubelet.d/static-web.yaml</code>に置きます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、kubeletが実行中のノード上で実行してください</span>
mkdir /etc/kubelet.d/
cat <span style=color:#b44>&lt;&lt;EOF &gt;/etc/kubelet.d/static-web.yaml
</span><span style=color:#b44>apiVersion: v1
</span><span style=color:#b44>kind: Pod
</span><span style=color:#b44>metadata:
</span><span style=color:#b44>  name: static-web
</span><span style=color:#b44>  labels:
</span><span style=color:#b44>    role: myrole
</span><span style=color:#b44>spec:
</span><span style=color:#b44>  containers:
</span><span style=color:#b44>    - name: web
</span><span style=color:#b44>      image: nginx
</span><span style=color:#b44>      ports:
</span><span style=color:#b44>        - name: web
</span><span style=color:#b44>          containerPort: 80
</span><span style=color:#b44>          protocol: TCP
</span><span style=color:#b44>EOF</span>
</code></pre></div></li>
<li>
<p>ノード上のkubeletがこのディレクトリを使用するようにするために、<code>--pod-manifest-path=/etc/kubelet.d/</code>引数を付けてkubeletを実行するように設定します。Fedoraの場合、次の行が含まれるように<code>/etc/kubernetes/kubelet</code>を編集します。</p>
<pre><code>KUBELET_ARGS=&quot;--cluster-dns=10.254.0.10 --cluster-domain=kube.local --pod-manifest-path=/etc/kubelet.d/&quot;
</code></pre><p>あるいは、<a href=/docs/tasks/administer-cluster/kubelet-config-file>kubeletの設定ファイル</a>に、<code>staticPodPath: &lt;ディレクトリの場所></code>フィールドを追加することでも設定できます。</p>
</li>
<li>
<p>kubeletを再起動します。Fedoraの場合、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、kubeletが実行中のノード上で実行してください</span>
systemctl restart kubelet
</code></pre></div></li>
</ol>
<h3 id=pods-created-via-http>ウェブ上でホストされたstatic Podマニフェスト</h3>
<p>kubeletは、<code>--manifest-url=&lt;URL></code>引数で指定されたファイルを定期的にダウンロードし、Podの定義が含まれたJSON/YAMLファイルとして解釈します。kubeletは、<a href=#configuration-files>ファイルシステム上でホストされたマニフェスト</a>での動作方法と同じように、定期的にマニフェストを再取得します。static Podのリスト中に変更が見つかると、kubeletがその変更を適用します。</p>
<p>このアプローチを採用する場合、次のように設定します。</p>
<ol>
<li>
<p>YAMLファイルを作成し、kubeletにファイルのURLを渡せるようにするために、ウェブサーバー上に保存する。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>static-web<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>myrole<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></code></pre></div></li>
<li>
<p>選択したノード上のkubeletを<code>--manifest-url=&lt;manifest-url></code>を使用して実行することで、このウェブ上のマニフェストを使用するように設定する。Fedoraの場合、<code>/etc/kubernetes/kubelet</code>に次の行が含まれるように編集します。</p>
<pre><code>KUBELET_ARGS=&quot;--cluster-dns=10.254.0.10 --cluster-domain=kube.local --manifest-url=&lt;マニフェストのURL&quot;
</code></pre></li>
<li>
<p>kubeletを再起動する。Fedoraの場合、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、kubeletが実行中のノード上で実行してください</span>
systemctl restart kubelet
</code></pre></div></li>
</ol>
<h2 id=behavior-of-static-pods>static Podの動作を観察する</h2>
<p>kubeletが起動すると、定義されたすべてのstatic Podを起動します。ここまででstatic Podを設定してkubeletを再起動したため、すでに新しいstatic Podが実行中になっているはずです。</p>
<p>次のコマンドを(ノード上で)実行することで、(static Podを含む)実行中のコンテナを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、kubeletが実行中のノード上で実行してください</span>
docker ps
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>CONTAINER ID IMAGE         COMMAND  CREATED        STATUS         PORTS     NAMES
f6d05272b57e nginx:latest  &quot;nginx&quot;  8 minutes ago  Up 8 minutes             k8s_web.6f802af4_static-web-fk-node1_default_67e24ed9466ba55986d120c867395f3c_378e5f3c
</code></pre><p>APIサーバー上では、ミラーPodを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME                       READY     STATUS    RESTARTS   AGE
static-web-my-node1        1/1       Running   0          2m
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> kubeletにAPIサーバー上のミラーPodを作成する権限があることを確認してください。もし権限がない場合、APIサーバーによって作成のリクエストが拒否されてしまいます。詳しくは、<a href=/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>を参照してください。
</div>
<p>static Podに付けた<a class=glossary-tooltip title=ユーザーにとって意味があり関連性のある識別属性を、オブジェクトにタグ付けするものです。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=ラベル>ラベル</a>はミラーPodに伝搬します。ミラーPodに付けたラベルは、通常のPodと同じように<a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=セレクター>セレクター</a>などから利用できます。</p>
<p>もし<code>kubectl</code>を使用してAPIサーバーからミラーPodを削除しようとしても、kubeletはstatic Podを削除<em>しません</em>。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod static-web-my-node1
</code></pre></div><pre><code>pod &quot;static-web-my-node1&quot; deleted
</code></pre><p>Podはまだ実行中であることがわかります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><pre><code>NAME                       READY     STATUS    RESTARTS   AGE
static-web-my-node1        1/1       Running   0          12s
</code></pre><p>kubeletが実行中のノードに戻り、Dockerコンテナを手動で停止してみることができます。しばらくすると、kubeletが変化に気づき、Podを自動的に再起動することがわかります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドは、kubeletが実行中のノード上で実行してください</span>
docker stop f6d05272b57e <span style=color:#080;font-style:italic># 実際のコンテナIDと置き換えてください</span>
sleep <span style=color:#666>20</span>
docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE         COMMAND                CREATED       ...
5b920cbaf8b1        nginx:latest  &quot;nginx -g 'daemon of   2 seconds ago ...
</code></pre><h2 id=static-podの動的な追加と削除>static Podの動的な追加と削除</h2>
<p>実行中のkubeletは設定ディレクトリ(この例では<code>/etc/kubelet.d</code>)の変更を定期的にスキャンし、このディレクトリ内にファイルが追加/削除されると、Podの追加/削除を行います。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># This assumes you are using filesystem-hosted static Pod configuration</span>
<span style=color:#080;font-style:italic># このコマンドは、kubeletが実行中のノード上で実行してください</span>
<span style=color:#080;font-style:italic>#</span>
mv /etc/kubelet.d/static-web.yaml /tmp
sleep <span style=color:#666>20</span>
docker ps
<span style=color:#080;font-style:italic># You see that no nginx container is running</span>
mv /tmp/static-web.yaml  /etc/kubelet.d/
sleep <span style=color:#666>20</span>
docker ps
</code></pre></div><pre><code>CONTAINER ID        IMAGE         COMMAND                CREATED           ...
e7a62e3427f1        nginx:latest  &quot;nginx -g 'daemon of   27 seconds ago
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-34a810f1516ad9d99b2697e36e9b0d0f>3 - クラスターの管理</h1>
<div class=lead>クラスターの管理のための一般的なタスクについて学びます。</div>
</div>
<div class=td-content>
<h1 id=pg-adb489b1ab985c9215657b0d4c6ae92b>3.1 - Namespaceに対する最小および最大メモリー制約の構成</h1>
<p>このページでは、Namespaceで実行されるコンテナが使用するメモリーの最小値と最大値を設定する方法を説明します。
<a href=/docs/reference/generated/kubernetes-api/v1.22/#limitrange-v1-core>LimitRange</a> で最小値と最大値のメモリー値を指定します。
PodがLimitRangeによって課される制約を満たさない場合、そのNamespaceではPodを作成できません。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>クラスター内の各ノードには、少なくとも1GiBのメモリーが必要です。</p>
<h2 id=namespaceの作成>Namespaceの作成</h2>
<p>この演習で作成したリソースがクラスターの他の部分から分離されるように、Namespaceを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create namespace constraints-mem-example
</code></pre></div><h2 id=limitrangeとpodを作成>LimitRangeとPodを作成</h2>
<p>LimitRangeの設定ファイルです。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/resource/memory-constraints.yaml download=admin/resource/memory-constraints.yaml><code>admin/resource/memory-constraints.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-yaml')" title="Copy admin/resource/memory-constraints.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mem-min-max-demo-lr<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>500Mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>LimitRangeを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><p>LimitRangeの詳細情報を表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get limitrange mem-min-max-demo-lr --namespace<span style=color:#666>=</span>constraints-mem-example --output<span style=color:#666>=</span>yaml
</code></pre></div><p>出力されるのは、予想通りメモリー制約の最小値と最大値を示しています。
しかし、LimitRangeの設定ファイルでデフォルト値を指定していないにもかかわらず、
自動的に作成されていることに気づきます。</p>
<pre><code>  limits:
  - default:
      memory: 1Gi
    defaultRequest:
      memory: 1Gi
    max:
      memory: 1Gi
    min:
      memory: 500Mi
    type: Container
</code></pre><p>constraints-mem-exampleNamespaceにコンテナが作成されるたびに、
Kubernetesは以下の手順を実行するようになっています。</p>
<ul>
<li>
<p>コンテナが独自のメモリー要求と制限を指定しない場合は、デフォルトのメモリー要求と制限をコンテナに割り当てます。</p>
</li>
<li>
<p>コンテナに500MiB以上のメモリー要求があることを確認します。</p>
</li>
<li>
<p>コンテナのメモリー制限が1GiB以下であることを確認します。</p>
</li>
</ul>
<p>以下は、1つのコンテナを持つPodの設定ファイルです。設定ファイルのコンテナ(containers)では、600MiBのメモリー要求と800MiBのメモリー制限が指定されています。これらはLimitRangeによって課される最小と最大のメモリー制約を満たしています。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/resource/memory-constraints-pod.yaml download=admin/resource/memory-constraints-pod.yaml><code>admin/resource/memory-constraints-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-pod-yaml')" title="Copy admin/resource/memory-constraints-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;600Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podの作成</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><p>Podのコンテナが実行されていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod constraints-mem-demo --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><p>Podの詳細情報を見ます</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod constraints-mem-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><p>出力は、コンテナが600MiBのメモリ要求と800MiBのメモリー制限になっていることを示しています。これらはLimitRangeによって課される制約を満たしています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>800Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>600Mi<span style=color:#bbb>
</span></code></pre></div><p>Podを消します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod constraints-mem-demo --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><h2 id=最大メモリ制約を超えるpodの作成の試み>最大メモリ制約を超えるPodの作成の試み</h2>
<p>これは、1つのコンテナを持つPodの設定ファイルです。コンテナは800MiBのメモリー要求と1.5GiBのメモリー制限を指定しています。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/resource/memory-constraints-pod-2.yaml download=admin/resource/memory-constraints-pod-2.yaml><code>admin/resource/memory-constraints-pod-2.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-pod-2-yaml')" title="Copy admin/resource/memory-constraints-pod-2.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-pod-2-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-2-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1.5Gi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成してみます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-2.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><p>出力は、コンテナが大きすぎるメモリー制限を指定しているため、Podが作成されないことを示しています。</p>
<pre><code>Error from server (Forbidden): error when creating &quot;examples/admin/resource/memory-constraints-pod-2.yaml&quot;:
pods &quot;constraints-mem-demo-2&quot; is forbidden: maximum memory usage per Container is 1Gi, but limit is 1536Mi.
</code></pre><h2 id=最低限のメモリ要求を満たさないpodの作成の試み>最低限のメモリ要求を満たさないPodの作成の試み</h2>
<p>これは、1つのコンテナを持つPodの設定ファイルです。コンテナは100MiBのメモリー要求と800MiBのメモリー制限を指定しています。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/resource/memory-constraints-pod-3.yaml download=admin/resource/memory-constraints-pod-3.yaml><code>admin/resource/memory-constraints-pod-3.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-pod-3-yaml')" title="Copy admin/resource/memory-constraints-pod-3.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-pod-3-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-3<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-3-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成してみます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-3.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><p>出力は、コンテナが小さすぎるメモリー要求を指定しているため、Podが作成されないことを示しています。</p>
<pre><code>Error from server (Forbidden): error when creating &quot;examples/admin/resource/memory-constraints-pod-3.yaml&quot;:
pods &quot;constraints-mem-demo-3&quot; is forbidden: minimum memory usage per Container is 500Mi, but request is 100Mi.
</code></pre><h2 id=メモリ要求や制限を指定しないpodの作成>メモリ要求や制限を指定しないPodの作成</h2>
<p>これは、1つのコンテナを持つPodの設定ファイルです。コンテナはメモリー要求を指定しておらず、メモリー制限も指定していません。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/resource/memory-constraints-pod-4.yaml download=admin/resource/memory-constraints-pod-4.yaml><code>admin/resource/memory-constraints-pod-4.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-resource-memory-constraints-pod-4-yaml')" title="Copy admin/resource/memory-constraints-pod-4.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-resource-memory-constraints-pod-4-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-4<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-4-ctr<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-4.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</code></pre></div><p>Podの詳細情報を見ます</p>
<pre><code>kubectl get pod constraints-mem-demo-4 --namespace=constraints-mem-example --output=yaml
</code></pre><p>出力を見ると、Podのコンテナのメモリ要求は1GiB、メモリー制限は1GiBであることがわかります。
コンテナはどのようにしてこれらの値を取得したのでしょうか？</p>
<pre><code>resources:
  limits:
    memory: 1Gi
  requests:
    memory: 1Gi
</code></pre><p>コンテナが独自のメモリー要求と制限を指定していなかったため、LimitRangeから与えられのです。
コンテナが独自のメモリー要求と制限を指定していなかったため、LimitRangeから<a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>デフォルトのメモリー要求と制限</a>が与えられたのです。</p>
<p>この時点で、コンテナは起動しているかもしれませんし、起動していないかもしれません。このタスクの前提条件は、ノードが少なくとも1GiBのメモリーを持っていることであることを思い出してください。それぞれのノードが1GiBのメモリーしか持っていない場合、どのノードにも1GiBのメモリー要求に対応するのに十分な割り当て可能なメモリーがありません。たまたま2GiBのメモリーを持つノードを使用しているのであれば、おそらく1GiBのメモリーリクエストに対応するのに十分なスペースを持っていることになります。</p>
<p>Podを削除します。</p>
<pre><code>kubectl delete pod constraints-mem-demo-4 --namespace=constraints-mem-example
</code></pre><h2 id=最小および最大メモリー制約の強制>最小および最大メモリー制約の強制</h2>
<p>LimitRangeによってNamespaceに課される最大および最小のメモリー制約は、Podが作成または更新されたときにのみ適用されます。LimitRangeを変更しても、以前に作成されたPodには影響しません。</p>
<h2 id=最小-最大メモリー制約の動機>最小・最大メモリー制約の動機</h2>
<p>クラスター管理者としては、Podが使用できるメモリー量に制限を課したいと思うかもしれません。</p>
<p>例:</p>
<ul>
<li>
<p>クラスター内の各ノードは2GBのメモリーを持っています。クラスタ内のどのノードもその要求をサポートできないため、2GB以上のメモリーを要求するPodは受け入れたくありません。</p>
</li>
<li>
<p>クラスターは運用部門と開発部門で共有されています。 本番用のワークロードでは最大8GBのメモリーを消費しますが、開発用のワークロードでは512MBに制限したいとします。本番用と開発用に別々のNamespaceを作成し、それぞれのNamespaceにメモリー制限を適用します。</p>
</li>
</ul>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>Namespaceを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete namespace constraints-mem-example
</code></pre></div><h2 id=次の項目>次の項目</h2>
<h3 id=クラスター管理者向け>クラスター管理者向け</h3>
<ul>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>名前空間に対するデフォルトのメモリー要求と制限の構成</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>名前空間に対するデフォルトのCPU要求と制限の構成</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>名前空間に対する最小および最大CPU制約の構成</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>名前空間に対するメモリーとCPUのクォータの構成</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>名前空間に対するPodクォータの設定</a></p>
</li>
<li>
<p><a href=/docs/tasks/administer-cluster/quota-api-object/>APIオブジェクトのクォータの設定</a></p>
</li>
</ul>
<h3 id=アプリケーション開発者向け>アプリケーション開発者向け</h3>
<ul>
<li>
<p><a href=/docs/tasks/configure-pod-container/assign-memory-resource/>コンテナとPodへのメモリーリソースの割り当て</a></p>
</li>
<li>
<p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>コンテナとPodへのCPUリソースの割り当て</a></p>
</li>
<li>
<p><a href=/docs/tasks/configure-pod-container/quality-service-pod/>PodのQoS(サービス品質)を設定</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9133578f1e75663bb031e5a377ca896d>3.2 - Windowsノードの追加</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>Kubernetesを使用してLinuxノードとWindowsノードを混在させて実行できるため、Linuxで実行するPodとWindowsで実行するPodを混在させることができます。このページでは、Windowsノードをクラスターに登録する方法を示します。</p>
<h2 id=始める前に>始める前に</h2>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: 1.17.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
<ul>
<li>
<p>WindowsコンテナをホストするWindowsノードを構成するには、<a href=https://www.microsoft.com/en-us/cloud-platform/windows-server-pricing>Windows Server 2019ライセンス</a>(またはそれ以上)を取得します。
VXLAN/オーバーレイネットワークを使用している場合は、<a href=https://support.microsoft.com/help/4489899>KB4489899</a>もインストールされている必要があります。</p>
</li>
<li>
<p>コントロールプレーンにアクセスできるLinuxベースのKubernetes kubeadmクラスター(<a href=/ja/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>kubeadmを使用したシングルコントロールプレーンクラスターの作成</a>を参照)</p>
</li>
</ul>
<h2 id=目標>目標</h2>
<ul>
<li>Windowsノードをクラスターに登録する</li>
<li>LinuxとWindowsのPodとServiceが相互に通信できるようにネットワークを構成する</li>
</ul>
<h2 id=はじめに-クラスターへのwindowsノードの追加>はじめに: クラスターへのWindowsノードの追加</h2>
<h3 id=ネットワーク構成>ネットワーク構成</h3>
<p>LinuxベースのKubernetesコントロールプレーンノードを取得したら、ネットワーキングソリューションを選択できます。このガイドでは、簡単にするためにVXLANモードでのFlannelの使用について説明します。</p>
<h4 id=flannel構成>Flannel構成</h4>
<ol>
<li>
<p>FlannelのためにKubernetesコントロールプレーンを準備する</p>
<p>クラスター内のKubernetesコントロールプレーンでは、多少の準備が推奨されます。Flannelを使用する場合は、iptablesチェーンへのブリッジIPv4トラフィックを有効にすることをお勧めします。すべてのLinuxノードで次のコマンドを実行する必要があります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo sysctl net.bridge.bridge-nf-call-iptables<span style=color:#666>=</span><span style=color:#666>1</span>
</code></pre></div></li>
<li>
<p>Linux用のFlannelをダウンロードして構成する</p>
<p>最新のFlannelマニフェストをダウンロード:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
</code></pre></div><p>VNIを4096、ポートを4789に設定するために、flannelマニフェストの<code>net-conf.json</code>セクションを変更します。次のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span>net-conf.json:</span> <span>|</span>
    {
      <span style=color:green;font-weight:700>&#34;Network&#34;</span>: <span style=color:#b44>&#34;10.244.0.0/16&#34;</span>,
      <span style=color:green;font-weight:700>&#34;Backend&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;Type&#34;</span>: <span style=color:#b44>&#34;vxlan&#34;</span>,
        <span style=color:green;font-weight:700>&#34;VNI&#34;</span> : <span style=color:#666>4096</span>,
        <span style=color:green;font-weight:700>&#34;Port&#34;</span>: <span style=color:#666>4789</span>
      }
    }
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Linux上のFlannelがWindows上のFlannelと相互運用するには、VNIを4096およびポート4789に設定する必要があります。これらのフィールドの説明については、<a href=https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan>VXLANドキュメント</a>を参照してください。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> L2Bridge/Host-gatewayモードを使用するには、代わりに<code>Type</code>の値を<code>"host-gw"</code>に変更し、<code>VNI</code>と<code>Port</code>を省略します。
</div>
</li>
<li>
<p>Flannelマニフェストを適用して検証する</p>
<p>Flannelの構成を適用しましょう:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl apply -f kube-flannel.yml
</code></pre></div><p>数分後、Flannel Podネットワークがデプロイされていれば、すべてのPodが実行されていることがわかります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get pods -n kube-system
</code></pre></div><p>出力結果には、実行中のLinux flannel DaemonSetが含まれているはずです:</p>
<pre><code>NAMESPACE     NAME                                      READY        STATUS    RESTARTS   AGE
...
kube-system   kube-flannel-ds-54954                     1/1          Running   0          1m
</code></pre></li>
<li>
<p>Windows Flannelとkube-proxy DaemonSetを追加する</p>
<p>これで、Windows互換バージョンのFlannelおよびkube-proxyを追加できます。
互換性のあるバージョンのkube-proxyを確実に入手するには、イメージのタグを置換する必要があります。
次の例は、Kubernetesv1.22.16の使用方法を示していますが、
独自のデプロイに合わせてバージョンを調整する必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/kube-proxy.yml | sed <span style=color:#b44>&#39;s/VERSION/v1.22.16/g&#39;</span> | kubectl apply -f -
kubectl apply -f https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-overlay.yml
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ホストゲートウェイを使用している場合は、代わりに <a href=https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-host-gw.yml>https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-host-gw.yml</a> を使用してください。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p>Windowsノードでイーサネット(「Ethernet0 2」など)ではなく別のインターフェースを使用している場合は、次の行を変更する必要があります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>wins <span style=color:#a2f>cli </span><span style=color:#a2f;font-weight:700>process</span> run --path /k/flannel/setup.exe --args <span style=color:#b44>&#34;--mode=overlay --interface=Ethernet&#34;</span>
</code></pre></div><p><code>flannel-host-gw.yml</code>または<code>flannel-overlay.yml</code>ファイルで、それに応じてインターフェースを指定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#080;font-style:italic># 例</span>
curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/flannel-overlay.yml | sed <span style=color:#b44>&#39;s/Ethernet/Ethernet0 2/g&#39;</span> | kubectl apply -f -
</code></pre></div>
</div>
</li>
</ol>
<h3 id=windowsワーカーノードの参加>Windowsワーカーノードの参加</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>Containers</code>機能をインストールし、Dockerをインストールする必要があります。
行うための指示としては、<a href=https://docs.mirantis.com/docker-enterprise/v3.1/dockeree-products/docker-engine-enterprise/dee-windows.html>Dockerエンジンのインストール - Windowsサーバー上のエンタープライズ</a>を利用できます。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Windowsセクションのすべてのコードスニペットは、
Windowsワーカーノードの(管理者)権限を持つPowerShell環境で実行されます。
</div>
<ol>
<li>
<p>wins、kubelet、kubeadmをインストールします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell>curl.exe -LO https<span>:</span>//raw.githubusercontent.com/<span style=color:#a2f>kubernetes-sigs</span>/<span style=color:#a2f>sig-windows</span>-tools/master/kubeadm/scripts/PrepareNode.ps1
.\PrepareNode.ps1 -KubernetesVersion <span style=color:#a2f>
</code></pre></div></li>
<li>
<p><code>kubeadm</code>を実行してノードに参加します</p>
<p>コントロールプレーンホストで<code>kubeadm init</code>を実行したときに提供されたコマンドを使用します。
このコマンドがなくなった場合、またはトークンの有効期限が切れている場合は、<code>kubeadm token create --print-join-command</code>
(コントロールプレーンホスト上で)を実行して新しいトークンを生成します。</p>
</li>
</ol>
<h4 id=インストールの確認>インストールの確認</h4>
<p>次のコマンドを実行して、クラスター内のWindowsノードを表示できるようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>kubectl get nodes -o wide
</code></pre></div><p>新しいノードが<code>NotReady</code>状態の場合は、flannelイメージがまだダウンロード中の可能性があります。
<code>kube-system</code>名前空間のflannel Podを確認することで、以前と同様に進行状況を確認できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl -n kube-system get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>flannel
</code></pre></div><p>flannel Podが実行されると、ノードは<code>Ready</code>状態になり、ワークロードを処理できるようになります。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/administer-cluster/kubeadm/upgrading-windows-nodes>Windows kubeadmノードのアップグレード</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e805c7d8d4ad6195cb82dbbc843bfc29>3.3 - Windowsノードのアップグレード</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>このページでは、<a href=/docs/tasks/administer-cluster/kubeadm/adding-windows-nodes>kubeadmで作られた</a>Windowsノードをアップグレードする方法について説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: 1.17.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<ul>
<li><a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade>残りのkubeadmクラスターをアップグレードするプロセス</a>を理解します。
Windowsノードをアップグレードする前にコントロールプレーンノードをアップグレードしたいと思うかもしれません。</li>
</ul>
<h2 id=ワーカーノードをアップグレード>ワーカーノードをアップグレード</h2>
<h3 id=kubeadmをアップグレード>kubeadmをアップグレード</h3>
<ol>
<li>
<p>Windowsノードから、kubeadmをアップグレードします。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#080;font-style:italic># v1.22.16を目的のバージョンに置き換えます</span>
curl.exe -Lo C:\k\kubeadm.exe https<span>:</span>//dl.k8s.io/<span style=color:#a2f>/bin/windows/amd64/kubeadm.exe
</code></pre></div></li>
</ol>
<h3 id=ノードをドレインする>ノードをドレインする</h3>
<ol>
<li>
<p>Kubernetes APIにアクセスできるマシンから、
ノードをスケジュール不可としてマークして、ワークロードを削除することでノードのメンテナンスを準備します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;をドレインするノードの名前に置き換えます</span>
kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets
</code></pre></div><p>このような出力結果が表示されるはずです:</p>
<pre><code>node/ip-172-31-85-18 cordoned
node/ip-172-31-85-18 drained
</code></pre></li>
</ol>
<h3 id=kubeletの構成をアップグレード>kubeletの構成をアップグレード</h3>
<ol>
<li>
<p>Windowsノードから、次のコマンドを呼び出して新しいkubelet構成を同期します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell>kubeadm upgrade node
</code></pre></div></li>
</ol>
<h3 id=kubeletをアップグレード>kubeletをアップグレード</h3>
<ol>
<li>
<p>Windowsノードから、kubeletをアップグレードして再起動します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=color:#a2f>stop-service</span> kubelet
curl.exe -Lo C:\k\kubelet.exe https<span>:</span>//dl.k8s.io/<span style=color:#a2f>/bin/windows/amd64/kubelet.exe
<span style=color:#a2f>restart-service</span> kubelet
</code></pre></div></li>
</ol>
<h3 id=ノードをオンライン状態に>ノードをオンライン状態に</h3>
<ol>
<li>
<p>Kubernetes APIにアクセスできるマシンから、
スケジュール可能としてマークして、ノードをオンラインに戻します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># &lt;node-to-drain&gt;をノードの名前に置き換えます</span>
kubectl uncordon &lt;node-to-drain&gt;
</code></pre></div></li>
</ol>
<h3 id=kube-proxyをアップグレード>kube-proxyをアップグレード</h3>
<ol>
<li>
<p>Kubernetes APIにアクセスできるマシンから、次を実行します、
もう一度v1.22.16を目的のバージョンに置き換えます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl -L https://github.com/kubernetes-sigs/sig-windows-tools/releases/latest/download/kube-proxy.yml | sed <span style=color:#b44>&#39;s/VERSION/v1.22.16/g&#39;</span> | kubectl apply -f -
</code></pre></div></li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-77351865caa548b0a06694b904dd881c>3.4 - EndpointSliceの有効化</h1>
<p>このページはKubernetesのEndpointSliceの有効化の概要を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=概要>概要</h2>
<p>EndpointSliceは、KubernetesのEndpointsに対してスケーラブルで拡張可能な代替手段を提供します。Endpointsが提供する機能のベースの上に構築し、スケーラブルな方法で拡張します。Serviceが多数(100以上)のネットワークエンドポイントを持つ場合、それらは単一の大きなEndpointsリソースではなく、複数の小さなEndpointSliceに分割されます。</p>
<h2 id=endpointsliceの有効化>EndpointSliceの有効化</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> EndpointSliceは、最終的には既存のEndpointsを置き換える可能性がありますが、多くのKubernetesコンポーネントはまだ既存のEndpointsに依存しています。現時点ではEndpointSliceを有効化することは、Endpointsの置き換えではなく、クラスター内のEndpointsへの追加とみなされる必要があります。
</div>
<p>EndpoitSliceはベータ版の機能です。APIとEndpointSlice<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>はデフォルトで有効です。<a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>はデフォルトでEndpointSliceではなくEndpointsを使用します。</p>
<p>スケーラビリティと性能向上のため、kube-proxy上で<code>EndpointSliceProxying</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にできます。この変更はデータソースをEndpointSliceに移します、これはkube-proxyとKubernetes API間のトラフィックの量を削減します。</p>
<h2 id=endpointsliceの使用>EndpointSliceの使用</h2>
<p>クラスター内でEndpointSliceを完全に有効にすると、各Endpointsリソースに対応するEndpointSliceリソースが表示されます。既存のEndpointsの機能をサポートすることに加えて、EndpointSliceはトポロジーなどの新しい情報を含みます。これらにより、クラスター内のネットワークエンドポイントのスケーラビリティと拡張性が大きく向上します。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/concepts/services-networking/endpoint-slices/>EndpointSlice</a>を参照してください。</li>
<li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>サービスとアプリケーションの接続</a>を参照してください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9ceed97f912df7289ed8872e290cfbad>3.5 - KubernetesクラスターでNodeLocal DNSキャッシュを使用する</h1>
<p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code>
</div>
このページでは、KubernetesのNodeLocal DNSキャッシュの機能の概要について説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=イントロダクション>イントロダクション</h2>
<p>NodeLocal DNSキャッシュは、クラスターノード上でDNSキャッシュエージェントをDaemonSetで稼働させることで、クラスターのDNSパフォーマンスを向上させます。現在のアーキテクチャーにおいて、ClusterFirstのDNSモードでのPodは、DNSクエリー用にkube-dnsのService IPに疎通します。これにより、kube-proxyによって追加されたiptablesを介してkube-dns/CoreDNSのエンドポイントへ変換されます。この新しいアーキテクチャーによって、Podは同じノード上で稼働するDNSキャッシュエージェントに対して疎通し、それによってiptablesのDNATルールとコネクショントラッキングを回避します。ローカルのキャッシュエージェントはクラスターのホスト名(デフォルトではcluster.localというサフィックス)に対するキャッシュミスがあるときはkube-dnsサービスへ問い合わせます。</p>
<h2 id=動機>動機</h2>
<ul>
<li>
<p>現在のDNSアーキテクチャーでは、ローカルのkube-dns/CoreDNSがないとき、DNSへの秒間クエリー数が最も高いPodは他のノードへ疎通する可能性があります。ローカルでキャッシュを持つことにより、この状況におけるレイテンシーの改善に役立ちます。</p>
</li>
<li>
<p>iptables DNATとコネクショントラッキングをスキップすることは<a href=https://github.com/kubernetes/kubernetes/issues/56903>conntrackの競合</a>を減らし、UDPでのDNSエントリーがconntrackテーブルを満杯にすることを避けるのに役立ちます。</p>
</li>
<li>
<p>ローカルのキャッシュエージェントからkube-dnsサービスへの接続がTCPにアップグレードされます。タイムアウトをしなくてはならないUDPエントリーと比べ、TCPのconntrackエントリーはコネクションクローズ時に削除されます(<a href=https://www.kernel.org/doc/Documentation/networking/nf_conntrack-sysctl.txt>デフォルトの</a> <code>nf_conntrack_udp_timeout</code> は30秒です)。</p>
</li>
<li>
<p>DNSクエリーをUDPからTCPにアップグレードすることで、UDPパケットの欠損や、通常30秒(10秒のタイムアウトで3回再試行する)であるDNSのタイムアウトによるテイルレイテンシーを減少させます。NodeLocalキャッシュはUDPのDNSクエリーを待ち受けるため、アプリケーションを変更する必要はありません。</p>
</li>
<li>
<p>DNSクエリーに対するノードレベルのメトリクスと可視性を得られます。</p>
</li>
<li>
<p>DNSの不在応答のキャッシュも再度有効にされ、それによりkube-dnsサービスに対するクエリー数を減らします。</p>
</li>
</ul>
<h2 id=アーキテクチャー図>アーキテクチャー図</h2>
<p>この図はNodeLocal DNSキャッシュが有効にされた後にDNSクエリーがあったときの流れとなります。</p>
<figure>
<img src=/images/docs/nodelocaldns.svg alt="NodeLocal DNSCache flow"> <figcaption>
<h4>Nodelocal DNSCacheのフロー</h4><p>この図は、NodeLocal DNSキャッシュがDNSクエリーをどう扱うかを表したものです。</p>
</figcaption>
</figure>
<h2 id=設定>設定</h2>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> NodeLocal DNSキャッシュ用のローカルに待ち受けているIPアドレスは、169.254.20.0/16の範囲のIPか、既存のIPと衝突しないことが保証されている他のIPとなります。このドキュメントでは例として169.254.10を使用します。
</div>
<p>この機能は、下記の手順により有効化できます。</p>
<ul>
<li>
<p><a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/addons/dns/nodelocaldns/nodelocaldns.yaml><code>nodelocaldns.yaml</code></a>と同様のマニフェストを用意し、<code>nodelocaldns.yaml</code>という名前で保存してください。</p>
</li>
<li>
<p>マニフェスト内の変数を正しい値に置き換えてください。</p>
<ul>
<li>
<p>kubedns=<code>kubectl get svc kube-dns -n kube-system -o jsonpath={.spec.clusterIP}</code></p>
</li>
<li>
<p>domain=<code>&lt;cluster-domain></code></p>
</li>
<li>
<p>localdns=<code>&lt;node-local-address></code></p>
</li>
</ul>
<p><code>&lt;cluster-domain></code>はデフォルトで"cluster.local"です。<code>&lt;node-local-address></code> はNodeLocal DNSキャッシュ用に確保されたローカルの待ち受けIPアドレスです。</p>
<ul>
<li>
<p>kube-proxyがIPTABLESモードで稼働中のとき:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sed -i <span style=color:#b44>&#34;s/__PILLAR__LOCAL__DNS__/</span><span style=color:#b8860b>$localdns</span><span style=color:#b44>/g; s/__PILLAR__DNS__DOMAIN__/</span><span style=color:#b8860b>$domain</span><span style=color:#b44>/g; s/__PILLAR__DNS__SERVER__/</span><span style=color:#b8860b>$kubedns</span><span style=color:#b44>/g&#34;</span> nodelocaldns.yaml
</code></pre></div><p><code>__PILLAR__CLUSTER__DNS__</code>と<code>__PILLAR__UPSTREAM__SERVERS__</code>はnode-local-dnsというPodによって生成されます。
このモードでは、node-local-dns Podは<code>&lt;node-local-address></code>とkube-dnsのサービスIPの両方で待ち受けるため、PodはIPアドレスでもDNSレコードのルップアップができます。</p>
</li>
<li>
<p>kube-proxyがIPVSモードで稼働中のとき:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash> sed -i <span style=color:#b44>&#34;s/__PILLAR__LOCAL__DNS__/</span><span style=color:#b8860b>$localdns</span><span style=color:#b44>/g; s/__PILLAR__DNS__DOMAIN__/</span><span style=color:#b8860b>$domain</span><span style=color:#b44>/g; s/,__PILLAR__DNS__SERVER__//g; s/__PILLAR__CLUSTER__DNS__/</span><span style=color:#b8860b>$kubedns</span><span style=color:#b44>/g&#34;</span> nodelocaldns.yaml
</code></pre></div><p>このモードでは、node-local-dns Podは<code>&lt;node-local-address></code>上のみで待ち受けます。node-local-dnsのインターフェースはkube-dnsのクラスターIPをバインドしません。なぜならばIPVSロードバランシング用に使われているインターフェースは既にこのアドレスを使用しているためです。
<code>__PILLAR__UPSTREAM__SERVERS__</code> はnode-local-dns Podにより生成されます。</p>
</li>
</ul>
</li>
<li>
<p><code>kubectl create -f nodelocaldns.yaml</code>を実行してください。</p>
</li>
<li>
<p>kube-proxyをIPVSモードで使用しているとき、NodeLocal DNSキャッシュが待ち受けている<code>&lt;node-local-address></code>を使用するため、kubeletに対する<code>--cluster-dns</code>フラグを修正する必要があります。IPVSモード以外のとき、<code>--cluster-dns</code>フラグの値を修正する必要はありません。なぜならNodeLocal DNSキャッシュはkube-dnsのサービスIPと<code>&lt;node-local-address></code>の両方で待ち受けているためです。</p>
</li>
</ul>
<p>一度有効にすると、クラスターの各Node上で、kube-systemという名前空間でnode-local-dns Podが、稼働します。このPodは<a href=https://github.com/coredns/coredns>CoreDNS</a>をキャッシュモードで稼働させるため、異なるプラグインによって公開された全てのCoreDNSのメトリクスがNode単位で利用可能となります。</p>
<p><code>kubectl delete -f &lt;manifest></code>を実行してDaemonSetを削除することによって、この機能を無効にできます。また、kubeletの設定に対して行った全ての変更をリバートすべきです。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-00733cc3747eb3f5fe1c9e0439262967>3.6 - Serviceトポロジーを有効にする</h1>
<p>このページでは、Kubernetes上でServiceトポロジーを有効にする方法の概要について説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=はじめに>はじめに</h2>
<p><em>Serviceトポロジー</em>は、クラスターのノードのトポロジーに基づいてトラフィックをルーティングできるようにする機能です。たとえば、あるServiceのトラフィックに対して、できるだけ同じノードや同じアベイラビリティゾーン上にあるエンドポイントを優先してルーティングするように指定できます。</p>
<h2 id=前提>前提</h2>
<p>トポロジーを考慮したServiceのルーティングを有効にするには、以下の前提を満たしている必要があります。</p>
<ul>
<li>Kubernetesバージョン1.17以降である</li>
<li><a class=glossary-tooltip title=kube-proxyはクラスター内の各Nodeで動作しているネットワークプロキシです。 data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=Kube-proxy>Kube-proxy</a>がiptableモードまたはIPVSモードで稼働している</li>
<li><a href=/docs/concepts/services-networking/endpoint-slices/>Endpoint Slice</a>を有効にしている</li>
</ul>
<h2 id=serviceトポロジーを有効にする>Serviceトポロジーを有効にする</h2>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.17 [alpha]</code>
</div>
<p>Serviceトポロジーを有効にするには、すべてのKubernetesコンポーネントで<code>ServiceTopology</code>と<code>EndpointSlice</code>フィーチャーゲートを有効にする必要があります。</p>
<pre><code>--feature-gates=&quot;ServiceTopology=true,EndpointSlice=true&quot;
</code></pre><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/services-networking/service-topology>Serviceトポロジー</a>のコンセプトについて読む</li>
<li><a href=/docs/concepts/services-networking/endpoint-slices>Endpoint Slice</a>について読む</li>
<li><a href=/ja/docs/concepts/services-networking/connect-applications-service/>サービスとアプリケーションの接続</a>を読む</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ce4cd28c8feb9faa783e79b48af37961>3.7 - クラウドコントローラーマネージャーの運用管理</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code>
</div>
<p>クラウドプロバイダーはKubernetesプロジェクトとは異なるペースで開発およびリリースされるため、プロバイダー固有のコードを<a class=glossary-tooltip title=サードパーティクラウドプロバイダーにKubernetewを結合するコントロールプレーンコンポーネント data-toggle=tooltip data-placement=top href=/ja/docs/concepts/architecture/cloud-controller/ target=_blank aria-label="`cloud-controller-manager`">`cloud-controller-manager`</a>バイナリに抽象化することでクラウドベンダーはKubernetesのコアのコードとは独立して開発が可能となりました。</p>
<p><code>cloud-controller-manager</code>は、<a href=https://github.com/kubernetes/cloud-provider/blob/master/cloud.go>cloudprovider.Interface</a>を満たす任意のクラウドプロバイダーと接続できます。下位互換性のためにKubernetesのコアプロジェクトで提供される<a href=https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager>cloud-controller-manager</a>は<code>kube-controller-manager</code>と同じクラウドライブラリを使用します。Kubernetesのコアリポジトリですでにサポートされているクラウドプロバイダーは、Kubernetesリポジトリにあるcloud-controller-managerを使用してKubernetesのコアから移行することが期待されています。</p>
<h2 id=運用>運用</h2>
<h3 id=要件>要件</h3>
<p>すべてのクラウドには動作させるためにそれぞれのクラウドプロバイダーの統合を行う独自の要件があり、<code>kube-controller-manager</code>を実行する場合の要件とそれほど違わないようにする必要があります。一般的な経験則として、以下のものが必要です。</p>
<ul>
<li>クラウドの認証/認可: クラウドではAPIへのアクセスを許可するためにトークンまたはIAMルールが必要になる場合があります</li>
<li>kubernetesの認証/認可: cloud-controller-managerは、kubernetes apiserverと通信するためにRBACルールの設定を必要とする場合があります</li>
<li>高可用性: kube-controller-managerのように、リーダー選出を使用したクラウドコントローラーマネージャーの高可用性のセットアップが必要になる場合があります(デフォルトでオンになっています)。</li>
</ul>
<h3 id=cloud-controller-managerを動かす>cloud-controller-managerを動かす</h3>
<p>cloud-controller-managerを正常に実行するにはクラスター構成にいくつかの変更が必要です。</p>
<ul>
<li><code>kube-apiserver</code>と<code>kube-controller-manager</code>は**<code>--cloud-provider</code>フラグを指定してはいけません**。これによりクラウドコントローラーマネージャーによって実行されるクラウド固有のループが実行されなくなります。将来このフラグは非推奨になり削除される予定です。</li>
<li><code>kubelet</code>は<code>--cloud-provider=external</code>で実行する必要があります。これは作業をスケジュールする前にクラウドコントローラーマネージャーによって初期化する必要があることをkubeletが認識できるようにするためです。</li>
</ul>
<p>クラウドコントローラーマネージャーを使用するようにクラスターを設定するとクラスターの動作がいくつか変わることに注意してください。</p>
<ul>
<li><code>--cloud-provider=external</code>を指定したkubeletは、初期化時に<code>NoSchedule</code>の<code>node.cloudprovider.kubernetes.io/uninitialized</code>汚染を追加します。これによりノードは作業をスケジュールする前に外部のコントローラーからの2回目の初期化が必要であるとマークされます。クラウドコントローラーマネージャーが使用できない場合クラスター内の新しいノードはスケジュールできないままになることに注意してください。スケジューラーはリージョンやタイプ(高CPU、GPU、高メモリ、スポットインスタンスなど)などのノードに関するクラウド固有の情報を必要とする場合があるためこの汚染は重要です。</li>
<li>クラスター内のノードに関するクラウド情報はローカルメタデータを使用して取得されなくなりましたが、代わりにノード情報を取得するためのすべてのAPI呼び出しはクラウドコントローラーマネージャーを経由して行われるようになります。これはセキュリティを向上させるためにkubeletでクラウドAPIへのアクセスを制限できることを意味します。大規模なクラスターではクラスター内からクラウドのほとんどすべてのAPI呼び出しを行うため、クラウドコントローラーマネージャーがレートリミットに達するかどうかを検討する必要があります。</li>
</ul>
<p>クラウドコントローラーマネージャーは以下を実装できます。</p>
<ul>
<li>ノードコントローラー - クラウドAPIを使用してkubernetesノードを更新し、クラウドで削除されたkubernetesノードを削除します。</li>
<li>サービスコントローラー - タイプLoadBalancerのサービスに対応してクラウド上のロードバランサーを操作します。</li>
<li>ルートコントローラー - クラウド上でネットワークルートを設定します。</li>
<li>Kubernetesリポジトリの外部にあるプロバイダーを実行している場合はその他の機能の実装。</li>
</ul>
<h2 id=例>例</h2>
<p>現在Kubernetesのコアでサポートされているクラウドを使用していて、クラウドコントローラーマネージャーを利用する場合は、<a href=https://github.com/kubernetes/kubernetes/tree/master/cmd/cloud-controller-manager>kubernetesのコアのクラウドコントローラーマネージャー</a>を参照してください。</p>
<p>Kubernetesのコアリポジトリにないクラウドコントローラーマネージャーの場合、クラウドベンダーまたはsigリードが管理するリポジトリでプロジェクトを見つけることができます。</p>
<p>すでにKubernetesのコアリポジトリにあるプロバイダーの場合、クラスター内でデーモンセットとしてKubernetesリポジトリ内部のクラウドコントローラーマネージャーを実行できます。以下をガイドラインとして使用してください。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/admin/cloud/ccm-example.yaml download=admin/cloud/ccm-example.yaml><code>admin/cloud/ccm-example.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('admin-cloud-ccm-example-yaml')" title="Copy admin/cloud/ccm-example.yaml to clipboard">
</img>
</div>
<div class=includecode id=admin-cloud-ccm-example-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># This is an example of how to setup cloud-controller-manager as a Daemonset in your cluster.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># It assumes that your masters can run pods and has the role node-role.kubernetes.io/master</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Note that this Daemonset will not work straight out of the box for your cloud, this is</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># meant to be a guideline.</span><span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cluster-admin<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># for in-tree providers we use k8s.gcr.io/cloud-controller-manager</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># this can be replaced with any other image for out-of-tree providers</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/cloud-controller-manager:v1.8.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- /usr/local/bin/cloud-controller-manager<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --cloud-provider=&lt;YOUR_CLOUD_PROVIDER&gt;  <span style=color:#bbb> </span><span style=color:#080;font-style:italic># Add your own cloud provider here!</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --leader-elect=true<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --use-service-account-credentials<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># these flags will vary for every cloud provider</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --allocate-node-cidrs=true<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --configure-cloud-routes=true<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- --cluster-cidr=172.17.0.0/16<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># this is required so CCM can bootstrap itself</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node.cloudprovider.kubernetes.io/uninitialized<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># this is to have the daemonset runnable on master nodes</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># the taint may vary depending on your cluster setup</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># this is to restrict CCM to only run on master nodes</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># the node selector may vary depending on your cluster setup</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>node-role.kubernetes.io/master</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<h2 id=制限>制限</h2>
<p>クラウドコントローラーマネージャーの実行にはいくつかの制限があります。これらの制限は今後のリリースで対処されますが、本番のワークロードにおいてはこれらの制限を認識することが重要です。</p>
<h3 id=ボリュームのサポート>ボリュームのサポート</h3>
<p>ボリュームの統合にはkubeletとの調整も必要になるためクラウドコントローラーマネージャーは<code>kube-controller-manager</code>にあるボリュームコントローラーを実装しません。CSI(コンテナストレージインターフェイス)が進化してFlexボリュームプラグインの強力なサポートが追加されるにつれ、クラウドがボリュームと完全に統合できるようクラウドコントローラーマネージャーに必要なサポートが追加されます。Kubernetesリポジトリの外部にあるCSIボリュームプラグインの詳細については<a href=https://github.com/kubernetes/features/issues/178>こちら</a>をご覧ください。</p>
<h3 id=スケーラビリティ>スケーラビリティ</h3>
<p>cloud-controller-managerは、クラウドプロバイダーのAPIにクエリーを送信して、すべてのノードの情報を取得します。非常に大きなクラスターの場合、リソース要件やAPIレートリミットなどのボトルネックの可能性を考慮する必要があります。</p>
<h3 id=鶏と卵>鶏と卵</h3>
<p>クラウドコントローラーマネージャープロジェクトの目標はKubernetesのコアプロジェクトからクラウドに関する機能の開発を切り離すことです。残念ながら、Kubernetesプロジェクトの多くの面でクラウドプロバイダーの機能がKubernetesプロジェクトに緊密に結びついているという前提があります。そのため、この新しいアーキテクチャを採用するとクラウドプロバイダーの情報を要求する状況が発生する可能性がありますが、クラウドコントローラーマネージャーはクラウドプロバイダーへのリクエストが完了するまでその情報を返すことができない場合があります。</p>
<p>これの良い例は、KubeletのTLSブートストラップ機能です。TLSブートストラップはKubeletがすべてのアドレスタイプ(プライベート、パブリックなど)をクラウドプロバイダー(またはローカルメタデータサービス)に要求する能力を持っていると仮定していますが、クラウドコントローラーマネージャーは最初に初期化されない限りノードのアドレスタイプを設定できないためapiserverと通信するためにはkubeletにTLS証明書が必要です。</p>
<p>このイニシアチブが成熟するに連れ、今後のリリースでこれらの問題に対処するための変更が行われます。</p>
<h2 id=次の項目>次の項目</h2>
<p>独自のクラウドコントローラーマネージャーを構築および開発するには<a href=/ja/docs/tasks/administer-cluster/developing-cloud-controller-manager/>クラウドコントローラーマネージャーの開発</a>を参照してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9585dc0efb0450fd68728e7511754717>3.8 - クラウドコントローラーマネージャーの開発</h1>
<p><p>cloud-controller-managerは クラウド特有の制御ロジックを組み込むKubernetesの<a class=glossary-tooltip title=コンテナのライフサイクルを定義、展開、管理するためのAPIとインターフェイスを公開するコンテナオーケストレーションレイヤーです。 data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-control-plane" target=_blank aria-label="control plane">control plane</a>コンポーネントです。クラウドコントロールマネージャーは、クラスターをクラウドプロバイダーAPIをリンクし、クラスタのみで相互作用するコンポーネントからクラウドプラットフォームで相互作用するコンポーネントを分離します。</p></p>
<p>Kubernetesと下のクラウドインフラストラクチャー間の相互運用ロジックを分離することで、cloud-controller-managerコンポーネントはクラウドプロバイダを主なKubernetesプロジェクトと比較し異なるペースで機能をリリース可能にします。</p>
<h2 id=背景>背景</h2>
<p>クラウドプロバイダーはKubernetesプロジェクトとは異なる速度で開発しリリースすることから、プロバイダー特有なコードを<code>cloud-controller-manager</code>バイナリから抽象化することで、クラウドベンダーはコアKubernetesコードから独立して発展することができます。</p>
<p>Kubernetesプロジェクトは、(クラウドプロバイダーの)独自実装を組み込めるGoインターフェースを備えたcloud-controller-managerのスケルトンコードを提供しています。これは、クラウドプロバイダーがKubernetesコアからパッケージをインポートすることでcloud-controller-managerを実装できることを意味します。各クラウドプロバイダーは利用可能なクラウドプロバイダーのグローバル変数を更新するために<code>cloudprovider.RegisterCloudProvider</code>を呼び出し、独自のコードを登録します。</p>
<h2 id=開発>開発</h2>
<h3 id=kubernetesには登録されていない独自クラウドプロバイダー>Kubernetesには登録されていない独自クラウドプロバイダー</h3>
<p>Kubernetesには登録されていない独自のクラウドプロバイダーのクラウドコントローラーマネージャーを構築するには、</p>
<ol>
<li><a href=https://github.com/kubernetes/cloud-provider/blob/master/cloud.go>cloudprovider.Interface</a>を満たす go パッケージを実装します。</li>
<li>Kubernetesのコアにある<a href=https://github.com/kubernetes/kubernetes/blob/master/cmd/cloud-controller-manager/controller-manager.go>cloud-controller-managerの<code>main.go</code></a>をあなたの<code>main.go</code>のテンプレートとして利用します。上で述べたように、唯一の違いはインポートされるクラウドパッケージのみです。</li>
<li>クラウドパッケージを <code>main.go</code> にインポートし、パッケージに <a href=https://github.com/kubernetes/cloud-provider/blob/master/plugins.go><code>cloudprovider.RegisterCloudProvider</code></a> を実行するための <code>init</code> ブロックがあることを確認します。</li>
</ol>
<p>多くのクラウドプロバイダーはオープンソースとしてコントローラーマネージャーのコードを公開しています。新たにcloud-controller-managerをスクラッチから開発する際には、既存のKubernetesには登録されていない独自クラウドプロバイダーのコントローラーマネージャーを開始地点とすることができます。</p>
<h3 id=kubernetesに登録されているクラウドプロバイダー>Kubernetesに登録されているクラウドプロバイダー</h3>
<p>Kubernetesに登録されているクラウドプロバイダーであれば、<a class=glossary-tooltip title=Podのコピーがクラスター内の一連のNodeに渡って実行されることを保証します。 data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>を使ってあなたのクラスターで動かすことができます。詳細については<a href=/ja/docs/tasks/administer-cluster/running-cloud-controller/>Kubernetesクラウドコントローラーマネージャー</a>を参照してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e1afcdac8d5e8458274b3c481c5ebcda>3.9 - サービスディスカバリーにCoreDNSを使用する</h1>
<p>このページでは、CoreDNSのアップグレードプロセスと、kube-dnsの代わりにCoreDNSをインストールする方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.9.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=about-coredns>CoreDNSについて</h2>
<p><a href=https://coredns.io>CoreDNS</a>は、KubernetesクラスターDNSとして稼働させることができる柔軟で拡張可能なDNSサーバーです。Kubernetesと同様に、CoreDNSプロジェクトは<a class=glossary-tooltip title="Cloud Native Computing Foundation" data-toggle=tooltip data-placement=top href=https://cncf.io/ target=_blank aria-label=CNCF>CNCF</a>によってホストされています。</p>
<p>既存のデプロイでkube-dnsを置き換えるか、クラスターのデプロイとアップグレードを代行してくれるkubeadmのようなツールを使用することで、クラスターでkube-dnsの代わりにCoreDNSを使用することができます。</p>
<h2 id=installing-coredns>CoreDNSのインストール</h2>
<p>kube-dnsの手動デプロイや置き換えについては、<a href=https://github.com/coredns/deployment/tree/master/kubernetes>CoreDNS GitHub project</a>のドキュメントを参照してください。</p>
<h2 id=migrating-to-coredns>CoreDNSへの移行</h2>
<h3 id=upgrading-an-existing-cluster-with-kubeadm>kubeadmを使用した既存のクラスターのアップグレード</h3>
<p>Kubernetesバージョン1.10以降では、<code>kube-dns</code>を使用しているクラスターを<code>kubeadm</code>を使用してアップグレードするときに、CoreDNSに移行することもできます。この場合、<code>kubeadm</code>は、<code>kube-dns</code> ConfigMapをベースにしてCoreDNS設定("Corefile")を生成し、フェデレーション、スタブドメイン、および上流のネームサーバーの設定を保持します。</p>
<p>kube-dnsからCoreDNSに移行する場合は、アップグレード時に必ず<code>CoreDNS</code>フィーチャーゲートを<code>true</code>に設定してください。たとえば、<code>v1.11.0</code>のアップグレードは次のようになります:</p>
<pre><code>kubeadm upgrade apply v1.11.0 --feature-gates=CoreDNS=true
</code></pre><p>Kubernetesバージョン1.13以降では、<code>CoreDNS</code>フィーチャーゲートが削除され、CoreDNSがデフォルトで使用されます。アップグレードしたクラスターでkube-dnsを使用する場合は、<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase#cmd-phase-addon>こちら</a>のガイドに従ってください。</p>
<p>1.11以前のバージョンでは、Corefileはアップグレード中に作成されたものによって<strong>上書き</strong>されます。<strong>カスタマイズしている場合は、既存のConfigMapを保存する必要があります。</strong> 新しいConfigMapが稼働したら、カスタマイズを再適用できます。</p>
<p>Kubernetesバージョン1.11以降でCoreDNSを実行している場合、アップグレード中、既存のCorefileは保持されます。</p>
<h3 id=installing-kube-dns-instead-of-coredns-with-kubeadm>kubeadmを使用してCoreDNSの代わりにkube-dnsをインストールする</h3>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Kubernetes 1.11では、CoreDNSは一般利用可能(GA)にアップグレードされ、デフォルトでインストールされます。
</div>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> Kubernetes 1.18では、kubeadmでのkube-dns使用は非推奨となり、将来のバージョンでは削除されます。
</div>
<p>1.13以前のバージョンにkube-dnsをインストールするには、<code>CoreDNS</code>フィーチャーゲートの値を<code>false</code>に設定します:</p>
<pre><code>kubeadm init --feature-gates=CoreDNS=false
</code></pre><p>バージョン1.13以降の場合は、<a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase#cmd-phase-addon>こちら</a>に記載されているガイドに従ってください。</p>
<h2 id=upgrading-coredns>CoreDNSのアップグレード</h2>
<p>CoreDNSはv1.9以降のKubernetesで使用できます。Kubernetesに同梱されているCoreDNSのバージョンと、CoreDNSに加えられた変更は<a href=https://github.com/coredns/deployment/blob/master/kubernetes/CoreDNS-k8s_version.md>こちら</a>で確認できます。</p>
<p>CoreDNSだけをアップグレードしたい場合や、独自のカスタムイメージを使用したい場合は、CoreDNSを手動でアップグレードすることができます。スムーズなアップグレードのために役立つ<a href=https://github.com/coredns/deployment/blob/master/kubernetes/Upgrading_CoreDNS.md>ガイドラインとウォークスルー</a>が用意されています。</p>
<h2 id=tuning-coredns>CoreDNSのチューニング</h2>
<p>リソース使用率が問題になる場合は、CoreDNSの設定を調整すると役立つ場合があります。詳細は、<a href=https://github.com/coredns/deployment/blob/master/kubernetes/Scaling_CoreDNS.md>CoreDNSのスケーリングに関するドキュメント</a>を参照してください。</p>
<h2 id=次の項目>次の項目</h2>
<p><a href=https://coredns.io>CoreDNS</a>は、<code>Corefile</code>を変更することで、kube-dnsよりも多くのユースケースをサポートするように設定することができます。詳細は<a href=https://coredns.io/2017/05/08/custom-dns-entries-for-kubernetes/>CoreDNSサイト</a>を参照してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a3790dfb57271d13517e549dffa805b9>3.10 - ネットワークポリシーを宣言する</h1>
<p>このドキュメントでは、Pod同士の通信を制御するネットワークポリシーを定義するための、Kubernetesの<a href=/docs/concepts/services-networking/network-policies/>NetworkPolicy API</a>を使い始める手助けをします。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.8.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>ネットワークポリシーをサポートしているネットワークプロバイダーが設定済みであることを確認してください。さまざまなネットワークプロバイダーがNetworkPolicyをサポートしています。次に挙げるのは一例です。</p>
<ul>
<li><a href=/docs/tasks/administer-cluster/network-policy-provider/calico-network-policy/>Calico</a></li>
<li><a href=/docs/tasks/administer-cluster/network-policy-provider/cilium-network-policy/>Cilium</a></li>
<li><a href=/docs/tasks/administer-cluster/network-policy-provider/kube-router-network-policy/>Kube-router</a></li>
<li><a href=/docs/tasks/administer-cluster/network-policy-provider/romana-network-policy/>Romana</a></li>
<li><a href=/docs/tasks/administer-cluster/network-policy-provider/weave-network-policy/>Weave Net</a></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 上記のリストは製品名のアルファベット順にソートされていて、推奨順や好ましい順にソートされているわけではありません。このページの例は、Kubernetesクラスターでこれらのどのプロバイダーを使用していても有効です。
</div>
<h2 id=nginx-deploymentを作成してservice経由で公開する><code>nginx</code> Deploymentを作成してService経由で公開する</h2>
<p>Kubernetesのネットワークポリシーの仕組みを理解するために、まずは<code>nginx</code> Deploymentを作成することから始めましょう。</p>
<pre><code class=language-console data-lang=console>kubectl create deployment nginx --image=nginx
</code></pre><pre><code class=language-none data-lang=none>deployment.apps/nginx created
</code></pre><p><code>nginx</code>という名前のService経由でDeploymentを公開します。</p>
<pre><code class=language-console data-lang=console>kubectl expose deployment nginx --port=80
</code></pre><pre><code class=language-none data-lang=none>service/nginx exposed
</code></pre><p>上記のコマンドを実行すると、nginx Podを持つDeploymentが作成され、そのDeploymentが<code>nginx</code>という名前のService経由で公開されます。<code>nginx</code>のPodおよびDeploymentは<code>default</code>名前空間の中にあります。</p>
<pre><code class=language-console data-lang=console>kubectl get svc,pod
</code></pre><pre><code class=language-none data-lang=none>NAME                        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGE
service/kubernetes          10.100.0.1    &lt;none&gt;        443/TCP    46m
service/nginx               10.100.0.16   &lt;none&gt;        80/TCP     33s

NAME                        READY         STATUS        RESTARTS   AGE
pod/nginx-701339712-e0qfq   1/1           Running       0          35s
</code></pre><h2 id=もう1つのpodからアクセスしてserviceを検証する>もう1つのPodからアクセスしてServiceを検証する</h2>
<p>これで、新しい<code>nginx</code>サービスに他のPodからアクセスできるようになったはずです。<code>default</code>名前空間内の他のPodから<code>nginx</code> Serviceにアクセスするために、busyboxコンテナを起動します。</p>
<pre><code class=language-console data-lang=console>kubectl run busybox --rm -ti --image=busybox -- /bin/sh
</code></pre><p>シェルの中で、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</code></pre></div><pre><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
remote file exists
</code></pre><h2 id=nginx-serviceへのアクセスを制限する><code>nginx</code> Serviceへのアクセスを制限する</h2>
<p><code>nginx</code> Serviceへのアクセスを制限するために、<code>access: true</code>というラベルが付いたPodだけがクエリできるようにします。次の内容でNetworkPolicyオブジェクトを作成してください。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/nginx-policy.yaml download=service/networking/nginx-policy.yaml><code>service/networking/nginx-policy.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-nginx-policy-yaml')" title="Copy service/networking/nginx-policy.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-nginx-policy-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>access-nginx<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>access</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>NetworkPolicyオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>でなければなりません。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このNetworkPolicyには、ポリシーを適用するPodのグループを選択するための<code>podSelector</code>が含まれています。このポリシーは、ラベル<code>app=nginx</code>の付いたPodを選択していることがわかります。このラベルは、<code>nginx</code> Deployment内のPodに自動的に追加されたものです。空の<code>podSelector</code>は、その名前空間内のすべてのPodを選択します。
</div>
<h2 id=serviceにポリシーを割り当てる>Serviceにポリシーを割り当てる</h2>
<p>kubectlを使って、上記の<code>nginx-policy.yaml</code>ファイルからNetworkPolicyを作成します。</p>
<pre><code class=language-console data-lang=console>kubectl apply -f https://k8s.io/examples/service/networking/nginx-policy.yaml
</code></pre><pre><code class=language-none data-lang=none>networkpolicy.networking.k8s.io/access-nginx created
</code></pre><h2 id=accessラベルが定義されていない状態でserviceへのアクセスをテストする>accessラベルが定義されていない状態でServiceへのアクセスをテストする</h2>
<p><code>nginx</code> Serviceに正しいラベルが付いていないPodからアクセスを試してみると、リクエストがタイムアウトします。</p>
<pre><code class=language-console data-lang=console>kubectl run busybox --rm -ti --image=busybox -- /bin/sh
</code></pre><p>シェルの中で、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</code></pre></div><pre><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
wget: download timed out
</code></pre><h2 id=accessラベルを定義して再テストする>accessラベルを定義して再テストする</h2>
<p>正しいラベルが付いたPodを作成すると、リクエストが許可されるようになるのがわかります。</p>
<pre><code class=language-console data-lang=console>kubectl run busybox --rm -ti --labels=&quot;access=true&quot; --image=busybox -- /bin/sh
</code></pre><p>シェルの中で、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget --spider --timeout<span style=color:#666>=</span><span style=color:#666>1</span> nginx
</code></pre></div><pre><code class=language-none data-lang=none>Connecting to nginx (10.100.0.16:80)
remote file exists
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8060aed5bf1172fa62199a4c306a4cd1>3.11 - ノードのトポロジー管理ポリシーを制御する</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code>
</div>
<p>近年、CPUやハードウェア・アクセラレーターの組み合わせによって、レイテンシーが致命的となる実行や高いスループットを求められる並列計算をサポートするシステムが増えています。このようなシステムには、通信、科学技術計算、機械学習、金融サービス、データ分析などの分野のワークロードが含まれます。このようなハイブリッドシステムは、高い性能の環境で構成されます。</p>
<p>最高のパフォーマンスを引き出すために、CPUの分離やメモリーおよびデバイスの位置に関する最適化が求められます。しかしながら、Kubernetesでは、これらの最適化は分断されたコンポーネントによって処理されます。</p>
<p><em>トポロジーマネージャー</em> はKubeletコンポーネントの1つで最適化の役割を担い、コンポーネント群を調和して機能させます。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.18.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=トポロジーマネージャーはどのように機能するか>トポロジーマネージャーはどのように機能するか</h2>
<p>トポロジーマネージャー導入前は、KubernetesにおいてCPUマネージャーやデバイスマネージャーはそれぞれ独立してリソースの割り当てを決定します。
これは、マルチソケットのシステムでは望ましくない割り当てとなり、パフォーマンスやレイテンシーが求められるアプリケーションは、この望ましくない割り当てに悩まされます。
この場合の望ましくない例として、CPUやデバイスが異なるNUMAノードに割り当てられ、それによりレイテンシー悪化を招くことが挙げられます。</p>
<p>トポロジーマネージャーはKubeletコンポーネントであり、信頼できる情報源として振舞います。それによって、他のKubeletコンポーネントはトポロジーに沿ったリソース割り当ての選択を行うことができます。</p>
<p>トポロジーマネージャーは <em>Hint Providers</em> と呼ばれるコンポーネントのインターフェースを提供し、トポロジー情報を送受信します。トポロジーマネージャーは、ノード単位のポリシー群を保持します。ポリシーについて以下で説明します。</p>
<p>トポロジーマネージャーは <em>Hint Providers</em> からトポロジー情報を受け取ります。トポロジー情報は、利用可能なNUMAノードと優先割り当て表示を示すビットマスクです。トポロジーマネージャーのポリシーは、提供されたヒントに対して一連の操作を行い、ポリシーに沿ってヒントをまとめて最適な結果を得ます。もし、望ましくないヒントが保存された場合、ヒントの優先フィールドがfalseに設定されます。現在のポリシーでは、最も狭い優先マスクが優先されます。</p>
<p>選択されたヒントはトポロジーマネージャーの一部として保存されます。設定されたポリシーにしたがい、選択されたヒントに基づいてノードがPodを許可したり、拒否することができます。
トポロジーマネージャーに保存されたヒントは、<em>Hint Providers</em> が使用しリソース割り当てを決定します。</p>
<h3 id=トポロジーマネージャーの機能を有効にする>トポロジーマネージャーの機能を有効にする</h3>
<p>トポロジーマネージャーをサポートするには、<code>TopologyManager</code> <a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にする必要があります。Kubernetes 1.18ではデフォルトで有効です。</p>
<h2 id=トポロジーマネージャーのスコープとポリシー>トポロジーマネージャーのスコープとポリシー</h2>
<p>トポロジーマネージャは現在:</p>
<ul>
<li>全てのQoAクラスのPodを調整する</li>
<li>Hint Providerによって提供されたトポロジーヒントから、要求されたリソースを調整する</li>
</ul>
<p>これらの条件が合致した場合、トポロジーマネージャーは要求されたリソースを調整します。</p>
<p>この調整をどのように実行するかカスタマイズするために、トポロジーマネージャーは2つのノブを提供します: <code>スコープ</code> と<code>ポリシー</code>です。</p>
<p><code>スコープ</code>はリソースの配置を行う粒度を定義します(例:<code>pod</code>や<code>container</code>)。そして、<code>ポリシー</code>は調整を実行するための実戦略を定義します(<code>best-effort</code>, <code>restricted</code>, <code>single-numa-node</code>等)。</p>
<p>現在利用可能な<code>スコープ</code>と<code>ポリシー</code>の値について詳細は以下の通りです。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> PodのSpecにある他の要求リソースとCPUリソースを調整するために、CPUマネージャーを有効にし、適切なCPUマネージャーのポリシーがノードに設定されるべきです。<a href=/docs/tasks/administer-cluster/cpu-management-policies/>CPU管理ポリシー</a>を参照してください。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> PodのSpecにある他の要求リソースとメモリー（およびhugepage）リソースを調整するために、メモリーマネージャーを有効にし、適切なメモリーマネージャーポリシーがノードに設定されるべきです。<a href=/docs/tasks/administer-cluster/memory-manager/>メモリーマネージャー</a> のドキュメントを確認してください。
</div>
<h3 id=トポロジーマネージャーのスコープ>トポロジーマネージャーのスコープ</h3>
<p>トポロジーマネージャーは、以下の複数の異なるスコープでリソースの調整を行う事が可能です:</p>
<ul>
<li><code>container</code> (デフォルト)</li>
<li><code>pod</code></li>
</ul>
<p>いずれのオプションも、<code>--topology-manager-scope</code>フラグによって、kubelet起動時に選択できます。</p>
<h3 id=containerスコープ>containerスコープ</h3>
<p><code>container</code>スコープはデフォルトで使用されます。</p>
<p>このスコープでは、トポロジーマネージャーは連続した複数のリソース調整を実行します。つまり、Pod内の各コンテナは、分離された配置計算がされます。言い換えると、このスコープでは、コンテナを特定のNUMAノードのセットにグループ化するという概念はありません。実際には、トポロジーマネージャーは各コンテナのNUMAノードへの配置を任意に実行します。</p>
<p>コンテナをグループ化するという概念は、以下のスコープで設定・実行されます。例えば、<code>pod</code>スコープが挙げられます。</p>
<h3 id=podスコープ>podスコープ</h3>
<p><code>pod</code>スコープを選択するには、コマンドラインで<code>--topology-manager-scope=pod</code>オプションを指定してkubeletを起動します。</p>
<p>このスコープでは、Pod内全てのコンテナを共通のNUMAノードのセットにグループ化することができます。トポロジーマネージャーはPodをまとめて1つとして扱い、ポッド全体（全てのコンテナ）を単一のNUMAノードまたはNUMAノードの共通セットのいずれかに割り当てようとします。以下の例は、さまざまな場面でトポロジーマネージャーが実行する調整を示します:</p>
<ul>
<li>全てのコンテナは、単一のNUMAノードに割り当てられます。</li>
<li>全てのコンテナは、共有されたNUMAノードのセットに割り当てられます。</li>
</ul>
<p>Pod全体に要求される特定のリソースの総量は<a href=/ja/docs/concepts/workloads/pods/init-containers/#resources>有効なリクエスト／リミット</a>の式に従って計算されるため、この総量の値は以下の最大値となります。</p>
<ul>
<li>全てのアプリケーションコンテナのリクエストの合計。</li>
<li>リソースに対するinitコンテナのリクエストの最大値。</li>
</ul>
<p><code>pod</code>スコープと<code>single-numa-node</code>トポロジーマネージャーポリシーを併用することは、レイテンシーが重要なワークロードやIPCを行う高スループットのアプリケーションに対して特に有効です。両方のオプションを組み合わせることで、Pod内の全てのコンテナを単一のNUMAノードに配置できます。そのため、PodのNUMA間通信によるオーバーヘッドを排除することができます。</p>
<p><code>single-numa-node</code>ポリシーの場合、可能な割り当ての中に適切なNUMAノードのセットが存在する場合にのみ、Podが許可されます。上の例をもう一度考えてみましょう:</p>
<ul>
<li>1つのNUMAノードのみを含むセット - Podが許可されます。</li>
<li>2つ以上のNUMAノードを含むセット - Podが拒否されます(1つのNUMAノードの代わりに、割り当てを満たすために2つ以上のNUMAノードが必要となるため)。</li>
</ul>
<p>要約すると、トポロジーマネージャーはまずNUMAノードのセットを計算し、それをトポロジーマネージャーのポリシーと照合し、Podの拒否または許可を検証します。</p>
<h3 id=トポロジーマネージャーのポリシー>トポロジーマネージャーのポリシー</h3>
<p>トポロジーマネージャーは4つの調整ポリシーをサポートします。<code>--topology-manager-policy</code>というKubeletフラグを通してポリシーを設定できます。
4つのサポートされるポリシーがあります:</p>
<ul>
<li><code>none</code> (デフォルト)</li>
<li><code>best-effort</code></li>
<li><code>restricted</code></li>
<li><code>single-numa-node</code></li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> トポロジーマネージャーが <strong>pod</strong> スコープで設定された場合、コンテナはポリシーによって、Pod全体の要求として反映します。
したがって、Podの各コンテナは <strong>同じ</strong> トポロジー調整と同じ結果となります。
</div>
<h3 id=policy-none>none ポリシー</h3>
<p>これはデフォルトのポリシーで、トポロジーの調整を実行しません。</p>
<h3 id=policy-best-effort>best-effort ポリシー</h3>
<p>Pod内の各コンテナに対して、<code>best-effort</code> トポロジー管理ポリシーが設定されたkubeletは、各Hint Providerを呼び出してそれらのリソースの可用性を検出します。
トポロジーマネージャーはこの情報を使用し、そのコンテナの推奨されるNUMAノードのアフィニティーを保存します。アフィニティーが優先されない場合、トポロジーマネージャーはこれを保存し、Podをノードに許可します。</p>
<p><em>Hint Providers</em> はこの情報を使ってリソースの割り当てを決定します。</p>
<h3 id=policy-restricted>restricted ポリシー</h3>
<p>Pod内の各コンテナに対して、<code>restricted</code> トポロジー管理ポリシーが設定されたkubeletは各Hint Providerを呼び出してそれらのリソースの可用性を検出します。
トポロジーマネージャーはこの情報を使用し、そのコンテナの推奨されるNUMAノードのアフィニティーを保存します。アフィニティーが優先されない場合、トポロジーマネージャーはPodをそのノードに割り当てることを拒否します。この結果、PodはPodの受付失敗となり<code>Terminated</code> 状態になります。</p>
<p>Podが一度<code>Terminated</code>状態になると、KubernetesスケジューラーはPodの再スケジューリングを試み <strong>ません</strong> 。Podの再デプロイをするためには、ReplicasetかDeploymenを使用してください。<code>Topology Affinity</code>エラーとなったpodを再デプロイするために、外部のコントロールループを実行することも可能です。</p>
<p>Podが許可されれば、 <em>Hint Providers</em> はこの情報を使ってリソースの割り当てを決定します。</p>
<h3 id=policy-single-numa-node>single-numa-node ポリシー</h3>
<p>Pod内の各コンテナに対して、<code>single-numa-node</code>トポロジー管理ポリシーが設定されたkubeletは各Hint Prociderを呼び出してそれらのリソースの可用性を検出します。
トポロジーマネージャーはこの情報を使用し、単一のNUMAノードアフィニティが可能かどうか決定します。
可能な場合、トポロジーマネージャーは、この情報を保存し、<em>Hint Providers</em> はこの情報を使ってリソースの割り当てを決定します。
不可能な場合、トポロジーマネージャーは、Podをそのノードに割り当てることを拒否します。この結果、Pod は Pod の受付失敗となり<code>Terminated</code>状態になります。</p>
<p>Podが一度<code>Terminated</code>状態になると、KubernetesスケジューラーはPodの再スケジューリングを試み<strong>ません</strong>。Podの再デプロイをするためには、ReplicasetかDeploymentを使用してください。<code>Topology Affinity</code>エラーとなったpodを再デプロイするために、外部のコントロールループを実行することも可能です。</p>
<h3 id=podとトポロジー管理ポリシーの関係>Podとトポロジー管理ポリシーの関係</h3>
<p>以下のようなpodのSpecで定義されるコンテナを考えます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></code></pre></div><p><code>requests</code>も<code>limits</code>も定義されていないため、このPodは<code>BestEffort</code>QoSクラスで実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>requestsがlimitsより小さい値のため、このPodは<code>Burstable</code>QoSクラスで実行します。</p>
<p>選択されたポリシーが<code>none</code>以外の場合、トポロジーマネージャーは、これらのPodのSpecを考慮します。トポロジーマネージャーは、Hint Providersからトポロジーヒントを取得します。CPUマネージャーポリシーが<code>static</code>の場合、デフォルトのトポロジーヒントを返却します。これらのPodは明示的にCPUリソースを要求していないからです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/device</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/device</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>整数値でCPUリクエストを指定されたこのPodは、<code>requests</code>が<code>limits</code>が同じ値のため、<code>Guaranteed</code>QoSクラスで実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;300m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/device</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;300m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/device</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>CPUの一部をリクエストで指定されたこのPodは、<code>requests</code>が<code>limits</code>が同じ値のため、<code>Guaranteed</code>QoSクラスで実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/deviceA</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/deviceB</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/deviceA</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/deviceB</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>CPUもメモリもリクエスト値がないため、このPodは <code>BestEffort</code> QoSクラスで実行します。</p>
<p>トポロジーマネージャーは、上記Podを考慮します。トポロジーマネージャーは、Hint ProvidersとなるCPUマネージャーとデバイスマネージャーに問い合わせ、トポロジーヒントを取得します。</p>
<p>整数値でCPU要求を指定された<code>Guaranteed</code>QoSクラスのPodの場合、<code>static</code>が設定されたCPUマネージャーポリシーは、排他的なCPUに関するトポロジーヒントを返却し、デバイスマネージャーは要求されたデバイスのヒントを返します。</p>
<p>CPUの一部を要求を指定された<code>Guaranteed</code>QoSクラスのPodの場合、排他的ではないCPU要求のため<code>static</code>が設定されたCPUマネージャーポリシーはデフォルトのトポロジーヒントを返却します。デバイスマネージャーは要求されたデバイスのヒントを返します。</p>
<p>上記の<code>Guaranteed</code>QoSクラスのPodに関する2ケースでは、<code>none</code>で設定されたCPUマネージャーポリシーは、デフォルトのトポロジーヒントを返却します。</p>
<p><code>BestEffort</code>QoSクラスのPodの場合、<code>static</code>が設定されたCPUマネージャーポリシーは、CPUの要求がないためデフォルトのトポロジーヒントを返却します。デバイスマネージャーは要求されたデバイスごとのヒントを返します。</p>
<p>トポロジーマネージャーはこの情報を使用してPodに最適なヒントを計算し保存します。保存されたヒントは Hint Providersが使用しリソースを割り当てます。</p>
<h3 id=既知の制限>既知の制限</h3>
<ol>
<li>
<p>トポロジーマネージャーが許容するNUMAノードの最大値は8です。8より多いNUMAノードでは、可能なNUMAアフィニティを列挙しヒントを生成する際に、生成する状態数が爆発的に増加します。</p>
</li>
<li>
<p>スケジューラーはトポロジーを意識しません。そのため、ノードにスケジュールされた後に実行に失敗する可能性があります。</p>
</li>
</ol>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a8f6511197efcd7d0db80ade49620f9d>3.12 - 拡張リソースをNodeにアドバタイズする</h1>
<p>このページでは、Nodeに対して拡張リソースを指定する方法を説明します。拡張リソースを利用すると、Kubernetesにとって未知のノードレベルのリソースをクラスター管理者がアドバタイズできるようになります。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=nodeの名前を取得する>Nodeの名前を取得する</h2>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes
</code></pre></div><p>この練習で使いたいNodeを1つ選んでください。</p>
<h2 id=nodeの1つで新しい拡張リソースをアドバタイズする>Nodeの1つで新しい拡張リソースをアドバタイズする</h2>
<p>Node上の新しい拡張リソースをアドバタイズするには、HTTPのPATCHリクエストをKubernetes APIサーバーに送ります。たとえば、Nodeの1つに4つのドングルが接続されているとします。以下に、4つのドングルリソースをNodeにアドバタイズするPATCHリクエストの例を示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>PATCH /api/v1/nodes/&lt;選択したNodeの名前&gt;/status HTTP/1.1
Accept: application/json
Content-Type: application/json-patch+json
Host: k8s-master:8080

<span style=color:#666>[</span>
  <span style=color:#666>{</span>
    <span style=color:#b44>&#34;op&#34;</span>: <span style=color:#b44>&#34;add&#34;</span>,
    <span style=color:#b44>&#34;path&#34;</span>: <span style=color:#b44>&#34;/status/capacity/example.com~1dongle&#34;</span>,
    <span style=color:#b44>&#34;value&#34;</span>: <span style=color:#b44>&#34;4&#34;</span>
  <span style=color:#666>}</span>
<span style=color:#666>]</span>
</code></pre></div><p>Kubernetesは、ドングルとは何かも、ドングルが何に利用できるのかを知る必要もないことに注意してください。上のPATCHリクエストは、ただNodeが4つのドングルと呼ばれるものを持っているとKubernetesに教えているだけです。</p>
<p>Kubernetes APIサーバーに簡単にリクエストを送れるように、プロキシーを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy
</code></pre></div><p>もう1つのコマンドウィンドウを開き、HTTPのPATCHリクエストを送ります。<code>&lt;選択したNodeの名前></code>の部分は、選択したNodeの名前に置き換えてください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1dongle&#34;, &#34;value&#34;: &#34;4&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>http://localhost:8001/api/v1/nodes/&lt;選択したNodeの名前&gt;/status
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 上のリクエストにある<code>~1</code>は、PATCHのパスにおける<code>/</code>という文字をエンコーディングしたものです。JSON-Patch内のoperationのpathはJSON-Pointerとして解釈されます。詳細については、<a href=https://tools.ietf.org/html/rfc6901>IETF RFC 6901</a>のsection 3を読んでください。
</div>
<p>出力には、Nodeがキャパシティー4のdongleを持っていることが示されます。</p>
<pre><code>&quot;capacity&quot;: {
  &quot;cpu&quot;: &quot;2&quot;,
  &quot;memory&quot;: &quot;2049008Ki&quot;,
  &quot;example.com/dongle&quot;: &quot;4&quot;,
</code></pre><p>Nodeの説明を確認します。</p>
<pre><code>kubectl describe node &lt;選択したNodeの名前&gt;
</code></pre><p>出力には、再びdongleリソースが表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb>  </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb>  </span>2049008Ki<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb>  </span><span style=color:#666>4</span><span style=color:#bbb>
</span></code></pre></div><p>これで、アプリケーション開発者は特定の数のdongleをリクエストするPodを作成できるようになりました。詳しくは、<a href=/docs/tasks/configure-pod-container/extended-resource/>拡張リソースをコンテナに割り当てる</a>を読んでください。</p>
<h2 id=議論>議論</h2>
<p>拡張リソースは、メモリやCPUリソースと同様のものです。たとえば、Nodeが持っている特定の量のメモリやCPUがNode上で動作している他のすべてのコンポーネントと共有されるのと同様に、Nodeが搭載している特定の数のdongleが他のすべてのコンポーネントと共有されます。そして、アプリケーション開発者が特定の量のメモリとCPUをリクエストするPodを作成できるのと同様に、Nodeが搭載している特定の数のdongleをリクエストするPodが作成できます。</p>
<p>拡張リソースはKubernetesには詳細を意図的に公開しないため、Kubernetesは拡張リソースの実体をまったく知りません。Kubernetesが知っているのは、Nodeが特定の数の拡張リソースを持っているということだけです。拡張リソースは整数値でアドバタイズしなければなりません。たとえば、Nodeは4つのdongleをアドバタイズできますが、4.5のdongleというのはアドバタイズできません。</p>
<h3 id=storageの例>Storageの例</h3>
<p>Nodeに800GiBの特殊なディスクストレージがあるとします。この特殊なストレージの名前、たとえばexample.com/special-storageという名前の拡張リソースが作れます。そして、そのなかの一定のサイズ、たとえば100GiBのチャンクをアドバタイズできます。この場合、Nodeはexample.com/special-storageという種類のキャパシティ8のリソースを持っているとアドバタイズします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/special-storage</span>:<span style=color:#bbb> </span><span style=color:#666>8</span><span style=color:#bbb>
</span></code></pre></div><p>特殊なストレージに任意のサイズのリクエストを許可したい場合、特殊なストレージを1バイトのサイズのチャンクでアドバタイズできます。その場合、example.com/special-storageという種類の800Giのリソースとしてアドバタイズします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>Capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>example.com/special-storage</span>:<span style=color:#bbb>  </span>800Gi<span style=color:#bbb>
</span></code></pre></div><p>すると、コンテナは好きなバイト数の特殊なストレージを最大800Giまでリクエストできるようになります。</p>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>以下に、dongleのアドバタイズをNodeから削除するPATCHリクエストを示します。</p>
<pre><code>PATCH /api/v1/nodes/&lt;選択したNodeの名前&gt;/status HTTP/1.1
Accept: application/json
Content-Type: application/json-patch+json
Host: k8s-master:8080

[
  {
    &quot;op&quot;: &quot;remove&quot;,
    &quot;path&quot;: &quot;/status/capacity/example.com~1dongle&quot;,
  }
]
</code></pre><p>Kubernetes APIサーバーに簡単にリクエストを送れるように、プロキシーを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl proxy
</code></pre></div><p>もう1つのコマンドウィンドウで、HTTPのPATCHリクエストを送ります。<code>&lt;選択したNodeの名前></code>の部分は、選択したNodeの名前に置き換えてください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1dongle&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>http://localhost:8001/api/v1/nodes/&lt;選択したNodeの名前&gt;/status
</code></pre></div><p>dongleのアドバタイズが削除されたことを検証します。</p>
<pre><code>kubectl describe node &lt;選択したNodeの名前&gt; | grep dongle
</code></pre><p>(出力には何も表示されないはずです)</p>
<h2 id=次の項目>次の項目</h2>
<h3 id=アプリケーション開発者向け>アプリケーション開発者向け</h3>
<ul>
<li><a href=/ja/docs/tasks/configure-pod-container/extended-resource/>拡張リソースをコンテナに割り当てる</a></li>
</ul>
<h3 id=クラスター管理者向け>クラスター管理者向け</h3>
<ul>
<li><a href=/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>Namespaceに対してメモリの最小値と最大値の制約を設定する</a></li>
<li><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>Namespaceに対してCPUの最小値と最大値の制約を設定する</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-aa0731e8aa8e2f6cc9e3c1a5e9895863>4 - Kubernetesオブジェクトの管理</h1>
<div class=lead>Kubernetes APIと対話するための宣言型および命令型のパラダイム。</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-94f49ece137035764368f22a98942872>5 - Secretの管理</h1>
<div class=lead>Secretを使用した機密設定データの管理</div>
</div>
<div class=td-content>
<h1 id=pg-0ed63ce3c9665aed7ff5a560ff1da843>5.1 - kubectlを使用してSecretを管理する</h1>
<div class=lead>kubectlコマンドラインを使用してSecretを作成する</div>
<h2 id=始める前に>始める前に</h2>
<p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
<h2 id=secretを作成する>Secretを作成する</h2>
<p><code>Secret</code>はデータベースにアクセスするためにPodが必要とするユーザー資格情報を含めることができます。
たとえば、データベース接続文字列はユーザー名とパスワードで構成されます。
ユーザー名はローカルマシンの<code>./username.txt</code>に、パスワードは<code>./password.txt</code>に保存します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> &gt; ./username.txt
<span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> &gt; ./password.txt
</code></pre></div><p>上記の2つのコマンドの<code>-n</code>フラグは、生成されたファイルにテキスト末尾の余分な改行文字が含まれないようにします。
<code>kubectl</code>がファイルを読み取り、内容をbase64文字列にエンコードすると、余分な改行文字もエンコードされるため、これは重要です。</p>
<p><code>kubectl create secret</code>コマンドはこれらのファイルをSecretにパッケージ化し、APIサーバー上にオブジェクトを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span>./username.txt <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span>./password.txt
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>secret/db-user-pass created
</code></pre><p>ファイル名がデフォルトのキー名になります。オプションで<code>--from-file=[key=]source</code>を使用してキー名を設定できます。たとえば:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>./username.txt <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>./password.txt
</code></pre></div><p><code>--from-file</code>に指定したファイルに含まれるパスワードの特殊文字をエスケープする必要はありません。</p>
<p>また、<code>--from-literal=&lt;key>=&lt;value></code>タグを使用してSecretデータを提供することもできます。
このタグは、複数のキーと値のペアを提供するために複数回指定することができます。
<code>$</code>、<code>\</code>、<code>*</code>、<code>=</code>、<code>!</code>などの特殊文字は<a href=https://en.wikipedia.org/wiki/Shell_(computing)>シェル</a>によって解釈されるため、エスケープを必要とすることに注意してください。
ほとんどのシェルでは、パスワードをエスケープする最も簡単な方法は、シングルクォート(<code>'</code>)で囲むことです。
たとえば、実際のパスワードが<code>S!B\*d$zDsb=</code>の場合、次のようにコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;S!B\*d$zDsb=&#39;</span>
</code></pre></div><h2 id=secretを検証する>Secretを検証する</h2>
<p>Secretが作成されたことを確認できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secrets
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>NAME                  TYPE                                  DATA      AGE
db-user-pass          Opaque                                2         51s
</code></pre><p><code>Secret</code>の説明を参照できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe secrets/db-user-pass
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>Name:            db-user-pass
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

Data
====
password:    12 bytes
username:    5 bytes
</code></pre><p><code>kubectl get</code>と<code>kubectl describe</code>コマンドはデフォルトでは<code>Secret</code>の内容を表示しません。
これは、<code>Secret</code>が不用意に他人にさらされたり、ターミナルログに保存されたりしないようにするためです。</p>
<h2 id=decoding-secret>Secretをデコードする </h2>
<p>先ほど作成したSecretの内容を見るには、以下のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secret db-user-pass -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data}&#39;</span>
</code></pre></div><p>出力は次のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;password&#34;</span>:<span style=color:#b44>&#34;MWYyZDFlMmU2N2Rm&#34;</span>,<span style=color:green;font-weight:700>&#34;username&#34;</span>:<span style=color:#b44>&#34;YWRtaW4=&#34;</span>}
</code></pre></div><p><code>password</code>のデータをデコードします:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;MWYyZDFlMmU2N2Rm&#39;</span> | base64 --decode
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>1f2d1e2e67df
</code></pre><h2 id=クリーンアップ>クリーンアップ</h2>
<p>作成したSecretを削除するには次のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete secret db-user-pass
</code></pre></div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/configuration/secret/>Secretのコンセプト</a>を読む</li>
<li><a href=/ja/docs/tasks/configmap-secret/managing-secret-using-config-file/>設定ファイルを使用してSecretを管理する</a>方法を知る</li>
<li><a href=/docs/tasks/configmap-secret/managing-secret-using-kustomize/>kustomizeを使用してSecretを管理する</a>方法を知る</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-e841cf91fd3566db1e86143ed7a9e13c>5.2 - 設定ファイルを使用してSecretを管理する</h1>
<div class=lead>リソース設定ファイルを使用してSecretを作成する</div>
<h2 id=始める前に>始める前に</h2>
<p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
<h2 id=設定ファイルを作成する>設定ファイルを作成する</h2>
<p>あらかじめYAMLまたはJSON形式でSecretのマニフェストを作成したうえで、オブジェクトを作成することができます。
<a href=/docs/reference/generated/kubernetes-api/v1.22/#secret-v1-core>Secret</a>リソースには、<code>data</code>と<code>stringData</code>の2つのマップが含まれています。
<code>data</code>フィールドは任意のデータを格納するのに使用され、base64でエンコードされます。
<code>stringData</code>フィールドは利便性のために用意されており、Secretデータをエンコードされていない文字列として提供することができます。
<code>data</code>と<code>stringData</code>のキーは、英数字、<code>-</code>、<code>_</code>、<code>.</code>で構成されている必要があります。</p>
<p>たとえば、<code>data</code>フィールドを使用して2つの文字列をSecretに格納するには、次のように文字列をbase64に変換します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> | base64
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>YWRtaW4=
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> | base64
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>MWYyZDFlMmU2N2Rm
</code></pre><p>以下のようなSecret設定ファイルを記述します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></code></pre></div><p>なお、Secretオブジェクトの名前は、有効な<a href=/ja/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNSサブドメイン名</a>である必要があります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> SecretデータのシリアライズされたJSONおよびYAMLの値は、base64文字列としてエンコードされます。
文字列中の改行は不正で、含まれていてはなりません。
Darwin/macOSで<code>base64</code>ユーティリティーを使用する場合、長い行を分割するために<code>-b</code>オプションを使用するのは避けるべきです。
逆に、Linux ユーザーは、<code>base64</code> コマンドにオプション<code>-w 0</code>を追加するか、<code>-w</code>オプションが利用できない場合には、パイプライン<code>base64 | tr -d '\n'</code>を追加する<em>必要があります</em>。
</div>
<p>特定のシナリオでは、代わりに<code>stringData</code>フィールドを使用できます。
このフィールドでは、base64エンコードされていない文字列を直接Secretに入れることができ、Secretの作成時や更新時には、その文字列がエンコードされます。</p>
<p>たとえば、設定ファイルを保存するためにSecretを使用しているアプリケーションをデプロイする際に、デプロイプロセス中に設定ファイルの一部を入力したい場合などが考えられます。</p>
<p>たとえば、次のような設定ファイルを使用しているアプリケーションの場合:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiUrl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my.api.com/api/v1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;user&gt;&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;password&gt;&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>次のような定義でSecretに格納できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    apiUrl: &#34;https://my.api.com/api/v1&#34;
</span><span style=color:#b44;font-style:italic>    username: &lt;user&gt;
</span><span style=color:#b44;font-style:italic>    password: &lt;password&gt;</span><span style=color:#bbb>    
</span></code></pre></div><h2 id=secretを作成する>Secretを作成する</h2>
<p><a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>でSecretを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f ./secret.yaml
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>secret/mysecret created
</code></pre><h2 id=secretを確認する>Secretを確認する</h2>
<p><code>stringData</code>フィールドは、書き込み専用の便利なフィールドです。Secretを取得する際には決して出力されません。たとえば、次のようなコマンドを実行した場合:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secret mysecret -o yaml
</code></pre></div><p>出力は次のようになります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>YXBpVXJsOiAiaHR0cHM6Ly9teS5hcGkuY29tL2FwaS92MSIKdXNlcm5hbWU6IHt7dXNlcm5hbWV9fQpwYXNzd29yZDoge3twYXNzd29yZH19<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:40:59Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7225&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>c280ad2e-e916-11e8-98f2-025000000001<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></code></pre></div><p><code>kubectl get</code>と<code>kubectl describe</code>コマンドはデフォルトではSecretの内容を表示しません。
これは、Secretが不用意に他人にさらされたり、ターミナルログに保存されたりしないようにするためです。
エンコードされたデータの実際の内容を確認するには、<a href=/ja/docs/tasks/configmap-secret/managing-secret-using-kubectl/#decoding-secret>Secretのデコード</a>を参照してください。</p>
<p><code>username</code>などのフィールドが<code>data</code>と<code>stringData</code>の両方に指定されている場合は、<code>stringData</code>の値が使われます。
たとえば、以下のようなSecretの定義の場合:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>administrator<span style=color:#bbb>
</span></code></pre></div><p>結果は以下の通りです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW5pc3RyYXRvcg==<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:46:46Z<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7579&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>91460ecb-e917-11e8-98f2-025000000001<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></code></pre></div><p><code>YWRtaW5pc3RyYXRvcg==</code>をデコードすると<code>administrator</code>となります。</p>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>作成したSecretを削除するには次のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete secret mysecret
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/configuration/secret/>Secretのコンセプト</a>を読む</li>
<li><a href=/ja/docs/tasks/configmap-secret/managing-secret-using-kubectl/>kubectlを使用してSecretを管理する</a>方法を知る</li>
<li><a href=/docs/tasks/configmap-secret/managing-secret-using-kustomize/>kustomizeを使用してSecretを管理する</a>方法を知る</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a0ff2e3ba8af5670d5dc3d94c4bd0a68>5.3 - Kustomizeを使用してSecretを管理する</h1>
<div class=lead>kustomization.yamlを使用してSecretを作成する</div>
<p>Kubernetes v1.14以降、<code>kubectl</code>は<a href=/docs/tasks/manage-kubernetes-objects/kustomization/>Kustomizeを使ったオブジェクト管理</a>をサポートしています。
KustomizeはSecretやConfigMapを作成するためのリソースジェネレーターを提供します。
Kustomizeジェネレーターは、ディレクトリ内の<code>kustomization.yaml</code>ファイルで指定します。
Secretを生成したら、<code>kubectl apply</code>でAPIサーバー上にSecretを作成します。</p>
<h2 id=始める前に>始める前に</h2>
<p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
<h2 id=kustomizationファイルを作成する>Kustomizationファイルを作成する</h2>
<p><code>kustomization.yaml</code>ファイルの中で<code>secretGenerator</code>を定義し、他の既存のファイルを参照することで、Secretを生成することができます。
たとえば、以下のkustomizationファイルは<code>./username.txt</code>と<code>./password.txt</code>を参照しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>secretGenerator</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user-pass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>files</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- username.txt<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- password.txt<span style=color:#bbb>
</span></code></pre></div><p>また、<code>kustomization.yaml</code>ファイルの中でリテラルを指定して<code>secretGenerator</code>を定義することもできます。
たとえば、以下の<code>kustomization.yaml</code>ファイルには<code>username</code>と<code>password</code>の2つのリテラルが含まれています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>secretGenerator</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user-pass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>literals</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- username=admin<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- password=1f2d1e2e67df<span style=color:#bbb>
</span></code></pre></div><p>また、<code>kustomization.yaml</code>ファイルに<code>.env</code>ファイルを用意して<code>secretGenerator</code>を定義することもできます。
たとえば、以下の<code>kustomization.yaml</code>ファイルは、<code>.env.secret</code>ファイルからデータを取り込みます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>secretGenerator</span>:<span style=color:#bbb>
</span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user-pass<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>envs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- .env.secret<span style=color:#bbb>
</span></code></pre></div><p>なお、いずれの場合も、値をbase64エンコードする必要はありません。</p>
<h2 id=secretを作成する>Secretを作成する</h2>
<p><code>kustomization.yaml</code>を含むディレクトリを適用して、Secretを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -k .
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>secret/db-user-pass-96mffmfh4k created
</code></pre><p>なお、Secretを生成する際には、データをハッシュ化し、そのハッシュ値を付加することでSecret名を生成します。
これにより、データが変更されるたびに、新しいSecretが生成されます。</p>
<h2 id=作成したsecretを確認する>作成したSecretを確認する</h2>
<p>Secretが作成されたことを確認できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get secrets
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>NAME                             TYPE                                  DATA      AGE
db-user-pass-96mffmfh4k          Opaque                                2         51s
</code></pre><p>Secretの説明を参照できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe secrets/db-user-pass-96mffmfh4k
</code></pre></div><p>出力は次のようになります:</p>
<pre><code>Name:            db-user-pass-96mffmfh4k
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

Data
====
password.txt:    12 bytes
username.txt:    5 bytes
</code></pre><p><code>kubectl get</code>と<code>kubectl describe</code>コマンドはデフォルトではSecretの内容を表示しません。
これは、Secretが不用意に他人にさらされたり、ターミナルログに保存されたりしないようにするためです。
エンコードされたデータの実際の内容を確認するには、<a href=/ja/docs/tasks/configmap-secret/managing-secret-using-kubectl/#decoding-secret>Secretのデコード</a>を参照してください。</p>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>作成したSecretを削除するには次のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete secret db-user-pass-96mffmfh4k
</code></pre></div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/configuration/secret/>Secretのコンセプト</a>を読む</li>
<li><a href=/ja/docs/tasks/configmap-secret/managing-secret-using-kubectl/>kubectlを使用してSecretを管理する</a>方法を知る</li>
<li><a href=/ja/docs/tasks/configmap-secret/managing-secret-using-config-file/>設定ファイルを使用してSecretを管理する</a>方法を知る</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-866924fa095f897ede8dfdcab9e97942>6 - アプリケーションへのデータ注入</h1>
<div class=lead>ワークロードを実行するPodの構成とその他のデータを指定します。</div>
</div>
<div class=td-content>
<h1 id=pg-82c93897176489678232542102daea40>6.1 - コンテナの環境変数の定義</h1>
<p>このページでは、Kubernetes Podでコンテナの環境変数を定義する方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=define-an-environment-variable-for-a-container>コンテナの環境変数を定義する</h2>
<p>Podを作成するとき、そのPodで実行するコンテナに環境変数を設定することができます。環境変数を設定するには、設定ファイルに <code>env</code> または <code>envFrom</code> フィールドを含めます。</p>
<p>この演習では、1つのコンテナを実行するPodを作成します。Podの設定ファイルには、名前 <code>DEMO_GREETING</code>、値 <code>"Hello from the environment"</code>を持つ環境変数が定義されています。Podの設定マニフェストを以下に示します:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/inject/envars.yaml download=pods/inject/envars.yaml><code>pods/inject/envars.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-envars-yaml')" title="Copy pods/inject/envars.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-envars-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envar-demo<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>purpose</span>:<span style=color:#bbb> </span>demonstrate-envars<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envar-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>DEMO_GREETING<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Hello from the environment&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>DEMO_FAREWELL<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Such a sweet sorrow&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>マニフェストに基づいてPodを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/inject/envars.yaml
</code></pre></div></li>
<li>
<p>実行中のPodを一覧表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>purpose</span><span style=color:#666>=</span>demonstrate-envars
</code></pre></div><p>出力は以下のようになります:</p>
<pre><code>NAME            READY     STATUS    RESTARTS   AGE
envar-demo      1/1       Running   0          9s
</code></pre></li>
<li>
<p>Podで実行しているコンテナのシェルを取得します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it envar-demo -- /bin/bash
</code></pre></div></li>
<li>
<p>シェルで<code>printenv</code>コマンドを実行すると、環境変数の一覧が表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># コンテナ内のシェルで以下のコマンドを実行します</span>
printenv
</code></pre></div><p>出力は以下のようになります:</p>
<pre><code>NODE_VERSION=4.4.2
EXAMPLE_SERVICE_PORT_8080_TCP_ADDR=10.3.245.237
HOSTNAME=envar-demo
...
DEMO_GREETING=Hello from the environment
DEMO_FAREWELL=Such a sweet sorrow
</code></pre></li>
<li>
<p>シェルを終了するには、<code>exit</code>と入力します。</p>
</li>
</ol>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>env</code>または<code>envFrom</code>フィールドを使用して設定された環境変数は、コンテナイメージで指定された環境変数を上書きします。
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 環境変数は相互に参照でき、循環して使用可能です。使用する前に順序に注意してください。
</div>
<h2 id=using-environment-variables-inside-of-your-config>設定の中で環境変数を使用する</h2>
<p>Podの設定で定義した環境変数は、Podのコンテナに設定したコマンドや引数など、設定の他の場所で使用することができます。以下の設定例では、環境変数<code>GREETING</code>、<code>HONORORIFIC</code>、<code>NAME</code>にそれぞれ <code>Warm greetings to</code>、<code>The Most Honorable</code>、<code>Kubernetes</code>を設定しています。これらの環境変数は、<code>env-print-demo</code>コンテナに渡されるCLI引数で使われます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>print-greeting<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-print-demo<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>bash<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>GREETING<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Warm greetings to&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>HONORIFIC<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;The Most Honorable&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>NAME<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Kubernetes&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;echo&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;$(GREETING) $(HONORIFIC) $(NAME)&#34;</span>]<span style=color:#bbb>
</span></code></pre></div><p>作成されると、コンテナ上で<code>echo Warm greetings to The Most Honorable Kubernetes</code>というコマンドが実行されます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>環境変数</a>の詳細</li>
<li><a href=/docs/concepts/configuration/secret/#using-secrets-as-environment-variables>Secretを環境変数として使用する</a>詳細</li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#envvarsource-v1-core>EnvVarSource</a>をご覧ください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-66c0456fdbef5e5116dd606d1e6f73cc>6.2 - 環境変数によりコンテナにPod情報を共有する</h1>
<p>このページでは、Podが内部で実行しているコンテナに自身の情報を共有する方法を説明します。環境変数ではPodのフィールドとコンテナのフィールドを共有することができます。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=the-downward-api>Downward API</h2>
<p>Podとコンテナのフィールドを実行中のコンテナに共有する方法は2つあります:</p>
<ul>
<li>環境変数</li>
<li><a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#the-downward-api>ボリュームファイル</a></li>
</ul>
<p>これら2つの方法を合わせて、Podとコンテナフィールドを共有する方法を<em>Downward API</em>と呼びます。</p>
<h2 id=use-pod-fields-as-values-for-environment-variables>Podフィールドを環境変数の値として使用する</h2>
<p>この演習では、1つのコンテナを持つPodを作成します。Podの設定ファイルは次のとおりです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/inject/dapi-envars-pod.yaml download=pods/inject/dapi-envars-pod.yaml><code>pods/inject/dapi-envars-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-dapi-envars-pod-yaml')" title="Copy pods/inject/dapi-envars-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-dapi-envars-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-envars-fieldref<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- while true; do<span style=color:#bbb>
</span><span style=color:#bbb>          </span>echo -en &#39;\n&#39;;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>printenv MY_NODE_NAME MY_POD_NAME MY_POD_NAMESPACE;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>printenv MY_POD_IP MY_POD_SERVICE_ACCOUNT;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>sleep 10;<span style=color:#bbb>
</span><span style=color:#bbb>        </span>done;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_NODE_NAME<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>spec.nodeName<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_NAME<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_NAMESPACE<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.namespace<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_IP<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>status.podIP<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_POD_SERVICE_ACCOUNT<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>spec.serviceAccountName<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルには、5つの環境変数があります。<code>env</code>フィールドは<a href=/docs/reference/generated/kubernetes-api/v1.22/#envvar-v1-core>EnvVars</a>の配列です。配列の最初の要素では、環境変数<code>MY_NODE_NAME</code>の値をPodの<code>spec.nodeName</code>フィールドから取得することを指定します。同様に、他の環境変数もPodのフィールドから名前を取得します。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> この例のフィールドはPodのフィールドです。これらはPod内のコンテナのフィールドではありません。
</div>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-envars-pod.yaml
</code></pre></div><p>Podのコンテナが実行されていることを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>コンテナのログを表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs dapi-envars-fieldref
</code></pre></div><p>出力には、選択した環境変数の値が表示されます:</p>
<pre><code>minikube
dapi-envars-fieldref
default
172.17.0.4
default
</code></pre><p>これらの値がログにある理由を確認するには、設定ファイルの<code>command</code>および<code>args</code>フィールドを確認してください。コンテナが起動すると、5つの環境変数の値が標準出力に書き込まれます。これを10秒ごとに繰り返します。</p>
<p>次に、Podで実行しているコンテナへのシェルを取得します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it dapi-envars-fieldref -- sh
</code></pre></div><p>シェルで環境変数を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>/# printenv
</code></pre></div><p>出力は、特定の環境変数にPodフィールドの値が割り当てられていることを示しています:</p>
<pre><code>MY_POD_SERVICE_ACCOUNT=default
...
MY_POD_NAMESPACE=default
MY_POD_IP=172.17.0.4
...
MY_NODE_NAME=minikube
...
MY_POD_NAME=dapi-envars-fieldref
</code></pre><h2 id=use-container-fields-as-values-for-environment-variables>コンテナフィールドを環境変数の値として使用する</h2>
<p>前の演習では、環境変数の値としてPodフィールドを使用しました。次の演習では、環境変数の値としてコンテナフィールドを使用します。これは、1つのコンテナを持つPodの設定ファイルです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/inject/dapi-envars-container.yaml download=pods/inject/dapi-envars-container.yaml><code>pods/inject/dapi-envars-container.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-inject-dapi-envars-container-yaml')" title="Copy pods/inject/dapi-envars-container.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-inject-dapi-envars-container-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-envars-resourcefieldref<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox:1.24<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- while true; do<span style=color:#bbb>
</span><span style=color:#bbb>          </span>echo -en &#39;\n&#39;;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>printenv MY_CPU_REQUEST MY_CPU_LIMIT;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>printenv MY_MEM_REQUEST MY_MEM_LIMIT;<span style=color:#bbb>
</span><span style=color:#bbb>          </span>sleep 10;<span style=color:#bbb>
</span><span style=color:#bbb>        </span>done;<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;32Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;125m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_CPU_REQUEST<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>requests.cpu<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_CPU_LIMIT<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.cpu<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_MEM_REQUEST<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>requests.memory<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MY_MEM_LIMIT<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.memory<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルには、4つの環境変数があります。<code>env</code>フィールドは<a href=/docs/reference/generated/kubernetes-api/v1.22/#envvar-v1-core>EnvVars</a>の配列です。配列の最初の要素では、環境変数<code>MY_CPU_REQUEST</code>の値を<code>test-container</code>という名前のコンテナの<code>requests.cpu</code>フィールドから取得することを指定します。同様に、他の環境変数もコンテナのフィールドから値を取得します。</p>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/pods/inject/dapi-envars-container.yaml
</code></pre></div><p>Podのコンテナが実行されていることを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods
</code></pre></div><p>コンテナのログを表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs dapi-envars-resourcefieldref
</code></pre></div><p>出力には、選択した環境変数の値が表示されます:</p>
<pre><code>1
1
33554432
67108864
</code></pre><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/tasks/inject-data-application/define-environment-variable-container/>コンテナの環境変数の定義</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#podspec-v1-core>PodSpec</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#container-v1-core>Container</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#envvar-v1-core>EnvVar</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#envvarsource-v1-core>EnvVarSource</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#objectfieldselector-v1-core>ObjectFieldSelector</a></li>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#resourcefieldselector-v1-core>ResourceFieldSelector</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a78a5e7e765fd8c49c8f7c0d72499f72>7 - アプリケーションの実行</h1>
<div class=lead>ステートレスアプリケーションとステートフルアプリケーションの両方を実行および管理します。</div>
</div>
<div class=td-content>
<h1 id=pg-790ea02857492b3a822e981e93e3a98b>7.1 - Deploymentを使用してステートレスアプリケーションを実行する</h1>
<p>このページでは、Kubernetes Deploymentオブジェクトを使用してアプリケーションを実行する方法を説明します。</p>
<h2 id=目標>目標</h2>
<ul>
<li>nginx deploymentを作成します。</li>
<li>kubectlを使ってdeploymentに関する情報を一覧表示します。</li>
<li>deploymentを更新します。</li>
</ul>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.9.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=nginx-deploymentの作成と探検>nginx deploymentの作成と探検</h2>
<p>Kubernetes Deploymentオブジェクトを作成することでアプリケーションを実行できます。また、YAMLファイルでDeploymentを記述できます。例えば、このYAMLファイルはnginx:1.14.2 Dockerイメージを実行するデプロイメントを記述しています:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-deployment-yaml')" title="Copy application/deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>YAMLファイルに基づいてDeploymentを作成します:</p>
<pre><code> kubectl apply -f https://k8s.io/examples/application/deployment.yaml
</code></pre>
</li>
<li>
<p>Deploymentに関する情報を表示します:</p>
<pre><code> kubectl describe deployment nginx-deployment
</code></pre>
<p>出力はこのようになります:</p>
<pre><code> Name:     nginx-deployment
 Namespace:    default
 CreationTimestamp:  Tue, 30 Aug 2016 18:11:37 -0700
 Labels:     app=nginx
 Annotations:    deployment.kubernetes.io/revision=1
 Selector:   app=nginx
 Replicas:   2 desired | 2 updated | 2 total | 2 available | 0 unavailable
 StrategyType:   RollingUpdate
 MinReadySeconds:  0
 RollingUpdateStrategy:  1 max unavailable, 1 max surge
 Pod Template:
   Labels:       app=nginx
   Containers:
    nginx:
     Image:              nginx:1.14.2
     Port:               80/TCP
     Environment:        &lt;none&gt;
     Mounts:             &lt;none&gt;
   Volumes:              &lt;none&gt;
 Conditions:
   Type          Status  Reason
   ----          ------  ------
   Available     True    MinimumReplicasAvailable
   Progressing   True    NewReplicaSetAvailable
 OldReplicaSets:   &lt;none&gt;
 NewReplicaSet:    nginx-deployment-1771418926 (2/2 replicas created)
 No events.
</code></pre>
</li>
<li>
<p>Deploymentによって作成されたPodを一覧表示します:</p>
<pre><code> kubectl get pods -l app=nginx
</code></pre>
<p>出力はこのようになります:</p>
<pre><code> NAME                                READY     STATUS    RESTARTS   AGE
 nginx-deployment-1771418926-7o5ns   1/1       Running   0          16h
 nginx-deployment-1771418926-r18az   1/1       Running   0          16h
</code></pre>
</li>
<li>
<p>Podに関する情報を表示します:</p>
<pre><code> kubectl describe pod &lt;pod-name&gt;
</code></pre>
<p>ここで<code>&lt;pod-name></code>はPodの1つの名前を指定します。</p>
</li>
</ol>
<h2 id=deploymentの更新>Deploymentの更新</h2>
<p>新しいYAMLファイルを適用してDeploymentを更新できます。このYAMLファイルは、Deploymentを更新してnginx 1.16.1を使用するように指定しています。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/deployment-update.yaml download=application/deployment-update.yaml><code>application/deployment-update.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-deployment-update-yaml')" title="Copy application/deployment-update.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-deployment-update-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16.1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Update the version of nginx from 1.14.2 to 1.16.1</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>新しいYAMLファイルを適用します:</p>
<pre><code>  kubectl apply -f https://k8s.io/examples/application/deployment-update.yaml
</code></pre>
</li>
<li>
<p>Deploymentが新しい名前でPodを作成し、古いPodを削除するのを監視します:</p>
<pre><code>  kubectl get pods -l app=nginx
</code></pre>
</li>
</ol>
<h2 id=レプリカ数を増やすことによるアプリケーションのスケール>レプリカ数を増やすことによるアプリケーションのスケール</h2>
<p>新しいYAMLファイルを適用することで、Deployment内のPodの数を増やすことができます。このYAMLファイルは<code>replicas</code>を4に設定します。これはDeploymentが4つのPodを持つべきであることを指定します:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/deployment-scale.yaml download=application/deployment-scale.yaml><code>application/deployment-scale.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-deployment-scale-yaml')" title="Copy application/deployment-scale.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-deployment-scale-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Update the replicas from 2 to 4</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>新しいYAMLファイルを適用します:</p>
<pre><code> kubectl apply -f https://k8s.io/examples/application/deployment-scale.yaml
</code></pre>
</li>
<li>
<p>Deploymentに4つのPodがあることを確認します:</p>
<pre><code> kubectl get pods -l app=nginx
</code></pre>
<p>出力はこのようになります:</p>
<pre><code> NAME                               READY     STATUS    RESTARTS   AGE
 nginx-deployment-148880595-4zdqq   1/1       Running   0          25s
 nginx-deployment-148880595-6zgi1   1/1       Running   0          25s
 nginx-deployment-148880595-fxcez   1/1       Running   0          2m
 nginx-deployment-148880595-rwovn   1/1       Running   0          2m
</code></pre>
</li>
</ol>
<h2 id=deploymentの削除>Deploymentの削除</h2>
<p>Deploymentを名前を指定して削除します:</p>
<pre><code>kubectl delete deployment nginx-deployment
</code></pre>
<h2 id=replicationcontrollers-昔のやり方>ReplicationControllers -- 昔のやり方</h2>
<p>複製アプリケーションを作成するための好ましい方法はDeploymentを使用することです。そして、DeploymentはReplicaSetを使用します。 DeploymentとReplicaSetがKubernetesに追加される前は、<a href=/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>を使用して複製アプリケーションを構成していました。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deploymentオブジェクト</a>の詳細</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-43398a6f5dc7ce19df59f5f4c2e7922d>7.2 - 単一レプリカのステートフルアプリケーションを実行する</h1>
<p>このページでは、PersistentVolumeとDeploymentを使用して、Kubernetesで単一レプリカのステートフルアプリケーションを実行する方法を説明します。アプリケーションはMySQLです。</p>
<h2 id=目標>目標</h2>
<ul>
<li>自身の環境のディスクを参照するPersistentVolumeを作成します。</li>
<li>MySQLのDeploymentを作成します。</li>
<li>MySQLをDNS名でクラスター内の他のPodに公開します。</li>
</ul>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
</li>
<li>
<p>ここで使用されている<a href=/docs/user-guide/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaims</a>の要件を満たすには、デフォルトの<a href=/docs/concepts/storage/storage-classes/>StorageClass</a>を使用して動的PersistentVolumeプロビジョナーを作成するか、<a href=/docs/user-guide/persistent-volumes/#provisioning>PersistentVolumesを静的にプロビジョニングする</a>必要があります。</p>
</li>
</ul>
<h2 id=mysqlをデプロイする>MySQLをデプロイする</h2>
<p>Kubernetes Deploymentを作成し、PersistentVolumeClaimを使用して既存のPersistentVolumeに接続することで、ステートフルアプリケーションを実行できます。
たとえば、以下のYAMLファイルはMySQLを実行し、PersistentVolumeClaimを参照するDeploymentを記述しています。
このファイルは/var/lib/mysqlのボリュームマウントを定義してから、20Gのボリュームを要求するPersistentVolumeClaimを作成します。
この要求は、要件を満たす既存のボリューム、または動的プロビジョナーによって満たされます。</p>
<p>注：パスワードはYAMLファイル内に定義されており、これは安全ではありません。安全な解決策については<a href=/docs/concepts/configuration/secret/>Kubernetes Secret</a>を参照してください 。</p>
<p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/mysql/mysql-deployment.yaml download=application/mysql/mysql-deployment.yaml><code>application/mysql/mysql-deployment.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-deployment-yaml')" title="Copy application/mysql/mysql-deployment.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-deployment-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Recreate<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql:5.6<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># Use secret in real usage</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-persistent-storage<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-persistent-storage<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>mysql-pv-claim<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/mysql/mysql-pv.yaml download=application/mysql/mysql-pv.yaml><code>application/mysql/mysql-pv.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-pv-yaml')" title="Copy application/mysql/mysql-pv.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-pv-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-pv-volume<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>local<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/mnt/data&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-pv-claim<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
</p>
<ol>
<li>
<p>YAMLファイルに記述されたPVとPVCをデプロイします。</p>
<pre><code> kubectl create -f https://k8s.io/examples/application/mysql/mysql-pv.yaml
</code></pre>
</li>
<li>
<p>YAMLファイルの内容をデプロイします。</p>
<pre><code> kubectl create -f https://k8s.io/examples/application/mysql/mysql-deployment.yaml
</code></pre>
</li>
<li>
<p>作成したDeploymentの情報を表示します。</p>
<pre><code> kubectl describe deployment mysql

 Name:                 mysql
 Namespace:            default
 CreationTimestamp:    Tue, 01 Nov 2016 11:18:45 -0700
 Labels:               app=mysql
 Annotations:          deployment.kubernetes.io/revision=1
 Selector:             app=mysql
 Replicas:             1 desired | 1 updated | 1 total | 0 available | 1 unavailable
 StrategyType:         Recreate
 MinReadySeconds:      0
 Pod Template:
   Labels:       app=mysql
   Containers:
    mysql:
     Image:      mysql:5.6
     Port:       3306/TCP
     Environment:
       MYSQL_ROOT_PASSWORD:      password
     Mounts:
       /var/lib/mysql from mysql-persistent-storage (rw)
   Volumes:
    mysql-persistent-storage:
     Type:       PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)
     ClaimName:  mysql-pv-claim
     ReadOnly:   false
 Conditions:
   Type          Status  Reason
   ----          ------  ------
   Available     False   MinimumReplicasUnavailable
   Progressing   True    ReplicaSetUpdated
 OldReplicaSets:       &lt;none&gt;
 NewReplicaSet:        mysql-63082529 (1/1 replicas created)
 Events:
   FirstSeen    LastSeen    Count    From                SubobjectPath    Type        Reason            Message
   ---------    --------    -----    ----                -------------    --------    ------            -------
   33s          33s         1        {deployment-controller }             Normal      ScalingReplicaSet Scaled up replica set mysql-63082529 to 1
</code></pre>
</li>
<li>
<p>Deploymentによって作成されたPodを一覧表示します。</p>
<pre><code> kubectl get pods -l app=mysql

 NAME                   READY     STATUS    RESTARTS   AGE
 mysql-63082529-2z3ki   1/1       Running   0          3m
</code></pre>
</li>
<li>
<p>PersistentVolumeClaimを確認します。</p>
<pre><code> kubectl describe pvc mysql-pv-claim

 Name:         mysql-pv-claim
 Namespace:    default
 StorageClass:
 Status:       Bound
 Volume:       mysql-pv-volume
 Labels:       &lt;none&gt;
 Annotations:    pv.kubernetes.io/bind-completed=yes
                 pv.kubernetes.io/bound-by-controller=yes
 Capacity:     20Gi
 Access Modes: RWO
 Events:       &lt;none&gt;
</code></pre>
</li>
</ol>
<h2 id=mysqlインスタンスにアクセスする>MySQLインスタンスにアクセスする</h2>
<p>前述のYAMLファイルは、クラスター内の他のPodがデータベースにアクセスできるようにするServiceを作成します。
Serviceのオプションで<code>clusterIP: None</code>を指定すると、ServiceのDNS名がPodのIPアドレスに直接解決されます。
このオプションは、ServiceのバックエンドのPodが1つのみであり、Podの数を増やす予定がない場合に適しています。</p>
<p>MySQLクライアントを実行してサーバーに接続します。</p>
<pre><code>kubectl run -it --rm --image=mysql:5.6 --restart=Never mysql-client -- mysql -h mysql -ppassword
</code></pre><p>このコマンドは、クラスター内にMySQLクライアントを実行する新しいPodを作成し、Serviceを通じてMySQLサーバーに接続します。
接続できれば、ステートフルなMySQLデータベースが稼働していることが確認できます。</p>
<pre><code>Waiting for pod default/mysql-client-274442439-zyp6i to be running, status is Pending, pod ready: false
If you don't see a command prompt, try pressing enter.

mysql&gt;
</code></pre><h2 id=アップデート>アップデート</h2>
<p>イメージまたはDeploymentの他の部分は、<code>kubectl apply</code>コマンドを使用して通常どおりに更新できます。
ステートフルアプリケーションに固有のいくつかの注意事項を以下に記載します。</p>
<ul>
<li>アプリケーションをスケールしないでください。このセットアップは単一レプリカのアプリケーション専用です。
下層にあるPersistentVolumeは1つのPodにしかマウントできません。
クラスター化されたステートフルアプリケーションについては、<a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSetのドキュメント</a>を参照してください。</li>
<li>Deploymentを定義するYAMLファイルでは<code>strategy: type: Recreate</code>を使用して下さい。
この設定はKubernetesにローリングアップデートを使用 <em>しない</em> ように指示します。
同時に複数のPodを実行することはできないため、ローリングアップデートは使用できません。
<code>Recreate</code>戦略は、更新された設定で新しいPodを作成する前に、最初のPodを停止します。</li>
</ul>
<h2 id=deploymentの削除>Deploymentの削除</h2>
<p>名前を指定してデプロイしたオブジェクトを削除します。</p>
<pre><code>kubectl delete deployment,svc mysql
kubectl delete pvc mysql-pv-claim
kubectl delete pv mysql-pv-volume
</code></pre><p>PersistentVolumeを手動でプロビジョニングした場合は、PersistentVolumeを手動で削除し、また、下層にあるリソースも解放する必要があります。
動的プロビジョニング機能を使用した場合は、PersistentVolumeClaimを削除すれば、自動的にPersistentVolumeも削除されます。
一部の動的プロビジョナー(EBSやPDなど)は、PersistentVolumeを削除すると同時に下層にあるリソースも解放します。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>
<p><a href=/ja/docs/concepts/workloads/controllers/deployment/>Deploymentオブジェクト</a>についてもっと学ぶ</p>
</li>
<li>
<p><a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>アプリケーションのデプロイ</a>についてもっと学ぶ</p>
</li>
<li>
<p><a href=/docs/reference/generated/kubectl/kubectl-commands/#run>kubectl runのドキュメント</a></p>
</li>
<li>
<p><a href=/docs/concepts/storage/volumes/>Volumes</a>と<a href=/docs/concepts/storage/persistent-volumes/>Persistent Volumes</a></p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-95b3d561509c573e53bec2368264cf6a>7.3 - レプリカを持つステートフルアプリケーションを実行する</h1>
<p>このページでは、<a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>
コントローラーを使用して、レプリカを持つステートフルアプリケーションを実行する方法を説明します。
ここでの例は、非同期レプリケーションを行う複数のスレーブを持つ、単一マスターのMySQLです。</p>
<p><strong>この例は本番環境向けの構成ではない</strong>ことに注意してください。
具体的には、MySQLの設定が安全ではないデフォルトのままとなっています。
これはKubernetesでステートフルアプリケーションを実行するための一般的なパターンに焦点を当てるためです。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</li>
<li><p>ここで使用されている<a href=/docs/user-guide/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaims</a>の要件を満たすには、デフォルトの<a href=/docs/concepts/storage/storage-classes/>StorageClass</a>を使用して動的PersistentVolumeプロビジョナーを作成するか、<a href=/docs/user-guide/persistent-volumes/#provisioning>PersistentVolumesを静的にプロビジョニングする</a>必要があります。</p>
</li>
<li>このチュートリアルは、あなたが<a href=/ja/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>
と<a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>、
さらには<a href=/ja/docs/concepts/workloads/pods/>Pod</a>、
<a href=/ja/docs/concepts/services-networking/service/>Service</a>、
<a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>などの
他のコアな概念に精通していることを前提としています。</li>
<li>MySQLに関する知識は記事の理解に役立ちますが、
このチュートリアルは他のシステムにも役立つ一般的なパターンを提示することを目的としています。</li>
</ul>
<h2 id=目標>目標</h2>
<ul>
<li>StatefulSetコントローラーを使用して、レプリカを持つMySQLトポロジーをデプロイします。</li>
<li>MySQLクライアントトラフィックを送信します。</li>
<li>ダウンタイムに対する耐性を観察します。</li>
<li>StatefulSetをスケールアップおよびスケールダウンします。</li>
</ul>
<h2 id=mysqlをデプロイする>MySQLをデプロイする</h2>
<p>このMySQLのデプロイの例は、1つのConfigMap、2つのService、および1つのStatefulSetから構成されます。</p>
<h3 id=configmap>ConfigMap</h3>
<p>次のYAML設定ファイルからConfigMapを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-configmap.yaml
</code></pre></div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/mysql/mysql-configmap.yaml download=application/mysql/mysql-configmap.yaml><code>application/mysql/mysql-configmap.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-configmap-yaml')" title="Copy application/mysql/mysql-configmap.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-configmap-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>master.cnf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    # Apply this config only on the master.
</span><span style=color:#b44;font-style:italic>    [mysqld]
</span><span style=color:#b44;font-style:italic>    log-bin</span><span style=color:#bbb>    
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>slave.cnf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>    # Apply this config only on slaves.
</span><span style=color:#b44;font-style:italic>    [mysqld]
</span><span style=color:#b44;font-style:italic>    super-read-only</span><span style=color:#bbb>    
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>このConfigMapは、MySQLマスターとスレーブの設定を独立して制御するために、
それぞれの<code>my.cnf</code>を上書きする内容を提供します。
この場合、マスターはスレーブにレプリケーションログを提供するようにし、
スレーブはレプリケーション以外の書き込みを拒否するようにします。</p>
<p>ConfigMap自体に特別なことはありませんが、ConfigMapの各部分は異なるPodに適用されます。
各Podは、StatefulSetコントローラーから提供される情報に基づいて、
初期化時にConfigMapのどの部分を見るかを決定します。</p>
<h3 id=services>Services</h3>
<p>以下のYAML設定ファイルからServiceを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-services.yaml
</code></pre></div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/mysql/mysql-services.yaml download=application/mysql/mysql-services.yaml><code>application/mysql/mysql-services.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-services-yaml')" title="Copy application/mysql/mysql-services.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-services-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#080;font-style:italic># Headless service for stable DNS entries of StatefulSet members.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Client service for connecting to any MySQL instance for reads.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#080;font-style:italic># For writes, you must instead connect to the master: mysql-0.mysql.</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-read<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>ヘッドレスサービスは、StatefulSetコントローラーが
StatefulSetの一部であるPodごとに作成するDNSエントリーのベースエントリーを提供します。
この例ではヘッドレスサービスの名前は<code>mysql</code>なので、同じKubernetesクラスタの
同じ名前空間内の他のPodは、<code>&lt;pod-name>.mysql</code>を名前解決することでPodにアクセスできます。</p>
<p><code>mysql-read</code>と呼ばれるクライアントサービスは、独自のクラスタIPを持つ通常のServiceであり、
Ready状態のすべてのMySQL Podに接続を分散します。
Serviceのエンドポイントには、MySQLマスターとすべてのスレーブが含まれる可能性があります。</p>
<p>読み込みクエリーのみが、負荷分散されるクライアントサービスを使用できることに注意してください。
MySQLマスターは1つしかいないため、クライアントが書き込みを実行するためには、
(ヘッドレスサービス内のDNSエントリーを介して)MySQLのマスターPodに直接接続する必要があります。</p>
<h3 id=statefulset>StatefulSet</h3>
<p>最後に、次のYAML設定ファイルからStatefulSetを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-statefulset.yaml
</code></pre></div>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/mysql/mysql-statefulset.yaml download=application/mysql/mysql-statefulset.yaml><code>application/mysql/mysql-statefulset.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-mysql-mysql-statefulset-yaml')" title="Copy application/mysql/mysql-statefulset.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-mysql-mysql-statefulset-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql:5.7<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- bash<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          set -ex
</span><span style=color:#b44;font-style:italic>          # Generate mysql server-id from pod ordinal index.
</span><span style=color:#b44;font-style:italic>          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1
</span><span style=color:#b44;font-style:italic>          ordinal=${BASH_REMATCH[1]}
</span><span style=color:#b44;font-style:italic>          echo [mysqld] &gt; /mnt/conf.d/server-id.cnf
</span><span style=color:#b44;font-style:italic>          # Add an offset to avoid reserved server-id=0 value.
</span><span style=color:#b44;font-style:italic>          echo server-id=$((100 + $ordinal)) &gt;&gt; /mnt/conf.d/server-id.cnf
</span><span style=color:#b44;font-style:italic>          # Copy appropriate conf.d files from config-map to emptyDir.
</span><span style=color:#b44;font-style:italic>          if [[ $ordinal -eq 0 ]]; then
</span><span style=color:#b44;font-style:italic>            cp /mnt/config-map/master.cnf /mnt/conf.d/
</span><span style=color:#b44;font-style:italic>          else
</span><span style=color:#b44;font-style:italic>            cp /mnt/config-map/slave.cnf /mnt/conf.d/
</span><span style=color:#b44;font-style:italic>          fi</span><span style=color:#bbb>          
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt/conf.d<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-map<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt/config-map<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>clone-mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/xtrabackup:1.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- bash<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          set -ex
</span><span style=color:#b44;font-style:italic>          # Skip the clone if data already exists.
</span><span style=color:#b44;font-style:italic>          [[ -d /var/lib/mysql/mysql ]] &amp;&amp; exit 0
</span><span style=color:#b44;font-style:italic>          # Skip the clone on master (ordinal index 0).
</span><span style=color:#b44;font-style:italic>          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1
</span><span style=color:#b44;font-style:italic>          ordinal=${BASH_REMATCH[1]}
</span><span style=color:#b44;font-style:italic>          [[ $ordinal -eq 0 ]] &amp;&amp; exit 0
</span><span style=color:#b44;font-style:italic>          # Clone data from previous peer.
</span><span style=color:#b44;font-style:italic>          ncat --recv-only mysql-$(($ordinal-1)).mysql 3307 | xbstream -x -C /var/lib/mysql
</span><span style=color:#b44;font-style:italic>          # Prepare the backup.
</span><span style=color:#b44;font-style:italic>          xtrabackup --prepare --target-dir=/var/lib/mysql</span><span style=color:#bbb>          
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/mysql/conf.d<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql:5.7<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ALLOW_EMPTY_PASSWORD<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/mysql/conf.d<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;mysqladmin&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;ping&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:#080;font-style:italic># Check we can execute queries over TCP (skip-networking is off).</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;mysql&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-h&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;127.0.0.1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-e&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;SELECT 1&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>xtrabackup<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/xtrabackup:1.0<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>xtrabackup<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>3307</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- bash<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          set -ex
</span><span style=color:#b44;font-style:italic>          cd /var/lib/mysql
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          # Determine binlog position of cloned data, if any.
</span><span style=color:#b44;font-style:italic>          if [[ -f xtrabackup_slave_info &amp;&amp; &#34;x$(&lt;xtrabackup_slave_info)&#34; != &#34;x&#34; ]]; then
</span><span style=color:#b44;font-style:italic>            # XtraBackup already generated a partial &#34;CHANGE MASTER TO&#34; query
</span><span style=color:#b44;font-style:italic>            # because we&#39;re cloning from an existing slave. (Need to remove the tailing semicolon!)
</span><span style=color:#b44;font-style:italic>            cat xtrabackup_slave_info | sed -E &#39;s/;$//g&#39; &gt; change_master_to.sql.in
</span><span style=color:#b44;font-style:italic>            # Ignore xtrabackup_binlog_info in this case (it&#39;s useless).
</span><span style=color:#b44;font-style:italic>            rm -f xtrabackup_slave_info xtrabackup_binlog_info
</span><span style=color:#b44;font-style:italic>          elif [[ -f xtrabackup_binlog_info ]]; then
</span><span style=color:#b44;font-style:italic>            # We&#39;re cloning directly from master. Parse binlog position.
</span><span style=color:#b44;font-style:italic>            [[ `cat xtrabackup_binlog_info` =~ ^(.*?)[[:space:]]+(.*?)$ ]] || exit 1
</span><span style=color:#b44;font-style:italic>            rm -f xtrabackup_binlog_info xtrabackup_slave_info
</span><span style=color:#b44;font-style:italic>            echo &#34;CHANGE MASTER TO MASTER_LOG_FILE=&#39;${BASH_REMATCH[1]}&#39;,\
</span><span style=color:#b44;font-style:italic>                  MASTER_LOG_POS=${BASH_REMATCH[2]}&#34; &gt; change_master_to.sql.in
</span><span style=color:#b44;font-style:italic>          fi
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          # Check if we need to complete a clone by starting replication.
</span><span style=color:#b44;font-style:italic>          if [[ -f change_master_to.sql.in ]]; then
</span><span style=color:#b44;font-style:italic>            echo &#34;Waiting for mysqld to be ready (accepting connections)&#34;
</span><span style=color:#b44;font-style:italic>            until mysql -h 127.0.0.1 -e &#34;SELECT 1&#34;; do sleep 1; done
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>            echo &#34;Initializing replication from clone position&#34;
</span><span style=color:#b44;font-style:italic>            mysql -h 127.0.0.1 \
</span><span style=color:#b44;font-style:italic>                  -e &#34;$(&lt;change_master_to.sql.in), \
</span><span style=color:#b44;font-style:italic>                          MASTER_HOST=&#39;mysql-0.mysql&#39;, \
</span><span style=color:#b44;font-style:italic>                          MASTER_USER=&#39;root&#39;, \
</span><span style=color:#b44;font-style:italic>                          MASTER_PASSWORD=&#39;&#39;, \
</span><span style=color:#b44;font-style:italic>                          MASTER_CONNECT_RETRY=10; \
</span><span style=color:#b44;font-style:italic>                        START SLAVE;&#34; || exit 1
</span><span style=color:#b44;font-style:italic>            # In case of container restart, attempt this at-most-once.
</span><span style=color:#b44;font-style:italic>            mv change_master_to.sql.in change_master_to.sql.orig
</span><span style=color:#b44;font-style:italic>          fi
</span><span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          # Start a server to send backups when requested by peers.
</span><span style=color:#b44;font-style:italic>          exec ncat --listen --keep-open --send-only --max-conns=1 3307 -c \
</span><span style=color:#b44;font-style:italic>            &#34;xtrabackup --backup --slave-info --stream=xbstream --host=127.0.0.1 --user=root&#34;</span><span style=color:#bbb>          
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/mysql/conf.d<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-map<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;ReadWriteOnce&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>次のコマンドを実行して起動の進行状況を確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql --watch
</code></pre></div><p>しばらくすると、3つのPodすべてがRunning状態になるはずです。</p>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
mysql-0   2/2       Running   0          2m
mysql-1   2/2       Running   0          1m
mysql-2   2/2       Running   0          1m
</code></pre><p><strong>Ctrl+C</strong>を押してウォッチをキャンセルします。
起動が進行しない場合は、<a href=#%E5%A7%8B%E3%82%81%E3%82%8B%E5%89%8D%E3%81%AB>始める前に</a>で説明されているように、
PersistentVolumeの動的プロビジョニング機能が有効になっていることを確認してください。</p>
<p>このマニフェストでは、StatefulSetの一部としてステートフルなPodを管理するためにさまざまな手法を使用しています。
次のセクションでは、これらの手法のいくつかに焦点を当て、StatefulSetがPodを作成するときに何が起こるかを説明します。</p>
<h2 id=ステートフルなpodの初期化を理解する>ステートフルなPodの初期化を理解する</h2>
<p>StatefulSetコントローラーは、序数インデックスの順にPodを一度に1つずつ起動します。
各PodがReady状態を報告するまで待機してから、その次のPodの起動が開始されます。</p>
<p>さらに、コントローラーは各Podに <code>&lt;statefulset-name>-&lt;ordinal-index></code>という形式の一意で不変の名前を割り当てます。
この例の場合、Podの名前は<code>mysql-0</code>、<code>mysql-1</code>、そして<code>mysql-2</code>となります。</p>
<p>上記のStatefulSetマニフェスト内のPodテンプレートは、これらのプロパティーを利用して、
MySQLレプリケーションの起動を順序正しく実行します。</p>
<h3 id=構成を生成する>構成を生成する</h3>
<p>Podスペック内のコンテナを起動する前に、Podは最初に
<a href=/ja/docs/concepts/workloads/pods/init-containers/>初期化コンテナ</a>を定義された順序で実行します。</p>
<p>最初の初期化コンテナは<code>init-mysql</code>という名前で、序数インデックスに基づいて特別なMySQL設定ファイルを生成します。</p>
<p>スクリプトは、<code>hostname</code>コマンドによって返されるPod名の末尾から抽出することによって、自身の序数インデックスを特定します。
それから、序数を(予約された値を避けるために数値オフセット付きで)MySQLの<code>conf.d</code>ディレクトリーの<code>server-id.cnf</code>というファイルに保存します。
これは、StatefulSetコントローラーによって提供される一意で不変のIDを、同じ特性を必要とするMySQLサーバーIDの領域に変換します。</p>
<p>さらに、<code>init-mysql</code>コンテナ内のスクリプトは、<code>master.cnf</code>または<code>slave.cnf</code>のいずれかを、
ConfigMapから内容を<code>conf.d</code>にコピーすることによって適用します。
このトポロジー例は単一のMySQLマスターと任意の数のスレーブで構成されているため、
スクリプトは単に序数の<code>0</code>がマスターになるように、それ以外のすべてがスレーブになるように割り当てます。
StatefulSetコントローラーによる
<a href=/ja/docs/concepts/workloads/controllers/statefulset/#%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E3%81%A8%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AE%E4%BF%9D%E8%A8%BC>デプロイ順序の保証</a>と組み合わせると、
スレーブが作成される前にMySQLマスターがReady状態になるため、スレーブはレプリケーションを開始できます。</p>
<h3 id=既存データをクローンする>既存データをクローンする</h3>
<p>一般に、新しいPodがセットにスレーブとして参加するときは、
MySQLマスターにはすでにデータがあるかもしれないと想定する必要があります。
また、レプリケーションログが期間の先頭まで全て揃っていない場合も想定する必要があります。
これらの控えめな仮定は、実行中のStatefulSetのサイズを初期サイズに固定するのではなく、
時間の経過とともにスケールアップまたはスケールダウンできるようにするために重要です。</p>
<p>2番目の初期化コンテナは<code>clone-mysql</code>という名前で、スレーブPodが空のPersistentVolumeで最初に起動したときに、
クローン操作を実行します。
つまり、実行中の別のPodから既存のデータをすべてコピーするので、
そのローカル状態はマスターからレプリケーションを開始するのに十分な一貫性があります。</p>
<p>MySQL自体はこれを行うためのメカニズムを提供していないため、この例ではPercona XtraBackupという人気のあるオープンソースツールを使用しています。
クローンの実行中は、ソースとなるMySQLサーバーのパフォーマンスが低下する可能性があります。
MySQLマスターへの影響を最小限に抑えるために、スクリプトは各Podに序数インデックスが自分より1低いPodからクローンするように指示します。
StatefulSetコントローラーは、<code>N+1</code>のPodを開始する前には必ず<code>N</code>のPodがReady状態であることを保証するので、この方法が機能します。</p>
<h3 id=レプリケーションを開始する>レプリケーションを開始する</h3>
<p>初期化コンテナが正常に完了すると、通常のコンテナが実行されます。
MySQLのPodは実際に<code>mysqld</code>サーバーを実行する<code>mysql</code>コンテナと、
<a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>サイドカー</a>
として機能する<code>xtrabackup</code>コンテナから成ります。</p>
<p><code>xtrabackup</code>サイドカーはクローンされたデータファイルを見て、
スレーブ上でMySQLレプリケーションを初期化する必要があるかどうかを決定します。
もし必要がある場合、<code>mysqld</code>が準備できるのを待ってから、
XtraBackupクローンファイルから抽出されたレプリケーションパラメーターで<code>CHANGE MASTER TO</code>と<code>START SLAVE</code>コマンドを実行します。</p>
<p>スレーブがレプリケーションを開始すると、スレーブはMySQLマスターを記憶し、
サーバーが再起動した場合または接続が停止した場合に、自動的に再接続します。
また、スレーブはその不変のDNS名(<code>mysql-0.mysql</code>)でマスターを探すため、
再スケジュールされたために新しいPod IPを取得したとしても、自動的にマスターを見つけます。</p>
<p>最後に、レプリケーションを開始した後、<code>xtrabackup</code>コンテナはデータのクローンを要求する他のPodからの接続を待ち受けます。
StatefulSetがスケールアップした場合や、次のPodがPersistentVolumeClaimを失ってクローンをやり直す必要がある場合に備えて、
このサーバーは無期限に起動したままになります。</p>
<h2 id=クライアントトラフィックを送信する>クライアントトラフィックを送信する</h2>
<p>テストクエリーをMySQLマスター(ホスト名 <code>mysql-0.mysql</code>)に送信するには、
<code>mysql:5.7</code>イメージを使って一時的なコンテナーを実行し、<code>mysql</code>クライアントバイナリーを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run mysql-client --image<span style=color:#666>=</span>mysql:5.7 -i --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  mysql -h mysql-0.mysql <span style=color:#b44>&lt;&lt;EOF
</span><span style=color:#b44>CREATE DATABASE test;
</span><span style=color:#b44>CREATE TABLE test.messages (message VARCHAR(250));
</span><span style=color:#b44>INSERT INTO test.messages VALUES (&#39;hello&#39;);
</span><span style=color:#b44>EOF</span>
</code></pre></div><p>Ready状態を報告したいずれかのサーバーにテストクエリーを送信するには、ホスト名<code>mysql-read</code>を使用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run mysql-client --image<span style=color:#666>=</span>mysql:5.7 -i -t --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  mysql -h mysql-read -e <span style=color:#b44>&#34;SELECT * FROM test.messages&#34;</span>
</code></pre></div><p>次のような出力が得られるはずです。</p>
<pre><code>Waiting for pod default/mysql-client to be running, status is Pending, pod ready: false
+---------+
| message |
+---------+
| hello   |
+---------+
pod &quot;mysql-client&quot; deleted
</code></pre><p><code>mysql-read</code>サービスがサーバー間で接続を分散させることを実証するために、
ループで<code>SELECT @@server_id</code>を実行することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run mysql-client-loop --image<span style=color:#666>=</span>mysql:5.7 -i -t --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  bash -ic <span style=color:#b44>&#34;while sleep 1; do mysql -h mysql-read -e &#39;SELECT @@server_id,NOW()&#39;; done&#34;</span>
</code></pre></div><p>接続の試行ごとに異なるエンドポイントが選択される可能性があるため、
報告される<code>@@server_id</code>はランダムに変更されるはずです。</p>
<pre><code>+-------------+---------------------+
| @@server_id | NOW()               |
+-------------+---------------------+
|         100 | 2006-01-02 15:04:05 |
+-------------+---------------------+
+-------------+---------------------+
| @@server_id | NOW()               |
+-------------+---------------------+
|         102 | 2006-01-02 15:04:06 |
+-------------+---------------------+
+-------------+---------------------+
| @@server_id | NOW()               |
+-------------+---------------------+
|         101 | 2006-01-02 15:04:07 |
+-------------+---------------------+
</code></pre><p>ループを止めたいときは<strong>Ctrl+C</strong>を押すことができますが、別のウィンドウで実行したままにしておくことで、
次の手順の効果を確認できます。</p>
<h2 id=podとnodeのダウンタイムをシミュレーションする>PodとNodeのダウンタイムをシミュレーションする</h2>
<p>単一のサーバーではなくスレーブのプールから読み取りを行うことによって可用性が高まっていることを実証するため、
Podを強制的にReadyではない状態にする間、上記の<code>SELECT @@server_id</code>ループを実行したままにしてください。</p>
<h3 id=readiness-probeを壊す>Readiness Probeを壊す</h3>
<p><code>mysql</code>コンテナに対する
<a href=/ja/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-readiness-probes>readiness probe</a>
は、<code>mysql -h 127.0.0.1 -e 'SELECT 1'</code>コマンドを実行することで、サーバーが起動していてクエリーが実行できることを確認します。</p>
<p>このreadiness probeを失敗させる1つの方法は、そのコマンドを壊すことです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> mysql-2 -c mysql -- mv /usr/bin/mysql /usr/bin/mysql.off
</code></pre></div><p>ここでは、<code>mysql-2</code> Podの実際のコンテナのファイルシステムにアクセスし、
<code>mysql</code>コマンドの名前を変更してreadiness probeがコマンドを見つけられないようにしています。
数秒後、Podはそのコンテナの1つがReadyではないと報告するはずです。以下を実行して確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod mysql-2
</code></pre></div><p><code>READY</code>列の<code>1/2</code>を見てください。</p>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE
mysql-2   1/2       Running   0          3m
</code></pre><p>この時点で、<code>SELECT @@server_id</code>ループは実行され続け、しかしもう<code>102</code>が報告されないことが確認できるはずです。
<code>init-mysql</code>スクリプトが<code>server-id</code>を<code>100+$ordinal</code>として定義したことを思い出して下さい。
そのため、サーバーID<code>102</code>はPodの<code>mysql-2</code>に対応します。</p>
<p>それではPodを修復しましょう。すると数秒後にループ出力に再び現れるはずです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> mysql-2 -c mysql -- mv /usr/bin/mysql.off /usr/bin/mysql
</code></pre></div><h3 id=podを削除する>Podを削除する</h3>
<p>StatefulSetは、Podが削除された場合にPodを再作成します。
これはReplicaSetがステートレスなPodに対して行うのと同様です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod mysql-2
</code></pre></div><p>StatefulSetコントローラーは<code>mysql-2</code> Podがもう存在しないことに気付き、
同じ名前で同じPersistentVolumeClaimにリンクされた新しいPodを作成します。
サーバーID<code>102</code>がしばらくの間ループ出力から消えて、また元に戻るのが確認できるはずです。</p>
<h3 id=ノードをdrainする>ノードをdrainする</h3>
<p>Kubernetesクラスタに複数のノードがある場合は、
<a href=/docs/reference/generated/kubectl/kubectl-commands/#drain>drain</a>を発行して
ノードのダウンタイム(例えばノードのアップグレード時など)をシミュレートできます。</p>
<p>まず、あるMySQL Podがどのノード上にいるかを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod mysql-2 -o wide
</code></pre></div><p>ノード名が最後の列に表示されるはずです。</p>
<pre><code>NAME      READY     STATUS    RESTARTS   AGE       IP            NODE
mysql-2   2/2       Running   0          15m       10.244.5.27   kubernetes-minion-group-9l2t
</code></pre><p>その後、次のコマンドを実行してノードをdrainします。
これにより、新しいPodがそのノードにスケジュールされないようにcordonされ、そして既存のPodは強制退去されます。
<code>&lt;node-name></code>は前のステップで確認したノードの名前に置き換えてください。</p>
<p>この操作はノード上の他のアプリケーションに影響を与える可能性があるため、
<strong>テストクラスタでのみこの操作を実行</strong>するのが最善です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl drain &lt;node-name&gt; --force --delete-local-data --ignore-daemonsets
</code></pre></div><p>Podが別のノードに再スケジュールされる様子を確認しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod mysql-2 -o wide --watch
</code></pre></div><p>次のような出力が見られるはずです。</p>
<pre><code>NAME      READY   STATUS          RESTARTS   AGE       IP            NODE
mysql-2   2/2     Terminating     0          15m       10.244.1.56   kubernetes-minion-group-9l2t
[...]
mysql-2   0/2     Pending         0          0s        &lt;none&gt;        kubernetes-minion-group-fjlm
mysql-2   0/2     Init:0/2        0          0s        &lt;none&gt;        kubernetes-minion-group-fjlm
mysql-2   0/2     Init:1/2        0          20s       10.244.5.32   kubernetes-minion-group-fjlm
mysql-2   0/2     PodInitializing 0          21s       10.244.5.32   kubernetes-minion-group-fjlm
mysql-2   1/2     Running         0          22s       10.244.5.32   kubernetes-minion-group-fjlm
mysql-2   2/2     Running         0          30s       10.244.5.32   kubernetes-minion-group-fjlm
</code></pre><p>また、サーバーID<code>102</code>が<code>SELECT @@server_id</code>ループの出力からしばらくの消えて、
そして戻ることが確認できるはずです。</p>
<p>それでは、ノードをuncordonして正常な状態に戻しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl uncordon &lt;node-name&gt;
</code></pre></div><h2 id=スレーブの数をスケーリングする>スレーブの数をスケーリングする</h2>
<p>MySQLレプリケーションでは、スレーブを追加することで読み取りクエリーのキャパシティーをスケールできます。
StatefulSetを使用している場合、単一のコマンドでこれを実行できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale statefulset mysql  --replicas<span style=color:#666>=</span><span style=color:#666>5</span>
</code></pre></div><p>次のコマンドを実行して、新しいPodが起動してくるのを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql --watch
</code></pre></div><p>新しいPodが起動すると、サーバーID<code>103</code>と<code>104</code>が<code>SELECT @@server_id</code>ループの出力に現れます。</p>
<p>また、これらの新しいサーバーが、これらのサーバーが存在する前に追加したデータを持っていることを確認することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run mysql-client --image<span style=color:#666>=</span>mysql:5.7 -i -t --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>  mysql -h mysql-3.mysql -e <span style=color:#b44>&#34;SELECT * FROM test.messages&#34;</span>
</code></pre></div><pre><code>Waiting for pod default/mysql-client to be running, status is Pending, pod ready: false
+---------+
| message |
+---------+
| hello   |
+---------+
pod &quot;mysql-client&quot; deleted
</code></pre><p>元の状態へのスケールダウンもシームレスに可能です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale statefulset mysql --replicas<span style=color:#666>=</span><span style=color:#666>3</span>
</code></pre></div><p>ただし、スケールアップすると新しいPersistentVolumeClaimが自動的に作成されますが、
スケールダウンしてもこれらのPVCは自動的には削除されないことに注意して下さい。
このため、初期化されたPVCをそのまま置いておいくことで再スケールアップを速くしたり、
PVを削除する前にデータを抽出するといった選択が可能になります。</p>
<p>次のコマンドを実行してこのことを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql
</code></pre></div><p>StatefulSetを3にスケールダウンしたにもかかわらず、5つのPVCすべてがまだ存在しています。</p>
<pre><code>NAME           STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
data-mysql-0   Bound     pvc-8acbf5dc-b103-11e6-93fa-42010a800002   10Gi       RWO           20m
data-mysql-1   Bound     pvc-8ad39820-b103-11e6-93fa-42010a800002   10Gi       RWO           20m
data-mysql-2   Bound     pvc-8ad69a6d-b103-11e6-93fa-42010a800002   10Gi       RWO           20m
data-mysql-3   Bound     pvc-50043c45-b1c5-11e6-93fa-42010a800002   10Gi       RWO           2m
data-mysql-4   Bound     pvc-500a9957-b1c5-11e6-93fa-42010a800002   10Gi       RWO           2m
</code></pre><p>余分なPVCを再利用するつもりがないのであれば、削除することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pvc data-mysql-3
kubectl delete pvc data-mysql-4
</code></pre></div><h2 id=クリーンアップ>クリーンアップ</h2>
<ol>
<li>
<p><code>SELECT @@server_id</code>ループを実行している端末で<strong>Ctrl+C</strong>を押すか、
別の端末から次のコマンドを実行して、ループをキャンセルします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pod mysql-client-loop --now
</code></pre></div></li>
<li>
<p>StatefulSetを削除します。これによってPodの終了も開始されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete statefulset mysql
</code></pre></div></li>
<li>
<p>Podが消えたことを確認します。
Podが終了処理が完了するのには少し時間がかかるかもしれません。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql
</code></pre></div><p>上記のコマンドから以下の出力が戻れば、Podが終了したことがわかります。</p>
<pre><code>No resources found.
</code></pre></li>
<li>
<p>ConfigMap、Services、およびPersistentVolumeClaimを削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete configmap,service,pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql
</code></pre></div></li>
<li>
<p>PersistentVolumeを手動でプロビジョニングした場合は、それらを手動で削除し、
また、下層にあるリソースも解放する必要があります。
動的プロビジョニング機能を使用した場合は、PersistentVolumeClaimを削除すれば、自動的にPersistentVolumeも削除されます。
一部の動的プロビジョナー(EBSやPDなど)は、PersistentVolumeを削除すると同時に下層にあるリソースも解放します。</p>
</li>
</ol>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>その他のステートフルアプリケーションの例は、<a href=https://github.com/kubernetes/charts>Helm Charts repository</a>を見てください。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7a9b5779e228083ba3fdeaf414fe704e>7.4 - StatefulSetのスケール</h1>
<p>このタスクは、StatefulSetをスケールする方法を示します。StatefulSetをスケーリングするとは、レプリカの数を増減することです。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>
<p>StatefulSetはKubernetesバージョン1.5以降でのみ利用可能です。
Kubernetesのバージョンを確認するには、<code>kubectl version</code>を実行してください。</p>
</li>
<li>
<p>すべてのステートフルアプリケーションがうまくスケールできるわけではありません。StatefulSetがスケールするかどうかわからない場合は、<a href=/ja/docs/concepts/workloads/controllers/statefulset/>StatefulSetの概念</a>または<a href=/ja/docs/tutorials/stateful-application/basic-stateful-set/>StatefulSetのチュートリアル</a>を参照してください。</p>
</li>
<li>
<p>ステートフルアプリケーションクラスターが完全に健全であると確信できる場合にのみ、スケーリングを実行してください。</p>
</li>
</ul>
<h2 id=statefulsetのスケール>StatefulSetのスケール</h2>
<h3 id=kubectlを使用したstatefulsetのスケール>kubectlを使用したStatefulSetのスケール</h3>
<p>まず、スケールしたいStatefulSetを見つけます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get statefulsets &lt;stateful-set-name&gt;
</code></pre></div><p>StatefulSetのレプリカ数を変更します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale statefulsets &lt;stateful-set-name&gt; --replicas<span style=color:#666>=</span>&lt;new-replicas&gt;
</code></pre></div><h3 id=statefulsetのインプレースアップデート>StatefulSetのインプレースアップデート</h3>
<p>コマンドライン上でレプリカ数を変更する代わりに、StatefulSetに<a href=/ja/docs/concepts/cluster-administration/manage-deployment/#in-place-updates-of-resources>インプレースアップデート</a>が可能です。</p>
<p>StatefulSetが最初に <code>kubectl apply</code>で作成されたのなら、StatefulSetマニフェストの<code>.spec.replicas</code>を更新してから、<code>kubectl apply</code>を実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f &lt;stateful-set-file-updated&gt;
</code></pre></div><p>そうでなければ、<code>kubectl edit</code>でそのフィールドを編集してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl edit statefulsets &lt;stateful-set-name&gt;
</code></pre></div><p>あるいは<code>kubectl patch</code>を使ってください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch statefulsets &lt;stateful-set-name&gt; -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;replicas&#34;:&lt;new-replicas&gt;}}&#39;</span>
</code></pre></div><h2 id=トラブルシューティング>トラブルシューティング</h2>
<h3 id=スケールダウンがうまくいかない>スケールダウンがうまくいかない</h3>
<p>管理するステートフルPodのいずれかが異常である場合、StatefulSetをスケールダウンすることはできません。それらのステートフルPodが実行され準備ができた後にのみ、スケールダウンが行われます。</p>
<p>spec.replicas > 1の場合、Kubernetesは不健康なPodの理由を判断できません。それは、永続的な障害または一時的な障害の結果である可能性があります。一時的な障害は、アップグレードまたはメンテナンスに必要な再起動によって発生する可能性があります。</p>
<p>永続的な障害が原因でPodが正常でない場合、障害を修正せずにスケーリングすると、StatefulSetメンバーシップが正しく機能するために必要な特定の最小レプリカ数を下回る状態になる可能性があります。これにより、StatefulSetが利用できなくなる可能性があります。</p>
<p>一時的な障害によってPodが正常でなくなり、Podが再び使用可能になる可能性がある場合は、一時的なエラーがスケールアップまたはスケールダウン操作の妨げになる可能性があります。一部の分散データベースでは、ノードが同時に参加および脱退するときに問題があります。このような場合は、アプリケーションレベルでスケーリング操作を考えることをお勧めします。また、ステートフルアプリケーションクラスタが完全に健全であることが確実な場合にのみスケーリングを実行してください。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/tasks/run-application/delete-stateful-set/>StatefulSetの削除</a>の詳細</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-c43537b0ee1da992ecb7488f87e6c934>7.5 - StatefulSetの削除</h1>
<p>このタスクでは、StatefulSetを削除する方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>このタスクは、クラスター上で、StatefulSetで表現されるアプリケーションが実行されていることを前提としています。</li>
</ul>
<h2 id=statefulsetの削除>StatefulSetの削除</h2>
<p>Kubernetesで他のリソースを削除するのと同じ方法でStatefulSetを削除することができます。つまり、<code>kubectl delete</code>コマンドを使い、StatefulSetをファイルまたは名前で指定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete -f &lt;file.yaml&gt;
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete statefulsets &lt;statefulset-name&gt;
</code></pre></div><p>StatefulSet自体が削除された後で、関連するヘッドレスサービスを個別に削除する必要があるかもしれません。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete service &lt;service-name&gt;
</code></pre></div><p>kubectlを使ってStatefulSetを削除すると0にスケールダウンされ、すべてのPodが削除されます。PodではなくStatefulSetだけを削除したい場合は、<code>--cascade=orphan</code>を使用してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete -f &lt;file.yaml&gt; --cascade<span style=color:#666>=</span>orphan
</code></pre></div><p><code>--cascade=orphan</code>を<code>kubectl delete</code>に渡すことで、StatefulSetオブジェクト自身が削除された後でも、StatefulSetによって管理されていたPodは残ります。Podに<code>app=myapp</code>というラベルが付いている場合は、次のようにして削除できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp
</code></pre></div><h3 id=永続ボリューム>永続ボリューム</h3>
<p>StatefulSet内のPodを削除しても、関連付けられているボリュームは削除されません。これは、削除する前にボリュームからデータをコピーする機会があることを保証するためです。Podが終了した後にPVCを削除すると、ストレージクラスと再利用ポリシーによっては、背後にある永続ボリュームの削除がトリガーされることがあります。決してクレーム削除後にボリュームにアクセスできると想定しないでください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> データを損失する可能性があるため、PVCを削除するときは注意してください。
</div>
<h3 id=statefulsetの完全削除>StatefulSetの完全削除</h3>
<p>関連付けられたPodを含むStatefulSet内のすべてのものを単純に削除するには、次のような一連のコマンドを実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>grace</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods &lt;stateful-set-pod&gt; --template <span style=color:#b44>&#39;{{.spec.terminationGracePeriodSeconds}}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
kubectl delete statefulset -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp
sleep <span style=color:#b8860b>$grace</span>
kubectl delete pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp

</code></pre></div><p>上の例では、Podは<code>app=myapp</code>というラベルを持っています。必要に応じてご利用のラベルに置き換えてください。</p>
<h3 id=statefulset-podの強制削除>StatefulSet Podの強制削除</h3>
<p>StatefulSet内の一部のPodが長期間<code>Terminating</code>または<code>Unknown</code>状態のままになっていることが判明した場合は、手動でapiserverからPodを強制的に削除する必要があります。これは潜在的に危険な作業です。詳細は<a href=/ja/docs/tasks/run-application/force-delete-stateful-set-pod/>StatefulSet Podの強制削除</a>を参照してください。</p>
<h2 id=次の項目>次の項目</h2>
<p><a href=/ja/docs/tasks/run-application/force-delete-stateful-set-pod/>StatefulSet Podの強制削除</a>の詳細</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f5f2f7a74377a9d45325c5253353fa8f>7.6 - StatefulSet Podの強制削除</h1>
<p>このページでは、StatefulSetの一部であるPodを削除する方法と、削除する際に考慮すべき事項について説明します。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>これはかなり高度なタスクであり、StatefulSetに固有のいくつかの特性に反する可能性があります。</li>
<li>先に進む前に、以下に列挙されている考慮事項をよく理解してください。</li>
</ul>
<h2 id=statefulsetに関する考慮事項>StatefulSetに関する考慮事項</h2>
<p>StatefulSetの通常の操作では、StatefulSet Podを強制的に削除する必要は<strong>まったく</strong>ありません。StatefulSetコントローラーは、StatefulSetのメンバーの作成、スケール、削除を行います。それは序数0からN-1までの指定された数のPodが生きていて準備ができていることを保証しようとします。StatefulSetは、クラスター内で実行されている特定のIDを持つ最大1つのPodがいつでも存在することを保証します。これは、StatefulSetによって提供される<em>最大1つの</em>セマンティクスと呼ばれます。</p>
<p>手動による強制削除は、StatefulSetに固有の最大1つのセマンティクスに違反する可能性があるため、慎重に行う必要があります。StatefulSetを使用して、安定したネットワークIDと安定した記憶域を必要とする分散型およびクラスター型アプリケーションを実行できます。これらのアプリケーションは、固定IDを持つ固定数のメンバーのアンサンブルに依存する構成を持つことがよくあります。同じIDを持つ複数のメンバーを持つことは悲惨なことになり、データの損失につながる可能性があります(例：定足数ベースのシステムでのスプリットブレインシナリオ)。</p>
<h2 id=podの削除>Podの削除</h2>
<p>次のコマンドで正常なPod削除を実行できます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pods &lt;pod&gt;
</code></pre></div><p>上記がグレースフルターミネーションにつながるためには、<code>pod.Spec.TerminationGracePeriodSeconds</code>に0を指定しては<strong>いけません</strong>。<code>pod.Spec.TerminationGracePeriodSeconds</code>を0秒に設定することは安全ではなく、StatefulSet Podには強くお勧めできません。グレースフル削除は安全で、kubeletがapiserverから名前を削除する前にPodが<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/#termination-of-pods>適切にシャットダウンする</a>ことを保証します。</p>
<p>Kubernetes(バージョン1.5以降)は、Nodeにアクセスできないという理由だけでPodを削除しません。到達不能なNodeで実行されているPodは、<a href=/ja/docs/concepts/architecture/nodes/#condition>タイムアウト</a>の後に<code>Terminating</code>または<code>Unknown</code>状態になります。到達不能なNode上のPodをユーザーが適切に削除しようとすると、Podはこれらの状態に入ることもあります。そのような状態のPodをapiserverから削除することができる唯一の方法は以下の通りです:</p>
<ul>
<li>(ユーザーまたは<a href=/ja/docs/concepts/architecture/nodes/>Node Controller</a>によって)Nodeオブジェクトが削除されます。</li>
<li>応答していないNodeのkubeletが応答を開始し、Podを終了してapiserverからエントリーを削除します。</li>
<li>ユーザーによりPodを強制削除します。</li>
</ul>
<p>推奨されるベストプラクティスは、1番目または2番目のアプローチを使用することです。Nodeが死んでいることが確認された(例えば、ネットワークから恒久的に切断された、電源が切られたなど)場合、Nodeオブジェクトを削除します。Nodeがネットワークパーティションに苦しんでいる場合は、これを解決するか、解決するのを待ちます。パーティションが回復すると、kubeletはPodの削除を完了し、apiserverでその名前を解放します。</p>
<p>通常、PodがNode上で実行されなくなるか、管理者によってそのNodeが削除されると、システムは削除を完了します。あなたはPodを強制的に削除することでこれを無効にすることができます。</p>
<h3 id=強制削除>強制削除</h3>
<p>強制削除はPodが終了したことをkubeletから確認するまで<strong>待ちません</strong>。強制削除がPodの削除に成功したかどうかに関係なく、apiserverから名前をすぐに解放します。これにより、StatefulSetコントローラーは、同じIDを持つ交換Podを作成できます。これは、まだ実行中のPodの複製につながる可能性があり、そのPodがまだStatefulSetの他のメンバーと通信できる場合、StatefulSetが保証するように設計されている最大1つのセマンティクスに違反します。</p>
<p>StatefulSetのPodを強制的に削除するということは、問題のPodがStatefulSet内の他のPodと再び接触することはなく、代わりのPodを作成するために名前が安全に解放されることを意味します。</p>
<p>バージョン1.5以上のkubectlを使用してPodを強制的に削除する場合は、次の手順を実行します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pods &lt;pod&gt; --grace-period<span style=color:#666>=</span><span style=color:#666>0</span> --force
</code></pre></div><p>バージョン1.4以下のkubectlを使用している場合、<code>--force</code>オプションを省略する必要があります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete pods &lt;pod&gt; --grace-period<span style=color:#666>=</span><span style=color:#666>0</span>
</code></pre></div><p>これらのコマンドを実行した後でもPodが<code>Unknown</code>状態のままになっている場合は、次のコマンドを使用してPodをクラスターから削除します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl patch pod &lt;pod&gt; -p <span style=color:#b44>&#39;{&#34;metadata&#34;:{&#34;finalizers&#34;:null}}&#39;</span>
</code></pre></div><p>StatefulSet Podの強制削除は、常に慎重に、関連するリスクを完全に把握して実行してください。</p>
<h2 id=次の項目>次の項目</h2>
<p><a href=/docs/tasks/debug-application-cluster/debug-stateful-set/>StatefulSetのデバッグ</a>の詳細</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-8138226ce9660ac8e3e82ff86fff8ad2>7.7 - Horizontal Pod Autoscalerウォークスルー</h1>
<p>Horizontal Pod Autoscalerは、Deployment、ReplicaSetまたはStatefulSetといったレプリケーションコントローラ内のPodの数を、観測されたCPU使用率（もしくはベータサポートの、アプリケーションによって提供されるその他のメトリクス）に基づいて自動的にスケールさせます。</p>
<p>このドキュメントはphp-apacheサーバーに対しHorizontal Pod Autoscalerを有効化するという例に沿ってウォークスルーで説明していきます。Horizontal Pod Autoscalerの動作についてのより詳細な情報を知りたい場合は、<a href=/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscalerユーザーガイド</a>をご覧ください。</p>
<h2 id=始める前に>始める前に</h2>
<p>この例ではバージョン1.2以上の動作するKubernetesクラスターおよびkubectlが必要です。
<a href=https://github.com/kubernetes/metrics>Metrics API</a>を介してメトリクスを提供するために、<a href=https://github.com/kubernetes-sigs/metrics-server>Metrics server</a>によるモニタリングがクラスター内にデプロイされている必要があります。
Horizontal Pod Autoscalerはメトリクスを収集するためにこのAPIを利用します。metrics-serverをデプロイする方法を知りたい場合は<a href=https://github.com/kubernetes-sigs/metrics-server#deployment>metrics-server ドキュメント</a>をご覧ください。</p>
<p>Horizontal Pod Autoscalerで複数のリソースメトリクスを利用するためには、バージョン1.6以上のKubernetesクラスターおよびkubectlが必要です。カスタムメトリクスを使えるようにするためには、あなたのクラスターがカスタムメトリクスAPIを提供するAPIサーバーと通信できる必要があります。
最後に、Kubernetesオブジェクトと関係のないメトリクスを使うにはバージョン1.10以上のKubernetesクラスターおよびkubectlが必要で、さらにあなたのクラスターが外部メトリクスAPIを提供するAPIサーバーと通信できる必要があります。
詳細については<a href=/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics>Horizontal Pod Autoscaler user guide</a>をご覧ください。</p>
<h2 id=php-apacheの起動と公開>php-apacheの起動と公開</h2>
<p>Horizontal Pod Autoscalerのデモンストレーションのために、php-apacheイメージをもとにしたカスタムのDockerイメージを使います。
このDockerfileは下記のようになっています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=color:#a2f;font-weight:700>FROM</span><span style=color:#b44> php:5-apache</span><span>
</span><span></span><span style=color:#a2f;font-weight:700>COPY</span> index.php /var/www/html/index.php<span>
</span><span></span><span style=color:#a2f;font-weight:700>RUN</span> chmod a+rx index.php<span>
</span></code></pre></div><p>これはCPU負荷の高い演算を行うindex.phpを定義しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=color:#666>&lt;?</span>php
  <span style=color:#b8860b>$x</span> <span style=color:#666>=</span> <span style=color:#666>0.0001</span>;
  <span style=color:#a2f;font-weight:700>for</span> (<span style=color:#b8860b>$i</span> <span style=color:#666>=</span> <span style=color:#666>0</span>; <span style=color:#b8860b>$i</span> <span style=color:#666>&lt;=</span> <span style=color:#666>1000000</span>; <span style=color:#b8860b>$i</span><span style=color:#666>++</span>) {
    <span style=color:#b8860b>$x</span> <span style=color:#666>+=</span> sqrt(<span style=color:#b8860b>$x</span>);
  }
  <span style=color:#a2f;font-weight:700>echo</span> <span style=color:#b44>&#34;OK!&#34;</span>;
<span style=color:#080>?&gt;</span><span>
</span></code></pre></div><p>まず最初に、イメージを動かすDeploymentを起動し、Serviceとして公開しましょう。
下記の設定を使います。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/php-apache.yaml download=application/php-apache.yaml><code>application/php-apache.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-php-apache-yaml')" title="Copy application/php-apache.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-php-apache-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/hpa-example<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>200m<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>以下のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/php-apache.yaml
</code></pre></div><pre><code>deployment.apps/php-apache created
service/php-apache created
</code></pre><h2 id=horizontal-pod-autoscalerを作成する>Horizontal Pod Autoscalerを作成する</h2>
<p>サーバーが起動したら、<a href=/docs/reference/generated/kubectl/kubectl-commands#autoscale>kubectl autoscale</a>を使ってautoscalerを作成しましょう。以下のコマンドで、最初のステップで作成したphp-apache deploymentによって制御されるPodレプリカ数を1から10の間に維持するHorizontal Pod Autoscalerを作成します。
簡単に言うと、HPAは（Deploymentを通じて）レプリカ数を増減させ、すべてのPodにおける平均CPU使用率を50%（それぞれのPodは<code>kubectl run</code>で200 milli-coresを要求しているため、平均CPU使用率100 milli-coresを意味します）に保とうとします。
このアルゴリズムについての詳細は<a href=/docs/tasks/run-application/horizontal-pod-autoscale/#algorithm-details>こちら</a>をご覧ください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl autoscale deployment php-apache --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span> --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>
</code></pre></div><pre><code>horizontalpodautoscaler.autoscaling/php-apache autoscaled
</code></pre><p>以下を実行して現在のAutoscalerの状況を確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get hpa
</code></pre></div><pre><code>NAME         REFERENCE                     TARGET    MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   0% / 50%  1         10        1          18s
</code></pre><p>現在はサーバーにリクエストを送っていないため、CPU使用率が0%になっていることに注意してください（<code>TARGET</code>カラムは対応するDeploymentによって制御される全てのPodの平均値を示しています。）。</p>
<h2 id=負荷の増加>負荷の増加</h2>
<p>Autoscalerがどのように負荷の増加に反応するか見てみましょう。
コンテナを作成し、クエリの無限ループをphp-apacheサーバーに送ってみます（これは別のターミナルで実行してください）。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run -i --tty load-generator --rm --image<span style=color:#666>=</span>busybox --restart<span style=color:#666>=</span>Never -- /bin/sh -c <span style=color:#b44>&#34;while sleep 0.01; do wget -q -O- http://php-apache; done&#34;</span>
</code></pre></div><p>数分以内に、下記を実行することでCPU負荷が高まっていることを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get hpa
</code></pre></div><pre><code>NAME         REFERENCE                     TARGET      MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   305% / 50%  1         10        1          3m
</code></pre><p>ここでは、CPU使用率はrequestの305%にまで高まっています。
結果として、Deploymentはレプリカ数7にリサイズされました。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment php-apache
</code></pre></div><pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
php-apache   7/7      7           7           19m
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> レプリカ数が安定するまでは数分かかることがあります。負荷量は何らかの方法で制御されているわけではないので、最終的なレプリカ数はこの例とは異なる場合があります。
</div>
<h2 id=負荷の停止>負荷の停止</h2>
<p>ユーザー負荷を止めてこの例を終わらせましょう。</p>
<p>私たちが<code>busybox</code>イメージを使って作成したコンテナ内のターミナルで、<code>&lt;Ctrl> + C</code>を入力して負荷生成を終了させます。</p>
<p>そして結果の状態を確認します（数分後）。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get hpa
</code></pre></div><pre><code>NAME         REFERENCE                     TARGET       MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   0% / 50%     1         10        1          11m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployment php-apache
</code></pre></div><pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
php-apache   1/1     1            1           27m
</code></pre><p>ここでCPU使用率は0に下がり、HPAによってオートスケールされたレプリカ数は1に戻ります。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> レプリカのオートスケールには数分かかることがあります。
</div>
<h2 id=複数のメトリクスやカスタムメトリクスを基にオートスケーリングする>複数のメトリクスやカスタムメトリクスを基にオートスケーリングする</h2>
<p><code>autoscaling/v2beta2</code> APIバージョンと使うと、<code>php-apache</code> Deploymentをオートスケーリングする際に使う追加のメトリクスを導入することが出来ます。</p>
<p>まず、<code>autoscaling/v2beta2</code>内のHorizontalPodAutoscalerのYAMLファイルを入手します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get hpa.v2beta2.autoscaling -o yaml &gt; /tmp/hpa-v2.yaml
</code></pre></div><p><code>/tmp/hpa-v2.yaml</code>ファイルをエディタで開くと、以下のようなYAMLファイルが見えるはずです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v2beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metrics</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lastScaleTime</span>:<span style=color:#bbb> </span>&lt;some-time&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentMetrics</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></code></pre></div><p><code>targetCPUUtilizationPercentage</code>フィールドは<code>metrics</code>と呼ばれる配列に置換されています。
CPU使用率メトリクスは、Podコンテナで定められたリソースの割合として表されるため、<em>リソースメトリクス</em>です。CPU以外のリソースメトリクスを指定することもできます。デフォルトでは、他にメモリだけがリソースメトリクスとしてサポートされています。これらのリソースはクラスター間で名前が変わることはなく、そして<code>metrics.k8s.io</code> APIが利用可能である限り常に利用可能です。</p>
<p>さらに<code>target.type</code>において<code>Utilization</code>の代わりに<code>AverageValue</code>を使い、<code>target.averageUtilization</code>フィールドの代わりに対応する<code>target.averageValue</code>フィールドを設定することで、リソースメトリクスをrequest値に対する割合に代わり、直接的な値に設定することも可能です。</p>
<p>PodメトリクスとObjectメトリクスという2つの異なる種類のメトリクスが存在し、どちらも<em>カスタムメトリクス</em>とみなされます。これらのメトリクスはクラスター特有の名前を持ち、利用するにはより発展的なクラスター監視設定が必要となります。</p>
<p>これらの代替メトリクスタイプのうち、最初のものが<em>Podメトリクス</em>です。これらのメトリクスはPodを説明し、Podを渡って平均され、レプリカ数を決定するためにターゲット値と比較されます。
これらはほとんどリソースメトリクス同様に機能しますが、<code>target</code>の種類としては<code>AverageValue</code><em>のみ</em>をサポートしている点が異なります。</p>
<p>Podメトリクスはmetricブロックを使って以下のように指定されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>packets-per-second<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span>1k<span style=color:#bbb>
</span></code></pre></div><p>2つ目のメトリクスタイプは<em>Objectメトリクス</em>です。これらのメトリクスはPodを説明するかわりに、同一Namespace内の異なったオブジェクトを説明します。このメトリクスはオブジェクトから取得される必要はありません。単に説明するだけです。Objectメトリクスは<code>target</code>の種類として<code>Value</code>と<code>AverageValue</code>をサポートします。<code>Value</code>では、ターゲットはAPIから返ってきたメトリクスと直接比較されます。<code>AverageValue</code>では、カスタムメトリクスAPIから返ってきた値はターゲットと比較される前にPodの数で除算されます。以下の例は<code>requests-per-second</code>メトリクスのYAML表現です。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Value<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>2k<span style=color:#bbb>
</span></code></pre></div><p>もしこのようなmetricブロックを複数提供した場合、HorizontalPodAutoscalerはこれらのメトリクスを順番に処理します。
HorizontalPodAutoscalerはそれぞれのメトリクスについて推奨レプリカ数を算出し、その中で最も多いレプリカ数を採用します。</p>
<p>例えば、もしあなたがネットワークトラフィックについてのメトリクスを収集する監視システムを持っているなら、<code>kubectl edit</code>を使って指定を次のように更新することができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v2beta2<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metrics</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>packets-per-second<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span>1k<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Value<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>10k<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lastScaleTime</span>:<span style=color:#bbb> </span>&lt;some-time&gt;<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentMetrics</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>10k<span style=color:#bbb>
</span></code></pre></div><p>この時、HorizontalPodAutoscalerはそれぞれのPodがCPU requestの50%を使い、1秒当たり1000パケットを送信し、そしてmain-route
Ingressの裏にあるすべてのPodが合計で1秒当たり10000パケットを送信する状態を保持しようとします。</p>
<h3 id=より詳細なメトリクスをもとにオートスケーリングする>より詳細なメトリクスをもとにオートスケーリングする</h3>
<p>多くのメトリクスパイプラインは、名前もしくは <em>labels</em> と呼ばれる追加の記述子の組み合わせによって説明することができます。全てのリソースメトリクス以外のメトリクスタイプ（Pod、Object、そして下で説明されている外部メトリクス）において、メトリクスパイプラインに渡す追加のラベルセレクターを指定することができます。例えば、もしあなたが<code>http_requests</code>メトリクスを<code>verb</code>ラベルとともに収集しているなら、下記のmetricブロックを指定してGETリクエストにのみ基づいてスケールさせることができます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http_requests<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb> </span>{<span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb> </span>{<span style=color:green;font-weight:700>verb</span>:<span style=color:#bbb> </span>GET}}<span style=color:#bbb>
</span></code></pre></div><p>このセレクターは完全なKubernetesラベルセレクターと同じ文法を利用します。もし名前とセレクターが複数の系列に一致した場合、この監視パイプラインはどのようにして複数の系列を一つの値にまとめるかを決定します。このセレクターは付加的なもので、ターゲットオブジェクト（<code>Pods</code>タイプの場合は対象Pod、<code>Object</code>タイプの場合は説明されるオブジェクト）では<strong>ない</strong>オブジェクトを説明するメトリクスを選択することは出来ません。</p>
<h3 id=kubernetesオブジェクトと関係ないメトリクスに基づいたオートスケーリング>Kubernetesオブジェクトと関係ないメトリクスに基づいたオートスケーリング</h3>
<p>Kubernetes上で動いているアプリケーションを、Kubernetes Namespaceと直接的な関係がないサービスを説明するメトリクスのような、Kubernetesクラスター内のオブジェクトと明確な関係が無いメトリクスを基にオートスケールする必要があるかもしれません。Kubernetes 1.10以降では、このようなユースケースを<em>外部メトリクス</em>によって解決できます。</p>
<p>外部メトリクスを使うにはあなたの監視システムについての知識が必要となります。この設定はカスタムメトリクスを使うときのものに似ています。外部メトリクスを使うとあなたの監視システムのあらゆる利用可能なメトリクスに基づいてクラスターをオートスケールできるようになります。上記のように<code>metric</code>ブロックで<code>name</code>と<code>selector</code>を設定し、<code>Object</code>のかわりに<code>External</code>メトリクスタイプを使います。
もし複数の時系列が<code>metricSelector</code>により一致した場合は、それらの値の合計がHorizontalPodAutoscalerに使われます。
外部メトリクスは<code>Value</code>と<code>AverageValue</code>の両方のターゲットタイプをサポートしています。これらの機能は<code>Object</code>タイプを利用するときとまったく同じです。</p>
<p>例えばもしあなたのアプリケーションがホストされたキューサービスからのタスクを処理している場合、あなたは下記のセクションをHorizontalPodAutoscalerマニフェストに追記し、未処理のタスク30個あたり1つのワーカーを必要とすることを指定します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>External<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>external</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>queue_messages_ready<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;queue=worker_tasks&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></code></pre></div><p>可能なら、クラスター管理者がカスタムメトリクスAPIを保護することを簡単にするため、外部メトリクスのかわりにカスタムメトリクスを用いることが望ましいです。外部メトリクスAPIは潜在的に全てのメトリクスへのアクセスを許可するため、クラスター管理者はこれを公開する際には注意が必要です。</p>
<h2 id=付録-horizontal-pod-autoscaler-status-conditions>付録: Horizontal Pod Autoscaler status conditions</h2>
<p><code>autoscaling/v2beta2</code>形式のHorizontalPodAutoscalerを使っている場合は、KubernetesによるHorizontalPodAutoscaler上の<em>status conditions</em>セットを見ることができます。status conditionsはHorizontalPodAutoscalerがスケール可能かどうか、そして現時点でそれが何らかの方法で制限されているかどうかを示しています。</p>
<p>このconditionsは<code>status.conditions</code>フィールドに現れます。HorizontalPodAutoscalerに影響しているconditionsを確認するために、<code>kubectl describe hpa</code>を利用できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe hpa cm-test
</code></pre></div><pre><code>Name:                           cm-test
Namespace:                      prom
Labels:                         &lt;none&gt;
Annotations:                    &lt;none&gt;
CreationTimestamp:              Fri, 16 Jun 2017 18:09:22 +0000
Reference:                      ReplicationController/cm-test
Metrics:                        ( current / target )
  &quot;http_requests&quot; on pods:      66m / 500m
Min replicas:                   1
Max replicas:                   4
ReplicationController pods:     1 current / 1 desired
Conditions:
  Type                  Status  Reason                  Message
  ----                  ------  ------                  -------
  AbleToScale           True    ReadyForNewScale        the last scale time was sufficiently old as to warrant a new scale
  ScalingActive         True    ValidMetricFound        the HPA was able to successfully calculate a replica count from pods metric http_requests
  ScalingLimited        False   DesiredWithinRange      the desired replica count is within the acceptable range
Events:
</code></pre><p>このHorizontalPodAutoscalerにおいて、いくつかの正常な状態のconditionsを見ることができます。まず最初に、<code>AbleToScale</code>は、HPAがスケール状況を取得し、更新させることが出来るかどうかだけでなく、何らかのbackoffに関連した状況がスケーリングを妨げていないかを示しています。2番目に、<code>ScalingActive</code>は、HPAが有効化されているかどうか（例えば、レプリカ数のターゲットがゼロでないこと）や、望ましいスケールを算出できるかどうかを示します。もしこれが<code>False</code>の場合、大体はメトリクスの取得において問題があることを示しています。最後に、一番最後の状況である<code>ScalingLimited</code>は、HorizontalPodAutoscalerの最大値や最小値によって望ましいスケールがキャップされていることを示しています。この指標を見てHorizontalPodAutoscaler上の最大・最小レプリカ数制限を増やす、もしくは減らす検討ができます。</p>
<h2 id=付録-数量>付録: 数量</h2>
<p>全てのHorizontalPodAutoscalerおよびメトリクスAPIにおけるメトリクスは<a class=glossary-tooltip title="A whole-number representation of small or large numbers using SI suffixes." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-quantity" target=_blank aria-label=quantity>quantity</a>として知られる特殊な整数表記によって指定されます。例えば、<code>10500m</code>という数量は10進数表記で<code>10.5</code>と書くことができます。メトリクスAPIは可能であれば接尾辞を用いない整数を返し、そうでない場合は基本的にミリ単位での数量を返します。これはメトリクス値が<code>1</code>と<code>1500m</code>の間で、もしくは10進法表記で書かれた場合は<code>1</code>と<code>1.5</code>の間で変動するということを意味します。</p>
<h2 id=付録-その他の起きうるシナリオ>付録: その他の起きうるシナリオ</h2>
<h3 id=autoscalerを宣言的に作成する>Autoscalerを宣言的に作成する</h3>
<p><code>kubectl autoscale</code>コマンドを使って命令的にHorizontalPodAutoscalerを作るかわりに、下記のファイルを使って宣言的に作成することができます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/hpa/php-apache.yaml download=application/hpa/php-apache.yaml><code>application/hpa/php-apache.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-hpa-php-apache-yaml')" title="Copy application/hpa/php-apache.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-hpa-php-apache-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>下記のコマンドを実行してAutoscalerを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/application/hpa/php-apache.yaml
</code></pre></div><pre><code>horizontalpodautoscaler.autoscaling/php-apache created
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ca3bc4e31dfe46d5044a3b93eb804ee9>8 - Jobの実行</h1>
<div class=lead>並列処理を使用してJobを実行します。</div>
</div>
<div class=td-content>
<h1 id=pg-964bdff888520740e5e221695245678d>8.1 - CronJobを使用して自動化タスクを実行する</h1>
<p>CronJobは、Kubernetes v1.21で一般利用(GA)に昇格しました。古いバージョンのKubernetesを使用している場合、正確な情報を参照できるように、使用しているバージョンのKubernetesのドキュメントを参照してください。古いKubernetesのバージョンでは、<code>batch/v1</code> CronJob APIはサポートされていません。</p>
<p><a class=glossary-tooltip title="A repeating task (a Job) that runs on a regular schedule." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/cron-jobs/ target=_blank aria-label=CronJob>CronJob</a>を使用すると、<a class=glossary-tooltip title="A finite or batch task that runs to completion." data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>を時間ベースのスケジュールで実行できるようになります。この自動化されたJobは、LinuxまたはUNIXシステム上の<a href=https://ja.wikipedia.org/wiki/Cron>Cron</a>のように実行されます。</p>
<p>CronJobは、バックアップやメールの送信など、定期的なタスクや繰り返しのタスクを作成する時に便利です。CronJobはそれぞれのタスクを、たとえばアクティビティが少ない期間など、特定の時間にスケジューリングすることもできます。</p>
<p>CronJobには制限と特性があります。たとえば、特定の状況下では、1つのCronJobが複数のJobを作成する可能性があるため、Jobは冪等性を持つようにしなければいけません。</p>
<p>制限に関する詳しい情報については、<a href=/ja/docs/concepts/workloads/controllers/cron-jobs/>CronJob</a>を参照してください。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
</li>
</ul>
<h2 id=cronjobを作成する>CronJobを作成する</h2>
<p>CronJobには設定ファイルが必要です。次の例のCronJobの<code>.spec</code>は、現在の時刻とhelloというメッセージを1分ごとに表示します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/job/cronjob.yaml download=application/job/cronjob.yaml><code>application/job/cronjob.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-cronjob-yaml')" title="Copy application/job/cronjob.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-cronjob-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronJob<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*/1 * * * *&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jobTemplate</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- /bin/sh<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- -c<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- date; echo Hello from the Kubernetes cluster<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>次のコマンドで例のCronJobを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://k8s.io/examples/application/job/cronjob.yaml
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>cronjob.batch/hello created
</code></pre><p>CronJobを作成したら、次のコマンドで状態を取得します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get cronjob hello
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     0        &lt;none&gt;          10s
</code></pre><p>コマンドの結果からわかるように、CronJobはまだスケジュールされておらず、まだ何のJobも実行していません。約1分以内にJobが作成されるのを見てみましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get <span style=color:#a2f>jobs</span> --watch
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME               COMPLETIONS   DURATION   AGE
hello-4111706356   0/1                      0s
hello-4111706356   0/1           0s         0s
hello-4111706356   1/1           5s         5s
</code></pre><p>"hello"CronJobによってスケジュールされたJobが1つ実行中になっていることがわかります。Jobを見るのをやめて、再度CronJobを表示して、Jobがスケジュールされたことを確認してみます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get cronjob hello
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     0        50s             75s
</code></pre><p>CronJob<code>hello</code>が、<code>LAST SCHEDULE</code>で指定された時間にJobを正しくスケジュールしたことが確認できるはずです。現在、activeなJobの数は0です。つまり、Jobは完了または失敗したことがわかります。</p>
<p>それでは、最後にスケジュールされたJobの作成と、Podの1つの標準出力を表示してみましょう。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Jobの名前とPodの名前は異なります。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># &#34;hello-4111706356&#34; の部分は、あなたのシステム上のJobの名前に置き換えてください。</span>
<span style=color:#b8860b>pods</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span>job-name<span style=color:#666>=</span>hello-4111706356 --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items<span style=color:#666>[</span>*<span style=color:#666>]</span>.metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
</code></pre></div><p>Podのログを表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs <span style=color:#b8860b>$pods</span>
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>Fri Feb 22 11:02:09 UTC 2019
Hello from the Kubernetes cluster
</code></pre><h2 id=cronjobの削除>CronJobの削除</h2>
<p>CronJobが必要なくなったときは、<code>kubectl delete cronjob &lt;cronjob name></code>で削除します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete cronjob hello
</code></pre></div><p>CronJobを削除すると、すべてのJobと、そのJobが作成したPodが削除され、追加のJobの作成が停止されます。Jobの削除について詳しく知りたい場合は、<a href=/ja/docs/concepts/workloads/controllers/garbage-collection/>ガベージコレクション</a>を読んでください。</p>
<h2 id=writing-a-cron-job-spec>CronJobのspecを書く</h2>
<p>すべてのKubernetesの設定と同じように、CronJobにも<code>apiVersion</code>、<code>kind</code>、<code>metadata</code>のフィールドが必要です。設定ファイルの扱い方についての一般的な情報については、<a href=/ja/docs/tasks/run-application/run-stateless-application-deployment/>アプリケーションのデプロイ</a>と<a href=/ja/docs/concepts/overview/working-with-objects/object-management/>kubectlを使用してリソースを管理する</a>を読んでください。</p>
<p>CronJobの設定には、<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code>セクション</a>も必要です。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> CronJobの特に<code>spec</code>へのすべての修正は、それ以降の実行にのみ適用されます。
</div>
<h3 id=schedule>Schedule</h3>
<p><code>.spec.schedule</code>は、<code>.spec</code>には必須のフィールドです。<code>0 * * * *</code>や<code>@hourly</code>などの<a href=https://ja.wikipedia.org/wiki/Cron>Cron</a>形式の文字列を取り、Jobの作成と実行のスケジュール時間を指定します。</p>
<p>フォーマットにはVixie cronのステップ値(step value)も指定できます。<a href=https://www.freebsd.org/cgi/man.cgi?crontab%285%29>FreeBSDのマニュアル</a>では次のように説明されています。</p>
<blockquote>
<p>ステップ値は範囲指定と組み合わせて使用できます。範囲の後ろに<code>/&lt;number></code>を付けると、範囲全体で指定したnumberの値ごとにスキップすることを意味します。たとえば、<code>0-23/2</code>をhoursフィールドに指定すると、2時間毎にコマンド実行を指定することになります(V7標準では代わりに<code>0,2,4,6,8,10,12,14,16,18,20,22</code>と指定する必要があります)。ステップはアスタリスクの後ろにつけることもできます。そのため、「2時間毎に実行」したい場合は、単純に<code>*/2</code>と指定できます。</p>
</blockquote>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> スケジュール内の疑問符<code>?</code>はアスタリスク<code>*</code>と同じ意味を持ちます。つまり、与えられたフィールドには任意の値が使えるという意味になります。
</div>
<h3 id=job-template>Job Template</h3>
<p><code>.spec.jobTemplate</code>はJobのテンプレートであり、必須です。<a href=/docs/concepts/workloads/controllers/job/>Job</a>と完全に同一のスキーマを持ちますが、フィールドがネストされている点と、<code>apiVersion</code>と<code>kind</code>が存在しない点だけが異なります。Jobの<code>.spec</code>を書くための情報については、<a href=/docs/concepts/workloads/controllers/job/#writing-a-job-spec>JobのSpecを書く</a>を参照してください。</p>
<h3 id=starting-deadline>Starting Deadline</h3>
<p><code>.spec.startingDeadlineSeconds</code>フィールドはオプションです。何かの理由でスケジュールに間に合わなかった場合に適用される、Jobの開始のデッドライン(締め切り)を秒数で指定します。デッドラインを過ぎると、CronJobはJobを開始しません。この場合にデッドラインに間に合わなかったJobは、失敗したJobとしてカウントされます。もしこのフィールドが指定されなかった場合、Jobはデッドラインを持ちません。</p>
<p><code>.spec.startingDeadlineSeconds</code>フィールドがnull以外に設定された場合、CronJobコントローラーはJobの作成が期待される時間と現在時刻との間の時間を計測します。もしその差が制限よりも大きかった場合、その実行はスキップされます。</p>
<p>たとえば、この値が<code>200</code>に設定された場合、実際のスケジュールの最大200秒後までに作成されるJobだけが許可されます。</p>
<h3 id=concurrency-policy>Concurrency Policy</h3>
<p><code>.spec.concurrencyPolicy</code>フィールドもオプションです。このフィールドは、このCronJobで作成されたJobの並列実行をどのように扱うかを指定します。specには以下のconcurrency policyのいずれかを指定します。</p>
<ul>
<li><code>Allow</code> (デフォルト): CronJobがJobを並列に実行することを許可します。</li>
<li><code>Forbid</code>: CronJobの並列実行を禁止します。もし新しいJobの実行時に過去のJobがまだ完了していなかった場合、CronJobは新しいJobの実行をスキップします。</li>
<li><code>Replace</code>: もし新しいJobの実行の時間になっても過去のJobの実行が完了していなかった場合、CronJobは現在の実行中のJobを新しいJobで置換します。</li>
</ul>
<p>concurrency policyは、同じCronJobが作成したJobにのみ適用されます。もし複数のCronJobがある場合、それぞれのJobの並列実行は常に許可されます。</p>
<h3 id=suspend>Suspend</h3>
<p><code>.spec.suspend</code>フィールドもオプションです。このフィールドを<code>true</code>に設定すると、すべての後続の実行がサスペンド(一時停止)されます。この設定はすでに実行開始したJobには適用されません。デフォルトはfalseです。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> スケジュールされた時間中にサスペンドされた実行は、見逃されたJob(missed job)としてカウントされます。<a href=#starting-deadline>starting deadline</a>が設定されていない既存のCronJob<code>.spec.suspend</code>が<code>true</code>から<code>false</code>に変更されると、見逃されたJobは即座にスケジュールされます。
</div>
<h3 id=job-history-limit>Job History Limit</h3>
<p><code>.spec.successfulJobsHistoryLimit</code>と<code>.spec.failedJobsHistoryLimit</code>フィールドはオプションです。これらのフィールドには、完了したJobと失敗したJobをいくつ保持するかを指定します。デフォルトでは、それぞれ3と1に設定されます。リミットを<code>0</code>に設定すると、対応する種類のJobを実行完了後に何も保持しなくなります。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9e63850014876afaebd1561f70bb8f6b>8.2 - 静的な処理の割り当てを使用した並列処理のためのインデックス付きJob</h1>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code>
</div>
<p>この例では、複数の並列ワーカープロセスを使用するKubernetesのJobを実行します。各ワーカーは、それぞれが自分のPod内で実行される異なるコンテナです。Podはコントロールプレーンが自動的に設定する<em>インデックス値</em>を持ち、この値を利用することで、各Podは処理するタスク全体のどの部分を処理するのかを特定できます。</p>
<p>Podのインデックスは、<a class=glossary-tooltip title="A key-value pair that is used to attach arbitrary non-identifying metadata to objects." data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/annotations target=_blank aria-label=アノテーション>アノテーション</a>内の<code>batch.kubernetes.io/job-completion-index</code>を整数値の文字列表現として利用できます。コンテナ化されたタスクプロセスがこのインデックスを取得できるようにするために、このアノテーションの値は<a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#the-downward-api>downward API</a>の仕組みを利用することで公開できます。利便性のために、コントロールプレーンは自動的にdownward APIを設定して、<code>JOB_COMPLETION_INDEX</code>環境変数にインデックスを公開します。</p>
<p>以下に、この例で実行するステップの概要を示します。</p>
<ol>
<li><strong>completionのインデックスを使用してJobのマニフェストを定義する</strong>。downward APIはPodのインデックスのアノテーションを環境変数またはファイルとしてコンテナに渡してくれます。</li>
<li><strong>そのマニフェストに基づいてインデックス付き(Indexed)のJobを開始する</strong>。</li>
</ol>
<h2 id=始める前に>始める前に</h2>
<p>あらかじめ基本的な非並列の<a href=/docs/concepts/workloads/controllers/job/>Job</a>の使用に慣れている必要があります。</p>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.21.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>インデックス付きJobを作成できるようにするには、<a href=/docs/reference/command-line-tools-reference/kube-apiserver/>APIサーバー</a>と<a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>コントローラーマネージャー</a>上で<code>IndexedJob</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を有効にしていることを確認してください。</p>
<h2 id=アプローチを選択する>アプローチを選択する</h2>
<p>ワーカープログラムから処理アイテムにアクセスするには、いくつかの選択肢があります。</p>
<ol>
<li><code>JOB_COMPLETION_INDEX</code>環境変数を読み込む。Job<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>は、この変数をcompletion indexを含むアノテーションに自動的にリンクします。</li>
<li>completion indexを含むファイルを読み込む。</li>
<li>プログラムを修正できない場合、プログラムをスクリプトでラップし、上のいずれかの方法でインデックスを読み取り、プログラムが入力として使用できるものに変換する。</li>
</ol>
<p>この例では、3番目のオプションを選択肢して、<a href=https://man7.org/linux/man-pages/man1/rev.1.html>rev</a>ユーティリティを実行したいと考えているとしましょう。このプログラムはファイルを引数として受け取り、内容を逆さまに表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>rev data.txt
</code></pre></div><p><code>rev</code>ツールは<a href=https://hub.docker.com/_/busybox><code>busybox</code></a>コンテナイメージから利用できます。</p>
<p>これは単なる例であるため、各Podはごく簡単な処理(短い文字列を逆にする)をするだけです。現実のワークロードでは、たとえば、シーンデータをもとに60秒の動画を生成するというようなタスクを記述したJobを作成するかもしれません。ビデオレンダリングJobの各処理アイテムは、ビデオクリップの特定のフレームのレンダリングを行うものになるでしょう。その場合、インデックス付きの完了が意味するのは、クリップの最初からフレームをカウントすることで、Job内の各Podがレンダリングと公開をするのがどのフレームであるかがわかるということです。</p>
<h2 id=インデックス付きjobを定義する>インデックス付きJobを定義する</h2>
<p>以下は、completion modeとして<code>Indexed</code>を使用するJobのマニフェストの例です。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/job/indexed-job.yaml download=application/job/indexed-job.yaml><code>application/job/indexed-job.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-indexed-job-yaml')" title="Copy application/job/indexed-job.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-indexed-job-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;indexed-job&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completionMode</span>:<span style=color:#bbb> </span>Indexed<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;input&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/bash&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;bash&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span><span style=color:#b44;font-style:italic>          items=(foo bar baz qux xyz)
</span><span style=color:#b44;font-style:italic>          echo ${items[$JOB_COMPLETION_INDEX]} &gt; /input/data.txt</span><span style=color:#bbb>          
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;worker&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/busybox&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;rev&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;/input/data.txt&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>上記の例では、Jobコントローラーがすべてのコンテナに設定する組み込みの<code>JOB_COMPLETION_INDEX</code>環境変数を使っています。<a href=/ja/docs/concepts/workloads/pods/init-containers/>initコンテナ</a>がインデックスを静的な値にマッピングし、その値をファイルに書き込み、ファイルを<a href=/docs/concepts/storage/volumes/#emptydir>emptyDir volume</a>を介してワーカーを実行しているコンテナと共有します。オプションとして、インデックスとコンテナに公開するために<a href=/ja/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>downward APIを使用して独自の環境変数を定義する</a>こともできます。<a href=/ja/docs/tasks/configure-pod-container/configure-pod-configmap/>環境変数やファイルとして設定したConfigMap</a>から値のリストを読み込むという選択肢もあります。</p>
<p>他には、以下の例のように、直接<a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/#store-pod-fields>downward APIを使用してアノテーションの値をボリュームファイルとして渡す</a>こともできます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/job/indexed-job-vol.yaml download=application/job/indexed-job-vol.yaml><code>application/job/indexed-job-vol.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-job-indexed-job-vol-yaml')" title="Copy application/job/indexed-job-vol.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-job-indexed-job-vol-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;indexed-job&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completions</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parallelism</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>completionMode</span>:<span style=color:#bbb> </span>Indexed<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;worker&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker.io/library/busybox&#39;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;rev&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;/input/data.txt&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/input<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>input<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;data.txt&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.annotations[&#39;batch.kubernetes.io/job-completion-index&#39;]</code></pre></div>
</div>
</div>
<h2 id=jobを実行する>Jobを実行する</h2>
<p>次のコマンドでJobを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドでは1番目のアプローチを使っています ($JOB_COMPLETION_INDEX に依存しています)</span>
kubectl apply -f https://kubernetes.io/examples/application/job/indexed-job.yaml
</code></pre></div><p>このJobを作成したら、コントロールプレーンは指定した各インデックスごとに一連のPodを作成します。<code>.spec.parallelism</code>の値が同時に実行できるPodの数を決定し、<code>.spec.completions</code>の値がJobが作成するPodの合計数を決定します。</p>
<p><code>.spec.parallelism</code>は<code>.spec.completions</code>より小さいため、コントロールプレーンは別のPodを開始する前に最初のPodの一部が完了するまで待機します。</p>
<p>Jobを作成したら、少し待ってから進行状況を確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe jobs/indexed-job
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>Name:              indexed-job
Namespace:         default
Selector:          controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
Labels:            controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
                   job-name=indexed-job
Annotations:       &lt;none&gt;
Parallelism:       3
Completions:       5
Start Time:        Thu, 11 Mar 2021 15:47:34 +0000
Pods Statuses:     2 Running / 3 Succeeded / 0 Failed
Completed Indexes: 0-2
Pod Template:
  Labels:  controller-uid=bf865e04-0b67-483b-9a90-74cfc4c3e756
           job-name=indexed-job
  Init Containers:
   input:
    Image:      docker.io/library/bash
    Port:       &lt;none&gt;
    Host Port:  &lt;none&gt;
    Command:
      bash
      -c
      items=(foo bar baz qux xyz)
      echo ${items[$JOB_COMPLETION_INDEX]} &gt; /input/data.txt

    Environment:  &lt;none&gt;
    Mounts:
      /input from input (rw)
  Containers:
   worker:
    Image:      docker.io/library/busybox
    Port:       &lt;none&gt;
    Host Port:  &lt;none&gt;
    Command:
      rev
      /input/data.txt
    Environment:  &lt;none&gt;
    Mounts:
      /input from input (rw)
  Volumes:
   input:
    Type:       EmptyDir (a temporary directory that shares a pod's lifetime)
    Medium:
    SizeLimit:  &lt;unset&gt;
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-njkjj
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-9kd4h
  Normal  SuccessfulCreate  4s    job-controller  Created pod: indexed-job-qjwsz
  Normal  SuccessfulCreate  1s    job-controller  Created pod: indexed-job-fdhq5
  Normal  SuccessfulCreate  1s    job-controller  Created pod: indexed-job-ncslj
</code></pre><p>この例では、各インデックスごとにカスタムの値を使用してJobを実行します。次のコマンドでPodの1つの出力を確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs indexed-job-fdhq5 <span style=color:#080;font-style:italic># これを対象のJobのPodの名前に一致するように変更してください。</span>
</code></pre></div><p>出力は次のようになります。</p>
<pre><code>xuq
</code></pre>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-b74b959f5a531003dd0653dfbfc2e88b>9 - クラスター内アプリケーションへのアクセス</h1>
<div class=lead>クラスター内アプリケーションへアクセスできるようにするために、ロードバランシングやポートフォワーディングの設定、ファイアウォールやDNS設定のセットアップを行います。</div>
</div>
<div class=td-content>
<h1 id=pg-777447042cd4e81df3fa5beb3357a485>9.1 - Web UI (Dashboard)</h1>
<p>ダッシュボードは、WebベースのKubernetesユーザーインターフェイスです。
ダッシュボードを使用して、コンテナ化されたアプリケーションをKubernetesクラスターにデプロイしたり、
コンテナ化されたアプリケーションをトラブルシューティングしたり、クラスターリソースを管理したりすることができます。
ダッシュボードを使用して、クラスター上で実行されているアプリケーションの概要を把握したり、
個々のKubernetesリソース(Deployments、Jobs、DaemonSetsなど)を作成または修正したりすることができます。
たとえば、Deploymentのスケール、ローリングアップデートの開始、Podの再起動、
デプロイウィザードを使用した新しいアプリケーションのデプロイなどが可能です。</p>
<p>ダッシュボードでは、クラスター内のKubernetesリソースの状態や、発生した可能性のあるエラーに関する情報も提供されます。</p>
<p><img src=/images/docs/ui-dashboard.png alt="Kubernetes Dashboard UI"></p>
<h2 id=ダッシュボードuiのデプロイ>ダッシュボードUIのデプロイ</h2>
<p>ダッシュボードUIはデフォルトではデプロイされていません。デプロイするには、以下のコマンドを実行します:</p>
<pre><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml
</code></pre><h2 id=ダッシュボードuiへのアクセス>ダッシュボードUIへのアクセス</h2>
<p>クラスターデータを保護するために、ダッシュボードはデフォルトで最小限のRBAC構成でデプロイします。
現在、ダッシュボードはBearer Tokenによるログインのみをサポートしています。
このデモ用のトークンを作成するには、
<a href=https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md>サンプルユーザーの作成</a>ガイドに従ってください。</p>
<div class="alert alert-danger warning callout" role=alert>
<strong>警告:</strong> チュートリアルで作成されたサンプルユーザーには管理者権限が与えられ、教育目的のみに使用されます。
</div>
<h3 id=コマンドラインプロキシー>コマンドラインプロキシー</h3>
<p>以下のコマンドを実行することで、kubectlコマンドラインツールを使ってダッシュボードにアクセスすることができます:</p>
<pre><code>kubectl proxy
</code></pre><p>kubectlは、ダッシュボードを http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/ で利用できるようにします。</p>
<p>UIはコマンドを実行しているマシンから <em>のみ</em> アクセスできます。オプションについては<code>kubectl proxy --help</code>を参照してください。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Kubeconfigの認証方法は、外部IDプロバイダーやx509証明書ベースの認証には対応していません。
</div>
<h2 id=ウェルカムビュー>ウェルカムビュー</h2>
<p>空のクラスターでダッシュボードにアクセスすると、ウェルカムページが表示されます。
このページには、このドキュメントへのリンクと、最初のアプリケーションをデプロイするためのボタンが含まれています。
さらに、クラスターの<code>kube-system</code><a href=/docs/tasks/administer-cluster/namespaces/>名前空間</a>でデフォルトで実行されているシステムアプリケーション、たとえばダッシュボード自体を見ることができます。</p>
<p><img src=/images/docs/ui-dashboard-zerostate.png alt="Kubernetes Dashboard welcome page"></p>
<h2 id=コンテナ化されたアプリケーションのデプロイ>コンテナ化されたアプリケーションのデプロイ</h2>
<p>ダッシュボードを使用すると、簡単なウィザードでコンテナ化されたアプリケーションをDeploymentとオプションのServiceとして作成してデプロイすることができます。
アプリケーションの詳細を手動で指定するか、アプリケーションの設定を含むYAMLまたはJSONファイルをアップロードすることができます。</p>
<p>任意のページの右上にある<strong>CREATE</strong>ボタンをクリックして開始します。</p>
<h3 id=アプリケーションの詳細の指定>アプリケーションの詳細の指定</h3>
<p>デプロイウィザードでは、以下の情報を入力する必要があります:</p>
<ul>
<li>
<p><strong>App name</strong> (必須): アプリケーションの名前です。
その名前の<a href=/ja/docs/concepts/overview/working-with-objects/labels/>label</a>は、デプロイされるDeploymentとServiceに追加されます。</p>
<p>アプリケーション名は、選択したKubernetes<a href=/docs/tasks/administer-cluster/namespaces/>名前空間</a>内で一意である必要があります。
小文字で始まり、小文字または数字で終わり、小文字、数字、ダッシュ(-)のみを含む必要があります。文字数は24文字に制限されています。先頭と末尾のスペースは無視されます。</p>
</li>
<li>
<p><strong>Container image</strong> (必須): 任意のレジストリ上の公開Docker<a href=/docs/concepts/containers/images/>コンテナイメージ</a>、またはプライベートイメージ(一般的にはGoogle Container RegistryやDocker Hub上でホストされている)のURLです。
コンテナイメージの指定はコロンで終わらせる必要があります。</p>
<p>クラスタ全体で必要な数のPodを維持するために、<a href=/ja/docs/concepts/workloads/controllers/deployment/>Deployment</a>が作成されます。</p>
</li>
<li>
<p><strong>Service</strong> (任意): アプリケーションのいくつかの部分(たとえばフロントエンド)では、
<a href=/ja/docs/concepts/services-networking/service/>Service</a>をクラスター外の外部、おそらくパブリックIPアドレス(外部サービス)に公開したいと思うかもしれません。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 外部サービスの場合は、そのために1つ以上のポートを開放する必要があるでしょう。
</div>
<p>クラスター内部からしか見えないその他のサービスは、内部サービスと呼ばれます。</p>
<p>サービスの種類にかかわらず、サービスを作成し、コンテナがポート(受信)をリッスンする場合は、
2つのポートを指定する必要があります。
サービスは、ポート(受信)をコンテナから見たターゲットポートにマッピングして作成されます。
このサービスは、デプロイされたPodにルーティングされます。サポートされるプロトコルはTCPとUDPです。
このサービスの内部DNS名は、上記のアプリケーション名として指定した値になります。</p>
</li>
</ul>
<p>必要に応じて、<strong>高度なオプション</strong>セクションを展開して、より多くの設定を指定することができます:</p>
<ul>
<li>
<p><strong>Description</strong>: ここで入力したテキストは、
<a href=/ja/docs/concepts/overview/working-with-objects/annotations/>アノテーション</a>としてDeploymentに追加され、アプリケーションの詳細に表示されます。</p>
</li>
<li>
<p><strong>Labels</strong>: アプリケーションに使用するデフォルトの<a href=/ja/docs/concepts/overview/working-with-objects/labels/>ラベル</a>は、アプリケーション名とバージョンです。
リリース、環境、ティア、パーティション、リリーストラックなど、Deployment、Service(存在する場合)、Podに適用する追加のラベルを指定できます。</p>
<p>例:</p>
<pre><code class=language-conf data-lang=conf>release=1.0
tier=frontend
environment=pod
track=stable
</code></pre></li>
<li>
<p><strong>Namespace</strong>: Kubernetesは、同じ物理クラスターを基盤とする複数の仮想クラスターをサポートしています。
これらの仮想クラスタは<a href=/docs/tasks/administer-cluster/namespaces/>名前空間</a> と呼ばれます。
これにより、リソースを論理的に名前のついたグループに分割することができます。</p>
<p>ダッシュボードでは、利用可能なすべての名前空間がドロップダウンリストに表示され、新しい名前空間を作成することができます。
名前空間名には、最大63文字の英数字とダッシュ(-)を含めることができますが、大文字を含めることはできません。
名前空間名は数字だけで構成されるべきではありません。
名前が10などの数値として設定されている場合、Podはデフォルトの名前空間に配置されます。</p>
<p>名前空間の作成に成功した場合は、デフォルトで選択されます。
作成に失敗した場合は、最初の名前空間が選択されます。</p>
</li>
<li>
<p><strong>Image Pull Secret</strong>:
指定されたDockerコンテナイメージが非公開の場合、
<a href=/ja/docs/concepts/configuration/secret/>pull secret</a>の認証情報が必要になる場合があります。</p>
<p>ダッシュボードでは、利用可能なすべてのSecretがドロップダウンリストに表示され、新しいSecretを作成できます。
Secret名は DNSドメイン名の構文に従う必要があります。たとえば、<code>new.image-pull.secret</code>です。
Secretの内容はbase64エンコードされ、<a href=/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod><code>.dockercfg</code></a>ファイルで指定されている必要があります。
Secret名は最大253文字で構成されます。</p>
<p>イメージプルシークレットの作成に成功した場合は、デフォルトで選択されています。作成に失敗した場合は、シークレットは適用されません。</p>
</li>
<li>
<p><strong>CPU requirement (cores)<strong>と</strong>Memory requirement (MiB)</strong>:
コンテナの最小<a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>リソース制限</a>を指定することができます。デフォルトでは、PodはCPUとメモリの制限がない状態で実行されます。</p>
</li>
<li>
<p><strong>Run command</strong>と<strong>Run command arguments</strong>:
デフォルトでは、コンテナは指定されたDockerイメージのデフォルトの<a href=/docs/tasks/inject-data-application/define-command-argument-container/>entrypointコマンド</a>を実行します。
コマンドのオプションと引数を使ってデフォルトを上書きすることができます。</p>
</li>
<li>
<p><strong>Run as privileged</strong>: この設定は、<a href=/ja/docs/concepts/workloads/pods/pod/#privileged-mode-for-pod-containers>特権コンテナ</a>内のプロセスが、ホスト上でrootとして実行されているプロセスと同等であるかどうかを決定します。特権コンテナは、
ネットワークスタックの操作やデバイスへのアクセスなどの機能を利用できます。</p>
</li>
<li>
<p><strong>Environment variables</strong>: Kubernetesは<a href=/ja/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>環境変数</a>を介してServiceを公開しています。
環境変数を作成したり、環境変数の値を使ってコマンドに引数を渡したりすることができます。
環境変数の値はServiceを見つけるためにアプリケーションで利用できます。
値は<code>$(VAR_NAME)</code>構文を使用して他の変数を参照できます。</p>
</li>
</ul>
<h3 id=yamlまたはjsonファイルのアップロード>YAMLまたはJSONファイルのアップロード</h3>
<p>Kubernetesは宣言的な設定をサポートしています。
このスタイルでは、すべての設定は Kubernetes <a href=/ja/docs/concepts/overview/kubernetes-api/>API</a>リソーススキーマを使用してYAMLまたは JSON設定ファイルに格納されます。</p>
<p>デプロイウィザードでアプリケーションの詳細を指定する代わりに、
YAMLまたはJSONファイルでアプリケーションを定義し、ダッシュボードを使用してファイルをアップロードできます。</p>
<h2 id=ダッシュボードの使用>ダッシュボードの使用</h2>
<p>以下のセクションでは、Kubernetes Dashboard UIのビュー、それらが提供するものとその使用方法について説明します。</p>
<h3 id=ナビゲーション>ナビゲーション</h3>
<p>クラスターにKubernetesオブジェクトが定義されている場合、ダッシュボードではそれらのオブジェクトが初期表示されます。
デフォルトでは <em>default</em> 名前空間のオブジェクトのみが表示されますが、これはナビゲーションメニューにある名前空間セレクターで変更できます。</p>
<p>ダッシュボードにはほとんどのKubernetesオブジェクトの種類が表示され、いくつかのメニューカテゴリーにグループ化されています。</p>
<h4 id=管理者の概要>管理者の概要</h4>
<p>クラスターと名前空間の管理者向けに、ダッシュボードにはノード、名前空間、永続ボリュームが一覧表示され、それらの詳細ビューが用意されています。
ノードリストビューには、すべてのノードにわたって集計されたCPUとメモリーのメトリクスが表示されます。
詳細ビューには、ノードのメトリクス、仕様、ステータス、割り当てられたリソース、イベント、ノード上で実行されているPodが表示されます。</p>
<h4 id=ワークロード>ワークロード</h4>
<p>選択した名前空間で実行されているすべてのアプリケーションを表示します。
このビューでは、アプリケーションがワークロードの種類(例：Deployment、ReplicaSet、StatefulSetなど)ごとに一覧表示され、各ワークロードの種類を個別に表示することができます。
リストには、ReplicaSetの準備ができたPodの数やPodの現在のメモリ使用量など、ワークロードに関する実用的な情報がまとめられています。</p>
<p>ワークロードの詳細ビューには、ステータスや仕様情報、オブジェクト間の表面関係が表示されます。
たとえば、ReplicaSetが制御しているPodや、新しいReplicaSet、DeploymentのためのHorizontal Pod Autoscalerなどです。</p>
<h4 id=service>Service</h4>
<p>外部の世界にサービスを公開し、クラスター内でサービスを発見できるようにするKubernetesリソースを表示します。
そのため、ServiceとIngressのビューには、それらが対象とするPod、クラスター接続の内部エンドポイント、外部ユーザーの外部エンドポイントが表示されます。</p>
<h4 id=ストレージ>ストレージ</h4>
<p>ストレージビューには、アプリケーションがデータを保存するために使用するPersistentVolumeClaimリソースが表示されます。</p>
<h4 id=configmapとsecret>ConfigMapとSecret</h4>
<p>クラスターで実行されているアプリケーションのライブ設定に使用されているすべてのKubernetesリソースを表示します。
このビューでは、設定オブジェクトの編集と管理が可能で、デフォルトで非表示になっているSecretを表示します。</p>
<h4 id=ログビューアー>ログビューアー</h4>
<p>Podのリストと詳細ページは、ダッシュボードに組み込まれたログビューアーにリンクしています。
このビューアーでは、単一のPodに属するコンテナからログをドリルダウンすることができます。</p>
<p><img src=/images/docs/ui-dashboard-logs-view.png alt="Logs viewer"></p>
<h2 id=次の項目>次の項目</h2>
<p>詳細については<a href=https://github.com/kubernetes/dashboard>Kubernetes Dashboardプロジェクトページ</a>をご覧ください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5a233e14205d77fe1294917d2da6f876>9.2 - 複数のクラスターへのアクセスを設定する</h1>
<p>ここでは、設定ファイルを使って複数のクラスターにアクセスする方法を紹介します。クラスター、ユーザー、コンテキストの情報を一つ以上の設定ファイルにまとめることで、<code>kubectl config use-context</code>のコマンドを使ってクラスターを素早く切り替えることができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> クラスターへのアクセスを設定するファイルを、<em>kubeconfig</em> ファイルと呼ぶことがあります。これは設定ファイルの一般的な呼び方です。<code>kubeconfig</code>という名前のファイルが存在するわけではありません。
</div>
<h2 id=始める前に>始める前に</h2>
<p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
<p><a class=glossary-tooltip title="A command line tool for communicating with a Kubernetes API server." data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>がインストールされているか確認するため、<code>kubectl version --client</code>を実行してください。kubectlのバージョンは、クラスターのAPIサーバーの<a href=/ja/docs/setup/release/version-skew-policy/#kubectl>1つのマイナーバージョン内</a>である必要があります。</p>
<h2 id=クラスター-ユーザー-コンテキストを設定する>クラスター、ユーザー、コンテキストを設定する</h2>
<p>例として、開発用のクラスターが一つ、実験用のクラスターが一つ、計二つのクラスターが存在する場合を考えます。<code>development</code>と呼ばれる開発用のクラスター内では、フロントエンドの開発者は<code>frontend</code>というnamespace内で、ストレージの開発者は<code>storage</code>というnamespace内で作業をします。<code>scratch</code>と呼ばれる実験用のクラスター内では、開発者はデフォルトのnamespaceで作業をするか、状況に応じて追加のnamespaceを作成します。開発用のクラスターは証明書を通しての認証を必要とします。実験用のクラスターはユーザーネームとパスワードを通しての認証を必要とします。</p>
<p><code>config-exercise</code>というディレクトリを作成してください。<code>config-exercise</code>ディレクトリ内に、以下を含む<code>config-demo</code>というファイルを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apiVersion: v1
kind: Config
preferences: <span style=color:#666>{}</span>

clusters:
- cluster:
  name: development
- cluster:
  name: scratch

users:
- name: developer
- name: experimenter

contexts:
- context:
  name: dev-frontend
- context:
  name: dev-storage
- context:
  name: exp-scratch
</code></pre></div><p>設定ファイルには、クラスター、ユーザー、コンテキストの情報が含まれています。上記の<code>config-demo</code>設定ファイルには、二つのクラスター、二人のユーザー、三つのコンテキストの情報が含まれています。</p>
<p><code>config-exercise</code>ディレクトリに移動してください。クラスター情報を設定ファイルに追加するために、以下のコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-cluster development --server<span style=color:#666>=</span>https://1.2.3.4 --certificate-authority<span style=color:#666>=</span>fake-ca-file
kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-cluster scratch --server<span style=color:#666>=</span>https://5.6.7.8 --insecure-skip-tls-verify
</code></pre></div><p>ユーザー情報を設定ファイルに追加してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-credentials developer --client-certificate<span style=color:#666>=</span>fake-cert-file --client-key<span style=color:#666>=</span>fake-key-seefile
kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-credentials experimenter --username<span style=color:#666>=</span>exp --password<span style=color:#666>=</span>some-password
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>kubectl --kubeconfig=config-demo config unset users.&lt;name></code>を実行すると、ユーザーを削除することができます。
<code>kubectl --kubeconfig=config-demo config unset clusters.&lt;name></code>を実行すると、クラスターを除去することができます。
<code>kubectl --kubeconfig=config-demo config unset contexts.&lt;name></code>を実行すると、コンテキスト情報を除去することができます。
</div>
<p>コンテキスト情報を設定ファイルに追加してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context dev-frontend --cluster<span style=color:#666>=</span>development --namespace<span style=color:#666>=</span>frontend --user<span style=color:#666>=</span>developer
kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context dev-storage --cluster<span style=color:#666>=</span>development --namespace<span style=color:#666>=</span>storage --user<span style=color:#666>=</span>developer
kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context exp-scratch --cluster<span style=color:#666>=</span>scratch --namespace<span style=color:#666>=</span>default --user<span style=color:#666>=</span>experimenter
</code></pre></div><p>追加した情報を確認するために、<code>config-demo</code>ファイルを開いてください。<code>config-demo</code>ファイルを開く代わりに、<code>config view</code>のコマンドを使うこともできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view
</code></pre></div><p>出力には、二つのクラスター、二人のユーザー、三つのコンテキストが表示されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apiVersion: v1
clusters:
- cluster:
    certificate-authority: fake-ca-file
    server: https://1.2.3.4
  name: development
- cluster:
    insecure-skip-tls-verify: <span style=color:#a2f>true</span>
    server: https://5.6.7.8
  name: scratch
contexts:
- context:
    cluster: development
    namespace: frontend
    user: developer
  name: dev-frontend
- context:
    cluster: development
    namespace: storage
    user: developer
  name: dev-storage
- context:
    cluster: scratch
    namespace: default
    user: experimenter
  name: exp-scratch
current-context: <span style=color:#b44>&#34;&#34;</span>
kind: Config
preferences: <span style=color:#666>{}</span>
users:
- name: developer
  user:
    client-certificate: fake-cert-file
    client-key: fake-key-file
- name: experimenter
  user:
    password: some-password
    username: exp
</code></pre></div><p>上記の<code>fake-ca-file</code>、<code>fake-cert-file</code>、<code>fake-key-file</code>は、証明書ファイルの実際のパスのプレースホルダーです。環境内にある証明書ファイルの実際のパスに変更してください。</p>
<p>証明書ファイルのパスの代わりにbase64にエンコードされたデータを使用したい場合は、キーに<code>-data</code>の接尾辞を加えてください。例えば、<code>certificate-authority-data</code>、<code>client-certificate-data</code>、<code>client-key-data</code>とできます。</p>
<p>それぞれのコンテキストは、クラスター、ユーザー、namespaceの三つ組からなっています。例えば、<code>dev-frontend</code>は、<code>developer</code>ユーザーの認証情報を使って<code>development</code>クラスターの<code>frontend</code>namespaceへのアクセスを意味しています。</p>
<p>現在のコンテキストを設定してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context dev-frontend
</code></pre></div><p>これ以降実行される<code>kubectl</code>コマンドは、<code>dev-frontend</code>に設定されたクラスターとnamespaceに適用されます。また、<code>dev-frontend</code>に設定されたユーザーの認証情報を使用します。</p>
<p>現在のコンテキストの設定情報のみを確認するには、<code>--minify</code>フラグを使用してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</code></pre></div><p>出力には、<code>dev-frontend</code>の設定情報が表示されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apiVersion: v1
clusters:
- cluster:
    certificate-authority: fake-ca-file
    server: https://1.2.3.4
  name: development
contexts:
- context:
    cluster: development
    namespace: frontend
    user: developer
  name: dev-frontend
current-context: dev-frontend
kind: Config
preferences: <span style=color:#666>{}</span>
users:
- name: developer
  user:
    client-certificate: fake-cert-file
    client-key: fake-key-file
</code></pre></div><p>今度は、実験用のクラスター内でしばらく作業する場合を考えます。</p>
<p>現在のコンテキストを<code>exp-scratch</code>に切り替えてください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context exp-scratch
</code></pre></div><p>これ以降実行される<code>kubectl</code>コマンドは、<code>scratch</code>クラスター内のデフォルトnamespaceに適用されます。また、<code>exp-scratch</code>に設定されたユーザーの認証情報を使用します。</p>
<p>新しく切り替えた<code>exp-scratch</code>の設定を確認してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</code></pre></div><p>最後に、<code>development</code>クラスター内の<code>storage</code>namespaceでしばらく作業する場合を考えます。</p>
<p>現在のコンテキストを<code>dev-storage</code>に切り替えてください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context dev-storage
</code></pre></div><p>新しく切り替えた<code>dev-storage</code>の設定を確認してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</code></pre></div><h2 id=二つ目の設定ファイルを作成する>二つ目の設定ファイルを作成する</h2>
<p><code>config-exercise</code>ディレクトリ内に、以下を含む<code>config-demo-2</code>というファイルを作成してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>apiVersion: v1
kind: Config
preferences: <span style=color:#666>{}</span>

contexts:
- context:
    cluster: development
    namespace: ramp
    user: developer
  name: dev-ramp-up
</code></pre></div><p>上記の設定ファイルは、<code>dev-ramp-up</code>というコンテキストを表します。</p>
<h2 id=set-the-kubeconfig-environment-variable>KUBECONFIG環境変数を設定する</h2>
<p><code>KUBECONFIG</code>という環境変数が存在するかを確認してください。もし存在する場合は、後で復元できるようにバックアップしてください。例えば:</p>
<h3 id=linux>Linux</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG_SAVED</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>
</code></pre></div><h3 id=windows-powershell>Windows PowerShell</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>$Env</span>:KUBECONFIG_SAVED<span style=color:#666>=</span><span style=color:#b8860b>$ENV</span>:KUBECONFIG
</code></pre></div><p><code>KUBECONFIG</code>環境変数は、設定ファイルのパスのリストです。リスト内のパスはLinuxとMacではコロンで区切られ、Windowsではセミコロンで区切られます。<code>KUBECONFIG</code>環境変数が存在する場合は、リスト内の設定ファイルの内容を確認してください。</p>
<p>一時的に<code>KUBECONFIG</code>環境変数に以下の二つのパスを追加してください。例えば:<br></p>
<h3 id=linux-1>Linux</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>:config-demo:config-demo-2
</code></pre></div><h3 id=windows-powershell-1>Windows PowerShell</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>$Env</span>:KUBECONFIG<span style=color:#666>=(</span><span style=color:#b44>&#34;config-demo;config-demo-2&#34;</span><span style=color:#666>)</span>
</code></pre></div><p><code>config-exercise</code>ディレクトリ内から、以下のコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div><p>出力には、<code>KUBECONFIG</code>環境変数に含まれる全てのファイルの情報がまとめて表示されます。<code>config-demo-2</code>ファイルに設定された<code>dev-ramp-up</code>の情報と、<code>config-demo</code>に設定された三つのコンテキストの情報がまとめてあることに注目してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>contexts:
- context:
    cluster: development
    namespace: frontend
    user: developer
  name: dev-frontend
- context:
    cluster: development
    namespace: ramp
    user: developer
  name: dev-ramp-up
- context:
    cluster: development
    namespace: storage
    user: developer
  name: dev-storage
- context:
    cluster: scratch
    namespace: default
    user: experimenter
  name: exp-scratch
</code></pre></div><p>kubeconfigファイルに関するさらなる情報を参照するには、<a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfigファイルを使ってクラスターへのアクセスを管理する</a>を参照してください。</p>
<h2 id=home-kubeディレクトリの内容を確認する>$HOME/.kubeディレクトリの内容を確認する</h2>
<p>既にクラスターを所持していて、<code>kubectl</code>を使ってクラスターを操作できる場合は、<code>$HOME/.kube</code>ディレクトリ内に<code>config</code>というファイルが存在する可能性が高いです。</p>
<p><code>$HOME/.kube</code>に移動して、そこに存在するファイルを確認してください。<code>config</code>という設定ファイルが存在するはずです。他の設定ファイルも存在する可能性があります。全てのファイルの中身を確認してください。</p>
<h2 id=home-kube-configをkubeconfig環境変数に追加する>$HOME/.kube/configをKUBECONFIG環境変数に追加する</h2>
<p>もし<code>$HOME/.kube/config</code>ファイルが存在していて、既に<code>KUBECONFIG</code>環境変数に追加されていない場合は、<code>KUBECONFIG</code>環境変数に追加してください。例えば:</p>
<h3 id=linux-2>Linux</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>:<span style=color:#b8860b>$HOME</span>/.kube/config
</code></pre></div><h3 id=windows-powershell-2>Windows Powershell</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>$Env</span>:KUBECONFIG<span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$Env</span><span style=color:#b44>:KUBECONFIG;</span><span style=color:#b8860b>$HOME</span><span style=color:#b44>/.kube/config&#34;</span>
</code></pre></div><p><code>KUBECONFIG</code>環境変数内のファイルからまとめられた設定情報を確認してください。<code>config-exercise</code>ディレクトリ内から、以下のコマンドを実行してください:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl config view
</code></pre></div><h2 id=クリーンアップ>クリーンアップ</h2>
<p><code>KUBECONFIG</code>環境変数を元に戻してください。例えば:</p>
<h3 id=linux-3>Linux:</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG_SAVED</span>
</code></pre></div><h3 id=windows-powershell-3>Windows PowerShell</h3>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#b8860b>$Env</span>:KUBECONFIG<span style=color:#666>=</span><span style=color:#b8860b>$ENV</span>:KUBECONFIG_SAVED
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfigファイルを使ってクラスターへのアクセスを管理する</a></li>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands#config>kubectl config</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-312f29f850826b74618634cd877aa065>9.3 - Serviceを利用したクラスター内のアプリケーションへのアクセス</h1>
<p>ここでは、クラスター内で稼働しているアプリケーションに外部からアクセスするために、KubernetesのServiceオブジェクトを作成する方法を紹介します。
例として、2つのインスタンスから成るアプリケーションへのロードバランシングを扱います。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=目標>目標</h2>
<ul>
<li>2つのHello Worldアプリケーションを稼働させる。</li>
<li>Nodeのポートを公開するServiceオブジェクトを作成する。</li>
<li>稼働しているアプリケーションにアクセスするためにServiceオブジェクトを使用する。</li>
</ul>
<h2 id=2つのpodから成るアプリケーションのserviceを作成>2つのPodから成るアプリケーションのServiceを作成</h2>
<p>アプリケーションDeploymentの設定ファイルは以下の通りです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/access/hello-application.yaml download=service/access/hello-application.yaml><code>service/access/hello-application.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-hello-application-yaml')" title="Copy service/access/hello-application.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-access-hello-application-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-world<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-world<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>クラスタでHello Worldアプリケーションを稼働させます:
上記のファイルを使用し、アプリケーションのDeploymentを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/access/hello-application.yaml
</code></pre></div><p>このコマンドは<a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>オブジェクトとそれに紐付く<a class=glossary-tooltip title="ReplicaSet ensures that a specified number of Pod replicas are running at one time" data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSet>ReplicaSet</a>オブジェクトを作成します。ReplicaSetは、Hello Worldアプリケーションが稼働している2つの<a class=glossary-tooltip title="一番小さく一番シンプルな Kubernetes のオブジェクト。Pod とはクラスターで動作しているいくつかのコンテナのまとまりです。" data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>から構成されます。</p>
</li>
<li>
<p>Deploymentの情報を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get deployments hello-world
kubectl describe deployments hello-world
</code></pre></div></li>
<li>
<p>ReplicaSetオブジェクトの情報を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get replicasets
kubectl describe replicasets
</code></pre></div></li>
<li>
<p>Deploymentを公開するServiceオブジェクトを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment hello-world --type<span style=color:#666>=</span>NodePort --name<span style=color:#666>=</span>example-service
</code></pre></div></li>
<li>
<p>Serviceに関する情報を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe services example-service
</code></pre></div><p>出力例は以下の通りです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Name:                   example-service
Namespace:              default
Labels:                 <span style=color:#b8860b>run</span><span style=color:#666>=</span>load-balancer-example
Annotations:            &lt;none&gt;
Selector:               <span style=color:#b8860b>run</span><span style=color:#666>=</span>load-balancer-example
Type:                   NodePort
IP:                     10.32.0.16
Port:                   &lt;unset&gt; 8080/TCP
TargetPort:             8080/TCP
NodePort:               &lt;unset&gt; 31496/TCP
Endpoints:              10.200.1.4:8080,10.200.2.5:8080
Session Affinity:       None
Events:                 &lt;none&gt;
</code></pre></div><p>NodePortの値を記録しておきます。上記の例では、31496です。</p>
</li>
<li>
<p>Hello Worldアプリーションが稼働しているPodを表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b44>&#34;run=load-balancer-example&#34;</span> --output<span style=color:#666>=</span>wide
</code></pre></div><p>出力例は以下の通りです:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                           READY   STATUS    ...  IP           NODE
hello-world-2895499144-bsbk5   1/1     Running   ...  10.200.1.4   worker1
hello-world-2895499144-m1pwt   1/1     Running   ...  10.200.2.5   worker2
</code></pre></div></li>
<li>
<p>Hello World podが稼働するNodeのうち、いずれか1つのパブリックIPアドレスを確認します。
確認方法は、使用している環境により異なります。
例として、Minikubeの場合は<code>kubectl cluster-info</code>、Google Compute Engineの場合は<code>gcloud compute instances list</code>によって確認できます。</p>
</li>
<li>
<p>選択したノード上で、NodePortの値でのTCP通信を許可するファイヤーウォールを作成します。
NodePortの値が31568の場合、31568番のポートを利用したTCP通信を許可するファイヤーウォールを作成します。
クラウドプロバイダーによって設定方法が異なります。</p>
</li>
<li>
<p>Hello World applicationにアクセスするために、Nodeのアドレスとポート番号を使用します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl http://&lt;public-node-ip&gt;:&lt;node-port&gt;
</code></pre></div><p>ここで <code>&lt;public-node-ip></code> はNodeのパブリックIPアドレス、
<code>&lt;node-port></code> はNodePort Serviceのポート番号の値を表しています。
リクエストが成功すると、下記のメッセージが表示されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Hello Kubernetes!
</code></pre></div></li>
</ol>
<h2 id=service-configuration-fileの利用>service configuration fileの利用</h2>
<p><code>kubectl expose</code>コマンドの代わりに、
<a href=/ja/docs/concepts/services-networking/service/>service configuration file</a>
を使用してServiceを作成することもできます。</p>
<h2 id=クリーンアップ>クリーンアップ</h2>
<p>Serviceを削除するには、以下のコマンドを実行します:</p>
<pre><code>kubectl delete services example-service
</code></pre>
<p>Hello Worldアプリケーションが稼働しているDeployment、ReplicaSet、Podを削除するには、以下のコマンドを実行します:</p>
<pre><code>kubectl delete deployment hello-world
</code></pre>
<h2 id=次の項目>次の項目</h2>
<p>詳細は
<a href=/docs/concepts/services-networking/connect-applications-service/>serviceを利用してアプリケーションと接続する</a>
を確認してください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f3dac629bea950fc026d920306f09fb4>9.4 - Serviceを使用してフロントエンドをバックエンドに接続する</h1>
<p>このタスクでは、フロントエンドとバックエンドのマイクロサービスを作成する方法を示します。
バックエンドのマイクロサービスは挨拶です。
フロントエンドとバックエンドは、Kubernetes <a class=glossary-tooltip title=Podの集合で実行されているアプリケーションをネットワークサービスとして公開する方法。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>オブジェクトを使用して接続されます。</p>
<h2 id=目標>目標</h2>
<ul>
<li><a class=glossary-tooltip title=クラスター上の複製されたアプリケーションを管理します。 data-toggle=tooltip data-placement=top href=/ja/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>オブジェクトを使用してマイクロサービスを作成および実行します。</li>
<li>フロントエンドを経由してトラフィックをバックエンドにルーティングします。</li>
<li>Serviceオブジェクトを使用して、フロントエンドアプリケーションをバックエンドアプリケーションに接続します。</li>
</ul>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>このタスクでは<a href=/docs/tasks/access-application-cluster/create-external-load-balancer/>Serviceで外部ロードバランサー</a>を使用しますが、外部ロードバランサーの使用がサポートされている環境である必要があります。
ご使用の環境がこれをサポートしていない場合は、代わりにタイプ<a href=/ja/docs/concepts/services-networking/service/#nodeport>NodePort</a>のServiceを使用できます。</p>
<h2 id=deploymentを使用したバックエンドの作成>Deploymentを使用したバックエンドの作成</h2>
<p>バックエンドは、単純な挨拶マイクロサービスです。
バックエンドのDeploymentの構成ファイルは次のとおりです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/access/hello.yaml download=service/access/hello.yaml><code>service/access/hello.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-hello-yaml')" title="Copy service/access/hello.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-access-hello-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>7</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;gcr.io/google-samples/hello-go-gke:1.0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>バックエンドのDeploymentを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/access/hello.yaml
</code></pre></div><p>バックエンドのDeploymentに関する情報を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe deployment hello
</code></pre></div><p>出力はこのようになります:</p>
<pre><code>Name:                           hello
Namespace:                      default
CreationTimestamp:              Mon, 24 Oct 2016 14:21:02 -0700
Labels:                         app=hello
                                tier=backend
                                track=stable
Annotations:                    deployment.kubernetes.io/revision=1
Selector:                       app=hello,tier=backend,track=stable
Replicas:                       7 desired | 7 updated | 7 total | 7 available | 0 unavailable
StrategyType:                   RollingUpdate
MinReadySeconds:                0
RollingUpdateStrategy:          1 max unavailable, 1 max surge
Pod Template:
  Labels:       app=hello
                tier=backend
                track=stable
  Containers:
   hello:
    Image:              &quot;gcr.io/google-samples/hello-go-gke:1.0&quot;
    Port:               80/TCP
    Environment:        &lt;none&gt;
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
OldReplicaSets:                 &lt;none&gt;
NewReplicaSet:                  hello-3621623197 (7/7 replicas created)
Events:
...
</code></pre><h2 id=バックエンドserviceオブジェクトの作成>バックエンドServiceオブジェクトの作成</h2>
<p>フロントエンドをバックエンドに接続する鍵は、バックエンドServiceです。
Serviceは、バックエンドマイクロサービスに常に到達できるように、永続的なIPアドレスとDNS名のエントリを作成します。
Serviceは<a class=glossary-tooltip title=セレクターを利用すると、ユーザーはラベルに基づいてリソースのリストをフィルタリングできます。 data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=セレクター>セレクター</a>を使用して、トラフィックをルーティングするPodを見つけます。</p>
<p>まず、Service構成ファイルを調べます:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/access/hello-service.yaml download=service/access/hello-service.yaml><code>service/access/hello-service.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-hello-service-yaml')" title="Copy service/access/hello-service.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-access-hello-service-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルで、Serviceが<code>app：hello</code>および<code>tier：backend</code>というラベルを持つPodにトラフィックをルーティングしていることがわかります。</p>
<p><code>hello</code> Serviceを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/access/hello-service.yaml
</code></pre></div><p>この時点で、バックエンドのDeploymentが実行され、そちらにトラフィックをルーティングできるServiceがあります。</p>
<h2 id=フロントエンドの作成>フロントエンドの作成</h2>
<p>バックエンドができたので、バックエンドに接続するフロントエンドを作成できます。
フロントエンドは、バックエンドServiceに指定されたDNS名を使用して、バックエンドワーカーPodに接続します。
DNS名は<code>hello</code>です。これは、前のサービス設定ファイルの<code>name</code>フィールドの値です。</p>
<p>フロントエンドDeploymentのPodは、helloバックエンドServiceを見つけるように構成されたnginxイメージを実行します。
これはnginx設定ファイルです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/access/frontend.conf download=service/access/frontend.conf><code>service/access/frontend.conf</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-frontend-conf')" title="Copy service/access/frontend.conf to clipboard">
</img>
</div>
<div class=includecode id=service-access-frontend-conf>
<pre tabindex=0><code class=language-conf data-lang=conf>upstream hello {
    server hello;
}

server {
    listen 80;

    location / {
        proxy_pass http://hello;
    }
}
</code></pre>
</div>
</div>
<p>バックエンドと同様に、フロントエンドにはDeploymentとServiceがあります。
Serviceの設定には<code>type：LoadBalancer</code>があります。これは、Serviceがクラウドプロバイダーのデフォルトのロードバランサーを使用することを意味します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/access/frontend.yaml download=service/access/frontend.yaml><code>service/access/frontend.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-access-frontend-yaml')" title="Copy service/access/frontend.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-access-frontend-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;TCP&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;gcr.io/google-samples/hello-frontend:1.0&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>preStop</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/usr/sbin/nginx&#34;</span>,<span style=color:#b44>&#34;-s&#34;</span>,<span style=color:#b44>&#34;quit&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>フロントエンドのDeploymentとServiceを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/access/frontend.yaml
</code></pre></div><p>出力結果から両方のリソースが作成されたことを確認します:</p>
<pre><code>deployment.apps/frontend created
service/frontend created
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> nginxの構成は、<a href=/examples/service/access/Dockerfile>コンテナイメージ</a>に焼き付けられます。
これを行うためのより良い方法は、<a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>を使用して、構成をより簡単に変更できるようにすることです。
</div>
<h2 id=フロントエンドserviceと対話>フロントエンドServiceと対話</h2>
<p>LoadBalancerタイプのServiceを作成したら、このコマンドを使用して外部IPを見つけることができます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service frontend --watch
</code></pre></div><p>これにより<code>frontend</code> Serviceの設定が表示され、変更が監視されます。
最初、外部IPは<code>&lt;pending></code>としてリストされます:</p>
<pre><code>NAME       TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)  AGE
frontend   LoadBalancer   10.51.252.116   &lt;pending&gt;     80/TCP   10s
</code></pre><p>ただし、外部IPがプロビジョニングされるとすぐに、<code>EXTERNAL-IP</code>という見出しの下に新しいIPが含まれるように構成が更新されます:</p>
<pre><code>NAME       TYPE           CLUSTER-IP      EXTERNAL-IP        PORT(S)  AGE
frontend   LoadBalancer   10.51.252.116   XXX.XXX.XXX.XXX    80/TCP   1m
</code></pre><p>このIPを使用して、クラスターの外部から<code>frontend</code> Serviceとやり取りできるようになりました。</p>
<h2 id=フロントエンドを介するトラフィック送信>フロントエンドを介するトラフィック送信</h2>
<p>フロントエンドとバックエンドが接続されました。
フロントエンドServiceの外部IPに対してcurlコマンドを使用して、エンドポイントにアクセスできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl http://<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>EXTERNAL_IP</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#080;font-style:italic># これを前に見たEXTERNAL-IPに置き換えます</span>
</code></pre></div><p>出力には、バックエンドによって生成されたメッセージが表示されます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{<span style=color:green;font-weight:700>&#34;message&#34;</span>:<span style=color:#b44>&#34;Hello&#34;</span>}
</code></pre></div><h2 id=クリーンアップ>クリーンアップ</h2>
<p>Serviceを削除するには、このコマンドを入力してください：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete services frontend hello
</code></pre></div><p>バックエンドとフロントエンドアプリケーションを実行しているDeploymentとReplicaSetとPodを削除するために、このコマンドを入力してください：</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl delete deployment frontend hello
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/services-networking/service/>Service</a>の詳細</li>
<li><a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>の詳細</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-1839d8468a083839ed1cc8d18fe1142e>9.5 - Minikube上でNGINX Ingressコントローラーを使用してIngressをセットアップする</h1>
<p><a href=/ja/docs/concepts/services-networking/ingress/>Ingress</a>とは、クラスター内のServiceに外部からのアクセスを許可するルールを定義するAPIオブジェクトです。<a href=/ja/docs/concepts/services-networking/ingress-controllers/>Ingressコントローラー</a>はIngress内に設定されたルールを満たすように動作します。</p>
<p>このページでは、簡単なIngressをセットアップして、HTTPのURIに応じてwebまたはweb2というServiceにリクエストをルーティングする方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=minikubeクラスターを作成する>Minikubeクラスターを作成する</h2>
<ol>
<li>
<p><strong>Launch Terminal</strong>をクリックします。</p>
<script defer src=https://katacoda.com/embed.js></script>
<button class=button onclick=window.katacoda.init()>Launch Terminal</button>
</li>
<li>
<p>(オプション) Minikubeをローカル環境にインストールした場合は、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube start
</code></pre></div></li>
</ol>
<h2 id=ingressコントローラーを有効化する>Ingressコントローラーを有効化する</h2>
<ol>
<li>
<p>NGINX Ingressコントローラーを有効にするために、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube addons <span style=color:#a2f>enable</span> ingress
</code></pre></div></li>
<li>
<p>NGINX Ingressコントローラーが起動したことを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -n kube-system
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このコマンドの実行には数分かかる場合があります。
</div>
<p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME                                        READY     STATUS    RESTARTS   AGE
default-http-backend-59868b7dd6-xb8tq       1/1       Running   <span style=color:#666>0</span>          1m
kube-addon-manager-minikube                 1/1       Running   <span style=color:#666>0</span>          3m
kube-dns-6dcb57bcc8-n4xd4                   3/3       Running   <span style=color:#666>0</span>          2m
kubernetes-dashboard-5498ccf677-b8p5h       1/1       Running   <span style=color:#666>0</span>          2m
nginx-ingress-controller-5984b97644-rnkrg   1/1       Running   <span style=color:#666>0</span>          1m
storage-provisioner                         1/1       Running   <span style=color:#666>0</span>          2m
</code></pre></div></li>
</ol>
<h2 id=hello-worldアプリをデプロイする>Hello Worldアプリをデプロイする</h2>
<ol>
<li>
<p>次のコマンドを実行して、Deploymentを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment web --image<span style=color:#666>=</span>gcr.io/google-samples/hello-app:1.0
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps/web created
</code></pre></div></li>
<li>
<p>Deploymentを公開します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment web --type<span style=color:#666>=</span>NodePort --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>service/web exposed
</code></pre></div></li>
<li>
<p>Serviceが作成され、NodePort上で利用できるようになったことを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service web
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME      TYPE       CLUSTER-IP       EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>          AGE
web       NodePort   10.104.133.249   &lt;none&gt;        8080:31637/TCP   12m
</code></pre></div></li>
<li>
<p>NodePort経由でServiceを訪問します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube service web --url
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>http://172.17.0.15:31637
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Katacoda環境の場合のみ: 上部のterminalパネルでプラスのアイコンをクリックして、<strong>Select port to view on Host 1</strong>(Host 1を表示するポートを選択)をクリックします。NodePort(上の例では<code>31637</code>)を入力して、<strong>Display Port</strong>(ポートを表示)をクリックしてください。
</div>
<p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre></div><p>これで、MinikubeのIPアドレスとNodePort経由で、サンプルアプリにアクセスできるようになりました。次のステップでは、Ingressリソースを使用してアプリにアクセスできるように設定します。</p>
</li>
</ol>
<h2 id=ingressリソースを作成する>Ingressリソースを作成する</h2>
<p>以下に示すファイルは、hello-world.info経由で送られたトラフィックをServiceに送信するIngressリソースです。</p>
<ol>
<li>
<p>以下の内容で<code>example-ingress.yaml</code>を作成します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/example-ingress.yaml download=service/networking/example-ingress.yaml><code>service/networking/example-ingress.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-example-ingress-yaml')" title="Copy service/networking/example-ingress.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-example-ingress-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-ingress<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/$1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>hello-world.info<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span></code></pre></div>
</div>
</div>
</li>
<li>
<p>次のコマンドを実行して、Ingressリソースを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://kubernetes.io/examples/service/networking/example-ingress.yaml
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ingress.networking.k8s.io/example-ingress created
</code></pre></div></li>
<li>
<p>次のコマンドで、IPアドレスが設定されていることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get ingress
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> このコマンドの実行には数分かかる場合があります。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME              CLASS    HOSTS              ADDRESS        PORTS   AGE
example-ingress   &lt;none&gt;   hello-world.info   172.17.0.15    <span style=color:#666>80</span>      38s
</code></pre></div></li>
<li>
<p>次の行を<code>/etc/hosts</code>ファイルの最後に書きます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Minikubeをローカル環境で実行している場合、<code>minikube ip</code>コマンドを使用すると外部のIPが取得できます。Ingressのリスト内に表示されるIPアドレスは、内部のIPになるはずです。
</div>
<pre><code>172.17.0.15 hello-world.info
</code></pre><p>この設定により、リクエストがhello-world.infoからMinikubeに送信されるようになります。</p>
</li>
<li>
<p>Ingressコントローラーがトラフィックを制御していることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl hello-world.info
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Minikubeをローカル環境で実行している場合、ブラウザからhello-world.infoにアクセスできます。
</div>
</li>
</ol>
<h2 id=2番目のdeploymentを作成する>2番目のDeploymentを作成する</h2>
<ol>
<li>
<p>次のコマンドを実行して、v2のDeploymentを作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment web2 --image<span style=color:#666>=</span>gcr.io/google-samples/hello-app:2.0
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>deployment.apps/web2 created
</code></pre></div></li>
<li>
<p>Deploymentを公開します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment web2 --port<span style=color:#666>=</span><span style=color:#666>8080</span> --type<span style=color:#666>=</span>NodePort
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>service/web2 exposed
</code></pre></div></li>
</ol>
<h2 id=ingressを編集する>Ingressを編集する</h2>
<ol>
<li>
<p>既存の<code>example-ingress.yaml</code>を編集して、以下の行を追加します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/v2<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pathType</span>:<span style=color:#bbb> </span>Prefix<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web2<span style=color:#bbb>
</span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb>
</span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>number</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></code></pre></div></li>
<li>
<p>次のコマンドで変更を適用します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f example-ingress.yaml
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ingress.networking/example-ingress configured
</code></pre></div></li>
</ol>
<h2 id=ingressを試す>Ingressを試す</h2>
<ol>
<li>
<p>Hello Worldアプリの1番目のバージョンにアクセスします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl hello-world.info
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Hello, world!
Version: 1.0.0
Hostname: web-55b8c6998d-8k564
</code></pre></div></li>
<li>
<p>Hello Worldアプリの2番目のバージョンにアクセスします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl hello-world.info/v2
</code></pre></div><p>出力は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>Hello, world!
Version: 2.0.0
Hostname: web2-75cd47646f-t8cjk
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> Minikubeをローカル環境で実行している場合、ブラウザからhello-world.infoおよびhello-world.info/v2にアクセスできます。
</div>
</li>
</ol>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/ja/docs/concepts/services-networking/ingress/>Ingress</a>についてさらに学ぶ。</li>
<li><a href=/ja/docs/concepts/services-networking/ingress-controllers/>Ingressコントローラー</a>についてさらに学ぶ。</li>
<li><a href=/ja/docs/concepts/services-networking/service/>Service</a>についてさらに学ぶ。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-48e8f306f919c5b81265e265a2b76ab4>9.6 - クラスターで実行されているすべてのコンテナイメージを一覧表示する</h1>
<p>このページでは、kubectlを使用して、クラスターで実行されているPodのすべてのコンテナイメージを一覧表示する方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<p>この演習では、kubectlを使用してクラスターで実行されているすべてのPodを取得し、出力をフォーマットしてそれぞれのコンテナの一覧を取得します。</p>
<h2 id=list-all-container-images-in-all-namespaces>すべての名前空間のコンテナイメージを一覧表示する</h2>
<ul>
<li><code>kubectl get pods --all-namespaces</code>を使用して、すべての名前空間のPodを取得します</li>
<li><code>-o jsonpath={.. image}</code>を使用して、コンテナイメージ名のリストのみが含まれるように出力をフォーマットします。これは、返されたjsonの<code>image</code>フィールドを再帰的に解析します。
<ul>
<li>jsonpathの使い方については、<a href=/docs/reference/kubectl/jsonpath/>jsonpathリファレンス</a>を参照してください。</li>
</ul>
</li>
<li><code>tr</code>、<code>sort</code>、<code>uniq</code>などの標準ツールを使用して出力をフォーマットします。
<ul>
<li><code>tr</code>を使用してスペースを改行に置換します。</li>
<li><code>sort</code>を使用して結果を並べ替えます。</li>
<li><code>uniq</code>を使用してイメージ数を集計します。</li>
</ul>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{..image}&#34;</span> |<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>tr -s <span style=color:#b44>&#39;[[:space:]]&#39;</span> <span style=color:#b44>&#39;\n&#39;</span> |<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>sort |<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>uniq -c
</code></pre></div><p>上記のコマンドは、返されるすべてのアイテムについて、<code>image</code>という名前のすべてのフィールドを再帰的に返します。</p>
<p>別の方法として、Pod内のimageフィールドへの絶対パスを使用することができます。これにより、フィールド名が繰り返されている場合でも正しいフィールドが取得されます。多くのフィールドは与えられたアイテム内で<code>name</code>と呼ばれます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span>
</code></pre></div><p>jsonpathは次のように解釈されます:</p>
<ul>
<li><code>.items[*]</code>: 各戻り値</li>
<li><code>.spec</code>: 仕様の取得</li>
<li><code>.containers[*]</code>: 各コンテナ</li>
<li><code>.image</code>: イメージの取得</li>
</ul>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 例えば<code>kubectl get pod nginx</code>のように名前を指定して単一のPodを取得する場合、アイテムのリストではなく単一のPodが返されるので、パスの<code>.items[*]</code>部分は省略してください。
</div>
<h2 id=list-container-images-by-pod>Podごとにコンテナイメージを一覧表示する</h2>
<p><code>range</code>を使用して要素を個別に繰り返し処理することにより、フォーマットをさらに制御できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{&#34;\n&#34;}{.metadata.name}{&#34;:\t&#34;}{range .spec.containers[*]}{.image}{&#34;, &#34;}{end}{end}&#39;</span> |<span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>sort
</code></pre></div><h2 id=list-container-images-filtering-by-pod-namespace>Podのラベルを使用してコンテナイメージ一覧をフィルタリングする</h2>
<p>特定のラベルに一致するPodのみを対象とするには、-lフラグを使用します。以下は、<code>app=nginx</code>に一致するラベルを持つPodのみに一致します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{..image}&#34;</span> -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</code></pre></div><h2 id=list-container-images-filtering-by-pod-namespace>Podの名前空間でコンテナイメージ一覧をフィルタリングする</h2>
<p>特定の名前空間のPodのみを対象とするには、namespaceフラグを使用します。以下は<code>kube-system</code>名前空間のPodのみに一致します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --namespace kube-system -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{..image}&#34;</span>
</code></pre></div><h2 id=list-container-images-using-a-go-template-instead-of-jsonpath>jsonpathの代わりにgo-templateを使用してコンテナイメージを一覧表示する</h2>
<p>jsonpathの代わりに、kubectlは<a href=https://golang.org/pkg/text/template/>go-templates</a>を使用した出力のフォーマットをサポートしています:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --all-namespaces -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#34;{{range .items}}{{range .spec.containers}}{{.image}} {{end}}{{end}}&#34;</span>
</code></pre></div>
<h2 id=次の項目>次の項目</h2>
<h3 id=参照>参照</h3>
<ul>
<li><a href=/docs/reference/kubectl/jsonpath/>jsonpath</a>参照ガイド</li>
<li><a href=https://golang.org/pkg/text/template/>Go template</a>参照ガイド</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-7c319a9981586e5fbcfa21b392720650>9.7 - 共有ボリュームを使用して同じPod内のコンテナ間で通信する</h1>
<p>このページでは、ボリュームを使用して、同じPodで実行されている2つのコンテナ間で通信する方法を示します。
コンテナ間で<a href=/ja/docs/tasks/configure-pod-container/share-process-namespace/>プロセス名前空間を共有する</a>ことにより、プロセスが通信できるようにする方法も参照してください。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=2つのコンテナを実行するpodの作成>2つのコンテナを実行するPodの作成</h2>
<p>この演習では、2つのコンテナを実行するPodを作成します。
2つのコンテナは、通信に使用できるボリュームを共有します。
これがPodの設定ファイルです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/pods/two-container-pod.yaml download=pods/two-container-pod.yaml><code>pods/two-container-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('pods-two-container-pod-yaml')" title="Copy pods/two-container-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=pods-two-container-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>two-containers<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>debian-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/pod-data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo Hello from the debian container &gt; /pod-data/index.html&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>設定ファイルで、Podに<code>shared-data</code>という名前のボリュームがあることがわかります。</p>
<p>設定ファイルにリストされている最初のコンテナは、nginxサーバーを実行します。
共有ボリュームのマウントパスは<code>/usr/share/nginx/html</code>です。
2番目のコンテナはdebianイメージをベースとしており、<code>/pod-data</code>のマウントパスを持っています。
2番目のコンテナは次のコマンドを実行してから終了します。</p>
<pre><code>echo Hello from the debian container &gt; /pod-data/index.html
</code></pre>
<p>2番目のコンテナがnginxサーバーのルートディレクトリに<code>index.html</code>ファイルを書き込むことに注意してください。</p>
<p>Podと2つのコンテナを作成します:</p>
<pre><code>kubectl apply -f https://k8s.io/examples/pods/two-container-pod.yaml
</code></pre>
<p>Podとコンテナに関する情報を表示します:</p>
<pre><code>kubectl get pod two-containers --output=yaml
</code></pre>
<p>こちらは出力の一部です:</p>
<pre><code>apiVersion: v1
kind: Pod
metadata:
  ...
  name: two-containers
  namespace: default
  ...
spec:
  ...
  containerStatuses:

  - containerID: docker://c1d8abd1 ...
    image: debian
    ...
    lastState:
      terminated:
        ...
    name: debian-container
    ...

  - containerID: docker://96c1ff2c5bb ...
    image: nginx
    ...
    name: nginx-container
    ...
    state:
      running:
    ...
</code></pre>
<p>debianコンテナが終了し、nginxコンテナがまだ実行されていることがわかります。</p>
<p>nginxコンテナへのシェルを取得します:</p>
<pre><code>kubectl exec -it two-containers -c nginx-container -- /bin/bash
</code></pre>
<p>シェルで、nginxが実行されていることを確認します:</p>
<pre><code>root@two-containers:/# apt-get update
root@two-containers:/# apt-get install curl procps
root@two-containers:/# ps aux
</code></pre>
<p>出力はこのようになります:</p>
<pre><code>USER       PID  ...  STAT START   TIME COMMAND
root         1  ...  Ss   21:12   0:00 nginx: master process nginx -g daemon off;
</code></pre>
<p>debianコンテナがnginxルートディレクトリに<code>index.html</code>ファイルを作成したことを思い出してください。
<code>curl</code>を使用して、GETリクエストをnginxサーバーに送信します:</p>
<pre><code>root@two-containers:/# curl localhost
</code></pre><p>出力は、nginxがdebianコンテナによって書かれたWebページを提供することを示しています:</p>
<pre><code>Hello from the debian container
</code></pre>
<h2 id=議論>議論</h2>
<p>Podが複数のコンテナを持つことができる主な理由は、プライマリアプリケーションを支援するヘルパーアプリケーションをサポートするためです。
ヘルパーアプリケーションの典型的な例は、データプラー、データプッシャー、およびプロキシです。
多くの場合、ヘルパーアプリケーションとプライマリアプリケーションは互いに通信する必要があります。
通常、これは、この演習に示すように共有ファイルシステムを介して、またはループバックネットワークインターフェイスであるlocalhostを介して行われます。
このパターンの例は、新しい更新のためにGitリポジトリをポーリングするヘルパープログラムを伴うWebサーバーです。</p>
<p>この演習のボリュームは、コンテナがポッドの寿命中に通信する方法を提供します。
Podを削除して再作成すると、共有ボリュームに保存されているデータはすべて失われます。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li>
<p><a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>複合コンテナのパターン</a>の詳細</p>
</li>
<li>
<p><a href=http://www.slideshare.net/Docker/slideshare-burns>モジュラーアーキテクチャ用の複合コンテナ</a>について学ぶ</p>
</li>
<li>
<p><a href=/ja/docs/tasks/configure-pod-container/configure-volume-storage/>ストレージにボリュームを使用するPodの構成</a>を参照</p>
</li>
<li>
<p><a href=/ja/docs/tasks/configure-pod-container/share-process-namespace/>Pod内のコンテナ間でプロセス名前空間を共有するPodの構成</a>を参照</p>
</li>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#volume-v1-core>Volume</a>を参照</p>
</li>
<li>
<p><a href=/docs/reference/generated/kubernetes-api/v1.22/#pod-v1-core>Pod</a>を参照</p>
</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f6a755efe831d24956501e4bcd49ff96>10 - 監視、ログ、デバッグ</h1>
<div class=lead>クラスターのトラブルシューティングや、コンテナ化したアプリケーションのデバッグのために、監視とログをセットアップします。</div>
</div>
<div class=td-content>
<h1 id=pg-06bb252f25983de12f635c806d180d30>10.1 - Initコンテナのデバッグ</h1>
<p>このページでは、Initコンテナの実行に関連する問題を調査する方法を説明します。以下のコマンドラインの例では、Podを<code>&lt;pod-name></code>、Initコンテナを<code>&lt;init-container-1></code>および<code>&lt;init-container-2></code>として参照しています。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<ul>
<li><a href=/ja/docs/concepts/workloads/pods/init-containers/>Initコンテナ</a>の基本を理解しておきましょう。</li>
<li><a href=/docs/tasks/configure-pod-container/configure-pod-initialization/#creating-a-pod-that-has-an-init-container/>Initコンテナを設定</a>しておきましょう。</li>
</ul>
<h2 id=initコンテナのステータスを確認する>Initコンテナのステータスを確認する</h2>
<p>Podのステータスを表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod &lt;pod-name&gt;
</code></pre></div><p>たとえば、<code>Init：1/2</code>というステータスは、2つのInitコンテナのうちの1つが正常に完了したことを示します。</p>
<pre><code>NAME         READY     STATUS     RESTARTS   AGE
&lt;pod-name&gt;   0/1       Init:1/2   0          7s
</code></pre><p>ステータス値とその意味の例については、<a href=#understanding-pod-status>Podのステータスを理解する</a>を参照してください。</p>
<h2 id=initコンテナの詳細を取得する>Initコンテナの詳細を取得する</h2>
<p>Initコンテナの実行に関する詳細情報を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pod &lt;pod-name&gt;
</code></pre></div><p>たとえば、2つのInitコンテナを持つPodでは、次のように表示されます:</p>
<pre><code>Init Containers:
  &lt;init-container-1&gt;:
    Container ID:    ...
    ...
    State:           Terminated
      Reason:        Completed
      Exit Code:     0
      Started:       ...
      Finished:      ...
    Ready:           True
    Restart Count:   0
    ...
  &lt;init-container-2&gt;:
    Container ID:    ...
    ...
    State:           Waiting
      Reason:        CrashLoopBackOff
    Last State:      Terminated
      Reason:        Error
      Exit Code:     1
      Started:       ...
      Finished:      ...
    Ready:           False
    Restart Count:   3
    ...
</code></pre><p>また、Pod Specの<code>status.initContainerStatuses</code>フィールドを読むことでプログラムでInitコンテナのステータスにアクセスすることもできます。:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod nginx --template <span style=color:#b44>&#39;{{.status.initContainerStatuses}}&#39;</span>
</code></pre></div><p>このコマンドは生のJSONで上記と同じ情報を返します。</p>
<h2 id=initコンテナのログにアクセスする>Initコンテナのログにアクセスする</h2>
<p>ログにアクセスするには、Initコンテナ名とPod名を渡します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs &lt;pod-name&gt; -c &lt;init-container-2&gt;
</code></pre></div><p>シェルスクリプトを実行するInitコンテナは、実行時にコマンドを出力します。たとえば、スクリプトの始めに<code>set -x</code>を実行することでBashで同じことができます。</p>
<h2 id=understanding-pod-status>Podのステータスを理解する</h2>
<p><code>Init：</code>で始まるPodステータスはInitコンテナの実行ステータスを要約します。以下の表は、Initコンテナのデバッグ中に表示される可能性のあるステータス値の例をいくつか示しています。</p>
<table>
<thead>
<tr>
<th>ステータス</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Init:N/M</code></td>
<td>Podは<code>M</code>個のInitコンテナを持ち、これまでに<code>N</code>個完了しました。</td>
</tr>
<tr>
<td><code>Init:Error</code></td>
<td>Initコンテナが実行に失敗しました。</td>
</tr>
<tr>
<td><code>Init:CrashLoopBackOff</code></td>
<td>Initコンテナが繰り返し失敗しました。</td>
</tr>
<tr>
<td><code>Pending</code></td>
<td>PodはまだInitコンテナの実行を開始していません。</td>
</tr>
<tr>
<td><code>PodInitializing</code> or <code>Running</code></td>
<td>PodはすでにInitコンテナの実行を終了しています。</td>
</tr>
</tbody>
</table>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-858517cd46a1b5a1fd2e650edd785cea>10.2 - PodとReplicationControllerのデバッグ</h1>
<p>このページでは、PodとReplicationControllerをデバッグする方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<ul>
<li><a href=/ja/docs/concepts/workloads/pods/pod/>Pod</a>と<a href=/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a>の基本を理解している必要があります。</li>
</ul>
<h2 id=podのデバッグ>Podのデバッグ</h2>
<p>Podのデバッグの最初のステップは、Podを調べることです。
次のコマンドで、Podの現在の状態と最近のイベントを確認して下さい。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe pods <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>POD_NAME</span><span style=color:#b68;font-weight:700>}</span>
</code></pre></div><p>Pod内のコンテナの状態を確認します。
コンテナはすべて<code>Running</code>状態ですか？最近再起動はしましたか？</p>
<p>Podの状態に応じてデバッグを続けます。</p>
<h3 id=podがpending状態にとどまっている>PodがPending状態にとどまっている</h3>
<p>Podが<code>Pending</code>状態でスタックしている場合、ノードにスケジュールできていないことを意味します。
一般的に、これは、何らかのタイプのリソースが不足しており、それによってスケジューリングを妨げられているためです。
上述の<code>kubectl describe...</code>コマンドの出力を確認してください。
Podをスケジュールできない理由に関するスケジューラーからのメッセージがあるはずです。
理由としては以下のようなものがあります。</p>
<h4 id=リソースが不十分>リソースが不十分</h4>
<p>クラスター内のCPUまたはメモリーの供給を使い果たした可能性があります。
この場合、いくつかのことを試すことができます。</p>
<ul>
<li>
<p>クラスターにノードを追加します。</p>
</li>
<li>
<p><a href=/docs/concepts/workloads/pods/#pod-termination>不要なPodを終了</a>して、
<code>Pending</code>状態のPodのための空きリソースを作ります。</p>
</li>
<li>
<p>Podがノードよりも大きくないことを確認します。
例えば、すべてのノードのキャパシティーが<code>cpu: 1</code>の場合、<code>cpu: 1.1</code>を要求するPodは決してスケジュールされません。</p>
<p><code>kubectl get nodes -o &lt;format></code>コマンドでノードのキャパシティーを確認できます。
必要な情報を抽出するコマンドラインの例を以下に示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes -o yaml | egrep <span style=color:#b44>&#39;\sname:|cpu:|memory:&#39;</span>
kubectl get nodes -o json | jq <span style=color:#b44>&#39;.items[] | {name: .metadata.name, cap: .status.capacity}&#39;</span>
</code></pre></div><p><a href=/docs/concepts/policy/resource-quotas/>リソースクォータ</a>機能では、
消費できるリソースの合計量を制限するように構成できます。
Namespaceと組み合わせて使用すると、1つのチームがすべてのリソースを占有することを防ぐことができます。</p>
</li>
</ul>
<h4 id=hostportの使用>hostPortの使用</h4>
<p>Podを<code>hostPort</code>にバインドすると、Podをスケジュールできる場所の数が制限されます。
ほとんどの場合、<code>hostPort</code>は不要です。Serviceオブジェクトを使用してPodを公開してください。
どうしても<code>hostPort</code>が必要な場合は、コンテナクラスター内のノードと同じ数のPodのみをスケジュールできます。</p>
<h3 id=podがwaiting状態にとどまっている>PodがWaiting状態にとどまっている</h3>
<p>Podが<code>Waiting</code>状態でスタックしている場合、Podはワーカーノードにスケジュールされていますが、そのマシンでは実行できない状態です。
この場合も、<code>kubectl describe ...</code>の情報が参考になるはずです。
Podが<code>Waiting</code>状態となる最も一般的な原因は、イメージをプルできないことです。
確認すべき事項が3つあります。</p>
<ul>
<li>イメージの名前が正しいことを確認して下さい。</li>
<li>イメージはリポジトリーにプッシュしましたか？</li>
<li>マシンで手動で<code>docker pull &lt;image></code>を実行し、イメージをプルできるかどうかを確認して下さい。</li>
</ul>
<h3 id=podがクラッシュする-あるいはunhealthy状態>Podがクラッシュする、あるいはUnhealthy状態</h3>
<p>Podがスケジュールされると、<a href=/docs/tasks/debug-application-cluster/debug-running-pod/>動作中のPodをデバッグする</a>に説明されている方法がデバッグに使用可能です。</p>
<h2 id=replicationcontrollerのデバッグ>ReplicationControllerのデバッグ</h2>
<p>ReplicationControllerはかなり明快です。Podを作成できるか、できないかのどちらかです。
Podを作成できない場合は、<a href=#Pod%E3%81%AE%E3%83%87%E3%83%90%E3%83%83%E3%82%B0>上述の手順</a>を参照してPodをデバッグしてください。</p>
<p><code>kubectl describe rc ${CONTROLLER_NAME}</code>を使用して、レプリケーションコントローラーに関連するイベントを調べることもできます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-ef360b1f8e65236251826db478cfcab3>10.3 - Pod障害の原因を特定する</h1>
<p>このページでは、コンテナ終了メッセージの読み書き方法を説明します。</p>
<p>終了メッセージは、致命的なイベントに関する情報を、ダッシュボードや監視ソフトウェアなどのツールで簡単に取得して表示できる場所にコンテナが書き込むための手段を提供します。 ほとんどの場合、終了メッセージに入力した情報も一般的な<a href=/docs/concepts/cluster-administration/logging/>Kubernetesログ</a>に書き込まれるはずです。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=終了メッセージの書き込みと読み取り>終了メッセージの書き込みと読み取り</h2>
<p>この課題では、1つのコンテナを実行するPodを作成します。
設定ファイルには、コンテナの開始時に実行されるコマンドを指定します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/debug/termination.yaml download=debug/termination.yaml><code>debug/termination.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('debug-termination-yaml')" title="Copy debug/termination.yaml to clipboard">
</img>
</div>
<div class=includecode id=debug-termination-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>termination-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>termination-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep 10 &amp;&amp; echo Sleep expired &gt; /dev/termination-log&#34;</span>]<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<ol>
<li>
<p>YAML設定ファイルに基づいてPodを作成します:</p>
<pre><code> kubectl apply -f https://k8s.io/examples/debug/termination.yaml
</code></pre>
<p>YAMLファイルの<code>command</code>フィールドと<code>args</code>フィールドで、コンテナが10秒間スリープしてから<code>/dev/termination-log</code>ファイルに「Sleep expired」と書いているのがわかります。コンテナが「Sleep expired」メッセージを書き込んだ後、コンテナは終了します。</p>
</li>
<li>
<p>Podに関する情報を表示します:</p>
<pre><code> kubectl get pod termination-demo
</code></pre>
<p>Podが実行されなくなるまで、上記のコマンドを繰り返します。</p>
</li>
<li>
<p>Podに関する詳細情報を表示します:</p>
<pre><code> kubectl get pod termination-demo --output=yaml
</code></pre>
<p>出力には「Sleep expired」メッセージが含まれています:</p>
<pre><code> apiVersion: v1
 kind: Pod
 ...
     lastState:
       terminated:
         containerID: ...
         exitCode: 0
         finishedAt: ...
         message: |
           Sleep expired
         ...
</code></pre>
</li>
<li>
<p>Goテンプレートを使用して、終了メッセージのみが含まれるように出力をフィルタリングします:</p>
<pre><code> kubectl get pod termination-demo -o go-template=&quot;{{range .status.containerStatuses}}{{.lastState.terminated.message}}{{end}}&quot;
</code></pre>
</li>
</ol>
<h2 id=終了メッセージのカスタマイズ>終了メッセージのカスタマイズ</h2>
<p>Kubernetesは、コンテナの<code>terminationMessagePath</code>フィールドで指定されている終了メッセージファイルから終了メッセージを取得します。デフォルト値は<code>/dev/termination-log</code>です。このフィールドをカスタマイズすることで、Kubernetesに別のファイルを使うように指示できます。Kubernetesは指定されたファイルの内容を使用して、成功と失敗の両方についてコンテナのステータスメッセージを入力します。</p>
<p>終了メッセージはアサーションエラーメッセージのように、最終状態を簡潔に示します。kubeletは4096バイトより長いメッセージは切り詰めます。全コンテナの合計メッセージの長さの上限は12キビバイトです。デフォルトの終了メッセージのパスは<code>/dev/termination-log</code>です。Pod起動後に終了メッセージのパスを設定することはできません。</p>
<p>次の例では、コンテナはKubernetesが取得するために終了メッセージを<code>/tmp/my-log</code>に書き込みます:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>msg-path-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>msg-path-demo-container<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>terminationMessagePath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp/my-log&#34;</span><span style=color:#bbb>
</span></code></pre></div><p>さらに、ユーザーは追加のカスタマイズをするためにContainerの<code>terminationMessagePolicy</code>フィールドを設定できます。このフィールドのデフォルト値は<code>File</code>です。これは、終了メッセージが終了メッセージファイルからのみ取得されることを意味します。<code>terminationMessagePolicy</code>を<code>FallbackToLogsOnError</code>に設定することで、終了メッセージファイルが空でコンテナがエラーで終了した場合に、コンテナログ出力の最後のチャンクを使用するようにKubernetesに指示できます。ログ出力は、2048バイトまたは80行のどちらか小さい方に制限されています。</p>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/reference/generated/kubernetes-api/v1.22/#container-v1-core>コンテナ</a>の<code>terminationMessagePath</code>フィールド参照</li>
<li><a href=/docs/concepts/cluster-administration/logging/>ログ取得</a>について</li>
<li><a href=https://golang.org/pkg/text/template/>Goテンプレート</a>について</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-f79645981e310858111bd5673614cab6>10.4 - Serviceのデバッグ</h1>
<p>新規にKubernetesをインストールした環境でかなり頻繁に発生する問題は、Serviceが適切に機能しないというものです。Deployment(または他のワークロードコントローラー)を通じてPodを実行し、サービスを作成したにもかかわらず、アクセスしようとしても応答がありません。何が問題になっているのかを理解するのに、このドキュメントがきっと役立つでしょう。</p>
<h2 id=pod内でコマンドを実行する>Pod内でコマンドを実行する</h2>
<p>ここでの多くのステップでは、クラスターで実行されているPodが見ているものを確認する必要があります。これを行う最も簡単な方法は、インタラクティブなalpineのPodを実行することです。</p>
<pre><code class=language-none data-lang=none>kubectl run -it --rm --restart=Never alpine --image=alpine sh
</code></pre><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> コマンドプロンプトが表示されない場合は、Enterキーを押してみてください。
</div>
<p>使用したい実行中のPodがすでにある場合は、以下のようにしてそのPod内でコマンドを実行できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> &lt;POD-NAME&gt; -c &lt;CONTAINER-NAME&gt; -- &lt;COMMAND&gt;
</code></pre></div><h2 id=セットアップ>セットアップ</h2>
<p>このドキュメントのウォークスルーのために、いくつかのPodを実行しましょう。おそらくあなた自身のServiceをデバッグしているため、あなた自身の詳細に置き換えることもできますし、これに沿って2番目のデータポイントを取得することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create deployment hostnames --image<span style=color:#666>=</span>k8s.gcr.io/serve_hostname
</code></pre></div><pre><code class=language-none data-lang=none>deployment.apps/hostnames created
</code></pre><p><code>kubectl</code>コマンドは作成、変更されたリソースのタイプと名前を出力するため、この後のコマンドで使用することもできます。</p>
<p>Deploymentを3つのレプリカにスケールさせてみましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl scale deployment hostnames --replicas<span style=color:#666>=</span><span style=color:#666>3</span>
</code></pre></div><pre><code class=language-none data-lang=none>deployment.apps/hostnames scaled
</code></pre><p>これは、次のYAMLでDeploymentを開始した場合と同じです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/serve_hostname<span style=color:#bbb>
</span></code></pre></div><p>"app"ラベルは<code>kubectl create deployment</code>によって、Deploymentの名前に自動的にセットされます。</p>
<p>Podが実行されていることを確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME                        READY     STATUS    RESTARTS   AGE
hostnames-632524106-bbpiw   1/1       Running   0          2m
hostnames-632524106-ly40y   1/1       Running   0          2m
hostnames-632524106-tlaok   1/1       Running   0          2m
</code></pre><p>Podが機能していることも確認できます。Pod IP アドレスリストを取得し、直接テストできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .items}}{{.status.podIP}}{{&#34;\n&#34;}}{{end}}&#39;</span>
</code></pre></div><pre><code class=language-none data-lang=none>10.244.0.5
10.244.0.6
10.244.0.7
</code></pre><p>このウォークスルーに使用されるサンプルコンテナは、ポート9376でHTTPを介して独自のホスト名を提供するだけですが、独自のアプリをデバッグする場合は、Podがリッスンしているポート番号を使用する必要があります。</p>
<p>Pod内から実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> ep in 10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376; <span style=color:#a2f;font-weight:700>do</span>
    wget -qO- <span style=color:#b8860b>$ep</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><p>次のように表示されます。</p>
<pre><code>hostnames-632524106-bbpiw
hostnames-632524106-ly40y
hostnames-632524106-tlaok
</code></pre><p>この時点で期待通りの応答が得られない場合、Podが正常でないか、想定しているポートでリッスンしていない可能性があります。なにが起きているかを確認するために<code>kubectl logs</code>が役立ちます。Podに直接に入りデバッグする場合は<code>kubectl exec</code>が必要になります。</p>
<p>これまでにすべての計画が完了していると想定すると、Serviceが機能しない理由を調査することができます。</p>
<h2 id=serviceは存在するか>Serviceは存在するか？</h2>
<p>賢明な読者は、Serviceをまだ実際に作成していないことにお気付きかと思いますが、これは意図的です。これは時々忘れられるステップであり、最初に確認すべきことです。</p>
<p>存在しないServiceにアクセスしようとするとどうなるでしょうか？このServiceを名前で利用する別のPodがあると仮定すると、次のような結果が得られます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>wget -O- hostnames
</code></pre></div><pre><code class=language-none data-lang=none>Resolving hostnames (hostnames)... failed: Name or service not known.
wget: unable to resolve host address 'hostnames'
</code></pre><p>最初に確認するのは、そのServiceが実際に存在するかどうかです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc hostnames
</code></pre></div><pre><code class=language-none data-lang=none>No resources found.
Error from server (NotFound): services &quot;hostnames&quot; not found
</code></pre><p>Serviceを作成しましょう。前と同様に、これはウォークスルー用です。ご自身のServiceの詳細を使用することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl expose deployment hostnames --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>9376</span>
</code></pre></div><pre><code class=language-none data-lang=none>service/hostnames exposed
</code></pre><p>そして、念のため内容を確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME        TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
hostnames   ClusterIP   10.0.1.175   &lt;none&gt;        80/TCP    5s
</code></pre><p>これで、Serviceが存在することがわかりました。</p>
<p>前と同様に、これは次のようなYAMLでServiceを開始した場合と同じです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>hostnames<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></code></pre></div><p>構成の全範囲をハイライトするため、ここで作成したServiceはPodとは異なるポート番号を使用します。多くの実際のServiceでは、これらのポートは同じになる場合があります。</p>
<h2 id=サービスはdns名によって機能しているか>サービスはDNS名によって機能しているか？</h2>
<p>クライアントがサービスを使用する最も一般的な方法の1つは、DNS名を使用することです。同じNamespaceのPodから次のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre><p>これが失敗した場合、おそらくPodとServiceが異なるNamespaceにあるため、ネームスペースで修飾された名前を試してください。(Podの中からもう一度)</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames.default
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre><p>これが機能する場合、クロスネームスペース名を使用するようにアプリケーションを調整するか、同じNamespaceでアプリとServiceを実行する必要があります。これでも失敗する場合は、完全修飾名を試してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default.svc.cluster.local
</code></pre></div><pre><code class=language-none data-lang=none>Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      hostnames.default.svc.cluster.local
Address 1: 10.0.1.175 hostnames.default.svc.cluster.local
</code></pre><p>ここでのサフィックス"default.svc.cluster.local"に注意してください。"default"は、操作しているNamespaceです。"svc"は、これがServiceであることを示します。"cluster.local"はクラスタードメインであり、あなたのクラスターでは異なる場合があります。</p>
<p>クラスター内のノードからも試すこともできます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> 10.0.0.10はクラスターのDNSサービスのIPであり、あなたのクラスターでは異なるかもしれません。
</div>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup hostnames.default.svc.cluster.local 10.0.0.10
</code></pre></div><pre><code class=language-none data-lang=none>Server:         10.0.0.10
Address:        10.0.0.10#53

Name:   hostnames.default.svc.cluster.local
Address: 10.0.1.175
</code></pre><p>完全修飾名では検索できるのに、相対名ではできない場合、Podの<code>/etc/resolv.conf</code>ファイルが正しいことを確認する必要があります。Pod内から実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>cat /etc/resolv.conf
</code></pre></div><p>次のように表示されます。</p>
<pre><code>nameserver 10.0.0.10
search default.svc.cluster.local svc.cluster.local cluster.local example.com
options ndots:5
</code></pre><p>nameserver行はクラスターのDNS Serviceを示さなければなりません。これは、<code>--cluster-dns</code>フラグで<code>kubelet</code>に渡されます。</p>
<p><code>search</code>行には、<code>Service</code>名を見つけるための適切なサフィックスを含める必要があります。この場合、ローカルの<code>Namespace</code>で<code>Service</code>を見つけるためのサフィックス(<code>default.svc.cluster.local</code>)、すべての<code>Namespaces</code>で<code>Service</code>を見つけるためのサフィックス(<code>svc.cluster.local</code>)、およびクラスターのサフィックス(<code>cluster.local</code>)です。インストール方法によっては、その後に追加のレコードがある場合があります(合計6つまで)。クラスターのサフィックスは、<code>--cluster-domain</code>フラグを使用して<code>kubelet</code>に渡されます。このドキュメントではそれが"cluster.local"であると仮定していますが、あなたのクラスターでは異なる場合があります。その場合は、上記のすべてのコマンドでクラスターのサフィックスを変更する必要があります。</p>
<p><code>options</code>行では、DNSクライアントライブラリーが検索パスをまったく考慮しないように<code>ndots</code>を十分に高く設定する必要があります。Kubernetesはデフォルトでこれを5に設定します。これは、生成されるすべてのDNS名をカバーするのに十分な大きさです。</p>
<h3 id=does-any-service-exist-in-dns>DNS名で機能するServiceはあるか？</h3>
<p>上記がまだ失敗する場合、DNSルックアップがServiceに対して機能していません。一歩離れて、他の何が機能していないかを確認しましょう。KubernetesマスターのServiceは常に機能するはずです。Pod内から実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>nslookup kubernetes.default
</code></pre></div><pre><code class=language-none data-lang=none>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      kubernetes.default
Address 1: 10.0.0.1 kubernetes.default.svc.cluster.local
</code></pre><p>これが失敗する場合は、このドキュメントの<a href=#is-the-kube-proxy-working>kube-proxy</a>セクションを参照するか、このドキュメントの先頭に戻って最初からやり直してください。ただし、あなた自身のServiceをデバッグするのではなく、DNSサービスをデバッグします。</p>
<h2 id=serviceはipでは機能するか>ServiceはIPでは機能するか？</h2>
<p>DNSサービスが正しく動作できると仮定すると、次にテストするのはIPによってServiceが動作しているかどうかです。上述の<code>kubectl get</code>で確認できるIPに、クラスター内のPodからアクセスします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#a2f;font-weight:700>$(</span>seq <span style=color:#666>1</span> 3<span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
    wget -qO- 10.0.1.175:80
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><p>次のように表示されます。</p>
<pre><code>hostnames-0uton
hostnames-bvc05
hostnames-yp2kp
</code></pre><p>Serviceが機能している場合は、正しい応答が得られるはずです。そうでない場合、おかしい可能性のあるものがいくつかあるため、続けましょう。</p>
<h2 id=serviceは正しく定義されているか>Serviceは正しく定義されているか？</h2>
<p>馬鹿げているように聞こえるかもしれませんが、Serviceが正しく定義されPodのポートとマッチすることを二度、三度と確認すべきです。Serviceを読み返して確認しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get service hostnames -o json
</code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>{
    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Service&#34;</span>,
    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>,
        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
        <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;428c8b6c-24bc-11e5-936d-42010af0a9bc&#34;</span>,
        <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>: <span style=color:#b44>&#34;347189&#34;</span>,
        <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>: <span style=color:#b44>&#34;2015-07-07T15:24:29Z&#34;</span>,
        <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;app&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>
        }
    },
    <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;ports&#34;</span>: [
            {
                <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>,
                <span style=color:green;font-weight:700>&#34;protocol&#34;</span>: <span style=color:#b44>&#34;TCP&#34;</span>,
                <span style=color:green;font-weight:700>&#34;port&#34;</span>: <span style=color:#666>80</span>,
                <span style=color:green;font-weight:700>&#34;targetPort&#34;</span>: <span style=color:#666>9376</span>,
                <span style=color:green;font-weight:700>&#34;nodePort&#34;</span>: <span style=color:#666>0</span>
            }
        ],
        <span style=color:green;font-weight:700>&#34;selector&#34;</span>: {
            <span style=color:green;font-weight:700>&#34;app&#34;</span>: <span style=color:#b44>&#34;hostnames&#34;</span>
        },
        <span style=color:green;font-weight:700>&#34;clusterIP&#34;</span>: <span style=color:#b44>&#34;10.0.1.175&#34;</span>,
        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;ClusterIP&#34;</span>,
        <span style=color:green;font-weight:700>&#34;sessionAffinity&#34;</span>: <span style=color:#b44>&#34;None&#34;</span>
    },
    <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
        <span style=color:green;font-weight:700>&#34;loadBalancer&#34;</span>: {}
    }
}
</code></pre></div><ul>
<li>アクセスしようとしているServiceポートは<code>spec.ports[]</code>のリストのなかに定義されていますか？</li>
<li><code>targetPort</code>はPodに対して適切ですか(いくつかのPodはServiceとは異なるポートを使用します)？</li>
<li><code>targetPort</code>を数値で定義しようとしている場合、それは数値(9376)、文字列"9376"のどちらですか？</li>
<li><code>targetPort</code>を名前で定義しようとしている場合、Podは同じ名前でポートを公開していますか？</li>
<li>ポートの<code>protocol</code>はPodに適切ですか？</li>
</ul>
<h2 id=serviceにendpointsがあるか>ServiceにEndpointsがあるか？</h2>
<p>ここまで来たということは、Serviceは正しく定義され、DNSによって名前解決できることが確認できているでしょう。ここでは、実行したPodがServiceによって実際に選択されていることを確認しましょう。</p>
<p>以前に、Podが実行されていることを確認しました。再確認しましょう。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>hostnames
</code></pre></div><pre><code class=language-none data-lang=none>NAME                        READY     STATUS    RESTARTS   AGE
hostnames-632524106-bbpiw   1/1       Running   0          1h
hostnames-632524106-ly40y   1/1       Running   0          1h
hostnames-632524106-tlaok   1/1       Running   0          1h
</code></pre><p><code>-l app=hostnames</code>引数はラベルセレクターで、ちょうど私たちの<code>Service</code>に定義されているものと同じです。</p>
<p>"AGE"列は、これらのPodが約1時間前のものであることを示しており、それらが正常に実行され、クラッシュしていないことを意味します。</p>
<p>"RESTARTS"列は、これらのポッドが頻繁にクラッシュしたり、再起動されていないことを示しています。頻繁に再起動すると、断続的な接続性の問題が発生する可能性があります。再起動回数が多い場合は、<a href=/ja/docs/tasks/debug-application-cluster/debug-pod-replication-controller/#pod%E3%81%AE%E3%83%87%E3%83%90%E3%83%83%E3%82%B0>ポッドをデバッグする</a>を参照してください。</p>
<p>Kubernetesシステム内には、すべてのServiceのセレクターを評価し、結果をEndpointsオブジェクトに保存するコントロールループがあります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get endpoints hostnames

NAME        ENDPOINTS
hostnames   10.244.0.5:9376,10.244.0.6:9376,10.244.0.7:9376
</code></pre></div><p>これにより、EndpointsコントローラーがServiceの正しいPodを見つけていることを確認できます。<code>ENDPOINTS</code>列が<code>&lt;none></code>の場合、Serviceの<code>spec.selector</code>フィールドが実際にPodの<code>metadata.labels</code>値を選択していることを確認する必要があります。よくある間違いは、タイプミスやその他のエラー、たとえばDeployment作成にも<code>kubectl run</code>が使われた1.18以前のバージョンのように、Serviceが<code>app=hostnames</code>を選択しているのにDeploymentが<code>run=hostnames</code>を指定していることです。</p>
<h2 id=podは機能しているか>Podは機能しているか？</h2>
<p>この時点で、Serviceが存在し、Podを選択していることがわかります。このウォークスルーの最初に、Pod自体を確認しました。Podが実際に機能していることを確認しましょう。Serviceメカニズムをバイパスして、上記EndpointsにリストされているPodに直接アクセスすることができます。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> これらのコマンドは、Serviceポート(80)ではなく、Podポート(9376)を使用します。
</div>
<p>Pod内から実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> ep in 10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376; <span style=color:#a2f;font-weight:700>do</span>
    wget -qO- <span style=color:#b8860b>$ep</span>
<span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><p>次のように表示されます。</p>
<pre><code>hostnames-632524106-bbpiw
hostnames-632524106-ly40y
hostnames-632524106-tlaok
</code></pre><p>Endpointsリスト内の各Podは、それぞれの自身のホスト名を返すはずです。そうならない(または、あなた自身のPodの正しい振る舞いにならない)場合は、そこで何が起こっているのかを調査する必要があります。</p>
<h2 id=is-the-kube-proxy-working>kube-proxyは機能しているか？</h2>
<p>ここに到達したのなら、Serviceは実行され、Endpointsがあり、Podが実際にサービスを提供しています。この時点で、Serviceのプロキシーメカニズム全体が疑わしいです。ひとつひとつ確認しましょう。</p>
<p>Serviceのデフォルト実装、およびほとんどのクラスターで使用されるものは、kube-proxyです。kube-proxyはそれぞれのノードで実行され、Serviceの抽象化を提供するための小さなメカニズムセットの1つを構成するプログラムです。クラスターがkube-proxyを使用しない場合、以下のセクションは適用されず、使用しているServiceの実装を調査する必要があります。</p>
<h3 id=kube-proxyは実行されているか>kube-proxyは実行されているか？</h3>
<p><code>kube-proxy</code>がノード上で実行されていることを確認しましょう。ノードで実行されていれば、以下のような結果が得られるはずです。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps auxw | grep kube-proxy
</code></pre></div><pre><code class=language-none data-lang=none> root  4194  0.4  0.1 101864 17696 ?    Sl Jul04  25:43 /usr/local/bin/kube-proxy --master=https://kubernetes-master --kubeconfig=/var/lib/kube-proxy/kubeconfig --v=2
</code></pre><p>次に、マスターとの接続など、明らかな失敗をしていないことを確認します。これを行うには、ログを確認する必要があります。ログへのアクセス方法は、ノードのOSに依存します。一部のOSでは/var/log/kube-proxy.logのようなファイルですが、他のOSでは<code>journalctl</code>を使用してログにアクセスします。次のように表示されます。</p>
<pre><code class=language-none data-lang=none>I1027 22:14:53.995134    5063 server.go:200] Running in resource-only container &quot;/kube-proxy&quot;
I1027 22:14:53.998163    5063 server.go:247] Using iptables Proxier.
I1027 22:14:53.999055    5063 server.go:255] Tearing down userspace rules. Errors here are acceptable.
I1027 22:14:54.038140    5063 proxier.go:352] Setting endpoints for &quot;kube-system/kube-dns:dns-tcp&quot; to [10.244.1.3:53]
I1027 22:14:54.038164    5063 proxier.go:352] Setting endpoints for &quot;kube-system/kube-dns:dns&quot; to [10.244.1.3:53]
I1027 22:14:54.038209    5063 proxier.go:352] Setting endpoints for &quot;default/kubernetes:https&quot; to [10.240.0.2:443]
I1027 22:14:54.038238    5063 proxier.go:429] Not syncing iptables until Services and Endpoints have been received from master
I1027 22:14:54.040048    5063 proxier.go:294] Adding new service &quot;default/kubernetes:https&quot; at 10.0.0.1:443/TCP
I1027 22:14:54.040154    5063 proxier.go:294] Adding new service &quot;kube-system/kube-dns:dns&quot; at 10.0.0.10:53/UDP
I1027 22:14:54.040223    5063 proxier.go:294] Adding new service &quot;kube-system/kube-dns:dns-tcp&quot; at 10.0.0.10:53/TCP
</code></pre><p>マスターに接続できないことに関するエラーメッセージが表示された場合、ノードの設定とインストール手順をダブルチェックする必要があります。</p>
<p><code>kube-proxy</code>が正しく実行できない理由の可能性の1つは、必須の<code>conntrack</code>バイナリが見つからないことです。これは、例えばKubernetesをスクラッチからインストールするなど、クラスターのインストール方法に依存して、一部のLinuxシステムで発生する場合があります。これが該当する場合は、<code>conntrack</code>パッケージを手動でインストール(例: Ubuntuでは<code>sudo apt install conntrack</code>)する必要があり、その後に再試行する必要があります。</p>
<p>kube-proxyは、いくつかのモードのいずれかで実行できます。上記のログの<code>Using iptables Proxier</code>という行は、kube-proxyが「iptables」モードで実行されていることを示しています。最も一般的な他のモードは「ipvs」です。古い「ユーザースペース」モードは、主にこれらに置き換えられました。</p>
<h4 id=iptables-mode>Iptables mode</h4>
<p>「iptables」モードでは、ノードに次のようなものが表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>iptables-save | grep hostnames
</code></pre></div><pre><code class=language-none data-lang=none>-A KUBE-SEP-57KPRZ3JQVENLNBR -s 10.244.3.6/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-57KPRZ3JQVENLNBR -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.3.6:9376
-A KUBE-SEP-WNBA2IHDGP2BOBGZ -s 10.244.1.7/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-WNBA2IHDGP2BOBGZ -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.1.7:9376
-A KUBE-SEP-X3P2623AGDH6CDF3 -s 10.244.2.3/32 -m comment --comment &quot;default/hostnames:&quot; -j MARK --set-xmark 0x00004000/0x00004000
-A KUBE-SEP-X3P2623AGDH6CDF3 -p tcp -m comment --comment &quot;default/hostnames:&quot; -m tcp -j DNAT --to-destination 10.244.2.3:9376
-A KUBE-SERVICES -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames: cluster IP&quot; -m tcp --dport 80 -j KUBE-SVC-NWV5X2332I4OT4T3
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.33332999982 -j KUBE-SEP-WNBA2IHDGP2BOBGZ
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-X3P2623AGDH6CDF3
-A KUBE-SVC-NWV5X2332I4OT4T3 -m comment --comment &quot;default/hostnames:&quot; -j KUBE-SEP-57KPRZ3JQVENLNBR
</code></pre><p>各サービスのポートごとに、<code>KUBE-SERVICES</code>に1つのルールと1つの<code>KUBE-SVC- &lt;hash></code>チェーンが必要です。Podエンドポイントごとに、その<code>KUBE-SVC- &lt;hash></code>に少数のルールがあり、少数のルールが含まれる1つの<code>KUBE-SEP- &lt;hash></code>チェーンがあるはずです。正確なルールは、正確な構成(NodePortとLoadBalancerを含む)に基づいて異なります。</p>
<h4 id=ipvs-mode>IPVS mode</h4>
<p>「ipvs」モードでは、ノードに次のようなものが表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ipvsadm -ln
</code></pre></div><pre><code class=language-none data-lang=none>Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
...
TCP  10.0.1.175:80 rr
  -&gt; 10.244.0.5:9376               Masq    1      0          0
  -&gt; 10.244.0.6:9376               Masq    1      0          0
  -&gt; 10.244.0.7:9376               Masq    1      0          0
...
</code></pre><p>各Serviceの各ポートに加えて、NodePort、External IP、およびLoad Balancer IPに対して、kube-proxyは仮想サーバーを作成します。Pod endpointごとに、対応する実サーバーが作成されます。この例では、サービスhostnames(<code>10.0.1.175:80</code>)は3つのendpoints(<code>10.244.0.5:9376</code>、<code>10.244.0.6:9376</code>、<code>10.244.0.7:9376</code>)を持っています。</p>
<p>IPVSプロキシーは、各Serviceアドレス(Cluster IP、External IP、NodePort IP、Load Balancer IPなど)毎の仮想サーバーと、Serviceのエンドポイントが存在する場合に対応する実サーバーを作成します。この例では、hostnames Service(<code>10.0.1.175:80</code>)は3つのエンドポイント(<code>10.244.0.5:9376</code>、<code>10.244.0.6:9376</code>、<code>10.244.0.7:9376</code>)を持ち、上と似た結果が得られるはずです。</p>
<h4 id=userspace-mode>Userspace mode</h4>
<p>まれに、「userspace」モードを使用している場合があります。</p>
<p>ノードから実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>iptables-save | grep hostnames
</code></pre></div><pre><code class=language-none data-lang=none>-A KUBE-PORTALS-CONTAINER -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames:default&quot; -m tcp --dport 80 -j REDIRECT --to-ports 48577
-A KUBE-PORTALS-HOST -d 10.0.1.175/32 -p tcp -m comment --comment &quot;default/hostnames:default&quot; -m tcp --dport 80 -j DNAT --to-destination 10.240.115.247:48577
</code></pre><p>サービスの各ポートには2つのルールが必要です(この例では1つだけ)-「KUBE-PORTALS-CONTAINER」と「KUBE-PORTALS-HOST」です。</p>
<p>「userspace」モードを使用する必要はほとんどないので、ここでこれ以上時間を費やすことはありません。</p>
<h3 id=kube-proxyはプロキシしているか>kube-proxyはプロキシしているか？</h3>
<p>上記のいずれかが発生したと想定して、いずれかのノードからIPでサービスにアクセスをしています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl 10.0.1.175:80
</code></pre></div><pre><code class=language-none data-lang=none>hostnames-632524106-bbpiw
</code></pre><p>もしこれが失敗し、あなたがuserspaceプロキシーを使用している場合、プロキシーへの直接アクセスを試してみてください。もしiptablesプロキシーを使用している場合、このセクションはスキップしてください。</p>
<p>上記の<code>iptables-save</code>の出力を振り返り、<code>kube-proxy</code>がServiceに使用しているポート番号を抽出します。上記の例では"48577"です。このポートに接続してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>curl localhost:48577
</code></pre></div><pre><code class=language-none data-lang=none>hostnames-632524106-tlaok
</code></pre><p>もしまだ失敗する場合は、<code>kube-proxy</code>ログで次のような特定の行を探してください。</p>
<pre><code class=language-none data-lang=none>Setting endpoints for default/hostnames:default to [10.244.0.5:9376 10.244.0.6:9376 10.244.0.7:9376]
</code></pre><p>これらが表示されない場合は、<code>-v</code>フラグを4に設定して<code>kube-proxy</code>を再起動してから、再度ログを確認してください。</p>
<h3 id=a-pod-fails-to-reach-itself-via-the-service-ip>エッジケース: PodがService IP経由で自身に到達できない</h3>
<p>これはありそうに聞こえないかもしれませんが、実際には起こり、動作するはずです。これはネットワークが"hairpin"トラフィック用に適切に設定されていない場合、通常は<code>kube-proxy</code>が<code>iptables</code>モードで実行され、Podがブリッジネットワークに接続されている場合に発生します。<code>Kubelet</code>は<code>hairpin-mode</code><a href=/docs/reference/command-line-tools-reference/kubelet/>フラグ</a>を公開します。これにより、Serviceのエンドポイントが自身のServiceのVIPにアクセスしようとした場合に、自身への負荷分散を可能にします。<code>hairpin-mode</code>フラグは<code>hairpin-veth</code>または<code>promiscuous-bridge</code>に設定する必要があります。</p>
<p>この問題をトラブルシューティングする一般的な手順は次のとおりです。</p>
<ul>
<li><code>hairpin-mode</code>が<code>hairpin-veth</code>または<code>promiscuous-bridge</code>に設定されていることを確認します。次のような表示がされるはずです。この例では、<code>hairpin-mode</code>は<code>promiscuous-bridge</code>に設定されています。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ps auxw | grep kubelet
</code></pre></div><pre><code class=language-none data-lang=none>root      3392  1.1  0.8 186804 65208 ?        Sl   00:51  11:11 /usr/local/bin/kubelet --enable-debugging-handlers=true --config=/etc/kubernetes/manifests --allow-privileged=True --v=4 --cluster-dns=10.0.0.10 --cluster-domain=cluster.local --configure-cbr0=true --cgroup-root=/ --system-cgroups=/system --hairpin-mode=promiscuous-bridge --runtime-cgroups=/docker-daemon --kubelet-cgroups=/kubelet --babysit-daemons=true --max-pods=110 --serialize-image-pulls=false --outofdisk-transition-frequency=0
</code></pre><ul>
<li>実際に使われている<code>hairpin-mode</code>を確認します。これを行うには、kubeletログを確認する必要があります。ログへのアクセス方法は、ノードのOSによって異なります。一部のOSでは/var/log/kubelet.logなどのファイルですが、他のOSでは<code>journalctl</code>を使用してログにアクセスします。互換性のために、実際に使われている<code>hairpin-mode</code>が<code>--hairpin-mode</code>フラグと一致しない場合があることに注意してください。kubelet.logにキーワード<code>hairpin</code>を含むログ行があるかどうかを確認してください。実際に使われている<code>hairpin-mode</code>を示す以下のようなログ行があるはずです。</li>
</ul>
<pre><code class=language-none data-lang=none>I0629 00:51:43.648698    3252 kubelet.go:380] Hairpin mode set to &quot;promiscuous-bridge&quot;
</code></pre><ul>
<li>実際に使われている<code>hairpin-mode</code>が<code>hairpin-veth</code>の場合、<code>Kubelet</code>にノードの<code>/sys</code>で操作する権限があることを確認します。すべてが正常に機能している場合、次のようなものが表示されます。</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f;font-weight:700>for</span> intf in /sys/devices/virtual/net/cbr0/brif/*; <span style=color:#a2f;font-weight:700>do</span> cat <span style=color:#b8860b>$intf</span>/hairpin_mode; <span style=color:#a2f;font-weight:700>done</span>
</code></pre></div><pre><code class=language-none data-lang=none>1
1
1
1
</code></pre><p>実際に使われている<code>hairpin-mode</code>が<code>promiscuous-bridge</code>の場合、<code>Kubelet</code>にノード上のLinuxブリッジを操作する権限があることを確認してください。<code>cbr0</code>ブリッジが使用され適切に構成されている場合、以下が表示されます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>ifconfig cbr0 |grep PROMISC
</code></pre></div><pre><code class=language-none data-lang=none>UP BROADCAST RUNNING PROMISC MULTICAST  MTU:1460  Metric:1
</code></pre><ul>
<li>上記のいずれも解決しない場合、助けを求めてください。</li>
</ul>
<h2 id=助けを求める>助けを求める</h2>
<p>ここまでたどり着いたということは、とてもおかしなことが起こっています。Serviceは実行中で、Endpointsがあり、Podは実際にサービスを提供しています。DNSは動作していて、<code>kube-proxy</code>も誤動作していないようです。それでも、あなたのServiceは機能していません。おそらく私たちにお知らせ頂いた方がよいでしょう。調査をお手伝いします！</p>
<p><a href=/docs/tasks/debug-application-cluster/troubleshooting/#slack>Slack</a>、<a href=https://discuss.kubernetes.io>Forum</a>または<a href=https://github.com/kubernetes/kubernetes>GitHub</a>でお問い合わせください。</p>
<h2 id=次の項目>次の項目</h2>
<p>詳細については、<a href=/docs/tasks/debug-application-cluster/troubleshooting/>トラブルシューティングドキュメント</a>をご覧ください。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a070b1250ee142402d492b505a56ca83>10.5 - StatefulSetのデバッグ</h1>
<p>このタスクでは、StatefulSetをデバッグする方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>Kubernetesクラスターが必要です。また、kubectlコマンドラインツールがクラスターと通信するように設定されている必要があります。</li>
<li>調べたいStatefulSetを実行しておきましょう。</li>
</ul>
<h2 id=statefulsetのデバッグ>StatefulSetのデバッグ</h2>
<p>StatefulSetに属し、ラベル<code>app=myapp</code>が設定されているすべてのPodを一覧表示するには、以下のコマンドを利用できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>myapp
</code></pre></div><p>Podが長期間<code>Unknown</code>または<code>Terminating</code>の状態になっていることがわかった場合は、それらを処理する方法について<a href=/ja/docs/tasks/run-application/delete-stateful-set/>StatefulSetの削除</a>タスクを参照してください。
<a href=/docs/tasks/debug-application-cluster/debug-pod-replication-controller/>Podのデバッグ</a>ガイドを使用して、StatefulSet内の個々のPodをデバッグできます。</p>
<h2 id=次の項目>次の項目</h2>
<p><a href=/ja/docs/tasks/debug-application-cluster/debug-init-containers/>Initコンテナのデバッグ</a>の詳細</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-9713ac27b6d9e3034033200d968221f2>10.6 - 実行中のコンテナへのシェルを取得する</h1>
<p>このページは<code>kubectl exec</code>を使用して実行中のコンテナへのシェルを取得する方法を説明します。</p>
<h2 id=始める前に>始める前に</h2>
<p><p>Kubernetesクラスターが必要、かつそのクラスターと通信するためにkubectlコマンドラインツールが設定されている必要があります。
このチュートリアルは、コントロールプレーンのホストとして動作していない少なくとも2つのノードを持つクラスターで実行することをおすすめします。
まだクラスターがない場合、<a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>minikube</a>を使って作成するか、
以下のいずれかのKubernetesプレイグラウンドも使用できます:</p>
<ul>
<li><a href=https://www.katacoda.com/courses/kubernetes/playground>Katacoda</a></li>
<li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li>
</ul>
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
</p>
<h2 id=コンテナへのシェルの取得>コンテナへのシェルの取得</h2>
<p>このエクササイズでは、1つのコンテナを持つPodを作成します。
コンテナはnginxのイメージを実行します。以下がそのPodの設定ファイルです:</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/application/shell-demo.yaml download=application/shell-demo.yaml><code>application/shell-demo.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('application-shell-demo-yaml')" title="Copy application/shell-demo.yaml to clipboard">
</img>
</div>
<div class=includecode id=application-shell-demo-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell-demo<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Podを作成します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/application/shell-demo.yaml
</code></pre></div><p>コンテナが実行中であることを確認します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod shell-demo
</code></pre></div><p>実行中のコンテナへのシェルを取得します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> --stdin --tty shell-demo -- /bin/bash
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ダブルダッシュの記号 <code>--</code> はコマンドに渡す引数とkubectlの引数を分離します。
</div>
<p>シェル内で、ルートディレクトリーのファイル一覧を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドをコンテナ内で実行します</span>
ls /
</code></pre></div><p>シェル内で、他のコマンドを試しましょう。以下がいくつかの例です:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># これらのサンプルコマンドをコンテナ内で実行することができます</span>
ls /
cat /proc/mounts
cat /proc/1/maps
apt-get update
apt-get install -y tcpdump
tcpdump
apt-get install -y lsof
lsof
apt-get install -y procps
ps aux
ps aux | grep nginx
</code></pre></div><h2 id=nginxのルートページへの書き込み>nginxのルートページへの書き込み</h2>
<p>Podの設定ファイルを再度確認します。Podは<code>emptyDir</code>ボリュームを持ち、
コンテナは<code>/usr/share/nginx/html</code>ボリュームをマウントします。</p>
<p>シェル内で、<code>/usr/share/nginx/html</code>ディレクトリに<code>index.html</code>を作成します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># このコマンドをコンテナ内で実行します</span>
<span style=color:#a2f>echo</span> <span style=color:#b44>&#39;Hello shell demo&#39;</span> &gt; /usr/share/nginx/html/index.html
</code></pre></div><p>シェル内で、nginxサーバーにGETリクエストを送信します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># これらのコマンドをコンテナ内のシェルで実行します</span>
apt-get update
apt-get install curl
curl http://localhost/
</code></pre></div><p>出力に<code>index.html</code>ファイルに書き込んだ文字列が表示されます:</p>
<pre><code>Hello shell demo
</code></pre><p>シェルを終了する場合、<code>exit</code>を入力します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#a2f>exit</span> <span style=color:#080;font-style:italic># コンテナ内のシェルを終了する</span>
</code></pre></div><h2 id=コンテナ内での各コマンドの実行>コンテナ内での各コマンドの実行</h2>
<p>シェルではない通常のコマンドウインドウ内で、実行中のコンテナの環境変数の一覧を表示します:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> shell-demo env
</code></pre></div><p>他のコマンドを試します。以下がいくつかの例です:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> shell-demo -- ps aux
kubectl <span style=color:#a2f>exec</span> shell-demo -- ls /
kubectl <span style=color:#a2f>exec</span> shell-demo -- cat /proc/1/mounts
</code></pre></div>
<h2 id=podが1つ以上のコンテナを持つ場合にシェルを開く>Podが1つ以上のコンテナを持つ場合にシェルを開く</h2>
<p>Podが1つ以上のコンテナを持つ場合、<code>--container</code>か<code>-c</code>を使用して、<code>kubectl exec</code>コマンド内でコンテナを指定します。
例えば、my-podという名前のPodがあり、そのPodが <em>main-app</em> と <em>helper-app</em> という2つのコンテナを持つとします。
以下のコマンドは <em>main-app</em> のコンテナへのシェルを開きます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -i -t my-pod --container main-app -- /bin/bash
</code></pre></div><div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> ショートオプションの<code>-i</code>と<code>-t</code>は、ロングオプションの<code>--stdin</code>と<code>--tty</code>と同様です。
</div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>について読む</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d3c88a8663f58e9ec0bed73faff5b670>11 - TLS</h1>
<div class=lead>Transport Layer Security(TLS)を使用して、クラスター内のトラフィックを保護する方法について理解します。</div>
</div>
<div class=td-content>
<h1 id=pg-1272b18ac0c008f6ffc2c62a29fa929f>11.1 - Kubeletの証明書のローテーションを設定する</h1>
<p>このページでは、kubeletの証明書のローテーションを設定する方法を説明します。</p>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.8 [beta]</code>
</div>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>Kubernetesはバージョン1.8.0以降である必要があります。</li>
</ul>
<h2 id=概要>概要</h2>
<p>kubeletは、Kubernetes APIへの認証のために証明書を使用します。デフォルトでは、証明書は1年間の有効期限付きで発行されるため、頻繁に更新する必要はありません。</p>
<p>Kubernetes 1.8にはベータ機能の<a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet certificate rotation</a>が含まれているため、現在の証明書の有効期限が近づいたときに自動的に新しい鍵を生成して、Kubernetes APIに新しい証明書をリクエストできます。新しい証明書が利用できるようになると、Kubernetes APIへの接続の認証に利用されます。</p>
<h2 id=クライアント証明書のローテーションを有効にする>クライアント証明書のローテーションを有効にする</h2>
<p><code>kubelet</code>プロセスは<code>--rotate-certificates</code>という引数を受け付けます。この引数によって、現在使用している証明書の有効期限が近づいたときに、kubeletが自動的に新しい証明書をリクエストするかどうかを制御できます。証明書のローテーションはベータ機能であるため、<code>--feature-gates=RotateKubeletClientCertificate=true</code>を使用してフィーチャーフラグを有効にする必要もあります。</p>
<p><code>kube-controller-manager</code>プロセスは、<code>--experimental-cluster-signing-duration</code>という引数を受け付け、この引数で証明書が発行される期間を制御できます。</p>
<h2 id=証明書のローテーションの設定を理解する>証明書のローテーションの設定を理解する</h2>
<p>kubeletが起動すると、ブートストラップが設定されている場合(<code>--bootstrap-kubeconfig</code>フラグを使用した場合)、初期証明書を使用してKubernetes APIに接続して、証明書署名リクエスト(certificate signing request、CSR)を発行します。証明書署名リクエストのステータスは、次のコマンドで表示できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>kubectl get csr
</code></pre></div><p>ノード上のkubeletから発行された証明書署名リクエストは、初めは<code>Pending</code>状態です。証明書署名リクエストが特定の条件を満たすと、コントローラーマネージャーに自動的に承認され、<code>Approved</code>状態になります。次に、コントローラーマネージャーは<code>--experimental-cluster-signing-duration</code>パラメーターで指定された有効期限で発行された証明書に署名を行い、署名された証明書が証明書署名リクエストに添付されます。</p>
<p>kubeletは署名された証明書をKubernetes APIから取得し、ディスク上の<code>--cert-dir</code>で指定された場所に書き込みます。その後、kubeletは新しい証明書を使用してKubernetes APIに接続するようになります。</p>
<p>署名された証明書の有効期限が近づくと、kubeletはKubernetes APIを使用して新しい証明書署名リクエストを自動的に発行します。再び、コントローラーマネージャーは証明書のリクエストを自動的に承認し、署名された証明書を証明書署名リクエストに添付します。kubeletは新しい署名された証明書をKubernetes APIから取得してディスクに書き込みます。その後、kubeletは既存のコネクションを更新して、新しい証明書でKubernetes APIに再接続します。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5266308e17490aeee8b018316bf47e03>12 - サービスカタログ</h1>
<div class=lead>サービスカタログ拡張APIをインストールする</div>
</div>
<div class=td-content>
<h1 id=pg-f741b6fc36e27a6f79c1c3d02a40d8f9>12.1 - Helmを使用したサービスカタログのインストール</h1>
<p><p>サービスカタログは kubernetesクラスターで稼働するアプリケーションが、クラウドプロバイダーによって提供されるデータストアサービスのように、外部のマネージドソフトウェアを容易に使えるようにするための拡張APIです。</p></p>
<p>サービスカタログを使用することで<a class=glossary-tooltip title="An endpoint for a set of Managed Services offered and maintained by a third-party." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-service-broker" target=_blank aria-label=サービスブローカー>サービスブローカー</a>が提供する<a class=glossary-tooltip title="A software offering maintained by a third-party provider." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-managed-service" target=_blank aria-label=マネージドサービス>マネージドサービス</a>を、それらのサービスがどのように作成されるか、また管理されるかについての知識を無しに、一覧表示したり、プロビジョニングや使用をすることができます。</p>
<p><a href=https://helm.sh/>Helm</a>を使用してKubernetesクラスターにサービスカタログをインストールします。手順の最新情報は<a href=https://github.com/kubernetes-sigs/service-catalog/blob/master/docs/install.md>kubernetes-sigs/service-catalog</a>リポジトリーを参照してください。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li><a href=/docs/concepts/extend-kubernetes/service-catalog/>サービスカタログ</a>の基本概念を理解してください。</li>
<li>サービスカタログを使用するには、Kubernetesクラスターのバージョンが1.7以降である必要があります。</li>
<li>KubernetesクラスターのクラスターDNSを有効化する必要があります。
<ul>
<li>クラウド上のKubernetesクラスター、または<a class=glossary-tooltip title="A tool for running Kubernetes locally." data-toggle=tooltip data-placement=top href=/docs/setup/learning-environment/minikube/ target=_blank aria-label=Minikube>Minikube</a>を使用している場合、クラスターDNSはすでに有効化されています。</li>
<li><code>hack/local-up-cluster.sh</code>を使用している場合は、環境変数<code>KUBE_ENABLE_CLUSTER_DNS</code>が設定されていることを確認し、インストールスクリプトを実行してください。</li>
</ul>
</li>
<li><a href=/ja/docs/tasks/tools/install-kubectl/>kubectlのインストールおよびセットアップ</a>を参考に、v1.7以降のkubectlをインストールし、設定を行ってください。</li>
<li>v2.7.0以降の<a href=https://helm.sh/>Helm</a>をインストールしてください。
<ul>
<li><a href=https://helm.sh/docs/intro/install/>Helm install instructions</a>を参考にしてください。</li>
<li>上記のバージョンのHelmをすでにインストールしている場合は、<code>helm init</code>を実行し、HelmのサーバーサイドコンポーネントであるTillerをインストールしてください。</li>
</ul>
</li>
</ul>
<h2 id=helmリポジトリーにサービスカタログを追加>Helmリポジトリーにサービスカタログを追加</h2>
<p>Helmをインストールし、以下のコマンドを実行することでローカルマシンに<em>service-catalog</em>のHelmリポジトリーを追加します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm repo add svc-cat https://kubernetes-sigs.github.io/service-catalog
</code></pre></div><p>以下のコマンドを実行し、インストールに成功していることを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm search service-catalog
</code></pre></div><p>インストールが成功していれば、出力は以下のようになります:</p>
<pre><code>NAME                	CHART VERSION	APP VERSION	DESCRIPTION                                                 
svc-cat/catalog     	0.2.1        	           	service-catalog API server and controller-manager helm chart
svc-cat/catalog-v0.2	0.2.2        	           	service-catalog API server and controller-manager helm chart
</code></pre><h2 id=rbacの有効化>RBACの有効化</h2>
<p>KubernetesクラスターのRBACを有効化することで、Tiller Podに<code>cluster-admin</code>アクセスを持たせます。</p>
<p>v0.25以前のMinikubeを使用している場合は、明示的にRBACを有効化して起動する必要があります:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube start --extra-config<span style=color:#666>=</span>apiserver.Authorization.Mode<span style=color:#666>=</span>RBAC
</code></pre></div><p>v0.26以降のMinikubeを使用している場合は、以下のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>minikube start
</code></pre></div><p>v0.26以降のMinikubeを使用している場合、<code>--extra-config</code>を指定しないでください。
このフラグは--extra-config=apiserver.authorization-modeを指定するものに変更されており、現在MinikubeではデフォルトでRBACが有効化されています。
古いフラグを指定すると、スタートコマンドが応答しなくなることがあります。</p>
<p><code>hack/local-up-cluster.sh</code>を使用している場合、環境変数<code>AUTHORIZATION_MODE</code>を以下の値に設定してください:</p>
<pre><code>AUTHORIZATION_MODE=Node,RBAC hack/local-up-cluster.sh -O
</code></pre><p><code>helm init</code>は、デフォルトで<code>kube-system</code>のnamespaceにTiller Podをインストールし、Tillerは<code>default</code>のServiceAccountを使用するように設定されています。</p>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <code>helm init</code>を実行する際に<code>--tiller-namespace</code>または<code>--service-account</code>のフラグを使用する場合、以下のコマンドの<code>--serviceaccount</code>フラグには適切なnamespaceとServiceAccountを指定する必要があります。
</div>
<p>Tillerに<code>cluster-admin</code>アクセスを設定する場合:</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create clusterrolebinding tiller-cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span><span style=color:#b62;font-weight:700></span>    --serviceaccount<span style=color:#666>=</span>kube-system:default
</code></pre></div><h2 id=kubernetesクラスターにサービスカタログをインストール>Kubernetesクラスターにサービスカタログをインストール</h2>
<p>以下のコマンドを使用して、Helmリポジトリーのrootからサービスカタログをインストールします:</p>
<ul class="nav nav-tabs" id=helm-versions role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#helm-versions-0 role=tab aria-controls=helm-versions-0 aria-selected=true>Helm バージョン3</a></li>
<li class=nav-item><a data-toggle=tab class=nav-link href=#helm-versions-1 role=tab aria-controls=helm-versions-1>Helm バージョン2</a></li></ul>
<div class=tab-content id=helm-versions><div id=helm-versions-0 class="tab-pane show active" role=tabpanel aria-labelledby=helm-versions-0>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm install catalog svc-cat/catalog --namespace catalog
</code></pre></div></div>
<div id=helm-versions-1 class=tab-pane role=tabpanel aria-labelledby=helm-versions-1>
<p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>helm install svc-cat/catalog --name catalog --namespace catalog
</code></pre></div></div></div>
<h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=https://github.com/openservicebrokerapi/servicebroker/blob/master/gettingStarted.md#sample-service-brokers>sample service brokers</a></li>
<li><a href=https://github.com/kubernetes-sigs/service-catalog>kubernetes-sigs/service-catalog</a></li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-d85a30635b5c3578487b9f6f214c07ea>12.2 - SCを使用したサービスカタログのインストール</h1>
<p><p>サービスカタログは kubernetesクラスターで稼働するアプリケーションが、クラウドプロバイダーによって提供されるデータストアサービスのように、外部のマネージドソフトウェアを容易に使えるようにするための拡張APIです。</p></p>
<p>サービスカタログを使用することで<a class=glossary-tooltip title="An endpoint for a set of Managed Services offered and maintained by a third-party." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-service-broker" target=_blank aria-label=サービスブローカー>サービスブローカー</a>が提供する<a class=glossary-tooltip title="A software offering maintained by a third-party provider." data-toggle=tooltip data-placement=top href="/ja/docs/reference/glossary/?all=true#term-managed-service" target=_blank aria-label=マネージドサービス>マネージドサービス</a>を、それらのサービスがどのように作成されるか、また管理されるかについての知識を無しに、一覧表示したり、プロビジョニングや使用をすることができます。</p>
<p>GCPの<a href=https://github.com/GoogleCloudPlatform/k8s-service-catalog#installation>Service Catalog Installer</a>ツールを使うと、Kubernetesクラスター上にサービスカタログを簡単にインストール・アンインストールして、Google Cloudのプロジェクトに紐付けることもできます。</p>
<p>サービスカタログ自体は、Google Cloudだけではなく、どのような種類のマネージドサービスでも動作します。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>
<p><a href=/docs/concepts/extend-kubernetes/service-catalog/>サービスカタログ</a>の基本概念を理解してください。</p>
</li>
<li>
<p><a href=https://golang.org/dl/>Go 1.6+</a>をインストールして、<code>GOPATH</code>を設定してください。</p>
</li>
<li>
<p>SSLに関するファイルを生成するために必要な<a href=https://github.com/cloudflare/cfssl>cfssl</a>ツールをインストールしてください。</p>
</li>
<li>
<p>サービスカタログを使用するには、Kubernetesクラスターのバージョンが1.7以降である必要があります。</p>
</li>
<li>
<p><a href=/ja/docs/tasks/tools/install-kubectl/>kubectlのインストールおよびセットアップ</a>を参考に、v1.7以降のkubectlをインストールし、設定を行ってください。</p>
</li>
<li>
<p>サービスカタログをインストールするためには、kubectlのユーザーが<em>cluster-admin</em>ロールにバインドされている必要があります。正しくバインドされていることを確認するには、次のコマンドを実行します。</p>
<pre><code>  kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=&lt;user-name&gt;
</code></pre>
</li>
</ul>
<h2 id=ローカル環境に-sc-をインストールする>ローカル環境に<code>sc</code>をインストールする</h2>
<p>インストーラーは、ローカルのコンピューター上で<code>sc</code>と呼ばれるCLIツールとして実行します。</p>
<p><code>go get</code>を使用してインストールします。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>go get github.com/GoogleCloudPlatform/k8s-service-catalog/installer/cmd/sc
</code></pre></div><p>これで、<code>sc</code>が<code>GOPATH/bin</code>ディレクトリー内にインストールされたはずです。</p>
<h2 id=kubernetesクラスターにサービスカタログをインストールする>Kubernetesクラスターにサービスカタログをインストールする</h2>
<p>まず、すべての依存関係がインストールされていることを確認します。次のコマンドを実行してください。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sc check
</code></pre></div><p>チェックが成功したら、次のように表示されるはずです。</p>
<pre><code>Dependency check passed. You are good to go.
</code></pre><p>次に、バックアップに使用したい<code>storageclass</code>を指定して、installコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sc install --etcd-backup-storageclass <span style=color:#b44>&#34;standard&#34;</span>
</code></pre></div><h2 id=サービスカタログのアンインストール>サービスカタログのアンインストール</h2>
<p>Kubernetesクラスターからサービスカタログをアンインストールしたい場合は、<code>sc</code>ツールを使って次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>sc uninstall
</code></pre></div><h2 id=次の項目>次の項目</h2>
<ul>
<li><a href=https://github.com/openservicebrokerapi/servicebroker/blob/master/gettingStarted.md#sample-service-brokers>サービスブローカーのサンプル</a>を読む。</li>
<li><a href=https://github.com/kubernetes-incubator/service-catalog>kubernetes-incubator/service-catalog</a>プロジェクトを探索する。</li>
</ul>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-a701e71f3b32dae474c63ae4c596c856>13 - ネットワーク</h1>
<div class=lead>クラスターのネットワークの設定方法を学びます。</div>
</div>
<div class=td-content>
<h1 id=pg-2edb5b02ea1e646c333c9fe4d5f02ff1>13.1 - HostAliasesを使用してPodの/etc/hostsにエントリーを追加する</h1>
<p>Podの<code>/etc/hosts</code>ファイルにエントリーを追加すると、DNSやその他の選択肢を利用できない場合に、Podレベルでホスト名の名前解決を上書きできるようになります。このようなカスタムエントリーは、PodSpecのHostAliasesフィールドに追加できます。</p>
<p>HostAliasesを使用せずにファイルを修正することはおすすめできません。このファイルはkubeletが管理しており、Podの作成や再起動時に上書きされる可能性があるためです。</p>
<h2 id=デフォルトのhostsファイルの内容>デフォルトのhostsファイルの内容</h2>
<p>Nginx Podを実行すると、Pod IPが割り当てられます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl run nginx --image nginx
</code></pre></div><pre><code>pod/nginx created
</code></pre><p>Pod IPを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods --output<span style=color:#666>=</span>wide
</code></pre></div><pre><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre><p>hostsファイルの内容は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> nginx -- cat /etc/hosts
</code></pre></div><pre><code># Kubernetes-managed hosts file.
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
fe00::0	ip6-mcastprefix
fe00::1	ip6-allnodes
fe00::2	ip6-allrouters
10.200.0.4	nginx
</code></pre><p>デフォルトでは、<code>hosts</code>ファイルには、<code>localhost</code>やPod自身のホスト名などのIPv4とIPv6のボイラープレートだけが含まれています。</p>
<h2 id=追加エントリーをhostaliasesに追加する>追加エントリーをhostAliasesに追加する</h2>
<p>デフォルトのボイラープレートに加えて、<code>hosts</code>ファイルに追加エントリーを追加できます。たとえば、<code>foo.local</code>と<code>bar.local</code>を<code>127.0.0.1</code>に、<code>foo.remote</code>と<code>bar.remote</code>を<code>10.1.2.3</code>にそれぞれ解決するためには、PodのHostAliasesを<code>.spec.hostAliases</code>以下に設定します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/hostaliases-pod.yaml download=service/networking/hostaliases-pod.yaml><code>service/networking/hostaliases-pod.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-hostaliases-pod-yaml')" title="Copy service/networking/hostaliases-pod.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-hostaliases-pod-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostaliases-pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostAliases</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;127.0.0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostnames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;foo.local&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;bar.local&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostnames</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;foo.remote&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;bar.remote&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cat-hosts<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- cat<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/hosts&#34;</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>この設定を使用したPodを開始するには、次のコマンドを実行します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl apply -f https://k8s.io/examples/service/networking/hostaliases-pod.yaml
</code></pre></div><pre><code>pod/hostaliases-pod created
</code></pre><p>Podの詳細情報を表示して、IPv4アドレスと状態を確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pod --output<span style=color:#666>=</span>wide
</code></pre></div><pre><code>NAME                           READY     STATUS      RESTARTS   AGE       IP              NODE
hostaliases-pod                0/1       Completed   0          6s        10.200.0.5      worker0
</code></pre><p><code>hosts</code>ファイルの内容は次のようになります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl logs hostaliases-pod
</code></pre></div><pre><code># Kubernetes-managed hosts file.
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
fe00::0	ip6-mcastprefix
fe00::1	ip6-allnodes
fe00::2	ip6-allrouters
10.200.0.5	hostaliases-pod

# Entries added by HostAliases.
127.0.0.1	foo.local	bar.local
10.1.2.3	foo.remote	bar.remote
</code></pre><p>ファイルの最後に追加エントリーが指定されています。</p>
<h2 id=why-does-kubelet-manage-the-hosts-file>kubeletがhostsファイルを管理するのはなぜですか？</h2>
<p>kubeletがPodの各コンテナの<code>hosts</code>ファイルを<a href=https://github.com/kubernetes/kubernetes/issues/14633>管理する</a>のは、コンテナ起動後にDockerがファイルを<a href=https://github.com/moby/moby/issues/17190>編集する</a>のを防ぐためです。</p>
<div class="alert alert-warning caution callout" role=alert>
<strong>注意:</strong> <p>コンテナ内部でhostsファイルを手動で変更するのは控えてください。</p>
<p>hostsファイルを手動で変更すると、コンテナが終了したときに変更が失われてしまいます。</p>
</div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-eebac062766222247063d6513f95c7b2>13.2 - IPv4/IPv6デュアルスタックの検証</h1>
<p>このドキュメントでは、IPv4/IPv6デュアルスタックが有効化されたKubernetesクラスターを検証する方法について共有します。</p>
<h2 id=始める前に>始める前に</h2>
<ul>
<li>プロバイダーがデュアルスタックのネットワークをサポートしていること (クラウドプロバイダーか、ルーティングできるIPv4/IPv6ネットワークインターフェイスを持つKubernetesノードが提供できること)</li>
<li>(KubenetやCalicoなど)デュアルスタックをサポートする<a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>ネットワークプラグイン</a></li>
<li><a href=/ja/docs/concepts/services-networking/dual-stack/>デュアルスタックを有効化</a>したクラスター</li>
</ul>
作業するKubernetesサーバーは次のバージョン以降のものである必要があります: v1.20.
バージョンを確認するには次のコマンドを実行してください: <code>kubectl version</code>.
<h2 id=アドレスの検証>アドレスの検証</h2>
<h3 id=ノードアドレスの検証>ノードアドレスの検証</h3>
<p>各デュアルスタックのノードは、1つのIPv4ブロックと1つのIPv6ブロックを割り当てる必要があります。IPv4/IPv6のPodアドレスの範囲が設定されていることを検証するには、次のコマンドを実行します。例の中のノード名は、自分のクラスターの有効なデュアルスタックのノードの名前に置換してください。この例では、ノードの名前は<code>k8s-linuxpool1-34450317-0</code>になっています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes k8s-linuxpool1-34450317-0 -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .spec.podCIDRs}}{{printf &#34;%s\n&#34; .}}{{end}}&#39;</span>
</code></pre></div><pre><code>10.244.1.0/24
a00:100::/24
</code></pre><p>IPv4ブロックとIPv6ブロックがそれぞれ1つずつ割り当てられているはずです。</p>
<p>ノードが検出されたIPv4とIPv6のインターフェイスを持っていることを検証します。ノード名は自分のクラスター内の有効なノード名に置換してください。この例では、ノード名は<code>k8s-linuxpool1-34450317-0</code>になっています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get nodes k8s-linuxpool1-34450317-0 -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .status.addresses}}{{printf &#34;%s: %s\n&#34; .type .address}}{{end}}&#39;</span>
</code></pre></div><pre><code>Hostname: k8s-linuxpool1-34450317-0
InternalIP: 10.240.0.5
InternalIP: 2001:1234:5678:9abc::5
</code></pre><h3 id=podアドレスの検証>Podアドレスの検証</h3>
<p>PodにIPv4とIPv6のアドレスが割り当てられていることを検証します。Podの名前は自分のクラスター内の有効なPodの名前と置換してください。この例では、Podの名前は<code>pod01</code>になっています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get pods pod01 -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range .status.podIPs}}{{printf &#34;%s\n&#34; .ip}}{{end}}&#39;</span>
</code></pre></div><pre><code>10.244.1.4
a00:100::4
</code></pre><p>Downward APIを使用して、<code>status.podIPs</code>のfieldPath経由でPod IPを検証することもできます。次のスニペットは、Pod IPを<code>MY_POD_IPS</code>という名前の環境変数経由でコンテナ内に公開する方法を示しています。</p>
<pre><code>        env:
        - name: MY_POD_IPS
          valueFrom:
            fieldRef:
              fieldPath: status.podIPs
</code></pre><p>次のコマンドを実行すると、<code>MY_POD_IPS</code>環境変数の値をコンテナ内から表示できます。値はカンマ区切りのリストであり、PodのIPv4とIPv6のアドレスに対応しています。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it pod01 -- <span style=color:#a2f>set</span> | grep MY_POD_IPS
</code></pre></div><pre><code>MY_POD_IPS=10.244.1.4,a00:100::4
</code></pre><p>PodのIPアドレスは、コンテナ内の<code>/etc/hosts</code>にも書き込まれます。次のコマンドは、デュアルスタックのPod上で<code>/etc/hosts</code>に対してcatコマンドを実行します。出力を見ると、Pod用のIPv4およびIPv6のIPアドレスの両方が確認できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl <span style=color:#a2f>exec</span> -it pod01 -- cat /etc/hosts
</code></pre></div><pre><code># Kubernetes-managed hosts file.
127.0.0.1    localhost
::1    localhost ip6-localhost ip6-loopback
fe00::0    ip6-localnet
fe00::0    ip6-mcastprefix
fe00::1    ip6-allnodes
fe00::2    ip6-allrouters
10.244.1.4    pod01
a00:100::4    pod01
</code></pre><h2 id=serviceの検証>Serviceの検証</h2>
<p><code>.spec.isFamilyPolicy</code>を明示的に定義していない、以下のようなServiceを作成してみます。Kubernetesは最初に設定した<code>service-cluster-ip-range</code>の範囲からServiceにcluster IPを割り当てて、<code>.spec.ipFamilyPolicy</code>を<code>SingleStack</code>に設定します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/dual-stack-default-svc.yaml download=service/networking/dual-stack-default-svc.yaml><code>service/networking/dual-stack-default-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-default-svc-yaml')" title="Copy service/networking/dual-stack-default-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-default-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p><code>kubectl</code>を使ってServiceのYAMLを表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-service -o yaml
</code></pre></div><p>Serviceの<code>.spec.ipFamilyPolicy</code>は<code>SingleStack</code>に設定され、<code>.spec.clusterIP</code>にはkube-controller-manager上の<code>--service-cluster-ip-range</code>フラグで最初に設定した範囲から1つのIPv4アドレスが設定されているのがわかります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.217.164</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIPs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:#666>10.0.217.164</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv4<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>SingleStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sessionAffinity</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ClusterIP<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div><p><code>.spec.ipFamilies</code>内の配列の1番目の要素に<code>IPv6</code>を明示的に指定した、次のようなServiceを作成してみます。Kubernetesは<code>service-cluster-ip-range</code>で設定したIPv6の範囲からcluster IPを割り当てて、<code>.spec.ipFamilyPolicy</code>を<code>SingleStack</code>に設定します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/dual-stack-ipfamilies-ipv6.yaml download=service/networking/dual-stack-ipfamilies-ipv6.yaml><code>service/networking/dual-stack-ipfamilies-ipv6.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-ipfamilies-ipv6-yaml')" title="Copy service/networking/dual-stack-ipfamilies-ipv6.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-ipfamilies-ipv6-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv6<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p><code>kubectl</code>を使ってServiceのYAMLを表示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc my-service -o yaml
</code></pre></div><p>Serviceの<code>.spec.ipFamilyPolicy</code>は<code>SingleStack</code>に設定され、<code>.spec.clusterIP</code>には、kube-controller-manager上の<code>--service-cluster-ip-range</code>フラグで指定された最初の設定範囲から1つのIPv6アドレスが設定されているのがわかります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>fd00::5118<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIPs</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- fd00::5118<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv6<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>SingleStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sessionAffinity</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ClusterIP<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></code></pre></div><p><code>.spec.ipFamiliePolicy</code>に<code>PreferDualStack</code>を明示的に指定した、次のようなServiceを作成してみます。Kubernetesは(クラスターでデュアルスタックを有効化しているため)IPv4およびIPv6のアドレスの両方を割り当て、<code>.spec.ClusterIPs</code>のリストから、<code>.spec.ipFamilies</code>配列の最初の要素のアドレスファミリーに基づいた<code>.spec.ClusterIP</code>を設定します。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/dual-stack-preferred-svc.yaml download=service/networking/dual-stack-preferred-svc.yaml><code>service/networking/dual-stack-preferred-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-preferred-svc-yaml')" title="Copy service/networking/dual-stack-preferred-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-preferred-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>PreferDualStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<div class="alert alert-info note callout" role=alert>
<strong>備考:</strong> <p><code>kubectl get svc</code>コマンドは、<code>CLUSTER-IP</code>フィールドにプライマリーのIPだけしか表示しません。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>MyApp

NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>   AGE
my-service   ClusterIP   10.0.216.242   &lt;none&gt;        80/TCP    5s
</code></pre></div>
</div>
<p><code>kubectl describe</code>を使用して、ServiceがIPv4およびIPv6アドレスのブロックからcluster IPを割り当てられていることを検証します。その後、ServiceにIPアドレスとポートを使用してアクセスできることを検証することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe svc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>MyApp
</code></pre></div><pre><code>Name:              my-service
Namespace:         default
Labels:            app=MyApp
Annotations:       &lt;none&gt;
Selector:          app=MyApp
Type:              ClusterIP
IP Family Policy:  PreferDualStack
IP Families:       IPv4,IPv6
IP:                10.0.216.242
IPs:               10.0.216.242,fd00::af55
Port:              &lt;unset&gt;  80/TCP
TargetPort:        9376/TCP
Endpoints:         &lt;none&gt;
Session Affinity:  None
Events:            &lt;none&gt;
</code></pre><h3 id=デュアルスタックのloadbalancer-serviceを作成する>デュアルスタックのLoadBalancer Serviceを作成する</h3>
<p>クラウドプロバイダーがIPv6を有効化した外部ロードバランサーのプロビジョニングをサポートする場合、<code>.spec.ipFamilyPolicy</code>に<code>PreferDualStack</code>を指定し、<code>.spec.ipFamilies</code>の最初の要素を<code>IPv6</code>にして、<code>type</code>フィールドに<code>LoadBalancer</code>を指定したServiceを作成できます。</p>
<div class=highlight>
<div class=copy-code-icon style=text-align:right>
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ja/examples/service/networking/dual-stack-prefer-ipv6-lb-svc.yaml download=service/networking/dual-stack-prefer-ipv6-lb-svc.yaml><code>service/networking/dual-stack-prefer-ipv6-lb-svc.yaml</code>
</a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick="copyCode('service-networking-dual-stack-prefer-ipv6-lb-svc-yaml')" title="Copy service/networking/dual-stack-prefer-ipv6-lb-svc.yaml to clipboard">
</img>
</div>
<div class=includecode id=service-networking-dual-stack-prefer-ipv6-lb-svc-yaml>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilyPolicy</span>:<span style=color:#bbb> </span>PreferDualStack<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamilies</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- IPv6<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></code></pre></div>
</div>
</div>
<p>Serviceを確認します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl get svc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>MyApp
</code></pre></div><p>ServiceがIPv6アドレスブロックから<code>CLUSTER-IP</code>のアドレスと<code>EXTERNAL-IP</code>を割り当てられていることを検証します。その後、IPとポートを用いたServiceへのアクセスを検証することもできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>NAME         TYPE           CLUSTER-IP   EXTERNAL-IP        PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>        AGE
my-service   LoadBalancer   fd00::7ebc   2603:1030:805::5   80:30790/TCP   35s
</code></pre></div>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-5ab7bc7f14942c5c4b29d19f4a87271c>14 - GPUのスケジューリング</h1>
<div class=lead>クラスター内のノードのリソースとしてGPUを設定してスケジューリングします</div>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code>
</div>
<p>Kubernetesには、複数ノードに搭載されたAMDおよびNVIDIAのGPU(graphical processing unit)を管理するための<strong>実験的な</strong>サポートが含まれています。</p>
<p>このページでは、異なるバージョンのKubernetesを横断してGPUを使用する方法と、現時点での制限について説明します。</p>
<h2 id=デバイスプラグインを使用する>デバイスプラグインを使用する</h2>
<p>Kubernetesでは、GPUなどの特別なハードウェアの機能にPodがアクセスできるようにするために、<a class=glossary-tooltip title="Software extensions to let Pods access devices that need vendor-specific initialization or setup" data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/ target=_blank aria-label=デバイスプラグイン>デバイスプラグイン</a>が実装されています。</p>
<p>管理者として、ノード上に対応するハードウェアベンダーのGPUドライバーをインストールして、以下のような対応するGPUベンダーのデバイスプラグインを実行する必要があります。</p>
<ul>
<li><a href=#deploying-amd-gpu-device-plugin>AMD</a></li>
<li><a href=#deploying-nvidia-gpu-device-plugin>NVIDIA</a></li>
</ul>
<p>上記の条件を満たしていれば、Kubernetesは<code>amd.com/gpu</code>または<code>nvidia.com/gpu</code>をスケジュール可能なリソースとして公開します。</p>
<p>これらのGPUをコンテナから使用するには、<code>cpu</code>や<code>memory</code>をリクエストするのと同じように<code>&lt;vendor>.com/gpu</code>というリソースをリクエストするだけです。ただし、GPUを使用するときにはリソースのリクエストの指定方法にいくつか制限があります。</p>
<ul>
<li>GPUは<code>limits</code>セクションでのみ指定されることが想定されている。この制限は、次のことを意味します。
<ul>
<li>Kubernetesはデフォルトでlimitの値をrequestの値として使用するため、GPUの<code>requests</code>を省略して<code>limits</code>を指定できる。</li>
<li>GPUを<code>limits</code>と<code>requests</code>の両方で指定できるが、これら2つの値は等しくなければならない。</li>
<li>GPUの<code>limits</code>を省略して<code>requests</code>だけを指定することはできない。</li>
</ul>
</li>
<li>コンテナ(およびPod)はGPUを共有しない。GPUのオーバーコミットは起こらない。</li>
<li>各コンテナは1つ以上のGPUをリクエストできる。1つのGPUの一部だけをリクエストすることはできない。</li>
</ul>
<p>以下に例を示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># https://github.com/kubernetes/kubernetes/blob/v1.7.11/test/images/nvidia-cuda/Dockerfile</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 1 GPUをリクエストしています</span><span style=color:#bbb>
</span></code></pre></div><h3 id=deploying-amd-gpu-device-plugin>AMDのGPUデバイスプラグインをデプロイする</h3>
<p><a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>AMD公式のGPUデバイスプラグイン</a>には以下の要件があります。</p>
<ul>
<li>Kubernetesのノードに、AMDのGPUのLinuxドライバーがあらかじめインストール済みでなければならない。</li>
</ul>
<p>クラスターが起動して上記の要件が満たされれば、以下のコマンドを実行することでAMDのデバイスプラグインをデプロイできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://raw.githubusercontent.com/RadeonOpenCompute/k8s-device-plugin/v1.10/k8s-ds-amdgpu-dp.yaml
</code></pre></div><p>このサードパーティーのデバイスプラグインに関する問題は、<a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>RadeonOpenCompute/k8s-device-plugin</a>で報告できます。</p>
<h3 id=deploying-nvidia-gpu-device-plugin>NVIDIAのGPUデバイスプラグインをデプロイする</h3>
<p>現在、NVIDIAのGPU向けのデバイスプラグインの実装は2種類あります。</p>
<h4 id=nvidia公式のgpuデバイスプラグイン>NVIDIA公式のGPUデバイスプラグイン</h4>
<p><a href=https://github.com/NVIDIA/k8s-device-plugin>NVIDIA公式のGPUデバイスプラグイン</a>には以下の要件があります。</p>
<ul>
<li>Kubernetesのノードに、NVIDIAのドライバーがあらかじめインストール済みでなければならない。</li>
<li>Kubernetesのノードに、<a href=https://github.com/NVIDIA/nvidia-docker>nvidia-docker 2.0</a>があらかじめインストール済みでなければならない。</li>
<li>KubeletはコンテナランタイムにDockerを使用しなければならない。</li>
<li>runcの代わりにDockerの<a href=https://github.com/NVIDIA/k8s-device-plugin#preparing-your-gpu-nodes>デフォルトランタイム</a>として、<code>nvidia-container-runtime</code>を設定しなければならない。</li>
<li>NVIDIAのドライバーのバージョンが次の条件を満たさなければならない ~= 384.81。</li>
</ul>
<p>クラスターが起動して上記の要件が満たされれば、以下のコマンドを実行することでNVIDIAのデバイスプラグインがデプロイできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl create -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/1.0.0-beta4/nvidia-device-plugin.yml
</code></pre></div><p>このサードパーティーのデバイスプラグインに関する問題は、<a href=https://github.com/NVIDIA/k8s-device-plugin>NVIDIA/k8s-device-plugin</a>で報告できます。</p>
<h4 id=gceで使用されるnvidiaのgpuデバイスプラグイン>GCEで使用されるNVIDIAのGPUデバイスプラグイン</h4>
<p><a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators/tree/master/cmd/nvidia_gpu>GCEで使用されるNVIDIAのGPUデバイスプラグイン</a>は、nvidia-dockerを必要としないため、KubernetesのContainer Runtime Interface(CRI)と互換性のある任意のコンテナランタイムで動作するはずです。このデバイスプラグインは<a href=https://cloud.google.com/container-optimized-os/>Container-Optimized OS</a>でテストされていて、1.9以降ではUbuntu向けの実験的なコードも含まれています。</p>
<p>以下のコマンドを実行すると、NVIDIAのドライバーとデバイスプラグインをインストールできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># NVIDIAドライバーをContainer-Optimized OSにインストールする</span>
kubectl create -f https://raw.githubusercontent.com/GoogleCloudPlatform/container-engine-accelerators/stable/daemonset.yaml

<span style=color:#080;font-style:italic># NVIDIAドライバーをUbuntuにインストールする(実験的)</span>
kubectl create -f https://raw.githubusercontent.com/GoogleCloudPlatform/container-engine-accelerators/stable/nvidia-driver-installer/ubuntu/daemonset.yaml

<span style=color:#080;font-style:italic># デバイスプラグインをインストールする</span>
kubectl create -f https://raw.githubusercontent.com/kubernetes/kubernetes/release-1.14/cluster/addons/device-plugins/nvidia-gpu/daemonset.yaml
</code></pre></div><p>このサードパーティーのデバイスプラグインの使用やデプロイに関する問題は、<a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators>GoogleCloudPlatform/container-engine-accelerators</a>で報告できます。</p>
<p>Googleは、GKE上でNVIDIAのGPUを使用するための<a href=https://cloud.google.com/kubernetes-engine/docs/how-to/gpus>手順</a>も公開しています。</p>
<h2 id=異なる種類のgpuを搭載するクラスター>異なる種類のGPUを搭載するクラスター</h2>
<p>クラスター上の別のノードに異なる種類のGPUが搭載されている場合、<a href=/docs/tasks/configure-pod-container/assign-pods-nodes/>NodeラベルとNodeセレクター</a>を使用することで、Podを適切なノードにスケジューリングできます。</p>
<p>以下に例を示します。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#080;font-style:italic># アクセラレーターを搭載したノードにラベルを付けます。</span>
kubectl label nodes &lt;node-with-k80&gt; <span style=color:#b8860b>accelerator</span><span style=color:#666>=</span>nvidia-tesla-k80
kubectl label nodes &lt;node-with-p100&gt; <span style=color:#b8860b>accelerator</span><span style=color:#666>=</span>nvidia-tesla-p100
</code></pre></div><h2 id=node-labeller>自動的なNodeラベルの付加</h2>
<p>AMDのGPUデバイスを使用している場合、<a href=https://github.com/RadeonOpenCompute/k8s-device-plugin/tree/master/cmd/k8s-node-labeller>Node Labeller</a>をデプロイできます。Node Labellerは<a class=glossary-tooltip title=クラスターの状態をAPIサーバーから取得、見張る制御ループで、現在の状態を望ましい状態に移行するように更新します。 data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=コントローラー>コントローラー</a>の1種で、GPUデバイスのプロパティを持つノードに自動的にラベルを付けてくれます。</p>
<p>現在は、このコントローラーは以下のプロパティに基づいてラベルを追加できます。</p>
<ul>
<li>デバイスID(-device-id)</li>
<li>VRAMのサイズ(-vram)</li>
<li>SIMDの数(-simd-count)</li>
<li>Compute Unitの数(-cu-count)</li>
<li>ファームウェアとフィーチャーのバージョン(-firmware)</li>
<li>2文字の頭字語で表されたGPUファミリー(-family)
<ul>
<li>SI - Southern Islands</li>
<li>CI - Sea Islands</li>
<li>KV - Kaveri</li>
<li>VI - Volcanic Islands</li>
<li>CZ - Carrizo</li>
<li>AI - Arctic Islands</li>
<li>RV - Raven</li>
</ul>
</li>
</ul>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kubectl describe node cluster-node-23
</code></pre></div><pre><code>    Name:               cluster-node-23
    Roles:              &lt;none&gt;
    Labels:             beta.amd.com/gpu.cu-count.64=1
                        beta.amd.com/gpu.device-id.6860=1
                        beta.amd.com/gpu.family.AI=1
                        beta.amd.com/gpu.simd-count.256=1
                        beta.amd.com/gpu.vram.16G=1
                        beta.kubernetes.io/arch=amd64
                        beta.kubernetes.io/os=linux
                        kubernetes.io/hostname=cluster-node-23
    Annotations:        kubeadm.alpha.kubernetes.io/cri-socket: /var/run/dockershim.sock
                        node.alpha.kubernetes.io/ttl: 0
    …
</code></pre><p>Node Labellerを使用すると、GPUの種類をPodのspec内で指定できます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-vector-add<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># https://github.com/kubernetes/kubernetes/blob/v1.7.11/test/images/nvidia-cuda/Dockerfile</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb> </span><span style=color:#080;font-style:italic># または nvidia-tesla-k80 など</span><span style=color:#bbb>
</span></code></pre></div><p>これにより、指定した種類のGPUを搭載したノードにPodがスケジューリングされることを保証できます。</p>
</div>
<div class=td-content style=page-break-before:always>
<h1 id=pg-fdfb2a2cba62a1e624897eaebac0168e>15 - huge pageを管理する</h1>
<div class=lead>クラスター内のスケジュール可能なリソースとしてhuge pageの設定と管理を行います。</div>
<div style=margin-top:10px;margin-bottom:10px>
<b>FEATURE STATE:</b> <code>Kubernetes v1.22 [stable]</code>
</div>
<p>Kubernetesでは、事前割り当てされたhuge pageをPod内のアプリケーションに割り当てたり利用したりすることをサポートしています。このページでは、ユーザーがhuge pageを利用できるようにする方法について説明します。</p>
<h2 id=始める前に>始める前に</h2>
<ol>
<li>Kubernetesのノードがhuge pageのキャパシティを報告するためには、ノード上でhuge pageを事前割り当てしておく必要があります。1つのノードでは複数のサイズのhuge pageが事前割り当てできます。</li>
</ol>
<p>ノードは、すべてのhuge pageリソースを、スケジュール可能なリソースとして自動的に探索・報告してくれます。</p>
<h2 id=api>API</h2>
<p>huge pageはコンテナレベルのリソース要求で<code>hugepages-&lt;size></code>という名前のリソースを指定することで利用できます。ここで、<code>&lt;size></code>は、特定のノード上でサポートされている整数値を使った最も小さなバイナリ表記です。たとえば、ノードが2048KiBと1048576KiBのページサイズをサポートしている場合、ノードはスケジュール可能なリソースとして、<code>hugepages-2Mi</code>と<code>hugepages-1Gi</code>の2つのリソースを公開します。CPUやメモリとは違い、huge pageはオーバーコミットをサポートしません。huge pageリソースをリクエストするときには、メモリやCPUリソースを同時にリクエストしなければならないことに注意してください。</p>
<p>1つのPodのspec内に書くことで、Podから複数のサイズのhuge pageを利用することもできます。その場合、すべてのボリュームマウントで<code>medium: HugePages-&lt;hugepagesize></code>という表記を使う必要があります。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>huge-pages-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:latest<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- inf<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/hugepages-2Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-2mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/hugepages-1Gi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-1gi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hugepages-2Mi</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hugepages-1Gi</span>:<span style=color:#bbb> </span>2Gi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-2mi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>medium</span>:<span style=color:#bbb> </span>HugePages-2Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage-1gi<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>medium</span>:<span style=color:#bbb> </span>HugePages-1Gi<span style=color:#bbb>
</span></code></pre></div><p>Podで1種類のサイズのhuge pageをリクエストするときだけは、<code>medium: HugePages</code>という表記を使うこともできます。</p>
<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>huge-pages-example<span style=color:#bbb>
</span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:latest<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- sleep<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- inf<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/hugepages<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hugepages-2Mi</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hugepage<span style=color:#bbb>
</span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb>
</span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>medium</span>:<span style=color:#bbb> </span>HugePages<span style=color:#bbb>
</span></code></pre></div><ul>
<li>huge pageのrequestsはlimitsと等しくなければなりません。limitsを指定した場合にはこれがデフォルトですが、requestsを指定しなかった場合にはデフォルトではありません。</li>
<li>huge pageはコンテナのスコープで隔離されるため、各コンテナにはそれぞれのcgroupサンドボックスの中でcontainer specでリクエストされた通りのlimitが設定されます。</li>
<li>huge pageベースのEmptyDirボリュームは、Podがリクエストしたよりも大きなサイズのページメモリーを使用できません。</li>
<li><code>shmget()</code>に<code>SHM_HUGETLB</code>を指定して取得したhuge pageを使用するアプリケーションは、<code>/proc/sys/vm/hugetlb_shm_group</code>に一致する補助グループ(supplemental group)を使用して実行する必要があります。</li>
<li>namespace内のhuge pageの使用量は、ResourceQuotaに対して<code>cpu</code>や<code>memory</code>のような他の計算リソースと同じように<code>hugepages-&lt;size></code>というトークンを使用することで制御できます。</li>
<li>複数のサイズのhuge pageのサポートはフィーチャーゲートによる設定が必要です。<a class=glossary-tooltip title=クラスター内の各ノードで実行されるエージェントです。各コンテナがPodで実行されていることを保証します。 data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>と<a class=glossary-tooltip title="Kubernetes APIを提供するコントロールプレーンのコンポーネントです。" data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a>上で、<code>HugePageStorageMediumSize</code><a href=/ja/docs/reference/command-line-tools-reference/feature-gates/>フィーチャーゲート</a>を使用すると有効にできます(<code>--feature-gates=HugePageStorageMediumSize=true</code>)。</li>
</ul>
</div>
</main>
</div>
</div>
<footer class=d-print-none>
<div class=footer__links>
<nav>
<a class=text-white href=/ja/docs/home/>ホーム</a>
<a class=text-white href=/ja/training/>トレーニング</a>
<a class=text-white href=/ja/partners/>パートナー</a>
<a class=text-white href=/ja/community/>コミュニティ</a>
<a class=text-white href=/ja/case-studies/>ケーススタディ</a>
</nav>
</div>
<div class=container-fluid>
<div class=row>
<div class="col-6 col-sm-2 text-xs-center order-sm-2">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list">
<a class=text-white target=_blank href=https://discuss.kubernetes.io>
<i class="fa fa-envelope"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter>
<a class=text-white target=_blank href=https://twitter.com/kubernetesio>
<i class="fab fa-twitter"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar>
<a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io">
<i class="fas fa-calendar-alt"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube>
<a class=text-white target=_blank href=https://youtube.com/kubernetescommunity>
<i class="fab fa-youtube"></i>
</a>
</li>
</ul>
</div>
<div class="col-6 col-sm-2 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub>
<a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes>
<i class="fab fa-github"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack>
<a class=text-white target=_blank href=https://slack.k8s.io>
<i class="fab fa-slack"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute>
<a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide>
<i class="fas fa-edit"></i>
</a>
</li>
<li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow">
<a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes>
<i class="fab fa-stack-overflow"></i>
</a>
</li>
</ul>
</div>
<div class="col-12 col-sm-8 text-center order-sm-2">
<small class=text-white>&copy; 2023 The Kubernetes Authors | Documentation Distributed under <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small>
<br>
<small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small>
<br>
<small class=text-white>ICP license: 京ICP备17074266号-3</small>
</div>
</div>
</div>
</footer>
</div>
<script src=/js/popper-1.14.3.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script>
<script src=/js/bootstrap-4.3.1.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=/js/main.min.40616251a9b6e4b689e7769be0340661efa4d7ebb73f957404e963e135b4ed52.js integrity="sha256-QGFiUam25LaJ53ab4DQGYe+k1+u3P5V0BOlj4TW07VI=" crossorigin=anonymous></script>
</body>
</html>